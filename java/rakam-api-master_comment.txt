/*
//www.apache.org/licenses/LICENSE-2.0
/*
//don't do any progress, unless asked
//set the timestamp to the file date.
//if (and only if) the use file time option is set, then
//the saved file now has its timestamp set to that of the
//downloaded file
// set up the URL connection
// modify the headers
// NB: things like user authentication could go in here too.
// connect to the remote site (may take some time)
// First check on a 301 / 302 (moved) response (HTTP only)
// next test for a 304 result (HTTP only)
// not modified so no file download. just return
// instead and trace out something so the user
// doesn't think that the download happened when it
// didn't
// test for 401 result (HTTP only)
// this three attempt trick is to get round quirks in different
// Java implementations. Some of them take a few goes to bind
// property; we ignore the first couple of such failures.
// we have started to (over)write dest, but failed.
// Try to delete the garbage we'd otherwise leave
// behind.
// ignore
// it may be slow because java performs reverse hostname lookup.
// Cloudflare country code header (Only works when the request passed through CF servers)
// it may be slow because java performs reverse hostname lookup.
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//don't do any progress, unless asked
//set the timestamp to the file date.
//if (and only if) the use file time option is set, then
//the saved file now has its timestamp set to that of the
//downloaded file
// set up the URL connection
// modify the headers
// NB: things like user authentication could go in here too.
// connect to the remote site (may take some time)
// First check on a 301 / 302 (moved) response (HTTP only)
// next test for a 304 result (HTTP only)
// not modified so no file download. just return
// instead and trace out something so the user
// doesn't think that the download happened when it
// didn't
// test for 401 result (HTTP only)
// this three attempt trick is to get round quirks in different
// Java implementations. Some of them take a few goes to bind
// property; we ignore the first couple of such failures.
// we have started to (over)write dest, but failed.
// Try to delete the garbage we'd otherwise leave
// behind.
// ignore
// it may be slow because java performs reverse hostname lookup.
// it may be slow because java performs reverse hostname lookup.
// Cloudflare country code header (Only works when the request passed through CF servers)
// it may be slow because java performs reverse hostname lookup.
//geolite.maxmind.com/download/geoip/database/GeoLite2-City.mmdb.gz");
// even if these are Google's ip Maxmind demo database may not identify so don't rely on their popularity.
//github.com/maxmind/MaxMind-DB/raw/master/test-data/GeoIP2-ISP-Test.mmdb")));
//github.com/maxmind/MaxMind-DB/raw/master/test-data/GeoIP2-Connection-Type-Test.mmdb")));
// TODO: find a reliable ip that can be mapped.
//github.com/maxmind/MaxMind-DB/raw/master/test-data/GeoIP2-Connection-Type-Test.mmdb"))
//github.com/maxmind/MaxMind-DB/raw/master/test-data/GeoIP2-ISP-Test.mmdb")));
//github.com/maxmind/MaxMind-DB/raw/master/test-data/GeoIP2-Connection-Type-Test.mmdb"))
//github.com/maxmind/MaxMind-DB/raw/master/test-data/GeoIP2-ISP-Test.mmdb")));
//github.com/maxmind/MaxMind-DB/raw/master/test-data/GeoIP2-Connection-Type-Test.mmdb"))
//github.com/maxmind/MaxMind-DB/raw/master/test-data/GeoIP2-ISP-Test.mmdb"));
//
// A bit SEO wouldn't hurt.
//        if (user.id == null) {
//            FieldType fieldType = userTypeCache.getUnchecked(project);
//            Schema field = AvroUtil.generateAvroSchema(fieldType);
//            Schema.Type type = field.getTypes().get(1).getType();
//            Object anonymousUser = requestParams.cookies().stream()
//                    .filter(e -> e.name().equals("_anonymous_user")).findAny()
//                    .map(e -> cast(type, e.value())).orElse(generate(type));
//
//            user.setId(anonymousUser);
//            return ImmutableList.of(new DefaultCookie("_anonymous_user", String.valueOf(anonymousUser)));
//        }
//
/**
// Iterate all the network interfaces
// Iterate all the addresses assigned to the network interface
// Found a non-loopback site-local address
// Found the first non-loopback, non-site-local address
// Return the first non-loopback, non-site-local address
// Return the local host address (may be the loopback address)
//        eventMappers.addBinding().to(UserIdEventMapper.class).in(Scopes.SINGLETON);
//        userPropertyMappers.addBinding().to(UserIdEventMapper.class).in(Scopes.SINGLETON);
//google.com/?q=test"), EventMapper.RequestParams.EMPTY_PARAMS},
//google.com/?q=test")},
//google.com/?q=test"), (EventMapper.RequestParams) () -> new DefaultHttpHeaders().set("Referer", "https://google.com/?q=test")}
//test.com");
//google.com/?q=test");
//test.com/");
#!/usr/bin/env python
#'):
# noinspection PyTypeChecker
# set process name: https://github.com/electrum/procname
//
//76daa36329be422ab9b592ab7239c2aa@sentry.io/1290994?release=%s&servername=%s&stacktrace.app.packages=org.rakam",
// TODO: support for breaking words to multiple lines
// process modules and add used properties to ConfigurationFactory
///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7");
// TODO: find a way to parse the content type
// do not set CsvSchema setUseHeader, it has extra overhead and the deserializer cannot handle that.
// do not set CsvSchema setUseHeader, it has extra overhead and the deserializer cannot handle that.
// if the array is null, return null as value.
// TODO: if the key already has a type, return that type instead of null.
// TODO: what if the other values are not null?
// if the map is null, return null as value.
// TODO: if the key already has a type, return that type instead of null.
// TODO: what if the other values are not null?
// pass START_OBJECT
// the type of magic _user field must be consistent between collections
// if the type of new field is ARRAY, we already switched to next token
// so current token is not START_ARRAY.
// the type is null or an empty array
// TODO: get rid of this loop.
// try to parse the value
// In order to determine the value type of map, getTypeForUnknown method performed an extra
// jp.nextToken() so the cursor should be at VALUE_STRING token.
// if the passStartArrayToken is true, we already performed jp.nextToken
// so there is no need to check if the current token is START_ARRAY
// Stack traces are expensive and we don't need them.
/*")
/*")
/*")
/*")
//www.apache.org/licenses/LICENSE-2.0.html"));
//@Path("/custom-event-mapper")
//@Api(value = "/custom-event-mapper", nickname = "collection", description = "Custom event mapper", tags = "event-mapper")
// field not exists, create it
// TODO :what if the new code has same hashcode?
// child first requires a parent class loader
// grab the magic lock
// Check if class is in the loaded classes cache
// If this is not a parent first class, look for the class locally
// not a local class
// Check parent class loaders, unless this is a hidden class
// this parent didn't have the class
// If this is a parent first class, now look for the class locally
// todo maybe make this more precise and only match base package
// todo maybe make this more precise and only match base package
// If this is not a parent first resource, check local resources first
// Check parent class loaders
// If this is a parent first resource, now check local resources
// If this is not a parent first resource, add resources from local urls first
// Add parent resources
//        if (!isHiddenResource(name)) {
//            Iterator<URL> parentResources = Iterators.forEnumeration(getParent().getResources(name));
//            resources.add(parentResources);
//        }
// If this is a parent first resource, now add resources from local urls
// TODO: bound event mappers to Netty Channels and runStatementSafe them in separate thread
// TODO: we may cache these values and reduce the db hit.
//            .put("email", UserEmailActionService.class)
//            eventMappers.addBinding().to(UserIdCheckEventMapper.class).in(Scopes.SINGLETON);
//            userPropertyMappers.addBinding().to(UserIdCheckEventMapper.class).in(Scopes.SINGLETON);
//@AutoService(RakamModule.class)
// ignore
// or from String, URL etc
//            System.out.println(row.get("latitude"));
//    @Test(expectedExceptions = JsonMappingException.class, expectedExceptionsMessageRegExp = "Cannot cast object to INTEGER for 'test' field.*")
//        jsCodeCompiler.createEngine("test", "new Array(100000000).concat(new Array(100000000));", "");
/**
//    @Test
// TODO: add an extra option the allow these values to be NULL.
// TODO: async callback?
//        while (producer.getOutstandingRecordsCount() > MAX_RECORDS_IN_FLIGHT) {
//            Thread.sleep(SLEEP_BACKOFF_IN_MS);
//        }
/*
//aws.amazon.com/asl/
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// handle race condition
// use same jdbc pool if report.metadata.store is not set explicitly.
// Postgresql BRIN support came in 9.5 version
// We cant't use CONCURRENTLY because it causes dead-lock with ALTER TABLE and it's slow.
// check_violation -> https://www.postgresql.org/docs/8.2/static/errcodes-appendix.html
// last event must have the last schema
// check_violation -> https://www.postgresql.org/docs/8.2/static/errcodes-appendix.html
// check_violation -> https://www.postgresql.org/docs/8.2/static/errcodes-appendix.html
// get the event with the last schema
//                    if(type == FieldType.MAP_STRING_STRING) {
//                        return "hstore";
//                    }
// syntax error exception
//www.postgresql.org/docs/devel/static/sql-keywords-appendix.html");
// column or table already exists
/*
//www.apache.org/licenses/LICENSE-2.0
// we need it in order to prevent race condition
// may use transaction when we start to use Postgresql 9.5. Since we use insert or merge, it doesn't work right now.
// it must be called from a separated transaction, otherwise it may lock table and the other insert may cause deadlock.
// what if the type does not match?
//        format("DROP TABLE IF EXISTS %s", table)
// we only support mysql at the moment
// handle race condition
// the table does not exist
// the table is already created
// the table is already created
// this field should be removed since the server sets it
//    @Size(min = 1)
// TODO: implement this
//        executorService.scheduleAtFixedRate(kafkaManager::updateOffsets, updateInterval, updateInterval, TimeUnit.SECONDS);
// The API implies that this will always return all of the offsets. So it seems a partition can not have
// more than Integer.MAX_VALUE-1 segments.
//
// This also assumes that the lowest value returned will be the first segment available. So if segments have been dropped off, this value
// should not be 0.
// Leader election going on...
//    @PostConstruct
// TODO: find a way to make this class immutable
//" + dbUri.getHost() : "") +
//rakam.io/doc").description("Rakam Documentation");
// SynchronousQueue
/*
//www.apache.org/licenses/LICENSE-2.0
// match server time and client time and get an estimate
//                ,new SchemaField(projectConfig.getClientTimeColumn(), FieldType.TIMESTAMP)
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// non-static inner classes doesn't work with Jackson
// so we pass the outer variable manually.
/*
//www.apache.org/licenses/LICENSE-2.0
// no-op
/*base 32,2^5*/, random).toString(32)).length() < length) {
// grab first 16 bytes - that's the IV
// grab everything else - that's the cipher-text (encrypted message)
// Joda parses [0-9]{10} as TIMESTAMP with huge value so we limit the characters.
/*
//www.apache.org/licenses/LICENSE-2.0
//pool1.rakam.io/event/collect";
//        public NashornHttpRequest cookie(String key, String value, String domain, String path, boolean secure, boolean httpOnly)
//        {
//            requestBuilder.addCookie(Cookie.newValidCookie(key, value, true, domain, path, System.currentTimeMillis() + 1000, secure, httpOnly));
//            return this;
//        }
//
//        public NashornHttpRequest cookie(String key, String value)
//        {
//            requestBuilder.addCookie(Cookie.newValidCookie(key, value, true, null, null, System.currentTimeMillis() + 1000, true, true));
//            return this;
//        }
/**
//        User test = userService.getUser(CONTEXT, 2).join();
//        assertEquals(test.id, 2);
//        assertEquals((Object) test.properties, JsonHelper.jsonObject()
//                .put("test", 2.0)
//                .put("test1 naber abi", "324")
//                .put("test4 samil", true)
//                .put("created_at", Instant.ofEpochMilli(100).toString())
//                .put("test5", 2.5));
//        User test = userService.getUser(CONTEXT, 3).join();
//        assertEquals(test.id, 3);
//        assertEquals((Object) test.properties, samplePropertiesExpected);
//        User test = userService.getUser(CONTEXT, 3).join();
//        assertEquals(test.id, 3);
//        assertNotNull(test.properties.get("created_at").asText());
//        User test = userService.getUser(CONTEXT, 3).join();
//        assertEquals(test.id, 3);
//        assertEquals((Object) test.properties, JsonHelper.jsonObject()
//                .put("test10", "val")
//                .put("created_at", Instant.ofEpochMilli(100).toString()));
//        User test = userService.getUser(CONTEXT, 3).join();
//        assertEquals(test.id, 3);
//        assertEquals((Object) test.properties, samplePropertiesExpected);
//        assertEquals((Object) samplePropertiesExpected,
//                userService.getUser(CONTEXT, isNumeric.get() ? 3 : "3").join().properties);
//        User test = userService.getUser(CONTEXT, "3").join();
//        assertEquals(test.id, "3");
//        assertEquals((Object) test.properties, samplePropertiesExpected);
//        User test = userService.getUser(CONTEXT, "selami").join();
//        assertEquals(test.id, 3);
//        assertEquals((Object) test.properties, samplePropertiesExpected);
//        User test = getUserService().getUser(CONTEXT, 3).join();
//        assertEquals(test.id, 3);
//        ObjectNode builder = JsonHelper.jsonObject();
//        builder.put("created_at", Instant.ofEpochMilli(10).toString());
//        for (String object : objects) {
//            builder.put(object, 10.0);
//        }
//        assertEquals((Object) test.properties, builder);
//        User test = userService.getUser(CONTEXT, 7).join();
//        assertEquals(test.id, 7);
//        assertEquals((Object) test.properties, JsonHelper.jsonObject()
//                .put("created_at", Instant.ofEpochMilli(100).toString())
//                .put("test5", 1.5));
//        assertEquals(userService.getUser(CONTEXT, 8).join().properties.get("test").asDouble(), 10.0);
//        assertEquals(userService.getUser(CONTEXT, 8).join().properties.get("test").asDouble(), 20.0);
