# Community Code of Conduct

## Our Pledge

As members of the Eclipse community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting code reviews, pull requests, patches, and other activities.

## Our Standards

We are committed to making participation in the Eclipse community a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion or analogous grounds.

Examples of unacceptable behavior by participants include the use of sexual language or imagery, derogatory comments or personal attacks, trolling, public or private harassment, insults, or other unprofessional conduct.

## Our Responsibilities

Eclipse Foundation staff have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. Project leaders, committers and contributors who do not follow the Code of Conduct may be removed from the project.

## Scope

This code of conduct applies within Eclipse project spaces, or in public spaces when an individual is representing the project or the Eclipse community.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by emailing the Eclipse Management Organization: codeofconduct@eclipse.org.

## Attribution

This Code of Conduct is adapted from the Contributor Covenant (http://contributor-covenant.org), version 1.1.0, available at http://contributor-covenant.org/version/1/1/0/

The Eclipse Code Of Conduct can also be viewed [here](https://eclipse.org/org/documents/Community_Code_of_Conduct.php).
# Contributing to Paho

Thanks for your interest in this project!

You can contribute bugfixes and new features by sending pull requests through GitHub.

## Legal

In order for your contribution to be accepted, it must comply with the Eclipse Foundation IP policy.

Please read the [Eclipse Foundation policy on accepting contributions via Git](http://wiki.eclipse.org/Development_Resources/Contributing_via_Git).

1. Sign the [Eclipse ECA](http://www.eclipse.org/legal/ECA.php)
  1. Register for an Eclipse Foundation User ID. You can register [here](https://dev.eclipse.org/site_login/createaccount.php).
  2. Log into the [Eclipse projects forge](https://www.eclipse.org/contribute/cla), and click on 'Eclipse Contributor Agreement'.
2. Go to your [account settings](https://dev.eclipse.org/site_login/myaccount.php#open_tab_accountsettings) and add your GitHub username to your account.
3. Make sure that you _sign-off_ your Git commits in the following format:
  ``` Signed-off-by: Alex Smith <alexsmith@nowhere.com> ``` This is usually at the bottom of the commit message. You can automate this by adding the '-s' flag when you make the commits. e.g.   ```git commit -s -m "Adding a cool feature"```
4. Ensure that the email address that you make your commits with is the same one you used to sign up to the Eclipse Foundation website with.

## Contributing a change

1. [Fork the repository on GitHub](https://github.com/eclipse/paho.mqtt.java/fork)
2. Clone the forked repository onto your computer: ``` git clone https://github.com/<your username>/paho.mqtt.java.git ```
3. Create a new branch from the latest ```develop``` branch with ```git checkout -b YOUR_BRANCH_NAME origin/develop```
4. Make your changes
5. If developing a new feature, make sure to include JUnit tests.
6. Ensure that all new and existing tests pass.
7. Commit the changes into the branch: ``` git commit -s ``` Make sure that your commit message is meaningful and describes your changes correctly.
8. If you have a lot of commits for the change, squash them into a single / few commits.
9. Push the changes in your branch to your forked repository.
10. Finally, go to [https://github.com/eclipse/paho.mqtt.java](https://github.com/eclipse/paho.mqtt.java) and create a pull request from your "YOUR_BRANCH_NAME" branch to the ```develop``` one to request review and merge of the commits in your pushed branch.


What happens next depends on the content of the patch. If it is 100% authored
by the contributor and is less than 1000 lines (and meets the needs of the
project), then it can be pulled into the main repository. If not, more steps
are required. These are detailed in the
[legal process poster](http://www.eclipse.org/legal/EclipseLegalProcessPoster.pdf).



## Developer resources:


Information regarding source code management, builds, coding standards, and more.

- [https://projects.eclipse.org/projects/iot.paho/developer](https://projects.eclipse.org/projects/iot.paho/developer)

Contact:
--------

Contact the project developers via the project's development
[mailing list](https://dev.eclipse.org/mailman/listinfo/paho-dev).

Search for bugs:
----------------

This project uses GitHub Issues here: [github.com/eclipse/paho.mqtt.java/issues](https://github.com/eclipse/paho.mqtt.java/issues) to track ongoing development and issues.

Create a new bug:
-----------------

Be sure to search for existing bugs before you create another one. Remember that contributions are always welcome!

- [Create new Paho bug](https://github.com/eclipse/paho.mqtt.java/issues/new)
Eclipse Public License - v 2.0

This program and the accompanying materials
are made available under the terms of the Eclipse Public License v2.0
and Eclipse Distribution License v1.0 which accompany this distribution.

The Eclipse Public License is available at
  https://www.eclipse.org/legal/epl-2.0/
and the Eclipse Distribution License is available at
  https://www.eclipse.org/org/documents/edl-v10.php

For an explanation of what dual-licensing means to you, see:
https://www.eclipse.org/legal/eplfaq.php#DUALLIC# Eclipse Paho Java MQTTv3 Client

The Paho Java Client provides two APIs: MqttAsyncClient provides a fully asychronous API where completion of activities is notified via registered callbacks. MqttClient is a synchronous wrapper around MqttAsyncClient where functions appear synchronous to the application.

## Using the Paho Java MQTTv3 Client

### Downloading

Eclipse hosts a Nexus repository for those who want to use Maven to manage their dependencies. The released libraries are also available in the Maven Central repository.

Add the repository definition and the dependency definition shown below to your pom.xml.

Replace %REPOURL% with either ``` https://repo.eclipse.org/content/repositories/paho-releases/ ``` for the official releases, or ``` https://repo.eclipse.org/content/repositories/paho-snapshots/  ``` for the nightly snapshots. Replace %VERSION% with the level required .
The latest release version is ```1.2.2``` and the current snapshot version is ```1.2.3-SNAPSHOT```.

```
<project ...>
<repositories>
    <repository>
        <id>Eclipse Paho Repo</id>
        <url>%REPOURL%</url>
    </repository>
</repositories>
...
<dependencies>
    <dependency>
        <groupId>org.eclipse.paho</groupId>
        <artifactId>org.eclipse.paho.client.mqttv3</artifactId>
        <version>%VERSION%</version>
    </dependency>
</dependencies>
</project>

```

If you find that there is functionality missing or bugs in the release version, you may want to try using the snapshot version to see if this helps before raising a feature request or an issue.

### Building from source

There are two active branches on the Paho Java git repository, ```master``` which is used to produce stable releases, and ```develop``` where active development is carried out. By default cloning the git repository will download the ```master``` branch, to build from ```develop``` make sure you switch to the remote branch: ``` git checkout -b develop remotes/origin/develop ```

To then build the library run the following maven command: ```mvn package -DskipTests```

This will build the client library without running the tests. The jars for the library, source and javadoc can be found in the ```org.eclipse.paho.client.mqttv3/target``` directory.

## Documentation
Reference documentation is online at: [http://www.eclipse.org/paho/files/javadoc/index.html](http://www.eclipse.org/paho/files/javadoc/index.html)

Log and Debug in the Java Client: [https://wiki.eclipse.org/Paho/Log_and_Debug_in_the_Java_client](https://wiki.eclipse.org/Paho/Log_and_Debug_in_the_Java_client)

## Getting Started

The included code below is a very basic sample that connects to a server and publishes a message using the MqttClient synchronous API. More extensive samples demonstrating the use of the Asynchronous API can be found in the ```org.eclipse.paho.sample.mqttv3app``` directory of the source.


```
import org.eclipse.paho.client.mqttv3.MqttClient;
import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttMessage;
import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;

public class MqttPublishSample {

    public static void main(String[] args) {

        String topic        = "MQTT Examples";
        String content      = "Message from MqttPublishSample";
        int qos             = 2;
        String broker       = "tcp://iot.eclipse.org:1883";
        String clientId     = "JavaSample";
        MemoryPersistence persistence = new MemoryPersistence();

        try {
            MqttClient sampleClient = new MqttClient(broker, clientId, persistence);
            MqttConnectOptions connOpts = new MqttConnectOptions();
            connOpts.setCleanSession(true);
            System.out.println("Connecting to broker: "+broker);
            sampleClient.connect(connOpts);
            System.out.println("Connected");
            System.out.println("Publishing message: "+content);
            MqttMessage message = new MqttMessage(content.getBytes());
            message.setQos(qos);
            sampleClient.publish(topic, message);
            System.out.println("Message published");
            sampleClient.disconnect();
            System.out.println("Disconnected");
            System.exit(0);
        } catch(MqttException me) {
            System.out.println("reason "+me.getReasonCode());
            System.out.println("msg "+me.getMessage());
            System.out.println("loc "+me.getLocalizedMessage());
            System.out.println("cause "+me.getCause());
            System.out.println("excep "+me);
            me.printStackTrace();
        }
    }
}
```

## Adding custom headers for Websocket connection

The included code below is a extended basic sample that connects to a server with custom headers.

```
MqttClient client = new MqttClient("wss://<BROKER_URI>", "MyClient");

MqttConnectOptions connectOptions = new MqttConnectOptions();
Properties properties = new Properties();
properties.setProperty("X-Amz-CustomAuthorizer-Name", <SOME_VALUE>);
properties.setProperty("X-Amz-CustomAuthorizer-Signature", <SOME_VALUE>);
properties.setProperty(<SOME_VALUE>, <SOME_VALUE>);
connectOptions.setCustomWebSocketHeaders(properties);

client.connect(connectOptions);

```
# Eclipse Paho Java Client for MQTTv5

_Warning: The Paho MQTTv5 client is under active development and so can expect breaking changes whilst in the develop branch._

This branch of the Paho Java client is the home of the new MQTTv5 client implementation. This is very much a work in progress, so any feedback / and contributions will be appreciated.

The Committee Specification for MQTT Version 5.0 is available to read here: http://docs.oasis-open.org/mqtt/mqtt/v5.0/cs01/mqtt-v5.0-cs01.html.

The v5 client is build on the same foundations as the v3 client is, however it is targeting Java 8 and above, allowing us to take advantages of more modern Java APIs to aid development and use. Any important fixes for the core engine can be ported between the two clients to take advantage of any performance or stability improvements. It is also being heavily refactored using lessons learnt from the v3 client and feedback from the community.

## Plan

#### Project Modules:
* `org.eclipse.paho.mqttv5.client` - A full client similar to the existing mqttv3 client
* `org.eclipse.paho.mqttv5.common` - A common library that could be used by both a client and server, contains a packet implementation that encodes and decodes all MQTTv5 packet types.
* `org.eclipse.paho.mqttv5.testClient` - A number of examples written that show off features of the v5 client.
* `org.eclipse.paho.mqttv5.server` - Not yet implemented. There has been some interest in the community for a Java MQTTv5 server using the vert.x framework. Contributions are very welcome.

## Help, something doesn't work! / This looks terrible! / What about x!

This client is under active development and as such may be incomplete / broken a lot of the time right now. However, the more feedback and help we get on it, the better it will get! If you have any issues, please raise a bug against the client [here](https://github.com/eclipse/paho.mqtt.java/issues), but **please** prefix it with 'MQTTv5' so we know that it's not an issue with the current v3.1.1 client.

If you have any ideas about how the API should be designed going forward, then please chip in on [this](https://github.com/eclipse/paho.mqtt.java/issues/389) issue.

And of course, if you think of an amazing new feature for the v5 client, have a go at implementing it and submit a Pull Request against the develop branch!# Eclipse Paho Java Client
[![Build Status](https://travis-ci.org/eclipse/paho.mqtt.java.svg?branch=develop)](https://travis-ci.org/eclipse/paho.mqtt.java)

The Paho Java Client is an MQTT client library written in Java for developing applications that run on the JVM or other Java compatible platforms such as Android

The Paho Java Client provides two APIs: MqttAsyncClient provides a fully asynchronous API where completion of activities is notified via registered callbacks. MqttClient is a synchronous wrapper around MqttAsyncClient where functions appear synchronous to the application.


## Project description:

The Paho project has been created to provide reliable open-source implementations of open and standard messaging protocols aimed at new, existing, and emerging applications for Machine-to-Machine (M2M) and Internet of Things (IoT).
Paho reflects the inherent physical and cost constraints of device connectivity. Its objectives include effective levels of decoupling between devices and applications, designed to keep markets open and encourage the rapid growth of scalable Web and Enterprise middleware and applications.


## Links

- Project Website: [https://www.eclipse.org/paho](https://www.eclipse.org/paho)
- Eclipse Project Information: [https://projects.eclipse.org/projects/iot.paho](https://projects.eclipse.org/projects/iot.paho)
- Paho Java Client Page: [https://eclipse.org/paho/clients/java/](https://eclipse.org/paho/clients/java)
- GitHub: [https://github.com/eclipse/paho.mqtt.java](https://github.com/eclipse/paho.mqtt.java)
- Twitter: [@eclipsepaho](https://twitter.com/eclipsepaho)
- Issues: [https://github.com/eclipse/paho.mqtt.java/issues](https://github.com/eclipse/paho.mqtt.java/issues)
- Mailing-list: [https://dev.eclipse.org/mailman/listinfo/paho-dev](https://dev.eclipse.org/mailman/listinfo/paho-dev)

## Using the Paho Java Client

### Downloading

Eclipse hosts a Nexus repository for those who want to use Maven to manage their dependencies. The released libraries are also available in the Maven Central repository.

Add the repository definition and the dependency definition shown below to your pom.xml.

Replace %REPOURL% with either ``` https://repo.eclipse.org/content/repositories/paho-releases/ ``` for the official releases, or ``` https://repo.eclipse.org/content/repositories/paho-snapshots/  ``` for the nightly snapshots. Replace %VERSION% with the level required .

The latest release version is ```1.2.2``` and the current snapshot version is ```1.2.3-SNAPSHOT```.


```
<project ...>
<repositories>
    <repository>
        <id>Eclipse Paho Repo</id>
        <url>%REPOURL%</url>
    </repository>
</repositories>
...
<dependencies>
    <dependency>
        <groupId>org.eclipse.paho</groupId>
        <artifactId>org.eclipse.paho.client.mqttv3</artifactId>
        <version>%VERSION%</version>
    </dependency>
</dependencies>
</project>

```

If you find that there is functionality missing or bugs in the release version, you may want to try using the snapshot version to see if this helps before raising a feature request or an issue.

### Building from source

There are two active branches on the Paho Java git repository, ```master``` which is used to produce stable releases, and ```develop``` where active development is carried out. By default cloning the git repository will download the ```master``` branch, to build from ```develop``` make sure you switch to the remote branch: ``` git checkout -b develop remotes/origin/develop ```

To then build the library run the following maven command: ```mvn package -DskipTests```

This will build the client library without running the tests. The jars for the library, source and javadoc can be found in the ```org.eclipse.paho.client.mqttv3/target``` directory.

## Documentation
Reference documentation is online at: [http://www.eclipse.org/paho/files/javadoc/index.html](http://www.eclipse.org/paho/files/javadoc/index.html)

Log and Debug in the Java Client: [https://wiki.eclipse.org/Paho/Log_and_Debug_in_the_Java_client](https://wiki.eclipse.org/Paho/Log_and_Debug_in_the_Java_client)

## Getting Started

The included code below is a very basic sample that connects to a server and publishes a message using the MqttClient synchronous API. More extensive samples demonstrating the use of the Asynchronous API can be found in the ```org.eclipse.paho.sample.mqttv3app``` directory of the source.


```
import org.eclipse.paho.client.mqttv3.MqttClient;
import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttMessage;
import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;

public class MqttPublishSample {

    public static void main(String[] args) {

        String topic        = "MQTT Examples";
        String content      = "Message from MqttPublishSample";
        int qos             = 2;
        String broker       = "tcp://iot.eclipse.org:1883";
        String clientId     = "JavaSample";
        MemoryPersistence persistence = new MemoryPersistence();

        try {
            MqttClient sampleClient = new MqttClient(broker, clientId, persistence);
            MqttConnectOptions connOpts = new MqttConnectOptions();
            connOpts.setCleanSession(true);
            System.out.println("Connecting to broker: "+broker);
            sampleClient.connect(connOpts);
            System.out.println("Connected");
            System.out.println("Publishing message: "+content);
            MqttMessage message = new MqttMessage(content.getBytes());
            message.setQos(qos);
            sampleClient.publish(topic, message);
            System.out.println("Message published");
            sampleClient.disconnect();
            System.out.println("Disconnected");
            System.exit(0);
        } catch(MqttException me) {
            System.out.println("reason "+me.getReasonCode());
            System.out.println("msg "+me.getMessage());
            System.out.println("loc "+me.getLocalizedMessage());
            System.out.println("cause "+me.getCause());
            System.out.println("excep "+me);
            me.printStackTrace();
        }
    }
}
```
Please fill out the form below before submitting, thank you!

- [ ] Bug exists Release Version 1.2.2 ( Master Branch)
- [ ] Bug exists in MQTTv3 Client on Snapshot Version 1.2.3-SNAPSHOT (Develop Branch)
- [ ] Bug exists in MQTTv5 Client on Snapshot Version 1.2.3-SNAPSHOT (Develop Branch)

If this is a bug regarding the Android Service, please raise the bug here instead: https://github.com/eclipse/paho.mqtt.android/issues/new
Please make sure that the following boxes are checked before submitting your Pull Request, thank you!

- [ ] This change is against the develop branch, **not** master.
- [ ] You have signed the [Eclipse ECA](https://wiki.eclipse.org/ECA)
- [ ] All of your commits have been signed-off with the correct email address (The same one that you used to sign the CLA) _Hint: use the -s argument when committing_.
- [ ] If This PR fixes an issue, that you reference the issue below. OR if this is a new issue that you are fixing straight away that you add some Description about the bug and how this will fix it.
- [ ] If this is new functionality, You have added the appropriate Unit tests.
#Sanskrit: ﻿काचं शक्नोम्यत्तुम् । नोपहिनस्ति माम् ॥
Sanskrit (standard transcription): kācaṃ śaknomyattum; nopahinasti mām.
Classical Greek: ὕαλον ϕαγεῖν δύναμαι· τοῦτο οὔ με βλάπτει.
Greek (monotonic): Μπορώ να φάω σπασμένα γυαλιά χωρίς να πάθω τίποτα.
Greek (polytonic): Μπορῶ νὰ φάω σπασμένα γυαλιὰ χωρὶς νὰ πάθω τίποτα. 
Latin: Vitrum edere possum; mihi non nocet.
Old French: Je puis mangier del voirre. Ne me nuit.
French: Je peux manger du verre, ça ne me fait pas mal.
Provençal / Occitan: Pòdi manjar de veire, me nafrariá pas.
Québécois: J'peux manger d'la vitre, ça m'fa pas mal.
Walloon: Dji pou magnî do vêre, çoula m' freut nén må. 
Picard: Ch'peux mingi du verre, cha m'foé mie n'ma. 
Kreyòl Ayisyen (Haitï): Mwen kap manje vè, li pa blese'm.
Basque: Kristala jan dezaket, ez dit minik ematen.
Catalan / Català: Puc menjar vidre, que no em fa mal.
Spanish: Puedo comer vidrio, no me hace daño.
Aragonés: Puedo minchar beire, no me'n fa mal . 
Galician: Eu podo xantar cristais e non cortarme.
European Portuguese: Posso comer vidro, não me faz mal.
Brazilian Portuguese (8): Posso comer vidro, não me machuca.
Caboverdiano/Kabuverdianu (Cape Verde): M' podê cumê vidru, ca ta maguâ-m'.
Papiamentu: Ami por kome glas anto e no ta hasimi daño.
Italian: Posso mangiare il vetro e non mi fa male.
Milanese: Sôn bôn de magnà el véder, el me fa minga mal.
Roman: Me posso magna' er vetro, e nun me fa male.
Napoletano: M' pozz magna' o'vetr, e nun m' fa mal.
Venetian: Mi posso magnare el vetro, no'l me fa mae.
Zeneise (Genovese): Pòsso mangiâ o veddro e o no me fà mâ.
Sicilian: Puotsu mangiari u vitru, nun mi fa mali. 
Romansch (Grischun): Jau sai mangiar vaider, senza che quai fa donn a mai. 
Romanian: Pot să mănânc sticlă și ea nu mă rănește.
Esperanto: Mi povas manĝi vitron, ĝi ne damaĝas min. 
Cornish: Mý a yl dybry gwéder hag éf ny wra ow ankenya.
Welsh: Dw i'n gallu bwyta gwydr, 'dyw e ddim yn gwneud dolur i mi.
Manx Gaelic: Foddym gee glonney agh cha jean eh gortaghey mee.
Old Irish (Ogham): ᚛᚛ᚉᚑᚅᚔᚉᚉᚔᚋ ᚔᚈᚔ ᚍᚂᚐᚅᚑ ᚅᚔᚋᚌᚓᚅᚐ᚜
Old Irish (Latin): Con·iccim ithi nglano. Ním·géna.
Irish: Is féidir liom gloinne a ithe. Ní dhéanann sí dochar ar bith dom.
Ulster Gaelic: Ithim-sa gloine agus ní miste damh é.
Scottish Gaelic: S urrainn dhomh gloinne ithe; cha ghoirtich i mi.
Anglo-Saxon (Runes): ᛁᚳ᛫ᛗᚨᚷ᛫ᚷᛚᚨᛋ᛫ᛖᚩᛏᚪᚾ᛫ᚩᚾᛞ᛫ᚻᛁᛏ᛫ᚾᛖ᛫ᚻᛖᚪᚱᛗᛁᚪᚧ᛫ᛗᛖ᛬
Anglo-Saxon (Latin): Ic mæg glæs eotan ond hit ne hearmiað me.
Middle English: Ich canne glas eten and hit hirtiþ me nouȝt.
English: I can eat glass and it doesn't hurt me.
English (IPA): [aɪ kæn iːt glɑːs ænd ɪt dɐz nɒt hɜːt miː] (Received Pronunciation)
English (Braille): ⠊⠀⠉⠁⠝⠀⠑⠁⠞⠀⠛⠇⠁⠎⠎⠀⠁⠝⠙⠀⠊⠞⠀⠙⠕⠑⠎⠝⠞⠀⠓⠥⠗⠞⠀⠍⠑
Jamaican: Mi kian niam glas han i neba hot mi.
Lalland Scots / Doric: Ah can eat gless, it disnae hurt us. 
#Gothic (4): 𐌼𐌰𐌲 𐌲𐌻𐌴𐍃 𐌹̈𐍄𐌰𐌽, 𐌽𐌹 𐌼𐌹𐍃 𐍅𐌿 𐌽𐌳𐌰𐌽 𐌱𐍂𐌹𐌲𐌲𐌹𐌸.
Old Norse (Runes): ᛖᚴ ᚷᛖᛏ ᛖᛏᛁ ᚧ ᚷᛚᛖᚱ ᛘᚾ ᚦᛖᛋᛋ ᚨᚧ ᚡᛖ ᚱᚧᚨ ᛋᚨᚱ
Old Norse (Latin): Ek get etið gler án þess að verða sár.
Norsk / Norwegian (Nynorsk): Eg kan eta glas utan å skada meg.
Norsk / Norwegian (Bokmål): Jeg kan spise glass uten å skade meg.
Føroyskt / Faroese: Eg kann eta glas, skaðaleysur.
Íslenska / Icelandic: Ég get etið gler án þess að meiða mig.
Svenska / Swedish: Jag kan äta glas utan att skada mig.
Dansk / Danish: Jeg kan spise glas, det gør ikke ondt på mig.
Sønderjysk: Æ ka æe glass uhen at det go mæ naue.
Frysk / Frisian: Ik kin glês ite, it docht me net sear.
Nederlands / Dutch: Ik kan glas eten, het doet mĳ geen kwaad.
Kirchröadsj/Bôchesserplat: Iech ken glaas èèse, mer 't deet miech jing pieng.
Afrikaans: Ek kan glas eet, maar dit doen my nie skade nie.
Lëtzebuergescht / Luxemburgish: Ech kan Glas iessen, daat deet mir nët wei.
Deutsch / German: Ich kann Glas essen, ohne mir zu schaden.
Ruhrdeutsch: Ich kann Glas verkasematuckeln, ohne dattet mich wat jucken tut.
Langenfelder Platt: Isch kann Jlaas kimmeln, uuhne datt mich datt weh dääd.
Lausitzer Mundart ("Lusatian"): Ich koann Gloos assn und doas dudd merr ni wii.
Odenwälderisch: Iech konn glaasch voschbachteln ohne dass es mir ebbs daun doun dud.
Sächsisch / Saxon: 'sch kann Glos essn, ohne dass'sch mer wehtue.
Pfälzisch: Isch konn Glass fresse ohne dasses mer ebbes ausmache dud.
Schwäbisch / Swabian: I kå Glas frässa, ond des macht mr nix!
Deutsch (Voralberg): I ka glas eassa, ohne dass mar weh tuat.
Bayrisch / Bavarian: I koh Glos esa, und es duard ma ned wei.
Allemannisch: I kaun Gloos essen, es tuat ma ned weh.
Schwyzerdütsch (Zürich): Ich chan Glaas ässe, das schadt mir nöd.
Schwyzerdütsch (Luzern): Ech cha Glâs ässe, das schadt mer ned. 
Hungarian: Meg tudom enni az üveget, nem lesz tőle bajom.
Suomi / Finnish: Voin syödä lasia, se ei vahingoita minua.
Sami (Northern): Sáhtán borrat lása, dat ii leat bávččas.
Erzian: Мон ярсан суликадо, ды зыян эйстэнзэ а ули.
Northern Karelian: Mie voin syvvä lasie ta minla ei ole kipie.
Southern Karelian: Minä voin syvvä st'oklua dai minule ei ole kibie. 
Estonian: Ma võin klaasi süüa, see ei tee mulle midagi.
Latvian: Es varu ēst stiklu, tas man nekaitē.
Lithuanian: Aš galiu valgyti stiklą ir jis manęs nežeidžia 
Czech: Mohu jíst sklo, neublíží mi.
Slovak: Môžem jesť sklo. Nezraní ma.
Polska / Polish: Mogę jeść szkło i mi nie szkodzi.
Slovenian: Lahko jem steklo, ne da bi mi škodovalo.
Bosnian, Croatian, Montenegrin and Serbian (Latin): Ja mogu jesti staklo, i to mi ne šteti.
Bosnian, Montenegrin and Serbian (Cyrillic): Ја могу јести стакло, и то ми не штети.
Macedonian: Можам да јадам стакло, а не ме штета.
Russian: Я могу есть стекло, оно мне не вредит.
Belarusian (Cyrillic): Я магу есці шкло, яно мне не шкодзіць.
Belarusian (Lacinka): Ja mahu jeści škło, jano mne ne škodzić.
Ukrainian: Я можу їсти скло, і воно мені не зашкодить.
Bulgarian: Мога да ям стъкло, то не ми вреди.
Georgian: მინას ვჭამ და არა მტკივა.
Armenian: Կրնամ ապակի ուտել և ինծի անհանգիստ չըներ։
Albanian: Unë mund të ha qelq dhe nuk më gjen gjë.
Turkish: Cam yiyebilirim, bana zararı dokunmaz.
Turkish (Ottoman): جام ييه بلورم بڭا ضررى طوقونمز
Tatar: Алам да бар, пыяла, әмма бу ранит мине.
Uzbek / O’zbekcha (Roman): Men shisha yeyishim mumkin, ammo u menga zarar keltirmaydi.
Uzbek / Ўзбекча (Cyrillic): Мен шиша ейишим мумкин, аммо у менга зарар келтирмайди.
Bangla / Bengali: আমি কাঁচ খেতে পারি, তাতে আমার কোনো ক্ষতি হয় না।
Marathi: मी काच खाऊ शकतो, मला ते दुखत नाही.
Kannada: ನನಗೆ ಹಾನಿ ಆಗದೆ, ನಾನು ಗಜನ್ನು ತಿನಬಹುದು
Hindi: मैं काँच खा सकता हूँ और मुझे उससे कोई चोट नहीं पहुंचती.
Malayalam: എനിക്ക് ഗ്ലാസ് തിന്നാം. അതെന്നെ വേദനിപ്പിക്കില്ല.
Tamil: நான் கண்ணாடி சாப்பிடுவேன், அதனால் எனக்கு ஒரு கேடும் வராது.
Telugu: నేను గాజు తినగలను మరియు అలా చేసినా నాకు ఏమి ఇబ్బంది లేదు
Sinhalese: මට වීදුරු කෑමට හැකියි. එයින් මට කිසි හානියක් සිදු නොවේ.
Urdu(3): میں کانچ کھا سکتا ہوں اور مجھے تکلیف نہیں ہوتی ۔
Pashto(3): زه شيشه خوړلې شم، هغه ما نه خوږوي
Farsi / Persian(3): .من می توانم بدونِ احساس درد شيشه بخورم
Arabic(3): أنا قادر على أكل الزجاج و هذا لا يؤلمني. 
Maltese: Nista' niekol il-ħġieġ u ma jagħmilli xejn.
Hebrew(3): אני יכול לאכול זכוכית וזה לא מזיק לי.
Yiddish(3): איך קען עסן גלאָז און עס טוט מיר נישט װײ. 
Twi: Metumi awe tumpan, ɜnyɜ me hwee.
Hausa (Latin): Inā iya taunar gilāshi kuma in gamā lāfiyā.
Hausa (Ajami) (2): إِنا إِىَ تَونَر غِلَاشِ كُمَ إِن غَمَا لَافِىَا
Yoruba(4): Mo lè je̩ dígí, kò ní pa mí lára.
Lingala: Nakokí kolíya biténi bya milungi, ekosála ngáí mabé tɛ́.
(Ki)Swahili: Naweza kula bilauri na sikunyui.
Malay: Saya boleh makan kaca dan ia tidak mencederakan saya.
Tagalog: Kaya kong kumain nang bubog at hindi ako masaktan.
Chamorro: Siña yo' chumocho krestat, ti ha na'lalamen yo'.
Fijian: Au rawa ni kana iloilo, ia au sega ni vakacacani kina.
Javanese: Aku isa mangan beling tanpa lara.
Burmese (Unicode 4.0): က္ယ္ဝန္‌တော္‌၊က္ယ္ဝန္‌မ မ္ယက္‌စားနုိင္‌သည္‌။ ၎က္ရောင္‌့ ထိခုိက္‌မ္ဟု မရ္ဟိပာ။ (9)
Burmese (Unicode 5.0): ကျွန်တော် ကျွန်မ မှန်စားနိုင်တယ်။ ၎င်းကြောင့် ထိခိုက်မှုမရှိပါ။ (9)
#Vietnamese (quốc ngữ): Tôi có thể ăn thủy tinh mà không hại gì.
#Vietnamese (nôm) (4): 些 𣎏 世 咹 水 晶 𦓡 空 𣎏 害 咦
Khmer: ខ្ញុំអាចញុំកញ្ចក់បាន ដោយគ្មានបញ្ហារ
Lao: ຂອ້ຍກິນແກ້ວໄດ້ໂດຍທີ່ມັນບໍ່ໄດ້ເຮັດໃຫ້ຂອ້ຍເຈັບ.
Thai: ฉันกินกระจกได้ แต่มันไม่ทำให้ฉันเจ็บ
Mongolian (Cyrillic): Би шил идэй чадна, надад хортой биш
Mongolian (Classic) (5): ᠪᠢ ᠰᠢᠯᠢ ᠢᠳᠡᠶᠦ ᠴᠢᠳᠠᠨᠠ ᠂ ᠨᠠᠳᠤᠷ ᠬᠣᠤᠷᠠᠳᠠᠢ ᠪᠢᠰᠢ 
#Nepali: ﻿म काँच खान सक्छू र मलाई केहि नी हुन्‍न् ।
Tibetan: ཤེལ་སྒོ་ཟ་ནས་ང་ན་གི་མ་རེད།
Chinese: 我能吞下玻璃而不伤身体。
Chinese (Traditional): 我能吞下玻璃而不傷身體。
Taiwanese(6): Góa ē-tàng chia̍h po-lê, mā bē tio̍h-siong.
Japanese: 私はガラスを食べられます。それは私を傷つけません。
Korean: 나는 유리를 먹을 수 있어요. 그래도 아프지 않아요
Bislama: Mi save kakae glas, hemi no save katem mi.
Hawaiian: Hiki iaʻu ke ʻai i ke aniani; ʻaʻole nō lā au e ʻeha.
Marquesan: E koʻana e kai i te karahi, mea ʻā, ʻaʻe hauhau.
Inuktitut (10): ᐊᓕᒍᖅ ᓂᕆᔭᕌᖓᒃᑯ ᓱᕋᙱᑦᑐᓐᓇᖅᑐᖓ
Chinook Jargon: Naika məkmək kakshət labutay, pi weyk ukuk munk-sik nay.
Navajo: Tsésǫʼ yishą́ągo bííníshghah dóó doo shił neezgai da. 
Lojban: mi kakne le nu citka le blaci .iku'i le se go'i na xrani mi
Nórdicg: Ljœr ye caudran créneþ ý jor cẃran.
#Emoji: 👁 🥫🍴🔍 ➕ 🙅 🤕
#Sanskrit: ﻿काचं शक्नोम्यत्तुम् । नोपहिनस्ति माम् ॥
Sanskrit (standard transcription): kācaṃ śaknomyattum; nopahinasti mām.
Classical Greek: ὕαλον ϕαγεῖν δύναμαι· τοῦτο οὔ με βλάπτει.
Greek (monotonic): Μπορώ να φάω σπασμένα γυαλιά χωρίς να πάθω τίποτα.
Greek (polytonic): Μπορῶ νὰ φάω σπασμένα γυαλιὰ χωρὶς νὰ πάθω τίποτα. 
Latin: Vitrum edere possum; mihi non nocet.
Old French: Je puis mangier del voirre. Ne me nuit.
French: Je peux manger du verre, ça ne me fait pas mal.
Provençal / Occitan: Pòdi manjar de veire, me nafrariá pas.
Québécois: J'peux manger d'la vitre, ça m'fa pas mal.
Walloon: Dji pou magnî do vêre, çoula m' freut nén må. 
Picard: Ch'peux mingi du verre, cha m'foé mie n'ma. 
Kreyòl Ayisyen (Haitï): Mwen kap manje vè, li pa blese'm.
Basque: Kristala jan dezaket, ez dit minik ematen.
Catalan / Català: Puc menjar vidre, que no em fa mal.
Spanish: Puedo comer vidrio, no me hace daño.
Aragonés: Puedo minchar beire, no me'n fa mal . 
Galician: Eu podo xantar cristais e non cortarme.
European Portuguese: Posso comer vidro, não me faz mal.
Brazilian Portuguese (8): Posso comer vidro, não me machuca.
Caboverdiano/Kabuverdianu (Cape Verde): M' podê cumê vidru, ca ta maguâ-m'.
Papiamentu: Ami por kome glas anto e no ta hasimi daño.
Italian: Posso mangiare il vetro e non mi fa male.
Milanese: Sôn bôn de magnà el véder, el me fa minga mal.
Roman: Me posso magna' er vetro, e nun me fa male.
Napoletano: M' pozz magna' o'vetr, e nun m' fa mal.
Venetian: Mi posso magnare el vetro, no'l me fa mae.
Zeneise (Genovese): Pòsso mangiâ o veddro e o no me fà mâ.
Sicilian: Puotsu mangiari u vitru, nun mi fa mali. 
Romansch (Grischun): Jau sai mangiar vaider, senza che quai fa donn a mai. 
Romanian: Pot să mănânc sticlă și ea nu mă rănește.
Esperanto: Mi povas manĝi vitron, ĝi ne damaĝas min. 
Cornish: Mý a yl dybry gwéder hag éf ny wra ow ankenya.
Welsh: Dw i'n gallu bwyta gwydr, 'dyw e ddim yn gwneud dolur i mi.
Manx Gaelic: Foddym gee glonney agh cha jean eh gortaghey mee.
Old Irish (Ogham): ᚛᚛ᚉᚑᚅᚔᚉᚉᚔᚋ ᚔᚈᚔ ᚍᚂᚐᚅᚑ ᚅᚔᚋᚌᚓᚅᚐ᚜
Old Irish (Latin): Con·iccim ithi nglano. Ním·géna.
Irish: Is féidir liom gloinne a ithe. Ní dhéanann sí dochar ar bith dom.
Ulster Gaelic: Ithim-sa gloine agus ní miste damh é.
Scottish Gaelic: S urrainn dhomh gloinne ithe; cha ghoirtich i mi.
Anglo-Saxon (Runes): ᛁᚳ᛫ᛗᚨᚷ᛫ᚷᛚᚨᛋ᛫ᛖᚩᛏᚪᚾ᛫ᚩᚾᛞ᛫ᚻᛁᛏ᛫ᚾᛖ᛫ᚻᛖᚪᚱᛗᛁᚪᚧ᛫ᛗᛖ᛬
Anglo-Saxon (Latin): Ic mæg glæs eotan ond hit ne hearmiað me.
Middle English: Ich canne glas eten and hit hirtiþ me nouȝt.
English: I can eat glass and it doesn't hurt me.
English (IPA): [aɪ kæn iːt glɑːs ænd ɪt dɐz nɒt hɜːt miː] (Received Pronunciation)
English (Braille): ⠊⠀⠉⠁⠝⠀⠑⠁⠞⠀⠛⠇⠁⠎⠎⠀⠁⠝⠙⠀⠊⠞⠀⠙⠕⠑⠎⠝⠞⠀⠓⠥⠗⠞⠀⠍⠑
Jamaican: Mi kian niam glas han i neba hot mi.
Lalland Scots / Doric: Ah can eat gless, it disnae hurt us. 
#Gothic (4): 𐌼𐌰𐌲 𐌲𐌻𐌴𐍃 𐌹̈𐍄𐌰𐌽, 𐌽𐌹 𐌼𐌹𐍃 𐍅𐌿 𐌽𐌳𐌰𐌽 𐌱𐍂𐌹𐌲𐌲𐌹𐌸.
Old Norse (Runes): ᛖᚴ ᚷᛖᛏ ᛖᛏᛁ ᚧ ᚷᛚᛖᚱ ᛘᚾ ᚦᛖᛋᛋ ᚨᚧ ᚡᛖ ᚱᚧᚨ ᛋᚨᚱ
Old Norse (Latin): Ek get etið gler án þess að verða sár.
Norsk / Norwegian (Nynorsk): Eg kan eta glas utan å skada meg.
Norsk / Norwegian (Bokmål): Jeg kan spise glass uten å skade meg.
Føroyskt / Faroese: Eg kann eta glas, skaðaleysur.
Íslenska / Icelandic: Ég get etið gler án þess að meiða mig.
Svenska / Swedish: Jag kan äta glas utan att skada mig.
Dansk / Danish: Jeg kan spise glas, det gør ikke ondt på mig.
Sønderjysk: Æ ka æe glass uhen at det go mæ naue.
Frysk / Frisian: Ik kin glês ite, it docht me net sear.
Nederlands / Dutch: Ik kan glas eten, het doet mĳ geen kwaad.
Kirchröadsj/Bôchesserplat: Iech ken glaas èèse, mer 't deet miech jing pieng.
Afrikaans: Ek kan glas eet, maar dit doen my nie skade nie.
Lëtzebuergescht / Luxemburgish: Ech kan Glas iessen, daat deet mir nët wei.
Deutsch / German: Ich kann Glas essen, ohne mir zu schaden.
Ruhrdeutsch: Ich kann Glas verkasematuckeln, ohne dattet mich wat jucken tut.
Langenfelder Platt: Isch kann Jlaas kimmeln, uuhne datt mich datt weh dääd.
Lausitzer Mundart ("Lusatian"): Ich koann Gloos assn und doas dudd merr ni wii.
Odenwälderisch: Iech konn glaasch voschbachteln ohne dass es mir ebbs daun doun dud.
Sächsisch / Saxon: 'sch kann Glos essn, ohne dass'sch mer wehtue.
Pfälzisch: Isch konn Glass fresse ohne dasses mer ebbes ausmache dud.
Schwäbisch / Swabian: I kå Glas frässa, ond des macht mr nix!
Deutsch (Voralberg): I ka glas eassa, ohne dass mar weh tuat.
Bayrisch / Bavarian: I koh Glos esa, und es duard ma ned wei.
Allemannisch: I kaun Gloos essen, es tuat ma ned weh.
Schwyzerdütsch (Zürich): Ich chan Glaas ässe, das schadt mir nöd.
Schwyzerdütsch (Luzern): Ech cha Glâs ässe, das schadt mer ned. 
Hungarian: Meg tudom enni az üveget, nem lesz tőle bajom.
Suomi / Finnish: Voin syödä lasia, se ei vahingoita minua.
Sami (Northern): Sáhtán borrat lása, dat ii leat bávččas.
Erzian: Мон ярсан суликадо, ды зыян эйстэнзэ а ули.
Northern Karelian: Mie voin syvvä lasie ta minla ei ole kipie.
Southern Karelian: Minä voin syvvä st'oklua dai minule ei ole kibie. 
Estonian: Ma võin klaasi süüa, see ei tee mulle midagi.
Latvian: Es varu ēst stiklu, tas man nekaitē.
Lithuanian: Aš galiu valgyti stiklą ir jis manęs nežeidžia 
Czech: Mohu jíst sklo, neublíží mi.
Slovak: Môžem jesť sklo. Nezraní ma.
Polska / Polish: Mogę jeść szkło i mi nie szkodzi.
Slovenian: Lahko jem steklo, ne da bi mi škodovalo.
Bosnian, Croatian, Montenegrin and Serbian (Latin): Ja mogu jesti staklo, i to mi ne šteti.
Bosnian, Montenegrin and Serbian (Cyrillic): Ја могу јести стакло, и то ми не штети.
Macedonian: Можам да јадам стакло, а не ме штета.
Russian: Я могу есть стекло, оно мне не вредит.
Belarusian (Cyrillic): Я магу есці шкло, яно мне не шкодзіць.
Belarusian (Lacinka): Ja mahu jeści škło, jano mne ne škodzić.
Ukrainian: Я можу їсти скло, і воно мені не зашкодить.
Bulgarian: Мога да ям стъкло, то не ми вреди.
Georgian: მინას ვჭამ და არა მტკივა.
Armenian: Կրնամ ապակի ուտել և ինծի անհանգիստ չըներ։
Albanian: Unë mund të ha qelq dhe nuk më gjen gjë.
Turkish: Cam yiyebilirim, bana zararı dokunmaz.
Turkish (Ottoman): جام ييه بلورم بڭا ضررى طوقونمز
Tatar: Алам да бар, пыяла, әмма бу ранит мине.
Uzbek / O’zbekcha (Roman): Men shisha yeyishim mumkin, ammo u menga zarar keltirmaydi.
Uzbek / Ўзбекча (Cyrillic): Мен шиша ейишим мумкин, аммо у менга зарар келтирмайди.
Bangla / Bengali: আমি কাঁচ খেতে পারি, তাতে আমার কোনো ক্ষতি হয় না।
Marathi: मी काच खाऊ शकतो, मला ते दुखत नाही.
Kannada: ನನಗೆ ಹಾನಿ ಆಗದೆ, ನಾನು ಗಜನ್ನು ತಿನಬಹುದು
Hindi: मैं काँच खा सकता हूँ और मुझे उससे कोई चोट नहीं पहुंचती.
Malayalam: എനിക്ക് ഗ്ലാസ് തിന്നാം. അതെന്നെ വേദനിപ്പിക്കില്ല.
Tamil: நான் கண்ணாடி சாப்பிடுவேன், அதனால் எனக்கு ஒரு கேடும் வராது.
Telugu: నేను గాజు తినగలను మరియు అలా చేసినా నాకు ఏమి ఇబ్బంది లేదు
Sinhalese: මට වීදුරු කෑමට හැකියි. එයින් මට කිසි හානියක් සිදු නොවේ.
Urdu(3): میں کانچ کھا سکتا ہوں اور مجھے تکلیف نہیں ہوتی ۔
Pashto(3): زه شيشه خوړلې شم، هغه ما نه خوږوي
Farsi / Persian(3): .من می توانم بدونِ احساس درد شيشه بخورم
Arabic(3): أنا قادر على أكل الزجاج و هذا لا يؤلمني. 
Maltese: Nista' niekol il-ħġieġ u ma jagħmilli xejn.
Hebrew(3): אני יכול לאכול זכוכית וזה לא מזיק לי.
Yiddish(3): איך קען עסן גלאָז און עס טוט מיר נישט װײ. 
Twi: Metumi awe tumpan, ɜnyɜ me hwee.
Hausa (Latin): Inā iya taunar gilāshi kuma in gamā lāfiyā.
Hausa (Ajami) (2): إِنا إِىَ تَونَر غِلَاشِ كُمَ إِن غَمَا لَافِىَا
Yoruba(4): Mo lè je̩ dígí, kò ní pa mí lára.
Lingala: Nakokí kolíya biténi bya milungi, ekosála ngáí mabé tɛ́.
(Ki)Swahili: Naweza kula bilauri na sikunyui.
Malay: Saya boleh makan kaca dan ia tidak mencederakan saya.
Tagalog: Kaya kong kumain nang bubog at hindi ako masaktan.
Chamorro: Siña yo' chumocho krestat, ti ha na'lalamen yo'.
Fijian: Au rawa ni kana iloilo, ia au sega ni vakacacani kina.
Javanese: Aku isa mangan beling tanpa lara.
Burmese (Unicode 4.0): က္ယ္ဝန္‌တော္‌၊က္ယ္ဝန္‌မ မ္ယက္‌စားနုိင္‌သည္‌။ ၎က္ရောင္‌့ ထိခုိက္‌မ္ဟု မရ္ဟိပာ။ (9)
Burmese (Unicode 5.0): ကျွန်တော် ကျွန်မ မှန်စားနိုင်တယ်။ ၎င်းကြောင့် ထိခိုက်မှုမရှိပါ။ (9)
#Vietnamese (quốc ngữ): Tôi có thể ăn thủy tinh mà không hại gì.
#Vietnamese (nôm) (4): 些 𣎏 世 咹 水 晶 𦓡 空 𣎏 害 咦
Khmer: ខ្ញុំអាចញុំកញ្ចក់បាន ដោយគ្មានបញ្ហារ
Lao: ຂອ້ຍກິນແກ້ວໄດ້ໂດຍທີ່ມັນບໍ່ໄດ້ເຮັດໃຫ້ຂອ້ຍເຈັບ.
Thai: ฉันกินกระจกได้ แต่มันไม่ทำให้ฉันเจ็บ
Mongolian (Cyrillic): Би шил идэй чадна, надад хортой биш
Mongolian (Classic) (5): ᠪᠢ ᠰᠢᠯᠢ ᠢᠳᠡᠶᠦ ᠴᠢᠳᠠᠨᠠ ᠂ ᠨᠠᠳᠤᠷ ᠬᠣᠤᠷᠠᠳᠠᠢ ᠪᠢᠰᠢ 
#Nepali: ﻿म काँच खान सक्छू र मलाई केहि नी हुन्‍न् ।
Tibetan: ཤེལ་སྒོ་ཟ་ནས་ང་ན་གི་མ་རེད།
Chinese: 我能吞下玻璃而不伤身体。
Chinese (Traditional): 我能吞下玻璃而不傷身體。
Taiwanese(6): Góa ē-tàng chia̍h po-lê, mā bē tio̍h-siong.
Japanese: 私はガラスを食べられます。それは私を傷つけません。
Korean: 나는 유리를 먹을 수 있어요. 그래도 아프지 않아요
Bislama: Mi save kakae glas, hemi no save katem mi.
Hawaiian: Hiki iaʻu ke ʻai i ke aniani; ʻaʻole nō lā au e ʻeha.
Marquesan: E koʻana e kai i te karahi, mea ʻā, ʻaʻe hauhau.
Inuktitut (10): ᐊᓕᒍᖅ ᓂᕆᔭᕌᖓᒃᑯ ᓱᕋᙱᑦᑐᓐᓇᖅᑐᖓ
Chinook Jargon: Naika məkmək kakshət labutay, pi weyk ukuk munk-sik nay.
Navajo: Tsésǫʼ yishą́ągo bííníshghah dóó doo shił neezgai da. 
Lojban: mi kakne le nu citka le blaci .iku'i le se go'i na xrani mi
Nórdicg: Ljœr ye caudran créneþ ý jor cẃran.
#Emoji: 👁 🥫🍴🔍 ➕ 🙅 🤕
# Eclipse Paho mqtt-client CLI App.

## Examples

### General
 1. To connect with a will message, you will need to include the -wp (--will-payload) and -wt (--will-topic) arguments. If the connection to the broker is then lost, then after the keepalive has expired, the broker will forward on the will message to any subscribed clients. The arguments -wt (--will-retain) and -wq (--will-qos) can also be used. Example: `./mqtt-client -sub -h tcp://iot.eclipse.org:1883 -t world -q 0 -wt status -wp "I have disconnected"`
 

### Publishing

1. Publish a message to a topic with a QoS of 0: `./mqtt-client -pub -h tcp://iot.eclipse.org:1883 -t world -m "Hello World" -q 0`
2. Publish a file to a topic: `./mqtt-client -pub -h tcp://iot.eclipse.org:1883 -t world -f alice.txt`
3. Publish input from stdin line-by-line to a toipc: `tail -f /var/log/system.log | ./mqtt-client -pub -h tcp://iot.eclipse.org:1883 -t world --stdin-line`
4. Publish all input from stdin to a topic in one go: `cat alice.txt | ./mqtt-client -pub -h tcp://iot.eclipse.org:1883 -t world --stdin`
5. Publish a message using MQTTv5 to a compatible broker: `./mqtt-client -pub -h tcp://iot.eclipse.org:1883 -t world -m "This is an MQTTv5 message" -v 5 `


### Subscibing

1. Subscribe to a topic with a QoS of 0: `./mqtt-client -sub -h tcp://iot.eclipse.org:1883 -t world -q 0`
2. Subscribe to a topic with a QoS of 0 and print incoming topic name (good with wildcards): `./mqtt-client -sub -h tcp://iot.eclipse.org:1883 -t world/# -q 0 -V`


# Eclipse Paho MQTT Utility

The Paho MQTT Utility is a lightweight but effective utility allowing you to test communication with an MQTT Broker as well as publish and subscribing to topics for application testing.

![Screenshot of Paho MQTT Utility](utility.png)

## How to Download and Use:
You can either build the Jar locally by calling `mvn package -DskipTests` from the parent directory, or you can download it from the Eclipse Repositories:
 - [Release Repository](https://repo.eclipse.org/content/repositories/paho-releases/org/eclipse/paho/org.eclipse.paho.mqtt.utility/)
 - [Snapshot Repository](https://repo.eclipse.org/content/repositories/paho-snapshots/org/eclipse/paho/org.eclipse.paho.mqtt.utility/)

Once you have the Jar, run it by executing: `java -jar org.eclipse.paho.mqtt.utility-1.1.1.jar` substituting the correct filename depending on the version./*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
// Do Nothing.
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
//extends IMqttAsyncClient {
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// ms
// ms
// Automatic reconnect timer
// Reconnect delay, starts at 1
// second
// Simple lock
/**
//</code> for a TCP connection and
//</code> for a TCP connection secured by SSL/TLS. For example:
//localhost:1883</code></li>
//localhost:8883</code></li>
//</code>" URIs, and 8883 for <code>ssl://</code> URIs.
//", "ssl://" or
//".
/**
//</code> for a TCP connection and
//</code> for a TCP connection secured by SSL/TLS. For example:
//localhost:1883</code></li>
//localhost:8883</code></li>
//</code>" URIs, and 8883 for <code>ssl://</code> URIs.
/**
//</code> for a TCP connection and
//</code> for a TCP connection secured by SSL/TLS. For example:
//localhost:1883</code></li>
//localhost:8883</code></li>
//</code>" URIs, and 8883 for <code>ssl://</code> URIs.
//", "ssl://" or
//"
// Support empty client Id, 3.1.1 standard
// Count characters, surrogate pairs count as one character.
// @TRACE 101=<init> ClientID={0} ServerURI={1} PersistenceType={2}
/**
/**
// @TRACE 116=URI={0}
/**
// @TRACE 115=URI={0}
/*
/*
/*
/*
// @TRACE 103=cleanSession={0} connectionTimeout={1} TimekeepAlive={2}
// userName={3} password={4} will={5} userContext={6} callback={7}
// Insert our own callback to iterate through the URIs till the connect
// succeeds
// If we are using the MqttCallbackExtended, set it on the
// connectActionListener
/*
/*
/*
/*
// @TRACE 104=> quiesceTimeout={0} userContext={1} callback={2}
// @TRACE 105=< exception
// @TRACE 108=<
/*
/*
/*
/**
/*
/*
/*
/**
//bugs.eclipse.org/bugs/show_bug.cgi?id=481097
/**
/* wildcards NOT allowed */);
/*
// @TRACE 117=>
// @TRACE 118=<
/*
/*
/*
/*
// remove any message handlers for individual topics and validate topicFilter
// Check if the topic filter is valid before subscribing
/* allow wildcards */);
// Only Generate Log string if we are logging at FINE level
// @TRACE 106=Subscribe topicFilter={0} userContext={1} callback={2}
// @TRACE 109=<
/*
/*
/*
// add or remove message handlers to the list for this client
/* allow wildcards */);
// if the subscribe fails, then we have to remove the message handlers
/*
/*
/*
/*
// Only Generate Log string if we are logging at FINE level
// @TRACE 107=Unsubscribe topic={0} userContext={1} callback={2}
// Check if the topic filter is valid before unsubscribing
// Although we already checked when subscribing, but invalid
// topic filter is meanless for unsubscribing, just prohibit it
// to reduce unnecessary control packet send to broker.
/* allow wildcards */);
// remove message handlers from the list for this client
// @TRACE 110=<
/*
/*
/*
/**
// length of nanoTime = 15, so total length = 19 < 65535(defined in
// spec)
/*
/*
/*
/*
/*
// @TRACE 111=< topic={0} message={1}userContext={1} callback={2}
// Checks if a topic is valid when publishing a message.
/* wildcards NOT allowed */);
// @TRACE 112=<
/**
// @Trace 500=Attempting to reconnect client: {0}
// Some checks to make sure that we're not attempting to reconnect an
// already connected client
// We don't want to spam the server
/**
// @Trace 500=Attempting to reconnect client: {0}
// @TRACE 804=exception
// @TRACE 804=exception
// @Trace 503=Start reconnect timer for client: {0}, delay: {1}
// @Trace 504=Stop reconnect timer for client: {0}
// Reset Delay Timer
// @Trace 506=Triggering Automatic Reconnect attempt.
// Automatic reconnect is set so make sure comms is in resting
// state
// @Trace 501=Automatic Reconnect Successful: {0}
// @Trace 502=Automatic Reconnect failed, rescheduling: {0}
// @Trace 505=Rescheduling reconnect timer for client: {0}, delay:
// {1}
// The previous reconnect timer was cancelled
/**
/**
/**
/**
/**
/*
/*
// @TRACE 113=<
// @TRACE 114=>
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Delegate implementation to MqttAsyncClient
// How long each method should wait for action to complete
/**
//</code> for a TCP connection and
//</code> for a TCP connection secured by SSL/TLS.
//localhost:1883</code></li>
//localhost:8883</code></li>
//</code>" URIs, and 8883 for <code>ssl://</code> URIs.
//", "ssl://" or "local://".
/**
//</code> for a TCP connection and
//</code> for a TCP connection secured by SSL/TLS.
//localhost:1883</code></li>
//localhost:8883</code></li>
//</code>" URIs, and 8883 for <code>ssl://</code> URIs.
//", "ssl://" or "local://"
/**
//</code> for a TCP connection and
//</code> for a TCP connection secured by SSL/TLS.
//localhost:1883</code></li>
//localhost:8883</code></li>
//</code>" URIs, and 8883 for <code>ssl://</code> URIs.
//", "ssl://" or "local://"
/*
/*
/*
/*
/*
/*
/*
/*
/**
/*
/*
/*
/*
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
// message handlers removed in the async client unsubscribe below
/*
/*
/**
/**
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/**
//bugs.eclipse.org/bugs/show_bug.cgi?id=481097
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
/**
// Client Operation Parameters
// How long to wait in seconds when terminating the executor service.
/**
// Initialise Base MqttConnectOptions Object
/**
/**
/**
/**
/**
/**
/**
/**
/**
/* wildcards NOT allowed */);
/**
// Prevent any more changes to the will message
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
//</code> for
//</code> for a TCP connection secured by
//localhost:1883</code></li>
//localhost:8883</code></li>
//</code>" URIs, and 8883 for <code>ssl://</code> URIs.
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/** 
// CONNACK return codes
/** The protocol version requested is not supported by the server. */
/** The server has rejected the supplied client ID */
/** The broker was not available to handle the request. */
/** Authentication with the server has failed, due to a bad user name or password. */
/** Not authorized to perform the requested operation */
/** An unexpected error has occurred. */
/** Error from subscribe - returned from the server. */
/** 
/**
/** 
/**
/**
/** 
/** Unable to connect to server */
/** 
/** 
//</code> must use a <code>javax.net.SocketFactory</code>,
//</code> must use a <code>javax.net.ssl.SSLSocketFactory</code>.
/**
/** 
/** 
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/** Persistence is already being used by another client. */
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
// topic name and topic filter length range defined in the spec
/**
/**
/**
/**
/**
/**
/**
// Spec: length check
// - All Topic Names and Topic Filters MUST be at least one character
// long
// - Topic Names and Topic Filters are UTF-8 encoded strings, they MUST
// NOT encode to more than 65535 bytes
// *******************************************************************************
// 1) This is a topic filter string that can contain wildcard characters
// *******************************************************************************
// Only # or +
// 1) Check multi-level wildcard
// Rule:
// The multi-level wildcard can be specified only on its own or next
// to the topic level separator character.
// - Can only contains one multi-level wildcard character
// - The multi-level wildcard must be the last character used within
// the topic tree
// 2) Check single-level wildcard
// Rule:
// The single-level wildcard can be used at any level in the topic
// tree, and in conjunction with the
// multilevel wildcard. It must be used next to the topic level
// separator, except when it is specified on
// its own.
// *******************************************************************************
// 2) This is a topic name string that MUST NOT contains any wildcard characters
// *******************************************************************************
// prev and next can be only '/' or none
/**
// skip until we meet the next separator, or end of string
// skip until end of string
/*
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
//@Trace 659=start timer for client:{0}
//Check ping after first keep alive interval.
//@Trace 661=stop
//@Trace 660=Check schedule at {0}
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
//@Trace 659=start timer for client:{0}
//Check ping after first keep alive interval.
//@Trace 661=stop
//@Trace 660=Check schedule at {0}
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Lowest possible MQTT message ID to use
// Highest possible MQTT message ID to use
// The next available message ID to use
// Used to store a set of in-use message IDs
/**
//@TRACE 603=clearState
//@TRACE 602=key={0} exception
// Premature end-of-file means that the message is corrupted
//@TRACE 601=key={0} message={1}
/**
/**
// here up the new list
// nothing to reorder
// last in the sorted list
// we need to check that the gap after highest msg id to the lowest msg id is not beaten
// starting message has been located, let's start from this point on
// and any wrapping back to the beginning
/**
//@TRACE 600=>
//@TRACE 604=inbound QoS 2 publish key={0} message={1}
// The inbound messages that we have persisted will be QoS 2 
// QoS 2, and CONFIRM has already been sent...
// NO DUP flag is allowed for 3.1.1 spec while it's not clear for 3.1 spec
// So we just remove DUP
// confirmMessage.setDuplicate(true); // REMOVED
//@TRACE 605=outbound QoS 2 pubrel key={0} message={1}
//@TRACE 606=outbound QoS 2 completed key={0} message={1}
// QoS 1 or 2, with no CONFIRM sent...
// Put the SEND to the list of pending messages, ensuring message ID ordering...
//@TRACE 607=outbound QoS 2 publish key={0} message={1}
//@TRACE 608=outbound QoS 1 publish key={0} message={1}
// Buffered outgoing messages that have not yet been sent at all
//@TRACE 607=outbound QoS 2 publish key={0} message={1}
//@TRACE 608=outbound QoS 1 publish key={0} message={1}
//@TRACE 511=outbound QoS 0 publish key={0} message={1}
// Because there is no Puback, we have to trust that this is enough to send the message
//@TRACE 609=removing orphaned pubrel key={0}
//@TRACE 610=QoS 2 publish key={0}
// set DUP flag only for PUBLISH, but NOT for PUBREL (spec 3.1.1)
//@TRACE 611=QoS 2 pubrel key={0}
//@TRACE 612=QoS 1 publish key={0}
//@TRACE 512=QoS 0 publish key={0}
/**
//@TRACE 613= sending {0} msgs at max inflight window
//@TRACE 628=pending publish key={0} qos={1} message={2}
//@TRACE 615=pending send key={0} message {1}
// Add the connect action at the head of the pending queue ensuring it jumps
// ahead of any of other pending actions.
/**
// Because the client will have disconnected, we will want to re-open persistence
//@TRACE 515=Could not Persist, attempting to Re-Open Persistence Store
//@TRACE 513=Persisted Buffered Message key={0}
//@TRACE 514=Failed to persist buffered message key={0}
/**
//@TRACE 517=Un-Persisting Buffered message key={0}
//@TRACE 518=Failed to Un-Persist Buffered message key={0}
/**
//@TRACE 618=key={0} QoS={1} 
//Free this message Id so it can be used again
//Set the messageId to 0 so if it's ever retried, it will get a new messageId
/**
/**
//@TRACE 616=checkForActivity entered
// ref bug: https://bugs.eclipse.org/bugs/show_bug.cgi?id=440698
// No ping while quiescing
// Below might not be necessary since move to nanoTime (Issue #278)
//Reduce schedule frequency since System.currentTimeMillis is no accurate, add a buffer
//It is 1/10 in minimum keepalive unit.
// ref bug: https://bugs.eclipse.org/bugs/show_bug.cgi?id=446663
// Is the broker connection lost because the broker did not reply to my ping?                                                                                                                                 
// lastInboundActivity will be updated once receiving is done.                                                                                                                                        
// Add a delta, since the timer and System.currentTimeMillis() is not accurate.     
// TODO - Remove Delta, maybe?
// A ping is outstanding but no packet has been received in KA so connection is deemed broken                                                                                                         
//@TRACE 619=Timed out as no activity, keepAlive={0} lastOutboundActivity={1} lastInboundActivity={2} time={3} lastPing={4}                                                                           
// A ping has already been sent. At this point, assume that the                                                                                                                                       
// broker has hung and the TCP layer hasn't noticed.                                                                                                                                                  
// Is the broker connection lost because I could not get any successful write for 2 keepAlive intervals?                                                                                                      
// I am probably blocked on a write operations as I should have been able to write at least a ping message                                                                                                    
// A ping has not been sent but I am not progressing on the current write operation. 
// At this point, assume that the broker has hung and the TCP layer hasn't noticed.                                                                                                                                                  
// 1. Is a ping required by the client to verify whether the broker is down?                                                                                                                                  
//    Condition: ((pingOutstanding == 0 && (time - lastInboundActivity >= keepAlive + delta)))                                                                                                                
//    In this case only one ping is sent. If not confirmed, client will assume a lost connection to the broker.                                                                                               
// 2. Is a ping required by the broker to keep the client alive?                                                                                                                                              
//    Condition: (time - lastOutboundActivity >= keepAlive - delta)                                                                                                                                           
//    In this case more than one ping outstanding may be necessary.                                                                                                                                           
//    This would be the case when receiving a large message;                                                                                                                                                  
//    the broker needs to keep receiving a regular ping even if the ping response are queued after the long message                                                                                           
//    If lacking to do so, the broker will consider my connection lost and cut my socket.                                                                                                                     
//@TRACE 620=ping needed. keepAlive={0} lastOutboundActivity={1} lastInboundActivity={2}                                                                                                              
// pingOutstanding++;  // it will be set after the ping has been written on the wire                                                                                                             
// lastPing = time;    // it will be set after the ping has been written on the wire                                                                                                             
//Wake sender thread since it may be in wait state (in ClientState.get())                                                                                                                             
//@TRACE 634=ping not needed yet. Schedule next ping.
//@TRACE 624=Schedule next ping at {0}                                                                                                                                                                                
/**
// If there is no work wait until there is work.
// If the inflight window is full and no flows are pending wait until space is freed.
// In both cases queueLock will be notified.
//@TRACE 644=wait for new work or for space in the inflight window 
//@TRACE 647=new work or ping arrived 
// Handle the case where not connected. This should only be the case if: 
// - in the process of disconnecting / shutting down
// - in the process of connecting
//@TRACE 621=no outstanding flows and not connected
// Check if there is a need to send a ping to keep the session alive. 
// Note this check is done before processing messages. If not done first
// an app that only publishes QoS 0 messages will prevent keepalive processing
// from functioning. 
//				checkForActivity(); //Use pinger, don't check here
// Now process any queued flows or messages
// Process the first "flow" in the queue
//@TRACE 617=+1 inflightpubrels={0}
// If the inflight window is full then messages are not 
// processed until the inflight window has space. 
// The in flight window is not full so process the 
// first message in the queue
//@TRACE 623=+1 actualInFlight={0}
//@TRACE 622=inflight window full
// @TRACE 643=sent bytes count={0}                                                                                                                                                                                            
/**
//@TRACE 625=key={0}
//@TRACE 635=ping sent. pingOutstanding: {0}                                                                                                                                                                  
// once a QoS 0 message is sent we can clean up its records straight away as
// we won't be hearing about it again
//@TRACE 646=-1 actualInFlight={0}
//		if (quiescing && actualInFlight == 0 && pendingFlows.size() == 0 && inFlightPubRels == 0 && callback.isQuiesced()) {
//@TRACE 626=quiescing={0} actualInFlight={1} pendingFlows={2} inFlightPubRels={3} callbackQuiesce={4} tokens={5}
// @TRACE 630=received bytes count={0}                                                                                                                                                                                        
/**
// @TRACE 627=received key={0} message={1}
// @TRACE 662=no message found for ack id={0}
// Complete the QoS 2 flow. Unlike all other
// flows, QoS is a 2 phase flow. The second phase sends a
// PUBREL - the operation is not complete until a PUBCOMP
// is received
// QoS 1 & 2 notify users of result before removing from
// persistence
// Do not remove publish / delivery token at this stage
// do this when the persistence is removed later 
//@TRACE 636=ping response received. pingOutstanding: {0}                                                                                                                                                     
// Add the connect token back in so that users can be  
// notified when connect completes.
// Notify the sender thread that there maybe work for it to do now
/**
// @TRACE 651=received key={0} message={1}
//should NOT reach here
// Original publish has already been delivered.
/**
// @TRACE 629=received key={0} token={1} message={2}
// QoS 1 - user notified now remove from persistence...
// @TRACE 650=removed Qos 1 publish. key={0}
// QoS 2 - user notified now remove from persistence...
// @TRACE 645=removed QoS 2 publish/pubrel. key={0}, -1 inFlightPubRels={1}
// unblock any threads waiting on the token  
// Let the user know an async operation has completed and then remove the token
//@TRACE 648=key{0}, msg={1}, excep={2}
// There are cases where there is no ack as the operation failed before 
// an ack was received 
//@TRACE 649=key={0},excep={1}
/**
//@TRACE 631=connected
//Start ping thread when client connected to server.
/**
//@TRACE 632=reason {0}
// If any outstanding let the user know the reason why it is still
// outstanding by putting the reason shutdown is occurring into the 
// token. 
// Set the token up so it is ready to be notified after disconnect
// processing has completed. Do not 
// remove the token from the store if it is a delivery token, it is 
// valid after a reconnect. 
// If not a delivery token it is not valid on 
// restart so remove
/**
//@TRACE 633=disconnected
// Reset pingOutstanding to allow reconnects to assume no previous ping.
// Ignore as we have disconnected at this point
/**
/**
// Allow two complete passes of the message ID range. This gives
// any asynchronous releases a chance to occur
/**
// If the timeout is greater than zero t
//@TRACE 637=timeout={0}
// We don't want to handle any new inbound messages
// If token count is not zero there is outbound work to process and 
// if pending flows is not zero there is outstanding work to complete and
// if call back is not quiseced there it needs to complete. 
//@TRACE 639=wait for outstanding: actualInFlight={0} pendingFlows={1} inFlightPubRels={2} tokens={3}
// wait for outstanding in flight messages to complete and
// any pending flows to complete
// Don't care, as we're shutting down anyway
// Quiesce time up or inflight messages delivered.  Ensure pending delivery
// vectors are cleared ready for disconnect to be sent as the final flow.
//@TRACE 640=finished
//@TRACE 638=notifying queueLock holders
//@TRACE 641=remove publish from persistence. key={0}
//@TRACE 641=remove publish from persistence. key={0}
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// topicFilter -> messageHandler
/**
// Preparatory work before starting the background thread.
// For safety ensure any old events are cleared.
/**
// @TRACE 700=stopping
// @TRACE 701=notify workAvailable and wait for run
// to finish
// Wait for the thread to finish.
// @TRACE 703=stopped
// If no work is currently available, then wait until there is some...
// @TRACE 704=wait for workAvailable
// Check for deliveryComplete callbacks...
// First call the delivery arrived callback if needed
// Check for messageArrived callbacks...
// Note, there is a window on connect where a publish
// could arrive before we've
// finished the connect logic.
// Users code could throw an Error or Exception e.g. in the case
// of class NoClassDefFoundError
// @TRACE 714=callback threw exception
// Notify the spaceAvailable lock, to say that there's now
// some space on the queue...
// @TRACE 706=notify spaceAvailable
// @TRACE 705=callback and notify for key={0}
// Finish by doing any post processing such as delete 
// from persistent store but only do so if the action
// is complete
// Unblock any waiters and if pending complete now set completed
// If a callback is registered and delivery has finished 
// call delivery complete callback. 
// Now call async action completion callbacks
// Set notified so we don't tell the user again about this action.
/**
// If there was a problem and a client callback has been set inform
// the connection lost listener of the problem.
// @TRACE 708=call connectionLost
// Just log the fact that a throwable has caught connection lost 
// is called during shutdown processing so no need to do anything else
// @TRACE 720=exception from connectionLost {0}
/**
// @TRACE 716=call onSuccess key={0}
// @TRACE 717=call onFailure key {0}
/**
// If we already have enough messages queued up in memory, wait
// until some more queue space becomes available. This helps 
// the client protect itself from getting flooded by messages 
// from the server.
// @TRACE 709=wait for spaceAvailable
// Notify the CommsCallback thread that there's work to do...
// @TRACE 710=new msg avail, notify workAvailable
/**
// @TRACE 711=quiesce notify spaceAvailable
// Unblock anything waiting for space...
// If quisecing process any pending messages.
// @TRACE 713=call messageArrived key={0} topic={1}
// invoke callbacks on callback thread
// @TRACE 715=new workAvailable. key={0}
// invoke async callback on invokers thread
// Users code could throw an Error or Exception e.g. in the case
// of class NoClassDefFoundError
// @TRACE 719=callback threw ex:
// Shutdown likely already in progress but no harm to confirm
/**
// no exception thrown if the filter was not present
/* if the message hasn't been delivered to a per subscription handler, give it to the default handler */
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
//@TRACE 855=starting
/**
//@TRACE 850=stopping
//@TRACE 851=stopped
/**
//@TRACE 852=network read message
// instanceof checks if message is null
// Ensure the notify processing is done under a lock on the token
// This ensures that the send processing can complete  before the
// receive processing starts! ( request and ack and ack processing
// can occur before request processing is complete if not!
//This is an ack for a message we no longer have a ticket for.
//This probably means we already received this message and it's being send again
//because of timeouts, crashes, disconnects, restarts etc.
//It should be safe to ignore these unexpected messages.
// It its an ack and there is no token then something is not right.
// An ack should always have a token assoicated with it.
// A new message has arrived
//@TRACE 856=Stopping, MQttException
// Token maybe null but that is handled in shutdown
//@TRACE 853=Stopping due to IOException
// An EOFException could be raised if the broker processes the
// DISCONNECT and ends the socket before we complete. As such,
// only shutdown the connection if we're not already shutting down.
// end while
// end try
//@TRACE 854=<
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
//Sends MQTT packets to the server on its own thread
/**
/**
//@TRACE 800=stopping sender
//@TRACE 801=stopped
//@TRACE 802=network send key={0} msg={1}
// While quiescing the tokenstore can be cleared so need
// to check for null for the case where clear occurs
// while trying to send a message.
// The flush has been seen to fail on disconnect of a SSL socket
// as disconnect is in progress this should not be treated as an error
// null message
//@TRACE 803=get message returned null, stopping}
// end while
//@TRACE 805=<
//@TRACE 804=exception
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Maps message-specific data (usually message IDs) to tokens
//@TRACE 308=<>
//,new Object[]{message});
/**
//@TRACE 306=key={0}
/**
//@TRACE 302=existing key={0} message={1} token={2}
//@TRACE 303=creating new token key={0} message={1} token={2}
// For outbound messages store the token in the token store 
// For pubrel use the existing publish token 
//@TRACE 300=key={0} message={1}
//@TRACE 307=key={0} token={1}
//@TRACE 309=resp={0}
//@TRACE 310=>
//@TRACE 311=>
//@TRACE 312=>
/**
//@TRACE 305=> {0} tokens
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
// fix bug 469527 - maybe should be set elsewhere?
/**
// try the next URI in the list
// fix bug 469527 - maybe should be set elsewhere?
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// Used to synchronise the buffer
/**
/**
/**
/**
/**
// @TRACE 516=Restoring all buffered messages.
// Publish was successful, remove message from buffer.
// If we get the max_inflight condition, try again after a short
// interval to allow more messages to be completely sent.
// Error occurred attempting to publish buffered message likely because the
// client is not connected
// @TRACE 519=Error occurred attempting to publish buffered message due to disconnect. Exception: {0}:{1}.
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
// Utility classes should not have a public or default constructor.
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
// Create a file to obtain a lock on. 
// Lock not obtained
/**
// Ignore exceptions
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Hide this class reference behind reflection so that the class does not need to
// be present when compiled on midp
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// Message key
// Message header
// Message payload
/**
/*
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/*
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/** Pattern to match URI authority parts: {@code authority = [userinfo"@"]host[":"port]} */
// no instances
/**
/**
/*
/**
//tools.ietf.org/html/rfc3986#section-3.2">rfc3986 - section-3.2</a>
// already successfully parsed
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
//MAY throws MissingResourceException
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
// @TRACE 260=setEnabledCiphers ciphers={0}
// RTC 765: Set a timeout to avoid the SSL handshake being blocked indefinitely
// SNI support.  Should be automatic under some circumstances - not all, apparently
// If default Hostname verification is enabled, use the same method that is used with HTTPS
// reset timeout to default value
//" + host + ":" + port;
/*
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// -1 if not defined
//			try {
//			}
//			catch (MqttDirectException ex) {
//				throw ExceptionHelper.createMqttException(ex.getCause());
//			}
// Create the network module...
// Ciphers suites need to be set, if they are available
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
// @TRACE 252=connect to host {0} port {1} timeout {2}
//@TRACE 250=Failed to create TCP socket
/**
/**
//" + host + ":" + port;
/*
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// -1 if not defined
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
//@TRACE 407=key={0} wait max={1} token={2}
//@TRACE 406=key={0} timed out token={1}
/**
//@TRACE 400=>key={0} timeout={1} sent={2} completed={3} hasException={4} response={5} token={6}
//@TRACE 408=key={0} wait max={1}
//@TRACE 401=failed with exception
// time up and still not completed
//@TRACE 402=key={0} response={1}
/**
//@TRACE 404=>key={0} response={1} excep={2}
// ACK means that everything was OK, so mark the message for garbage collection.
/**
//@TRACE 411=>key={0} response={1} excep={2}
// If pending complete is set then normally the token can be marked
// as complete and users notified. An abnormal error may have 
// caused the client to shutdown beween pending complete being set
// and notifying the user.  In this case - the action must be failed.
//	/**
/**
//	 * used for things like IOException, and not for MQTT NACKs.
//	 */
//	protected void notifyException() {
//		final String methodName = "notifyException";
//		//@TRACE 405=token={0} excep={1}
//		log.fine(CLASS_NAME,methodName, "405",new Object[]{this,this.exception});
//		synchronized (responseLock) {
//			responseLock.notifyAll();
//		}
//		synchronized (sentLock) {
//			sentLock.notifyAll();
//		}
//	}
//@TRACE 409=wait key={0}
/**
//@TRACE 403=> key={0}
// Token is already in use - cannot reset 
//@TRACE 410=> key={0}
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// if this string is changed, then the decode method must also be adapted.
/**
// Allocate a string buffer.
// j==2 | j==1 | j==0
// there is a rest of 2 bytes. This encodes into 3 chars.
// there is a rest of 1 byte. This encodes into 1 char.
// j==3 | j==2 
/* the core conding routine. Translates an input integer into
/*
// convert encoded[idx] back into a 6-bit value.
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
// "SSL_TLS" is not supported by DesktopEE
// a hashtable that maps configIDs to properties.
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
// can't use split as split is not available on all java platforms.
// handle all commas.
// add stuff before and up to (but not including) the comma.
// skip the comma.
// add last element after the comma or only element if no comma is present.
/**
/**
//	private Properties getOrCreate(String configID) {
//		Properties res = null;
//		if (configID == null) {
//			if (this.defaultProperties == null) {
//				this.defaultProperties = new Properties();
//			}
//			res = this.defaultProperties;
//		} else {
//			res = (Properties) this.configs.get(configID);
//			if (res == null) {
//				res = new Properties();
//				this.configs.put(configID, res);
//			}
//		}
//		return res;
//	}
/**
// copy the properties.
/**
/**
/**
/**
//	public String[] getConfigurationIDs() {
//		Set s = this.configs.keySet();
//		String[] configs = new String[s.size()];
//		configs = (String[]) s.toArray(configs);
//		return configs;
//	}
/**
//	private final void putOrRemove(Properties p, String key, String value) {
//		if (value == null) {
//			p.remove(key);
//		} else {
//			p.put(key, value);
//		}
//	}
/**
//	public void setSSLProtocol(String configID, String protocol) {
//		Properties p = getOrCreate(configID);
//		putOrRemove(p, SSLPROTOCOL, protocol);
//	}
/**
//	public void setJSSEProvider(String configID, String provider) {
//		Properties p = getOrCreate(configID);
//		putOrRemove(p, JSSEPROVIDER, provider);
//	}
/**
//	public void setKeyStore(String configID, String keyStore) {
//		if (keyStore == null)
//			return;
//		Properties p = getOrCreate(configID);
//		putOrRemove(p, KEYSTORE, keyStore);
//	}
/**
//	public void setKeyStorePassword(String configID, char[] password) {
//		if (password == null)
//			return;
//		Properties p = getOrCreate(configID);
//		// convert password, using XOR-based scrambling.
//		String ePasswd = obfuscate(password);
//		for(int i=0;i<password.length;i++) {
//			password[i]=' ';
//		}
//		putOrRemove(p, KEYSTOREPWD, ePasswd);
//	}
/**
//	public void setKeyStoreProvider(String configID, String provider) {
//		Properties p = getOrCreate(configID);
//		putOrRemove(p, KEYSTOREPROVIDER, provider);
//	}
/**
//	public void setKeyStoreType(String configID, String type) {
//		Properties p = getOrCreate(configID);
//		putOrRemove(p, KEYSTORETYPE, type);
//	}
/**
//	public void setCustomKeyManager(String configID, String keymanager) {
//		Properties p = getOrCreate(configID);
//		putOrRemove(p, CUSTOMKEYMGR, keymanager);
//	}
/**
//	public void setTrustStore(String configID, String trustStore) {
//		Properties p = getOrCreate(configID);
//		putOrRemove(p, TRUSTSTORE, trustStore);
//	}
/**
//	public void setTrustStorePassword(String configID, char[] password) {
//		Properties p = getOrCreate(configID);
//		// convert password, using XOR-based scrambling.
//		String ePasswd = obfuscate(password);
//		for(int i=0;i<password.length;i++) {
//			password[i]=' ';
//		}
//		putOrRemove(p, TRUSTSTOREPWD, ePasswd);
//	}
/**
//	public void setTrustStoreProvider(String configID, String provider) {
//		Properties p = getOrCreate(configID);
//		putOrRemove(p, TRUSTSTOREPROVIDER, provider);
//	}
/**
//	public void setTrustStoreType(String configID, String type) {
//		Properties p = getOrCreate(configID);
//		putOrRemove(p, TRUSTSTORETYPE, type);
//	}
/**
//	public void setCustomTrustManager(String configID, String trustmanager) {
//		Properties p = getOrCreate(configID);
//		putOrRemove(p, CUSTOMTRUSTMGR, trustmanager);
//	}
/**
//	public void setEnabledCipherSuites(String configID, String[] ciphers) {
//		if (ciphers == null)
//			return;
//		Properties p = getOrCreate(configID);
//		String cipherSet = packCipherSuites(ciphers);
//		putOrRemove(p, CIPHERSUITES, cipherSet);
//	}
/**
//	public void setClientAuthentication(String configID, boolean clientAuth) {
//		Properties p = getOrCreate(configID);
//		p.put(CLIENTAUTH, Boolean.toString(clientAuth));
//	}
/**
// scan system property, if it exists.
/**
// not found in config. try default properties.
/**
/**
//	/**
/**
//	 * 
//	 * @return the XPD Keystore if running on the XPD platform (otherwise null).
//	 * @throws MqttDirectException
//	 */
//	private KeyStore getXPDKeystore() throws MqttDirectException {
//		KeyStore keyStore = null;
//		try {
//			Class secPlatClass = Class.forName("com.ibm.rcp.security.auth.SecurePlatform");
//			Method m = secPlatClass.getMethod("getKeyStore", null);
//			Object secPlat = m.invoke(null,null); // getKeyStore is static
//			m = secPlatClass.getMethod("isLoggedIn", null);
//			Boolean b = (Boolean) m.invoke(secPlat, null);
//			if (b.booleanValue()) {
//				// login to secure platform was done.
//				m = secPlatClass.getMethod("getKeyStore", null);
//				keyStore = (KeyStore) m.invoke(secPlat, null);
//			}
//		} catch (ClassNotFoundException e) {
//			/*
/*
//			 * running on XPD runtime and therefore we can not get XPD keystore.
//			 * [Next step for the caller, is try to get the keystore from System
//			 * properties (see getKeyStore() method).]
//			 */
//		} catch (IllegalAccessException e) {
//			Object[] inserts = { e.getLocalizedMessage() };
//			throw new MqttSSLInitException(3026, inserts, e);
//		} catch (SecurityException e) {
//			Object[] inserts = { e.getLocalizedMessage() };
//			throw new MqttSSLInitException(3026, inserts, e);
//		} catch (NoSuchMethodException e) {
//			Object[] inserts = { e.getLocalizedMessage() };
//			throw new MqttSSLInitException(3026, inserts, e);
//		} catch (IllegalArgumentException e) {
//			Object[] inserts = { e.getLocalizedMessage() };
//			throw new MqttSSLInitException(3026, inserts, e);
//		} catch (InvocationTargetException e) {
//			Object[] inserts = { e.getLocalizedMessage() };
//			throw new MqttSSLInitException(3026, inserts, e);
//		}
//		return keyStore;
//	}
/**
//throws MqttDirectException {
//		// check for the XPD keystore here
//		if ( ibmKey != null && ibmKey.equals(KEYSTORE) ) {
//			KeyStore keyStore = getXPDKeystore();
//			if (keyStore != null)
//				return res = "Lotus Expeditor";
//		}
// scan system property, if it exists.
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
// 12000 "SSL initialization: configID = {0}, protocol = {1}"
// 12001 "SSL initialization: configID = {0}, provider = {1}"
//			if(keyStoreName==null) {
//				// try to instantiate XPD keyStore.
//				keyStore=getXPDKeystore();
//				if (logger != null) {
//					if (keyStore == null) {
//						// 12002 "SSL initialization: configID = {0}, XPD keystore not available"
//						logger.fine(CLASS_NAME, METHOD_NAME, "12002", new Object[]{configID!=null ? configID : "null (broker defaults)"});
//					} else {
//						// 12003 "SSL initialization: configID = {0}, XPD keystore available"
//						logger.fine(CLASS_NAME, METHOD_NAME, "12003", new Object[]{configID!=null ? configID : "null (broker defaults)"});
//					}
//				}
//			}
/*
// 12004 "SSL initialization: configID = {0}, keystore = {1}"
// 12005 "SSL initialization: configID = {0}, keystore password = {1}"
// 12006 "SSL initialization: configID = {0}, keystore type = {1}"
// 12010 "SSL initialization: configID = {0}, keystore manager algorithm = {1}"
// 12009 "SSL initialization: configID = {0}, keystore manager provider = {1}"
// keystore loaded, keymanagers instantiated if possible
// now the same for the truststore.
// 12011 "SSL initialization: configID = {0}, truststore = {1}"
// 12012 "SSL initialization: configID = {0}, truststore password = {1}"
// 12013 "SSL initialization: configID = {0}, truststore type = {1}"
// 12017 "SSL initialization: configID = {0}, truststore manager algorithm = {1}"
// 12016 "SSL initialization: configID = {0}, truststore manager provider = {1}"
// done.
//	/**
/**
//	 * SSLProtocol is already set, uses DEFAULT_PROTOCOL. Throws
//	 * IllegalArgumentException if the server socket factory could not be
//	 * created due to underlying configuration problems.
//	 * 
//	 * @see org.eclipse.paho.client.mqttv3.internal.security.SSLSocketFactoryFactory#DEFAULT_PROTOCOL
//	 * 
//	 * @param configID
//	 *            The configuration identifier for selecting a configuration.
//	 * @return An SSLServerSocketFactory
//	 * @throws MqttDirectException
//	 */
//	public SSLServerSocketFactory createServerSocketFactory(String configID)
//			throws MqttDirectException {
//		final String METHOD_NAME = "createServerSocketFactory";
//		SSLContext ctx = getSSLContext(configID);
//		if (logger != null) {
//			// 12018 "SSL initialization: configID = {0}, application-enabled cipher suites = {1}"
//			logger.fine(CLASS_NAME, METHOD_NAME, "12018", new Object[]{configID!=null ? configID : "null (broker defaults)", 
//					getEnabledCipherSuites(configID)!=null ? getProperty(configID, CIPHERSUITES, null) : "null (using platform-enabled cipher suites)"});
//			
//			// 12019 "SSL initialization: configID = {0}, client authentication = {1}"
//			logger.fine(CLASS_NAME, METHOD_NAME, "12019", new Object[]{configID!=null ? configID : "null (broker defaults)", 
//					new Boolean (getClientAuthentication(configID)).toString()});
//		}
//		
//		return ctx.getServerSocketFactory();
//	}
/**
// 12020 "SSL initialization: configID = {0}, application-enabled cipher suites = {1}"
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
// First Byte: Fin, Reserved, Opcode
// Second Byte Masked & Initial Length
// 8 Byte Extended payload length
// 2 bytes extended payload length
// Decode the extended payload length
// Get the Masking key if masked
// Demask payload if needed
/**
// Reserved bits, unused right now.
// boolean rsv1 = ((incomingByte & 0x40) != 0);
// boolean rsv2 = ((incomingByte & 0x20) != 0);
// boolean rsv3 = ((incomingByte & 0x10) != 0);
/**
// 8 Byte Extended payload length
// 2 bytes extended payload length
// Decode the payload length
// Get the masking key
// Demask if needed
// Closing connection with server
/**
// Calculating overhead
/**
/**
/**
// Add Fin flag
// RSV 1,2,3 aren't important
// Add opcode
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Do not change: https://tools.ietf.org/html/rfc6455#section-1.3
/**
/**
/**
/**
/**
// We build up the accept in the same way the server should
// then we check that the response is the same.
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
// Creating Close Frame
//" + host + ":" + port;
/*
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// so specific requirements so far
// -1 if not defined
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
//@TRACE 855=starting
/**
//@TRACE 850=stopping
// Wait for the thread to finish
//This must not happen in the synchronized block, otherwise we can deadlock ourselves!
// Interrupted Exception
//@TRACE 851=stopped
//@TRACE 852=network read message
// Ignore SocketTimeoutException 
// Exception occurred whilst reading the stream.
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Creating Close Frame
//" + host + ":" + port;
/*
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// so specific requirements so far
// -1 if not defined
// Create the network module...
// Ciphers suites need to be set, if they are available
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Not needed, as the client never encodes a CONNACK
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
// read header
// Assume we can read the whole header at once.
// The header is very small so it's likely we
// are able to read it fully or not at all.
// This keeps the parser lean since we don't
// need to cope with a partial header.
// Should we lose synch with the stream,
// the keepalive mechanism would kick in
// closing the connection.
// Invalid MQTT message type...
// bit silly, we decode it then encode it
// read remaining packet
// the remaining packet can be read with timeouts
// reset packet parsing state 
// @TRACE 301= received {0} 
// ignore socket read timeout
// remember the packet read so far 
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
//		out.write(message.getHeader());
//		out.write(message.getPayload());
// @TRACE 529= sent {0}
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
//	public String getKey() throws MqttPersistenceException {
//		return new Integer(getMessageId()).toString();
//	}
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Not needed, as the client never encodes a PINGRESP
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
// Convert the first few bytes of the payload into a hex string
// It will not always be possible to convert the binary payload into
// characters, but never-the-less we attempt to do this as it is often
// useful
// all publishes require a message ID as it's used as the key to the token store
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// This method exists here to get around the protected visibility of the
// super class method.
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Not needed, as the client never encodes a SUBACK
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Not needed, as the client never encodes an UNSUBACK
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// The type of the message (e.g. CONNECT, PUBLISH, PUBACK)
// The MQTT message ID
/**
// Use zero as the default message ID. Can't use -1, as that is serialized
// as 65535, which would be a valid ID.
/**
/**
/**
/**
/**
/**
/**
// The persistable interface allows a message to be restored entirely in the
// header array
// Need to treat these two arrays as a single array of bytes and use the
// decoding
// logic to identify the true header/payload split
// The remaining bytes must be the payload...
// Encode the remaining length fields in the four bytes
/**
/**
/**
/**
/* Check for mismatched surrogates */
/* Trailing high surrogate */
/* No low surrogate */
/* Noncharacter in base plane */
/* Control character or no high surrogate */
/* Noncharacter in other nonbase plane */
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
//		loggerName = "org.eclipse.paho.client.mqttv3." + ((null == loggerID || 0 == loggerID.length()) ? "internal" : loggerID);
// || InternalTracer.isLoggable(level);
//		InternalTracer.log(this.catalogID, level, sourceClass, sourceMethod, msg, inserts, thrown);
//	public void setTrace(Trace trace) {
//		InternalTracer.setTrace(trace);
//	}
//		if (FINE == level || isJULLoggable || InternalTracer.isLoggable(level)) {
//			InternalTracer.traceForced(level, sourceClass, sourceMethod, msg, inserts);
//		}
// This is acceptable, simply return the given msg string.
//		LogRecord logRecord = new LogRecord(julLevel, msg);
//		logRecord.setResourceBundleName(catalogName);
//		logRecord.setResourceBundle(messageCatalog);
//		if (null != inserts) {
//			logRecord.setParameters(inserts);
//		}
// synchronized (handler).
// for handlers...
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
//			logger = getJSR47Logger(ResourceBundle.getBundle(messageCatalogName), loggerID, null) ;
//		}
/**
//, FFDC ffdc) {
// Now instantiate the log
/**
// Hide behind reflection as java.util.logging is guaranteed to be
// available.
// Any error, assume JSR47 isn't available and return null
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
// ignore
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
//TODO
//throws MqttPersistenceException {
/**
//throws MqttPersistenceException {
//If lock was previously acquired, release before requesting a new one
// TODO - This shouldn't be here according to the interface
// See https://github.com/eclipse/paho.mqtt.java/issues/178
//throw new MqttPersistenceException(MqttPersistenceException.REASON_CODE_PERSISTENCE_IN_USE);
// Scan the directory for .backup files. These will
// still exist if the JVM exited during addMessage, before
// the new message was written to disk and the backup removed.
/**
// checkIsOpen();
/**
// Backup the existing file so the overwrite can be rolled-back 
// The write has completed successfully, delete the backup 
// The write has failed - restore the backup
/**
/**
/**
/*
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Represents a failed index search.
/**
/**
/**
// missing low surrogate, fine, like String.indexOf(String)
// ch is in the Basic Multilingual Plane
/**
/**
/**
/**
/**
// prevented from constructing objects
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Used to synchronize connection state
/**
/**
//@TRACE 200=internalSend key={0} message={1} token={2}
// Associate the client with the token - also marks it as in use.
// Token is already in use - cannot reuse
//@TRACE 213=fail: token in use: key={0} message={1} token={2}
// Persist if needed and send the message
// undo client setting on error
/**
//@TRACE 507=Client Connected, Offline Buffer available, but not empty. Adding message to buffer. message={0}
//@TRACE 508=Offline Buffer available. Adding message to buffer. message={0}
//@TRACE 208=failed: not connected
/**
/**
// Must be disconnected before close can take place or if we are being forced
//@TRACE 224=failed: not disconnected
// Don't shut down an externally supplied executor service 
//shutdownExecutorService();
// ShutdownConnection has already cleaned most things
/**
//@TRACE 214=state=CONNECTING
// @TRACE 207=connect failed: not disconnected {0}
// We've successfully connected
// @TRACE 215=state=CONNECTED
// @TRACE 204=connect failed: rc={0}
/**
//Token to notify after disconnect completes
// This method could concurrently be invoked from many places only allow it
// to run once.
//@TRACE 216=state=DISCONNECTING
// Update the token with the reason for shutdown if it
// is not already complete.
// Stop the thread that is used to call the user back
// when actions complete
// Stop the thread that handles inbound work from the network
// Stop the network module, send and receive now not possible
// Ignore as we are shutting down
// Stop any new tokens being saved by app and throwing an exception if they do
// Notify any outstanding tokens with the exception of
// con or discon which may be returned and will be notified at
// the end
// Clean session handling and tidy up
// Ignore as we are shutting down
// Ignore as we are shutting down
// All disconnect logic has been completed allowing the
// client to be marked as disconnected.
//@TRACE 217=state=DISCONNECTED
// Internal disconnect processing has completed.  If there
// is a disconnect token or a connect in error notify
// it now. This is done at the end to allow a new connect
// to be processed and now throw a currently disconnecting error.
// any outstanding tokens and unblock any waiters
// Let the user know client has disconnected either normally or abnormally
// While disconnecting, close may have been requested - try it now
// ignore any errors as closing
// Tidy up. There may be tokens outstanding as the client was
// not disconnected/quiseced cleanly! Work out what tokens still
// need to be notified and waiters unblocked. Store the
// disconnect or connect token to notify after disconnect is
// complete.
//@TRACE 222=>
// First the token that was related to the disconnect / shutdown may
// not be in the token table - temporarily add it if not
// Its con or discon so remember and notify @ end of disc routine
// notify waiters and callbacks of outstanding tokens
// that a problem has occurred and disconnect is in
// progress
// Ignore as we are shutting down
//@TRACE 223=failed: in closed state
//@TRACE 211=failed: already disconnected
//@TRACE 219=failed: already disconnecting
//@TRACE 210=failed: called on callback thread
// Not allowed to call disconnect() from the callback, as it will deadlock.
//@TRACE 218=state=DISCONNECTING
/**
// Allow current inbound and outbound work to complete
// Send disconnect packet
// Wait util the disconnect packet sent with timeout
// ignore, probably means we failed to send the disconnect packet.
// Kick off the connect processing in the background so that it does not block. For instance
// the socket could take time to create.
//@TRACE 220=>
// Reset an exception on existing delivery tokens.
// This will have been set if disconnect occurred before delivery was
// fully processed.
// Save the connect token in tokenStore as failure can occur before send
// Connect to the server at the network level e.g. TCP socket and then
// start the background processing threads before sending the connect
// packet.
//@TRACE 212=connect failed: unexpected exception
//@TRACE 209=connect failed: unexpected exception
// Kick off the disconnect processing in the background so that it does not block. For instance
// the quiesce
//@TRACE 221=>
// Allow current inbound and outbound work to complete
// do not wait if the sender process is not running
// if the sender process is not running 
/*
/*
//@TRACE 804=exception
/**
/**
//@TRACE 509=Client Connected, Offline Buffer Available. Sending Buffered Messages.
// First pass at making sure that we don't flood the in-flight messages
// We need to Yield to the other threads to allow the in flight messages to clear
//@TRACE 510=Publishing Buffered message message={0}
// Delete from persistence if in there
//@TRACE 208=failed: not connected
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/** 
// Set defaults by assuming this is run from an eclipse workspace with paho projects loaded
//\\s*@TRACE\\s*(\\d+)=(.*?)\\s*$");
// The original extractor put out 4 values for each trace point
//				out.println(number+".class="+classname);
//				out.println(number+".line="+lineNo);
//				out.println(number+".value="+m.group(2));
/* Copyright (c) 2009, 2014 IBM Corp.
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
//" + serverHost + ":" + TestProperties.getServerSSLPort());
/**
//" + serverHost + ":" + TestProperties.getServerSSLPort());
// for...
// for...
// for publishers...
// for subscribers...
// for messages...
/**
//" + serverHost + ":" + TestProperties.getServerSSLPort());
// Create message of size 'messageSize'
/**
//" + serverHost + ":" + TestProperties.getServerSSLPort()) , methodName);
// Expected exception
/**
//" + serverHost + ":18883"), methodName);
// Expected exception
/* Copyright (c) 2009, 2014 IBM Corp.
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
// Some old clients do not support the new HA interface on the connect call
// If a client does not support the URI list in the connect options, then this test should fail.
// We ensure this happens by using a junk URI when creating the client. 
//junk:123");
// The first URI has a good protocol, but has a garbage hostname. 
// This ensures that a connect is attempted to the the second URI in the list 
//junk", serverURI.toString()};
// logger.info(e.getClass().getName() + ": " + e.getMessage());
/**
/**
/**
//iot.eclipse.org:1882");
// this would deadlock before fix
// -------------------------------------------------------------
// Helper methods/classes
// -------------------------------------------------------------
/**
// empty
/**
/**
/**
// publish messages until the queue is full > 10
// wait until the exception is thrown
// wait some time let client2 to shutdown because of the exception thrown from the callback
// client2 should be disconnected
// close client1
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
//localhost", "foo-bar");
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
//Tell the first client to go and let it publish for a couple of seconds
//Now lets take over the connection  
// Create a second MQTT client connection with the same clientid. The 
// server should spot this and kick the first client connection off. 
// To do this from the same box the 2nd client needs to use either
// a different form of persistent store or a different locaiton for 
// the store to the first client. 
// MqttClientPersistence persist = new MemoryPersistence();
//We should have taken over the first Client's subscription...we may have some
//of his publishes arrive.
// NOTE: as a different persistence is used for the second client any inflight 
// publications from the client will not be recovered / restarted. This will 
// leave debris on the server.
//Ignore his publishes that arrive...
//Now check we have grabbed his subscription by publishing..
// Don't fail - we are going to get an exception as we disconnected during takeOver
// Its likely the publish rate is too high i.e. inflight window is full
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
//@Test(timeout=150000)
/**
/**
/**
// Clean any hungover state
/**
// disconnect
// subscribe
// unsubscribe
// publish
// pendingDeliveryTokens 
// connect
// pendingDeliveryTokens
// disconnect
/**
/**
// ignore - cleanup for error cases, allow any previous exception to be seen
// TODO:
/**
/*
/**
/**
/**
/**
/**
/**
/**
/**
/**
// If the message is retained then we should wait for completion. If this isn't done there
// is a risk that a subsequent subscriber could be created to receive the message before it
// has been fully delivered and hence would not see the retained flag.
// For QoS0 messages, wait for completion takes no effect as there is no feedback from
// the server, and so even though not very deterministic, a small sleep is taken.
/**
/**
/**
/**
/**
/**
/**
/**
// Encode The String
// Decode the String
// Attempt to encode a negative number
// Attempt to encode a negative number
// System.out.println(String.format("'%s' is %d bytes, %d chars long",
// testString, testString.getBytes().length, testString.length()));
// System.out.println(String.format("'%s' is %d bytes, %d chars long",
// testString, testString.getBytes().length, testString.length()));
// System.out.println(String.format("'%s' is %d bytes, %d chars long",
// testString, testString.getBytes().length, testString.length()));
// System.out.println(String.format("'%s' is %d bytes, %d chars long",
// testString, testString.getBytes().length, testString.length()));
/**
/** Copyright (c)  2014 IBM Corp.
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
//host_literal:1883");
//host_literal:8883");
//host_literal:80/path/to/ws");
//host_literal:443/path/to/ws");
//host_literal:1883/somePath");
//host_literal:1883/somePath\"", e.getMessage());
//host_literal:1883/somePath");
//host_literal:1883");
//host_literal:1883\"", e
/**
//user:password@some_host:666/some_path");
/*
//localhost:666";
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
// empty
/**
/*
/* subscription handler should still exist on reconnect */
/* clean up by connecting cleansession */
/* subscription handler should still exist on reconnect */
/* clean up by connecting cleansession */
/* check unsubscribe removes handlers */
/*
// unsubscribe will remove the message handler
// but so will this
/* check can resubscribe after client object recreation */
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
// empty
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
// for...
// for...
// for publishers...
// for subscribers...
// for messages...
/**
// Clean start: true - The broker cleans up all client state, including subscriptions, when the client is disconnected.
// Clean start: false - The broker remembers all client state, including subscriptions, when the client is disconnected.
//                      Matching publications will get queued in the broker whilst the client is disconnected.
// For Mqtt V3 cleanSession=false, implies new subscriptions are durable.
// Disconnect and reconnect to make sure the subscription and all queued messages are cleared.
// Send a message from another client, to our durable subscription.
// Receive the publication so that we can be sure the first client has also received it.
// Otherwise the first client may reconnect with its clean session before the message has arrived.
// Reconnect and check we have no messages.
// Also check that subscription is cancelled.
/**
//keepAlive=30s
//10MB
/**
// Change the URI to a none MQTT server
//iot.eclipse.org:22");
//reuse the client instance to reconnect
/**
// how many QoS 0 tokens shall we track?
// Connect to the server
//time elapsed
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
/**
// for...
// for...
// for publishers...
// for subscribers...
// for messages...
/**
// Clean start: true  - The broker cleans up all client state, including subscriptions, when the client is disconnected.
// Clean start: false - The broker remembers all client state, including subscriptions, when the client is disconnected.
//                      Matching publications will get queued in the broker whilst the client is disconnected.
// For Mqtt V3 cleanSession=false, implies new subscriptions are durable.
// Disconnect and reconnect to make sure the subscription and all queued messages are cleared.
// Send a message from another client, to our durable subscription.
// Receive the publication so that we can be sure the first client has also received it.
// Otherwise the first client may reconnect with its clean session before the message has arrived.
// Reconnect and check we have no messages.
// Also check that subscription is cancelled.
// do nothing
// do nothing
/**
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
//" + TestProperties.getServerURI().getHost() + ":" +TestProperties.getServerSSLPort();
/**
//System.setProperty("javax.net.debug", "all");
/**
// System.setProperty("javax.net.debug", "all");
/**
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
// Configured to use the Paho Testing server localhost certificate
// certificateName = "server.crt";
/**
//" + serverHost + ":" + serverPort;
/**
//" + serverIP + ":" + serverPort;
// We want to make sure that the returned exception is an SSLHandshakeException
/**
//" + serverHost + ":" + websocketPort + "/ws";
/**
//" + serverIP + ":" + websocketPort + "/ws";
// We want to make sure that the returned exception is an SSLHandshakeException
/* Copyright (c) 2009, 2014 IBM Corp.
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
//bugs.eclipse.org/bugs/show_bug.cgi?id=482432
// Generate large byte array;
// -------------------------------------------------------------
// Helper methods/classes
// -------------------------------------------------------------
/**
// Wait a bit longer than usual because of the largePayloadTest
// empty
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// Use 0 for the first time.
/**
//localhost:" + proxy.getLocalPort(), clientId, DATA_STORE);
// give it some time to reconnect
/**
//localhost:" + proxy.getLocalPort(), clientId, DATA_STORE);
// give it some time to reconnect
/**
//localhost:" + proxy.getLocalPort(), clientId, DATA_STORE);
// Make sure the proxy is disabled and give it a second to close everything down
// Exceptions are good in this case!
// Enable The Proxy
// Give it some time to make sure we are still not connected
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
//" + serverURI.getHost() + ":" + serverURI.getPort();
// Use 0 for the first time.
/**
// Tokens
// Client Options
//localhost:" + proxy.getLocalPort(), methodName, DATA_STORE);
// Enable Proxy & Connect to server
// Disable Proxy and cause disconnect
// Publish Message
// Enable Proxy
// Check that we are connected
// give it some time to reconnect
// Check that Message has been delivered
/**
// Tokens
// Client Options
// Workaround for Issue #582 - Remove once fixed.
//options.setMaxInflight(100);
//localhost:" + proxy.getLocalPort(), methodName, DATA_STORE);
// Create subscription client that won't be affected by proxy
// Subscribe to topic
// Enable Proxy & Connect to server
// Disable Proxy and cause disconnect
// Publish msg_count messages
// Enable Proxy
// Check that we are connected
// give it some time to reconnect
// Check that all messages have been delivered
/**
// Tokens
// Client Options
//localhost:" + proxy.getLocalPort(), methodName, DATA_STORE);
// Set buffer to 100 to save time
// Enable Proxy & Connect to server
// Disable Proxy and cause disconnect
// Publish 100 messages
// Publish one message too many
// Make sure that the message now at index 0 in the buffer is '1'
// instead of '0'
/**
// Tokens
// Client Options
//localhost:" + proxy.getLocalPort(), methodName, DATA_STORE);
// Set buffer to 100 to save time
// Enable Proxy & Connect to server
// Disable Proxy and cause disconnect
// Publish 100 messages
/**
// Tokens
// Client Options
//localhost:" + proxy.getLocalPort(), methodName,
// Enable Proxy & Connect to server
// Disable Proxy and cause disconnect
// Make Sure persistence is empty before publish
// Publish Message
// Check that message is now in persistence layer
/**
// Mock up an Mqtt Message to be stored in Persistence
// If ID is not set, then the persisted message may be invalid for QoS 1 & 2
// Create Subscription client to watch for the message being published
// as soon as the main client connects
// Create Real client
// Connect Client with existing persistence layer
// Check that message is published / delivered
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
// not implemented
/**
// not implemented
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
// empty
/**
// empty
/**
// empty
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
// not implemented
/**
// not implemented
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Use 0 for the first time.
/**
//localhost:" + proxy.getLocalPort(), clientId, DATA_STORE);
// ignore
/**
//localhost:" + proxy.getLocalPort(), clientId, DATA_STORE);
// ignore
/**
//localhost:" + proxy.getLocalPort(), clientId, DATA_STORE);
// ignore
/**
//localhost:" + proxy.getLocalPort(), clientId, DATA_STORE);
/**
//localhost:" + proxy.getLocalPort(), clientId, DATA_STORE);
/**
//localhost:" + proxy.getLocalPort(), clientId, DATA_STORE);
//		log.info("Delivery Complete: " + token.getMessageId());
/**
//localhost:" + proxy.getLocalPort(), clientId, DATA_STORE);
// ignore
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
// Do nothing (the default implementation would close the stream!)
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
// do nothing
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
// do nothing
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
// sb.append("@" + Integer.toHexString(System.identityHashCode(l)) + " ");
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
// do nothing
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
//&lt;localhost&gt;:1883</code>> where <code>&lt;localhost&gt;</code> is expressed as a IPv4 dotted decimal value 
/**
/**
// empty
//" + localhost + ":1883";
// Make sure all the property classes we know about get initialised
/**
/**
/**
// Read the properties from the property file
// Override the default property values from SystemProperties
// Override the property values from SystemProperties
// Output the non-default properties
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
// Give it a second to close down
// TODO Auto-generated catch block
// Do nothing as we want to close;
// Wait for a connection on the local Port
// Attempt to make a connection to the real server
// Get Server Streams
// Read the Servers responses and pass them back to the client
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/** */
/** */
/**
/**
/**
/**
/**
/**
/**
// track time taken to receive messages
// Calculate new wait time based on experience, but not allowing it
// to get too small
/**
/**
/**
// Auto-generated method stub
/**
// Auto-generated method stub
/**
// logger.fine(methodName + ": '" + new String(message.getPayload()) + "'");
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/** Lookup the line separator once */
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/* (non-Javadoc)
//data.clear();
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* Copyright (c) 2009, 2014 IBM Corp.
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
// Skip over synthetic accessor methods
/**
/**
/**
/** 
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
// Do Nothing.
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
//bugs.eclipse.org/bugs/show_bug.cgi?id=481097
/*
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
//extends IMqttAsyncClient {
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// ms
// ms
// private String clientId;
// Automatic reconnect timer
// Reconnect delay, starts at 1
// second
// Simple lock
// Variables that exist within the life of an MQTT session
// Variables that exist within the life of an MQTT connection.
/**
//</code> for a TCP connection and
//</code> for a TCP connection secured by SSL/TLS. For example:
//localhost:1883</code></li>
//localhost:8883</code></li>
//</code>" URIs, and 8883 for <code>ssl://</code> URIs.
//", "ssl://" or "local://".
/**
//</code> for a TCP connection and
//</code> for a TCP connection secured by SSL/TLS. For example:
//localhost:1883</code></li>
//localhost:8883</code></li>
//</code>" URIs, and 8883 for <code>ssl://</code> URIs.
/**
//</code> for a TCP connection and
//</code> for a TCP connection secured by SSL/TLS. For example:
//localhost:1883</code></li>
//localhost:8883</code></li>
//</code>" URIs, and 8883 for <code>ssl://</code> URIs.
//", "ssl://" or "local://"
// Verify that the client ID is not too long
// Encode it ourselves to check
// Remove the two size bytes.
// @TRACE 101=<init> ClientID={0} ServerURI={1} PersistenceType={2}
/**
/**
// @TRACE 116=URI={0}
/**
// @TRACE 115=URI={0}
/*
/*
/*
/*
// @TRACE 103=cleanStart={0} connectionTimeout={1} TimekeepAlive={2}
// userName={3} password={4} will={5} userContext={6} callback={7}
// Insert our own callback to iterate through the URIs till the connect
// succeeds
// If we are using the MqttCallbackExtended, set it on the
// connectActionListener
/*
/*
/*
/*
// @TRACE 104=> quiesceTimeout={0} userContext={1} callback={2}
// @TRACE 105=< exception
// @TRACE 108=<
/*
/*
/*
/*
/*
/*
/*
/*
/*
/**
/* wildcards NOT allowed */, true);
/*
/*
// @TRACE 117=>
// @TRACE 118=<
/*
/*
/*
/*
/*
// remove any message handlers for individual topics and validate Topics
// Check if the topic filter is valid before subscribing
// Only Generate Log string if we are logging at FINE level
// @TRACE 106=Subscribe topicFilter={0} userContext={1} callback={2}
// TODO - Somehow refactor this....
// token.internalTok.setTopics(topicFilters);
// TODO - Build up MQTT Subscriptions properly here
// @TRACE 109=<
/*
/*
/*
/*
// add message handlers to the list for this client
// if the subscribe fails, then we have to remove the message handlers
/*
// Automatic Subscription Identifier Assignment is enabled
// Application is overriding the subscription Identifier
// Check that we are not already using this ID, else throw Illegal Argument
// Exception
// Automatically assign new ID and link to callback.
// add message handlers to the list for this client
// if the subscribe fails, then we have to remove the message handlers
/*
/*
/*
/*
// Only Generate Log string if we are logging at FINE level
// @TRACE 107=Unsubscribe topic={0} userContext={1} callback={2}
// Check if the topic filter is valid before unsubscribing
// Although we already checked when subscribing, but invalid
// topic filter is meanless for unsubscribing, just prohibit it
// to reduce unnecessary control packet send to broker.
/* allow wildcards */, this.mqttConnection.isSharedSubscriptionsAvailable());
// remove message handlers from the list for this client
// @TRACE 110=<
/*
/*
/*
/*
/*
/*
/*
/*
// @TRACE 111=< topic={0} message={1}userContext={1} callback={2}
// Checks if a topic is valid when publishing a message.
/* wildcards NOT allowed */, true);
// @TRACE 112=<
/*
// @Trace 500=Attempting to reconnect client: {0}
// Some checks to make sure that we're not attempting to reconnect an
// already connected client
// We don't want to spam the server
/**
// @Trace 500=Attempting to reconnect client: {0}
// @TRACE 804=exception
// @TRACE 804=exception
// @Trace 503=Start reconnect timer for client: {0}, delay: {1}
// @Trace 504=Stop reconnect timer for client: {0}
// Reset Delay Timer
// @Trace 506=Triggering Automatic Reconnect attempt.
// Automatic reconnect is set so make sure comms is in resting
// state
// @Trace 501=Automatic Reconnect Successful: {0}
// @Trace 502=Automatic Reconnect failed, rescheduling: {0}
// @Trace 505=Rescheduling reconnect timer for client: {0}, delay:
// {1}
// The previous reconnect timer was cancelled
/*
/*
/*
/*
/*
/*
/*
// @TRACE 113=<
// @TRACE 114=>
/*
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Delegate implementation to MqttAsyncClient
// How long each method should wait for action to complete
/**
//</code> for a TCP connection and
//</code> for a TCP connection secured by SSL/TLS. For example:
//localhost:1883</code></li>
//localhost:8883</code></li>
//</code>" URIs, and 8883 for <code>ssl://</code> URIs.
//", "ssl://" or "local://".
/**
//</code> for a TCP connection and
//</code> for a TCP connection secured by SSL/TLS. For example:
//localhost:1883</code></li>
//localhost:8883</code></li>
//</code>" URIs, and 8883 for <code>ssl://</code> URIs.
//", "ssl://" or "local://"
/**
//</code> for a TCP connection and
//</code> for a TCP connection secured by SSL/TLS. For example:
//localhost:1883</code></li>
//localhost:8883</code></li>
//</code>" URIs, and 8883 for <code>ssl://</code> URIs.
//", "ssl://" or "local://"
/*
/*
/*
/*
/*
/*
/*
/*
/**
/*
/*
/*
/*
/*
// message handlers removed in the async client unsubscribe below
/*
/*
/**
/**
/*
/*
/*
/*
/*
/**
//bugs.eclipse.org/bugs/show_bug.cgi?id=481097
/*
/*
/*
/*
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/** Unable to connect to server */
/**
/**
//</code> must use a
//</code>
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
// CONNACK return codes
/** The protocol version requested is not supported by the server. */
/** The server has rejected the supplied client ID */
/** The broker was not available to handle the request. */
/**
/** Not authorized to perform the requested operation */
/** An unexpected error has occurred. */
/** Error from subscribe - returned from the server. */
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Connection Behaviour Properties
// List of Servers to connect to in order
// Automatic Reconnect
// Time to wait before first automatic reconnection attempt in seconds.
// Max time to wait for automatic reconnection attempts in seconds.
// Whether to automatically assign subscription identifiers.
// Keep Alive Interval
// Connection timeout in seconds
// Connection packet properties
// MQTT Version 5
// Clean Session
// Will Topic
// Will Message
// Username
// Password
// The Session expiry Interval in seconds, null is the default of
// never.
// The Receive Maximum, null defaults to 65,535, cannot be 0.
// The Maximum packet size, null defaults to no limit.
// The Topic Alias Maximum, null defaults to 0.
// Request Response Information, null defaults to false.
// Request Problem Information, null defaults to true.
// User Defined Properties.
// Authentication Method, If null, Extended Authentication is not performed.
// Authentication Data.
// TLS Properties
// SocketFactory to be used to connect
// SSL Client Properties
// SSL Hostname Verifier
// Client Operation Parameters
// How long to wait in seconds when terminating the executor service.
/**
/**
/**
/**
/**
/**
/**
/**
// Wildcards are not allowed
// Prevent any more changes to the will message
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
//</code> for
//</code> for a TCP connection secured by
//localhost:1883</code></li>
//localhost:8883</code></li>
//</code>" URIs, and 8883 for <code>ssl://</code> URIs.
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
//@Trace 659=start timer for client:{0}
//Check ping after first keep alive interval.
//Check ping after first keep alive interval.
//@Trace 661=stop
//@Trace 660=Check schedule at {0}
//@Trace 660=Check schedule at {0}
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
// TODO Should this be logged?
// TODO Should this be logged?
// An invalid topic alias combination was recieved.
/**
/**
/**
/**
/**
/**
/** Unable to connect to server */
/**
/**
//</code> must use a
//</code>
/**
/**
/**
/**
/**
/**
/**
/**
/**
// CONNACK return codes
/** The protocol version requested is not supported by the server. */
/** The server has rejected the supplied client ID */
/** The broker was not available to handle the request. */
/**
/** Not authorized to perform the requested operation */
/** An unexpected error has occurred. */
/** Error from subscribe - returned from the server. */
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Used to synchronize connection state
/**
/**
// @TRACE 200=internalSend key={0} message={1} token={2}
// Associate the client with the token - also marks it as in use.
// Token is already in use - cannot reuse
// @TRACE 213=fail: token in use: key={0} message={1} token={2}
// Persist if needed and send the message
// undo client setting on error
/**
// @TRACE 507=Client Connected, Offline Buffer available, but not empty. Adding
// message to buffer. message={0}
// If the message is a publish, strip the topic alias:
// Override the QoS if the server has set a maximum
// Override the Retain flag if the server has disabled it
// @TRACE 508=Client Resting, Offline Buffer available. Adding message to
// buffer. message={0}
// @TRACE 208=failed: not connected
/**
// Must be disconnected before close can take place or if we are being forced
// @TRACE 224=failed: not disconnected
// Don't shut down an externally supplied executor service 
//shutdownExecutorService();
// ShutdownConnection has already cleaned most things
/**
// @TRACE 214=state=CONNECTING
/*
// @TRACE 207=connect failed: not disconnected {0}
// We've successfully connected
// @TRACE 215=state=CONNECTED
// @TRACE 204=connect failed: rc={0}
/**
// Token to notify after disconnect completes
// This method could concurrently be invoked from many places only allow it
// to run once.
// @TRACE 216=state=DISCONNECTING
// Update the token with the reason for shutdown if it
// is not already complete.
// Stop the thread that is used to call the user back
// when actions complete
// Stop the thread that handles inbound work from the network
// Stop the network module, send and receive now not possible
// Ignore as we are shutting down
// Stop any new tokens being saved by app and throwing an exception if they do
// Notify any outstanding tokens with the exception of
// con or discon which may be returned and will be notified at
// the end
// Clean session handling and tidy up
// Ignore as we are shutting down
// Ignore as we are shutting down
// All disconnect logic has been completed allowing the
// client to be marked as disconnected.
// @TRACE 217=state=DISCONNECTED
// Internal disconnect processing has completed. If there
// is a disconnect token or a connect in error notify
// it now. This is done at the end to allow a new connect
// to be processed and now throw a currently disconnecting error.
// any outstanding tokens and unblock any waiters
// Let the user know client has disconnected either normally or abnormally
// While disconnecting, close may have been requested - try it now
// ignore any errors as closing
// Tidy up. There may be tokens outstanding as the client was
// not disconnected/quiseced cleanly! Work out what tokens still
// need to be notified and waiters unblocked. Store the
// disconnect or connect token to notify after disconnect is
// complete.
// @TRACE 222=>
// First the token that was related to the disconnect / shutdown may
// not be in the token table - temporarily add it if not
// Its con or discon so remember and notify @ end of disc routine
// notify waiters and callbacks of outstanding tokens
// that a problem has occurred and disconnect is in
// progress
// Ignore as we are shutting down
// @TRACE 223=failed: in closed state
// @TRACE 211=failed: already disconnected
// @TRACE 219=failed: already disconnecting
// @TRACE 210=failed: called on callback thread
// Not allowed to call disconnect() from the callback, as it will deadlock.
// @TRACE 218=state=DISCONNECTING
/**
// Allow current inbound and outbound work to complete
// Send disconnect packet
// Wait util the disconnect packet sent with timeout
// ignore, probably means we failed to send the disconnect packet.
// Kick off the connect processing in the background so that it does not block.
// For instance
// the socket could take time to create.
// @TRACE 220=>
// Reset an exception on existing delivery tokens.
// This will have been set if disconnect occurred before delivery was
// fully processed.
// Save the connect token in tokenStore as failure can occur before send
// Connect to the server at the network level e.g. TCP socket and then
// start the background processing threads before sending the connect
// packet.
// @TRACE 212=connect failed: unexpected exception
// @TRACE 209=connect failed: unexpected exception
// Kick off the disconnect processing in the background so that it does not
// block. For instance
// the quiesce
// @TRACE 221=>
// Allow current inbound and outbound work to complete
// do not wait if the sender process is not running
// if the sender process is not running 
/*
/*
// @TRACE 804=exception
/**
/**
// @TRACE 509=Client Reconnected, Offline Buffer Available. Sending Buffered
// Messages.
// @TRACE 510=Publising Buffered message message={0}
// Delete from persistence if in there
// @TRACE 208=failed: not connected
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Lowest possible MQTT message ID to use
// Highest possible MQTT message ID to use
// The next available message ID to use
// Used to store a set of in-use message IDs
//private long keepAlive;
// Topic Alias Maps
// @TRACE 603=clearState
// @TRACE=665=Clearing Connection State (Topic Aliases)
// @TRACE 602=key={0} exception
// Premature end-of-file means that the message is corrupted
// @TRACE 601=key={0} message={1}
/**
/**
// here up the new list
// nothing to reorder
// last in the sorted list
// we need to check that the gap after highest msg id to the lowest msg id is
// not beaten
// starting message has been located, let's start from this point on
// and any wrapping back to the beginning
/**
// @TRACE 600=>
// @TRACE 604=inbound QoS 2 publish key={0} message={1}
// The inbound messages that we have persisted will be QoS 2
// QoS 2, and CONFIRM has already been sent...
// NO DUP flag is allowed for 3.1.1 spec while it's not clear for 3.1 spec
// So we just remove DUP
// confirmMessage.setDuplicate(true); // REMOVED
// @TRACE 605=outbound QoS 2 pubrel key={0} message={1}
// @TRACE 606=outbound QoS 2 completed key={0} message={1}
// QoS 1 or 2, with no CONFIRM sent...
// Put the SEND to the list of pending messages, ensuring message ID ordering...
// @TRACE 607=outbound QoS 2 publish key={0} message={1}
// @TRACE 608=outbound QoS 1 publish key={0} message={1}
// Buffered outgoing messages that have not yet been sent at all
// @TRACE 607=outbound QoS 2 publish key={0} message={1}
// @TRACE 608=outbound QoS 1 publish key={0} message={1}
// @TRACE 511=outbound QoS 0 publish key={0} message={1}
// Because there is no Puback, we have to trust that this is enough to send the
// message
// @TRACE 609=removing orphaned pubrel key={0}
// @TRACE 610=QoS 2 publish key={0}
// set DUP flag only for PUBLISH, but NOT for PUBREL (spec 3.1.1)
// @TRACE 611=QoS 2 pubrel key={0}
// @TRACE 612=QoS 1 publish key={0}
// @TRACE 512=QoS 0 publish key={0}
/*
// Set Message ID if required
// Set Topic Alias if required
// Existing Topic Alias, Assign it and remove the topic string
// Create a new Topic Alias and increment the counter
// @TRACE 613= sending {0} msgs at max inflight window
// @TRACE 628=pending publish key={0} qos={1} message={2}
// @TRACE 615=pending send key={0} message {1}
// Add the connect action at the head of the pending queue ensuring it jumps
// ahead of any of other pending actions.
/*
// Because the client will have disconnected, we will want to re-open
// persistence
// @TRACE 515=Could not Persist, attempting to Re-Open Persistence Store
// @TRACE 513=Persisted Buffered Message key={0}
// @TRACE 514=Failed to persist buffered message key={0}
/*
// @TRACE 517=Un-Persisting Buffered message key={0}
// @TRACE 518=Failed to Un-Persist Buffered message key={0}
/**
// @TRACE 618=key={0} QoS={1}
// Free this message Id so it can be used again
// Set the messageId to 0 so if it's ever retried, it will get a new messageId
/*
// @TRACE 616=checkForActivity entered
// ref bug: https://bugs.eclipse.org/bugs/show_bug.cgi?id=440698
// No ping while quiescing
// Reduce schedule frequency since System.currentTimeMillis is no accurate, add
// a buffer (This might not be needed since we moved to nanoTime)
// It is 1/10 in minimum keepalive unit.
// ref bug: https://bugs.eclipse.org/bugs/show_bug.cgi?id=446663
// Is the broker connection lost because the broker did not reply to my ping?
// lastInboundActivity will be updated once receiving is done.
// Add a delta, since the timer and System.currentTimeMillis() is not accurate.
// (This might not be needed since we moved to nanoTime)
// A ping is outstanding but no packet has been received in KA so connection is
// deemed broken
// @TRACE 619=Timed out as no activity, keepAlive={0} lastOutboundActivity={1}
// lastInboundActivity={2} time={3} lastPing={4}
// A ping has already been sent. At this point, assume that the
// broker has hung and the TCP layer hasn't noticed.
// Is the broker connection lost because I could not get any successful write
// for 2 keepAlive intervals?
// I am probably blocked on a write operations as I should have been able to
// write at least a ping message
// A ping has not been sent but I am not progressing on the current write
// operation.
// At this point, assume that the broker has hung and the TCP layer hasn't
// noticed.
// 1. Is a ping required by the client to verify whether the broker is down?
// Condition: ((pingOutstanding == 0 && (time - lastInboundActivity >= keepAlive
// + delta)))
// In this case only one ping is sent. If not confirmed, client will assume a
// lost connection to the broker.
// 2. Is a ping required by the broker to keep the client alive?
// Condition: (time - lastOutboundActivity >= keepAlive - delta)
// In this case more than one ping outstanding may be necessary.
// This would be the case when receiving a large message;
// the broker needs to keep receiving a regular ping even if the ping response
// are queued after the long message
// If lacking to do so, the broker will consider my connection lost and cut my
// socket.
// @TRACE 620=ping needed. keepAlive={0} lastOutboundActivity={1}
// lastInboundActivity={2}
// pingOutstanding++; // it will be set after the ping has been written on the
// wire
// lastPing = time; // it will be set after the ping has been written on the
// wire
// Wake sender thread since it may be in wait state (in ClientState.get())
// @TRACE 624=Schedule next ping at {0}
/**
// If there is no work wait until there is work.
// If the inflight window is full and no flows are pending wait until space is
// freed.
// In both cases queueLock will be notified.
// @TRACE 644=wait for new work or for space in the inflight window
// @TRACE 647=new work or ping arrived
// Handle the case where not connected. This should only be the case if:
// - in the process of disconnecting / shutting down
// - in the process of connecting
// @TRACE 621=no outstanding flows and not connected
// Check if there is a need to send a ping to keep the session alive.
// Note this check is done before processing messages. If not done first
// an app that only publishes QoS 0 messages will prevent keepalive processing
// from functioning.
// checkForActivity(); //Use pinger, don't check here
// Now process any queued flows or messages
// Process the first "flow" in the queue
// @TRACE 617=+1 inflightpubrels={0}
// If the inflight window is full then messages are not
// processed until the inflight window has space.
// The in flight window is not full so process the
// first message in the queue
// @TRACE 623=+1 actualInFlight={0}
// @TRACE 622=inflight window full
// end while
// synchronized
/*
// @TRACE 643=sent bytes count={0}
/**
// @TRACE 625=key={0}
// @TRACE 635=ping sent. pingOutstanding: {0}
// once a QoS 0 message is sent we can clean up its records straight away as
// we won't be hearing about it again
// @TRACE 646=-1 actualInFlight={0}
// if (quiescing && actualInFlight == 0 && pendingFlows.size() == 0 &&
// inFlightPubRels == 0 && callback.isQuiesced()) {
// @TRACE 626=quiescing={0} actualInFlight={1} pendingFlows={2}
// inFlightPubRels={3} callbackQuiesce={4} tokens={5}
/*
// @TRACE 630=received bytes count={0}
/**
// @TRACE 627=received key={0} message={1}
// @TRACE 662=no message found for ack id={0}
// @TRACE 664=[MQTT-4.3.3-4] - A Reason code greater than 0x80 (128) was
// received in an incoming PUBREC id={0} rc={1} message={2}, halting QoS 2 flow.
// Update the token with the reason codes
// Complete the QoS 2 flow. Unlike all other
// flows, QoS is a 2 phase flow. The second phase sends a
// PUBREL - the operation is not complete until a PUBCOMP
// is received
// Currently this client has no need of the properties, so this is left empty.
// QoS 1 & 2 notify users of result before removing from
// persistence
// Do not remove publish / delivery token at this stage
// do this when the persistence is removed later
// @TRACE 636=ping response received. pingOutstanding: {0}
// Add the connect token back in so that users can be
// notified when connect completes.
// Notify the sender thread that there maybe work for it to do now
/**
// @TRACE 666=Orphaned Ack key={0} message={1}
// MqttPubAck - This would be the end of a QoS 1 flow, so message can be ignored
// MqttPubRec - Send an MqttPubRel with the appropriate Reason Code
// MqttPubComp
/**
// @TRACE 667=MqttPubRel was received with an error code: key={0} message={1},
// Reason Code={2}
// Currently this client has no need of the properties, so this is left empty.
// @TRACE 668=Creating MqttPubComp: {0}
/**
// @TRACE 651=received key={0} message={1}
// Do we have an incoming topic Alias?
// Are incoming Topic Aliases enabled / is it a valid Alias?
// @TRACE 653=Invalid Topic Alias: topicAliasMax={0}, publishTopicAlias={1}
// Is this alias being sent with a topic string?
// @TRACE 652=Setting Incoming New Topic Alias alias={0}, topicName={1}
// No Topic String, so must be in incomingTopicAliases.
// @TRACE 654=Unknown Topic Alias: Incoming Alias={1}
// Currently this client has no need of the properties, so this is left empty.
// should NOT reach here
/**
// @TRACE 629=received key={0} token={1} message={2}
// QoS 1 - user notified now remove from persistence...
// @TRACE 650=removed Qos 1 publish. key={0}
// QoS 2 - user notified now remove from persistence...
// @TRACE 645=removed QoS 2 publish/pubrel. key={0}, -1 inFlightPubRels={1}
/**
// unblock any threads waiting on the token
// Let the user know an async operation has completed and then remove the token
// @TRACE 648=key{0}, msg={1}, excep={2}
// There are cases where there is no ack as the operation failed before
// an ack was received
// @TRACE 649=key={0},excep={1}
/*
// @TRACE 631=connected
// Start ping thread when client connected to server.
/*
// @TRACE 632=reason {0}
// If any outstanding let the user know the reason why it is still
// outstanding by putting the reason shutdown is occurring into the
// token.
// Set the token up so it is ready to be notified after disconnect
// processing has completed. Do not
// remove the token from the store if it is a delivery token, it is
// valid after a reconnect.
// If not a delivery token it is not valid on
// restart so remove
/*
// @TRACE 633=disconnected
// Reset pingOutstanding to allow reconnects to assume no previous ping.
// Ignore as we have disconnected at this point
/**
/**
// Allow two complete passes of the message ID range. This gives
// any asynchronous releases a chance to occur
/*
// If the timeout is greater than zero t
// @TRACE 637=timeout={0}
// We don't want to handle any new inbound messages
// If token count is not zero there is outbound work to process and
// if pending flows is not zero there is outstanding work to complete and
// if call back is not quiseced there it needs to complete.
// @TRACE 639=wait for outstanding: actualInFlight={0} pendingFlows={1}
// inFlightPubRels={2} tokens={3}
// wait for outstanding in flight messages to complete and
// any pending flows to complete
// Don't care, as we're shutting down anyway
// Quiesce time up or inflight messages delivered. Ensure pending delivery
// vectors are cleared ready for disconnect to be sent as the final flow.
// @TRACE 640=finished
/*
// @TRACE 638=notifying queueLock holders
// @TRACE 641=remove publish from persistence. key={0}
// @TRACE 641=remove publish from persistence. key={0}
/*
/**
/*
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Map of message handler callbacks to internal IDs
// Map of Topic Strings to internal callback Ids
// Map of Subscription Ids to callback Ids
/**
// Preparatory work before starting the background thread.
// For safety ensure any old events are cleared.
/**
// @TRACE 700=stopping
// @TRACE 701=notify workAvailable and wait for run
// to finish
// Wait for the thread to finish.
// @TRACE 703=stopped
// If no work is currently available, then wait until there is some...
// @TRACE 704=wait for workAvailable
// Check for deliveryComplete callbacks...
// First call the delivery arrived callback if needed
// Check for messageArrived callbacks...
// Note, there is a window on connect where a publish
// could arrive before we've
// finished the connect logic.
// Users code could throw an Error or Exception e.g. in the case
// of class NoClassDefFoundError
// @TRACE 714=callback threw exception
// Notify the spaceAvailable lock, to say that there's now
// some space on the queue...
// @TRACE 706=notify spaceAvailable
// @TRACE 705=callback and notify for key={0}
// Finish by doing any post processing such as delete
// from persistent store but only do so if the action
// is complete
// Unblock any waiters and if pending complete now set completed
// If a callback is registered and delivery has finished
// call delivery complete callback.
// Just log the fact that an exception was thrown
// @TRACE 726=Ignoring Exception thrown from deliveryComplete {0}
// Now call async action completion callbacks
// Set notified so we don't tell the user again about this action.
/**
// If there was a problem and a client callback has been set inform
// the connection lost listener of the problem.
// @TRACE 722=Server initiated disconnect, connection closed. Disconnect={0}
// @TRACE 708=call connectionLost
// Just log the fact that an exception was thrown
// @TRACE 720=Ignoring Exception thrown from connectionLost {0}
/**
// @TRACE 716=call onSuccess key={0}
// @TRACE 717=call onFailure key {0}
/**
// If we already have enough messages queued up in memory, wait
// until some more queue space becomes available. This helps
// the client protect itself from getting flooded by messages
// from the server.
// @TRACE 709=wait for spaceAvailable
// Notify the CommsCallback thread that there's work to do...
// @TRACE 710=new msg avail, notify workAvailable
/**
// Just log the fact that an exception was thrown
// @TRACE 727=Ignoring Exception thrown from authPacketArrived {0}
/**
// Just log the fact that an exception was thrown
// @TRACE 724=Ignoring Exception thrown from mqttErrorOccurred: {0}
/**
// @TRACE 711=quiesce notify spaceAvailable
// Unblock anything waiting for space...
// If quisecing process any pending messages.
// @TRACE 713=call messageArrived key={0} topic={1}
// If we are not in manual ACK mode:
// @TRACE 723=Creating MqttPubComp due to manual ACK: {0}
// invoke callbacks on callback thread
// @TRACE 715=new workAvailable. key={0}
// invoke async callback on invokers thread
// Users code could throw an Error or Exception e.g. in the case
// of class NoClassDefFoundError
// @TRACE 719=callback threw ex:
// Shutdown likely already in progress but no harm to confirm
/**
/**
// Reverse lookup the subscription ID if it exists to remove that as well
/**
// Reverse lookup the topic if it exists to remove that as well
// No Subscription IDs, use topic filter matching
// We have Subscription IDs
/*
// Just log the fact that an exception was thrown
// @TRACE 725=Ignoring Exception thrown from messageArrived: {0}
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
// @TRACE 855=starting
/**
//@TRACE 850=stopping
//@TRACE 851=stopped
/**
//@TRACE 852=network read message
// instanceof checks if message is null
// Ensure the notify processing is done under a lock on the token
// This ensures that the send processing can complete before the
// receive processing starts! ( request and ack and ack processing
// can occur before request processing is complete if not!
// This is an ack for a message we no longer have a ticket for.
// This is a Disconnect Message
// A new message has arrived
// @TRACE 856=Stopping, MQttException
// Token maybe null but that is handled in shutdown
// @TRACE 853=Stopping due to IOException
// An EOFException could be raised if the broker processes the
// DISCONNECT and ends the socket before we complete. As such,
// only shutdown the connection if we're not already shutting down.
// end while
// end try
//@TRACE 854=<
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
//Sends MQTT packets to the server on its own thread
/**
/**
//@TRACE 800=stopping sender
//@TRACE 801=stopped
//@TRACE 802=network send key={0} msg={1}
// While quiescing the tokenstore can be cleared so need
// to check for null for the case where clear occurs
// while trying to send a message.
// The flush has been seen to fail on disconnect of a SSL socket
// as disconnect is in progress this should not be treated as an error
// null message
//@TRACE 803=get message returned null, stopping}
// end while
//@TRACE 805=<
//@TRACE 804=exception
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Maps message-specific data (usually message IDs) to tokens
//@TRACE 308=<>
//,new Object[]{message});
/**
//@TRACE 306=key={0}
/**
//@TRACE 302=existing key={0} message={1} token={2}
//@TRACE 303=creating new token key={0} message={1} token={2}
// For outbound messages store the token in the token store 
// For pubrel use the existing publish token 
//@TRACE 300=key={0} message={1}
//@TRACE 307=key={0} token={1}
//@TRACE 309=resp={0}
//@TRACE 310=>
//@TRACE 311=>
//@TRACE 312=>
/**
//@TRACE 305=> {0} tokens
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
// Set properties imposed on us by the Server
// If provided, set the server keep alive value.
// If we are assigning the client ID post connect, then we need to re-initialise
// our persistence layer.
// If we fail to open persistence at this point, our best bet is to immediately
// close the connection.
// fix bug 469527 - maybe should be set elsewhere?
// Just catch any exceptions thrown here and ignore.
/**
// try the next URI in the list
// fix bug 469527 - maybe should be set elsewhere?
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// Used to synchronise the buffer
/**
/**
/**
/**
/**
// @TRACE 516=Restoring all buffered messages.
// Publish was successful, remove message from buffer.
// If we get the max_inflight condition, try again after a short
// interval to allow more messages to be completely sent.
// Error occurred attempting to publish buffered message likely because the client is not connected
// @TRACE 519=Error occurred attempting to publish buffered message due to disconnect. Exception: {0}.
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
// Utility classes should not have a public or default constructor.
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
// Create a file to obtain a lock on. 
// Lock not obtained
/**
// Ignore exceptions
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Hide this class reference behind reflection so that the class does not need to
// be present when compiled on midp
/**
// ******* Connection properties ******//
// ******* Counters ******//
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// Message key
// Message header
// Message payload
/**
/**
// ******* Session Specific Properties and counters ******//
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/*
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/** Pattern to match URI authority parts: {@code authority = [userinfo"@"]host[":"port]} */
// no instances
/**
/**
/*
/**
//tools.ietf.org/html/rfc3986#section-3.2
// already successfully parsed
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
//MAY throws MissingResourceException
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
// @TRACE 260=setEnabledCiphers ciphers={0}
// RTC 765: Set a timeout to avoid the SSL handshake being blocked indefinitely
// SNI support.  Should be automatic under some circumstances - not all, apparently
// If default Hostname verification is enabled, use the same method that is used with HTTPS
// reset timeout to default value
//" + host + ":" + port;
/*
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// -1 if not defined
//			try {
//			}
//			catch (MqttDirectException ex) {
//				throw ExceptionHelper.createMqttException(ex.getCause());
//			}
// Create the network module...
// Ciphers suites need to be set, if they are available
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
// @TRACE 252=connect to host {0} port {1} timeout {2}
//@TRACE 250=Failed to create TCP socket
/**
// CDA: an attempt is made to stop the receiver cleanly before closing the socket.
// If the socket is forcibly closed too early, the blocking socket read in
// the receiver thread throws a SocketException.
// While this causes the receiver thread to exit, it also invalidates the
// SSL session preventing to perform an accelerated SSL handshake in the
// next connection.
//
// Also note that due to the blocking socket reads in the receiver thread,
// it's not possible to interrupt the thread. Using non blocking reads in
// combination with a socket timeout (see setSoTimeout()) would be a better approach.
//
// Please note that the Javadoc only says that an EOF is returned on
// subsequent reads of the socket stream.
// Anyway, at least with Oracle Java SE 7 on Linux systems, this causes a blocked read
// to return EOF immediately.
// This workaround should not cause any harm in general but you might
// want to move it in SSLNetworkModule.
/**
//" + host + ":" + port;
/*
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// -1 if not defined
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// @TRACE 407=key={0} wait max={1} token={2}
/*||
// @TRACE 406=key={0} timed out token={1}
/**
// @TRACE 400=>key={0} timeout={1} sent={2} completed={3} hasException={4}
// response={5} token={6}
// @TRACE 408=key={0} wait max={1}
// @TRACE 401=failed with exception
// time up and still not completed
// @TRACE 402=key={0} response={1}
/**
// @TRACE 411=>key={0} response={1} excep={2}
/**
/**
// @TRACE 404=>key={0} response={1} excep={2}
// If reason codes are available, store them here.
// ACK means that everything was OK, so mark the message for garbage collection.
/**
// @TRACE 411=>key={0} response={1} excep={2}
// If pending complete is set then normally the token can be marked
// as complete and users notified. An abnormal error may have
// caused the client to shutdown beween pending complete being set
// and notifying the user. In this case - the action must be failed.
// /**
/**
// * used for things like IOException, and not for MQTT NACKs.
// */
// protected void notifyException() {
// final String methodName = "notifyException";
// //@TRACE 405=token={0} excep={1}
// log.fine(CLASS_NAME,methodName, "405",new Object[]{this,this.exception});
// synchronized (responseLock) {
// responseLock.notifyAll();
// }
// synchronized (sentLock) {
// sentLock.notifyAll();
// }
// }
// @TRACE 409=wait key={0}
/**
// @TRACE 403=> key={0}
// Token is already in use - cannot reset
// @TRACE 410=> key={0}
// TODO - Work out how to map multiple returncodes
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
//		loggerName = "org.eclipse.paho.mqttv5.client." + ((null == loggerID || 0 == loggerID.length()) ? "internal" : loggerID);
// || InternalTracer.isLoggable(level);
//		InternalTracer.log(this.catalogID, level, sourceClass, sourceMethod, msg, inserts, thrown);
//	public void setTrace(Trace trace) {
//		InternalTracer.setTrace(trace);
//	}
//		if (FINE == level || isJULLoggable || InternalTracer.isLoggable(level)) {
//			InternalTracer.traceForced(level, sourceClass, sourceMethod, msg, inserts);
//		}
// This is acceptable, simply return the given msg string.
//		LogRecord logRecord = new LogRecord(julLevel, msg);
//		logRecord.setResourceBundleName(catalogName);
//		logRecord.setResourceBundle(messageCatalog);
//		if (null != inserts) {
//			logRecord.setParameters(inserts);
//		}
// synchronized (handler).
// for handlers...
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
//			logger = getJSR47Logger(ResourceBundle.getBundle(messageCatalogName), loggerID, null) ;
//		}
/**
//, FFDC ffdc) {
// Now instantiate the log
/**
// Hide behind reflection as java.util.logging is guaranteed to be
// available.
// Any error, assume JSR47 isn't available and return null
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
// ignore
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
//TODO
//throws MqttPersistenceException {
/**
//throws MqttPersistenceException {
//If lock was previously acquired, release before requesting a new one
// TODO - This shouldn't be here according to the interface
// See https://github.com/eclipse/paho.mqtt.java/issues/178
//throw new MqttPersistenceException(MqttPersistenceException.REASON_CODE_PERSISTENCE_IN_USE);
// Scan the directory for .backup files. These will
// still exist if the JVM exited during addMessage, before
// the new message was written to disk and the backup removed.
/**
// checkIsOpen();
/**
// Backup the existing file so the overwrite can be rolled-back 
// The write has completed successfully, delete the backup 
// The write has failed - restore the backup
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// if this string is changed, then the decode method must also be adapted.
/**
// Allocate a string buffer.
// j==2 | j==1 | j==0
// there is a rest of 2 bytes. This encodes into 3 chars.
// there is a rest of 1 byte. This encodes into 1 char.
// j==3 | j==2 
/* the core conding routine. Translates an input integer into
/*
// convert encoded[idx] back into a 6-bit value.
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
// "SSL_TLS" is not supported by DesktopEE
// a hashtable that maps configIDs to properties.
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
// can't use split as split is not available on all java platforms.
// handle all commas.
// add stuff before and up to (but not including) the comma.
// skip the comma.
// add last element after the comma or only element if no comma is present.
/**
/**
//	private Properties getOrCreate(String configID) {
//		Properties res = null;
//		if (configID == null) {
//			if (this.defaultProperties == null) {
//				this.defaultProperties = new Properties();
//			}
//			res = this.defaultProperties;
//		} else {
//			res = (Properties) this.configs.get(configID);
//			if (res == null) {
//				res = new Properties();
//				this.configs.put(configID, res);
//			}
//		}
//		return res;
//	}
/**
// copy the properties.
/**
/**
/**
/**
//	public String[] getConfigurationIDs() {
//		Set s = this.configs.keySet();
//		String[] configs = new String[s.size()];
//		configs = (String[]) s.toArray(configs);
//		return configs;
//	}
/**
//	private final void putOrRemove(Properties p, String key, String value) {
//		if (value == null) {
//			p.remove(key);
//		} else {
//			p.put(key, value);
//		}
//	}
/**
//	public void setSSLProtocol(String configID, String protocol) {
//		Properties p = getOrCreate(configID);
//		putOrRemove(p, SSLPROTOCOL, protocol);
//	}
/**
//	public void setJSSEProvider(String configID, String provider) {
//		Properties p = getOrCreate(configID);
//		putOrRemove(p, JSSEPROVIDER, provider);
//	}
/**
//	public void setKeyStore(String configID, String keyStore) {
//		if (keyStore == null)
//			return;
//		Properties p = getOrCreate(configID);
//		putOrRemove(p, KEYSTORE, keyStore);
//	}
/**
//	public void setKeyStorePassword(String configID, char[] password) {
//		if (password == null)
//			return;
//		Properties p = getOrCreate(configID);
//		// convert password, using XOR-based scrambling.
//		String ePasswd = obfuscate(password);
//		for(int i=0;i<password.length;i++) {
//			password[i]=' ';
//		}
//		putOrRemove(p, KEYSTOREPWD, ePasswd);
//	}
/**
//	public void setKeyStoreProvider(String configID, String provider) {
//		Properties p = getOrCreate(configID);
//		putOrRemove(p, KEYSTOREPROVIDER, provider);
//	}
/**
//	public void setKeyStoreType(String configID, String type) {
//		Properties p = getOrCreate(configID);
//		putOrRemove(p, KEYSTORETYPE, type);
//	}
/**
//	public void setCustomKeyManager(String configID, String keymanager) {
//		Properties p = getOrCreate(configID);
//		putOrRemove(p, CUSTOMKEYMGR, keymanager);
//	}
/**
//	public void setTrustStore(String configID, String trustStore) {
//		Properties p = getOrCreate(configID);
//		putOrRemove(p, TRUSTSTORE, trustStore);
//	}
/**
//	public void setTrustStorePassword(String configID, char[] password) {
//		Properties p = getOrCreate(configID);
//		// convert password, using XOR-based scrambling.
//		String ePasswd = obfuscate(password);
//		for(int i=0;i<password.length;i++) {
//			password[i]=' ';
//		}
//		putOrRemove(p, TRUSTSTOREPWD, ePasswd);
//	}
/**
//	public void setTrustStoreProvider(String configID, String provider) {
//		Properties p = getOrCreate(configID);
//		putOrRemove(p, TRUSTSTOREPROVIDER, provider);
//	}
/**
//	public void setTrustStoreType(String configID, String type) {
//		Properties p = getOrCreate(configID);
//		putOrRemove(p, TRUSTSTORETYPE, type);
//	}
/**
//	public void setCustomTrustManager(String configID, String trustmanager) {
//		Properties p = getOrCreate(configID);
//		putOrRemove(p, CUSTOMTRUSTMGR, trustmanager);
//	}
/**
//	public void setEnabledCipherSuites(String configID, String[] ciphers) {
//		if (ciphers == null)
//			return;
//		Properties p = getOrCreate(configID);
//		String cipherSet = packCipherSuites(ciphers);
//		putOrRemove(p, CIPHERSUITES, cipherSet);
//	}
/**
//	public void setClientAuthentication(String configID, boolean clientAuth) {
//		Properties p = getOrCreate(configID);
//		p.put(CLIENTAUTH, Boolean.toString(clientAuth));
//	}
/**
// scan system property, if it exists.
/**
// not found in config. try default properties.
/**
/**
//	/**
/**
//	 * 
//	 * @return the XPD Keystore if running on the XPD platform (otherwise null).
//	 * @throws MqttDirectException
//	 */
//	private KeyStore getXPDKeystore() throws MqttDirectException {
//		KeyStore keyStore = null;
//		try {
//			Class secPlatClass = Class.forName("com.ibm.rcp.security.auth.SecurePlatform");
//			Method m = secPlatClass.getMethod("getKeyStore", null);
//			Object secPlat = m.invoke(null,null); // getKeyStore is static
//			m = secPlatClass.getMethod("isLoggedIn", null);
//			Boolean b = (Boolean) m.invoke(secPlat, null);
//			if (b.booleanValue()) {
//				// login to secure platform was done.
//				m = secPlatClass.getMethod("getKeyStore", null);
//				keyStore = (KeyStore) m.invoke(secPlat, null);
//			}
//		} catch (ClassNotFoundException e) {
//			/*
/*
//			 * running on XPD runtime and therefore we can not get XPD keystore.
//			 * [Next step for the caller, is try to get the keystore from System
//			 * properties (see getKeyStore() method).]
//			 */
//		} catch (IllegalAccessException e) {
//			Object[] inserts = { e.getLocalizedMessage() };
//			throw new MqttSSLInitException(3026, inserts, e);
//		} catch (SecurityException e) {
//			Object[] inserts = { e.getLocalizedMessage() };
//			throw new MqttSSLInitException(3026, inserts, e);
//		} catch (NoSuchMethodException e) {
//			Object[] inserts = { e.getLocalizedMessage() };
//			throw new MqttSSLInitException(3026, inserts, e);
//		} catch (IllegalArgumentException e) {
//			Object[] inserts = { e.getLocalizedMessage() };
//			throw new MqttSSLInitException(3026, inserts, e);
//		} catch (InvocationTargetException e) {
//			Object[] inserts = { e.getLocalizedMessage() };
//			throw new MqttSSLInitException(3026, inserts, e);
//		}
//		return keyStore;
//	}
/**
//throws MqttDirectException {
//		// check for the XPD keystore here
//		if ( ibmKey != null && ibmKey.equals(KEYSTORE) ) {
//			KeyStore keyStore = getXPDKeystore();
//			if (keyStore != null)
//				return res = "Lotus Expeditor";
//		}
// scan system property, if it exists.
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
// 12000 "SSL initialization: configID = {0}, protocol = {1}"
// 12001 "SSL initialization: configID = {0}, provider = {1}"
//			if(keyStoreName==null) {
//				// try to instantiate XPD keyStore.
//				keyStore=getXPDKeystore();
//				if (logger != null) {
//					if (keyStore == null) {
//						// 12002 "SSL initialization: configID = {0}, XPD keystore not available"
//						logger.fine(CLASS_NAME, METHOD_NAME, "12002", new Object[]{configID!=null ? configID : "null (broker defaults)"});
//					} else {
//						// 12003 "SSL initialization: configID = {0}, XPD keystore available"
//						logger.fine(CLASS_NAME, METHOD_NAME, "12003", new Object[]{configID!=null ? configID : "null (broker defaults)"});
//					}
//				}
//			}
/*
// 12004 "SSL initialization: configID = {0}, keystore = {1}"
// 12005 "SSL initialization: configID = {0}, keystore password = {1}"
// 12006 "SSL initialization: configID = {0}, keystore type = {1}"
// 12010 "SSL initialization: configID = {0}, keystore manager algorithm = {1}"
// 12009 "SSL initialization: configID = {0}, keystore manager provider = {1}"
// keystore loaded, keymanagers instantiated if possible
// now the same for the truststore.
// 12011 "SSL initialization: configID = {0}, truststore = {1}"
// 12012 "SSL initialization: configID = {0}, truststore password = {1}"
// 12013 "SSL initialization: configID = {0}, truststore type = {1}"
// 12017 "SSL initialization: configID = {0}, truststore manager algorithm = {1}"
// 12016 "SSL initialization: configID = {0}, truststore manager provider = {1}"
// done.
//	/**
/**
//	 * SSLProtocol is already set, uses DEFAULT_PROTOCOL. Throws
//	 * IllegalArgumentException if the server socket factory could not be
//	 * created due to underlying configuration problems.
//	 * 
//	 * @see org.eclipse.paho.mqttv5.client.internal.security.SSLSocketFactoryFactory#DEFAULT_PROTOCOL
//	 * 
//	 * @param configID
//	 *            The configuration identifier for selecting a configuration.
//	 * @return An SSLServerSocketFactory
//	 * @throws MqttDirectException
//	 */
//	public SSLServerSocketFactory createServerSocketFactory(String configID)
//			throws MqttDirectException {
//		final String METHOD_NAME = "createServerSocketFactory";
//		SSLContext ctx = getSSLContext(configID);
//		if (logger != null) {
//			// 12018 "SSL initialization: configID = {0}, application-enabled cipher suites = {1}"
//			logger.fine(CLASS_NAME, METHOD_NAME, "12018", new Object[]{configID!=null ? configID : "null (broker defaults)", 
//					getEnabledCipherSuites(configID)!=null ? getProperty(configID, CIPHERSUITES, null) : "null (using platform-enabled cipher suites)"});
//			
//			// 12019 "SSL initialization: configID = {0}, client authentication = {1}"
//			logger.fine(CLASS_NAME, METHOD_NAME, "12019", new Object[]{configID!=null ? configID : "null (broker defaults)", 
//					new Boolean (getClientAuthentication(configID)).toString()});
//		}
//		
//		return ctx.getServerSocketFactory();
//	}
/**
// 12020 "SSL initialization: configID = {0}, application-enabled cipher suites = {1}"
/*
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
// First Byte: Fin, Reserved, Opcode
// Second Byte Masked & Initial Length
// 8 Byte Extended payload length
// 2 bytes extended payload length
// Decode the extended payload length
// Get the Masking key if masked
// Demask payload if needed
/**
// Reserved bits, unused right now.
// boolean rsv1 = ((incomingByte & 0x40) != 0);
// boolean rsv2 = ((incomingByte & 0x20) != 0);
// boolean rsv3 = ((incomingByte & 0x10) != 0);
/**
// 8 Byte Extended payload length
// 2 bytes extended payload length
// Decode the payload length
// Get the masking key
// Demask if needed
// Closing connection with server
/**
// Calculating overhead
/**
/**
/**
// Add Fin flag
//RSV 1,2,3 aren't important
// Add opcode
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Do not change: https://tools.ietf.org/html/rfc6455#section-1.3
/**
/**
/**
/**
/**
// We build up the accept in the same way the server should
// then we check that the response is the same.
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
// Creating Close Frame
//" + host + ":" + port;
/*
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// so specific requirements so far
// -1 if not defined
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
//@TRACE 855=starting
/**
//@TRACE 850=stopping
// Wait for the thread to finish
//This must not happen in the synchronized block, otherwise we can deadlock ourselves!
// Interrupted Exception
//@TRACE 851=stopped
//@TRACE 852=network read message
// Ignore SocketTimeoutException 
// Exception occurred whilst reading the stream.
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Creating Close Frame
//" + host + ":" + port;
/*
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// so specific requirements so far
// -1 if not defined
// Create the network module...
// Ciphers suites need to be set, if they are available
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
// read header
// Assume we can read the whole header at once.
// The header is very small so it's likely we
// are able to read it fully or not at all.
// This keeps the parser lean since we don't
// need to cope with a partial header.
// Should we lose synch with the stream,
// the keepalive mechanism would kick in
// closing the connection.
// Invalid MQTT message type...
// Incoming packet is too large
// read remaining packet
// the remaining packet can be read with timeouts
// reset packet parsing state 
// @TRACE 530= Received {0} 
// ignore socket read timeout
// remember the packet read so far 
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
// Outgoing packet is too large
// @TRACE 529= sent {0}
//host_literal:1883");
//host_literal:8883");
//host_literal:80/path/to/ws");
//host_literal:443/path/to/ws");
//host_literal:1883/somePath");
//host_literal:1883/somePath\"", e.getMessage());
//host_literal:1883/somePath");
//host_literal:1883");
//host_literal:1883\"", e
/**
//user:password@some_host:666/some_path");
/*
//localhost:666";
/* Copyright (c) 2009, 2019 IBM Corp.
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
//" + serverHost + ":" + TestProperties.getServerSSLPort());
/**
//" + serverHost + ":" + TestProperties.getServerSSLPort());
// for...
// for...
// for publishers...
// for subscribers...
// for messages...
/**
//" + serverHost + ":" + TestProperties.getServerSSLPort());
// Create message of size 'messageSize'
/**
//" + serverHost + ":" + TestProperties.getServerSSLPort() , methodName);
// Expected exception
/**
//" + serverHost + ":18883", methodName);
// Expected exception
/**
/**
// This utility method already asserts that we are connected, so good so far
// Client Should now be disconnected.
/**
// Subscribe to a topic
// Publish a message to the topic
// Unsubscribe from the topic
/**
// Subscribe to a topic
//iot.eclipse.org:1882", methodName);
// this would deadlock before fix
/**
//new MqttAsyncClient(serverURI.toString(), "👁🐝Ⓜ");
// Very long ASCII string
// Very long UTF-8 string (each instance of 渚 is 3 bytes)
// Encode it ourselves to check
// Very long ASCII string
// Very long UTF-8 string (each instance of 渚 is 3 bytes)
// Encode it ourselves to check
/**
// Create an MqttAsyncClient with a null Client ID.
// Publish a message at QoS 2
// Validate that the message that was persisted does not have a topic alias.
// Cleanup
// Connect to the server
// Publish a message to a random topic
// Connect to the server
//end
//time elapsed
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
// for...
// for...
// for publishers...
// for subscribers...
// for messages...
/**
// Clean start: true - The broker cleans up all client state, including subscriptions, when the client is disconnected.
// Clean start: false - The broker remembers all client state, including subscriptions, when the client is disconnected.
//                      Matching publications will get queued in the broker whilst the client is disconnected.
// For Mqtt V3 cleanSession=false, implies new subscriptions are durable.
// Disconnect and reconnect to make sure the subscription and all queued messages are cleared.
// Send a message from another client, to our durable subscription.
// Receive the publication so that we can be sure the first client has also received it.
// Otherwise the first client may reconnect with its clean session before the message has arrived.
// Reconnect and check we have no messages.
// Also check that subscription is cancelled.
/**
//keepAlive=30s
//10MB
// * (1 << 20);
/**
// Change the URI to a none MQTT server
//iot.eclipse.org:22");
//reuse the client instance to reconnect
//Assert.assertTrue(exception instanceof MqttException);
/**
// how many QoS 0 tokens shall we track?
//opts.setMaxInflight(tokenCount);
/**
// Create an MqttAsyncClient with a null Client ID.
// First, validate that we actually received an Assigned Client Identifier from
// the Server
// Validate that the Client now knows about it's own Client ID;
// Cleanup
// Subscribe to a topic
// Publish a message to a random topic
// Use 0 for the first time.
/**
//localhost:" + proxy.getLocalPort(),
// give it some time to reconnect
/**
//localhost:" + proxy.getLocalPort(),
// give it some time to reconnect
/**
//localhost:" + proxy.getLocalPort(),
// Make sure the proxy is disabled and give it a second to close everything down
// Exceptions are good in this case!
// Enable The Proxy
// Give it some time to make sure we are still not connected
//" + serverURI.getHost() + ":" + serverURI.getPort();
// Use 0 for the first time.
/**
// Tokens
// Client Options
//localhost:" + proxy.getLocalPort(), methodName, DATA_STORE);
// Enable Proxy & Connect to server
// Disable Proxy and cause disconnect
// Publish Message
// Enable Proxy
// Check that we are connected
// give it some time to reconnect
// Check that Message has been delivered
/**
// Tokens
// Client Options
//localhost:" + proxy.getLocalPort(), methodName, DATA_STORE);
// Create subscription client that won't be affected by proxy
// Subscribe to topic
// Enable Proxy & Connect to server
// Disable Proxy and cause disconnect
// Publish some messages
// Enable Proxy
// Check that we are connected
// give it some time to reconnect
// Check that all messages have been delivered
/**
// Tokens
// Client Options
//localhost:" + proxy.getLocalPort(), methodName, DATA_STORE);
// Set buffer to 100 to save time
// Enable Proxy & Connect to server
// Disable Proxy and cause disconnect
// Publish 100 messages
// Publish one message too many
// Make sure that the message now at index 0 in the buffer is '1'
// instead of '0'
/**
// Tokens
// Client Options
//localhost:" + proxy.getLocalPort(), methodName, DATA_STORE);
// Set buffer to 100 to save time
// Enable Proxy & Connect to server
// Disable Proxy and cause disconnect
// Publish 100 messages
/**
// Tokens
// Client Options
//localhost:" + proxy.getLocalPort(), methodName,
// Enable Proxy & Connect to server
// Disable Proxy and cause disconnect
// Make Sure persistence is empty before publish
// Publish Message
// Check that message is now in persistence layer
/**
// Mock up an Mqtt Message to be stored in Persistence
// If ID is not set, then the persisted message may be invalid for QoS 1 & 2
// Create Subscription client to watch for the message being published
// as soon as the main client connects
// Create Real client
// Connect Client with existing persistence layer
// Check that message is published / delivered
// Allow a few seconds for the QoS 2 flow to complete
/**
// Tokens
// Client Options
//localhost:" + proxy.getLocalPort(), methodName, DATA_STORE);
// Enable Proxy & Connect to server
// Disable Proxy and cause disconnect
// Publish Message
// Use 0 for the first time.
/**
// 1. Client connects with Clean session=false, session expiry=Max (no expiry)
//localhost:" + proxy.getLocalPort(), clientId,
// 2.1 - Send first message, this will have a topic string AND a topic alias.
// 2.2 - Send second message, this won't have a topic string, but will have a
// topic Alias.
// 3 - Drop the connection
// 4 - Client uses Reconnect Logic to connect
// give it some time to reconnect
// 5 - Publish a final message, this message should have both a topic string AND
// a topic Alias.
// We should still be connected.
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
// not implemented
/**
// not implemented
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
// empty
/**
// empty
/**
// empty
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
// not implemented
/**
// not implemented
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Use 0 for the first time.
/**
//localhost:" + proxy.getLocalPort(), clientId, DATA_STORE);
// ignore
/**
//localhost:" + proxy.getLocalPort(), clientId, DATA_STORE);
// ignore
/**
//localhost:" + proxy.getLocalPort(), clientId, DATA_STORE);
// ignore
/**
//localhost:" + proxy.getLocalPort(), clientId, DATA_STORE);
/**
//localhost:" + proxy.getLocalPort(), clientId, DATA_STORE);
/**
//localhost:" + proxy.getLocalPort(), clientId, DATA_STORE);
// log.info("Delivery Complete: " + token.getMessageId());
// TODO Auto-generated method stub
// TODO Auto-generated method stub
// TODO Auto-generated method stub
// TODO Auto-generated method stub
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
// Do nothing (the default implementation would close the stream!)
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
// do nothing
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
// do nothing
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
// sb.append("@" + Integer.toHexString(System.identityHashCode(l)) + " ");
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
// do nothing
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
//&lt;localhost&gt;:1883</code>> where <code>&lt;localhost&gt;</code> is expressed as a IPv4 dotted decimal value 
/**
/**
// empty
//" + localhost + ":1883";
// Make sure all the property classes we know about get initialised
/**
/**
/**
// Read the properties from the property file
// Override the default property values from SystemProperties
// Override the property values from SystemProperties
// Output the non-default properties
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
// Give it a second to close down
// TODO Auto-generated catch block
// Do nothing as we want to close;
// Wait for a connection on the local Port
// Attempt to make a connection to the real server
// Get Server Streams
// Read the Servers responses and pass them back to the client
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/** */
/** */
/**
/**
/**
/**
/**
/**
/**
// track time taken to receive messages
// Calculate new wait time based on experience, but not allowing it
// to get too small
/**
/**
/**
// Auto-generated method stub
/**
// Auto-generated method stub
/**
// logger.fine(methodName + ": '" + new String(message.getPayload()) + "'");
/**
// TODO Auto-generated method stub
// TODO Auto-generated method stub
// TODO Auto-generated method stub
// TODO Auto-generated method stub
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/** Lookup the line separator once */
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/* (non-Javadoc)
//data.clear();
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
// Returns the Data cache
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/* (non-Javadoc)
//data.clear();
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* (non-Javadoc)
/* Copyright (c) 2009, 2014 IBM Corp.
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
// Skip over synthetic accessor methods
/**
/**
/**
/** 
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
// Utility classes should not have a public or default constructor.
/**
// New MQTTv5 Packet Errors
// Invalid Identifier in the IV fields
// Invalid Return code
// Packet was somehow malformed and did not comply to
// the MQTTv5 specification
// The CONNECT packet did not contain the
// correct protocol name or version
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
/**
/** Persistence is already being used by another client. */
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
// Count characters, surrogate pairs count as one character.
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Return codes
// Fields
/**
/**
// Encode the Return Code
// Write Identifier / Value Fields
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Encode the Session Present Flag
// Encode the Connect Return Code
// Write Identifier / Value Fields
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// Fields
/**
// Verify the Protocol name and version
/**
// Encode the Protocol Name
// Encode the MQTT Version
// Write Identifier / Value Fields
// Encode Will properties here
/**
/**
/**
// byte readBuffer[] = {0,0}
/**
/**
/**
/* Check for mismatched surrogates */
/* Trailing high surrogate */
/* No low surrogate */
/* Noncharacter in base plane */
/* Control character or no high surrogate */
/* Noncharacter in other nonbase plane */
/**
// Encode the remaining length fields in the four bytes
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// Fields
// Encode the Return Code
// Write Identifier / Value Fields
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
// 3.1.2.1 - If Protocol name is not 'MQTT', return Unsupported Protocol Version Error.
// 3.1.2.2 - If Protocol version is not 5, return Unsupported Protocol Version Error.
// 3.1.2.3 - If Reserved flag is not 0, return Malformed Packet Error.
// 3.1.2.6 - If Will QoS is 0x03, return Malformed Packet Error.
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// Remove the Topic Alias temporarily.
// Re Set Topic Alias
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/** 1 - Payload format indicator (Byte) */
/** 2 - Message Expiry Interval. (Four Byte Int). */
/** 3 - Content Type (UTF-8). */
/** 8 - Response Topic (UTF-8). */
/** 9 - Correlation Data. (UTF-8). */
/** 11 - Subscription Identifier (Variable Byte Int). */
/** 126 - Subscription Identifier Multi Flag (NOT ACTUAL PROPERTY). */
/** 127 - Subscription Identifier Single Flag (NOT ACTUAL PROPERTY). */
/** 17 - Session Expiry Interval (Four Byte Int). */
/** 18 - Assigned Client Identifier (UTF-8). */
/** 19 - Server Keep Alive (Two Byte Int). */
/** 21 - Authentication Method (UTF-8). */
/** 22 - Authentication Data (Binary Data). */
/** 23 - Request Problem Information (Byte). */
/** 24 - Will Delay Interval (Four Byte Int). */
/** 25 - Request Response Information (Byte). */
/** 26 - Response Information (UTF-8). */
/** 28 - Server Reference (UTF-8). */
/** 31 - Reason String (UTF-8). */
/** 33 - Receive Maximum (Two Byte Int). */
/** 34 - Topic Alias Maximum (Two Byte Int). */
/** 35 - Topic Alias (Two Byte Int). */
/** 36 - Maximum QOS (Byte). */
/** 37 - Retain Available (Byte). */
/** 38 - User Defined Pair (UTF-8 key value). */
/** 39 - Maximum Packet Size (Four Byte Int). */
/** 40 - Wildcard Subscriptions available (Byte). */
/** 41 - Subscription Identifier Available (Byte). */
/** 42 - Shared Subscription Available (Byte). */
// Properties, sorted by Type
// Byte
// Two Byte Integer
// Four Byte Integer
// UTF-8 encoded String
// Binary Data
// Variable Byte Integer
/**
/**
/**
/**
// Payload Format Indicator
// Message Expiry Interval
// Content Type
// Response Topic
// Correlation Data
// Subscription Identifier
// Session Expiry Interval
// Assigned Client Identifier
// Server Keep Alive
// Auth Method
// Auth Data
// Request Problem Info
// Will Delay Interval
// outputStream.writeInt(willDelayInterval);
// Request Response Info
// Response Info
// Server Reference
// Reason String
// Receive Maximum
// Topic Alias Maximum
// Topic Alias
// Maximum QoS
// Retain Available
// User Defined Properties
// outputStream.write(USER_DEFINED_PAIR_IDENTIFIER);
// Maximum Packet Size
// Wildcard Subscription Available flag
// Subscription Identifiers Available flag
// Shared Subscription Available flag
/**
// First get the length of the IV fields
// Get the first Byte
// Verify that certain properties are not included more than once
// This property can only be included once
// Bit of a hack, where we potentially write this many times, users should make
// sure they read the JavaDoc.
// Unidentified Identifier
// Unidentified Identifier
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// Encode the Message ID
// Encode the Return Code
// Encode the Return Code
// Write Identifier / Value Fields
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// Fields
// Encode the Message ID
// Encode the Return Code
// Encode the Return Code
// Write Identifier / Value Fields
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Fields
/**
/**
// If we are using a Topic Alias, then the topic should be empty
// Write Identifier / Value Fields
// all publishes require a message ID as it's used as the key to the
// token store
// Convert the first few bytes of the payload into a hex string
// It will not always be possible to convert the binary payload into
// characters, but never-the-less we attempt to do this as it is often
// useful.
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// Fields
// Encode the Message ID
// Encode the Return Code
// Encode the Return Code
// Write Identifier / Value Fields
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// Fields
// Encode the Message ID
// Encode the Return Code
// Encode the Return Code
// Write Identifier / Value Fields
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// This method exists here to get around the protected visibility of the
// super class method.
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/** Success and general Return Codes **/
// 0
// 0
// 1
// 2
// 4
// 16
// 17
// 24
// 25
/** Error Return Codes **/
// 128
// 129
// 130
// 131
// 132
// 133
// 134
// 135
// 136
// 137
// 138
// 139
// 140
// 141
// 142
// 143
// 144
// 145
// 146
// 147
// 148
// 149
// 150
// 151
// 152
// 153
// 154
// 155
// 156
// 157
// 158
// 159
// 160
// 161
// 162
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// Fields
// Encode the Message ID
// Write Identifier / Value Fields
// Write Identifier / Value Fields
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// Fields
/**
// Whilst we are reading data
/**
/**
// Encode the Message ID
// Write Identifier / Value Fields
/**
// Encode Subscription QoS
// Encode NoLocal Option
// Encode Retain As Published Option
// Encode Retain Handling Level
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// Fields
// Encode the msgId
// Write Identifier / Value Fields
// Write Identifier / Value Fields
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// Fields
// Whilst we are reading data
// Encode the Message ID
// Write Identifier / Value Fields
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// The type of the message (e.g CONNECT, PUBLISH, SUBSCRIBE)
// The MQTT Message ID
// Multiple Reason Codes (SUBACK, UNSUBACK)
// Single Reason Code, init with -1 as that's an invalid RC
// Use zero as the default message ID. Can't use -1, as that is serialized
// as 65535, which would be a valid ID.
/**
/**
/**
/**
/**
/**
/**
/**
/**
// The persistable interface allows a message to be restored entirely in the
// header array.
// We need to treat these two arrays as a single array of bytes and use the
// decoding
// logic to identify the true header / payload split.
// The remaining bytes must be the payload
// Encode the remaining length fields in the four bytes
/**
// Publish can vary, but will be parsed separately.
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**Constructs a new <code>CountingInputStream</code> wrapping the supplied
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
/**
/**
/**
/**
/**
// topic name and topic filter length range defined in the spec
/**
// Spec: length check
// - All Topic Names and Topic Filters MUST be at least one character
// long
// - Topic Names and Topic Filters are UTF-8 encoded strings, they MUST
// NOT encode to more than 65535 bytes
// *******************************************************************************
// 1) This is a topic filter string that can contain wildcard characters
// *******************************************************************************
// Only # or +
// 1) Check multi-level wildcard
// Rule:
// The multi-level wildcard can be specified only on its own or next
// to the topic level separator character.
// - Can only contains one multi-level wildcard character
// - The multi-level wildcard must be the last character used within
// the topic tree
// 2) Check single-level wildcard
// Rule:
// The single-level wildcard can be used at any level in the topic
// tree, and in conjunction with the
// multilevel wildcard. It must be used next to the topic level
// separator, except when it is specified on
// its own.
// Validate Shared Subscriptions
// *******************************************************************************
// 2) This is a topic name string that MUST NOT contains any wildcard characters
// *******************************************************************************
// prev and next can be only '/' or none
/**
// skip until we meet the next separator, or end of string
// skip until end of string
/*
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Represents a failed index search.
/**
/**
/**
// missing low surrogate, fine, like String.indexOf(String)
// ch is in the Basic Multilingual Plane
/**
/**
/**
/**
/**
// prevented from constructing objects
/**
// Encode The String
// Decode the String
// Attempt to encode a negative number
// Attempt to encode a value which is too big
/* ControlChar U+007F , smallest of the C1 range */
/* ControlChar U+007F , smallest of the C1 range */
/* Nonchar U+FDD0 */
/* Nonchar U+FDDF */
/* Nonchar *+FFFE */
/* Nonchar U+FFFF */
/* Nonchar U+1FFFE */
/* Nonchar U+1FFFF */
/* Two high surrogates */
/* trailing high surrogates */
/* low surrogate */
// System.out.println(String.format("'%s' is %d bytes, %d chars long",
// testString, testString.getBytes().length, testString.length()));
// System.out.println(String.format("'%s' is %d bytes, %d chars long",
// testString, testString.getBytes().length, testString.length()));
// System.out.println(String.format("'%s' is %d bytes, %d chars long",
// testString, testString.getBytes().length, testString.length()));
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
//printByteArray(outputStream.toByteArray());
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
// Test Min
// Test Max
// Useful for debugging.
// System.out.println(javax.xml.bind.DatatypeConverter.printHexBinary(encodedProperties));
/**
/**
/**
// Test Min
// Test Max
/**
/**
/**
// Test Min
// Test Max
/**
/**
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// Total Packet should be 5 bytes long
// Total Packet should be 4 bytes long
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// Total Packet should be 5 bytes long
// Total Packet should be 4 bytes long
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// Total Packet should be 5 bytes long
// Total Packet should be 4 bytes long
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// Total Packet should be 5 bytes long
// Total Packet should be 4 bytes long
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
// Assert that apart from the topic, all items are set to defaults
// Assert that apart from the topic, all items are set to defaults
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/** Copyright (c)  2014 IBM Corp.
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
// The time in ms to wait for any action to timeout.
/**
// Define Default Settings
// Define CLI Options
// Mode
// Debug / Verbosity
// Help
// Connection
//iot.eclipse.org:1883. Use ws:// for Websockets, wss:// for secure Websockets and ssl:// for TLS encrypted TCP connections.");
// SSL
// Publish
// Subscribe
// General
// cliOptions.addOption("", "", true, "");
// Parse and Set Options
// Print Help
// Process Verbosity / Debug Options
// Get Mode
// Process Publish Arguments
// Process Subscribe Arguments
/**
// Get the Host URI
// If the client ID was not set, generate one ourselves
// No client ID provided, generate one from the process ID
//ProcessHandle.current().pid();
// To allow a graceful disconnect.
/**
// TODO Auto-generated catch block
// Create Client
// Connect to Server
// Execute action based on mode
// TODO Auto-generated catch block
// TODO Auto-generated catch block
// Close the client
// TODO Auto-generated catch block
// Publish a message
// Close the client
// Subscribe to a topic
// Do nothing
// TODO Auto-generated catch block
/**
/**
/**
// Disconnect
// Close the client
// End the Application
/**
//logMessage(String.format("Message %d was delivered.", token.getMessageId()), true);
/**
// Get the Host URI
// If the client ID was not set, generate one ourselves
// No client ID provided, generate one from the process ID
//ProcessHandle.current().pid();
// To allow for a graceful disconnect
/**
// Create the client.
// Connect to the server
// Execute Action based on mode.
// Do nothing
/**
/**
/**
/**
// Disconnect
// Close the client
// End the Application
// No Required Implementation
// logMessage(String.format("Message %d was delivered.", token.getMessageId()),
// true);
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
// Default settings:
// Non durable subscriptions
// Parse the arguments -
// Check this is a valid argument
// Handle arguments that take no-value
// Now handle the arguments that take a value and
// ensure one is specified
// Validate the provided arguments
// Set the default topic according to the specified action
//";
//";
// With a valid set of arguments, the real work of
// driving the client API can begin
// Create an instance of this class
// Perform the requested action
// Display full details of any exception that occurs
// Private instance variables
/**
//This sample stores in a temporary directory... where messages temporarily
// stored until the message has been delivered to the server.
//..a real application ought to store them somewhere
// where they are not likely to get deleted or tampered with
// Construct the connection options object that contains connection parameters
// such as cleanSession and LWT
// Construct an MQTT blocking mode client
// Set this wrapper as the callback handler
/**
// Connect to the MQTT server
// Create and configure a message
// Send the message to the server, control is not returned until
// it has been delivered to the server meeting the specified
// quality of service.
// Disconnect the client
/**
// Connect to the MQTT server
// Subscribe to the requested topic
// The QoS specified is the maximum level that messages will be sent to the client at.
// For instance if QoS 1 is specified, any messages originally published at QoS 2 will
// be downgraded to 1 when delivering to the client but messages published at 1 and 0
// will be received at the same level they were published at.
// Continue waiting for messages until the Enter is pressed
//If we can't read we'll just exit
// Disconnect the client from the server
/**
/****************************************************************/
/* Methods to implement the MqttCallback interface              */
/****************************************************************/
/**
// Called when the connection to the server has been lost.
// An application may choose to implement reconnection
// logic at this point. This sample simply exits.
/**
// Called when a message has been delivered to the
// server. The token passed in here is the same one
// that was passed to or returned from the original call to publish.
// This allows applications to perform asynchronous
// delivery without blocking until delivery completes.
//
// This sample demonstrates asynchronous deliver and
// uses the token.waitForCompletion() call in the main thread which
// blocks until the delivery has completed.
// Additionally the deliveryComplete method will be called if
// the callback is set on the client
//
// If the connection to the server breaks before delivery has completed
// delivery of a message will complete after the client has re-connected.
// The getPendingTokens method will provide tokens for any messages
// that are still to be delivered.
/**
// Called when a message arrives from the server that matches any
// subscription made by the client
/****************************************************************/
/* End of MqttCallback methods                                  */
/****************************************************************/
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
// Default settings:
// Non durable subscriptions
// Parse the arguments -
// Check this is a valid argument
// Handle arguments that take no-value
// Now handle the arguments that take a value and
// ensure one is specified
// Validate the provided arguments
// Set the default topic according to the specified action
//";
//";
// With a valid set of arguments, the real work of
// driving the client API can begin
// Create an instance of the Sample client wrapper
// Perform the specified action
// Display full details of any exception that occurs
// Private instance variables
/**
//This sample stores in a temporary directory... where messages temporarily
// stored until the message has been delivered to the server.
//..a real application ought to store them somewhere
// where they are not likely to get deleted or tampered with
// Construct the object that contains connection parameters
// such as cleanSession and LWT
// Construct the MqttClient instance
// Set this wrapper as the callback handler
/**
// Use a state machine to decide which step to do next. State change occurs
// when a notification is received that an MQTT action has completed
// Connect using a non-blocking connect
// Publish using a non-blocking publisher
//    		if (state != FINISH) {
// Wait until notified about a state change and then perform next action
//    		}
/**
/**
// Use a state machine to decide which step to do next. State change occurs
// when a notification is received that an MQTT action has completed
// Connect using a non-blocking connect
// Subscribe using a non-blocking subscribe
// Block until Enter is pressed allowing messages to arrive
//If we can't read we'll just exit
//    		if (state != FINISH && state != DISCONNECT) {
//    	}
/**
/****************************************************************/
/* Methods to implement the MqttCallback interface              */
/****************************************************************/
/**
// Called when the connection to the server has been lost.
// An application may choose to implement reconnection
// logic at this point. This sample simply exits.
/**
// Called when a message has been delivered to the
// server. The token passed in here is the same one
// that was returned from the original call to publish.
// This allows applications to perform asynchronous
// delivery without blocking until delivery completes.
//
// This sample demonstrates asynchronous deliver, registering
// a callback to be notified on each call to publish.
//
// The deliveryComplete method will also be called if
// the callback is set on the client
//
// note that token.getTopics() returns an array so we convert to a string
// before printing it on the console
/**
// Called when a message arrives from the server that matches any
// subscription made by the client
/****************************************************************/
/* End of MqttCallback methods                                  */
/****************************************************************/
/**
// Connect to the server
// Get a token and setup an asynchronous listener on the token which
// will be notified once the connect completes
// Connect using a non-blocking connect
// If though it is a non-blocking connect an exception can be
// thrown if validation of parms fails or other checks such
// as already connected fail.
/**
// Send / publish a message to the server
// Get a token and setup an asynchronous listener on the token which
// will be notified once the message has been delivered
// Setup a listener object to be notified when the publish completes.
//
// Publish the message
/**
// Make a subscription
// Get a token and setup an asynchronous listener on the token which
// will be notified once the subscription is in place.
/**
// Disconnect the client
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
// Default settings:
// Non durable subscriptions
// Parse the arguments -
// Check this is a valid argument
// Handle arguments that take no-value
// Now handle the arguments that take a value and
// ensure one is specified
// Validate the provided arguments
// Set the default topic according to the specified action
//";
//";
// With a valid set of arguments, the real work of
// driving the client API can begin
// Create an instance of this class
// Perform the specified action
// Display full details of any exception that occurs
// Private instance variables
/**
//This sample stores in a temporary directory... where messages temporarily
// stored until the message has been delivered to the server.
//..a real application ought to store them somewhere
// where they are not likely to get deleted or tampered with
// Construct the connection options object that contains connection parameters
// such as cleanSession and LWT
// Construct a non-blocking MQTT client instance
// Set this wrapper as the callback handler
/**
// Connect to the MQTT server
// issue a non-blocking connect and then use the token to wait until the
// connect completes. An exception is thrown if connect fails.
// Construct the message to send
// Send the message to the server, control is returned as soon
// as the MQTT client has accepted to deliver the message.
// Use the delivery token to wait until the message has been
// delivered
// Disconnect the client
// Issue the disconnect and then use a token to wait until
// the disconnect completes.
/**
// Connect to the MQTT server
// issue a non-blocking connect and then use the token to wait until the
// connect completes. An exception is thrown if connect fails.
// Subscribe to the requested topic.
// Control is returned as soon client has accepted to deliver the subscription.
// Use a token to wait until the subscription is in place.
// Continue waiting for messages until the Enter is pressed
//If we can't read we'll just exit
// Disconnect the client
// Issue the disconnect and then use the token to wait until
// the disconnect completes.
/**
/****************************************************************/
/* Methods to implement the MqttCallback interface              */
/****************************************************************/
/**
// Called when the connection to the server has been lost.
// An application may choose to implement reconnection
// logic at this point. This sample simply exits.
/**
// Called when a message has been delivered to the
// server. The token passed in here is the same one
// that was passed to or returned from the original call to publish.
// This allows applications to perform asynchronous
// delivery without blocking until delivery completes.
//
// This sample demonstrates asynchronous deliver and
// uses the token.waitForCompletion() call in the main thread which
// blocks until the delivery has completed.
// Additionally the deliveryComplete method will be called if
// the callback is set on the client
//
// If the connection to the server breaks before delivery has completed
// delivery of a message will complete after the client has re-connected.
// The getPendinTokens method will provide tokens for any messages
// that are still to be delivered.
/**
// Called when a message arrives from the server that matches any
// subscription made by the client
/****************************************************************/
/* End of MqttCallback methods                                  */
/****************************************************************/
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/** This class constructs the user interface dialog allowing the input of additional 
/**
// Get the container for this dialog and set the size and layout manager		
// Create widgets to place on the GUI
// Clean session check box
// Text field to hold the client id
// Should persistence be used for the WMQtt connection?
// Default button
// Add an actionlistener and tooltip to the button
// Create components to go in the NORTH panel of the dialog
// Top part
// Create a title in BOLD with a trace button
// Create a Client Identifier field
// Create clean session and keep alive options
// Create retry interval and keep alive options
// Create a log file name field
// Now add all the components to the top part of the options panel
// Create components required for Last Will and Testament
// CENTER pane - Last Will and Testament options
// The CENTER pane of the dialog will contain a BorderLayout with the components laid out as follows:
//       NORTH - title label, topic and options
//       CENTER - LW&T message data
// Create a LW&T topic field        
// Create a text area for LW&T topic data				
// Create a check box for LW&T retained topic option
// Create a dropdown box to hold the Last Will & Testament QoS options.
// Create a title in BOLD
// Create a panel and add the LW&T topic and retained option to it
// Now add all the components for the LW&T NORTH panel to one panel
// Finally construct the LW&T panel
// Create button components
// SOUTH pane - Close and reset buttons
// Now put the complete connection options panel together
/**
/**
/**
/**
/**
// Invalid entry set - use the default
/**
// Invalid entry set - use the default
/**
/**
// See if the set text equals "" and return the inverse
/**
/**
/**
/**
// Reset button has been pressed
// Reset all the fields to their default values
/*******************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// define the polyline for the outer border
// define the polyline which is the grey extra highlight
// when the LED is in its off state
// Interval between flashing
/**
// main colour
// darker outline colour
// highlight colour
// default shadow colour for illuminated LED
// glint colour
// Some predefined colours - amber, red and green.
// this one uses the 4-way initialiser, including the shadow colour
// this is the current state of the LED
// and this is whether or not it is flashing
// this is whether or not it is currently off, regardless of the state colour
/**
/**
/**
// if the LED is currently off, use the off colours to draw with, otherwise, use the
// colours as defined in the state object
// draw the main blob of main colour
// draw the polyline of slightly darker main colour that goes round the outside
// draw the drop shadow and the "corners"
// now do the highlight
// and finally the glint
// if the LED is currently "off", also add the extra lowlight
/**
// if we're flashing, flip the state
// if it's off, turn it on, and vice versa
// Suspend the thread when flashing is not required
// Don't care if an interrupt occurs
/**
/**
// arbitrary colour LED
/**
/**
// Notify the flash thread that a state change has occurred
/**
/**
/**
/********************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Main Components
// Object to coordinated ConnectionLost and disconnect threads if
// disconnect is hit during connectionLost
/**
/**
// The name of the properties file
// Other constants
/**
/**
// Don't cleanly disconnect when the window is closed.
// This allows things like Last Will & Testament to be easily tested by
// closing the window to unexpectedly terminate the MQTT session.
//view.disconnect();
// Write the properties to disk before exiting
// First populate the properties object
// IPADDRESS
// IPPORT
// CLIENTID
// PERSISTENCE ENABLED
// PERSISTENCE DIRECTORY
// Now write to disk
// If we cannot create a properties file then don't worry
/**
/**
// Don't worry if we can't set the look and feel
// Does a properties file exist from which the GUI can be populated?
// If we can't find a properties file then don't worry
// Now build the GUI components
// Build the main components to add to the tabbed pane.
// Add the panel which handles connecting and disconnecting from the broker
// Add the panels for publish and subscribe to a JSplitPane
// The JSplitPane allows the panels to be resized evenly, allows the user to resize the 
// panels manually and provides a good layout for two similar panels
// Allow either panel to be expanded to full size easily
// Set the divider size large enough to display the one touch expandable arrows
// Resize evenly
// Add the pubsub JSplitPane to the outer frame
// Load any TCP/IP address info from the config file
// Load any TCP/IP port info from the config file
// Create the options panel
// Add an LED to indicate the connection state
// Don't worry if we can't close the properties file
// Now construct the tabbed pane
/**
/**
// Notify connectionLost to give up. It may be running..
// Disconnect from the broker
// Set the LED state correctly
// If the led is flashing then turn it off
// This only occurs if disconnect is hit during connection lost
// Grab the log synchronisation lock
/**
// Connect to the broker
// If we have a MqttClient object and the new ip address
// or port number is not equal to the previous, or the persistence flag changes between
// off and on then we need a new object.
/*||
//mqtt.terminate();
// Carry the trace setting over to the new MqttClient object
// Set the retry interval for the connection
//mqtt.setRetry( optionsComp.getRetryInterval() );
/**
// Grab the log synchronisation lock
/** Invoked by actionPerformed when connect is pressed. 
// Connect to the broker
// If the entry in the IP Address drop down list contains '://' then assume
// the connection has been explicitly entered as tcp://ip_address:port or local://broker_name.
// Otherwise read the ip address and port number from their respective drop downs.
//")) {
//" + ipAddr + ":" + portNum;
// Successful connect(no exception). Remember the ipAddress and port in the drop downs
// Grab the log synchronisation lock
/**
// When the connect button is pressed we are either connected or not connected
// If we are connected then say so.
// If we are not connected then
//      1. Set the LED to Amber, the state to connecting and start a thread to do the actual connect.
//         This allows the GUI thread to return and paint the window correctly
// Already connected
// Initialise the GUI prior to connecting by setting the LED to amber.
// Start a thread to do the connect.
// Disconnect from the broker
/**
// Synchronized as this may also be called on the connectionLost thread, which is
// created by the Java MQTT Client
/**
// Flip the LED to Amber and set it flashing
// Grab the log synchronisation lock
// While we have failed to reconnect and disconnect hasn't
// been called by another thread retry to connect
// Don't care if we are interrupted
// Grab the log synchronisation lock
// Catch any MQTT exceptions, set rc to -1 and retry
// Remove title text once we have reconnected
//throw ex;
// Set the flashing off whatever happens
// Flash off
// If we get here and we are connected then set the led to green
/**
/**
/**
/**
// This topic already exists in the list, so don't add it again
/**
/*
/**
/*mqtt.stopTrace()*/
/**
/**
/** Add properties from a Properties object to a JComboBox. The properties to add
/**
// For IPADDRESS and IPPORT there may be mulitple values, so
// delimit the values with the PROP_DELIM character     	
// Don't add a delimiter after the last token
// Don't add a delimiter after the last token
/**
/********************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
// Remember the scroll pane object so that we can auto scroll
// close button
/**
// Get the container for this dialog and set the size and layout manager		
// Clear button
// Add an actionlistener and tooltip to the button
// Enable/Disable button
// Add an actionlistener and tooltip to the button
// Create button components
// SOUTH pane - Close and reset buttons
// Create a text area for history data
// Now put the complete panel together
// Start up the run method of this object as a thread to manage
// autoscrolling the log history window        
/**
/**
// Notify the autoscroll thread that it is time to exit
/**
// Tell the ScrollPane to sort itself out in terms of resizing the scrollbars    	
// Notify the autoscroll thread to scroll the window
/**
// Log is being enabled / disabled
/**
// Take a short nap after being notified to
// allow the swing components to revalidate themselves
// Don't mind if an interrupt occurs
// Autoscroll the text area to the bottom
/********************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
// Create the components to go in the NORTH panel
// Create the title label for the pubPanel
// To add a title to the panel place the Topic label, topic text field, qos combo box and retained check box in a horizontal layout
// Then place this horizontal layout below the title "Publish Messages"
// Add everything to the panel that will be inserted into the NORTH of the pubPanel
// Create the components to go in the EAST panel
// Add the button to a FlowLayout to stop it resizing
// Now add the title and topic options, data text area and the publish button to the pubPanel
/**
/**
// Remember the display state (hex or text) of the publish JTextArea
// Convert the display to the characters we want to send
// If we needed to update this list, then update the subscriber panel's topic list
// Publish the fileContent or the JTextArea contents. The file contents are the most
// current if fileContent is not null.
// Publish failed
// If the display was originally in hex then switch back to hex
// Grab the log synchronisation lock
// When writing the data to the log get it from the receivedData text area, so that it is in the correct format - Hex or Text
// Prefix hex data with 0x
// Display the file content as string data and listen for changes to it occuring
/**
// Change the byte value from a signed to unsigned value
// e.g. A byte of value 0xAA is treated as -86 and displayed incorrectly as 0xFFFFFFAA
// Adding 256 to this value changes it to 170 which is displayed correctly as 0xAA
/**
// Take each pair of bytes from the input and convert to a character			
// Use the Integer parseInt method to take a 2 byte string in base 16 and turn it into an integer.
/**
// DocumentListener Interface
/**
/**
/**
/********************************************************************************
//www.eclipse.org/legal/epl-2.0
//www.eclipse.org/org/documents/edl-v10.php
/**
/**
/**
// Create field to specify topics to subscribe to / unsubscribe from
// Set a maximum size for it to stop it sizing vertically
// Create fields to display the topic, QoS and retained flag for which data has been received
// Set a maximum size for it to stop it sizing vertically
// Create a text area to display received data in		
// Create a JComboBox to display the delivery QoS for a subscription
// Create the components to go in the NORTH panel
// Create a horizontal box layout in which to display the topic sent and its label
// Keep the qoslist from being right up against the edge of the window by adding some spaces
// Create a horizontal box layout in which to display the topic rcvd and its label
// Add some white space in to stop the receivedTopic field being sized to the whole width of the GUI
// The white space occupies the same space as the Request QoS JLabel, so the sent and rcvd topic fields line up reasonably well
// rcvdTopicPanel.add( new JLabel("                                       ") );
// Now to incorporate a title into the panel we place the two topic fields in a vertical
// layout with the title "Subscribe To Topics"
// Add a title in BOLD        
// Add all the fields that will make up the NORTH panel
// Create the components to go in the EAST panel
// Add the buttons to a FlowLayout to stop them resizing
// Add the Title and Topic fields to the NORTH panel
// Add the received publications text area to the CENTER
// Add the Subscribe and Unsubscribe buttons to the EAST       
/**
/**
// If we needed to update this list, then update the publisher panel's topic list
// Subscribe
// Unsubscribe
// Now close the file if we can
/**
// Remember the display state (hex or text) of the subscribe JTextArea
// Switch to a character display before adding text
// Store the data content in a buffer incase in needs to be written to a file
// If the data is binary reading it back from the receivedData field is not good enough
// If the display was originally in hex then switch back to hex
// When writing the data to the log get it from the receivedData text area, so that it is in the correct format - Hex or Text
// Grab the log synchronisation lock
// Prefix hex data with 0x
/**
// Change the byte value from a signed to unsigned value
// e.g. A byte of value 0xAA is treated as -86 and displayed incorrectly as 0xFFFFFFAA
// Adding 256 to this value changes it to 170 which is displayed correctly as 0xAA
/**
// Take each pair of bytes from the input and convert to a character			
// Use the Integer parseInt method to take a 2 byte string in base 16 and turn it into an integer.
/**
