/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// FIXME: For some reason, WebSphere changes JARs in WEB-INF/lib, breaking signatures. So ignore errors.
// Ignore
// No instances.
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// ignore
// Do nothing
/*
//www.apache.org/licenses/LICENSE-2.0
/** Facilitates virtual files e.g., IFileFragment */
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/** The file element hosting the fragment e.g., a comment or string literal */
/*
//www.apache.org/licenses/LICENSE-2.0
//  IFile getFakeFile( URL url, IModule module );
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// this check is too aggressive eg., including many jars we don't need to process
//!Extensions.getExtensions( root, "Main-Class" ).isEmpty() ||
// Weblogic packages all WEB-INF/classes content into this JAR
// http://middlewaremagic.com/weblogic/?p=408
// http://www.coderanch.com/t/69641/BEA-Weblogic/wl-cls-gen-jar-coming
// So we need to always treat it as containing sources
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
// We do not want to support this.
/*
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// no-op
// TODO - Throw if no more elements
/**
/**
/**
/**
/**
// We don't want to add the separator character after the windows network root; otherwise
// we want to add the separator in before adding in our name
/**
// no-op
/**
// Special hack:  the path string for the root element needs to
// include the separator unless it's the windows network root symbol
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Exclude directories that are not actual packages such as META-INF that exist in jar files
//## todo: also consider excluding a user-defined list of directories e.g., the ../config directories for XCenter
// add only if absent; respect class/sourcepath order
/*
//www.apache.org/licenses/LICENSE-2.0
//    try( InputStreamReader reader = new InputStreamReader( _enclosingFile.openInputStream() ) )
//    {
//      char[] fragment = new char[_length];
//      int length = reader.read( fragment, _offset, _length );
//      if( length != _length )
//      {
//        throw new IOException( "Expected fragment length " + _length + " but was " + length );
//      }
//      return new ByteArrayInputStream( new String( fragment ).getBytes() );
//    }
//    return getEnclosingFile().getBaseName() + '#' + _name;
// using enclosing file's uri for now because some type manifold Model's report() methods use the uri as file
//## todo: make a "filefragment" uri scheme like filefragment://C:/path/to/file.json#offset109length24
/*
//www.apache.org/licenses/LICENSE-2.0
// PL-21817 in OSGi/Equinox JAR could be named as "bundlefile"
// debug getting IAE only in TH - unable to parse URL with fragment identifier
/*
//www.apache.org/licenses/LICENSE-2.0
//    try {
/*.getCanonicalFile()*/;
//    } catch (IOException e) {
//      throw new RuntimeException(e);
//    }
//    try {
/*.getCanonicalFile()*/;
//    } catch (IOException e) {
//      throw new RuntimeException(e);
//    }
// This should always be called with the CACHED_FILE_SYSTEM_LOCK monitor already acquired
// This should always be called with the CACHED_FILE_SYSTEM_LOCK monitor already acquired
// If the timestamp is 0, assume it's been deleted
// in ms, absolute time
// in ms, absolute time
// This should always be called with the CACHED_FILE_SYSTEM_LOCK monitor already acquired
// If the timestamp is 0, assume it's been deleted
// Do nothing
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// Do nothing
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// IJarFileDirectory methods
// IDirectory methods
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/* Generated by Manifold */\n" );
// fields //\n" );
// methods //\n" );
// static blocks //\n" );
// constructors //\n" );
// properties //\n" );
//  private String getTypeVariables( StringBuilder sb )
//  {
//    if( _typeVars.isEmpty() )
//    {
//      return "";
//    }
//
//    sb.append( '<' );
//    for( int i = 0; i < gtvs.size(); i++ )
//    {
//      SrcTypeVar gtv = gtvs[i];
//      sb.append( i > 0 ? ", " : "" ).append( gtv.getSimpleName() );
//      String boundingType = gtv.getBoundingType();
//      if( boundingType != null )
//      {
//        sb.append( " extends ").append( boundingType );
//      }
//    }
//    sb.append( "> " );
//    return sb.toString();
//  }
// inner classes //\n" );
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Modifier.VARARGS
// Canonical order
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// prevent overriding Object#getClass()
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
// type annotations apply to class name part:  "java.util. @Foo List"
//!! ALWAYS USE FULLY QUALIFIED NAMES -- SOME USE CASES DEPEND ON FULLY QUALIFIED NAMES
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Handle "<any>" type used in javac to represent an Error type
// produce a type to reflect the errant javac <any> Type
//## note: ignoring type args for outer type of inner type e.g., abc.Outer<E>.Inner become abc.Outer.Inner
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//manifold.systems/docs.html#working-with-intellij">IntelliJ plugin</a>.
/**
/**
/**
/**
/**
// note type manifolds are sorted via getTypeManifoldSorter(), hence the use of TreeSet
/**
//noinspection ComparatorMethodParameterNotUsed
// Exclude type manifolds listed in the "manifold.exclude" sys property
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
// reflectively make modules accessible such as java.base and jdk.compiler
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// for subclasses
// for subclasses
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//en.wikipedia.org/wiki/Comma-separated_values">CSV</a> file.
// tolerate adding a file even though this is a single file model
// the idea is to issue a warning during compilation if this model has more than one file
// tolerate adding a file even though this is a single file model
// the idea is to issue a warning during compilation if this model has more than one file
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Sample code using embedded SQL
// Generated from Manifold
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/** Used to specify the preferred order a preprocessor runs wrt others */
/** Indicates a preprocessor should run before others */
/** Indicates a preprocessor should run after others */
/** Indicates the order is insignificant */
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/** Java source */
/** JavaScript source */
/** The {@ITypeManifold} does not contribute source */
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
//boolean filterError( TypeProcessor typeProcessor, Diagnostic diagnostic );
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
// Map primary type to model
// Map additional types to same model
// use same model as base fqn
// Add peripheral (global) types having separate model scheme
/**
/**
/**
/**
/**
// some environments (intellij) sometimes allow crazy stuff to parse as a name, ignore this
/**
// Now remove the model since we don't need it anymore
//.replace( "\r\n", "\n" );
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/** The location of the resource containing the feature "declaration" */
/** The offset of the feature declaration from the beginning of the file */
/** The length of the feature declaration */
/** The qualified type of the feature */
/** The name of the feature */
/** What kind of feature is this according to the resource's schema taxonomy? Optional. */
/** The line where the feature begins. Optional. */
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//www.w3.org/RDF/">RDF</a> could
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
// c.toArray might (incorrectly) not return Object[] (see 6260652)
/**
/**
/**
// minCapacity is usually close to size, so this is a win:
/**
/**
/**
/**
/**
/**
/**
// Make a new array of a's runtime type, but my contents:
// Positional Access Operations
/**
/**
/**
// Increments modCount!!
/**
// Increments modCount!!
/**
// Let gc do its work
/**
/*
// Let gc do its work
/**
// Let gc do its work
/**
// Increments modCount
/**
// Increments modCount
/**
// Let gc do its work
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// raw message includes {i} params
//noinspection ResultOfMethodCallIgnored
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// skip leading whitespace
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
// Defaulting
//-----------------------------------------------------------------------
/**
/**
/**
// Identity ToString
//-----------------------------------------------------------------------
/**
/**
/**
/**
// ToString
//-----------------------------------------------------------------------
/**
/**
// Min/Max
//-----------------------------------------------------------------------
/**
/**
// Null
//-----------------------------------------------------------------------
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//jakarta.apache.org/turbine/">Apache Jakarta Turbine</a>
/*
/**
/**
/**
/**
// Empty checks
//-----------------------------------------------------------------------
/**
/**
/**
/**
// Trim
//-----------------------------------------------------------------------
/**
/**
/**
/**
// Stripping
//-----------------------------------------------------------------------
/**
/**
/**
/**
/**
/**
// StripAll
//-----------------------------------------------------------------------
/**
/**
// Equals
//-----------------------------------------------------------------------
/**
/**
// IndexOf
//-----------------------------------------------------------------------
/**
/**
/**
/**
/**
// JDK1.2/JDK1.3 have a bug, when startPos > str.length for "", hence
// LastIndexOf
//-----------------------------------------------------------------------
/**
/**
/**
/**
// Contains
//-----------------------------------------------------------------------
/**
/**
/**
// IndexOfAny chars
//-----------------------------------------------------------------------
/**
/**
// ContainsAny
//-----------------------------------------------------------------------
/**
/**
// IndexOfAnyBut chars
//-----------------------------------------------------------------------
/**
/**
// ContainsOnly
//-----------------------------------------------------------------------
/**
// All these pre-checks are to maintain API with an older version
/**
// ContainsNone
//-----------------------------------------------------------------------
/**
/**
// IndexOfAny strings
//-----------------------------------------------------------------------
/**
// String's can't have a MAX_VALUEth index.
/**
// Substring
//-----------------------------------------------------------------------
/**
// handle negatives, which means last n characters
// remember start is negative
/**
// handle negatives
// remember end is negative
// remember start is negative
// check length next
// if start is greater than end, return ""
// Left/Right/Mid
//-----------------------------------------------------------------------
/**
/**
/**
// SubStringAfter/SubStringBefore
//-----------------------------------------------------------------------
/**
/**
/**
/**
// Substring between
//-----------------------------------------------------------------------
/**
/**
/**
// Nested extraction
//-----------------------------------------------------------------------
/**
/**
// Splitting
//-----------------------------------------------------------------------
/**
/**
/**
/**
/**
/**
/**
/**
/**
// Split on whitespace.
// The following is OK, because String.substring( beg, end ) excludes
// the character at the position 'end'.
// Set the starting point for the next search.
// The following is equivalent to beg = end + (separatorLength - 1) + 1,
// which is the right calculation:
// We found a consecutive occurrence of the separator, so skip it.
// String.substring( beg ) goes from 'beg' to the end of the String.
// -----------------------------------------------------------------------
/**
/**
/**
// Performance tuned for 2.0 (JDK1.4)
/**
/**
/**
// Performance tuned for 2.0 (JDK1.4)
// Direct code is quicker than StringTokenizer.
// Also, StringTokenizer uses isSpace() not isWhitespace()
// Null separator means use whitespace
// Optimise 1 character case
// standard case
/**
/**
/**
// Joining
//-----------------------------------------------------------------------
/**
/**
/**
/**
/**
/**
// endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))
//           (Assuming that all Strings are roughly equally long)
/**
// handle null, zero and one elements before building a buffer
// two or more elements
// Java default is 16, probably too small
/**
// handle null, zero and one elements before building a buffer
// two or more elements
// Java default is 16, probably too small
/**
/**
/**
// Remove
//-----------------------------------------------------------------------
/**
/**
/**
/**
/**
/**
// Replacing
//-----------------------------------------------------------------------
/**
/**
/**
/**
/**
// timeToLive should be 0 if not used or nothing to replace, else it's
// the length of the replace array
/**
// mchyzer Performance note: This creates very few new objects (one major goal)
// let me know if there are performance requests, we can create a harness to measure
// if recursing, this shouldnt be less than 0
// make sure lengths are ok, these need to be equal
// keep track of which still have matches
// index on index that the match was found
// index of replace array that will replace the search string found
// NOTE: logic duplicated below START
// see if we need to keep searching for this
// NOTE: logic mostly below END
// no search strings found, we are done
// get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit
// count the replacement text elements that are larger than their corresponding text being replaced
// assume 3 matches
// have upper-bound at 20% increase, then let Java take over
// find the next earliest match
// NOTE: logic mostly duplicated above START
// see if we need to keep searching for this
// NOTE: logic duplicated above END
// Replace, character based
//-----------------------------------------------------------------------
/**
/**
// Overlay
//-----------------------------------------------------------------------
/**
/**
// Chomping
//-----------------------------------------------------------------------
/**
/**
/**
/**
/**
/**
/**
// Chopping
//-----------------------------------------------------------------------
/**
/**
// Padding
//-----------------------------------------------------------------------
/**
// Performance tuned for 2.0 (JDK1.4)
/**
//www.unicode.org/glossary/#supplementary_character">Unicode Supplementary Characters</a>
/**
/**
// returns original String when possible
/**
// returns original String when possible
/**
/**
// returns original String when possible
/**
// returns original String when possible
/**
// Centering
//-----------------------------------------------------------------------
/**
/**
/**
// Case conversion
//-----------------------------------------------------------------------
/**
/**
/**
/**
/**
/**
/**
/**
/**
// Count matches
//-----------------------------------------------------------------------
/**
/**
// Character Tests
//-----------------------------------------------------------------------
/**
/**
/**
/**
/**
/**
/**
/**
/**
// Defaults
//-----------------------------------------------------------------------
/**
/**
/**
// Reversing
//-----------------------------------------------------------------------
/**
// Abbreviating
//-----------------------------------------------------------------------
/**
/**
// Difference
//-----------------------------------------------------------------------
/**
/**
/**
// find the min and max string lengths; this avoids checking to make
// sure we are not exceeding the length of the string each time through
// the bottom loop.
// handle lists containing all nulls or all empty strings
// handle lists containing some nulls or some empty strings
// find the position with the first difference across all strings
// we compared all of the characters up to the length of the
// shortest string and didn't find a match, but the string lengths
// vary, so return the length of the shortest string.
/**
// all strings were identical
// there were no common demo characters
// we found a common demo character sequence
// Misc
//-----------------------------------------------------------------------
/**
//www.merriampark.com/ld.htm">http://www.merriampark.com/ld.htm</a></p>
//www.merriampark.com/ldjava.htm">http://www.merriampark.com/ldjava.htm</a></p>
/*
// length of s
// length of t
// swap the input strings to consume less memory
//'previous' cost array, horizontally
// cost array, horizontally
//placeholder to assist in swapping p and d
// indexes into strings s and t
// iterates through s
// iterates through t
// jth character of t
// cost
// minimum of cell to the left+1, to the top+1, diagonally left and up +cost
// copy current distance counts to 'previous row' distance counts
// our last action in the above loop was to switch d and p, so p now
// actually has the most recent cost counts
/**
/*
// Method copied from NumberUtils to avoid dependency on subpackage
// startsWith
//-----------------------------------------------------------------------
/**
/**
/**
/**
// endsWith
//-----------------------------------------------------------------------
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Use the "user.dir" system property because we set this property to the experiment root.
// Note there is no way to set the current working directory at the OS level in Java, so we
// must use something like this.
// creates zip/jar file if not already exists
//## todo: find a better way, Files.isWritable() does not work e.g., returns true for ZipPath, which is wrong
/*
//www.apache.org/licenses/LICENSE-2.0
//noinspection ConstantConditions
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Capitalize/Uncapitalize reserved keywords to avoid parse errors.
// Internally we perserve the case of the keys, but in structure types
// we expose them as alternate versions of the reserved words.
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Load from Thread Context Loader
// (currently the IJ plugin creates loaders for accessing type manifolds from project classpath)
// not in the loader, check thread ctx loader next
// Also load from this loader
// avoid chicken/egg errors from attempting to build a module that self-registers a source producer
// it's important to allow a source producer module to specify its xxx.ITypeManifold file in its META-INF
// directory so that users of the source producer don't have to
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//## slow: warnIfRoot( p );
//## slow: warnIfRoot( p );
// necessary since java 9
// (surefile creates a classpath jar where the classpaths are formatted as URLs e.g., file://c:/blah, which blows up java 9)
// since we don't need this jar anyway, we omit it from the path
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// Using a relatively large block size to reduce the number of (very slow)
// native calls into the file system
/* disable construction */
/**
// shouldn't happen since UTF-8 is supported by all JVMs per spec
/**
// shouldn't happen since UTF-8 is supported by all JVMs per spec
/**
// shouldn't happen since UTF-8 is supported by all JVMs per spec
/**
// shouldn't happen with BAIS
/**
/**
// shouldn't happen since UTF-8 is supported by all JVMs per spec
/**
// shouldn't happen since UTF-8 is supported by all JVMs per spec
/**
/**
/**
/**
//    if( in instanceof FileInputStream && out instanceof FileOutputStream )
//    {
//      copy( (FileInputStream)in, (FileOutputStream)out );
//    }
//    else
//    {
//    }
/**
/**
/**
/**
//noinspection ResultOfMethodCallIgnored
//noinspection ResultOfMethodCallIgnored
/**
//noinspection ResultOfMethodCallIgnored
//noinspection ResultOfMethodCallIgnored
/**
/**
// done
// ignore io exceptions for input streams and readers
//  /**
/**
//   */
//  public static void copy( File fileOrDirectory, File toDir )
//  {
//    copy( fileOrDirectory, toDir, null );
//  }
//  /**
/**
//   */
//  public static void copy( File fileOrDirectory, File toDir, Predicate<Path> filter )
//  {
//    copy( fileOrDirectory.toPath(), toDir.toPath(), filter );
//  }
//
//  /**
/**
//   */
//  public static void copy( Path fileOrDirectory, Path toDir )
//  {
//    copy( fileOrDirectory, toDir, null );
//  }
//  /**
/**
//   */
//  public static void copy( Path fileOrDirectory, Path toDir, Predicate<Path> filter )
//  {
//    try
//    {
//      Files.walkFileTree( fileOrDirectory,
//                          EnumSet.of( FileVisitOption.FOLLOW_LINKS ), Integer.MAX_VALUE,
//                          new CopyFileVisitor( toDir, filter ) );
//    }
//    catch( IOException ioe )
//    {
//      throw new RuntimeException( ioe );
//    }
//  }
//
//  private static class CopyFileVisitor extends SimpleFileVisitor<Path>
//  {
//    private Path _from;
//    private Path _to;
//    private Predicate<Path> _filter;
//
//    CopyFileVisitor( Path to, Predicate<Path> filter )
//    {
//      _to = to;
//      _filter = filter;
//    }
//
//    @Override
//    public FileVisitResult preVisitDirectory( Path dir, BasicFileAttributes attrs ) throws IOException
//    {
//      if( _filter != null && !_filter.test( dir ) )
//      {
//        return FileVisitResult.SKIP_SUBTREE;
//      }
//
//      if( _from == null )
//      {
//        _from = dir;
//      }
//      else
//      {
//        Files.createDirectories( _to.resolve( _from.relativize( dir ) ) );
//      }
//      return FileVisitResult.CONTINUE;
//    }
//
//    @Override
//    public FileVisitResult visitFile( Path file, BasicFileAttributes attrs ) throws IOException
//    {
//      if( _filter == null || _filter.test( file ) )
//      {
//        Files.copy( file, _to.resolve( _from.relativize( file ) ) );
//      }
//      return FileVisitResult.CONTINUE;
//    }
//  }
/*
//www.apache.org/licenses/LICENSE-2.0
//todo: this prevents some names from working e.g., csv header column names tend to be pretty arbitrary and long and not very identifier-like
//          if( theRest.charAt( theRest.length() - 1 ) != '>' )
//          {
//            throw new IllegalTypeNameException( "\"" + theRest + "\" does not end with '>'" );
//          }
/*
//www.apache.org/licenses/LICENSE-2.0
// adding a child and setting userData must be an atomic operation,
// therefore userdata is assigned before child is added
// update reverse cache
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//  public static String get( String value ) {
//    String existing = INSTANCE._map.get( value );
//    INSTANCE._total++;
//    if( existing != null ) {
//      return existing;
//    }
//    INSTANCE._misses++;
//    INSTANCE._size += value.length();
//    INSTANCE._map.put( value, value );
//    return value;
//  }
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//    removeReleasedEntries();
//    removeReleasedEntries();
//    removeReleasedEntries();
//  private void removeReleasedEntries() {
//    while( true ) {
//      KeyedReference<T> ref = (KeyedReference<T>)_queue.poll();
//      if( ref == null ) {
//        break;
//      }
//      FqnCacheNode<WeakReference<T>> node = getNode( ref._fqn );
//      if( node != null && node.isLeaf() && node.getUserData() == ref ) {
//        _remove( ref._fqn );
//      //  System.out.println( "XXXXXX: " + (++_removed) + " : " + ref._fqn );
//      }
//    }
//  }
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*INOUT*/ byte[] buff )
/**
/**
/**
/**
/**
/**
/**
/**
/**
// NOTE pdalbora 23-Jul-2009 -- The following check is intentional. We don't extend the high order byte when it's
// zero, in order to avoid "weakening" the fingerprint of primarily ASCII data by adding unnecessary bits. The
// tradeoff for doing this is that two characters in the low order byte range (<= 0x00FF) will be
// indistinguishable from the corresponding character in the high order byte range (> 0x00FF). For example, the
// character sequence (0x0022, 0x0021) will have the same fingerprint as the character sequence (0x2122). However,
// it would be highly unlikely for this to happen, as ASCII data and non-ASCII data are unlikely to mix together.
// Even in the case where such a sequence pair occurred in two strings, the likelihood of it yielding a collision
// would be very low, when there other characters in the strings.
/**
/**
/* This class provides methods that construct fingerprints of
// implementation constants
// polynomials are represented with the coefficient for x^0
// in the most significant bit
// coefficient of x^63
/* This is the table used for extending fingerprints.  The
// Initialization code
// Maximum power needed == 64 + 8
//System.out.println("pow[" + i + "] = " + Long.toHexString(t));
// t = t * x
// group bit-wise overflows into bytes
//System.out.println("ByteModTable[" + j + "] = " + Long.toHexString(v));
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//## todo: move this to RuntimeManifoldHost after factoring ExtensionManifold#isInnerToJavaClass()
//    if( JavacPlugin.instance() == null )
//    {
//      // runtime
//      return Thread.currentThread().getContextClassLoader();
//    }
//    // compile-time
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// ensure output path is in the classpath
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Allow for the IRuntimeManifoldHost impl to be customised as a Java Service
// report, but do not throw, the exception; let the default host takeover
// default
/**
//ignore
// IntelliJ's PluginClassLoader is special
//    addBootstrapClasses( ll );
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//noinspection unchecked
//## todo: use location to select more specifically (in Java 9+ with the location's module)
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//noinspection ConstantConditions
// Must assign _module BEFORE initializeTypeManifolds() to prevent double bootstrapping
// Full type system monitoring is only necessary for an environment like an IDE where types change.
// Compilation and runtime environments should only care about *creation* events e.g., from a type embedded via @Type.
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
//  void modified( IResource file )
//  {
//    notify( file, RefreshKind.MODIFICATION );
//  }
//  void deleted( IResource file )
//  {
//    notify( file, RefreshKind.DELETION );
//  }
// for creation the file system needs to be updated *before* other listeners
// for deletion the file system needs to be updated *after* other listeners
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//noinspection unchecked
//noinspection unchecked
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// If an annotation processor is active, a class can be processed multiple times,
// so we check to see if we've already added the bootstrap block.
// don't bootstrap from an annotation class,
// many tools do not handle the presence of the <clinit> method well
// Don't insert bootstrap in a IManifoldHost impl
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// report errors to console
// report errors to console
// For the case where the class is generated from a type manifold esp. from a IExtensionClassProducer
//## want this instead, but the typeElement is not complete in this case, investigate this
//      if( JavacPlugin.instance() != null )
//      {
//        typeElement = IDynamicJdk.instance().getTypeElement( JavacPlugin.instance().getContext(), moduleCtx, fqn );
//        typeElement.complete();
//      }
// TreePath is only applicable to a source file;
// if fqn is not a source file, there is no compilation unit available
// For the case where the class is generated from a type manifold esp. from a IExtensionClassProducer
// need javac with ManifoldJavaFileManager because the produced class must come from manifold
// TreePath is only applicable to a source file;
// if fqn is not a source file, there is no compilation unit available
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//  /**
/**
//   */
//  public abstract boolean filterError( Diagnostic diagnostic );
//
// Process trees that were generated and therefore not available during ANALYZE
// For instance, we must process bridge methods
//
//
// Process fully analyzed trees (full type information is in the trees)
//
// already processed
//    if( visited == null && !isNested( e.getTypeElement().getEnclosingElement() ) && !isOuter( fqn ) )
//    {
//      // also process inner types of types to process and (outer type if processing inner type first)
//      return;
//    }
// mark processed
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*[>Foo.graphql<]
/*[>Foo.graphql<] query Persons { name address }*/
//[>Foo.graphql<] query Persons { name address }
/**
// skip '//'
// skip '/*'
/*'
// skip '/**'
/**'
// skip "
// end before terminating "
// skip """
// end before terminating """
// Name is optional if fragment is in a String literal e.g., "[>.sql<] blah blah" // just the dot is ok
//(note the reason why the dot is needed for anonymity is so multi-extension names can be distinguished
//esp. for template languages e.g., .html.mtl)
// name must be uniquely deterministic wrt content
/*
//www.apache.org/licenses/LICENSE-2.0
/**
///" + name.replace( '.', '/' ) + Kind.SOURCE.extension ), Kind.SOURCE );
///" + getName() );
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Java 9 & 10
// Java 11 or later
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
///" + className.replace( '.', '/' ) + kind.extension ), kind );
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//## would rather use javax.annotation.processing.Messager, but it doesn't give us what we want
/*
//www.apache.org/licenses/LICENSE-2.0
// Handle operator overloading
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
// Java 9 introduces StandardJavaFileManager#getLocationAsPaths() for validation, but there is a bug in their code
// where it does not check for empty iterable, which is what we do here
// exclusive to Java 9
//noinspection unchecked
/**
/**
/**
/**
/**
//return fileManager.getLocationForModule(location, moduleName);
/**
//return fileManager.getLocationForModule(location, fo);
/**
//return fileManager.getServiceLoader(location, service);
//noinspection unchecked
/**
//return fileManager.inferModuleName( location );
/**
//return fileManager.listLocationsForModules( location );
//noinspection unchecked
/**
//return fileManager.contains( location, fo );
//noinspection unchecked
//## todo: ...
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/** dynamic compilation mode */
/** disables &lt;clinit&gt; bootstap */
/** turns off checked exceptions (deprecated, use manifold-exceptions dependency) */
/** static mode (deprecated, now the default) */
/** enables string literal templating (deprecated, use manifold-strings dependency) */
/** all plugin args */
// ClassFinder is new in Java 9, its presence indicates Java 9 or later
// calling this here because the line below this references the type `BasicJavacTask`, which is in a jdk module needing exposure
// maven doesn't like the -Xplugin:"Manifold strings", it doesn't parse "Manifold string" as plugin name and argument, so we do it here:
// For type processing (##todo is this still necessary?)
//
// Both Java 8 and Java 9 alterations
//
// Override javac's Log for error suppression (@Jailbreak too, but that's only if extensions are enabled, see below)
// No need to hook up all the extension stuff if it's not enabled
// Override javac's Attr
// Override javac's ClassWriter
// Override javac's Resolve
// Override javac's TransTypes
// Override javac's Types
//
// Java 9 specific alterations
//
// Override javac's ClassFinder
// Override javac's JavaFileManager
// Assign our file manager to javac's various components
// Hack for using "-source 8" with Java 9
//noinspection ConstantConditions
//JavaFileObject classFile = _jpe.getFiler().createClassFile( ping );
// an explicit is compiling, determine the class path from its dependencies, which are allModules visible via Modules util
// Remove a path that is a parent of another path.
// For instance, "/foo/." is a parent of "/foo/classes", this must be unintentional
//noinspection StringEquality
//noinspection unchecked
/**
// If compiling from IntelliJ, we provide the resource paths definitively via a comment in
// the _Manifold_Temp_Main_.java file provided by our JPS plugin.
//noinspection unchecked
/**
//## ResourceRoots:";
// Must perform shenanigans early
// Initialize the Javac host environment
// Initialize the runtime host for dynamically loading darkj classes Manifold itself uses during compilation e.g., ManClassFinder_9
// Override javac's ClassFinder and Resolve so that we can safely load class symbols corresponding with extension classes
// override the ParserFactory to support fragments in comments and string literals
// add the fragments created during parsing
// If annotation processors are present, javac creates a whole new JavaCompiler and ctx before Analyze phase...
// Override javac's stuff again for the new ctx
// we construct BootstrapInserter reflectively because it extends TreeTranslator,
// which we have yet to open/export as JavacPlugin is loaded before that time
//noinspection Java8CollectionRemoveIf
//## todo: add compile warning
// ensure path cache is created before creation notify
/*
/*
//www.apache.org/licenses/LICENSE-2.0
// Adapted from JavacMessager.printMessage.  Following same basic routine regarding use of Log
// should be just one
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
// Share our existing Manifold file manager from Javac
// Make a new Manifold file manager exclusively for this JavaParser
//!! Do not init() here; do not use _javac or _mfm for parseExpr() since this method is generally used
//!! during the Parse phase, which happens earlier than the Enter phase where the plugin initializes much
//!! of its state i.e., if parseExpr() is called before an Enter phase, it could use Manifold prematurely
//!! and screw the pooch.  Also, we don't need Manifold for parsing expressions since it only produces a
//!! simple AST with nothing resolved.
// init();
/**
/**
/**
// short-circuit reentrancy during init()
/*
//www.apache.org/licenses/LICENSE-2.0
// note ==, !=, >, >=, <, <=  are covered via ComparableUsing
// Handle operator overloading
// pose with boolean return to satisfy type checker, this call will be transformed in ext transformer
// Attribute arguments
// Handle operator overloading
// replace the tree with JCBinary expressions reflecting the correct associativity and bindingOperator
// todo: maybe factor this out into a more efficient method from IDynamicJdk where Kind, KindSelector, and VAL can be referenced directly
// although this is only called for bonding expressions, so is somewhat infrequent
// Binding expr
// Support > >= < <= on any Comparable implementor
// Look for default interface methods impls
/*
//www.apache.org/licenses/LICENSE-2.0
// Override logger to handle final field assignment for @Jailbreak
/**
// record JCFieldAccess trees as they are visited so we can access them elsewhere while in context
/**
/**
// since method-calls can be nested, we need a tree of stacks TreeNode(JCTree.JCFieldAccess, Stack<JCDiagnostic>>)
// set qualifier type to supertype to handle private methods
// retry with supertype
// restore original type
// apply any issues logged for the found method (only the top of the suspend stack)
// binding expr
// Handle binding expressions
// pose as a MUL expr to pass binary expr checks
// Handle operator overloading
// Everything after left/right operand attribution (see super.visitBinary())
// Find operator.
// This will figure out when unboxing can happen and
// choose the right comparison operator.
// If both arguments are constants, fold them.
// Check that argument types of a reference ==, != are
// castable to each other, (JLS 15.21).  Note: unboxing
// comparisons will not have an acmp* opc at this point.
// Handle negation overloading
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
//System.err.println( "PATCH: " + fo.getName() );
// only retain primary class files e.g., don't keep stubbed class files from extension classes
// it's ok to write a type manifold class to disk if we're running javac and the class is not an extended java class
// ManChangedResourceBuilder from IJ plugin
// make a copy because this super call likes to remove the SOURCE kind in a multi-module project
// note, a null module indicates JavacPlugin is not initialized at ENTER phase yet
// Get a list of class files from the patch module location; these are patch candidates
//noinspection ConstantConditions
// NOT a ManPatchModuleLocation means NOT an extended class...
// and also NOT a class in a dependency that is not compiled, but
// needs to be dynamically compiled from the dependent module
// true if type is not exclusively an extended type
//noinspection unchecked
// type is from a dependency module, but was not compiled there, yet is
// referenced outside the module and needs to be dynamically compiled
// existing type is extended
// Module module = Modules.instance( _ctx ).getObservableModule( Names.instance( _ctx ).fromString( location.getName() ) );
// return module.classLocation;
// note userdata can be null in the case where an innerclass is loaded before the enclosing
// note we cache even if file is null, fqn cache is also a miss cache
// Remove all affected types for any refresh kind.
// Note we remove types for CREATION request because we could have cached misses to the type name.
// Since Java 10 javac uses .sig files...
/*
//www.apache.org/licenses/LICENSE-2.0
//      LambdaToMethod.instance( ctx ),
//      Lower.instance( ctx ),
//      MemberEnter.instance( ctx ),
//      TransTypes.instance( ctx ),
//      TypeAnnotations.instance( ctx ),
// Reassign Log fields
// Note this is only relevant when compiling with annotation processors
// Also reassign the 'log' fields in Check's various MandatoryWarningHandlers...
//noinspection StatementWithEmptyBody
// For @Jailbreak assignments, change error to warning re final var assignment
//## todo: the error message can't be converted to a warning, make up a custom warning
// report( diags.warning( source, pos, key, args ) );
//noinspection ConstantConditions
// found method in superclass, already recorded any issues from that attempt
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//override Java 9+
/**
// todo: passing raw characters means we must parse string literal escaped chars esp. '"', '\n', unicode
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// If using JavaParser.compile(), say from Lab, we don't care about modules, otherwise we run into trouble
/*ModuleElement*/ ms : (Iterable)ReflectUtil.method( elementUtils, "getAllModuleElements" ).invoke() )
//noinspection unchecked
//noinspection unchecked
// must return the fragment's enclosing class name to infer the module
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// handle the case where the class itself is inaccessible:
//
// // the *type* must be @Jailbreak as well as the constructor
// com.foo.@Jailbreak PrivateClass privateThing = new com.foo.@Jailbreak PrivateClass();
// privateThing.privateMethod();
// ...
// Java 9 +
// Allow augmented classes to access modules as if defined in both the extended class' module and
// the extension class' module.
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
//noinspection ConstantConditions
// Replace self type with qualifier type
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// sort according to preferred order
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// will become .java files
// wil become .javaX files
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//!! Note we preload because some environments (maven cough) reuse closed URLClassLoaders from earlier Javac runs,
//!! which will barf when trying to load any classes not already loaded e.g., those loaded during getCharContent() below
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// include private members because:
// 1. @Jailbreak can expose private members
// 2. Compiler error messages are better when referencing an inaccessible method vs. a non-existent one
//        long modifiers = SrcAnnotated.modifiersFrom( sym.getModifiers() );
//        if( Modifier.isPrivate( (int)modifiers ) )
//        {
//          continue;
//        }
// Add default no-arg ctor because enum constant stubs do not call a ctor explicitly
// Modifier.VARARGS
// Note we can't just throw an exception for the ctor body, the compiler will
// still complain about the missing super() call if the super class does not have
// an accessible default ctor. To appease the compiler we generate a super(...)
// call to the first accessible constructor we can find in the super class.
//noinspection ConstantConditions
//noinspection ConstantConditions
// Since java 10 we have to keep these out of stubbed java source
// Since java 10 we have to keep these out of stubbed java source
// cast to disambiguate when used as an argument
/*
//www.apache.org/licenses/LICENSE-2.0
/**
///" + name.replace( '.', '/' ) + Kind.SOURCE.extension ), Kind.SOURCE );
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//  @Override
//  public boolean filterError( Diagnostic diagnostic )
//  {
//    for( ITypeManifold sp: RuntimeManifoldHost.get().getSingleModule().getTypeManifolds() )
//    {
//      if( sp instanceof ITypeProcessor )
//      {
//        if( ((ITypeProcessor)sp).filterError( this, diagnostic ) )
//        {
//          return true;
//        }
//      }
//    }
//    return false;
//  }
// avoid re-entry of dynamic jdk construction
//JavacProcessingEnvironment.instance( getContext() ).getMessager().printMessage( Diagnostic.Kind.NOTE, "Processing: " + element.getQualifiedName() );
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//noinspection ResultOfMethodCallIgnored
//noinspection ResultOfMethodCallIgnored
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//= null;
//System.out.println( "WARNING: Can't wrap loader: " + loader.getClass().getTypeName() );
// we don't bother messing with any loaders above the system loader e.g., ExtClassLoader
/*
//    boolean bSysLoader = loader == ClassLoader.getSystemClassLoader();
//    if( bSysLoader )
//    {
//    }
//    else
//    {
//      ClassLoader parent = loader.getParent();
//      canWrap = wrapped != null && (parent == null || canWrapChain( parent ));
//    }
//" + loaderAddress + "/";
//    try
//    {
//      url = new URL( null, spec );
//    }
//    catch( Exception e )
//    {
// If our Handler class is not in the system loader and not accessible within the Caller's
// classloader from the URL constructor (3 activation records deep), then our Handler class
// is not loadable by the URL class, so we do this...
//    }
// Do not add protocol package since OSGi implementation of URLStreamFactory
// first delegates to those and only then calls service from Service Registry
// Remove our protocol from the list
// flag to prevent re-entry
//!! Do Not Rename or Remove this method.  Calls to it are generated by the compiler and javac hook.
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//ReflectUtil.method( classPath, "initLoader", URL.class, ReflectUtil.type( "com.intellij.util.lang.Loader" ) ).invoke( url, urlLoader );
//## todo: log error
//noinspection ConstantConditions
//## todo: log error
/*
//www.apache.org/licenses/LICENSE-2.0
//import java.lang.module.ModuleReader;
//import jdk.internal.loader.Resource;
//import jdk.internal.loader.URLClassPath;
/**
//implements ModuleReader
/*ModuleReader*/_delegate;
/*URLClassPath*/ _ucp;
/*ModuleReader*/ delegate, Object /*URLClassPath*/ ucp )
//@Override
//@Override
/*Resource*/ resource = ReflectUtil.method( _ucp, "getResource", String.class, boolean.class ).invoke( name, false );
//@Override
/*Resource*/ resource = ReflectUtil.method( _ucp, "getResource", String.class, boolean.class ).invoke( name, false );
//@Override
//@Override
//@Override
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Already visited
/*<ModuleReference, ModuleReader>*/ moduleToReader = (Map)ReflectUtil.field( _loader, "moduleToReader" ).get();
//noinspection unchecked
//## note: "jmod" files are not supported here because they are currently (2018) supported exclusively at compiler/linker time
/*ModuleReader*/ proxy = Proxy.newProxyInstance( moduleReaderClass.getClassLoader(), new Class<?>[]{moduleReaderClass},
//noinspection unchecked
/*ManModuleReader*/ _wrapper;
/*ManModuleReader*/ wrapper )
//## todo: look at other JRE impls (IBM) to see if they provide a different class loader / field name (other than Oracle's BuiltinClassLoader)
/*<String, ModuleReference>*/nameToModule = (Map)nameToModuleField.get();
//noinspection unchecked
//## note: "jmod" files are not supported here because they are currently (2018) supported exclusively at compiler/linker time
//noinspection unchecked
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Preload the Url Connection classes to prevent LinkageErrors during demo load
//## todo: we should try hard so that this never happens -- the type sys tries to resolve inner classes,
// which come back around here and always fail
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//noinspection deprecation
// Some tools (Equinox) expect to find a jar manifest file in the path entry, so we fake an empty one here
// If there were a class file for the Java type on disk, it would have loaded by now (the manifoldclass protocol is last).
// Therefore we compile and load the java class from the Java source file, eventually a JavaType based on the resulting class
// may load, if a source-based one hasn't already loaded.
// tools.jar likely not in the path...
// Avoid compiling until the bytes are actually requested;
// sun.misc.URLClassPath grabs the inputstream twice, the first time is for practice :)
//System.out.println( "Compiling: " + _type.getName() );
//        if( _bytecodeSupplier != null )
//        {
//          _buf = _bytecodeSupplier.get();
//        }
//noinspection ResultOfMethodCallIgnored
//noinspection ResultOfMethodCallIgnored
//noinspection ResultOfMethodCallIgnored
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
//noinspection unchecked
//noinspection unchecked
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// both endpoints included
// left endpoint excluded
// right endpoint excluded
// both endpoints excluded
// provides a `step` clause
// provides a `unit` clause
// test for range membership
// negative test for range membership
/**
/** Comparable */
/** Sequential */
/** BigDecimal */
/** BigInteger */
/** Double */
/** Long */
/** Integer */
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
//noinspection unchecked
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
//=================================================================
// Straight stream pass throughs
//=================================================================
//=================================================================
// Remove Optional
//=================================================================
//=================================================================
// Embellishments
//=================================================================
/**
//noinspection unchecked
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// expected
// expected
/**
// expected
// expected
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Dark Java files are intended to be compiled dynamically at runtime, they
// should never be compiled statically, otherwise just use normal Java.
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Dark Java is only available at runtime, bootstrap runtime
// Use reflection to work with Dark Java
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
//example.com/test" );
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//
// For now these are only used in the IntelliJ plugin
//
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
//noinspection ConstantConditions
//noinspection ConstantConditions
//noinspection ConstantConditions
//noinspection ConstantConditions
//noinspection ConstantConditions
//noinspection ConstantConditions
//noinspection ConstantConditions
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// Nominally implements ICallHandler
// Structurally implements ICallHandler
// maybe has an extension satisfying ICallHandler
// Nominally implements ICallHandler
// Structurally implements ICallHandler
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Interface methods
/*append( getTypeVarList( mi ) ).append( ' ' ).*/append( returnType.getCanonicalName() ).append( ' ' ).append( mi.getName() ).append( "(" );
//## todo: maybe we need to explicitly parameterize if the method is generic for some cases?
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//## todo: if fqn (the extension class) is source file, delegate the call to makeSrcClassStub() to the host somehow
//## todo: so that IJ can use it's virtual file, otherwise this uses the file on disk, which does not have local changes
// _location );
// short-circuit e.g., extension producers
//## todo: This is disabled because it involves calls to ClassSymbols#getClassSymbol() where another javac compiler task
//## todo: is spawned which can lead to perf problems because the same graph of types is recompiled over and over.
//## todo: Instead find a different way to get the type information e.g., ASM, dumb AST trees, etc.
//## todo: -- or ---
//## todo: Instead of checking for duplicates at this time, wait and do it during type processing i.e.,
//    if( warnIfDuplicate( method, extendedType, errorHandler ) )
//    {
//      return;
//    }
// the class is a produced class, therefore we must delegate the calls since calls are not replaced
// extension method must be default method in interface to not require implementation
//## Don't mark extension methods on classes as final, it otherwise blocks extended
//   classes from implementing an interface with the same method signature
//    else
//    {
//      // extension method must be final in class to prohibit override
//      modifiers |= Modifier.FINAL;
//    }
// remove static for instance method
// mark as extension method for efficient lookup during method call replacement
// extension method must reflect extended type's type vars before its own
// exclude This param
// delegate to the extension method
// stub the body
//## note: we are checking interfaces even for a non-abstract class because it could be
//## inheriting default interface methods, which must not be shadowed by an extension.
//noinspection SimplifiableIfStatement
//noinspection SimplifiableIfStatement
// checking only for simple name for cases where the name cannot be resolved yet e.g., extension method on another source producer type
//  private Symbol.MethodSymbol resolveMethod( Context ctx, JCDiagnostic.DiagnosticPosition pos, Name name, Type qual, com.sun.tools.javac.util.List<Type> args )
//  {
//    Resolve rs = Resolve.instance( ctx );
//    AttrContext attrContext = new AttrContext();
//    Env<AttrContext> env = new AttrContextEnv( pos.getTree(), attrContext );
//    env.toplevel = _tp.getCompilationUnit();
//    return rs.resolveInternalMethod( pos, env, qual, name, args, null );
//  }
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//## note: this is pretty sloppy science here, but we don't want to parse
// java or use asm here i.e., handlesFile() this has to be *fast*.
// .class file
// eat
// Include types extended by dynamically provided extension classes from IExtensionClassProducers
//## todo: This applies only to precompiled Java class files.
//## todo: Need to move this method to IManifoldHost for different use-cases (class files, javac symbols, and IJ psi)
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Don't process tree during GENERATE, unless the tree was generated e.g., a bridge method
// Handle operator overload expressions
// Equality requires null check before calling compareTo/Using():
//
// a == b
// ? true/false
// : a == null || b == null
//   ? false/true
//   : a.compareToUsing( b, op );
// (x > y) generated as: (x.compareTo(y) > 0)
// (x > y) generated as: (x.compareToUsing(y, GT))
// Create a temporary variable and corresonding identifier to avoid cop
// If methodCall is an extension method, rewrite it
// Replace with extension method call
// Concrete type set in attr
/**
// since the source may be preprocessed we attempt to get it in its preprocessed form
/** Expand a boxing or unboxing conversion if needed. */
//e.g. Character c = 89;
/** Box up a single primitive expression. */
/** Box up a single primitive expression. */
/** Unbox an object to a primitive value. */
// There must be a conversion from unboxedType to primitive.
// x.intValue()
/**
// Don't process tree during GENERATE, unless the tree was generated e.g., a bridge method
// Flag.Flag.PARAMETER.value
// Don't process tree during GENERATE, unless the tree was generated e.g., a bridge method
/**
// Don't process tree during GENERATE, unless the tree was generated e.g., a bridge method
// Flag.Flag.PARAMETER.value
// Don't process tree during GENERATE, unless the tree was generated e.g., a bridge method
// Don't process tree during GENERATE, unless the tree was generated e.g., a bridge method
// +=, -=, etc. operators not supported with jailbreak, only direct assignment
// Don't process tree during GENERATE, unless the tree was generated e.g., a bridge method
// handle negation overload
// Handle operator overload expressions
// If methodCall is an extension method, rewrite it accordingly
// Replace with extension method call
// ++, -- operators not supported with jailbreak access to fields, only direct assignment
// Don't process tree during GENERATE, unless the tree was generated e.g., a bridge method
// Don't process tree during GENERATE, unless the tree was generated e.g., a bridge method
// if the type itself is inaccessible and annotated with @Jailbreak, it will be erased to Object
// Don't process tree during GENERATE, unless the tree was generated e.g., a bridge method
// Don't process tree during GENERATE, unless the tree was generated e.g., a bridge method
// type
// the javac compiler generates casts e.g., for a generic call such as List#get()
// don't erase cast if we generated it here e.g.., for structural call cast on constructProxy
/**
// handle compiler-generated call to iterator(), sometimes a structural interface is involved here (lists in JSON)
// Don't process tree during GENERATE, unless the tree was generated e.g., a bridge method
// Replace with extension method call
// The structural interface method is implemented directly in the type or supertype hierarchy,
// replace with proxy call
// Method references not supported on extension methods
// Method references not supported on structural interface methods
// called reflectively from manifold core
// Called reflectively from manifold core
//## todo: shouldn't happen
// @Self not allowed on type param
// @Self allowed only on return type and parameters of an instance method
// @Self allowed only on class var, not local var
// This call surfaces the type in the compiler.  If compiling in "static" mode, this means
// the type will be compiled to disk.
// Keep track of Manifold types compiled, for hotswap compile drivers
// Ensure modified resource files are compiled, stemming from incremental compilation only
//noinspection unchecked
// nothing to compile
// This call surfaces the type in the compiler.  If compiling in "static" mode, this means
// the type will be compiled to disk.
// not a Manifold generated type
// nothing to add
// Keep track of compiled Manifold types during a Rebuild.
//
// Generally, since Manifold types are magically added to the build as
// they are referenced, they need to be mapped in the JPS compilation
// process to support hotswap debugging, etc.
//noinspection unchecked
// extension interfaces must be structural
/**
// we process bridge methods during Generation, since they don't exist prior to Generation
// Don't process tree during GENERATE, unless the tree was generated e.g., a bridge method
// Keep track of anonymous classes so we can process any bridge methods added to them
//    if( JavacPlugin.instance() == null )
//    {
//      // don't perform verification at runtime, slow
//      return;
//    }
// an extended class could be made a structural interface which results in Object as @This param, ignore this
// should not really get here, but should be static block scope if possible
// field initializers have a block scope
//## todo: maybe try to avoid reflection if the method is accessible -- at least check if the method and its enclosing nest of classes are all public
// No such field/method or wrong params
// receiver or class
// method name
// param types
// args
// handled in visitAssign() or visitAssignOp()
// supporting -, +, !, ~  not supporting --, ++
// No such field/method
// receiver or class
// field name
// receiver or class
// field name
// field value
//assert tree.constructor.kind == com.sun.tools.javac.code.Kinds.ERR;
// the class
// param types
// args
// class is publicly accessible, assume we can use class literal
// generate `ReflectUtil.type( typeName )`
//JavacHook.instance() != null ? (JavacTaskImpl)JavacHook.instance().getJavacTask_PlainFileMgr() : ClassSymbols.instance( _sp.getModule() ).getJavacTask_PlainFileMgr();
// In module mode if a package in another module is not exported, classes in the package
// will not be accessible to other modules, hence the null classSymbol
// This can happen during bootstrapping with Dark Java classes from Manifold itself
// So we short-circuit that here (ManClassFinder_9 or any other darkj class used during bootstrapping doesn't really need to use extensions)
//## todo: cache these
//## todo: cache these
//## todo: cache this
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// do not throw here, file creation events sometimes come in late after the
// model is created with a newly created file e.g., the Create Extension Class dialog
//
// throw new IllegalStateException( "Model already contains " + file.getName() );
/*
//www.apache.org/licenses/LICENSE-2.0
//noinspection ConstantConditions
//noinspection ConstantConditions
//noinspection ConstantConditions
//noinspection ConstantConditions
/*
//www.apache.org/licenses/LICENSE-2.0
// return findCachedProxy( root, iface ); // this is only beneficial when structural invocation happens in a loop, otherwise too costly
//## note: we'd like to avoid the operation if the obj not a ICallHandler,
// but that is an expensive structural check, more expensive than this call...
//  if( obj is a ICallHandler )
//  {
//   }
/**
// Person is a JsonTypeManifold interface; the runtime type of person here is really just a Map (or Binding)
// Extension method[s] satisfying IMyStructureThing on Person make this work e.g., via MyPersonExt extension methods class
// foo() is an extension method on Person e.g., defined in MyPersonExt, however the runtime type of thing is just a Map (or Binding) thus the Person type identity is lost
//## todo: this is inefficient, we should consider caching the methods by signature along with the interfaces
/**
//noinspection unchecked
// empty string is null e.g., CSV empty values are empty strings
//noinspection unchecked
// let the ClassCastException happen
// in Java 9+ in modular mode the proxy class belongs to the owner's module,
// therefore we need to make it accessible from the manifold module before
// calling newInstance()
//noinspection unchecked
// The self-proxy strategy avoids costs otherwise involved with generating and compiling the proxy at runtime via
// ICallHandler
// If the proxy factory declared in @Structural handles the rootClass, create the proxy via the factory
// See if there is a registered IProxyFactory for the rootClass and iface, so create one that way,
// otherwise return null
//noinspection ConstantConditions
// In Java 9+ in modular mode the proxy factory class belongs to the owner's module,
// therefore we need to use the constructor and make it accessible from the manifold module
// before calling newInstance() (as opposed to calling newInstance() from the class)
//return (IProxyFactory)factoryClass.newInstance();
//noinspection unchecked
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//  @Override
//  public Type visitMethodType( Type.MethodType mt, Void aVoid )
//  {
//    boolean erased = false;
//    ArrayList<Type> paramTypes = new ArrayList<>();
//    for( Type paramType: mt.getParameterTypes() )
//    {
//      Type param = visit( paramType );
//      if( param != paramType )
//      {
//        erased = true;
//      }
//      paramTypes.add( param );
//    }
//    Type returnType = visit( mt.getReturnType() );
//
//    if( returnType != mt.getReturnType() )
//    {
//      erased = true;
//    }
//    if( erased )
//    {
//      List<Type> pt = List.from( paramTypes );
//      mt = new Type.MethodType( pt, returnType, mt.getThrownTypes(), mt.asElement() );
//    }
//    return mt;
//  }
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Interface methods
/*append( getTypeVarList( mi ) ).append( ' ' ).*/append( returnType.getCanonicalName() ).append( ' ' ).append( mi.getName() ).append( "(" );
//## todo: maybe we need to explicitly parameterize if the method is generic for some cases?
// try not to let a field match when a method should match
// try not to let a field match when a method should match
//## todo:
//return isStructurallyAssignable( mi.getOwnersType(), type, mi, new TypeVarToTypeMap() );
//## todo:
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// use the raw type
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/** Use the {@code #compareTo()} method to implement `==` and `!=` */
/** Use the {@code equals()} method to implement `==` and `!=` (default) */
/** Use {@code identity} comparison for `==` and `!=`, note this is the same as Java's normal {@code ==} behavior } */
/** The method used to handle {@code ==} and {@code !=} */
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//manifold.systems/docs.html#type-safe-reflection">Type-safe Reflection</a> documentation for
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//manifold.systems/docs.html#the-self-type">Self Type</a> documentation
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//manifold.systems/docs.html#structural-interfaces">Structural Interfaces</a>
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//noinspection unchecked
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// Using LinkedHashMap to preserve insertion order, an impl detail currently required by the IJ plugin for rename
// refactoring i.e., renaming a json property should result in a source file that differs only in the naming
// difference -- there should be no difference in ordering of methods etc.
// eof
/*
//www.apache.org/licenses/LICENSE-2.0
//noinspection ConstantConditions
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// this test exercises ext-producer on a manifold type
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/**
//noinspection ResultOfMethodCallIgnored
//noinspection ResultOfMethodCallIgnored
//noinspection ResultOfMethodCallIgnored
//    leaf.foo(leaf.foo(leaf.foo(8)), false);
//    leaf.foo(leaf.foo());
//
//    leaf.foo("err");
//    leaf.foooo();
//
//    Leaf leaf2 = new Leaf();
//    leaf2.foo();
//    leaf2.foo(9);
//    leaf2.foo(9.0d);
//
//    leaf2.foo(leaf2.foo(8));
//    leaf2.foo(leaf2.foo());
//
//    leaf2.foo("err");
//    leaf2.foooo();
// instance method
// static method
// instance field
// static field
// new expr
// Test a class that is extended
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// returns CarBuilder
//    Bar bar = zeeBar.getMe();
//    bar.barMethod();
//    Bar[] bars = zeeBar.getArrayFoo();
//    zeeBar.addChild( new Bar() );
//    Bar child = zeeBar._children.get(0);
//"".hi();
//java.util.Date date = new java.util.Date( asdfg );
/**
/**
//assertEquals( "ok", list.stiff( "hi" ) );
// asserts object identity is not lost
// asserts object identity is not lost
// asserts object identity is not lost
// expected, cannot use structural type outside module scope of declared @Structural
// implements ITestFields
//implements Coordinate
// implements Coordinate
// implemnets Runnable
// implemnets Runnable
/**
// test warning for missing @This
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/** for static ext method test */
/**
//  // error, overloads method in StringBuffer
//  public static void append( @This StringBuffer thiz ) {}
//
//  // error, overloads method in CharSequence
//  public static void chars( @This StringBuffer thiz ) {}
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
// make Callable a structural interface
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//noinspection deprecation
// Date month is 0-based
// still a date, only a Chrono upon Chrono invocation
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// not public
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//localhost:8080/graphql?query=mutation+M{newTodo:createTodo(text:"This+is+a+mutation+example"){text+done}}'
//localhost:8080/graphql -H 'Content-Type: application/graphql' -d 'mutation M { newTodo: createTodo(text: "This is a mutation example") { text done } }'
//localhost:8080/graphql -H 'Content-Type: application/json' -d '{"query": "mutation M { newTodo: createTodo(text: \"This is a mutation example\") { text done } }"}'
/**
//en.wikipedia.org/wiki/List_of_HTTP_header_fields">HTTP header fields</a>
/**
/**
//[domain]/[oauth-service]
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
//noinspection unchecked
// used for tests
//noinspection unchecked
//noinspection unchecked
// DO NOT CHANGE THIS TO A LAMBDA, YOU WILL HAVE BAD LUCK FOR 9 YEARS
//noinspection Convert2Lambda
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// types, interfaces, unions, inputs, scalars, extensions
// register scalar type
// queries, mutations, subscriptions
// fragments
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Queries and mutations are the same thing -- web requests
// todo:
//noinspection unused
// Map of union type member to union types, facilitates nominal typing (for performance) e.g.,
//
//     union PointyShape = Triangle | Diamond
//
//     interface PointyShape { /* intersection methods of Triangle and Diamond */ }
/* intersection methods of Triangle and Diamond */ }
//
// Since we model a union as an interface consisting of the intersection of methods of its member types, by
// definition the member types logically implement the union, therefore the member type explicitly declares that it
// implements all unions of which it is a member:
//
//     interface Triangle extends PointyShape { ... }
//
// Thus we can nominally address a Triangle as a PointyShape:
//
//     PointyShape pointy = triangle;
//
// Note because we model graphql types as *structural* interfaces the nominal typing added here is unnecessary --
// because PointyShape is structural we could cast triangle. However, from a performance standpoint it is worthwhile
// because it saves us the initial cost of dynamic proxy generation, which otherwise adds considerable lag on first
// use.
// Queries and mutations are the same thing -- web requests
// todo:
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
// e.g., by convention a 'type' named "Query" is considered the root query type
// if one is not specified in the 'schema'
// The discriminator for the union
//noinspection unused
//noinspection unused
//## no setters for queries?
//      SrcSetProperty setter = new SrcSetProperty( propName, type )
//        .modifiers( Flags.DEFAULT )
//        .body( "getBindings().put(\"$name\", " + RuntimeMethods.class.getSimpleName() + ".coerceToBindingValue(${'$'}value));\n" );
//      addActualNameAnnotation( setter, name, true );
//      addSourcePositionAnnotation( srcClass, field, name, setter );
//      srcClass.addSetProperty( setter ).modifiers( Modifier.PUBLIC );
// assume the parser exposes the error
//noinspection unused
//noinspection unused
//## no setters for queries?
//      SrcSetProperty setter = new SrcSetProperty( propName, type1 )
//        .modifiers( Flags.DEFAULT )
//        .body( "getBindings().put(\"$name\", " + RuntimeMethods.class.getSimpleName() + ".coerceToBindingValue(${'$'}value));\n" );
//      addActualNameAnnotation( setter, name, true );
//      addSourcePositionAnnotation( srcClass, field, name, setter );
//      srcClass.addSetProperty( setter ).modifiers( Modifier.PUBLIC );
//noinspection unused
//noinspection unused
//## no setters for queries?
//      SrcSetProperty setter = new SrcSetProperty( propName, type1 )
//        .modifiers( Flags.DEFAULT )
//        .body( "getBindings().put(\"$name\", " + RuntimeMethods.class.getSimpleName() + ".coerceToBindingValue(${'$'}value));\n" );
//      addActualNameAnnotation( setter, name, true );
//      addSourcePositionAnnotation( srcClass, field, name, setter );
//      srcClass.addSetProperty( setter ).modifiers( Modifier.PUBLIC );
// inner interface of Result interface
/**
/**
/**
// There are two fields that differ in name only by the case of the first character "Foo" v. "foo".
// Since the get/set methods capitalize the name, we must differentiate the method names
// e.g., getFoo() and get_foo()
//noinspection unused
//noinspection unused
//noinspection OptionalGetWithoutIsPresent
// no common interface
// can only use one
// skip space
// not a scalar type, therefore it must be a 'type'
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// The Gql interfaces know how to convert value
/* [> MyEmbedded.graphql <]
/**[>MyEmbedded2.graphql<]
/*
//www.apache.org/licenses/LICENSE-2.0
// no cast
// no cast
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
//
// todo
//
// todo: make a unique class for each Symbol *instance* where the class has a static field with the Symbol's name.
// Then generate code to statically import the field.
//todo: add call to "Highjump.getInitialValue(\"" + symbol.getUid() + '$' + symbol.getName() + "\")" which will
// get the initialValue from the _fqnToSymbol map.
//
// IFileConnected (not file connected...)
//
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
//    Object result = Highjump.instance().evaluate( "2 + 2", Collections.emptyList(), Collections.emptyList(), null );
//    result = Highjump.instance().evaluate( "3 + 2", Collections.emptyList(), Collections.emptyList(), null );
//    System.out.println( result );
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//= FileWalkDirection.TOP_DOWN;
// = Integer.MAX_VALUE;
/**
/**
/**
/**
// Stack of directory states, beginning from the start directory
// There is nothing in the state
// Take next file from the top of the stack
// There is nothing more on the top of the stack, go back
// Check that file/directory matches the filter
// Proceed to a root directory or a simple file
// Proceed to a sub-directory
/**
/**
// First visit all files
// Then visit root
// That's all
/**
/**
// First visit root
// Then read an array of files, if any
// Then visit all files
// That's all
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
//noinspection ResultOfMethodCallIgnored
/**
/**
/**
/**
/**
/**
/**
/**
// Check roots
// Annihilate differing base components by adding required number of .. parts
// Add remaining this components
// If some .. were appended
/**
/**
//network.name/root as possible root names.
//network.name/root, but can detect Windows roots like C:/.
// Note: separators should be already replaced to system ones
// Network names like //my.host/home/something ? => //my.host/home/ should be root
// NB: does not work in Unix because //my.host/home is converted into /my.host/home there
// So in Windows we'll have root of //my.host/home but in Unix just /
// C:\
// C:
/**
//network.name/root as possible root names.
//network.name/root, but can detect Windows roots like C:/.
/**
//my.host/home for //my.host/home/user
/**
/**
//noinspection ResultOfMethodCallIgnored
/**
/**
/**
/**
/**
/**
// We cannot break for loop from inside a lambda, so we have to use an exception here
//noinspection ResultOfMethodCallIgnored
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*buffer*/, Integer/*bytesRead*/> action )
/**
/*buffer*/, Integer/*bytesRead*/> action )
/**
/*line*/> action )
// Note: close is called at forEachLine
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/** Creates a reader on this input stream using UTF-8 or the specified {@code charset}. */
/** Creates a buffered reader on this input stream using UTF-8 or the specified {@code charset}. */
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/** Creates a writer on this output stream using UTF-8 or the specified {@code charset}. */
/** Creates a buffered writer on this output stream using UTF-8 or the specified {@code charset}. */
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/** Returns a buffered reader wrapping this Reader, or this Reader itself if it is already buffered. */
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/** Returns a buffered reader wrapping this Writer, or this Writer itself if it is already buffered. */
/** Returns a buffered reader wrapping this Writer, or this Writer itself if it is already buffered. */
/**
//noinspection ResultOfMethodCallIgnored
/**
//    testCoverage(ManFileExt.class);
/*
//www.apache.org/licenses/LICENSE-2.0
//impl
// params
//impl
//impl
//noinspection unchecked
//noinspection unchecked
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
//noinspection unchecked
/*
//www.apache.org/licenses/LICENSE-2.0
//Calls the generated renderToString function with raw strings from template
//make argument list including the raw string list
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
//Constructor sets the src from which the parser reads
//Can only import classes at top of program
//Maybe parse class
//Parse program otherwise
//parse class name
//parse any super classes
//parse class body
//TODO: learn semi-colon syntax
//properties and functions can both be static
//'constructor'
//name of function
//Name of function
// property identifier
/*Concats parameters into a node*/
//ending paren or comma can follow identifier
//identifier must follow commas
/* Function: parseReturnType
/* Function: parseType()
/*starting from the opening parens for function parameters, parses the function params, return type,
/*Parses filler code and adds onto parent, as well watching for es6 features such as arrow functions
//Pause when seeing an arrow so we can add an arrow node
//Add filler node and create a new one
//continue parsing filler after consuming arrow node
//Pause when we see a backtick, and use the template parser to consume the template string
//continue parsing filler after consuming template string
//Pause when we see a function declaration to parse typescript style types
//reached the end token passed in to the argument; end parsing filler
//Concatenate tokens onto a filler node until a token is matched
//========================================================================================
// Utilities
//========================================================================================
/*Concats current token to a string builder*/
//Used to create lambda functions for matching tokens
/*assert an expectation for the current token then skip*/
/*Match single character punctuation*/
/*Match operators*/
/*Match reserved keywords only*/
/*Matches conditional keywords such as "constructor", which are sometimes keywords within a class
//If these class keywords aren't followed by an identifier, treat them as regular identifiers
//TODO: figure out when overriding java method if neccessary
//    IType superType = TypeSystem.getByFullName(packageName);
//    if (superType == null) return false;
//    for (IMethodInfo method : superType.getTypeInfo().getMethods()) {
//      if (method.getDisplayName().equals(functionName)) return true;
//    }
/*Move current token to the next token (including whitespace)*/
/*Move current token to the next non-whitespace token*/
/*
//www.apache.org/licenses/LICENSE-2.0
//Expressions either start with <% and and with %>; or start with ${ and end with }
/*Match template specific punctuation only*/
/*
//www.apache.org/licenses/LICENSE-2.0
//true if a JST template file, false if a template literal in a Util file
//token that enters an expressionOrStatement
//maps enter punctuation to exit punctuation (ex: "${" : "}")
//used to match curlies when exiting an expression
//transition from expression to rawstring
//if in statement, tokenize as normal
//transition from rawstring to expression; ${, <%, <%@, or <%=
//
// Entrance punctuations
//
//should be '{'
//
// Exit punctuations
//
//should be '>'
//skip over the \r in \r\n for windows files
//escape newlines since template literals can be multiline
//If escaped, skip escape character and return false
//'}' only exits expression if it matches with at the top of the stack ${
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
//Keeps track of beginning position of tokens
//Keeps track of current position of tokenizer
//Line number and col are 1 indexed; offset is 0 indexed (nextchar increments col and offset)
//keep track of position when we begin consuming a token
//For numbers that start with the decimal point
/*Forward slash will either result in a single line comment, multiline comment, or a operator token*/
//Throw away comments
/*Possible numbers are integers (decimal, hex, octal or binary)
//Mark if explicitly hex, octal, or binary
//Octal is implied if number starts with 0, but can still be dec if a 8 or 9 follows
//Limit one decimal point to floating point num
//Only dec can have decimal points
//changes octal to dec, so 0777 will be octal and 0778 will be dec
//If explicitly starts with 0x, 0o, or 0b; throw an error if nothing after
/* Helper for consume number; Consumes the exponent segment of a number, which will start with e (or E),
//consume 'e' or 'E'
//Consume optional + or -
/* Consumes and returns an word (either a identifier, keyword, boolean literal, or null)
/* Syntax for string literal taken from emca 6 language specs 11.8.4
//Can be either ' or "
//Consume string until we find a non-escaped quote matching the enter quote
//error if EOF comes before terminating quote
//error if line terminator in string
//Make sure escape sequences are legal
//add closing quote
/* Consume template string as a entire raw string. Template tokenizing and parsing are handled
//skip over `
//skip over closing backtick
/*Helper to consume and validate escape sequences;
/* Consumes single escapes (' " \ b \f n r t v), and non-escaped (such as 'a' where \ will be ignored)
/*Unicode escape sequence are either uHexHexHexHex or u{Hex+}*/
//consume 'u'
//keep track of hex number to check if valid unicode
//consume closing }
//error if exceeds max unicode number
//Must have exactly 4 hex digits in this pattern
/*hex escape sequences must be uHexHex*/
//consume 'x'
/*Consumes punctuation, which are all single characters*/
/*Keep consuming until we reach a non operator character or when adding the character makes a
/*" );
//Consume first two chars, which we know make '/*'
/*'
//error if EOF comes before terminating quote
//append closing slash
//" );
//Consume first two chars, which we know make '//'
//========================================================================================
// Utilities
//========================================================================================
//Returns the next character in the stream without updating _ch
//Updates the start token position when consuming a new token
/*
//www.apache.org/licenses/LICENSE-2.0
//For template files
//Keywords taken from ecma-262 6 11.6.2.1, excluding class which is its own token
//Taken from mozilla expressions and operators guide
//Assignment operators
//Comparator operators
//Arithmetic operators
//Bitwise operators
//Logical operators
//Ternary operators
//Arrow operator
//Rules for identifier names from emca-262 section 11.6.1
//todo: add unicode characters
//Taken from emca 6 language spec 11.3
/*
//www.apache.org/licenses/LICENSE-2.0
//If prev token is not ')', then there is only one parameter
//Otherwise, backtrack through list until opening parens
//## todo: this was ok with nashorn, but maybe not with rhino...
/*For expressions, use closure extension function (ex. function square(x) x*x;)*/
/*
//www.apache.org/licenses/LICENSE-2.0
//Test constructors
//If it's an override function, give as key value pair for Java.extend codegen from ClassNode
//If static, can be method of class directly
/*
//www.apache.org/licenses/LICENSE-2.0
/*Boiler plate code segments taken from babel.js*/
//Used for defining object properties
//Used to make sure classes can not be called as a function
//name of generated supertype object
//Makes sure constructor is called correctly
//Defines getters and setters
//Gen default constructor if no child found
//Should only have one constructor
//If superclass exists, instantiate superclass object inside constructor
//Create extended superclass object
//Add overridden methods
//Create property reference for the superclass object
//Create method for getting super object
//Possibly give superclass as arg
//Wrapper to hold getters and setters for the same property
//combines getters and setters for each property
//Separate static and non-static properties
//Get wrapper by property name, and insert name
//Combine the properties into an array
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*(Hopefully) Temporary Node to hold tokens that we don't parse and blindly concatenate*/
/*Either consists of a list of tokens or just a string of concatenated tokens*/
//Replace super with Java.super(_superClassObject) to support java-style super
//needs "this._superClassObject" to reference super if not function does not override
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/* Generates ES5 code */
/*
//www.apache.org/licenses/LICENSE-2.0
//Takes in parameter and type in string form
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*Returns the full package name of imported class (ex. java.util.ArrayList)
/*
//www.apache.org/licenses/LICENSE-2.0
//Test Constructor
//Should have one FunctionBodyNode child
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*Serves as the root for template files (.jst) . Generates a function with the template parameters as well as a
//boiler plate code for constructing string
//javascript variable that builds and returns string
//parameter of raw strings inputted into the template
//name of function; leaves room for parameters
//initializes str builder
//Add the header and parameters for the generated function
//Keep track of number of raw strings added to know which index of the raw string array to add
//Add whatever the expression evaluates to into the generated code
//Statement code not directly included in template output; instead is simply added into the genCode logic
/*raw strings will be passed into the function as a list, so just add the element from the argument list*/
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*Holds template literals inside javascript files. Supports interpolation and multiline characters*/
/**
//import demo.ExtendedArrayList;
//    ExtendedArrayList extendedArrayList = new ExtendedArrayList();
//    List asList = extendedArrayList;
//
//    asList.add(1);  // Overwritten function add, prints what was added when called
//    asList.add(2);
//    asList.add(3);
//
//    assertEquals(3, extendedArrayList.size());
//    assertEquals(42, extendedArrayList.demo());
/**
//success
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//tools.ietf.org/html/rfc4180">RFC 4180</a>. Note data in all fields is enclosed in double quotes.
/**
//tools.ietf.org/html/rfc4180">RFC 4180</a>. Note data in all fields is enclosed in double quotes.
// single entry with no name implies root, defer to the root
//todo: factor out Csv.CSV_DEFAULT_ROOT
// a single row of data consisting of the name/value pairs in the map
// A list of data
// a single row of data consisting of just one column of the name/value pair
// Csv header
// row of data
// single column of data
// Csv records
// Lists of lists not supported with CSV, just dumping text for each element to a single value
// single column of data
//json-schema.org/draft-04/schema#" );
// indicates this schema is not directly in the data file
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// leading/trailing whitespace significant?
// skip whitespace
// is quoted?
// when sampling favor the probability that one of these chars is the actual separator
// Assume NOT quoted because more data follows what would be a closing quote; let's be lenient and let
// this value be non-quoted (as opposed to making this an error).
//todo: add a warning here
// backtrack to quote
// separator
//todo: if quoted, add warning about missing terminal '"'
//noinspection ForLoopReplaceableByForEach
// EOF
// all header fields must be non-empty
// more fields in data row than header row! bail
// empty values are excluded from analysis
// more fields in header row than data row! bail
// skip header
// more fields in data row than header row! bail
// more fields in header row than data row! bail
// all null sample values for a column => String.class
// nothing merges with string
// nothing merges with boolean
// empty data does not contribute toward type inference
// none of the separators resulted in a consistent record size (rows had differing number of fields)
// default to comma, but the file may parse with errors
// always return '\n' as linebreak
// EOF
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/** Loader is a fluent API with methods for loading content from String, URL, file, etc. */
/** Writer is a fluent API to write this JSON object in various formats including JSON, YAML, CSV, and XML */
/** Provides a deep copy of this list */
//noinspection unchecked
/** For Internal Use Only */
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
// handle case for mixed array where component types are different (object and array)
// handle case for mixed array where component types are different (object and array)
// Empty list implies dynamic component type
// if the existing type is dynamic, override it with a more specific type,
// otherwise the types disagree...
// Keep the more specific type (Dynamic type is inferred from a 'null', thus the more specific type wins)
// Keep the more specific type
// merge the types
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//
// JSON methods
//
//
// YAML methods
//
//
// XML methods
//
//
// CSV methods
//
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//example.com/users").getOne("/$id");
// or
//example.com/users")
// eg., using OAuth token
/**
//example.com/users")
// eg., using OAuth token
//example.com/users"
/**
/**
//en.wikipedia.org/wiki/List_of_HTTP_header_fields>HTTP header fields</a>
/**
/**
//[domain]/[oauth-service]
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
//noinspection unchecked
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// String is compatible with all simple types
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// this is most likely a "definitions" inner class
//noinspection unused
//noinspection unused
//      addSourcePositionAnnotation( sb, indent + 2, key );
//noinspection unused
//noinspection unused
//noinspection UnusedAssignment
// Add a static create(...) method having parameters corresponding with "required" properties not having
// a "default" value.
// Provide a loader(...) method, returns Loader<typeName> with methods for loading content from String, URL, file, etc.
// Provide a requester(urlBase) method, returns Requester<typeName> with for performing HTTP requests using HTTP GET, POST, PUT, PATCH, & DELETE
// Allow non-schema files to load from themselves easily, also corresponds with @FragmentValue added to toplevel class
//noinspection unused
/**
//noinspection unused
//noinspection unused
//noinspection unused
// Json Schema types must be identity compared
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//
// State used exclusively during code generation, after resolve
//
// Using State to encapsulate state which facilitates cloning
// (this state must be shared across cloned versions, only the TypeAttributes state is separate per clone)
// Using LinkedHashMap to preserve insertion order, an impl detail currently required by the IJ plugin for rename
// refactoring i.e., renaming a json property should result in a source file that differs only in the naming
// difference -- there should be no difference in ordering of methods etc.
//      if( type instanceof JsonStructureType )
//      {
//        resolveInvertedUnionMember( entry.getKey(), (JsonStructureType)type );
//      }
/**
// union supers are not included for code gen
// assign required names, removing names that do not correspond to a property, and marking such names with an error
// verify each name corresponds with a property
//noinspection unchecked
//noinspection unchecked
// look in inner types
// look in definitions (json schema)
// look in union types
// Keep the more specific type (the dynamic type was inferred from a 'null' value, which should not override a static type)
// if the existing type is dynamic, override it with a more specific type,
// otherwise the types disagree...
// dump stack to diagnose unexpected error
// this is most likely a "definitions" inner class
//noinspection unused
// Include methods from super interfaces that are inner classes of this type
// Since Java does not allow a type to extend its own inner classes.  Note such
// a super type is not in the extends list of this interface.
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
// If additionalProperties is not defined, defaults to 'true'
// note if additionalProperties is false, there can still be patternProperties if they are defined, hence
// checking both values
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection UnusedAssignment
//noinspection unused
// Java does not allow extending your own inner class,
// instead we will grab all the methods from this later.
// See renderProperties().
// Add a static create(...) method having parameters corresponding with "required" properties not having
// a "default" value.
// Provide a builder(...) method having parameters matching create(...) above and providing
// withXxx( x ) methods corresponding with non "required" properties
// Similar to builder(), copier() takes an instance to copy and has withXxx() methods, and a copy() method
// Add a simple copy method for a deep copy
// Provide a loader(...) method, returns Loader<typeName> with methods for loading content from String, URL, file, etc.
// Provide a requester(urlBase) method, returns Requester<typeName> with for performing HTTP requests using HTTP GET, POST, PUT, PATCH, & DELETE
// Allow non-schema json files to load from themselves easily, also corresponds with @FragmentValue added to toplevel class
//noinspection unused
//noinspection unused
/**
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
// constructor
//noinspection unused
//noinspection unused
//noinspection unused
// constructor
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
/**
// Json Schema types must be identity compared
//noinspection ConstantConditions
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// not storing in _bytes because the string is in the bindings
// release potentially large array
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//
// From JSON value to Java value
//
//
// From Java value to JSON value
//
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//github.com/OAI/OpenAPI-Specification/blob/3.0.0-rc0/versions/3.0.md#schemaObject">OpenAPI Specification</a>
//
// From JSON value to Java value
//
//
// From Java value to JSON value
//
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Handle enum type
// Handle format types
// Enum type & Union type
// Format types
//noinspection ConstantConditions
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Standard temporal formats (JSON Schema 6)
// Non-standard temporal formats
// Non-standard number formats (see also BigNumberFormatResolver)
//noinspection ConstantConditions
//noinspection ConstantConditions
//
// From JSON value to Java value
//
// "date-time"
// "date"
// "time"
// "utc-millisec"
// "int64"
//
// From Java value to JSON value
//
// "date-time", "date", "time"
// "utc-millisec"
// "int64"
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// this is most likely a "definitions" inner class
// Enum constants with values
// static URL field
// _value field
// Constructor
// toBindingValue() method
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
//## todo: maybe be smarter about merging two format types?
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Ideally the "$schema" element would be required, but JSON Schema does not require it.
// As a fallback check for "$id" as this is pretty uniquely Json Schema
// As a fallback to the fallback, check for: "type": "object" or "type": "array"
// As a fallback to the fallback to the fallback, check for: "properties": (lots of use-cases like this unfortunately)
// move issues from errant cached type to the actual type
// Find by ref "id"
// Find by ref "location path"
// an empty "#" ref must resolve to the enclosing URL
// If the original ref is prefixed with '#', it was removed by the URI parser, try prepending it and roll dice.
// (Not sure why the JSON Schema docs uses an example where the 'id' begins with '#', which is the fragment
// separator char in a URI...)
// ref looks like: "#someType/foo/bar"
// thus we first lookup "#someType", and prepend its path
// {
//   "definitions": {
//     "Foo": {
//       "$id": "#someType"
//       ...
//     }
//   }
// }
// "#someType/foo/bar => "#/definitions/foo/bar"
// not an id
// build a path to the type
// Cache by FQN
// Also cache by Id (if defined)
// Copy format type to allow format type services to reuse types
// refParent is just a placeholder for definitions until the ref or combo type is constructe.
// Assign the definitions from the refParent to the actual parent
//noinspection unchecked
// No type or other means of deriving a type could be found.
// Default type is Dynamic (in Java this is Object)
// Note the "const" type is shorthand for a single element "enum" type
//
// "required"
//
//
// "$ref"
//
//
// "enum"
//
// Note enunType can't really be a super type. Basically if any types in an "allOf" are enum, they all have
// to be, thus the code gen logic can turn this structure type into a single enum type collapsing all enums
// into one. This includes any $ref enum types that may be super types.
//
// "properties"
//
//
// allOf", "oneOf", "anyOf"
//
// special handling required for combo as super type
// support refs like: "#/properties/blah".  They are the same as: "#/blah"
// relative to this file
// absolute address
// assume file system relative path
// use use IFile if url is a file e.g., IDE file system change caching
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
// shared state across type copies
// non-shared state that is different per type copy
//noinspection unused
//## todo: this switch is ripe, should be configurable as part of AbstractJsonTypeManifold somehow?
// include fragment directly as string literal
// avoid using a string literal, file could be very large, instead reference the corresponding resource file
//## todo: using getFqn(), which may not correspond with resource file name
//noinspection unused
//noinspection unused
// Must box primitive type for List<T>
//      if( parent instanceof JsonListType && parent.getParent() != null )
//      {
//        return getParentFromMe( parent, qualifiedWithMe );
//      }
//noinspection StringConcatenationInLoop
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// must cache now to handle recursive refs
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// not storing in _bytes because the string is stored in the bindings
// release potentially large array
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//noinspection unchecked
// Given o1 and o2, if o1 and o2 are not null, o1 && o2, otherwise the non-null value
// Given o1 and o2, if o1 and o2 are not null, o1 || o2, otherwise the non-null value
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
// jsonText = value.
// array = "[" [ value { "," value } ] "]".
// object = "{" [ member { "," member } ] "}".
// using a LinkedHashMap to preserve insertion order, necessary for IJ plugin
// member = string ":" value.
// value = object | array | number | string | "true" | "false" | "null" .
// we have an overflow, the tokenizer guarantees the format is correct
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
// handle hex numbers: 'A' = 65, '0' = 48. 'A'-'0' = 17, 17 - 7 = 10
/*
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// single entry with no name implies root, defer to the root
//todo: factor out Xml.XML_DEFAULT_ROOT
/**
// Add to parent
// Attributes
// Element text
// Child Elements
// Duplicates are put into a list and indirectly exposed through it
// Use the location of the first occurrence
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// Generated from XMLParser.g4 by ANTLR 4.4
/*
//www.apache.org/licenses/LICENSE-2.0
// Generated from XMLParser.g4 by ANTLR 4.4
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// Generated from XMLParser.g4 by ANTLR 4.7
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// Generated from XMLParser.g4 by ANTLR 4.4
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// Generated from XMLParser.g4 by ANTLR 4.7
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// Generated from XMLLexer.g4 by ANTLR 4.4
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// check circular dependencies
/*
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// add support for "PATCH"
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
//noinspection unchecked
//noinspection unchecked
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*[>MyObject.json<]
/**
/**
//assertNotNull( a );
// root array with dissimilar component types (object and array)
// repeat to test releasing of memory
// repeat to test releasing of memory
// Since the person interface is an inner class of FootballPlayer, FootballPlayer cannot extend it.  Here we
// test that FootballPlayer still implements person structurally.
//    angular.create(1).setSchematics(abc.angular.schematicOptions.create());
//    angular.create().
//
//    apple_app_site_association.create(apple_app_site_association.applinks.create(apple_app_site_association.applinks.apps.__, Arrays.asList(apple_app_site_association.applinks.details.builder().withAppID("foo").build())));
//    resume.builder().withBasics(
//            resume.basics.builder().withProfiles(Arrays.asList(resume.basics.profiles.builder().build())).build() );
/*
//www.apache.org/licenses/LICENSE-2.0
//## todo: enable after https://bitbucket.org/asomov/snakeyaml-engine/issues/8 is fixed
// assertEquals( "{\n}\n", empty.toYaml() );
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// EOF
// IDE
/*
//www.apache.org/licenses/LICENSE-2.0
// IDE
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// go up two since we already have the build.properties for its own parent
//noinspection unchecked
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/** Java source version*/
/** JPMS mode, defined by presence of module-info.java and if source version is > 8 */
/** Operating System of the compiler/IDE process */
/** Architecture of the compiler/IDE process */
//noinspection ConstantConditions
/**
//docs.oracle.com/javase/8/docs/technotes/tools/windows/javac.html">Standard Options</a>.
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// shouldn't happen
//noinspection AssignmentToForLoopParameter
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
//## todo: handle _isError, add logWarning()
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
// line comment 
// ding!
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// this is a crappy way to approximate the offset, we really need to parse the file ourselves and store the offsets
//assert offset >= 0;
// ignore indentation
//.replace( "\r\n", "\n" );
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//[>MyPropertiesRightHere.properties<] Foo=bar
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// note we don't want name here since we look up based on just left & right units
// i.e., we don't want to have to name units all the time, just look them up by left & right units
// && _name == that._name
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/** The magnitude stored in Base units */
/** The unit used to display the value of this instance */
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
//noinspection unchecked
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// reifies to same type :(
//abstract public A divide( B b )
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/* Default arithmetic implementation */
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// Extract the Period from the date-based time and add that
// Extract the Period from the date-based time and add that
/*
//www.apache.org/licenses/LICENSE-2.0
// Extract the Period from the date-based time and add that
// Now add the remaining fractional day part, if non-zero, as a Duration (added to the date-time's time component)
// Extract the Period from the date-based time and add that
// Now add the remaining fractional day part, if non-zero, as a Duration (added to the date-time's time component)
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
//@BinderSeparators( :accepted = {":"} )
//@BinderSeparators( :accepted = {":"} )
//@BinderSeparators( :accepted = {":"} )
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// x squared
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// commonly used unit abbreviations e.g., m, ft, hr, mph, etc.
// 5 meters
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//www.npl.co.uk/si-units/metre">npl.co.uk</a>)
/**
// SI Units
// US Standard
// Navigation
// Very large
// Very small
// Ancient
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// commonly used unit abbreviations e.g., m, ft, hr, kg, etc.
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//www.npl.co.uk/si-units/kilogram">npl.co.uk</a>)
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// 1.25 Million
// 1.25 Million
// 1.25 milli or 0.00125
// 'fe', not 'f' because conflicts with number literal float suffix
// 'de', not 'd' because conflicts with number literal float suffix
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// commonly used unit abbreviations e.g., m, ft, hr, dC, etc.
// rational coercion
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//www.npl.co.uk/si-units/kelvin">npl.co.uk</a>)
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// commonly used unit abbreviations e.g., m, ft, hr, mph, etc.
// add hours to seconds
//
// TemporalAmount impl
//
//
// Operators
//
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//www.npl.co.uk/si-units/second">npl.co.uk</a>)
/**
// SI Units
// Mean Gregorian (ISO Calendar) units
// Mean Tropical (Solar) units
// Planck-time
// For compatibility with java.time
//
// TemporalUnit Impl
//
//
// Operators
//
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
//
// Compass
//
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// SI metric unit factors
//
// Byte unit factors for quantities of digital information (International Electrotechnical Commission)
//
// kibibyte (prev. kilobyte)
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
// calling reduce() has a side effect of setting _reduced to true if this instance is found to be in reduced form
/**
//todo: a rational impl
// note: cast to Object to avoid using Rational's operator impl on == which is this method (avoids stack overflow)
//noinspection RedundantCast
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// pound-force unit </code></pre>
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
//!! Highly experimental!
// todo: add trig functions for Rational
// todo: add trig functions for Rational
//todo: for better accuracy use magnitude and angle components instead of x, y coords
// todo: add trig functions for Rational
//noinspection unchecked
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// Length / Time = Velocity
// Length / Velocity = Time
// Length * Area = Volume
// Length * Force = Energy
// multiplication undefined
// Time * Velocity = Length
// Time * Acceleration = Velocity
// Time * Current = Charge
// Time * Frequency = Angle
// Time * Power = Energy
// Time * Force = Momentum
// multiplication undefined
// Mass * Acceleration = Force
// Mass * Velocity = Momentum
// Mass * Area = Pressure
// Mass * Volume = Density
// multiplication undefined
// multiplication undefined
// multiplication undefined
/*
//www.apache.org/licenses/LICENSE-2.0
// A Time value expressed in non-date based units e.g., Seconds, works using the raw amount of time as opposed to
// the calendar amount derived from a date-based time amount.
// A Time value expressed in date-based units such as Month works in terms of calendar value
// A Time value expressed in non-date based units e.g., Seconds, works using the raw amount of time as opposed to
// the calendar amount derived from a date-based time amount.
// A Time value expressed in date-based units such as Month works in terms of calendar value
/*
//www.apache.org/licenses/LICENSE-2.0
// tests javac internals re binding expr in arg position of an overloaded method,
// deals with speculative multi-pass attribution for method scoring (note assertEquals() is an overloaded method)
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// first, establish that double loses precision
// now test that rational coercion preserves precision even though coded as a double literal 
// first, establish that double loses precision
// now test that rational coercion preserves precision even though coded as a double literal
/*
//www.apache.org/licenses/LICENSE-2.0
//  @Test
//  public void testSequence() {
//    StringBuilder sb = new StringBuilder();
//    for( rat : (-2r..2r).step( 1r/3 ) ) {
//      sb.append( rat.toMixedString() ).append( ", " );
//    }
//    assertEquals( "-2, -1 2/3, -1 1/3, -1, -2/3, -1/3, 0, 1/3, 2/3, 1, 1 1/3, 1 2/3, 2, ", sb.toString() );
//  }
// tests with comparableWith equality
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// don't allow string templates in fragments e.g., interferes with graphql and awkward to use @DisableStringLiteralTemplates
// add
/*
//www.apache.org/licenses/LICENSE-2.0
// Install the handler so we can filter the 'illegal escape character' errors for \$
// Uninstall the handler after the file parses (we create new handler for each file)
// processor
// Disable string templates inside annotations. Reasons:
// 1. spring framework has its own $ processing that interferes
// 2. annotation processors in IDEs won't work with it
// 3. there's not enough benefit to justify the cost of fixing the above problems
// See https://github.com/manifold-systems/manifold/issues/102
// enforce concatenation
// insert an empty string so concat will make the expr a string
// Log#error() will prepend "compiler.err", so we must remove it to avoid double-basing the message
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// Note the MyTemplateProcessorGate class from the manifold-strings-test-excl dependency
// excludes this class from string template processing. This is what makes the test work.
/*
//www.apache.org/licenses/LICENSE-2.0
// this is for testing only
// for test
/*
//www.apache.org/licenses/LICENSE-2.0
// NO-OP tracer by default
/*
//www.apache.org/licenses/LICENSE-2.0
//only for the outermost class
//continue;
//TODO: Fix this to get the correct line number (of the end of the file?)
//className
//className
//           params, paramsList
//className, params,            conditional
//className, params,            conditional
//className, params, paramsList
//
//
//className
//the directive is invalid
//imports "[static] [class_name]"
//extends "[class_name]"
//params ([paramType paramName], [paramType paramName],...)                  <---nothing stored for params or end section
//include "[templateName]"([paramVal], [paramVal],...) (conditional)
//nest "[templateName]"([paramVal], [paramVal],...) (conditional)
//section "[sectionName]"([paramType paramName], [paramType paramName],...)
//end section
//iff section, params, nest, and include (empty string if params not given for include/nest)
//iff section and params only (include/nest doesn't need it broken down bc types aren't given)
//iff include/nest
/**
/**
// todo: this needs grownup attention (it's using hard-coded offsets, instead it should be tokenized etc.)
/**
//given a list of 2 element String lists (0th elem is type and 1st elem is value), returns the string form
//ex. [[String, str],[int,5]] returns "String str, int 5"
//First Group: Matches Type arg format
//Second & Third Group: Deals with matching within strings
// for tests to avoid files
// eg. can happen during editing in IJ
// constructor
// render
// renderInto
// nestInto
// close class
//       sb.newLine( '@'+DisableStringLiteralTemplates.class.getTypeName() );
//close class
//!! only for tests
// verbatim
// sb.newLine( "                buffer.append(\"" ).append( text.replaceAll( "\"", "\\\\\"" ).replaceAll( "\r", "" ).replaceAll( "\n", "\\\\n" ) + "\");" );
// remove leading new line (which follows the preceding non-content token)
// remove leading new line (which follows the preceding non-content token)
// remove trailing indentation (which precedes the following non-content token)
//noinspection unused
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// No secondary extension in name, keep fqn as-is
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
// E.g., to trigger indentation for the `nest` directive
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// append directly to target
// buffer appends, append to target in `complete()`
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
//noinspection ConditionalBreakInInfiniteLoop
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*[>MyFragmentTest.html.mtl<]
//manifold.systems/manifold-templates.html",
//these errors have to be tested by hand and eye-balled
//    @Test
//    public void basicErrorWorks() {
//        BasicRuntimeError.render();
//    }
//
//    @Test
//    public void layoutErrorWorks() {
//        HasLayoutRuntimeError.render();
//    }
/**
//        assertLineColPosAre(tokenizer.tokenize("<html>${2 + 2}</html>"),1, 1, 0, 1, 7, 6, 1, 15, 14);
//assertLineColPosAre(tokenizer.tokenize("<html><% if(true) { %> foo <% } else { %> bar <% } %></html>"),
//        1, 1, 0, 1, 1, 8, 1, 1, 14);
//
//    @Test
//    public void statementErrorTest() {
//        Tokenizer tokenizer = new Tokenizer();
//        tokenizer.tokenize("<% foo");
//        tokenizer.tokenize("<% abc <% abc %> %>");
//        tokenizer.tokenize("<% ${ } %>");
//        tokenizer.tokenize("<% Abc <%@ abc %> %>");
//
//        List<String> expectedMessages = new ArrayList<>();
//        expectedMessages.add("Tokenization Error: STATEMENT is not closed");
//        expectedMessages.add("Attempted to open new statement within STATEMENT");
//        expectedMessages.add("Attempted to open new expression within STATEMENT");
//        expectedMessages.add("Attempted to open new directive within STATEMENT");
//
//        assertEquals(tokenizer.getIssues().size(), expectedMessages.size());
//        for(int i = 0; i < expectedMessages.size(); i += 1) {
//            assertEquals(tokenizer.getIssues().get(i).getMessage(), expectedMessages.get(i));
//        }
//
//    }
//
//    @Test
//    public void directiveErrorTest() {
//        Tokenizer tokenizer = new Tokenizer();
//        tokenizer.tokenize("<%@ foo");
//        tokenizer.tokenize("<%@ abc <% abc %> %>");
//        tokenizer.tokenize("<%@ ${ } %>");
//        tokenizer.tokenize("<%@ Abc <%@ abc %> %>");
//
//        List<String> expectedMessages = new ArrayList<>();
//        expectedMessages.add("Tokenization Error: DIRECTIVE is not closed");
//        expectedMessages.add("Attempted to open new statement within DIRECTIVE");
//        expectedMessages.add("Attempted to open new expression within DIRECTIVE");
//        expectedMessages.add("Attempted to open new directive within DIRECTIVE");
//
//        assertEquals(tokenizer.getIssues().size(), expectedMessages.size());
//        for(int i = 0; i < expectedMessages.size(); i += 1) {
//            assertEquals(tokenizer.getIssues().get(i).getMessage(), expectedMessages.get(i));
//        }
//    }
//
//    @Test
//    public void expressionErrorTest() {
//        Tokenizer tokenizer = new Tokenizer();
//        tokenizer.tokenize("${ foo");
//        tokenizer.tokenize("${ abc <% abc %> }");
//        tokenizer.tokenize("${ ${ } }");
//        tokenizer.tokenize("${ Abc <%@ abc %> }");
//
//        List<String> expectedMessages = new ArrayList<>();
//        expectedMessages.add("Tokenization Error: EXPRESSION is not closed");
//        expectedMessages.add("Attempted to open new statement within EXPRESSION");
//        expectedMessages.add("Attempted to open new expression within EXPRESSION");
//        expectedMessages.add("Attempted to open new directive within EXPRESSION");
//
//        assertEquals(tokenizer.getIssues().size(), expectedMessages.size());
//        for(int i = 0; i < expectedMessages.size(); i += 1) {
//            assertEquals(tokenizer.getIssues().get(i).getMessage(), expectedMessages.get(i));
//        }
//
//    }
/**
/**
//    private void assertTokenContentsAre(List<Token> tokenize, String... stringContent) {
//        assertEquals(tokenize.size(), stringContent.length);
//        for (int i = 0; i < tokenize.size(); i++) {
//            Token token = tokenize.get(i);
//            assertEquals(stringContent[i], token.getText());
//        }
//    }
//  }
//    private void assertTokenContentsAre(List<Token> tokenize, String... stringContent) {
//        assertEquals(tokenize.size(), stringContent.length);
//        for (int i = 0; i < tokenize.size(); i++) {
//            Token token = tokenize.get(i);
//            assertEquals(stringContent[i], token.getText());
//        }
//    }
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
// indexOfAny()
/**
/**
/**
/**
/**
/**
// indexOf
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*[>MyYamlObject.yaml<]
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*Context*/ ctx )
//noinspection ConstantConditions
//noinspection ConstantConditions
/*Module*/ manifoldModule = ReflectUtil.method( Class.class, "getModule" ).invoke( JreUtil.class );
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// above statement always throws, this is unreachable
//noinspection unchecked
/*
//www.apache.org/licenses/LICENSE-2.0
// Shutdown Oracle's attempt at blacklisting fields and methods from reflection in Java 12
// runtime
// compile-time
// Disable Java 9 warnings re "An illegal reflective access operation has occurred"
//
// Module: manifold jars
//
//      Object /*Module*/ manifoldModule = ReflectUtil.method( Class.class, "getModule" ).invoke( NecessaryEvilUtil.class );
/*Module*/ manifoldModule = ReflectUtil.method( Class.class, "getModule" ).invoke( NecessaryEvilUtil.class );
/*Module*/ manifoldModule = ReflectUtil.field( "java.lang.Module", "EVERYONE_MODULE" ).getStatic();
//
// Module: java.base
//
/*Module*/ javaBaseModule = ReflectUtil.method( Class.class, "getModule" ).invoke( String.class );
// for jailbreak
//
// Module: jdk.compiler
//
/*Module*/ jdkCompilerModule = ReflectUtil.method( Class.class, "getModule" )
//
// Module: jdk.javadoc
//
// Warn and continue
//System.out.println( "\nWARNING: Failed to find class 'jdk.javadoc.internal.doclets.formats.html.HtmlDoclet'\n" );
/*Module*/ jdkJavadoc = ReflectUtil.method( Class.class, "getModule" ).invoke( HtmlDoclet );
// `com.sun.tools.doclets.standard.Standard` and `com.sun.tools.javadoc.main.Main` are removed in JDK 13
// not modular java 9+
//System.err.println( "PACKAGE: " + pkg );
/* to root module[s], you must add the following argument to jave.exe:\n" +
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//manifold.systems/docs.html#type-safe-reflection">Type-safe Reflection</a>.)
//private static final ConcurrentHashMap<String, Boolean> _openPackages = new ConcurrentHashMap<>();
/**
//openPackage( fqn, null );
/**
//openPackage( fqn, cl );
/**
/**
/**
/**
/**
/**
/**
/**
/**
// already loaded
/**
/**
//## not necessary (until Unsafe goes away), using Unsafe.putObjectVolatile() to set 'override' directly
//
//  private static void openPackage( String fqn, ClassLoader cl )
//  {
//    if( JreUtil.isJava8() || _openPackages.containsKey( fqn ) )
//    {
//      return;
//    }
//
//    int iDot = fqn.lastIndexOf( '.' );
//    if( iDot < 0 )
//    {
//      return;
//    }
//
//    String pkg = fqn.substring( 0, iDot );
//    cl = cl == null ? ReflectUtil.class.getClassLoader() : cl;
//    LiveFieldRef packageToModule = WithNull.field( cl, "packageToModule" );
//    if( packageToModule != null )
//    {
//      Object loadedModule = ((Map)packageToModule.get()).get( pkg );
//      if( loadedModule != null )
//      {
//        if( method( loadedModule, "loader" ).invoke() == cl )
//        {
//          String moduleName = (String)method( loadedModule, "name" ).invoke();
//          //noinspection unchecked
//          Object module = ((Optional)ReflectUtil.method( ReflectUtil.method( "java.lang.ModuleLayer", "boot" ).invokeStatic(), "findModule", String.class ).invoke( moduleName )).orElse( null );
//          if( module != null )
//          {
//            Class<?> classModule = ReflectUtil.type( "java.lang.Module" );
//            ReflectUtil.MethodRef addExportsOrOpens = method( classModule, "implAddExportsOrOpens", String.class, classModule, boolean.class, boolean.class );
//            //noinspection ConstantConditions
//            Object /*Module*/ manifoldModule = method( Class.class, "getModule" ).invoke( ReflectUtil.class );
/*Module*/ manifoldModule = method( Class.class, "getModule" ).invoke( ReflectUtil.class );
//            //noinspection ConstantConditions
//            addExportsOrOpens.invoke( module, pkg, manifoldModule, true, true );
//            _openPackages.put( pkg, true );
//            return;
//          }
//        }
//      }
//    }
//    _openPackages.put( pkg, false );
//  }
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//statistics
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
// walk up the list until a node can be linked
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
// do nothing
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//creativecommons.org/licenses/publicdomain
/**
/*
/* ---------------- Constants -------------- */
/**
/**
/**
/**
/**
// slightly conservative
/**
/* ---------------- Fields -------------- */
/**
/**
/**
/* ---------------- Small Utilities -------------- */
/**
// Spread bits to regularize both segment and index locations,
// using variant of single-word Wang/Jenkins hash.
/**
/* ---------------- Inner Classes -------------- */
/**
/**
/**
/*
/**
/**
/**
/**
/**
/**
/**
/**
/**
/* Specialized implementations of map methods */
// read-volatile
// recheck
// read-volatile
// read-volatile
// recheck
// ensure capacity
// adjust from possible weak cleanups
// write-volatile
// write-volatile
/*
// We need to guarantee that any existing reads of old Map can
//  proceed. So we cannot yet null out each bin.
//  Single node on list
// Reuse trailing consecutive sequence at same slot
// Clone all remaining nodes
// Skip GC'd weak refs
/**
// a weak remove operation compares the WeakReference instance
// All entries following removed node can stay
// in list, but all preceding ones need to be
// cloned.
// Skip GC'd keys
// write-volatile
// replace the reference queue to avoid unnecessary stale cleanups
// write-volatile
/* ---------------- Public operations -------------- */
/**
// Find power-of-two sizes best matching arguments
/**
/**
/**
/**
/**
/*
// If mcsum happens to be zero, then we know we got a snapshot
// before any modifications at all were made.  This is
// probably common enough to bother tracking.
/**
// Try a few times to get accurate count. On failure due to
// continuous async changes in table, resort to locking.
// force retry
// Resort to locking all segments
/**
/**
/**
// See explanation of modCount use above
// Try a few times without locking
// Resort to locking all segments
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/* ---------------- Iterator Support -------------- */
// Strong reference to weak key (prevents gc)
// Skip GC'd keys
/*
/**
/**
/* ---------------- Serialization Support -------------- */
/**
// Skip GC'd keys
/**
// Initialize each segment to be minimally sized, and let grow.
// Read the keys and values, and put the mappings in the table
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//?
//?
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//The extra space makes all the difference
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// Duplicate the field layout of AccessibleObject so we can get the offset of the `override` field
// since we run this test in Java 8, we can test that the approximated offset for Java 12 matches the actual offset
