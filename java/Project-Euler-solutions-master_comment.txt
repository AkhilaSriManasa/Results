/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// This forces every solution class to implement a common interface,
// which is helpful for unit testing like in the EulerTest implementation.
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Returns the reverse of the given string.
// Tests whether the given string is a palindrome.
// Tests whether the given integer is a palindrome in decimal (base 10).
// Returns floor(sqrt(x)), for x >= 0.
// Returns floor(sqrt(x)), for x >= 0.
// Returns floor(sqrt(x)), for x >= 0.
// Tests whether x is a perfect square, for any value x.
// Returns x to the power of y, throwing an exception if the result overflows an int.
// Returns x^y mod m.
// Exponentiation by squaring
// Returns x^-1 mod m, where the result is in the range [0, m).
// Note that (x * x^-1) mod m = (x^-1 * x) mod m = 1.
// Based on a simplification of the extended Euclidean algorithm
// Returns n!.
// Returns n choose k.
// Returns the largest non-negative integer that divides both x and y.
// Tests whether the given non-negative integer is prime.
// Returns a Boolean array 'isPrime' where isPrime[i] indicates whether i is prime, for 0 <= i <= n.
// For a large batch of queries, this is faster than calling isPrime() for each integer.
// For example: listPrimality(100) = {false, false, true, true, false, true, false, true,
// false, false, false, true, false, true, false, false, false, true, ...} (array length 101).
// Sieve of Eratosthenes
// Note: i * i does not overflow
// Returns all the prime numbers less than or equal to n, in ascending order.
// For example: listPrimes(97) = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, ..., 83, 89, 97}.
// Returns an array spf where spf[k] is the smallest prime factor of k, valid for 2 <= k <= n.
// For example: listSmallestPrimeFactors(10) = {0, 0, 2, 3, 2, 5, 2, 7, 2, 3, 2}.
// Note: i * i does not overflow
// Returns the number of integers in the range [1, n] that are coprime with n.
// For example, totient(12) = 4 because these integers are coprime with 12: 1, 5, 7, 11.
// Trial division
// Found a factor
// Returns an array 'totients' where totients[i] == totient(i), for 0 <= i <= n.
// For a large batch of queries, this is faster than calling totient() for each integer.
// i is prime
// Attempts to advance the given sequence to the next permutation in lexicographical order.
// Returns true if the sequence was successfully permuted, or returns false if the sequence
// was already at the last possible permutation (a non-ascending sequence).
// Explanation: https://www.nayuki.io/page/next-lexicographical-permutation-algorithm
// For example:
// - nextPermutation({0,0,1}) changes the argument array to {0,1,0} and returns true.
// - nextPermutation({1,0,0}) leaves the argument array unchanged and returns false.
// Immutable unlimited precision fraction
// Always coprime with denominator
// Always positive
// Reduce to canonical form
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// uint31
// uint63
// Values out of range
// Values not coprime
// Pass
// uint31
// Pass
// uint31
// uint31
// x, y > 0
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Represents the current Fibonacci number being processed
// Represents the next Fibonacci number in the sequence
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Returns the smallest factor of n, which is in the range [2, n]. The result is always prime.
// n itself is prime
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// It is now implied that b < c, because we have a > 0
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// First endpoint is assumed to be in bounds. Check if second endpoint is in bounds.
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// This is the ith triangle number, i.e. num = 1 + 2 + ... + i = i * (i + 1) / 2
// Returns the number of integers in the range [1, n] that divide n.
// Perfect square
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Can be set to any non-negative number, but there are diminishing returns as you go larger
// Memoization
// Returns the Collatz chain length of the given integer with automatic caching.
// Caching not available
// Index in the cache
// Returns the Collatz chain length of the given integer, with the
// first step uncached but the remaining steps using automatic caching.
// Base case
// If n is even
// Else n is odd
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Mutable
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//en.wikipedia.org/wiki/Zeller%27s_congruence
// Sunday
// Return value: 0 = Sunday, 1 = Monday, ..., 6 = Saturday.
// Zeller's congruence algorithm
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// 10 strings per line, except final line. Mutable array
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Compute look-up table
// Sum of factors less than n
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/next-lexicographical-permutation-algorithm
// Initialize
// Permute
// Format output
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// At this point, prev = fibonacci(i - 1) and cur = fibonacci(i)
// Advance the Fibonacci sequence by one step
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Must be odd
// Special case for size 1
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// As stated in the problem, 1 = 1^5 is excluded.
// If a number has at least n >= 7 digits, then even if every digit is 9,
// n * 9^5 is still less than the number (which is at least 10^n).
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// ways[i][j] is the number of ways to use any copies of
// the first i coin values to form an unordered sum of j
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Find and examine all factors of n
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// As stated in the problem, 1 = 1! and 2 = 2! are excluded.
// If a number has at least n >= 8 digits, then even if every digit is 9,
// n * 9! is still less than the number (which is at least 10^n).
// Hard-coded values for factorial(0), factorial(1), ..., factorial(9)
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Test if left-truncatable
// Test if right-truncatable
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// 10 strings per line, except final line
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// First 7 primes
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// -1 means not found yet, positive number means found a candidate
// For each upper pentagonal number index, going upward
// If the next number down is at least as big as a found difference, then conclude searching
// For each lower pentagonal number index, going downward
// If the difference is at least as big as a found difference, then stop testing lower pentagonal numbers
// Found a smaller difference
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Now n is an odd composite number
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// For each index of a starting prime number
// For each end index (inclusive)
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Parse cards and divide among players
// Compare hand scores
// Returns a score for the given hand. If handX beats handY then getScore(handX) > getScore(handY), and if
// handX is a draw with handY then getScore(handX) = getScore(handY) (even if the hands have different cards).
// Note that scores need not be consecutive - for example even if scores 1 and 3 exist, there might be no
// hand that produces a score of 2. The comparison property is the only guarantee provided by getScore().
// rankCounts[i] is the number of cards with the rank of i
// flushSuit is in the range [0,3] if all cards have that suit; otherwise -1
// rankCountHist[i] is the number of times a rank count of i occurs.
// For example if there is exactly one triplet, then rankCountHist[3] = 1.
// Main idea: Encode the hand type in the top bits, then encode up to 5 cards in big-endian (4 bits each).
// Straight flush
// Four of a kind
// Full house
// Flush
// Straight
// Three of a kind
// Two pairs
// One pair
// High card
// Encodes 5 card ranks into 20 bits in big-endian, starting with the most frequent cards,
// breaking ties by highest rank. For example, the set of ranks {5,5,T,8,T} is encoded as
// the sequence [T,T,5,5,8] because pairs come before singles and highest pairs come first.
// Returns the rank of the highest card in the straight, or -1 if the set of cards does not form a straight.
// This takes into account the fact that ace can be rank 0 (i.e. face value 1) or rank 13 (value immediately after king).
// Current offset is not a straight
// Straight found
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Now n/d is the i'th (0-based) continued fraction approximation of sqrt(2) - 1
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Heuristical function that returns a penalty score, where lower is better.
// The current implementation returns only integral values, but floating-point values are legal too.
// Uppercase letters are good
// Lowercase letters are excellent
// Control characters are very bad
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Arbitrary initial cutoff
// Memoization
// No smaller sum found
/* 
// Tests whether parseInt(toString(x) + toString(y)) is prime.
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// numbers[i][j] is the set of figurate numbers of i sides (3 <= i <= 8), having 4 digits, beginning with the 2 digits equal to j
// Build table of numbers
// Do search
// Note: sidesUsed is a bit set
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Process and flush data for smaller number of digits
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Returns the period of the continued fraction of sqrt(n)
// Represents (a + b * sqrt(d)) / c. d must not be a perfect square.
// Simplify
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Returns the smallest x such that x > 0 and there exists some y such that x^2 - n y^2 = 1.
// Requires n to not be a perfect square.
// Returns the periodic continued fraction of sqrt(n). Requires n to not be a perfect square.
// result[0] is the minimal non-periodic prefix, and result[1] is the minimal periodic tail.
// Represents (a + b * sqrt(d)) / c. d must not be a perfect square.
// Simplify
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Mutable
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Initially infinity
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// n/d > maxN/maxD
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//mathworld.wolfram.com/Stern-BrocotTree.html
// Counts the number of reduced fractions n/d such that leftN/leftD < n/d < rightN/rightD and d <= 12000.
// leftN/leftD and rightN/rightD must be adjacent in the Stern-Brocot tree at some point in the generation process.
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Hard-coded values for factorial(0), factorial(1), ..., factorial(9)
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Increment but saturate at 2
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Dynamic programming
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Preprocessing
// Try ascending lengths
// For each string 's' in SUBSEQS, test if 's' is a subsequence of 'guess'
// Index in 's'
// Index in 'guess'
// Not all characters consumed, fail
// Converts integer to string with zero padding, in little endian.
// Since we're trying all combinations, the order doesn't matter.
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Shift left so that we can obtain 100 digits after the decimal point
// Skip perfect squares
// Strip rightmost digits so that we have exactly 100 decimal digits (some are before the decimal point)
// Find leftmost position
// Extract square root from left to right using an algorithm like long division
// Try every value for next digit
// Adjust the remainder
// Add the new digit
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Dynamic programming
// Mutable
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Dynamic programming
// Minimum of rightmost column
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Bellman–Ford algorithm
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Roll tetrahedral dice
// Process actions for some locations
// Chance
// Next railway
// Next utility
// Go to jail
// Community chest
// Embed index into count, invert so that maximum becomes minimum
// Fisher-Yates shuffle
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// A bit more than m^2 n^2 / 4
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// solutions.get(k) is the set of all solutions where the largest side has length k.
// A solution is a triple (x, y, z) such that 0 < x <= y <= z, and in the rectangular prism with dimensions x * y * z,
// the shortest surface path from one vertex to the opposite vertex has an integral length.
// cumulativeSolutions.get(m) = solutions.get(0).size() + solutions.get(1).size() + ... + solutions.get(m).size().
// Extend the solutions list with blank sets
// Compute the number of cumulative solutions up to and including a certain maximum size
// Raise the limit and keep searching
// Generates all solutions where the largest side has length less than 'limit'.
/* 
// Assumes that a^2 + b^2 = c^2.
// Add canonical solution
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// q = p^i
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Eliminate duplicates and compute sum
/* 
// Without using factors of 1, the sum never exceeds the product
// Note: maxFactor <= remain
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// e.g. (empty), I, II, III, IV, V, VI, VII, VIII, IX
// 4000 is MMMM, which doesn't have a two-letter form
// Compensate for this fact
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Each die has (10 choose 6) arrangements, so we have at most 44100 arrangements to check
// Ensure i <= j to force the dice to be orderless
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// For uniqueness, ensure that (x1,y1) has a larger angle than (x2,y2)
// Tests whether the three points {(0,0), (x1,y1), (x2,y2)} form a right triangle.
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Assumes 1 <= a < b < c < d <= 9
// Try all possible orderings of operands and operators
// 0 = operator slot, 1 to 9 = literal operand
// Try all possibilities for the 3 operators
// Operator index
// Operand
// Operator
// Stack underflow; skip this ordering
// Division by zero; skip the result for this case
// Consume an operator
// Find largest set of consecutive expressible integers starting from 1
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
// Swap the roles of a and b and try the same tests
// Note that a != b, since otherwise c = a * sqrt(2) would be irrational
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// divisorSum[n] is the sum of all the proper divisors of n
// Analyze the amicable chain length for each number in ascending order
// 'count' is the length of the this amicable chain
// Exceeds limit or not a chain (a rho shape instead)
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Empty cell
// Try each possible value
// Check row
// Check column
// Check box
// No checks failed, recurse on next index
// Full solution found
// Backtrack
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// a and b must be anagrams of each other
// 10 strings per line, except final line
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// First try fast low-precision computations, retrying with increasing precision
// Use interval arithmetic for approximate comparisons
// Otherwise do full-precision comparison (slow)
// Represents a strictly positive number equal to mantissa * 2^exponent
// The output's mantissa will have 'precision' or fewer bits
// In case 'man' is bumped up to the next power of 2
// Exponentiation by squaring
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Fundamental solution
// Current solution
// An alias for the number of red discs
// Check if this solution is acceptable
// Is odd
// Create the next bigger solution
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Lagrange interpolation
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// At the top level, we try to find a special sum set with sum at most s,
// incrementing the bound s until we succeed. When we find a solution
// with sum at most s, but find none with sum at most s - 1, it implies
// that the optimum set's sum is exactly s.
// Note: A set of n positive integers must have a sum of at least 1 + 2 + 3
// + ... + n = n * (n + 1) / 2. If the search specifies a maximum sum lower
// than this, then no solution can exist. But for simplicity we just start
// searching from a maximum sum of 0.
// Solution found; concatenate numbers into a string
// This helper class represents a finite sequence of distinct positive integers
// that satisfies properties (i) and (ii) given in the problem statement.
// Objects of the class are immutable. Objects also keep track of extra data to
// make it easier to check if adding a new element would violate the properties,
// without explicitly checking every non-empty disjoint subset pair by brute force.
// Returns the lexicographically lowest special sum set with the given size
// and with a sum of at most maximumSum, or null if no such set exists.
// Returns the lexicographically lowest special sum set by adding exactly sizeRemain elements
// to the given set, such that the sum of the additional elements is at most sumRemain,
// and the next element to be added is at least startVal. Returns null if no such set exists.
// In summary, this procedure takes a partial answer (prefix) and some parameters,
// and tries to extend the answer by performing depth-first search through recursion.
// Base case - success
// Optimization: If we still need to add at least 2 elements, then the next element
// will be at least startVal, the one after will be at least startVal + 1,
// thereafter is at least startVal + 2, et cetera. The sum of the elements
// to be added is strictly greater than startVal * sizeRemain, which we can
// check against sumRemain and bail out early if a solution is impossible.
// Optimization: If the partial set has at least two elements a and b, then by the
// property (ii), S({a, b}) = a + b must be greater than any single element of the set.
// We use the foremost two elements, which have the smallest values - this makes
// endVal as small and restrictive as possible compared to other choices of elements.
// Consider each possible value for the next element
// Try adding the value and see if any property is violated
// Recurse and see if a solution is found down the call tree
// No solution for the given current state
// Note: All fields are conceptually immutable
// Positive numbers in strict ascending order. Length 0 or more.
// For indexes i from 0 to sum(values) inclusive, sumPossible[i]
// is true iff there exists a subset of 'values' whose sum is i.
// For i from 0 to values.length (inclusive), minimumSum[i] is the minimum sum
// among all possible subsets of 'values' of size i, and likewise for maximumSum[i].
// Creates an empty set, which is a valid state.
// Internal constructor. The contents of the given array objects must not change.
// Attempts to add the given value to this set, returning a new set
// if successful. Otherwise returns null if any property is violated.
// Simple checks on the value
// Check if adding val to any subset of this set would create a duplicate sum
// Compute minimum and maximum sums for each subset size, with help from old data.
// The idea is that by introducing the new value val, each subset of the new set
// either contains val or doesn't. All old subsets are still possible, so we copy
// the old tables of minima and maxima. Each new subset contains val plus an old subset
// (possibly empty). Hence we look at the existing minima and maxima, add val to the sum,
// add 1 to the size, and merge the values into the table of minima and maxima.
// Check iff property (ii) '|B| > |C| implies S(B) > S(C)' is violated
// Compute all possible new subset sums, with help from old data. This is the
// classic table-based algorithm for solving the subset sum or knapsack problem.
// Append given value to the new set
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// We know that x.bitLength() = floor(log2(x)) + 1.
// Now compute an approximate base-10 logarithm, because log10(2) = 0.301... .
// The computed quantity is no larger than floor(log10(x)).
// Chop off quite a number of rightmost base-10 digits.
// It is guaranteed that there remains at least 9 digits.
// Deal with the remaining smaller number.
// Returns the pair [fib(n), fib(n + 1)].
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Step through all subsets
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Catalan number
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Inefficient minimum spanning tree algorithm
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Returns the number of divisors of n^2
// Remaining largest prime factor
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Both lists are orderless but duplicates are important; they are sort of like multisets
// Orderless
// Memoization array
// Number of ways to get exactly 'total' points in exactly 'throwz' throws, using
// items (unordered) from the 'points' list with index less than or equal to 'maxIndex'.
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// For each repeating digit
// Search by the number of repetitions in decreasing order
// Try all possibilities for filling the non-repeating digits
// Build initial array. For example, if DIGITS=7, digit=5, rep=4, i=123, then the array will be filled with 5,5,5,5,1,4,7.
// Skip the repeating digit
// If this is true, then after sorting, the array will be in an already-tried configuration
// Start at lowest permutation
// Go through all permutations
// Skip if the number has a leading zero, which means it has less than DIGIT digits
// Primes found; skip all lesser repetitions
// Only valid if 1 < n <= 10^DIGITS
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Dynamic programming
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Dynamic programming
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// m is the length of colored tiles
// Dynamic programming
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Dynamic programming
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Try all permutations, and try all splits within each permutation
// Cache for small numbers
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// 1-based
// Returns true iff there exists k >= 2 such that x = digitSum(x)^k.
// Powers of 10 are never a power of 1
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Dynamic programming
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//en.wikipedia.org/wiki/Addition-chain_exponentiation .
// Set up initial array of known/unknown minimum operation counts
// Perform bounded depth-first search with incrementing depth
// Add up the results
// Recursively builds up chains and compares them to chain lengths already found.
// Depth-based termination or early exit
// Try all unordered pairs of values in the current chain
// Peek at top
// Early exit due to ascending order
// Append x to the current chain and recurse
// For each unique value of x, we set minOperations[x] only once
// because we do progressive deepening in the depth-first search
// This implementation exists because Stack<Integer> is unacceptably slow due to integer boxing and such.
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Modification of the sieve of Eratosthenes
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Modification of the sieve of Eratosthenes
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/*
// Must be at least 3
// Because n = 1 and 2 satisfy PD(n) = 3
// Corner test
// Edge test
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Returns the smallest k such that R(k) is divisible by n.
// Equal to R(k) mod n
// Equal to 10^k mod n
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Returns the smallest k such that R(k) is divisible by n.
// Equal to R(k) mod n
// Equal to 10^k mod n
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Tests whether there exists a k such that R(10^k) is a multiple of p
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Raise the limit until a sum is found
// Lower the limit until no sum is found
// No smaller sum found
/* 
// Need them to be both odd or both even so that we get integers for x and y
// Because z >= 1
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Must be in non-decreasing order
// Generate the set of numbers to test for primality
// Test that each number is prime.
// Note: The nesting of the loops can be reversed, but this way is much faster.
// Test that each number that is not an increment is composite.
// This checks that the prime numbers we found are in fact consecutive.
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Fill the grid
// Scan along all line directions and positions
// Horizontal from left edge
// Vertical from top edge
// Diagonal from left edge
// Diagonal from top edge
// Anti-diagonal from top edge
// Anti-diagonal from right edge
// For the sequence of numbers in the grid at positions (x, y), (x+dx, y+dy), (x+2*dx, y+2*dy), ... until the
// last in-bounds indices, this function returns the maximum sum among all possible substrings of this sequence.
// Reset the running sum if it goes negative
// Keep track of the best seen running sum
// Lagged Fibonacci generator
// Circular buffer
// The 1-based index of the next sequence item, but saturates at 56
// Don't increment k, to prevent overflow
// Returns the number that was generated n steps ago, where 1 <= n <= history.length.
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Generate the triangle
// Calculate cumulative sums for each row
// Calculate minimum subtriangle sum for each apex position
// Apex element selected at triangle[i][j]
// Ending row (inclusive)
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Warning: Running this solution requires about 600 MiB of memory
// possible[i] holds all the possible capacitance values of a series/parallel
// capacitor network that uses exactly i capacitors of 60 uF each
// Union of every possible[i]
// Parallel
// Series
// A fraction that uses int for storage and long for computation, but switches to BigInteger when necessary.
// Returns 1 / (1/this + 1/other), also equal to (this * other) / (this + other).
// Some arbitrary constant to spread around the bits
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// The last 5 digits of n!, excluding trailing zeros.
// Always non-negative for every n
// We can reduce 'twos' because there is a cycle: 2^5 = 2^2505 = 32 mod 100000
// Equal to n! but with all factors of 2 and 5 removed and then modulo 10^5.
// The identity factorialIsh(n) = oddFactorialish(n) * evenFactorialish(n) (mod 10^5) is true by definition.
// The product of {all even numbers from 1 to n}, but with all factors of 2 and 5 removed and then modulo 10^5.
// For example, evenFactorialish(9) only considers the numbers {2, 4, 6, 8}. Divide each number by 2 to get {1, 2, 3, 4}. Thus evenFactorialish(9) = factorialish(4).
// The product of {all odd numbers from 1 to n}, but with all factors of 2 and 5 removed and then modulo 10^5.
// By definition, oddFactorialish() never considers any number that has a factor of 2. The product of the numbers that not a multiple of 5 are accumulated by factorialCoprime().
// Those that are a multiple of 5 are handled recursively by oddFactorialish(), noting that they are still odd after dividing by 5.
// The product of {all numbers from 1 to n that are coprime with 10}, modulo 10^5.
// The input argument can be taken modulo 10^5 because factorialoid(10^5) = 1, and each block of 10^5 numbers behaves the same.
// Counts the number of factors of n in the set of integers {1, 2, ..., end}.
// For example, countFactors(25, 5) = 6 because {5, 10, 15, 20} each has one factor of 5, and 25 has two factors of 5.
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// For syntactical convenience
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Dynamic programming array
// Initialize base case - ways for 0-digit numbers
// Compute DP table
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// A counter in base 10, little-endian
// All tests passed
// Increments the given base-10 counter in little endian, e.g. {9, 9, 5, 1} -> {0, 0, 6, 1}.
// Returns true if incremented, otherwise returns false if all elements are already 9.
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Memoization
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Must be less than 2^31
/* 
// Maximum possible squared digit sum (for 99...99)
// sum[n][s] is the sum of all length-n numbers with a square digit sum of s, modulo MODULUS
// count[n][s] is the count of all length-n numbers with a square digit sum of s, modulo MODULUS
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Highly customizable!
// >= 1
// >= ceiling(LENGTH / BASE), else the result is 0
// >= 2
/* 
// Multiply by (base - 1) / base to discount sequences with leading zeros
// Expresses 'LENGTH' as a sum of 'BASE' non-increasing terms, where terms to be added are in the range [0, max].
// e.g. partitionAndCount(7, 2, [3, 3, 2, 2, 1]) asks us to express 18 as a sum of 5 more terms,
// where the new terms have a sum of 7 and each is no greater than 2 and all terms are non-increasing.
// The number of times each frequency value occurs
// Multinomial coefficient: BASE! / (histogram[0]! * histogram[1]! * ...)
// Multinomial coefficient: LENGTH! / (freqs[0]! * freqs[1]! * ...)
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Outer square length
// Inner square length
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Generate all possible laminae with at most SIZE_LIMIT tiles
// Outer square size
// Inner square hole size
// Intermediate computation may overflow, but result is correct
// Examine the type of each total tiling
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Dynamic programming: ways[digits][head][low][high] is the number of pandigital
// step numbers such that each number is 'digits' long, starts with the digit 'head'
// (can be 0), and the union of all the digits equals the interval [low, high]
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Invalid for indexes 0 and 1
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Path compression
// Lagged Fibonacci generator
// Circular buffer
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Fact: If x and m are coprime, then x^y mod m = x^(y mod totient(m)) mod m
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// numPrizeStrings[i][j][k] is the number of prize strings of length i with
// exactly j absences at the tail and exactly k lates in the whole string
// Count which states can be appended to the tail
// On time
// Late
// Absent
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Floyd's cycle-finding algorithm
// Here at the top of the loop, x = f^i(-1) and y = f^{2i}(-1)
// This means index i is part of the cycle, and (2i - i) = i is some multiple of the true cycle length
// Advance the states at different speeds
// Advance by many multiples of the cycle length, then deal with the remaining iterations
// Truncate to 9 digits after the decimal point
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Collect unique numbers in Pascal's triangle
// Prepare list of squared primes
// Sum up the squarefree numbers
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// The major optimization is to do arithmetic in base 10 in the main loop, avoiding division and modulo
// Initialize
// The pattern is greater than 10^18, so start searching at 10^9
// In base 10, little-endian
// Based on length of pattern
// Increment and search
// Add 20n + 100 so that n2digits = (n + 10)^2
// Since n^2 ends with 0, n must end with 0
// Now n2digits = n^2
// Scan for 1 to 9
// Special case for 0
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Start with the initial state being reachable
// In each iteration, look at the set of reachable states and apply ACW and CW
// moves on each state. Count the number of ways the new states can be reached.
// Add up all the ways to reach the initial position using
// exactly LIMIT moves, finally facing any possible direction
// Represents a facing-direction and a position on the infinite plane.
// The position is a weighted sum of irrational x components and y components.
// In the range [0, 5).
// Any integer. For 2sqrt(5).
// Any integer. For sqrt(5)-5.
// Any integer. For sqrt(10-2sqrt(5)).
// Any integer. For sqrt(10+2sqrt(5)).
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Requires about 512 MB of memory
// sigma2[i] is the sum of the square of i's divisors.
// For example, sigma2[6] = 1^2 + 2^2 + 3^2 + 6^2 = 20.
// Computing using a modification of the sieve of Eratosthenes.
// Suppose i is the highest natural number such that k^i divides n.
// Then this function returns k^(2*0) + k^(2*1) + k^(2*2) + ... + k^(2*i).
// For example, with n=50 and k=5, i=2 because k^2 = 25 divides n = 50,
// so the result is k^0 + k^2 + k^4 = 1 + 25 + 625 = 651.
// Consider the set of all squared natural numbers, i.e. {0, 1, 4, 9, 16, 25, ...}.
// When this set is viewed modulo some number n, usually not every residue is in the set.
// For example, all squares modulo 3 is {0, 1} - so a perfect square modulo 3 is never 2.
// By choosing a suitably large modulus, we can quickly exclude many numbers that can't be perfect squares.
// isResidue[i] is true iff there exists a natural number k such that i = k^2 mod modulus.
// Hence for any i, if isResidue[i mod modulus] is false, then i is not a perfect square.
// Any product of unique small prime numbers excluding 2 makes a good modulus
// that leads to fast tests. But the behavior is correct for any modulus >= 1.
// Reject many but not all numbers that aren't a perfect square.
// This speed optimization can be omitted without affecting correctness.
// A complete algorithm for detecting squares
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Requires at least 320 MB of memory
// Fill table in ascending order because totient chains are strictly decreasing
// i is prime iff totient(i) = i-1
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// position > WIDTH
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/*
//code.google.com/archive/p/fun-math-problems/source/default/source?page=15 , p216.tex
// Produce the entire sequence
// Divide out factors using a kind of sieve
// We can assert at this point that term == 1 || isPrime(term)
// We can skip if term > LIMIT * 2 because in the second loop would do nothing. This also avoids overflows because term is a long.
// The loop does nothing because: i <= LIMIT < p/2; p/2 - i > 0; p - i > p/2; 2(p - i) > p. Clearly 2(p - i) < 2p.
// Hence 2(p - i) % p = p - 2i. Next, the start index j = i + (p - 2i) = p - i > p/2 >= LIMIT, therefore j > LIMIT.
// Visit specific later entries in the sequence and divide out all factors of p
// j starts at the smallest number such that j > i and j = +i mod p
// j starts at the smallest number such that j > i and j = -i mod p
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// {30000, 31000, 32000, ..., 49000, 50000}
// In micrometres
/* 
// Memoization
// This sphere is rightmost
// i is the index of the next sphere
// The sqrt() here is what makes the entire computation not guaranteed to be accurate
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// 1-based
// Tests whether any term of the Tribonacci sequence [1, 1, 1, 3, 5, 9, 17, 31, ...]
// is a multiple of 'modulus'. Although the mathematical sequence is infinitely long,
// this function returns an answer in O(modulus^3) time.
// Floyd's cycle-finding algorithm
// Advances the 3-element Tribonacci state vector by one iteration in place.
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/*
// Note: At this point in the code, denominator is the product of one copy of each
// prime number up to and including p, totient is equal to totient(denominator),
// and totient/denominator = R'(2 * 3 * ... * p) (the pseudo-resilience).
// Advance to the next prime
// If the lower bound is below the target, there might be a suitable solution d such that
// d's factorization only contains prime factors strictly below the current (advanced) value of p
// Try to find the lowest factor i such that R(i*d) < TARGET, if any.
// Note that over this range of i, we have R'(d) = R'(i*d) < R(i*d).
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Use dynamic programming
// numSubsets[i] is the number of subsets with sum i, mod 10^16
// Sum of all primes seen so far
// Optimization of modulo because we know 0 <= numSubsets[j] + numSubsets[j - i] < 2 * MODULUS
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Use dynamic programming
// numSubsets[i] is {the number of subsets with sum equal to i mod 250} mod 10^16
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Must be in the range [1, 5], otherwise the algorithm overflows
// Equal to 2^n. Here it is equal to 32.
// Equal to n 1's in binary, i.e. 0b11111.
// Equal to 2^n 1's in binary, i.e. 0b11111111111111111111111111111111.
// Tests whether all the n-bit cyclic windows of the given 2^n-bit number are unique values.
// Two copies
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Heuristic sampling algorithm.
// At level 1 we test {1/2}. At level 2 we test {1/4, 3/4}.
// At level 3 we test {1/8, 3/8, 5/8, 7/8}. Et cetera.
// Calculate the cumulative probability: binomialSum = sum (n choose k) for 0 <= k < maxIndex
// Returns the cumulative binomial probability index.
// Number of losses
// Range [0, TRIALS + 1]
// Converts a fraction to a correctly rounded decimal string.
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Note: The recursive algorithm generates all solutions, but the problem statement excludes 1
// Assuming that p and q are coprime, 0 <= a < p, and 0 <= b < q, this returns the unique
// integer x in the range [0, p*q) such that x satisfies (x = a mod p) and (x = b mod q).
// (a + (b - a) * reciprocalMod(p, q) * p) mod (p * q)
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Model the problem as a Markov process, and solve using dynamic programming
// Memoize the successors of each valid state
// Run the simulation
// The current probability of being in each state
// Note: The done state has no outgoing neighbors,
// so its probability disappears in the next iteration
// Note: Minimum completion is 44 steps
/* 
/*-- Static members --*/
// All valid state IDs are in the range [0, ID_LIMIT). Not every number in the range is a valid state.
// Special states.
// Returns a set of all valid states.
// Try all 2^11 ways for which cells (or ant) hold a seed
// Invalid state if not 5 things hold a seed
// For all 5*5 possible ant positions
/*-- Instance members --*/
// A number in the range [0, ID_LIMIT) such that each distinct state has a different ID.
// When the system is done, the ant's position is ignored. Thus there is only 1 done state, not 5.
// Moreover when done, hasSeed must equal [T T T T T, F F F F F, F].
// The ant's position on the grid. Both numbers are in the range [0, 5).
// 0 represents the top row, 4 is the bottom row.
// Indices 0 to 4 are for the top row, 5 to 9 for the bottom row, and 10 for the ant.
// Exactly 5 elements are true, and the other 6 are false.
// Returns a set (of size 0 to 4) containing this state's successors.
// Remember that this state transitions to a successor with equal probability.
// Ant moves off the grid
// Pick up seed
// Drop off seed
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Returns the exact minimum number of bits required to encode
// the circle image's region of [xStart, end) * [yStart, yEnd).
// All black or all white, respectively
// Top left
// Top right
// Bottom left
// Bottom right
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// feasible.get(i)[j] indicates whether there exists an i-digit number that consists of
// only the digits {0, 1, 2} (with possible leading zeros) having a remainder of j modulo n:
// - 0: No i-digit number can form this remainder
// - 1: Only zero can form this remainder
// - 2: Some non-zero number can form this remainder
// Initialization and base case
// Add digits on the left side until a solution exists, using dynamic programming
// Unbounded loop
// Run time of O(n)
// Construct the smallest solution using the memoized table
// Run time of O(feasible.size()) bigint operations
// Modulo n
// Pick digit values from left (most significant) to right
// Leading digit must start searching at 1; subsequent digits start searching at 0
// A roundabout way to compute (remainder - digitMod * j) mod n, because
// Java's remainder operator needs extra work when the left side is negative
// Digit value found, skip the assertion error
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Number of candidates starting from BASE to search for primes. Hopefully there are 100 000 primes among here.
// isComposite[i] pertains to the number BASE + i
// Sieve of Eratosthenes, but starting at BASE
// Returns p - BASE, where p is the next prime after n + BASE
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Also known as digital root.
// Mapping of [0, 10) -> [0x00, 0x7F); each output fits in 7 bits.
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Calculate the answer
// Round the fraction properly. This is the pedantically correct version of doing
// String.format("%.10f", ans.numerator.doubleValue() / ans.denominator.doubleValue())
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// For each starting square
// For each sequence of jumps
// Set initial position and croak
// Simulate each jump and croak
// Forced move
// Forced move
// Chosen move
// Chosen move
// Multiply the running probability by 2/3 if primeness of current position
// matches croak sequence at current index, otherwise multiply by 1/3
// Calculate final probability fraction
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Initialized to 0 because all the matrix elements are positive
// Memoization
// Returns the maximum sum when considering the submatrix from row 'startRow' until the bottom,
// with the bit set 'setOfCols' indicating which column indexes are still free to be used.
// Must have rows <= columns <= 30
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Collect all generated numbers to eliminate duplicates
// Special case
// For each possible length of strong repunits (ignoring the trivial length of 2)
// For each base to evaluate the repunit in, until the value exceeds the limit
// Evaluate value = base^(length-1) + base^(length-2) + ... + base^1 + base^0
// Carefully check for arithmetic overflow
// Sum all the numbers generated
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Initially all zero
// Examines all integers in the range [0, limit), and returns the sum of the lowest
// TARGET_COUNT integers each with the property that it is a palidrome in base 10
// and it can be expressed in exactly TARGET_COUNT ways as a sum of a perfect square
// greater than 1 and a perfect cube greater than 1. If fewer than TARGET_COUNT integers
// in [0, limit) have the desired property, then -1 is returned. Note that if
// trySearch(n) == k != -1, then for every m > n, trySearch(m) == k also holds.
// ways[i] is exactly the number of ways that i can be expressed as a sum of a
// square greater than 1 and a cube greater than 1. However, the counting of ways
// saturates at TARGET_COUNT+1 to prevent potentially unboundedly large values.
// Count both loops downward, so that the end
// value is a constant instead of a variable
// Examine which numbers are palindromes and have the target number of ways
// Not found
// Returns floor(cbrt(x)) for x >= 0.
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// All one-digit numbers are trivially Harshad numbers
// Note: n must be a right-truncatable Harshad number, and the other arguments are properties of the number n.
// Shift left by 1 digit, and try all 10 possibilities for the rightmost digit
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Must be less than 2^56
// Should be less than 2^30
/* 
// Can be any number from 1 to LIMIT, but somewhere near sqrt(LIMIT) is preferred
// Optimization: Put more weight on direct sums instead of slow BigInteger sums
// Consider divisors individually up and including this number
// Sum individual divisors
// Sum divisors grouped by count
// Find all divisors with the count of i
// Exclusive
// Inclusive
// (start+1)^2 + (start+2)^2 + ... + end^2 mod MODULUS
// Returns 1^2 + 2^2 + 3^2 + ... + n^2 mod MODULUS.
// Compute y = (n)(n + 1)(2n + 1) / 6 mod MODULUS
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Maximum size of set of prime factors where the product of the set <= LIMIT.
// This is important because the number of solutions for n is 2^N,
// where N is the number of distinct prime factors of n.
// i is prime
// Temporary arrays
// Compute factorization as coprime prime powers. e.g. 360 = {2^3, 3^2, 5^1}
// Use Chinese remainder theorem; cache parts of it
// Flip buffers
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// All the prime numbers we need to consider
// smallestPrimeFactor[i] is the smallest (prime) factor of i
// Requires 400 MB
// A sorted array of almost all prime powers less than or equal to LIMIT.
// Also, each prime power is associated with its totient.
// For each i, primePowersAndTotients[i] = ((p^k) << 32) | (totient(p^k))
// where p is some prime except 2 and 5, k >= 1 is an integer, and p^k <= LIMIT.
// The sequence of p^k values begins with 3, 7, 9, 11, 13, 17, 19, 23, 27, 29, 31, 37, 41, 43, 47, 49, 53, ... .
// (Before sorting, it would be 3^1, 3^2, ..., 3^16, 7^1, ..., 7^9, 11^1, ..., 11^7, ... .)
// The decimal expansion periods for each 1/p^k where p^k is a prime power (p != 2, 5).
// ppp[i] is the smallest positive integer such that 10^ppp[i] = 1 mod primePowers[i].
// Garbage collection voodoo
// Compute periods for each number that is coprime with 2 and 5,
// based on the prime power decomposition of the number
// Compute the period for all numbers (esp. those with factors of 2 and 5) and add 'em up
// Start with some multiple of the true period
// Remove unnecessary factors from the period
// Starter value for accumulating LCM
// The true value, because 1/1 has a terminating decimal expansion
// Remove all factors of 2
// Remove all factors of 5
// A packed, limited-functionality version of ArrayList<Long>.
// Trim
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// pathMax[i] = Integer.MAX_VALUE if i is not prime or i is not connected to 2.
// Otherwise, considering all connection paths from 2 to i and for each path computing
// the maximum number, pathMax[i] is the minimum number among all these maxima.
// Process paths in increasing order of maximum number
// This happens if at the time this update was queued, a better
// or equally good update was queued ahead but not processed yet
// Update the target node and explore neighbors
// Try all replacements of a single digit, including the leading zero.
// This generates exactly all (no more, no less) the ways that a number m is connected to n.
// For each digit position
// For each digit value
// Restore the digit
// Returns the given non-negative integer as an array of digits, in big endian, with an extra leading zero.
// e.g. 0 -> {0,0}; 1 -> {0,1}; 8 -> {0,8}; 42 -> {0,4,2}; 596 -> {0,5,9,6}.
// Extract base-10 digits in little endian
// Trim and reverse
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// In this computation, it's actually a product
// Returns the number of factors of p (prime) in factorial(n)
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
// Secant method with adaptive precision for numerical integration
// Precomputed constants
// Integrate using midpoint rule with uniform partition size
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Requires 0 <= y < x <= LIMIT
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Build table of smallest prime factors
// Process every integer in range
// Uses about 2 GiB of memory
// Second-largest solution
// Returns all the solutions (in ascending order) such that
// for each k, 1 <= k < n and k^2 = 1 mod n.
// n is prime
// Note: Changing the ArrayList<Integer> to an implementation
// based on int[] does not yield meaningful speed improvement
// Convert List<Integer> to int[]
// Conceptually like int[][], but having elements all packed into one int[].
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Search all possible x's. Note that a + 1 = x * y * y >= x. Furthermore, a < b, so a + 1 <= b.
// Thus if x >= LIMIT, then LIMIT <= a + 1 <= b. With b >= LIMIT, no candidates are possible.
// Search all possible y's. Notice that when y increases, 'a' strictly increases.
// So when some y generates an 'a' such that a >= LIMIT, no candidates are possible with higher values of y.
// Search all valid z's. We require z > y and gcd(y, z) = 1. Notice that when z increases, c strictly increases.
// So when some z generates a c such that c >= LIMIT, no candidates are possible with higher values of z.
// Check whether (a, b, c) is a solution
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// Modification of the sieve of Eratosthenes
// Now we know that i is prime
// We know j contains at least one factor of i
// Update answer for all multiples of 'power'
// Update power to include the remaining factors of i in j
// Now at this point, power = number of factors of i in the factorization of j!
// Won't overflow because 0 <= sum <= LIMIT^2 ~= 2^53
/* 
//www.nayuki.io/page/project-euler-solutions
//github.com/nayuki/Project-Euler-solutions
/* 
// The indefinite integral of (1 - sqrt(2x - x^2)) dx.
# 
# Shared code for solutions to Project Euler problems
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Returns the number of 1's in the binary representation of
# the non-negative integer x. Also known as Hamming weight.
# Given integer x, this returns the integer floor(sqrt(x)).
# Tests whether x is a perfect square, for any integer x.
# Tests whether the given integer is a prime number.
# Returns a list of True and False indicating whether each number is prime.
# For 0 <= i <= n, result[i] is True if i is a prime number, False otherwise.
# Sieve of Eratosthenes
# Returns all the prime numbers less than or equal to n, in ascending order.
# For example: listPrimes(97) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, ..., 83, 89, 97].
# Yields prime numbers in ascending order from 2 to limit (inclusive).
# Sieve of Eratosthenes, storing only odd numbers starting at 3
# i is prime
# Returns x^-1 mod m. Note that x * x^-1 mod m = x^-1 * x mod m = 1.
# Based on a simplification of the extended Euclidean algorithm
# Find non-increasing suffix
# Find successor to pivot
# Reverse suffix
# Decorator. The underlying function must take only positional arguments, no keyword arguments.
# 
# Test suite for Project Euler all Python solutions
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# In seconds
# Must return a string
# 
# Solution to Project Euler problem 1
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Computers are fast, so we can implement this solution directly without any clever math.
# 
# Solution to Project Euler problem 2
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Computers are fast, so we can implement this solution directly without any clever math.
# Represents the current Fibonacci number being processed
# Represents the next Fibonacci number in the sequence
# 
# Solution to Project Euler problem 3
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# By the fundamental theorem of arithmetic, every integer n > 1 has a unique factorization as a product of prime numbers.
# In other words, the theorem says that n = p_0 * p_1 * ... * p_{m-1}, where each p_i > 1 is prime but not necessarily unique.
# Now if we take the number n and repeatedly divide out its smallest factor (which must also be prime), then the last
# factor that we divide out must be the largest prime factor of n. For reference, 600851475143 = 71 * 839 * 1471 * 6857.
# Returns the smallest factor of n, which is in the range [2, n]. The result is always prime.
# n itself is prime
# 
# Solution to Project Euler problem 4
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Computers are fast, so we can implement this solution directly without any clever math.
# 
# Solution to Project Euler problem 5
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# The smallest number n that is evenly divisible by every number in a set {k1, k2, ..., k_m}
# is also known as the lowest common multiple (LCM) of the set of numbers.
# The LCM of two natural numbers x and y is given by LCM(x, y) = x * y / GCD(x, y).
# When LCM is applied to a collection of numbers, it is commutative, associative, and idempotent.
# Hence LCM(k1, k2, ..., k_m) = LCM(...(LCM(LCM(k1, k2), k3)...), k_m).
# 
# Solution to Project Euler problem 6
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Computers are fast, so we can implement this solution directly without any clever math.
# However for the mathematically inclined, there are closed-form formulas:
#   s  = N(N + 1) / 2.
#   s2 = N(N + 1)(2N + 1) / 6.
# Hence s^2 - s2 = (N^4 / 4) + (N^3 / 6) - (N^2 / 4) - (N / 6).
# 
# Solution to Project Euler problem 7
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Computers are fast, so we can implement this solution by testing each number
# individually for primeness, instead of using the more efficient sieve of Eratosthenes.
# 
# The algorithm starts with an infinite stream of incrementing integers starting at 2,
# filters them to keep only the prime numbers, drops the first 10000 items,
# and finally returns the first item thereafter.
# 
# Solution to Project Euler problem 8
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# We implement a straightforward algorithm that examines every substring of length 13.
# 
# Solution to Project Euler problem 9
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Computers are fast, so we can implement a brute-force search to directly solve the problem.
# It is now implied that b < c, because we have a > 0
# 
# Solution to Project Euler problem 10
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Call the sieve of Eratosthenes and sum the primes found.
# 
# Solution to Project Euler problem 11
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# We visit each grid cell and compute the product in the 4 directions starting from that cell.
# 
# Solution to Project Euler problem 12
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# This is the ith triangle number, i.e. num = 1 + 2 + ... + i = i * (i + 1) / 2
# Returns the number of integers in the range [1, n] that divide n.
# 
# Solution to Project Euler problem 13
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# We do a straightforward sum thanks to Python's built-in arbitrary precision integer type.
# 
# Solution to Project Euler problem 14
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# We compute the Collatz chain length for every integer in the range according to the iteration rule.
# Also, we cache the Collatz value for all integer arguments to speed up the computation.
# 
# Solution to Project Euler problem 15
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# This is a classic combinatorics problem. To get from the top left corner to the bottom right corner of an N*N grid,
# it involves making exactly N moves right and N moves down in some order. Because each individual down or right move
# is indistinguishable, there are exactly 2N choose N (binomial coefficient) ways of arranging these moves.
# 
# Solution to Project Euler problem 16
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# We implement this solution in a straightforward way thanks to Python's built-in arbitrary precision integer type.
# 
# Solution to Project Euler problem 17
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# - For the numbers 0 to 19, we write the single word:
#   {zero, one, two, three, four, five, six, seven, eight, nine,
#   ten, eleven, twelve, thirteen, fourteen, fifteen, sixteen, seventeen, eighteen, nineteen}.
# - For the numbers 20 to 99, we write the word for the tens place:
#   {twenty, thirty, forty, fifty, sixty, seventy, eighty, ninety}.
#   Subsequently if the last digit is not 0, then we write the word for the ones place (one to nine).
# - For the numbers 100 to 999, we write the ones word for the hundreds place followed by "hundred":
#   {one hundred, two hundred, three hundred, ..., eight hundred, nine hundred}.
#   Subsequently if the last two digits are not 00, then we write the word "and"
#   followed by the phrase for the last two digits (from 01 to 99).
# - For the numbers 1000 to 999999, we write the word for the three digits starting at the
#   thousands place and going leftward, followed by "thousand". Subsequently if the last three
#   digits are not 000, then we write the phrase for the last three digits (from 001 to 999).
# 
# Solution to Project Euler problem 18
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# We create a new blank triangle with the same dimensions as the original big triangle.
# For each cell of the big triangle, we consider the sub-triangle whose top is at this cell,
# calculate the maximum path sum when starting from this cell, and store the result
# in the corresponding cell of the blank triangle.
# 
# If we start at a particular cell, what is the maximum path total? If the cell is at the
# bottom of the big triangle, then it is simply the cell's value. Otherwise the answer is
# the cell's value plus either {the maximum path total of the cell down and to the left}
# or {the maximum path total of the cell down and to the right}, whichever is greater.
# By computing the blank triangle's values from bottom up, the dependent values are always
# computed before they are utilized. This technique is known as dynamic programming.
# Mutable
# 
# Solution to Project Euler problem 19
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# We simply use Python's built-in date library to compute the answer by brute force.
# 
# Solution to Project Euler problem 20
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# We do a straightforward computation thanks to Python's built-in arbitrary precision integer type.
# 
# Solution to Project Euler problem 21
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# We first compute a table of sum-of-proper-divisors, then we use it to test which numbers are amicable.
# This approach differs from the Java implementation because trying to directly compute
# the proper-divisor-sum of each number by brute force is unacceptably slow in Python.
# Compute sum of proper divisors for each number
# Find all amicable pairs within range
# 
# Solution to Project Euler problem 22
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# We apply straightforward algorithms to sort the names, sum the letter values, and multiply by the position.
# 10 strings per line, except final line
# 
# Solution to Project Euler problem 23
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 24
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# We initialize a list as the lowest permutation of the given digits, which is the sequence
# (0,1,2,3,4,5,6,7,8,9). Then we call a Python library function that generates a stream of
# all permutations of the values, seek to the 999 999th element (0-based indexing), and stringify it.
# 
# Solution to Project Euler problem 25
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Because the target number is relatively small, we simply compute each Fibonacci number starting
# from the beginning until we encounter one with exactly 1000 digits. The Fibonacci sequence grows
# exponentially with a base of about 1.618, so the numbers in base 10 will lengthen by one digit
# after every log10(1.618) ~= 4.78 steps on average. This means the answer is at index around 4780.
# At this point, prev = fibonacci(i - 1) and cur = fibonacci(i)
# Advance the Fibonacci sequence by one step
# 
# Solution to Project Euler problem 26
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 27
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 28
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# From the diagram, let's observe the four corners of an n * n square (where n is odd).
# It's not hard to convince yourself that the top right corner always has the value n^2.
# Working counterclockwise (backwards), the top left corner has the value n^2 - (n - 1),
# the bottom left corner has the value n^2 - 2(n - 1), and the bottom right is n^2 - 3(n - 1).
# Putting it all together, this outermost ring contributes 4n^2 - 6(n - 1) to the final sum.
# 
# Incidentally, the closed form of this sum is (4m^3 + 3m^2 + 8m - 9) / 6, where m = size.
# Must be odd
# Special case for size 1
# 
# Solution to Project Euler problem 29
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# We generate all the possible powers in the given range, put each value
# into a set, and let the set count the number of unique values present.
# 
# Solution to Project Euler problem 30
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# As stated in the problem, 1 = 1^5 is excluded.
# If a number has at least n >= 7 digits, then even if every digit is 9,
# n * 9^5 is still less than the number (which is at least 10^n).
# 
# Solution to Project Euler problem 31
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# We use the standard dynamic programming algorithm to solve the subset sum problem over integers.
# The order of the coin values does not matter, but the values need to be unique.
# At the start of each loop iteration, ways[i] is the number of ways to use {any copies
# of the all the coin values seen before this iteration} to form an unordered sum of i
# 
# Solution to Project Euler problem 32
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# For contradiction suppose a candidate (x, y, z) has z >= 10000.
# Then x*y consumes at least 5 digits. With the 4 (or fewer) remaining digits, even the
# upper bound of x=99 and y=99 produces a product of x*y < 10000, which is unequal to z.
# Therefore we need the product z < 10000 to be able to find possible x and y values.
# Find and examine all factors of n
# 
# Solution to Project Euler problem 33
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Consider an arbitrary fraction n/d:
#   Let n = 10 * n1 + n0 be the numerator.
#   Let d = 10 * d1 + d0 be the denominator.
# As stated in the problem, we need 10 <= n < d < 100.
# We must disregard trivial simplifications where n0 = d0 = 0.
# 
# Now, a simplification with n0 = d0 is impossible because:
#   n1 / d1 = n / d = (10*n1 + n0) / (10*d1 + n0).
#   n1 * (10*d1 + n0) = d1 * (10*n1 + n0).
#   10*n1*d1 + n1*n0 = 10*d1*n1 + d1*n0.
#   n1*n0 = d1*n0.
#   n1 = d1.
#   This implies n = d, which contradicts the fact that n < d.
# Similarly, we cannot have a simplification with n1 = d1 for the same reason.
# 
# Therefore we only need to consider the cases where n0 = d1 or n1 = d0.
# In the first case, check that n1/d0 = n/d;
# in the second case, check that n0/d1 = n/d.
# 
# Solution to Project Euler problem 34
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# As stated in the problem, 1 = 1! and 2 = 2! are excluded.
# If a number has at least n >= 8 digits, then even if every digit is 9,
# n * 9! is still less than the number (which is at least 10^n).
# 
# Solution to Project Euler problem 35
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 36
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 37
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Test if left-truncatable
# Test if right-truncatable
# 
# Solution to Project Euler problem 38
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 39
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# c >= b
# 
# Solution to Project Euler problem 40
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 41
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Note: The only 1-digit pandigital number is 1, which is not prime. Thus we require n >= 2.
# 
# Solution to Project Euler problem 42
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 10 strings per line, except final line
# 
# Solution to Project Euler problem 43
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 44
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# None means not found yet, positive number means found a candidate
# For each upper pentagonal number index, going upward
# If the next number down is at least as big as a found difference, then conclude searching
# For each lower pentagonal number index, going downward
# If the difference is at least as big as a found difference, then stop testing lower pentagonal numbers
# Found a smaller difference
# Provides memoization for generating and testing pentagonal numbers.
# 
# Solution to Project Euler problem 45
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 46
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 47
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# n is prime
# 
# Solution to Project Euler problem 48
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 49
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 50
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 51
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 52
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 53
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 54
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Handpair is a space-separated string of 10 cards.
# Parse cards and divide among players
# Compare hand scores
# Hand is an array of cards. Returns a score for the given hand. If handX beats handY then get_score(handX) > get_score(handY),
# and if handX is a draw with handY then get_score(handX) = get_score(handY) (even if the hands have different cards).
# Note that scores need not be consecutive - for example even if scores 1 and 3 exist, there might be no
# hand that produces a score of 2. The comparison property is the only guarantee provided by get_score().
# rankcounts[i] is the number of cards with the rank of i
# rankcounthist[i] is the number of times a rank count of i occurs.
# For example if there is exactly one triplet, then rankcounthist[3] = 1.
# flushsuit is in the range [0,3] if all cards have that suit; otherwise -1
# Main idea: Encode the hand type in the top bits, then encode up to 5 cards in big-endian (4 bits each).
# Straight flush
# Four of a kind
# Full house
# Flush
# Straight
# Three of a kind
# Two pairs
# One pair
# High card
# Encodes 5 card ranks into 20 bits in big-endian, starting with the most frequent cards,
# breaking ties by highest rank. For example, the set of ranks {5,5,T,8,T} is encoded as
# the sequence [T,T,5,5,8] because pairs come before singles and highest pairs come first.
# Returns the rank of the highest card in the straight, or -1 if the set of cards does not form a straight.
# This takes into account the fact that ace can be rank 0 (i.e. face value 1) or rank 13 (value immediately after king).
# Current offset is not a straight
# Straight found
# Card is a 2-letter string like "2H" for "two of hearts". Returns a pair of integers (rank, suit).
# 
# Solution to Project Euler problem 55
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 56
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 57
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Now numer/denom is the i'th (0-based) continued fraction approximation of sqrt(2) - 1
# 
# Solution to Project Euler problem 58
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# From the diagram, let's observe the four corners of an n * n square (where n is odd).
# It's not hard to convince yourself that:
# - The bottom right corner always has the value n^2.
# Working clockwise (backwards):
# - The bottom left corner has the value n^2 - (n - 1).
# - The top left corner has the value n^2 - 2(n - 1).
# - The top right has the value n^2 - 3(n - 1).
# Furthermore, the number of elements on the diagonal is 2n - 1.
# 
# Solution to Project Euler problem 59
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# ASCII lowercase 'a' to 'z'
# Heuristical function that returns a penalty score, where lower is better.
# ASCII uppercase 'A' to 'Z', good
# ASCII lowercase 'a' to 'z', excellent
# ASCII control characters, very bad
# Takes two sequences of integers and returns a list of integers.
# 
# Solution to Project Euler problem 60
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Arbitrary initial cutoff
# Tries to find any suitable set and return its sum, or None if none is found.
# A set is suitable if it contains only primes, its size is targetsize,
# its sum is less than or equal to sumlimit, and each pair concatenates to a prime.
# 'prefix' is an array of ascending indices into the 'primes' array,
# which describes the set found so far.
# The function blindly assumes that each pair of primes in 'prefix' concatenates to a prime.
# 
# For example, find_set_sum([1, 3, 28], 5, 10000) means "find the sum of any set
# where the set has size 5, consists of primes with the lowest elements being [3, 7, 109],
# has sum 10000 or less, and has each pair concatenating to form a prime".
# Tests whether concat(primes[x], primes[y]) is a prime number, with memoization.
# Tests whether the given integer is prime. The implementation performs trial division,
# first using the list of primes named 'primes', then switching to simple incrementation.
# This requires the last number in 'primes' (if any) to be an odd number.
# No smaller sum found
# 
# Solution to Project Euler problem 61
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Build table of numbers
# numbers[i][j] is the set of figurate numbers of i sides (3 <= i <= 8), having 4 digits, beginning with the 2 digits equal to j
# Note: sidesused is a bit set
# Do search
# 
# Solution to Project Euler problem 62
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# str numclass -> (int lowest, int count)
# Process and flush data for smaller number of digits
# 
# Solution to Project Euler problem 63
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Let's examine n^k for different values of n and k and see which
# choices cannot possibly work (i.e. not being exactly k digits long).
# 
# When n = 10, for each k, n^k has exactly k+1 digits, so these are excluded.
# By extension, when n > 10, for each k, n^k has at least k+1 digits, so these are excluded.
# Thus we should only consider 1 <= n <= 9.
# 
# When n = 9, k = 22, then n^k has 21 digits which is insufficient.
# Extending this, when n = 9 and k > 22, n^k has fewer than k digits.
# Furthermore, when n < 9, n^k will have start to have
# fewer than k digits at some value of k with k < 22.
# Therefore we should only consider 1 <= k <= 21.
# 
# We handle the rest of the testing by brute force.
# 
# Solution to Project Euler problem 64
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Returns the period of the continued fraction of sqrt(n)
# Represents (a + b * sqrt(d)) / c. d must not be a perfect square.
# Simplify
# 
# Solution to Project Euler problem 65
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 66
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Based on this insane theorem: Suppose D > 1 is an integer, non-perfect-square.
# 
# Express sqrt(D) as the continued fraction (a0, a1, ..., a_{n-1}, (b0, b1, ..., b_{m-1})),
# where the sequence of b's is the periodic part.
# 
# Let p/q (in lowest terms) = (a0, a1, ..., a_{n-1}, b0, b1, ..., b_{m-2}).
# (This is a truncation of the continued fraction with only one period minus the last term.)
# 
# Then the minimum solution (x, y) for Pell's equation is given by:
# - (p, q) if m is even
# - (p^2 + D q^2, 2pq) if m is odd
# Returns the smallest x such that x > 0 and there exists some y such that x^2 - n y^2 = 1.
# Requires n to not be a perfect square.
# Returns the periodic continued fraction of sqrt(n). Requires n to not be a perfect square.
# result[0] is the minimal non-periodic prefix, and result[1] is the minimal periodic tail.
# Represents (a + b * sqrt(d)) / c. d must not be a perfect square.
# Simplify
# 
# Solution to Project Euler problem 67
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# We create a new blank triangle with the same dimensions as the original big triangle.
# For each cell of the big triangle, we consider the sub-triangle whose top is at this cell,
# calculate the maximum path sum when starting from this cell, and store the result
# in the corresponding cell of the blank triangle.
# 
# If we start at a particular cell, what is the maximum path total? If the cell is at the
# bottom of the big triangle, then it is simply the cell's value. Otherwise the answer is
# the cell's value plus either {the maximum path total of the cell down and to the left}
# or {the maximum path total of the cell down and to the right}, whichever is greater.
# By computing the blank triangle's values from bottom up, the dependent values are always
# computed before they are utilized. This technique is known as dynamic programming.
# Mutable
# 
# Solution to Project Euler problem 68
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 69
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 70
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 71
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# We consider each (integer) denominator d from 1 to 1000000 by brute force.
# For a given d, what is the largest integer n such that n/d < 3/7?
# 
# - If d is a multiple of 7, then the integer n' = (d / 7) * 3 satisfies n'/d = 3/7.
#   Hence we choose n = n' - 1 = (d / 7) * 3 - 1, so that n/d < 3/7.
#   Since (d / 7) * 3 is already an integer, it is equal to floor(d * 3 / 7),
#   which will unifie with the next case. Thus n = floor(d * 3 / 7) - 1.
# - Otherwise d is not a multiple of 7, so choosing n = floor(d * 3 / 7)
#   will automatically satisfy n/d < 3/7, and be the largest possible n
#   due to the definition of the floor function.
# 
# When we choose n in this manner, it might not be coprime with d. In other words,
# the simplified form of the fraction n/d might have a denominator smaller than d.
# 
# Let's process denominators in ascending order. Each denominator generates a pair
# of integers (n, d) that conceptually represents a fraction, without simplification.
# Whenever the current value of n/d is strictly larger than the previously saved value,
# we save this current value of (n, d).
# 
# If we handle denominators in this way - starting from 1, counting up consecutively -
# then it is guaranteed that our final saved pair (n, d) is in lowest terms. This is
# because if (n, d) is not in lowest terms, then its reduced form (n', d') would have
# been saved when the smaller denominator d' was processed, and because n/d is
# not larger than n'/d' (they are equal), the saved value would not be overwritten.
# Hence in this entire computation we can avoid explicitly simplifying any fraction at all.
# n/d > maxdenom/maxnumer
# 
# Solution to Project Euler problem 72
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 73
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# The Stern-Brocot tree is an infinite binary search tree of all positive rational numbers,
# where each number appears only once and is in lowest terms.
# It is formed by starting with the two sentinels 0/1 and 1/1. Iterating infinitely in any order,
# between any two currently adjacent fractions Ln/Ld and Rn/Rd, insert a new fraction (Ln+Rn)/(Ld+Rd).
# See MathWorld for a visualization: http://mathworld.wolfram.com/Stern-BrocotTree.html
# 
# The natural algorithm is as follows:
#   # Counts the number of reduced fractions n/d such that leftN/leftD < n/d < rightN/rightD and d <= 12000.
#   # leftN/leftD and rightN/rightD must be adjacent in the Stern-Brocot tree at some point in the generation process.
#   def stern_brocot_count(leftn, leftd, rightn, rightd):
#     d = leftd + rightd
#     if d > 12000:
#       return 0
#     else:
#       n = leftn + rightn
#       return 1 + stern_brocot_count(leftn, leftd, n, d) + stern_brocot_count(n, d, rightn, rightd)
# But instead we use depth-first search on an explicit stack, because having
# a large number of stack frames seems to be supported on Linux but not on Windows.
# 
# Solution to Project Euler problem 74
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 75
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Pythagorean triples theorem:
#   Every primitive Pythagorean triple with a odd and b even can be expressed as
#   a = st, b = (s^2-t^2)/2, c = (s^2+t^2)/2, where s > t > 0 are coprime odd integers.
# 
# 
# Solution to Project Euler problem 76
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 77
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 78
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# We calculate partitions[i] mod 10^6 using a formula based on generalized pentagonal numbers:
#   partitions(i) =   partitions(i - pentagonal(1)) + partitions(i - pentagonal(-1))
#                   - partitions(i - pentagonal(2)) - partitions(i - pentagonal(-2))
#                   + partitions(i - pentagonal(3)) + partitions(i - pentagonal(-3))
#                   - partitions(i - pentagonal(4)) - partitions(i - pentagonal(-4))
#                   + ...,
#   where pentagonal(j) = (3*n^2 - n) / 2, and
#   we stop the sum when i - pentagonal(+/-j) < 0.
# Note that for j > 0, pentagonal(j) < pentagonal(-j) < pentagonal(j+1).
# 
# (The formula is used without mathematical justification;
# see https://en.wikipedia.org/wiki/Partition_(number_theory)#Generating_function .)
# index == (j * j * 3 + j) // 2
# Check or memoize the number
# 
# Solution to Project Euler problem 79
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Only guess characters that appear in the attempts
# Try ascending lengths
# Increment indices
# 
# Solution to Project Euler problem 80
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 81
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Dynamic programming
# Mutable
# 
# Solution to Project Euler problem 82
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Dynamic programming
# Minimum of rightmost column
# 
# Solution to Project Euler problem 83
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Bellman-Ford algorithm with early exit
# Note: The worst-case number of iterations is w*h
# 
# Solution to Project Euler problem 84
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# This is a statistical sampling approximation algorithm that simply simulates the game for a fixed number of dice rolls.
# An exact algorithm would involve calculating the eigenvector of the largest eigenvalue of the transition matrix (which is practical),
# but averaging over all possible permutations of both the Chance and Community Chest decks (which is computationally infeasible).
# Roll tetrahedral dice
# Process actions for some locations
# Chance
# Next railway
# Next utility
# Go to jail
# Community chest
# 
# Solution to Project Euler problem 85
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# A bit more than m^2 n^2 / 4
# 
# Solution to Project Euler problem 86
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# solutions[k] is the set of all solutions where the largest side has length k.
# A solution is a triple (x, y, z) such that 0 < x <= y <= z, and in the rectangular prism with dimensions x * y * z,
# the shortest surface path from one vertex to the opposite vertex has an integral length.
# Generates all solutions where the largest side has length less than 'limit'.
# Pythagorean triples theorem:
#   Every primitive Pythagorean triple with a odd and b even can be expressed as
#   a = st, b = (s^2-t^2)/2, c = (s^2+t^2)/2, where s > t > 0 are coprime odd integers.
# Now generate all Pythagorean triples, including non-primitive ones.
# Assumes that a^2 + b^2 = c^2.
# Add canonical solution
# cumulativesolutions[m] = len(solutions[0]) + len(solutions[1]) + ... + len(solutions[m]).
# Extend the solutions list with blank sets
# Compute the number of cumulative solutions up to and including a certain maximum size
# Raise the limit and keep searching
# 
# Solution to Project Euler problem 87
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 88
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# minSumProduct[k] is the smallest positive integers that can be written as both a sum and a product of the same collection of k positive integers.
# For example, minSumProduct[3] = 6 because 6 = 1 + 2 + 3 = 1 * 2 * 3, and this is the minimum possible number for 3 terms.
# 
# For all k >= 2:
# - minSumProduct[k] > k because 1 + ... + 1 (with k terms) = k, which is the minimum sum of k positive integers,
#   but the product is 1 which is unequal to k, so k is not a valid solution.
# - minSumProduct[k] <= 2k because 1 + ... + 1 + 2 + k (with k terms in total) = (k - 2) + 2 + k = 2k. The product is 2k, which equals the sum.
#   Since this is one achievable solution, the minimum solution must be no larger than this.
# - Aside: minSumProduct[k] is not a prime number. Suppose minSumProduct[k] = p, where p is prime. Then p can only be factorized as p, p * 1, p * 1 * 1, etc.
#   So whenever the factorization has more than one term, the sum exceeds p, which makes it unequal to the product.
# 
# Therefore we need to consider all numbers from 2 to LIMIT*2 and factorize them in all possible ways to find all the relevant solutions.
# Calculates all factorizations of the integer n >= 2 and updates smaller solutions into minSumProduct.
# For example, 12 can be factorized as follows - and duplicates are eliminated by finding only non-increasing sequences of factors:
# - 12 = 12. (1 term)
# - 12 = 6 * 2 * 1 * 1 * 1 * 1 = 6 + 2 + 1 + 1 + 1 + 1. (6 terms)
# - 12 = 4 * 3 * 1 * 1 * 1 * 1 * 1 = 4 + 3 + 1 + 1 + 1 + 1 + 1. (7 terms)
# - 12 = 3 * 2 * 2 * 1 * 1 * 1 * 1 * 1 = 3 + 2 + 2 + 1 + 1 + 1 + 1 + 1. (8 terms)
# Without using factors of 1, the sum never exceeds the product
# Note: maxfactor <= remain
# Eliminate duplicates and compute sum
# 
# Solution to Project Euler problem 89
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 4000 is MMMM, which doesn't have a two-letter form
# Compensate for this fact
# e.g. (empty), I, II, III, IV, V, VI, VII, VIII, IX
# 
# Solution to Project Euler problem 90
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Each die has (10 choose 6) arrangements, so we have at most 44100 arrangements to check
# Ensure i <= j to force the dice to be orderless
# If both have Hamming weight of 6
# 
# Solution to Project Euler problem 91
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# For uniqueness, ensure that (x1,y1) has a larger angle than (x2,y2)
# Tests whether the three points {(0,0), (x1,y1), (x2,y2)} form a right triangle.
# 
# Solution to Project Euler problem 92
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 93
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Try all possible orderings of operands and operators
# 0 = operator slot, 1 to 9 = literal operand
# Try all possibilities for the 3 operators
# Operator index
# Operand
# Operator
# Consume an operator
# Find largest set of consecutive expressible integers starting from 1
# 
# Solution to Project Euler problem 94
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Consider an arbitrary almost equilateral triangle with side lengths (c, c, c +/- 1).
# Split it down the middle to get a right triangle, and label the new sides.
#     /\               /|
#  c /  \ c         c / | b
#   /    \    -->    /  |
#  --------         -----
#   c +/- 1           a
# Note that a = (c +/- 1) / 2, and a^2 + b^2 = c^2 (Pythagorean theorem).
# 
# We know that c is an integer. The area of the original triangle is a*b,
# which is an integer by definition from the problem statement.
# - If a is an integer, then b is an integer (so that a*b is an integer),
#   thus (a,b,c) is a Pythagorean triple.
# - Otherwise a is an integer plus a half, then b must be even,
#   but a^2 + b^2 is not an integer, which contradicts c being an integer.
# 
# Conversely, consider an arbitrary Pythagorean triple (a,b,c).
# If 2a = c +/- 1, then we can form an almost equilateral triangle:
#     /|\
#  c / | \ c
#   /  |  \
#  ---------
#      2a
# For this to happen, the Pythagorean triple must be primitive. Because if not,
# then a = 0 mod k and c = 0 mod k for some k > 1, which means 2a = 0 mod k which
# cannot equal c +/- 1 = +/- 1 mod k. So we only need to generate primitive triples.
# 
# Pythagorean triples theorem:
#   Every primitive Pythagorean triple with a odd and b even can be expressed as
#   a = st, b = (s^2-t^2)/2, c = (s^2+t^2)/2, where s > t > 0 are coprime odd integers.
# What search range do we need?
# c = (s^2+t^2)/2. Perimeter = p = 3c +/- 1 = 3/2 (s^2+t^2) +/- 1 <= LIMIT.
# We need to keep the smaller perimeter within limit for
# the search to be meaningful, so 3/2 (s^2+t^2) - 1 <= LIMIT.
# With t < s, we have that s^2+t^2 < 2s^2, so 3/2 (s^2+t^2) - 1 < 3s^2 - 1.
# Therefore it is sufficient to ensure that 3s^2 - 1 <= LIMIT, i.e. s^2 <= (LIMIT+1)/3.
# Swap the roles of a and b and try the same tests
# Note that a != b, since otherwise c = a * sqrt(2) would be irrational
# 
# Solution to Project Euler problem 95
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# divisorsum[n] is the sum of all the proper divisors of n
# Analyze the amicable chain length for each number in ascending order
# 'count' is the length of the this amicable chain
# Exceeds limit or not a chain (a rho shape instead)
# 
# Solution to Project Euler problem 96
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# For example: extract([3, 9, 4, 1, ...]) = 394
# Given a string of 81 digits, this returns a list of 81 ints representing the solved sudoku puzzle.
# Initialize initial state
# Returns True/False to indicate whether a solution was found
# when given the initial state and coordinates.
# Otherwise backtrack
# Call the helper function
# 
# Solution to Project Euler problem 97
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 98
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Strings a and b must be anagrams of each other.
# 10 strings per line, except final line
# 
# Solution to Project Euler problem 99
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# First try fast low-precision computations, retrying with increasing precision
# Use interval arithmetic for approximate comparisons
# Otherwise do full-precision comparison (slow)
# Represents a strictly positive number equal to mantissa * 2^exponent
# The output's mantissa will have 'precision' or fewer bits
# In case 'man' is bumped up to the next power of 2
# Exponentiation by squaring
# 10 pairs per line
# 
# Solution to Project Euler problem 100
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Suppose the box has b blue discs and r red discs.
# The probability of taking 2 blue discs is [b / (b + r)] * [(b - 1) / (b + r - 1)],
# which we want to be equal to 1/2. Rearrange the equation:
#   [b(b - 1)] / [(b + r)(b + r - 1)] = 1 / 2.
#   2b(b - 1) = (b + r)(b + r - 1).
#   2b^2 - 2b = b^2 + br - b + br + r^2 - r.
#   b^2 - b = r^2 + 2br - r.
#   b^2 - (2r + 1)b + (r - r^2) = 0.
# Apply the quadratic equation to solve for b:
#   b = [(2r + 1) +/- sqrt((2r + 1)^2 - 4(r - r^2))] / 2
#     = r + [1 +/- sqrt(8r^2 + 1)]/2
#     = r + [sqrt(8r^2 + 1) + 1]/2.  (Discard the minus solution because it would make b < r)
# 
# For b to be an integer, we need sqrt(8r^2 + 1) to be odd, and also 8r^2 + 1 be a perfect square.
# Assume 8y^2 + 1 = x^2 for some integer x > 0.
# We can see this is in fact a Pell's equation: x^2 - 8y^2 = 1.
# 
# Suppose we have the solution (x0, y0) such that x0 > 0 and x0 is as small as possible.
# This is called the fundamental solution, and all other solutions be derived from it (proven elsewhere).
# Suppose (x0, y0) and (x1, y1) are solutions. Then we have:
#   x0^2 - 8*y0^2 = 1.
#   (x0 + y0*sqrt(8))(x0 - y0*sqrt(8)) = 1.
#   (x1 + y1*sqrt(8))(x1 - y1*sqrt(8)) = 1.  (Similarly)
# Multiply them together:
#   [(x0 + y0*sqrt(8))(x0 - y0*sqrt(8))][(x1 + y1*sqrt(8))(x1 - y1*sqrt(8))] = 1 * 1.
#   [(x0 + y0*sqrt(8))(x1 + y1*sqrt(8))][(x0 - y0*sqrt(8))(x1 - y1*sqrt(8))] = 1.
#   [x0*x1 + x0*y1*sqrt(8) + x1*y0*sqrt(8) + 8y0*y1][x0*x1 - x0*y1*sqrt(8) - x1*y0*sqrt(8) + 8y0*y1] = 1.
#   [(x0*x1 + 8y0*y1) + (x0*y1 + x1*y0)*sqrt(8)][(x0*x1 + 8y0*y1) - (x0*y1 + x1*y0)*sqrt(8)] = 1.
#   (x0*x1 + 8y0*y1)^2 - 8*(x0*y1 + x1*y0)^2 = 1.
# Therefore (x0*x1 + 8y0*y1, x0*y1 + x1*y0) is also a solution.
# By inspection, the fundamental solution is (3, 1).
# Fundamental solution
# Current solution
# An alias for the number of red discs
# Check if this solution is acceptable
# Is odd
# Create the next bigger solution
# 
# Solution to Project Euler problem 101
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# The generating function u(n) is a polynomial of degree 10.
# OP(k, n) is a polynomial of degree at most k-1, which can be obtained
# by the Lagrange interpolating polynomial (or other methods).
# Any polynomial P(n) of degree k has at most k roots (i.e. points where P(n) = 0).
# The zero polynomial Z(n) = 0 has negative infinite degree, and has roots everywhere.
# Now, let E(n) = u(n) - OP(k, n), which is also a polynomial.
# 
# If k <= 10, then OP(k, n) has degree less than k <= 10, so E(n) has degree 10. So E(n) has at most 10 roots.
# By construction, OP(k, n) = u(n) for n = 1, 2, ..., k, thus E(n) already has k roots at {1, 2, ..., k}.
# E(n) has at most 10 - k roots remaining, hence among the 11 - k values {k+1, k+2, ..., 11},
# there must be an n where E(n) != 0 (i.e. an incorrect term where OP(k, n) != u(n)).
# 
# If k > 10, E(n) has k roots at {1, 2, ..., k}, and possibly others.
# So either E(n) has degree at least k, or it's the zero polynomial.
# Now, u(n) has degree 10 and OP(k, n) has degree at most k-1,
# so their difference E(n) has at most degree max(10, k-1) = k-1.
# This means E(n) does not have degree k, so it is the zero polynomial.
# Hence u(n) = OP(k, n), and there are no incorrect terms.
# 
# In conclusion, BOPs exist for and only for 1 <= k <= 10. For each k in that range,
# the first incorrect term (FIT) of OP(k, n) exists for some n in {k+1, k+2, ..., 11}.
# Lagrange interpolation
# 
# Solution to Project Euler problem 102
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 103
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# We start with three pedantic lemmas to constrain the nature of possible solutions.
# 
# No-zero lemma:
#   A special sum set (SSS) should not contain the value 0. The problem statement
#   doesn't say this explicitly, but it is implied in the numerical examples.
# Proof:
#   - For size n = 0, {} technically qualifies as an SSS, and is trivially optimum.
#     But the problem statement does not mention the n = 0 case at all.
#   - For size n = 1, {0} has sum 0, which is better than the SSS {1} given in the
#     problem statement, yet this violates no properties. Even though the subsets
#     {} and {0} have the same sum of 0, the properties only apply to non-empty subsets.
#   - For size n = 2, {0,1} has sum 1, which is better than the SSS {1,2} given in
#     the problem statement, yet this still violates no properties. There is exactly
#     one possible pair of non-empty disjoint subsets, namely {0} vs. {1}, and
#     this pair satisfies both properties.
#   - For sizes n >= 3, having 0 in the set would violate property (ii) for the pair of
# 	subsets {0,a} and {b}, where 0 and a and b are distinct elements of the set and a < b.
#   Hence for 0 <= n <= 2, allowing 0 would produce a more optimum solution than the
#   examples given in the problem statement, and for n >= 3 an SSS can never contain 0.
# 
# As for negative numbers, the intent of the problem statement readily suggests that elements
# are never negative. Furthermore, having negative numbers in a set would either affect the
# sum by only a small amount or violate property (ii), making the problem uninteresting.
# 
# Upper bound lemma:
#   For each natural number n >= 0, there exists a special sum set
#   whose size is n and whose sum is (n + 1) * 2^n - 1.
# Proof:
#   - For each index i (counting from 0), let element i equal 2^n + 2^i.
#   - The sum of all the elements is (2^n + 2^0) + (2^n + 2^1) + ... + (2^n + 2^(n-1))
#     = n * 2^n + (2^0 + 2^1 + ... + 2^(n-1)) = n * 2^n + 2^n - 1 = (n + 1) * 2^n - 1.
#   - For example with n = 4, the elements expressed in binary are {10001,
#     10010, 10100, 11000}. Their sum is 1001111 (binary) = 79 (decimal).
#   - Notice that when summing a subset of (distinct) elements, the bottom n bits
#     never produce a carry. This means the bottom n bits behave like a set union,
#     and the activity in the bottom n bits never affect the 2^n term or above.
#   - Property (i) is satisfied because for any subset B, the bottommost n bits of S(B)
#     encode which elements are present. Thus any two unequal subsets will have unequal sums.
#   - Property (ii) is satisfied because for any subset B, the value floor(S(B) / 2^n)
#     (i.e. dropping the bottommost n bits) encodes the size of B.
# Corollaries:
#   - For any given upper bound, there are a finite number of {{sets of positive integers}
#     whose sum doesn't exceed the upper bound}. Thus once we find an SSS with a certain sum,
#     we can argue by finite search that there must exist an optimum SSS whose sum is
#     less than or equal to the aforementioned sum.
#   - For size 7, we know there exists an SSS of sum exactly (7 + 1) * 2^7 - 1 = 1023.
#     Hence we don't need to search any larger sums.
# 
# Lower bound lemma:
#   For each n >= 3, each special sum set of size n must have sum at least 2^n.
# Proof:
#   - A set of size n has exactly 2^n - 1 non-empty subsets
#     (the kind relevant to the problem statement).
#   - Because all elements are positive integers, the lowest possible
#     subset sum is 1, and the highest sum is the sum of all elements.
#   - To satisfy property (i) and give each non-empty subset a unique sum, the
#     set of sums with the smallest maximum value is {1, 2, 3, ..., 2^n - 1}.
#   - To achieve the aforementioned set of subset sums using positive elements,
#     the one and only solution is the set {1, 2, 4, 8, ..., 2^(n-1)}.
#   - But for n >= 3, the pair of subsets {1,2} and {4} violates property (ii).
#   - Hence the set cannot have sum 2^n - 1. It must have a sum of at least 2^n.
# Corollary:
#   We can begin searching for an optimum SSS with the initial maximum sum set to 2^n.
# At the top level, we try larger and smaller values of s until we find the smallest value
# of s such that there exists a special sum set with sum at most s. As long as no solution
# exists when the sum is at most s - 1, it means that the optimum set's sum is exactly s.
# First we try maxsum = 1, 2, 4, 8, ..., doubling the maximum sum until we find a solution.
# Now we know that there must be a special sum set whose sum is at most
# maxsum, and also that no solution exists for maxsum / 2.
# Perform a kind of binary search to decrease maxsum to the optimal value.
# For example, if maxsum = 256, then we know that a solution exists for
# maxsum = 256 but no solution exists for maxsum = 128. We don't know if
# maxsum = 129, 130, ..., 255 will yield solutions. We first try maxsum
# = 256 - 64, and depending on whether a solution exists, we eliminate
# either the bottom half of the search range or the top half. Then we
# try smaller steps, and stop after handling a step size of 1.
# Must be not None
# This helper class represents a finite sequence of distinct positive integers
# that satisfies properties (i) and (ii) given in the problem statement.
# Objects of the class are immutable. Objects also keep track of extra data to
# make it easier to check if adding a new element would violate the properties,
# without explicitly checking every non-empty disjoint subset pair by brute force.
# Returns the lexicographically lowest special sum set with the given size
# and with a sum of at most maximumsum, or None if no such set exists.
# Returns the lexicographically lowest special sum set by adding exactly sizeremain elements
# to the given set, such that the sum of the additional elements is at most sumremain,
# and the next element to be added is at least startval. Returns None if no such set exists.
# In summary, this procedure takes a partial answer (prefix) and some parameters,
# and tries to extend the answer by performing depth-first search through recursion.
# Base case - success
# Optimization: If we still need to add at least 2 elements, then the next element
# will be at least startval, the one after will be at least startval + 1,
# thereafter is at least startval + 2, et cetera. The sum of the elements
# to be added is strictly greater than startval * sizeremain, which we can
# check against sumremain and bail out early if a solution is impossible.
# Optimization: If the partial set has at least two elements a and b, then by the
# property (ii), S({a, b}) = a + b must be greater than any single element of the set.
# We use the foremost two elements, which have the smallest values - this makes
# endval as small and restrictive as possible compared to other choices of elements.
# Consider each possible value for the next element
# Try adding the value and see if any property is violated
# Recurse and see if a solution is found down the call tree
# No solution for the given current state
# Internal constructor. The contents of the given list objects must not change.
# Note: All fields are conceptually immutable
# Positive numbers in strict ascending order. Length 0 or more.
# For indexes i from 0 to sum(values) inclusive, sumpossible[i]
# is true iff there exists a subset of 'values' whose sum is i.
# For i from 0 to len(values) (inclusive), minimumsum[i] is the minimum sum
# among all possible subsets of 'values' of size i, and likewise for maximumsum[i].
# Attempts to add the given value to this set, returning a new set
# if successful. Otherwise returns None if any property is violated.
# Simple checks on the value
# Check if adding val to any subset of this set would create a duplicate sum
# Compute minimum and maximum sums for each subset size, with help from old data.
# The idea is that by introducing the new value val, each subset of the new set
# either contains val or doesn't. All old subsets are still possible, so we copy
# the old tables of minima and maxima. Each new subset contains val plus an old subset
# (possibly empty). Hence we look at the existing minima and maxima, add val to the sum,
# add 1 to the size, and merge the values into the table of minima and maxima.
# Check iff property (ii) '|B| > |C| implies S(B) > S(C)' is violated
# Compute all possible new subset sums, with help from old data. This is the
# classic table-based algorithm for solving the subset sum or knapsack problem.
# Append given value to the new set
# An illustrative example for SpecialSumSet and add():
# 
# Suppose our current set is {3, 5, 6}. All its subsets and their sums are:
# - S({}) = 0.
# - S({3}) = 3.
# - S({5}) = 5.
# - S({6}) = 6.
# - S({3, 5}) = 8.
# - S({3, 6}) = 9.
# - S({5, 6}) = 11.
# - S({3, 5, 6}) = 14.
# 
# Therefore, the data arrays have the following values:
# - sumpossible = [T, F, F, T, F, T, T, F, T, T,  F,  T,  F,  F,  T].
#   (Sum legend:   0  1  2  3  4  5  6  7  8  9  10  11  12  13  14)
# - minimumsums = [0, 3,  8, 14].
# - maximumsums = [0, 6, 11, 14].
# - (Size legend:  0  1   2   3)
# 
# Now suppose we want to add the value 7 to the set. Here is what happens:
# - First we check that in sumpossible, no pair of 'true' elements are
#   separated by a distance of 7. This ensures that if we take any particular
#   subset and add 7 to it, its sum won't equal another existing subset sum.
# - Let the new set S' = S union {7} = {3, 5, 6, 7}. What are
#   the minimum and maximum subset sums for each subset size k?
#   - If k = 0, the min and max are both clearly 0.
#   - If k = |S| = 4, then min and max are the sum of all elements, thus 21.
#   - Otherwise with k > 0, consider an arbitrary subset A of S' where |A| = k.
#     - If A does not contain 7, then A is a subset of S, so A's
#       minimum sum is minimumsums[k] and A's maximum sum is maximumsums[k].
#     - Otherwise split A = {7} union B, where B does not contain 7.
#       B is a subset of S, and |B| = k - 1. So A's minimum sum is
#       7 + minimumsums[k - 1], and A's maximum sum is 7 + maximumsums[k - 1].
#     Hence newminimumsums[k] = min(minimumsums[k], 7 + minimumsums[k - 1]),
#     and newmaximumsums[k] = max(maximumsums[k], 7 + maximumsums[k - 1]).
#   For each size k that is not out of bounds, if maximumsums[k] >= minimumsums[k + 1],
#   then there exists some set of size k with some set of size k + 1 fails property (ii).
#   Otherwise property (ii) is upheld in all subset pairs (including empty subsets).
# - Finally, we compute the new sumpossible table (which is guaranteed to
#   have no conflicts), and finish creating the new set with the added element.
# 
# Solution to Project Euler problem 104
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Loop invariants: a == fib(i) % MOD, b == fib(i+1) % MOD
# If suffix is pandigital
# If prefix is pandigital
# Returns the tuple (F(n), F(n+1)), computed by the fast doubling method.
# 
# Solution to Project Euler problem 105
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 106
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Lemma to confirm denominator:
#   For each natural number n >= 2, any set of size n has exactly
#   (3^n + 1) / 2 - 2^n unordered pairs of non-empty disjoint subsets.
# Proof:
#   0. Let A be an arbitrary set of size n. We want to count its subset pairs.
#   1. Suppose we can label each element of A with a letter from the set {B, C, N}.
#      A label is defined as an n-tuple of letters from the set {B, C, N}.
#      For example, the set {a,b,c,d} can be labeled as (B,B,C,N) or (N,C,N,N).
#   2. Let L be the set of all possible labels on A. We know that |L| = 3^n.
#   3. If a label doesn't contain any B's, then it is equivalent to saying that the
#      label is composed of any number of C's and N's, so there are 2^n of them.
#   4. If a label doesn't contain any C's, then it is equivalent to saying that the
#      label is composed of any number of B's and N's, so there are 2^n of them.
#   5. If a label doesn't contain any B's or C's, then it is the singleton of all N's.
#   6. How many labels contain at least one B and at least one C?
#      Using the inclusion-exclusion principle, we have:
#      |Have B and Have C| = |All labels| - |Lacks B or Lacks C|
#          = |All labels| - (|Lacks B| + |Lacks C| - |Lacks B and Lacks C|)
#          = |All labels| - |Lacks B| - |Lacks C| + |Lacks B and Lacks C|
#          = 3^n - 2^n - 2^n + 1.
#   7. For an arbitrary label that has at least one B and at least one C,
#      what actually matters is which elements of A are put into one subset
#      and which elements of A are put into the other disjoint subset, but
#      the names of these subsets as B and C are interchangeable. Hence we
#      divide by 2 to remove this degree of freedom, giving us a final count
#      of (3^n - 2^n - 2^n + 1) / 2 = (3^n + 1) / 2 - 2^n.
# Corollary:
#   This confirms some values mentioned in the problem statement:
#   - Set size n = 7 has 966 subset pairs.
#   - Set size n = 12 has 261625 subset pairs.
# 
# 
# Main theorem:
#   Let A be an arbitrary set such that all of the following hold:
#   - Its size is n.
#   - It consists only of positive integers.
#   - It satisfies the property (ii) given in the problem statement.
#   - a0 < a1 < ... < a_{n-1} are all the elements of A listed in ascending order.
#   To verify property (i), we would need to test some number of unordered pairs
#   of non-empty disjoint subsets of A to see that the subsets have unequal sums
#   Then we claim that exactly this many pairs need to be tested for equality:
#   The summation of (n choose 2k) * [(2k choose k) / 2 - (2k choose k) / (k + 1)]
#   for k from 2 to floor(n / 2) (inclusive).
# 
# Proof:
#   We begin by arguing about what subset pairs don't need to be tested,
#   then progress to counting which subset pairs do and don't need to be tested.
#   
#   Let B and C be an arbitrary pair of non-empty disjoint subsets of A.
#   Furthermore, restrict the pair  (and prevent duplicate counting) so that
#   the smallest element of B is smaller than the smallest element of C.
#   Assume that for each element of B and C, we know what index of A
#   it comes from, but we don't look at the actual element's value.
#   
#   If sets B and C have different sizes, then property (ii) implies that
#   either S(B) < S(C) or S(B) > S(C), which in both cases imply S(B) != S(C).
#   Hence we only care about the cases where |B| = |C|.
#   
#   If |B| = |C| = 1, then we know by disjointness that S(B) != S(C).
#   (Namely because each set has a different singleton element.)
#   
#   For the interesting case, we have |B| = |C| >= 2. If we can match each
#   element of B to a unique larger element in C, then we know for sure that
#   S(B) < S(C), which further implies that S(B) != S(C). When we find such
#   a matching, the ordering of the elements of A already implies inequality,
#   without the need to examine the actual element values.
#   
#   To illustrate with a concrete example, suppose B = {a0,a1} and C = {a2,a3}
#   are subsets of some set A. For each element of the set B or C, we are
#   assumed to know what index of A the element came from. Because we know
#   a0 < a2 and a1 < a3, we add these inequalities to get S(B) = a0 + a1
#   < a2 + a3 = S(C), implying S(B) != S(C). Similarly, with B = {a0,a2} and
#   C = {a1,a3}, we have a0 < a1 and a2 < a3, leading to a0 + a2 < a1 + a3.
#   But in the case of B = {a0,a3} and C = {a1,a2}, we cannot conclude
#   whether S(B) equals S(C) without examining the actual element values.
#   
#   Let's imagine scanning the elements of A in ascending order. When we
#   encounter an element a_i that is:
#   - In B, then we push it onto a stack, remembering that we need to
#     pair it with a later (and thus larger) element that is in C.
#   - In C, then we consult the stack. If the stack is empty, then this
#     element cannot be paired with an earlier (and thus smaller) element that
#     is in B, so no match exists. Otherwise we pop one element from the stack.
#   - Not in B or C, then we ignore it because it plays no role in the sums.
#   
#   Suppose we lay out the elements of A as a sequence, and label each element
#   according to the subsets B and C in a particular way. If element a_i is in B,
#   then label it as ( (left parenthesis). If element a_i is in C, then label it
#   as ) (right parenthesis). Otherwise label it as nothing/space.
#   
#   To illustrate, suppose A has size 5, B = {a0,a1}, and C = {a2,a3}.
#   Then this pair of subsets corresponds with the label "(( ))" on A.
#   
#   We can see that a pair of subsets doesn't need to be tested if
#   its label corresponds to a string of balanced parentheses. This is
#   a well-known combinatorics problem (which I won't try to prove):
#   The Catalan number C_k = (2k choose k) / (k + 1) represents the
#   number of ways that k pairs of parentheses can be arranged in a
#   sequence to produce a proper expression (i.e. no prefix contains
#   more right parentheses than left parentheses).
#   
#   There are (n choose 2k) ways to choose elements from A that will
#   then be split among the subsets B and C. Focus on one arbitrary choice.
#   
#   Subsequently, there are (2k choose k) / 2 ways to put k of those
#   elements into B and k of those elements into C, but without
#   regards to the ordering of B and C.
#   
#   However, C_k = (2k choose k) / (k + 1) of those choices of subset
#   pairs will necessarily have unequal sums due to the ordering of
#   elements, hence they don't need to be tested.
#   
#   This means that for a given k >= 2, we need to test (n choose 2k)
#   * ((2k choose k) / 2 - (2k choose k) / (k + 1)) subset pairs.
#   
#   Finally, we sum this term for k = 2, 3, 4, ... as long as 2k <= n,
#   so that we consider all the sizes of k where we can take a pair
#   of k-sized disjoint subsets of A.
#   
# Corollary:
#   Although the derivation/justification is long, the amount of
#   arithmetic is small enough to be doable by hand calculation.
# 
# Solution to Project Euler problem 107
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# This problem involves constructing a minimum spanning tree of the graph.
# 0. First we sum all the undirected edge weights of the original graph, which are given in the form of an adjacency matrix.
# 1. Next we compute a minimum spanning tree from scratch, taking note of the total weight of the spanning tree.
# 2. Finally we subtract the spanning tree weight from the original total weight to get the final answer.
# 
# Because the graph is small, the minimum spanning tree algorithm chosen is slower but simpler:
# 0. We start with one node that forms the connected set.
# 1. In each loop iteration, we look at all the nodes that are not in
#    the connected set but are adjacent to some node in the connected set.
# 2. Among these unexplored nodes, we pick the one that has the shortest edge to a connected node.
# 3. Then we mark this new node as connected and repeat the loop.
# This procedure can be thought of as a pessimized version of Prim's algorithm -
# with the same kind of frontier exploration, but without the priority queue.
# 
# Number of nodes/vertices in the matrix
# Check that the matrix is well-behaved
# Add up all undirected edge weights
# Inefficient minimum spanning tree algorithm
# Node indexes
# Total of edge weights used in spanning tree
# One new node is connected per iteration
# 
# Solution to Project Euler problem 108
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Rewrite the equation with x = n+i, y = n+j, and manipulate it:
#   1/n = 1/x + 1/y
#       = 1/(n+i) + 1/(n+j)
#       = (2n+i+j) / ((n+i)(n+j)).
#   n(2n+i+j) = (n+i)(n+j).
#   2n^2 + ni + nj = n^2 + ni + nj + ij.
#   n^2 = ij.
# Hence i and j are divisors of n^2. To ensure unique solutions,
# we impose that x <= y, so i <= j. Also, i > 0, otherwise no j exists.
# We have i <= j = n^2 / i, thus i^2 <= n^2. With i being positive, we get that i <= n.
# Therefore the number of solutions for i is the number of divisors of n^2 in the range [1, n].
# n^2 always has an odd number of divisors. One of them is n. As for the remainder of them, half of them are below n
# and half of them are above n. So if n^2 has m divisors, then we want (m+1)/2 of them as solutions for i.
# Returns the number of divisors of n^2
# Remaining largest prime factor
# 
# Solution to Project Euler problem 109
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Both lists are orderless but duplicates are important; they are sort of like multisets
# Memoization array, with dimensions (3, 101, len(points))
# Number of ways to get exactly 'total' points in exactly 'throwz' throws, using
# items (unordered) from the 'points' list with index less than or equal to 'maxIndex'.
# 
# Solution to Project Euler problem 111
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Only valid if 1 < n <= 10^DIGITS.
# For each repeating digit
# Search by the number of repetitions in decreasing order
# Try all possibilities for filling the non-repeating digits
# Build initial array. For example, if DIGITS=7, digit=5, rep=4, i=123, then the array will be filled with 5,5,5,5,1,4,7.
# Skip the repeating digit
# If this is true, then after sorting, the array will be in an already-tried configuration
# Start at lowest permutation
# Go through all permutations
# Skip if the number has a leading zero, which means it has less than DIGIT digits
# Primes found; skip all lesser repetitions
# 
# Solution to Project Euler problem 112
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# i is bouncy
# 
# Solution to Project Euler problem 113
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Let n be the number of digits. To count the number of increasing or decreasing numbers using combinatorics,
# let's view each number as a sequence of digit readout slots and operations. For example, suppose n=5 and
# we examine the increasing number 23667. We can express it as the sequence "+ + # + # + + + # # + # + +",
# where # is a digit and + means increment. This way of thinking will be useful, as we will see.
# 
# For the set of increasing numbers, each number has n readout slots and 9 increments, positioned arbitrarily.
# Using this construction, the number is guaranteed to be increasing. Note that leading zeros can be produced.
# Conversely, for each increasing number, we can generate a (unique) sequence of slots and increments that represents it
# (putting all unused increments after the rightmost digit). Hence there are n+9 objects to arrange in sequence,
# so there are binomial(n + 9, 9) ways to arrange them. Finally we subtract 1 because 0 can be formed with this scheme,
# which must be excluded from the set of increasing numbers.
# 
# For the set of decreasing numbers, each number has n readout slots and 10 operations. Of the 10 operations,
# the leading one must be "increment to 9", and the rest must be decrements. Similar to the increasing case,
# each sequence of slots and decrements produces a decreasing number, and conversely each decreasing number
# corresponds to a unique sequence of slots and decrements. However, 0 can be formed in n+1 ways, by concentrating
# all 10 operations between some pair of slots, e.g. "+9 -9 # # # #", "# +9 -9 # # #", ..., "# # # # +9 -9".
# 
# There are 9n "flat" numbers, for example: 1, 2, ..., 9; 11, 22, ..., 99; 111, 222, ..., 999; ... (note that 0 is excluded).
# Since they are double-counted in the increasing and decreasing numbers, we subtract the size of this set.
# 
# In conclusion, the number of non-bouncy numbers is (binomial(n+9,9) - 1) + (binomial(n+10,10) - (n+1)) - 9n.
# 
# (Technically, in the problem statement and this solution, "increasing" actually means "nondecreasing" and "decreasing" means "nonincreasing".)
# 
# Solution to Project Euler problem 114
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# How many ways can a row n units long be filled? Denote this quantity as ways[n].
# Compute n = 0, 1, 2 manually as base cases.
# 
# Now assume n >= 3. Look at the leftmost item and sum up the possibilities.
# - If the item is a black square, then the rest of the row is allowed
#   to be anything of length n-1. Add ways[n-1].
# - If the item is a red block with length k where k >= 3, then:
#   - If k = n, then the whole row is filled by this red block. Add 1.
#   - Otherwise k < n, this red block is followed by a black square, then followed
#     by anything of length n-k-1. So add ways[n-4] + ways[n-5] + ... + ways[0].
# Dynamic programming
# 
# Solution to Project Euler problem 115
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# How many ways can a row n units long be filled, where red blocks are
# at least m units long? Denote this quantity as ways[n].
# Compute n = 0 manually as a base case.
# 
# Now assume n >= 1. Look at the leftmost item and sum up the possibilities.
# - If the item is a black square, then the rest of the row is allowed
#   to be anything of length n-1. Add ways[n-1].
# - If the item is a red block with length k where k >= m, then:
#   - If k = n, then the whole row is filled by this red block. Add 1.
#   - Otherwise k < n, this red block is followed by a black square, then followed
#     by anything of length n-k-1. So add ways[n-m-1] + ways[n-m-2] + ... + ways[0].
# Dynamic programming
# 
# Solution to Project Euler problem 116
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# How many ways can a row n units long be filled with black squares 1 unit long
# and colored tiles m units long? Denote this quantity as ways[n].
# Compute n = 0 manually as a base case.
# 
# Now assume n >= 1. Look at the leftmost item and sum up the possibilities.
# - If the item is a black square, then the rest of the row
#   is allowed to be anything of length n-1. Add ways[n-1].
# - If the item is a colored tile of length m where m <= n, then the
#   rest of the row can be anything of length n-m. Add ways[n-m].
# 
# At the end, return ways[length]-1 to exclude the case where the row is all black squares.
# Dynamic programming
# 
# Solution to Project Euler problem 117
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# How many ways can a row n units long be filled with:
# - Black squares 1 unit long
# - Red tiles 2 units long
# - Green tiles 3 units long
# - Blue tiles 4 units long
# Denote this quantity as ways[n].
# 
# Compute n = 0 manually as a base case.
# Now assume n >= 1. Look at the leftmost item and sum up the possibilities.
# - Black square (n>=1): Rest of the row can be anything of length n-1. Add ways[n-1].
# - Red tile     (n>=2): Rest of the row can be anything of length n-2. Add ways[n-2].
# - Green tile   (n>=3): Rest of the row can be anything of length n-3. Add ways[n-3].
# - Blue tile    (n>=4): Rest of the row can be anything of length n-4. Add ways[n-4].
# Dynamic programming
# 
# Solution to Project Euler problem 118
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Cache for small numbers
# 
# Solution to Project Euler problem 119
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Candidates have the form n^k, where n >= 2, k >= 2, n^k >= 10, and isDigitSumPower(n^k) == true.
# We also impose n^k < limit. If there are at least 30 candidates under 'limit',
# then the 30th smallest candidate is the answer. Otherwise we raise the limit and search again.
# 
# We only need to try the exponents k until 2^k exceeds the limit.
# We only need to try the bases n until the power of the digit sum is too small to match n^k.
# The power of the digit sum is digitSum(n^k)^k, which is at most (9 * digitLength(n^k))^k.
# 1-based
# Powers of 10 are never a power of 1
# 
# Solution to Project Euler problem 120
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# For a given a, what is the n that maximizes the remainder, and what is the value of this remainder?
# 
# Let's simplify one term, mod a^2:
#   (a+1)^n = 1^n + (n choose 1) a 1^(n-1) + (n choose 2) a^2 1^(n-2) + ...  (by the binomial theorem)
#           = 1 + an + 0.  (remaining addends are 0 because they have a to the power of 2 or more, mod a^2)
# Similarly for the other term, mod a^2:
#   (a-1)^n = (-1)^n + (n choose 1) a (-1)^(n-1) + ...
#           = (-1)^(n-1) (-1 + an + 0)
#           = if n is even then (1 - an) else (an - 1).
# Therefore, adding the two terms:
#   (a+1)^n + (a-1)^n
#   = if n is even then 2 else 2an.
# 
# We can always make 2an >= 2 by taking n=1, for example. So we can disregard the "n is even" case.
# Maximizing 2an mod a^2 for n is the same as maximizing 2n mod a for n.
#   If a is even,  then the maximum achievable value is a - 2 by setting n = a/2 - 1.
#   Else a is odd, then the maximum achievable value is a - 1 by setting n = (a - 1) / 2.
# 
# In conclusion, if a is even, the maximum remainder is a(a-2);
# otherwise a is odd, the maximum remainder is a(a-1).
# 
# Solution to Project Euler problem 121
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# At the beginning of turn number k (0-based), there are k + 2 discs to choose from.
# Hence a game that has n turns has (n+1) * n * ... * 1 = (n + 1)! outcomes.
# 
# Let f(k, b) be the number of ways to accumulate exactly b blue discs after k turns.
# We can see that:
# - f(0, 0) = 1.
# - f(0, b) = 0, for b > 0.
# - f(k, 0) = k * f(k - 1, 0), for k > 0.
#   (Add a red disc, where there are k ways)
# - f(k, b) = f(k - 1, b - 1) + k * f(k - 1, b), for k > 0, b > 0.
#   (Add a blue disc (1 way) or add a red disc (k ways))
# 
# Next, we calculate the sum f(n, j) + f(n, j+1) + ... + f(n, n),
# where j is the smallest number of blue discs accumulated that exceeds
# the number of red discs accumulated (which is n - j). So j = ceil((n + 1) / 2).
# 
# Finally, the probability of winning is that sum divided by (n + 1)!.
# For any game where the cost of playing is 1 and the probability of winning is p,
# the maximum sustainable prize is 1 / p, therefore the maximum sustainable integer prize is floor(1 / p).
# Dynamic programming
# 
# Solution to Project Euler problem 122
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# This problem uses the concepts of https://en.wikipedia.org/wiki/Addition_chain
# and https://en.wikipedia.org/wiki/Addition-chain_exponentiation .
# 
# Definition: An addition chain is a finite sequence of integers {a_i} such that:
# - a_0 = 1 (i.e. the head element is 1).
# - For each index i (with 0 < i < length), there exists indices j and k such that 0 <= j <= k < i
#   and a_i = a_j + a_k (i.e. each subsequent element is the sum of some two elements that come before it).
# - The number of operations in an addition chain is equal to the length of the chain minus one.
# 
# Example: {1, 2, 3, 6, 9, 11} is an addition chain because
# 2 = 1 + 1, 3 = 1 + 2, 6 = 3 + 3, 9 = 3 + 6, 11 = 2 + 9.
# This chain has length 6, and uses 5 addition operations.
# 
# Note: A star chain or Brauer chain is an addition chain with the stronger condition that for each i > 0,
# there exists an index j such that 0 <= j < i and a_i = a_{i-1} + a_j. However, a minimum-length star chain
# might be longer than the minimum-length general addition chain. A counterexample is known for 12509;
# the shortest addition chain that produces 12509 is shorter than the shortest star chain that produces it.
# This is unfortunate because searching star chains is much faster than searching general addition chains.
# 
# The overall strategy of this solution is to explore all addition chains by brute force using depth-first search.
# We start with the base chain of {1}, progressively add elements that are the sum of some two earlier elements,
# and backtrack at each stage. No memoization or breadth-first search is performed because the search space is large.
# 
# An important detail is that we perform depth-limited search of the full search space, with depth = 1, 2, 3, etc.
# This gives us the benefit of breadth-first search without its high memory usage - namely, the first time
# we visit a sum of n, we can be sure that it has been reached with the smallest possible chain length.
# 
# A crucial algorithmic optimization is that we only consider addition chains that are strictly increasing.
# Clearly there is no benefit to producing a certain term twice within the same sequence (e.g. 2 + 2 = 4 and 1 + 3 = 4).
# As for the increasing order, we argue that for every addition chain that isn't strictly increasing, it can be
# reordered to one that is strictly increasing. For example, the chain {1, 2, 4, 3} can be reordered to {1, 2, 3, 4}.
# This is because if a_i > a_{i+1}, then a_{i+1} can't possibly use a_i as an addend (which are all positive),
# and it must have used two terms that are strictly in front of index i. Therefore, exploring only strictly increasing
# addition chains will still give us full coverage of the search space.
# Set up initial array of known/unknown minimum operation counts
# Use list instead of scalar to work around Python 2's broken scoping
# Recursively builds up chains and compares them to chain lengths already found.
# Depth-based termination or early exit
# Try all unordered pairs of values in the current chain
# Peek at top
# Early exit due to ascending order
# Append x to the current chain and recurse
# For each unique value of x, we set minoperations[x] only once
# because we do progressive deepening in the depth-first search
# Perform bounded depth-first search with incrementing depth
# Add up the results
# 
# Solution to Project Euler problem 123
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Using the result from Project Euler #120, we know that
# (a-1)^n + (a+1)^n mod a^2 = if (n is even) then 2 else 2an.
# Since 2 is tiny, we can skip the n is even case.
# a is the n'th (1-based) prime number, so a > n. In fact for n >= 5,
# we have a > 2n, so we can take 2an directly without moduloing it by a^2.
# 
# Solution to Project Euler problem 124
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Modification of the sieve of Eratosthenes
# 
# Solution to Project Euler problem 125
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Is palindrome
# 
# Solution to Project Euler problem 127
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# A straightforward solution would look like this:
#   for c in range(2, LIMIT):
#      for a in range(1, c):
#        b = c - a
#        if is_abc_hit(a, b, c):
#          ans += c
# 
# Here are some observations that lead to optimizations:
# - For each integer n >= 2, we have 2 <= rad(n) <= n.
# - By Euclid's GCD algorithm, gcd(c,b) = gcd(a+b,b) = gcd(a,b) = gcd(a,a+b) = gcd(a,c).
#   Hence gcd(a,b) = 1 if and only if gcd(a,c) = 1 and gcd(b,c) = 1.
#   We only need to compute and check one of these three GCDs.
# - Since {a, b, c} are mutually coprime, we have rad(a * b * c) = rad(a) * rad(b) * rad(c).
# - Instead of trying all 'a' values in the range [1, c), we only try promising 'a' values such that rad(a) * rad(c) < c.
#   If we try 'a' values in ascending order of rad(a), then we can stop the search early and not examine many values of 'a'.
# Modification of the sieve of Eratosthenes
# Get rid of the (0, 0) entry
# 
# Solution to Project Euler problem 128
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Let's do mathematical analysis to drastically reduce the amount of
# logic we need to implement and calculation the computer needs to do.
# We begin with a couple of definitions.
# 
# Ring number: Each cell belongs in a hexagonal ring,
# numbered starting from 0 at the center like this:
#               3
#           3       3
#       3       2       3
#   3       2       2       3
#       2       1       2
#   3       1       1       3
#       2       0       2
#   3       1       1       3
#       2       1       2
#   3       2       2       3
#       3       2       3
#           3       3
#               3
# 
# Corner/edge cell: Within a ring, each cell is
# either a corner cell or an edge cell, as shown:
#               C
#           E       E
#       E       C       E
#   C       E       E       C
#       C       C       C
#   E       C       C       E
#       E       C       E
#   E       C       C       E
#       C       C       C
#   C       E       E       C
#       E       C       E
#           E       E
#               C
# 
# Basic observations:
# - Except for the degenerate ring 0, each ring k has 6k cells.
#   The kth ring has exactly 6 corner cells and 6(k - 1) edge cells.
# - In the code we will skip the PD (prime difference) calculation for
#   rings 0 and 1 because the existence of ring 0 breaks many patterns.
# - Doing the PD calculation for rings 0 and 1 by hand (n = 1 to 7
#   inclusive), we find that PD(n) = 3 for and only for n = 1, 2.
# 
# Now let's analyze the characteristics of all cells in rings 2 or above.
# It's hard to justify these assertions rigorously, but they are true from
# looking at the spiral diagram.
# 
# - Corner cells along the upward vertical direction and the edge cells
#   immediately to the right of this vertical column are the most interesting,
#   so we will save these cases for last.
# 
# - Claim: Except for cells immediately right of the upward corner column,
#   no edge cell satisfies PD(n) = 3. Proof: Take an arbitrary edge cell n
#   not immediately to the right of the upward corner column...
#   - The two neighbors in the same ring have a difference of 1 compared to n,
#     which is not a prime number.
#   - The two neighbors in the previous (inward) ring are consecutive numbers,
#     so exactly one of them has an even absolute difference with n. Because
#     n is in ring 2 or above, the difference with any neighboring number in the
#     previous ring is at least 6. Thus an even number greater than 2 is not prime.
#   - Similarly, the two neighbors in the next (outward) ring are consecutive numbers.
#     One of them has an even difference with n, and this number is also at least 6,
#     so one neighbor is definitely not prime.
#   - Therefore with at least 4 neighbors that do not have a prime difference, PD(n) <= 2.
#   Example of an edge cell n = 11 in ring 2, which is straight left of the origin:
#         10
#     24      03
#         11
#     25      04
#         12
# 
# - Claim: No corner cell in the other 5 directions satisfies PD(n) = 3.
#   Proof: Take an arbitrary corner cell n in the non-upward direction...
#   - Two of its neighbors (in the same ring) have a difference of 1,
#     which is not prime.
#   - One neighbor is in the previous ring (inward) while three neighbors
#     are in the next ring (outward).
#   - Let the inner ring neighbor be k and the outer ring's middle neighbor
#     be m. The three outer ring neighbors are {m - 1, m, m + 1}.
#   - Then n - k + 6 = m - n. Also, {m - 1, m + 1} have the same parity,
#     and {k, m} have the same other parity.
#   - Either both {|k - n|, |m - n|} are even or both {|m - 1 - n|, |m + 1 - n|} are even.
#     In any case, all these differences are at least 6, so the even numbers are not prime.
#   - Therefore with at least 4 neighbors that do not have a prime difference, PD(n) <= 2.
#   Example of a corner cell n = 14 in ring 2, which is straight below the origin:
#         05
#     13      15
#         14
#     28      30
#         29
# 
# - Now let's consider an arbitrary upward corner cell n in ring k, with k >= 2.
#   We shall give variables to all its neighbors like this:
#         d
#     e       f
#         n
#     b       c
#         a
#   - a is in the previous ring, {b, c} are in the same ring as n,
#     and {d, e, f} are in the next ring.
#   - Equations derived from the structure of the hexagonal spiral:
#     n = 3k(k - 1) + 2.
#     a = n - 6(k - 1).
#     b = n + 1.
#     c = n + 6k - 1 = d - 1.
#     d = n + 6k.
#     e = n + 6k + 1 = d + 1.
#     f = n + 6k + 6(k + 1) - 1 = n + 12k + 5.
#   - Hence we get these absolute differences with n:
#     |a - n| = 6(k - 1). (Not prime because it's a multiple of 6)
#     |b - n| = 1. (Not prime)
#     |c - n| = 6k - 1. (Possibly prime)
#     |d - n| = 6k. (Not prime because it's a multiple of 6)
#     |e - n| = 6k + 1. (Possibly prime)
#     |f - n| = 12k + 5. (Possibly prime)
#   - Therefore for each k >= 2, we need to count how many numbers
#     in the set {6k - 1, 6k + 1, 12k + 5} are prime.
#   Example of a corner cell n = 8 in ring 2, which is straight above the origin:
#         20
#     21      37
#         08
#     09      19
#         02
# 
# - Finally let's consider an arbitrary edge cell immediately to the right of the
#   upward vertical column. Suppose the cell's value is n and it is in ring k,
#   with k >= 2. Give variables to all its neighbors like this:
#         f
#     c       e
#         n
#     a       d
#         b
#   - {a, b} are in the previous ring, {c, d} are in the current ring, and {e, f} are in
#     the next ring. The ascending ordering of all these numbers is (a, b, c, d, n, e, f).
#   - Equations derived from the structure of the hexagonal spiral:
#     n = 3k(k + 1) + 1.
#     a = n - 6k - 6(k - 1) + 1 = n - 12k + 7.
#     b = n - 6k.
#     c = n - 6k + 1.
#     d = n - 1.
#     e = n + 6(k + 1) - 1 = n + 6k + 5.
#     f = n + 6(k + 1).
#   - Hence we get these absolute differences with n:
#     |a - n| = 12k - 7. (Possibly prime)
#     |b - n| = 6k. (Not prime because it's a multiple of 6)
#     |c - n| = 6k - 1. (Possibly prime)
#     |d - n| = 1. (Not prime)
#     |e - n| = 6k + 5. (Possibly prime)
#     |f - n| = 6(k + 1). (Not prime because it's a multiple of 6)
#   - Therefore for each k >= 2, we need to count how many numbers
#     in the set {6k - 1, 6k + 5, 12k - 7} are prime.
#   Example of an edge cell n = 19 in ring 2:
#         37
#     08      36
#         19
#     02      18
#         07
# Must be at least 3
# Because n = 1 and 2 satisfy PD(n) = 3
# 
# Solution to Project Euler problem 129
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Let n >= 1 be arbitrary but assume that it is coprime with 10.
# We want to find the smallest k such that R(k) = 0 mod n, and we'll show that 1 <= k <= n.
# 
# Let "the sequence" of n values be (R(1) mod n, R(2) mod n, R(3) mod n, ..., R(n) mod n).
# For the sake of contradiction, assume that none of the values in the sequence are 0.
# 
# Each number in the sequence is an integer in the range [1, n).
# The range has n - 1 elements, but there are n elements in the sequence.
# Hence by the pigeonhole principle, there exist two distinct indexes
# in the sequence where the elements have the same value.
# 
# Suppose the two distinct indexes (1-based) are i and j.
# So the two values in question are R(i) mod n and R(j) mod n.
# Suppose WLOG that j > i. Then clearly R(j) - R(i) = 0 mod n,
# and so R(j) - R(i) = 1...10...0 = R(j - i) * 10^i = 0 mod n.
# 
# Since 10 is coprime with n, 10 (and its powers) are invertible modulo n.
# Multiply everything in the equation by 10^-i, and we get R(j - i) = 1...1 = 0 mod n.
# 
# We know 1 <= j - i <= n - 1. Then R(i - j) mod n, which is 0, is in the sequence.
# This contradicts our assumption that none of (R(1), R(2), ... R(n)) is 0 mod n.
# 
# Therefore if we want to find an n whose solution k is such that
# k > 1000000, then we need to have n > 1000000.
# Returns the smallest k such that R(k) is divisible by n.
# Loop invariant: Equal to R(k) mod n
# Loop invariant: Equal to 10^k mod n
# 
# Solution to Project Euler problem 130
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Returns the smallest k such that R(k) is divisible by n.
# Equal to R(k) mod n
# Equal to 10^k mod n
# 
# Solution to Project Euler problem 132
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Among the integers starting from 2, take the sum of
# the first 40 integers satisfying the filter condition
# 
# Solution to Project Euler problem 133
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Repunit formula: R(k) = (10^k - 1) / 9. (Using geometric series)
# 
# For the rest of the argument, let n be an arbitrary integer that is coprime with 10.
# 
# Let k = A(n) be the smallest positive integer such that R(k) = 0 mod n.
# From problem #129, we know k exists and satisfies 1 <= k <= n.
# 
# Lemma: For each natural number m, R(m) = 0 mod n if and only if m is a multiple of k.
# Proof:
#   Backward direction:
#     Assume m is a multiple of k. Then factorize m = jk, where j is an integer.
#     Look at R(m) = R(jk) = 1...1 ... 1...1 (j groups of k 1's) = 10...010...010...01 * R(k) (informally)
#                  = (sum of 10^(ik) for i = 0 to s-1) * R(k).
#     We already have R(k) = 0 mod n, thus (sum of 10^(ik) for i = 0 to s-1) * R(k) = R(m) = 0 mod n.
#   Forward direction (by converse):
#     Assume m is not a multiple of k. Suppose for contradiction that R(m) = 0 mod n.
#     Similar the previous argument, we can zeroize blocks of k 1's while preserving the value of R(m) mod n.
#     Namely, we delete the top k 1's by subtracting R(k) * 10^(m-k), which is 0 mod n because R(k) = 0 mod n.
#     After repeated deletion of the most significant 1's, we can get m' = m mod k, so that 0 < m' < k.
#     (m' != 0 because we assumed m is not a multiple of k.) But with R(m') = R(m) = 0 mod n, and m' < k,
#     this contradicts the definition of k = A(n), the smallest value such that R(k) = 0 mod n.
#     Hence the supposition that R(m) = 0 mod n is false.
# 
# Does there exist an x such that R(10^x) is a multiple of n? By the lemma, this is true if and only if
# there exists an x such that 10^x is a multiple of k. This means k must be a product of 2's and 5's.
# 
# Actually, we don't need to compute k = A(n) to perform this test. If k = 2^a * 5^b, then all sufficiently large
# powers of 10 are a multiple of k. (If k has other prime factors, then no power of 10 is a multiple of k.)
# We know 1 <= k < n, so in this problem 1 <= k < 10^5. For k in this range, the largest exponent among a and b is 16
# (for the number 2^16 = 65536). (In general, the largest exponent is floor(log2(limit)); in this case limit = 10^5.)
# So we only need to test if 10^16 is a multiple of k, equivalent to testing if R(10^16) is a multiple of n.
# Tests whether there exists a k such that R(10^k) is a multiple of p
# 
# Solution to Project Euler problem 134
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Let p and q be the two primes. Let k be the smallest power of 10 that exceeds p.
# The number that we seek is n = mk + p, where n is divisible by q, and m is minimized.
# (For example, p = 19, q = 23, k = 100, m = 12, n = 1219.)
# 
# Firstly, n = mk + p = 0 mod q. By rearrangement, m = -p k^-1 mod q. (k^-1 exists because q is coprime with 10.)
# Then of course the smallest m that satisfies the divisibility condition is the one such that 0 <= m < q.
# 
# Solution to Project Euler problem 135
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Very important to let the inner loop terminate early
# Let x = m, y = m - k, z = m - 2k (this is an arithmetic sequence).
# By tedious but straightforward algebra, x^2 - y^2 - z^2 = (m - k)(5k - m).
# 
# For the sequence to have positive descending terms, we require m > 0, k > 0, and 2k < m.
# We know y = m - k > 0, so this term in the product (m - k)(5k - m) is positive.
# Since we want x^2 - y^2 - z^2 > 0, this means we also require the term (5k - m) > 0, so 5k > m.
# Putting these facts together, we have m/5 < k < m/2. Note: k > m/5 is equivalent to k >= floor(m/5) + 1.
# 
# As for the search range of m, since (m - k) and (5k - m) are both positive integers,
# we know that (m - k)(5k - m) >= m - k > m/2. So m/2 < x^2 - y^2 - z^2 < 10^6.
# This means we search with 0 < m < 2 * 10^6.
# 
# Solution to Project Euler problem 139
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Pythagorean triples theorem:
#   Every primitive Pythagorean triple with a odd and b even can be expressed as
#   a = st, b = (s^2-t^2)/2, c = (s^2+t^2)/2, where s > t > 0 are coprime odd integers.
# 
# Solution to Project Euler problem 142
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Finds any sum s = x+y+z such that s < limit, 0 < z < y < x, and these are
# perfect squares: x+y, x-y, x+z, x-z, y+z, y-z. Returns -1 if none is found.
# 
# Suppose we let x + y = a^2 and x - y = b^2, so that they are always square.
# Then x = (a^2 + b^2) / 2 and y = (a^2 - b^2) / 2. By ensuring a > b > 0, we have x > y > 0.
# Now z < y and z < limit - x - y. Let y + z = c^2, then explicitly check
# if x+z, x-z, and y-z are square.
# Need them to be both odd or both even so that we get integers for x and y
# Because z >= 1
# Raise the limit until a sum is found
# Lower the limit until now sum is found
# No smaller sum found
# 
# Solution to Project Euler problem 145
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# First we define an n-digit number as a number beginning with the digit 1 to 9 (i.e. not 0) and having (n-1)
# of any digit thereafter. For example, 10652 is a 5-digit number, but 08913 = 8913 is a 4-digit number.
# 
# Lucky for us, the problem bound of 10^9 means that we examine all 1-to-9-digit numbers and not need
# to exclude some subrange. Note that we need to exclude all numbers ending in 0, so that the
# reversed number does not have leading zeros.
# 
# Consider different cases for the number of digits n (from 1 to 9, but the arguments apply generally):
# - n = 1:
#   Clearly there are no solutions because the last digit is always even.
# 
# - n = 0 mod 2:
#   We begin by proving that when a number is "reversible", the process of adding
#   the number to the reverse of itself will involve no carries in the arithmetic.
#   Normally a rigorous proof would require the use of mathematical induction,
#   but instead we will do illustratively with the specific case of n = 6.
#   A 6-digit number looks like abcdef, where each of 0 <= {a,b,c,d,e,f} <= 9, except a != 0.
#   When we add the number to its reverse, we get a structure like this:
#       abcdef
#     + fedcba
#     --------
#      tuvwxyz
#   For the number to be considered reversible, every digit in
#   the sum tuvwxyz needs to be odd, i.e. in the set {1,3,5,7,9}.
#   
#   First look at the middle two columns. If the 4th column d + c = x generates a carry-out, then
#   the 3rd column c + d + 1 = w receives a carry-in. But this would in turn require the 4th column to
#   have a carry-in, because otherwise x and w would have opposite evenness/oddness. Conversely if the
#   4th column has no carry-out, then the 3rd column has no carry-in and also must have no carry-out.
#     We can extend this argument outward from the middle. If the 5th column has a carry-out, then by
#   the above argument it would cause the 4th and 3rd columns to have a carry-out, which implies
#   the 2nd column has a carry-in, which would require the 5th column to have a carry-in.
#     But once we get to the rightmost column, we know by definition that it has no carry-in.
#   Hence the leftmost column has no carry-in, which implies the 2nd column has no carry-out.
#     Therefore the whole sum has no carries at all. This lemma is good news because
#   it means we can treat each column separately without worrying about their interactions.
#   
#   Let's look at the first column with a + f = u (with u < 10 because there is no carry-out). When we
#   choose a digit value for 'a', there is a set of values we can choose for 'f' so that their sum is odd.
#   'a' cannot be 0. When 'a' is 1, 'f' can be {2, 4, 6, 8} (not 0) and not produce a carry. When 'a' is 2,
#   'f' can be {1, 3, 5, 7} (not 9) and not produce a carry. We can list all the possibilities for (a, f):
#     (1,2), (1,4), (1,6), (1,8),
#     (2,1), (2,3), (2,5), (2,7),
#     (3,2), (3,4), (3,6),
#     (4,1), (4,3), (4,5),
#     (5,2), (5,4),
#     (6,1), (6,3),
#     (7,2),
#     (8,1).
#   We see above that there are 20 choices for (a,f). For the middle digits
#   (not first or last digit), we can use 0 so there are 30 choices:
#     (0,1), (0,3), (0,5), (0,7), (0,9),
#     (1,0), (1,2), (1,4), (1,6), (1,8),
#     (2,1), (2,3), (2,5), (2,7),
#     (3,0), (3,2), (3,4), (3,6),
#     (4,1), (4,3), (4,5),
#     (5,0), (5,2), (5,4),
#     (6,1), (6,3),
#     (7,0), (7,2),
#     (8,1),
#     (9,0).
#   Therefore by combinatorics, there are 20 * 30^(n/2 - 1) reversible n-digit numbers when n is even.
#   
# - n = 1 mod 2:
#   Let's illustrate what happens with a 7-digit number abcdefg:
#     0101010
#     abcdefg
#   + gfedcba
#   ---------
#    stuvwxyz
#   The middle column d + d = w will be even unless it has a carry-in from its right neighbor, so this
#   carry is required. Hence the 4th column has a carry-in, which means the 5th column has a carry-out.
#   By symmetry since 5th column carries out, then the 3rd column c + e = v must carry out as well.
#   (This is true even in the worst case if 5th column has a carry-in but the 3rd column has no carry-in,
#   because the sum must be odd and at least 11 so even if it drops to 10 there will still be a carry-out.)
#   Because the 2nd column receives a carry-in, the 6th column must receive a carry-in to maintain parity.
#     What this shows is that when the number of digits is odd, the middle column must have a carry-in,
#   and columns that are an even distance away from it must have a carry-in. This means it is impossible
#   to have a reversible number of length n = 1 mod 4, because that would force the rightmost column
#   to have a carry-in, which is impossible by definition. Thus we require n = 3 mod 4.
#     Let's analyze a bit further. The rightmost (7th) column has no carry-in by definition.
#   So the leftmost (1st) column must have no carry-in to ensure that both t and z are odd.
#   Then the 2nd column must have no carry-out, which implies the 6th column has no carry-out.
#   This is why we get the alternating pattern of carries in the adding process.
#   
#   The rest of the work is to enumerate the possibilities for each type of digit(s) in the number:
#   - Pairs of digits which take no carry and must generate a carry (20 choices):
#     (9,8), (9,6), (9,4), (9,2),
#     (8,9), (8,7), (8,5), (8,3),
#     (7,8), (7,6), (7,4),
#     (6,9), (6,7), (6,5),
#     (5,8), (5,6),
#     (4,9), (4,7),
#     (3,8),
#     (2,9).
#     Note that the first and last digits fall into this category, and there are no 0s at all.
#   - Non-middle pairs of digits which take a carry and generate no carry (25 choices):
#     (0,0), (0,2), (0,4), (0,6), (0,8),
#     (1,1), (1,3), (1,5), (1,7),
#     (2,0), (2,2), (2,4), (2,6),
#     (3,1), (3,3), (3,5),
#     (4,0), (4,2), (4,4),
#     (5,1), (5,3),
#     (6,0), (6,2),
#     (7,1),
#     (8,0).
#   - Middle single digit, which takes a carry and generates no carry (5 choices): 0, 1, 2, 3, 4.
#   All in all, there are 5 * 20^((n + 1)/4) * 25^((n - 3)/4) = 100 * 500^((n - 3)/4)
#   reversible n-digit numbers when n = 3 mod 4.
# 
# Solution to Project Euler problem 146
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Right off the bat, we can exclude 90% of the candidates by the following observations:
# - If n = 1 mod 2, then n^2 + 1 = 0 mod 2 which is composite.
# - Thus we require n = 0 mod 2.
# - If n = 1 mod 5, then n^2 + 9 = 0 mod 5 which is composite.
# - If n = 2 mod 5, then n^2 + 1 = 0 mod 5 which is composite.
# - If n = 3 mod 5, then n^2 + 1 = 0 mod 5 which is composite.
# - If n = 4 mod 5, then n^2 + 9 = 0 mod 5 which is composite.
# - Thus we require n = 0 mod 5.
# - Taking these two together and using the Chinese remainder theorem (CRT), we require n = 0 mod 10.
# 
# For each value of n, after we generate the set {n^2 + 1, n^2 + 3, ..., n^2 + 27}, it's more efficient to take each
# prime number and test whether it divides any number, rather than take each number and test it against all prime numbers.
# This is because some numbers in this set are prime so the latter method tests some numbers against all the primes;
# the former method will bail out early as soon as ~any~ number in the set has a small prime factor.
# 
# The rest of the algorithm is implemented straightforwardly.
# Must be in non-decreasing order
# Generate the set of numbers to test for primality
# Test that each number is prime.
# Note: The nesting of the loops can be reversed, but this way is much faster.
# Test that each number that is not an increment is composite.
# This checks that the prime numbers we found are in fact consecutive.
# 
# Solution to Project Euler problem 149
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Generate the pseudorandom sequence according to the lagged Fibonacci generator
# Reshape the sequence into into a 2D array
# For the sequence of numbers in the grid at positions (x, y), (x+dx, y+dy), (x+2*dx, y+2*dy), ... until the
# last in-bounds indices, this function returns the maximum sum among all possible substrings of this sequence.
# Reset the running sum if it goes negative
# Keep track of the best seen running sum
# Scan along all line directions and positions
# Horizontal from left edge
# Vertical from top edge
# Diagonal from left edge
# Diagonal from top edge
# Anti-diagonal from top edge
# Anti-diagonal from right edge
# 
# Solution to Project Euler problem 150
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Generate the triangle
# Calculate cumulative sums for each row
# Calculate minimum subtriangle sum for each apex position
# Apex element selected at triangle[i][j]
# Ending row (inclusive)
# Calculate cumulative sums for each row
# Calculate minimum subtriangle sum for each apex position
# Apex element selected at triangle[i][j]
# 
# Solution to Project Euler problem 151
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 155
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Warning: Running this solution requires about 1 GiB of memory
# possible[i] holds all the possible capacitance values of a series/parallel
# capacitor network that uses exactly i capacitors of 60 uF each
# Union of every possible[i]
# Note: Each fraction is represented as a pair (num, den), where den > 0 and gcd(num, den) = 1.
# This approach is much faster than using the fractions.Fraction class.
# Parallel
# Series
# 
# Solution to Project Euler problem 160
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# The last 5 digits of n!, excluding trailing zeros.
# Always non-negative for every n
# We can reduce 'twos' because there is a cycle: 2^5 = 2^2505 = 32 mod 100000
# Equal to n! but with all factors of 2 and 5 removed and then modulo 10^5.
# The identity factorialIsh(n) = odd_factorialish(n) * even_factorialish(n) (mod 10^5) is true by definition.
# The product of {all even numbers from 1 to n}, but with all factors of 2 and 5 removed and then modulo 10^5.
# For example, even_factorialish(9) only considers the numbers {2, 4, 6, 8}. Divide each number by 2 to get {1, 2, 3, 4}. Thus even_factorialish(9) = factorialish(4).
# The product of {all odd numbers from 1 to n}, but with all factors of 2 and 5 removed and then modulo 10^5.
# By definition, odd_factorialish() never considers any number that has a factor of 2. The product of the numbers that not a multiple of 5 are accumulated by factorial_coprime().
# Those that are a multiple of 5 are handled recursively by odd_factorialish(), noting that they are still odd after dividing by 5.
# The product of {all numbers from 1 to n that are coprime with 10}, modulo 10^5.
# The input argument can be taken modulo 10^5 because factorialoid(10^5) = 1, and each block of 10^5 numbers behaves the same.
# Counts the number of factors of n in the set of integers {1, 2, ..., end}.
# For example, count_factors(25, 5) = 6 because {5, 10, 15, 20} each has one factor of 5, and 25 has two factors of 5.
# 
# Solution to Project Euler problem 162
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Among the set of n-digit hexadecimal numbers, how many of them:
#   
#   Are there in total?: 15*16^(n-1).
#   
#   Have no 0?: 15^n.
#   Have no 1?: 14*15^(n-1).
#   Have no A?: 14*15^(n-1).
#   
#   Have some 0?: 15*16^(n-1) - 15^n.
#   Have some 1?: 15*16^(n-1) - 14*15^(n-1).
#   Have some A?: 15*16^(n-1) - 14*15^(n-1).
#   
#   Have no 0 and have no 1?: 14^n.
#   Have no 0 and have no A?: 14^n.
#   Have no 1 and have no A?: 13*14^(n-1).
#   
#   Have some 0 or have some 1: 15*16^(n-1) - 14^n.
#   Have some 0 or have some A: 15*16^(n-1) - 14^n.
#   Have some 1 or have some A: 15*16^(n-1) - 13*14^(n-1).
#   
#   Note: (Have X) + (Have Y) = (Have X or have Y) + (Have X and have Y).
#   Have some 0 and have some 1: (15*16^(n-1) - 15^n) + (15*16^(n-1) - 14*15^(n-1)) - (15*16^(n-1) - 14^n) = 15*16^(n-1) - 29*15^(n-1) + 14^n.
#   Have some 0 and have some A: (15*16^(n-1) - 15^n) + (15*16^(n-1) - 14*15^(n-1)) - (15*16^(n-1) - 14^n) = 15*16^(n-1) - 29*15^(n-1) + 14^n.
#   Have some 1 and have some A: (15*16^(n-1) - 14*15^(n-1)) + (15*16^(n-1) - 14*15^(n-1)) - (15*16^(n-1) - 13*14^(n-1)) = 15*16^(n-1) - 28*15^(n-1) + 13*14^(n-1).
#   
#   Have no 0 and have no 1 and have no A?    : 13^n.
#   Have some 0 or have some 1 or have some A?: 15*16^(n-1) - 13^n.
#   
#   Note: (Have 0 or have 1 or have A) = (Have 0) + (Have 1) + (Have A) - (Have 0 and have 1) - (Have 0 and have A) - (Have 1 and have A) + (Have 0 and have 1 and have A).
#   Therefore:
#     Have 0 and have 1 and have A
#     = (15*16^(n-1) - 13^n) - (15*16^(n-1) - 15^n) - (15*16^(n-1) - 14*15^(n-1)) - (15*16^(n-1) - 14*15^(n-1)) + (15*16^(n-1) - 29*15^(n-1) + 14^n) + (15*16^(n-1) - 29*15^(n-1) + 14^n) + (15*16^(n-1) - 28*15^(n-1) + 13*14^(n-1))
#     = 15*16^(n-1) - 43*15^(n-1) + 41*14^(n-1) - 13^n.
# 
# Solution to Project Euler problem 164
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Let ways[d][p] be the number of ways that a d-digit number (with possible leading zeros)
# whose first 'consecutive' (i.e. 3) digits are the same as the digits of p (padding with
# leading zeros up to 'consecutive' digits) and where each of the ways does not have
# 'consecutive' consecutive digits whose sum exceeds 'maxSum'.
# 
# For example, ways[5][27] is the number of ways that a 5-digit number starts with 027 and has
# no 3 consecutive digits summing to more than 9. This set of ways includes only {02700, 02701, 02702}
# and not {02703, 02710, 02799, etc}.
# 
# For each d (from 0 to anything) and p (from 0 to (10^consecutive - 1)), ways[d][p] is equal
# to the sum of ways[d-1][p'] for 10 choices of p'. To explain by example, suppose p = 555.
# Clearly these 3 digits sum to more than 9, so ways[d][555] = 0. To give another example,
# suppose p = 421. We strip off the first digit and try all possibilities for the last digit,
# giving the set {210, 211, ..., 219}. Now we add up the ways with one fewer digit with these
# prefixes: ways[d][421] = ways[d-1][210] + ways[d-1][211] + ... + ways[d-1][219].
# 
# The final number of ways wanted is for strict 20-digit numbers (i.e. with no leading zeros),
# which is equal to the number of ways for non-strict 23-digit numbers that start with 000 minus
# the number of non-strict 22-digit numbers that start with 000, leaving only 22-digit numbers
# that start with 001 to 009, which are exactly the 20-digit numbers that start with 1 to 9.
# Dynamic programming array, with base case (ways for 0-digit numbers)
# Compute DP table
# 
# Solution to Project Euler problem 166
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Give variables to the grid cells like this:
#   [ a b c d ]
#   [ e f g h ]
#   [ i j k l ]
#   [ m n o p ]
# There are 10 four-element lines in the grid. Assume each line has a sum of s.
# We write 9 equations to equate the first row's sum with each other line's sum:
#   a + b + c + d  =  e + f + g + h.  (1st row = 2nd row)
#   a + b + c + d  =  i + j + k + l.  (1st row = 3rd row)
#   a + b + c + d  =  m + n + o + p.  (1st row = 4th row)
#   a + b + c + d  =  a + e + i + m.  (1st row = 1st column)
#   a + b + c + d  =  b + f + j + n.  (1st row = 2nd column)
#   a + b + c + d  =  c + g + k + o.  (1st row = 3rd column)
#   a + b + c + d  =  d + h + l + p.  (1st row = 4th column)
#   a + b + c + d  =  a + f + k + p.  (1st row = diagonal)
#   a + b + c + d  =  d + g + j + m.  (1st row = antidiagonal)
# Actually only 8 of these equations are linearly independent.
# So with 16 variables and 8 equations, we have 8 free variables.
# Suppose we know the values of {a,b,c,d,e,g,i,k}. We perform some algebra:
#   m = b + c + d - e - i.  (based on 1st column)
#   o = a + b + d - g - k.  (based on 3rd column)
#   j = a + b + c - g - m.  (based on antidiagonal)
#   l = a + b + c + d - i - j - k.  (based on 3rd row)
# Now comes a difficult step. We need to solve a full system of linear equations to get the rest of the values.
# Here I state the result for f and show its correctness, but not explain how the solution was found:
#   - 1 (a + b + c + d)     - 1 (m + n + o + p)
#   + 2 (a + b + c + d)     + 2 (a + e + i + m)
#   + 1 (a + b + c + d)  =  + 1 (b + f + j + n)  .
#   + 1 (a + b + c + d)     + 1 (c + g + k + o)
#   + 1 (a + b + c + d)     + 1 (a + f + k + p)
#   - 1 (a + b + c + d)     - 1 (d + g + j + m)
# Adding up all terms on the left side and on the right side, and simplifying, we get:
#   3(a + b + c + d) = 3a + 2e + 2i + b + 2f + c + 2k - d.
#   f = b + c + 2d - e - i - k.
# The rest of the way is smooth sailing:
#   h = a + b + c + d - e - f - g.  (based on 2nd row)
#   n = a + c + d - f - j.  (based on 2nd column)
#   p = a + b + c - h - l.  (based on 4th column)
# 
# Solution to Project Euler problem 169
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 171
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# The key insight is to use dynamic programming to build up the answer one digit at a time.
# 
# Let Num(n, s) denote the set of numbers of length n (with leading zeros) whose squared digits sum to s.
# For example, Num(2, 25) = {05, 34, 43, 50}.
# Then for any particular n and s, we know that Num(n, s) = union of
#   (prepend 0 to each of Num(n-1, s - 0*0)),
#   (prepend 1 to each of Num(n-1, s - 1*1)),
#   ...,
#   (prepend 9 to each of Num(n-1, s - 9*9)).
# 
# However, keeping track of these sets of numbers explicitly is just as slow as iterating over
# all the numbers by brute force. So instead, we only store the sums and counts of these sets,
# and these two pieces of information are enough to determine the final answer.
# (Furthermore, these can be reduced by the modulus.)
# Maximum possible squared digit sum (for 99...99)
# sqsum[n][s] is the sum of all length-n numbers with a square digit sum of s, modulo MODULUS
# count[n][s] is the count of all length-n numbers with a square digit sum of s, modulo MODULUS
# 
# Solution to Project Euler problem 172
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Highly customizable!
# >= 1
# >= ceiling(LENGTH / BASE), else the result is 0
# >= 2
# Let's explain how to solve this problem mostly by examples rather than by rigorous arguments.
# 
# We want to generate all the sequences of 18 decimal digits where each digit value (from '0' to '9') is used 0 to 3 times.
# We can partition the set of all possible sequences by considering, for each sequence, the multiset of digit value repetition counts.
# For example, the number 111222333444555666 has '1' used 3 times, '2' used 3 times, ..., and '6' used 3 times.
# When we look at these repetition counts, we see that 3 + 3 + 3 + 3 + 3 + 3 = 18. We always need them to sum to 18 ('LENGTH').
# 
# There are sequences with other repetition counts too. For example: 121212333444567890, the rep counts are 1 + 3 + 3 + 3 + 3 + 1 + 1 + 1 + 1 + 1.
# In fact, there are exactly 17 ways (partitions) to express 18 as an unordered sum of 10 terms with each term from 0 to 3:
# - 3 + 3 + 3 + 3 + 3 + 3 + 0 + 0 + 0 + 0
# - 3 + 3 + 3 + 3 + 3 + 2 + 1 + 0 + 0 + 0
# - 3 + 3 + 3 + 3 + 3 + 1 + 1 + 1 + 0 + 0
# - 3 + 3 + 3 + 3 + 2 + 2 + 2 + 0 + 0 + 0
# - 3 + 3 + 3 + 3 + 2 + 2 + 1 + 1 + 0 + 0
# - 3 + 3 + 3 + 3 + 2 + 1 + 1 + 1 + 1 + 0
# - 3 + 3 + 3 + 3 + 1 + 1 + 1 + 1 + 1 + 1
# - 3 + 3 + 3 + 2 + 2 + 2 + 2 + 1 + 0 + 0
# - 3 + 3 + 3 + 2 + 2 + 2 + 1 + 1 + 1 + 0
# - 3 + 3 + 3 + 2 + 2 + 1 + 1 + 1 + 1 + 1
# - 3 + 3 + 2 + 2 + 2 + 2 + 2 + 2 + 0 + 0
# - 3 + 3 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 0
# - 3 + 3 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1
# - 3 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 0
# - 3 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1
# - 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 0
# - 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1
# For example, the number 912349441125323088 is associated with the partition (3 + 3 + 3 + 3 + 2 + 2 + 1 + 1 + 0 + 0),
# because '1' is used 3 times, '2' is used 3 times, '3' is used 3 times, '8' is used 2 times, '9' is used 2 times,
# '0' is used 1 time, '5' is used 1 time, '6' is used 0 times, and '7' is used 0 times.
# 
# For each partition, we want to take the 10 decimal digit values and assign them to the terms of the partition. Here is one example assignment:
#   Frequency:   3 3 3 3 | 2 2 | 1 1 | 0 0
#   Digit value: 1 2 3 4 | 8 9 | 0 5 | 6 7
# But note that order does not matter if the frequency is the same - for example, this means the same as above:
#   Frequency:   3 3 3 3 | 2 2 | 1 1 | 0 0
#   Digit value: 4 1 3 2 | 8 9 | 5 0 | 7 6
# 
# For a given partition, how many ways are there to assign digit values to the frequencies?
# Considering the frequencies and the digit values each as a length-10 sequence (like above),
# we know that there are 10! raw ways to arrange the digit values. But order within a frequency does not matter.
# So we divide by the factorial of the repetition count of each frequency. In the example above, the answer is 10! / (4! 2! 2! 2!).
# (Note that this is a multinomial coefficient.)
# 
# Now that we have a partition and a digit value assignment to the frequencies, we can generate permutations.
# For the example above, one possible sequence (and the lexicographically lowest) is 011122233344458899 (length 18).
# If we permute this sequence, the partition and digit-frequency assignments will remain the same.
# So we want to count how many permutations this sequence has.
# 
# Given a partition and a digit-frequency assignment, how many sequences have this classification?
# Because there are 18 digits, there are 18! raw arrangements of digits for the sequence.
# But for each digit value, it is repeated k times, so we need to divide by k! to suppress identical-looking arrangements.
# In this example, there are 18! / (3! 3! 3! 3! 2! 2! 2! 2! 2! 2!) arrangements.
# 
# Now, all of the arguments above have no made use of the specific digit values, so there is a certain symmetry in the set of desired sequences.
# In particular, this means exactly 9/10th of all items have a leading zero, hence we multiply by 9/10 to get the final answer.
# Multiply by (base - 1) / base to discount sequences with leading zeros
# Expresses 'LENGTH' as a sum of 'BASE' non-increasing terms, where terms to be added are in the range [0, max].
# e.g. partitionAndCount(7, 2, [3, 3, 2, 2, 1]) asks us to express 18 as a sum of 5 more terms,
# where the new terms have a sum of 7 and each is no greater than 2 and all terms are non-increasing.
# The number of times each frequency value occurs
# Multinomial coefficient: BASE! / (histogram[0]! * histogram[1]! * ...)
# Multinomial coefficient: LENGTH! / (freqs[0]! * freqs[1]! * ...)
# 
# Solution to Project Euler problem 173
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Very important to let the inner loop terminate early
# Outer square length
# Inner square length
# 
# Solution to Project Euler problem 174
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Very important to let the inner loop terminate early
# Generate all possible laminae with at most SIZE_LIMIT tiles
# Outer square size
# Inner square hole size
# Examine the type of each total tiling
# 
# Solution to Project Euler problem 178
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Returns the number of pandigital step numbers such that each
# number is 'digits' long, starts with the digit 'head' (can be 0),
# and the union of all the digits equals the interval [low, high].
# 
# Solution to Project Euler problem 179
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Invalid for indexes 0 and 1
# 
# Solution to Project Euler problem 182
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Sentinel
# 
# Solution to Project Euler problem 186
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Path compression
# 
# Solution to Project Euler problem 187
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# LIMIT is the highest number that we will test for being semiprime.
# Make a list of primes: 2, 3, 5, 7, ... . Stop beyond LIMIT/2, because one of the prime factors in the semiprime is at least 2.
# For each prime p in the list, look at the set of numbers q such that q >= p and pq <= LIMIT.
# Actually, we can stop when p^2 > LIMIT, as we'll see later.
# In this algorithm, we find the index 'end' such that primes[i] * primes[end] > LIMIT.
# So for that p, we have (end - i) different choices for q. Since q >= p, all these pairs are unique.
# Furthermore, by the fundamental theorem of arithmetic, all the products pq are unique.
# Given a sorted list and a value, this returns an index i such that lst[i] == x if it exists,
# otherwise this returns (-i - 1) where i is the index that x should be inserted at.
# 
# Solution to Project Euler problem 188
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Because the default recursion limit of 1000 is insufficient
# Fact: If x and m are coprime, then x^y mod m = x^(y mod totient(m)) mod m
# Found a factor
# 
# Solution to Project Euler problem 191
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# num_prize_strings[i][j][k] is the number of prize strings of length i with
# exactly j absences at the tail and exactly k lates in the whole string
# On time
# Late
# Absent
# 
# Solution to Project Euler problem 197
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Floyd's cycle-finding algorithm
# Here at the top of the loop, x = f^i(-1) and y = f^{2i}(-1)
# This means index i is part of the cycle, and (2i - i) = i is some multiple of the true cycle length
# Advance the states at different speeds
# Advance by many multiples of the cycle length, then deal with the remaining iterations
# Truncate to 9 digits after the decimal point
# 
# Solution to Project Euler problem 203
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Collect unique numbers in Pascal's triangle
# Prepare list of squared primes
# Sum up the squarefree numbers
# 
# Solution to Project Euler problem 204
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 205
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 206
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# The major optimization is to do arithmetic in base 10 in the main loop, avoiding division and modulo
# Initialize
# The pattern is greater than 10^18, so start searching at 10^9
# In base 10, little-endian
# Based on length of pattern
# Increment and search
# Add 20n + 100 so that n2digits = (n + 10)^2
# Since n^2 ends with 0, n must end with 0
# Now n2digits = n^2
# Scan for 1 to 9
# Special case for 0
# 
# Solution to Project Euler problem 208
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Because the robot moves in 72-degree arcs, it can only face 5 possible directions.
# - Define the initial northward direction as the integer 0.
# - Let each anticlockwise (leftward) move add 1 to the direction, modulo 5.
# - Let each clockwise (rightward) move subtract 1 from the direction, modulo 5.
# 
# At each of the 5 possible facing directions, there are 2 possible moves.
# What is the (x, y) displacement of each of these 10 possible moves?
# 
# We can figure this out by drawing a circle with 5 points evenly spaced 72
# degrees apart. To align with the problem description, one of the points will
# be on the positive x axis. For our convenience, the circle shall have radius 4.
# Doing some moderate algebra and trigonometry, we get these point coordinates:
# - Point 0: (cos   0, sin   0)*4 = (+4, 0).
# - Point 1: (cos  72, sin  72)*4 = (+(sqrt(5)-1), +sqrt(10+2sqrt(5))).
# - Point 2: (cos 144, sin 144)*4 = (-(sqrt(5)+1), +sqrt(10-2sqrt(5))).
# - Point 3: (cos 216, sin 216)*4 = (-(sqrt(5)+1), -sqrt(10-2sqrt(5))).
# - Point 4: (cos 288, sin 288)*4 = (+(sqrt(5)-1), -sqrt(10+2sqrt(5))).
# (The inputs to cos and sin are given in degrees.)
# 
# This sequence of points is constructed so that the displacement vector from
# point k to point k+1 is equal to the displacement of making an anticlockwise
# move when facing direction k. For example, (point1 - point0) is the
# displacement of an anticlockwise move when facing north (dir=0).
# Hence, the displacement vectors of the 5 anticlockwise move are:
# - point1 - point0 = (-(5-sqrt(5)),  +sqrt(10+2sqrt(5))).
# - point2 - point1 = (-2sqrt(5)   , -2sqrt( 5-2sqrt(5))).
# - point3 - point2 = (0           , -2sqrt(10-2sqrt(5))).
# - point4 - point3 = (+2sqrt(5)   , -2sqrt( 5-2sqrt(5))).
# - point0 - point4 = (+(5-sqrt(5)),  +sqrt(10+2sqrt(5))).
# As for clockwise moves, simply take the displacements vectors above and negate the x values.
# The mapping of displacement vectors to direction states also needs to be negated modulo 5.
# 
# Altogether, we have this table of valid moves:
#    Direction | Move | x displacement |   y displacement
#   -----------+------+----------------+---------------------
#        0     | ACW  |  -(5-sqrt(5))  | +sqrt(10+2sqrt(5))
#        0     |  CW  |  +(5-sqrt(5))  | +sqrt(10+2sqrt(5))
#        1     | ACW  |    -2sqrt(5)   | -2sqrt(5-2sqrt(5))
#        1     |  CW  |  -(5-sqrt(5))  | +sqrt(10+2sqrt(5))
#        2     | ACW  |        0       | -2sqrt(10-2sqrt(5))
#        2     |  CW  |    -2sqrt(5)   | -2sqrt(5-2sqrt(5))
#        3     | ACW  |    +2sqrt(5)   | -2sqrt(5-2sqrt(5))
#        3     |  CW  |        0       | -2sqrt(10-2sqrt(5))
#        4     | ACW  |  +(5-sqrt(5))  | +sqrt(10+2sqrt(5))
#        4     |  CW  |    +2sqrt(5)   | -2sqrt(5-2sqrt(5))
# Note that -2sqrt(5-2sqrt(5)) = sqrt(10-2sqrt(5)) - sqrt(10+2sqrt(5)).
# 
# As the robot moves, it adds x components and y components to its displacement.
# - At any given time, the x coordinate equals a unique integer-weighted
#   sum of 2sqrt(5) and (sqrt(5)-5), namely i*2sqrt(5) + j*(sqrt(5)-5).
#   We can show that these two irrational components cannot "simplify"
#   with each other - i.e. when (i, j) != (0, 0), the sum must be non-zero.
# - At any given time, the y coordinate equals a unique integer-weighted
#   sum of sqrt(10-2sqrt(5)) and sqrt(10+2sqrt(5)). We will assume without proof that
#   these two components don't "interact" with each other or cancel out in any way.
# Returns a new state tuple.
# 
# Solution to Project Euler problem 211
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Can be any number >= 1, but it's most beneficial to use a product of unique small primes excluding 2
# Optional optimization: Check if x is a quadratic residue modulo some number.
# The modulus was chosen to be a product of k primes; in this case, k = 5.
# If x is a square, then it must be a quadratic residue modulo each prime.
# For each prime p, there is an approximately half chance that an arbitrary number
# is a residue mod p. Thus with 5 primes, only about 1/32 of candidates remain.
# Note that the prime 2 tells us nothing about whether x is a square, so we exclude it.
# Requires at least 640 MB of memory
# If i has a prime factor p <= sqrt, then quasiprimefactor[i] = p.
# Otherwise i > sqrt must be prime, and quasiprimefactor[i] = 0 because i may overflow an int16.
# Richer version of the sieve of Eratosthenes
# 
# Solution to Project Euler problem 214
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Requires about 400 MB of memory
# Fill table in ascending order because totient chains are strictly decreasing
# i is prime iff totient(i) = i-1
# i is prime
# 
# Solution to Project Euler problem 215
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# position > WIDTH
# 
# Solution to Project Euler problem 216
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# As per the problem statement, define t(n) = 2n^2 - 1 and assume that always n > 1.
# Hence t(n) >= 7, and the sequence is strictly increasing (with no repeats).
# 
# Algorithm statement:
# 0. Create a mutable sequence of integers, with indices (2, 3, 4, ..., 50000000)
#    initialized to (t(2), t(3), t(4), ..., t(50000000)).
# 1. For each index i = (2, 3, ..., 50000000) in ascending order:
#    a) If seq(i) = t(i) (the original value), then t(i) must be prime (proven below). Continue to (b).
#    b) If seq(i) > 1, then let p = seq(i) (actually prime but not obvious), and for each choice of index j
#       with 1 < j = kp +/- i <= 50000000, divide at least one factor of p from seq(j) until they are coprime.
#    c) Else seq(i) = 1, then do nothing.
# 
# Lemma: No term t(n) is divisible by 2, 3, or 5.
# Proof:
# - For all n, t(n) = 2n^2 - 1 is clearly odd.
# - Suppose n = {0, 1, 2} mod 3. Then 2n^2 - 1 = {2, 1, 1} mod 3, all of which are nonzero.
# - Suppose n = {0, 1, 2, 3, 4} mod 5. Then 2n^2 - 1 = {4, 1, 2, 2, 1} mod 5, all of which are nonzero.
# 
# Lemma:
#   If some p (can be prime or composite) divides some term t(n), then p also divides t(kp +/- n) for all k
#   that produces an in-bounds index; furthermore these are the only indices where the term is divisible by p.
# Proof:
#   We have the fact that p divides t(n), which means 2n^2 - 1 = 0 mod p.
#   To find all indices j where p divides t(j), we derive:
#        t(j) = 0 mod p
#   <=>  2j^2 - 1 = 0 mod p
#   <=>  2j^2 - 1 = 2n^2 - 1 mod p
#   <=>  2j^2 = 2n^2 mod p
#   <=>  2(j^2 - n^2) = 0 mod p
#   <=>  2(j - n)(j + n) = 0 mod p
#   <=>  (j = n mod p) inclusive-or (j = -n mod p).
#   In fact, the two cases are disjoint because n != 0 mod p, since it would imply
#   t(n) = 2n^2 - 1 = 0 - 1 mod p, which contradicts the initial assumption that p divides t(n).
#   The case j = n mod p is satisfied by j = kp + n for any k. The case j = -n mod p is satisfied by j = kp - n for any k.
#   Thus if j is of the form kp +/- n and j > 1, these are necessary and sufficient conditions for p to divide t(j).
# 
# Lemma: In the algorithm's main loop, for each index i when it is visited, the value seq(i) is either 1 or a prime number.
# Proof:
#   For i = (2, 3, 4) this is clearly true since t(i) is prime. Otherwise:
#   Suppose some prime p divides seq(i). What can its value be?
#   - Case p < i: By the second lemma, p also divides t(i - p). We know that i - p >= 1. We argue that i - p = 1
#     is impossible, because then i = p + 1, and t(i) = 2i^2 - 1 = 2(p + 1)^2 - 1 = 2p^2 + 4p + 1 = 1 mod p,
#     which is not a multiple of p. Hence i - p >= 2. This means p would have been the value of seq(j) for some j < i,
#     and factors of p would have been divided out of seq(i) already.
#   - Case p = i: This is impossible because t(i) = 2i^2 - 1 = -1 mod p. Furthermore,
#     this is still impossible even if factors are divided out of t(i) to yield seq(i).
#   - Case i < p < 2i: By the second lemma, p also divides t(p - i). We know that p - i >= 1. We argue that p - i = 1
#     is impossible, because then i = p - 1, and t(i) = 2i^2 - 1 = 2(p - 1)^2 - 1 = 2p^2 - 4p + 1 = 1 mod p,
#     which is not a multiple of p. Hence p - i >= 2. This means p would have been the value of seq(j) for some j < i,
#     and factors of p would have been divided out of seq(i) already.
#   - Case 2i < p: If seq(i) itself is prime, then there is no problem. Otherwise it would have at least two prime factors
#     p, q > 2i, but it would mean pq > 4i^2 > 2i^2 (because i > 0) > 2i^2 - 1 = t(i) >= seq(i), which is a contradiction.
#   Therefore the only non-contradictory case is the one where seq(i) is a prime number.
# 
# Credits:
#   My algorithm and proof were written with major help from this document:
#   https://code.google.com/archive/p/fun-math-problems/source/default/source?page=15 , p216.tex
# Produce the entire sequence
# Divide out factors using a kind of sieve
# We can assert at this point that term == 1 or isPrime(term)
# We can skip if term > LIMIT * 2 because in the second loop would do nothing. This also avoids overflows because term is a long.
# The loop does nothing because: i <= LIMIT < p/2; p/2 - i > 0; p - i > p/2; 2(p - i) > p. Clearly 2(p - i) < 2p.
# Hence 2(p - i) % p = p - 2i. Next, the start index j = i + (p - 2i) = p - i > p/2 >= LIMIT, therefore j > LIMIT.
# Visit specific later entries in the sequence and divide out all factors of p
# j starts at the smallest number such that j > i and j = +i mod p
# j starts at the smallest number such that j > i and j = -i mod p
# 
# Solution to Project Euler problem 218
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# == Primitive Pythagorean triples ==
# 
# Each valid pair generates a PPT:
# 
#   For each pair of positive integers (s,t) such that s > t, they are coprime, and one of them
#   is odd and one of them is even: Let a = s^2 - t^2 (odd), b = 2st (even), and c = s^2 + t^2 (odd).
#   Then (a,b,c) is a primitive Pythagorean triple (PPT).
# 
#   Proof: The fact that a^2 + b^2 = c^2 can be readily verified. Now for the sake of contradiction,
#   suppose some prime p divides each of {a,b,c} (which would make the Pythagorean triple non-primitive).
#   Since p divides b = 2st and p is prime, p must divide at least one of {2,s,t}. a is odd, so 2 doesn't
#   divide a, so p != 2. Hence p > 2, and p must divide at least one of {s,t}. p divides c = s^2 + t^2.
#   WLOG if p divides s, then p divides the difference c - s^2 = t^2, thus p divides t.
#   Therefore p divides {s,t}, contradicting that {s,t} are coprime.
# 
# Each PPT can be generated from some valid pair:
# 
#   Conversely, for each PPT (a,b,c) there exists an (s,t), satisfying the restrictions above,
#   that generates it using the relations above.
# 
#   Proof: WLOG assume that a is odd (otherwise swap the roles of a and b). Knowing that a^2 + b^2 = c^2
#   and b is even, rearrange it to get (b/2)^2 = (c^2 - a^2)/4 = [(c-a)/2][(c+a)/2]. The claim is that
#   (c-a)/2 and (c+a)/2 are both perfect squares. For any prime p, if it divides both (c-a)/2 and (c+a)/2,
#   then it divides the sum (which is c) and the difference (which is a), so it would also divide c^2 - a^2 = b^2,
#   contradicting the primitiveness. Thus each prime power (i.e. p^k) in the factorization of (b/2)^2 appears
#   in either the factor (c-a)/2 or the factor (c+a)/2. Since (b/2)^2 is a perfect square, each prime power
#   in it is a perfect square, and it would contribute to either (c-a)/2 or (c+a)/2, making both of them
#   perfect squares as well.
# 
#   With this setup, let s = sqrt((c+a)/2) and t = sqrt((c-a)/2), which are both positive integers.
#   It's easy to verify that a = s^2 - t^2, b = 2st, and c = s^2 + t^2. Clearly s > t, since a is added in s
#   while a is subtracted in t. {s,t} cannot both be even or both be odd, otherwise 2 divides all of {a,b,c},
#   contradicting primitiveness. {s,t} must be coprime, otherwise some p divides {s,t}, so p^2 divides s^2 = (c+a)/2
#   and p^2 divides t^2 = (c-a)^2, which contradicts {a,c} being coprime using the argument above.
# 
# 
# == Perfect triangles ==
# 
# A perfect right-angled triangle (a,b,c) has c = r^2 for some integer r. We use the PPT theorem converse
# to find (s,t). The area of the triangle (a,b,c) is ab/2 = (s^2 - t^2)(2st)/2 = st(s^2 - t^2).
# Curiously, we have c = s^2 + t^2 = r^2, which means (s,t,r) is itself a Pythagorean triple, and in fact
# a primitive one because (s,t) are coprime. Use the PPT theorem converse on (s,t,r) (or (t,s,r), depending on
# which of s or t is odd) to find (u,v), i.e. s = u^2 - v^2, t = 2uv, and r = u^2 + v^2.
# So the area is also expressible as (u^2 - v^2)(2uv)[(u^2 - v^2)^2 - (2uv)^2].
# 
# The area is divisible by 6 and 28 (super-perfectness) iff it is divisible by lcm(6, 28) = 84
# = 3 * 4 * 7 (coprime factorization) iff it is divisible by 3, 4, and 7.
# Now, the area is divisible by 4 because in the factor 2uv, either u or v is even.
# The area is divisible by 3 because st is a factor in one of the area formulas, and with (s,t,r) being
# a Pythagorean triple, at least one of {s,t} must be 0 mod 3 (see footnote 0).
# Similarly, since (s,t,r) is a Pythagorean triple, 7 divides at least one of {s,t} (so 7 divides
# the area factor of st), or s^2 = t^2 mod 7 (so 7 divides the area factor s^2 - t^2) (see footnote 1).
# 
# In conclusion, every perfect right-angled triangle is also super-perfect.
# There is no perfect triangle that isn't super-perfect.
# 
# Footnote 0: This can be proven by brute force over the 3^3 cases of values of s,t,r mod 3.
# Or alternatively: If s or t is 0 mod 3, then we're done. Otherwise, s is either 1 or 2 mod 3,
# and t is either 1 or 2 mod 3. s^2 = 1 mod 3, and t^2 = 1 mod 3. s^2 + t^2 = 2 = r^2 mod 3,
# but no r can satisfy r^2 = 2 mod 3. So this "otherwise" case is impossible.
# 
# Footnote 1: This can also be proven by brute force over all 7^3 cases of values of s,t,r mod 7.
# Or alternatively: If s or t is 0 mod 7, then we're done. Otherwise, notice that for k != 0 mod 7,
# we have that k^2 mod 7 is in the set {1,2,4} (quadratic residues). If s^2 != t^2 mod 7,
# then their sum mod 7 is not a residue, so r^2 != s^2 + t^2. Therefore it must be that s^2 = t^2 mod 7
# (e.g. s = 3 mod 7, t = 4, r = 2 mod 7).
# 
# Solution to Project Euler problem 222
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# In micrometres
# minlength[i][j] is the minimum achievable length for fitting a set of spheres in a cylindrical tube
# of radius 50000 micrometres, where the sphere of radius sphereradii[i] is at the left end,
# the bit vector j represents the set of spheres, and i must be in the set denoted by j.
# (In the integer j, bit k denotes whether the sphere of radius sphereradii[k] is in the set or not.)
# The right-side length of the rightmost sphere is included, the length of the distance between spheres
# (arranged in an optimal way) is included, but the left-side length of the leftmost sphere is excluded.
# 
# For example, minlength[3][0x819] is the minimum length of fitting the set of spheres with radii
# {30000, 33000, 34000, 41000} micrometres, where the leftmost sphere has radius 33000
# (and this value is discounted from the total length).
# Memoization
# This sphere is rightmost
# i is the index of the next sphere
# The sqrt() here is what makes the entire computation not guaranteed to be accurate
# 
# Solution to Project Euler problem 225
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 1-based
# 
# Solution to Project Euler problem 231
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 243
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# == Introduction ==
# 
# From the problem statement, a fraction n/d is resilient if and only if n and d are coprime.
# The value totient(i) equals the number of i's in the range [1, d-1] such that i and d are coprime.
# We can see this value is useful because the resilience of a denominator d,
# denoted as R(d), is equal to totient(d) / (d - 1).
# The problem gives us a target value and asks us to find the smallest d such that R(d) < target.
# 
# We know that totient(d) can be calculated from d's prime factorization.
# Namely if d = p1^k1 * p2^k2 * ... p_m^k_m where each p_i is unique and k_i >= 1,
# then totient(d) = (p1 - 1) p1^(k1 - 1) * ... * (p_m - 1) p_m^(k_m - 1).
# 
# 
# == Contiguous prime factors ==
# 
# In the context of this problem, we argue that it is never advantageous to skip a prime factor when
# searching for the smallest d. To phrase it formally, if we have some d = c * p^0 * q^k, where
# {p < q, k >= 1, and c >= 1 is coprime with p and q (i.e. c consists of the other prime factors)},
# then let d' = c * p^k * q^0 and so d' < d, and we shall show that R(d') <= R(d). Here's a long proof:
# 
# We examine the two values
#   R(d') = (totient(c) * (p - 1) * p^(k - 1)) / (c * p^k - 1) = constant * f(p, c, k) and
#   R(d ) = (totient(c) * (q - 1) * q^(k - 1)) / (c * q^k - 1) = constant * f(q, c, k),
#   where f(x, c, k) = (x - 1) x^(k - 1) / (c * x^k - 1).
# 
# Given the crucial fact that p < q, if we want to show that R(d') <= R(d) then it is
# sufficient to show that f(x, c, k) is a non-strictly increasing function with respect to x
# (with c and k being fixed). To achieve this, we take the partial derivative with respect
# to x and derive the fact that it is always non-negative. So we begin:
# 
#   d/dx f(x, c, k) = [x^(k - 2) * (c*x^k - x*k + k - 1)] / [(c*x^k - 1)^2].
#   (omitting a tedious but elementary algebraic derivation)
# 
# Because x >= 2 and c >= 1, clearly the part of the denominator (c*x^k - 1) > 0.
# Also, clearly part of the numerator x^(k - 2) > 0.
# So next we tackle the (c*x^k - x*k + k - 1) part indirectly.
# 
# The following lemma is a special case of Bernoulli's inequality.
# For all k >= 0, x^k >= 1 + k*(x - 1). Proof by induction:
#   Base case, k = 0:
#     x^k = x^0 = 1.  (left-hand side)
#     1 + k*(x - 1) = 1 + 0*(x - 1) + 1.  (RHS)
#     1 >= 1.
#   Induction step, k >= 0:
#     x^k >= 1 + k*(x - 1).  (by assumption)
#     x * x^k >= x * (1 + k*(x - 1)).
#     x^(k + 1) >= x + x*k*(x - 1).  (a)
#     (x - 1)^2 >= 0.  (squares are non-negative)
#     x^2 - 2*x + 1 >= 0.
#     k*x^2 - 2*k*x + k >= 0.
#     k*x^2 - k*x >= k*x - k.
#     x + k*x^2 - k*x >= x + k*x - k
#                      = 1 + x + k*x - k - 1
#                      = 1 + (k + 1)(x - 1).
#     x + x*k*(x - 1) >= 1 + (k + 1)(x - 1).  (b)
#     x^(k + 1) >= 1 + (k + 1)(x - 1).  (combine (a) and (b))
# 
# Now we deduce: c*x^k - x*k + k - 1
#   >= x^k - x*k + k - 1  (because c >= 1)
#   >= (1 + k*(x - 1)) - x*k + k - 1 = 0.  (using the x^k inequality lemma)
# 
# To summarize: x^(k - 2) > 0, (c*x^k - x*k + k - 1) >= 0, and (c x^k - 1)^2 > 0. Therefore we
# conclude that f'(x, c, k) >= 0 for all real x > 1, which means the function is non-strictly increasing
# when x increases. Hence with p < q, we have f(p, c, k) <= f(q, c, k), and finally that R(d') <= R(d).
# 
# The consequence of this lemma is that for any particular target, {the minimum value of d
# satisfying R(d) < target} will have the property that d uses all of the smallest prime factors
# up to a certain point (with at least 1 copy of each factor). For example, d = 2 * 3 * 5 could be
# a minimum value, and d = 2^4 * 3^2 * 5 * 7 might be one. But d = 2 * 5^8 cannot be a minimum value
# because it skips the prime number 3; the alternative d = 2 * 3^8 would be a smaller candidate.
# 
# 
# == Pseudo-resilience ==
# 
# For the sake of the mathematical argument, let's define a related value called the pseudo-resilience:
# 
#   R'(d) = totient(d) / d  (we divide by d instead of d-1)
#         = ((p1 - 1) p1^(k1 - 1) * ... * (p_m - 1) p_m^(k_m - 1)) / (p1^k1 * ... * p_m^k_m)
#         = (p1 - 1)/p1 * (p2 - 1)/p2 * ... (p_m - 1)/p_m.
# 
# Notice that this value is independent of the exponents k_i (as long as each k_i >= 1)!
# Hence the value R'(d) only depends on d's set of unique prime factors, not the multiplicity of
# each factor. Each new prime factor p decreases the pseudo-resilience R'(d) by a factor of (p - 1) / p
# (equivalent to 1 - 1/p). Note that smaller values of p cause a larger decrease.
# 
# The pseudo-resilience is always smaller than the resilience, i.e. R'(d) < R(d), so we
# can use it as a lower bound. For an arbitrary number d, if d is composed entirely of
# copies of the first n primes (e.g. d = 2^4 * 3^2 * 5 is composed of the first 3 primes),
# then R'(p1 * p2 * ... * p_n) = R'(d) < R(d). This means that if we restrict ourselves to
# only using the first n primes to build up d, then R(d) can never be smaller than the value
# R'(p1 * p2 * ... * p_n). So if we look at R'(...) for products of primes (namely primorials),
# we can derive a lower bound on at least how many distinct prime factors d must contain in
# order to make R(d) possibly fall below the target.
# 
# Suppose d's prime factorization contains all of the first n prime numbers (i.e. one or more
# copies of each), and b is another integer such that the set of the first n prime numbers contains
# all of the factors of b. (For example: n = 3, d = 2^4 * 3^2 * 5, b = 2 * 5^9.) Then it is easy
# to show that R'(b*d) = R'(d) (the extra factors have no effect), and then R(b*d) <= R(d) because:
# 
#   R(b*d) = b * totient(d) / (b*d - 1).
#   R(d)   = totient(d) / (d - 1).
#   R(b*d) / R(d) = (b * (d - 1)) / (b*d - 1)
#                 = (b*d - b) / (b*d - 1)
#                 = 1 - (b - 1) / (b*d - 1)
#                <= 1.  (because b >= 1)
# 
# We could make b arbitrary large (e.g. by setting b = 2^k), and this will make R(b*d)
# asymptotically approach R'(b*d) (equivalently R'(d)) from above. But there is no benefit
# to making b larger past a certain point, because multiplying d by the next prime factor q
# will decrease the resilience by more than any value of b ever could. This is because:
# 
#   d > 1. -d < -1.
#   q*d - d < q*d - 1.
#   (q - 1)*d < (q*d - 1).
#   (q - 1) / (q*d - 1) < 1 / d.
#   (q - 1) * totient(d) / (q*d - 1) < totient(d) / d.
#   R(q*d) < R'(d).  (by substitution)
#   Also, R'(d) = R'(b*d) < R(b*d) = b * totient(d) / (b*d - 1).
#   Therefore R(q*d) < R(b*d) for any b whose set of prime factors is already contained in d.
# 
# 
# == The algorithm ==
# 
# First we compute R'(primorial(n)) for n = 1, 2, 3, ... until R'(primorial(n)) < target.
# This gives us a lower bound, telling us that {the answer d}'s factorization needs to
# contain at least all of the first n prime numbers in order to achieve R(d) < target
# (this is a necessary but not sufficient condition). We let d = primorial(n).
# 
# With this lower bound in hand, we test values of b = 1, 2, ..., prime(n+1)-1 (inclusive)
# and try to find the smallest b (if any) such that R(b*d) < target.
# If we succeed, then b*d is the answer. Otherwise we increment n and try again.
# Note: At this point in the code, denominator is the product of one copy of each
# prime number up to and including p, totient is equal to totient(denominator),
# and totient/denominator = R'(2 * 3 * ... * p) (the pseudo-resilience).
# Advance to the next prime
# If the lower bound is below the target, there might be a suitable solution d such that
# d's factorization only contains prime factors strictly below the current (advanced) value of p
# Try to find the lowest factor i such that R(i*d) < TARGET, if any.
# Note that over this range of i, we have R'(d) = R'(i*d) < R(i*d).
# 
# Solution to Project Euler problem 249
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Use dynamic programming. count[i] is the number of subsets of primes with the sum of i, modulo MODULUS.
# Sum of all primes seen so far, and thus the highest index among nonzero entries in 'count'
# 
# Solution to Project Euler problem 250
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Use dynamic programming
# subsets[i] is {the number of subsets with sum equal to i mod 250} mod 10^16
# 
# Solution to Project Euler problem 265
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# In this problem we look at 2^n-digit binary strings and the n-digit substrings of these.
# We are given that n = 5, so we are looking at windows of 5 bits in 32-bit strings.
# 
# There are of course 32 possible cyclic windows in a 32-bit string.
# We want each of these windows to be a unique 5-bit string. There are exactly 2^5 = 32
# possible 5-bit strings, hence the 32 windows must cover the 5-bit space exactly once.
# 
# The result requires the substring of all zeros to be in the most significant bits.
# We argue that the top n bits must be all zeros, because this is one of the cyclic windows
# and the value 00...00 must occur once. Furthermore the next and previous bit must be 1 -
# because if they're not, then at least one of the adjacent windows are also zero, which
# violates the uniqueness requirement.
# 
# With n = 5, this means every candidate string must start with 000001 and end with 1.
# In other words, they are of the form 000001xxxxxxxxxxxxxxxxxxxxxxxxx1.
# The middle 25 bits still need to be determined, and we simply search by brute force.
# Must be at least 1
# Equal to n 1's in binary, i.e. 0b11111
# Make second copy
# 
# Solution to Project Euler problem 267
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# When you win a coin toss, your capital is multiplied by (1 + 2f).
# Whenever you lose, your capital is multiplied by (1 - f).
# Thus the game's result is independent of the order of wins and losses;
# what matters is only the total numbers of each outcome.
# 
# Suppose you have n tosses and w wins. Then there are n - w losses.
# By the binomial theorem, this outcome happens (n choose w) times out of 2^n.
# Moreover, the final capital is 1 * (1 + 2f)^w * (1 - f)^(n - w).
# 
# Some parts of this algorithm use accurate computations:
# - Sum of binomial coefficients in bigint, for the probability.
# - Conversion of the probability bigint fraction to decimal string.
# Some parts are inaccurate or are based on heuristics:
# - Calculating the final capital using floating-point arithmetic,
#   for each bet proportion and number of wins+losses.
# - Sampling the continuous input interval of [0.0, 1.0]
#   to try to maximize the value of the function.
# Overall this solution is not provably mathematically correct.
# Heuristic sampling algorithm.
# At level 1 we test {1/2}. At level 2 we test {1/4, 3/4}.
# At level 3 we test {1/8, 3/8, 5/8, 7/8}. Et cetera.
# Calculate the cumulative probability: binomialSum = sum (n choose k) for 0 <= k < maxIndex
# Returns the cumulative binomial probability index.
# Number of losses
# Need to take logarithms because Python's ** operator and math.pow()
# would raise an exception on overflow instead of returning infinity
# Range [0, TRIALS + 1]
# Converts a fraction to a correctly rounded decimal string.
# Round half to even
# 
# Solution to Project Euler problem 271
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# First we observe that the modulus 13082761331670030 can be factorized as
# 2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 * 29 * 31 * 37 * 41 * 43,
# which happens to be the product of the first 14 prime numbers.
# 
# Due to the laws of modular arithmetic, if x^3 = 1 mod (n*k),
# then it is also true that x^3 = 1 mod n and x^3 = 1 mod k.
# Hence the problem statement is equivalent to finding all x in the range (1, n) such that
# (x^3 = 1 mod 2) and (x^3 = 1 mod 3) and (x^3 = 1 mod 5) and ... and (x^3 = 1 mod 43).
# 
# When the main congruence of x^3 = 1 mod 13082761331670030 is broken up into a set of sub-congruences,
# because the sub-congruences have tiny moduli they are easy to solve by brute force. That is to say,
# for x^3 = 1 mod n, we can find all the solutions for x in the range [1, k) just by testing all possibilities.
# For example:
# - x^3 = 1 mod  2 has the solutions (for 1 <= x <  2) of {1}.
# - x^3 = 1 mod  7 has the solutions (for 1 <= x <  7) of {1, 2, 4}.
# - x^3 = 1 mod 11 has the solutions (for 1 <= x < 11) of {1}.
# - x^3 = 1 mod 43 has the solutions (for 1 <= x < 43) of {1, 6, 36}.
# 
# By the Chinese remainder theorem, the set of solutions for x^3 = 1 mod (n*k) has a bijection with
# the set of ordered pairs of solutions for (x^3 = 1 mod n, x^3 = 1 mod k). Furthermore, if we know
# all solutions of (x^3 = 1 mod n) and (x^3 = 1 mod k), then we can apply the CRT on these numbers to
# compute all the solutions of x^3 = 1 mod (n*k). Using this fact, we build up the full set of solutions
# from the smallest factor to the largest factor.
# Note: The recursive algorithm generates all solutions, but the problem statement excludes 1
# Assuming that p and q are coprime, 0 <= a < p, and 0 <= b < q, this returns the unique
# integer x in the range [0, p*q) such that x satisfies (x = a mod p) and (x = b mod q).
# 
# Solution to Project Euler problem 280
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Model the problem as a Markov process, and solve using dynamic programming
# Memoize the successors of each valid state
# Run the simulation
# The current probability of being in each state
# Note: The done state has no outgoing neighbors,
# so its probability disappears in the next iteration
# Note: Minimum completion is 44 steps
# Represents the global state of the system, including the ant and seeds. Immutable.
# All valid state IDs are in the range [0, ID_LIMIT). Not every number in the range is a valid state.
# Try all 2^11 ways for which cells (or ant) hold a seed
# Invalid state if not 5 things hold a seed
# For all 5*5 possible ant positions
# Returns a set (of size 0 to 4) containing this state's successors.
# Remember that this state transitions to a successor with equal probability.
# Ant moves off the grid
# Pick up seed
# Drop off seed
# 
# Solution to Project Euler problem 287
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Let R = 2^(N-1) denote the radius of the circle (filled disk) being drawn.
# 
# First, we can simplify the problem by translating (shifting) the coordinate system.
# Instead of x and y each in [0, 2^N) for the formula [x - 2^(N-1)]^2 + [y - 2^(N-1)]^2 <= R^2,
# we shall consider x and y each in [-(2^(N-1)), 2^(N-1)) for the formula x^2 + y^2 <= R^2.
# 
# Suppose we are given a square 2D region with endpoints [xstart, xend) and [ystart, yend).
# If the region is entirely white or entirely black, then it takes 2 bits to encode the region.
# Otherwise the region must have both white and black pixels, so we use 1 bit
# to encode the split, recurse on the 4 sub-squares, and sum their code lengths.
# 
# Within the region, what are the possible values of the left side of the formula, x^2 + y^2?
# To minimize or maximize x^2 + y^2, we can min/maximize each of x^2 and y^2 independently.
# - To minimize x^2, we minimize |x|. If 0 is in [xstart, xend),
#   then the minimum |x| is 0, and thus the minimum x^2 is 0.
#   Otherwise, either all possible x values are negative or all
#   are positive, so the minimum |x| is min(|xstart|, |xend-1|).
# - To maximize x^2, we maximize |x|. This simply equals max(|xstart|, |xend-1|).
# - The same arguments apply to minimizing/maximizing y^2.
# 
# Now evaluate minR^2 = minX^2 + minY^2, and maxR^2 = maxX^2 + maxY^2.
# - If maxR^2 <= R^2, then all points in the region satisfy
#   x^2 + y^2 <= R^2, hence the entire region is black.
# - Similarly, if minR^2 > R^2, then all points in the region
#   satisfy x^2 + y^2 > R^2, hence the entire region is white.
# - Otherwise, the region must contain both black and white points,
#   so we split into 4 subregions and recurse.
# 
# One further optimization: If the region [xstart, xend) * [ystart, yend) lies
# entirely within a quadrant, then calculating minR and maxR becomes trivial.
# In fact, only the root call to compressed_length() spans both positive
# and negative coordinates; all deeper calls are entirely within a quadrant.
# For a region with [xstart, xend) where xstart < xend <= 0, compressed_length()
# yields the same result when the range is replaced with [-xend + 1, -xstart + 1).
# Hence by symmetry, we can only consider cases where 0 <= xstart < xend,
# and not deal with negative ranges. This optimized bit length algorithm can
# no longer be adapted to encode the actual compressed bit stream, however.
# Returns the exact minimum number of bits required to encode
# the circle image's region of [xstart, end) * [ystart, yend),
# requiring 0 <= xstart < xend and 0 <= ystart < yend.
# All white
# All black
# Subdivide and recurse
# Top left
# Top right
# Bottom left
# Bottom right
# 
# Solution to Project Euler problem 301
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# In a game of Nim where both players play with perfect strategy, if the current state is a collection (multiset) of piles
# with sizes {n1, n2, ..., n_m}, then the current player will lose if and only if n1 XOR n2 XOR ... XOR n_m = 0.
# In this problem, we specialize the condition to just n XOR 2n XOR 3n = 0.
# 
# Facts:
#   3n = 2n + n.
#   a ^ b = 0 iff a = b. (from digital logic)
#   a + b = (a ^ b) + ((a & b) << 1). (from digital logic)
# Hence:
#   n ^ 2n ^ 3n = 0                          (what we want)
#   iff n ^ 2n = 3n                          (from the second fact)
#   iff n ^ 2n = (n ^ 2n) + ((n & 2n) << 1)  (from the third fact)
#   iff (n & 2n) << 1 = 0                    (by cancelling on both sides)
#   iff n & 2n = 0                           (left-shifting doesn't change zeroness)
#   iff the binary representation of n does not have consecutive '1' bits.
# 
# How many binary strings of length i have no consecutive 1's?
#   First partition the set into strings that begin with a 0 and strings that begin with a 1.
#   For those that begin with a 0, the rest of the string can be any string of length i-1 that doesn't have consecutive 1's.
#   For those that begin with a 1, the rest of the string can be any string of length i-1 that begins with a 0 and doesn't have consecutive 1's.
# Let numStrings(i, j) be the number of bit strings of length i that begin with the bit j and have no consecutive 1's. Then:
#   numStrings(1, 0) = 1.  (base case)
#   numStrings(1, 1) = 1.  (base case)
#   numStrings(i, 0) = numStrings(i-1, 0) + numStrings(i-1, 1).  (for i >= 2)
#   numStrings(i, 1) = numStrings(i-1, 0).                       (for i >= 2)
# This corresponds to a shifted Fibonacci sequence, because:
#   numStrings(i, 0) = numStrings(i-1, 0) + numStrings(i-2, 0).  (substitute)
#   numStrings(1, 0) = 1.  (base case)
#   numStrings(2, 0) = 2.  (derived)
#   So numStrings(i, 0) = fibonacci(i + 1).
# What we want is numStrings(30, 0) + numStrings(30, 1) = numStrings(31, 0) = fibonacci(32).
# 
# Actually, that answer considers numbers in the range [0, 2^30), which is not exactly what we want.
# According to the problem statement, we need to exclude 0 and include 2^30. But both are losing positions, so the adjustments cancel out.
# 
# Solution to Project Euler problem 303
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# This function computes and returns the smallest positive multiple of n such that the result
# uses only the digits 0, 1, 2 in base 10. For example, fmm(2) = 2, fmm(3) = 12, fmm(5) = 10.
# 
# As an overview, the algorithm has two phases:
# 0. Determine whether a k-digit solution is possible, for increasing values of k.
# 1. Knowing that a k-digit solution exists, construct the minimum solution.
# 
# Let n >= 1 be an arbitrary integer that will remain constant for the rest of the explanation.
# 
# When we look at the set of all k-digit numbers using only the digits {0, 1, 2}
# (with possible leading zeros), each number will have a particular remainder modulo n.
# For example, the set of 3-digit numbers is {000, 001, 002, 010, ..., 120, ..., 221, 222} (having 3^3 = 27 elements).
# If one of these numbers is congruent to 0 mod n, then a solution to the original problem exists.
# If not, then we prepend the digits 0, 1, 2 to all the numbers to get the set of all 4-digit numbers.
# 
# The size of the set of k-digit numbers grows exponentially with the length k, but we can avoid constructing and
# working with the explicit set of numbers. Instead, we only need to keep track of whether each remainder modulo n has
# a number that generates it or not. But we also need to exclude 0 as a solution, even though it is a multiple of n.
# 
# For 0-digit numbers, the only possible remainder is 0. All other remainders modulo n are impossible.
# For 1-digit numbers, we look at all the possible 0-digit number remainders. If a remainder m is possible, then:
# - By prepending the digit 0, a remainder of (m + 0*1 mod n) is possible for 1-digit numbers.
# - By prepending the digit 1, a remainder of (m + 1*1 mod n) is possible for 1-digit numbers.
# - By prepending the digit 2, a remainder of (m + 2*1 mod n) is possible for 1-digit numbers.
# We keep iterating this process of tracking possible remainders for k-digit
# numbers until the remainder of 0 mod n is possible in a non-zero number.
# 
# Now we know that a k-digit solution exists, such that the k-digit number consists of only {0, 1, 2},
# and the number is congruent to 0 modulo n. To construct the minimum solution, we start at the most significant
# digit of the result, choose the lowest possible value, and work backward toward the least significant digit.
# 
# The leading digit must be 1 or 2, because if it were 0 then it would contradict the fact that
# no solution shorter than k digits exists. All subsequent digits can possibly be 0, 1, or 2.
# 
# At each value place, we choose the lowest digit value out of {0, 1, 2} such that there still
# exists a solution for the remaining suffix of the number. When we choose a value at a certain
# digit position, say 2 at the 8th place, we subtract 2 * 10^8 mod n from the ongoing remainder.
# feasible[i][j] indicates whether there exists an i-digit number that consists of
# only the digits {0, 1, 2} (with possible leading zeros) having a remainder of j modulo n:
# - 0: No i-digit number can form this remainder
# - 1: Only zero can form this remainder
# - 2: Some non-zero number can form this remainder
# Initialization and base case
# Add digits on the left side until a solution exists, using dynamic programming
# Unbounded loop
# Clone
# Run time of O(n)
# Construct the smallest solution using the memoized table
# Run time of O(len(feasible)) bigint operations
# Modulo n
# Pick digit values from left (most significant) to right
# Leading digit must start searching at 1; subsequent digits start searching at 0
# 
# Solution to Project Euler problem 304
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Number of candidates starting from BASE to search for primes. Hopefully there are 100 000 primes among here.
# iscomposite[i] pertains to the number BASE + i
# Sieve of Eratosthenes, but starting at BASE
# Returns p - BASE, where p is the next prime after n + BASE
# 
# Solution to Project Euler problem 315
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Also known as digital root.
# Mapping of [0, 10) -> [0x00, 0x7F); each output fits in 7 bits.
# 
# Solution to Project Euler problem 323
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Define a sequence of random variables:
# - Let X0 be 0. (This will become apparent when we define X_n.)
# - Let X1 to represent how many trials it takes for a uniformly random bit to see
#   the first 1 (a positive integer). For example, if the random bit experiences
#   the sequence (1, 0, ...), then X1 = 1 because it took 1 trial. For example,
#   the sequence (0, 0, 0, 1, 1, 0, 1, ...) implies X1 = 4, because it took 4 trials.
# - For any integer n >= 1, let X_n represent how many trials it takes for a sequence
#   of n uniformly random bits to see at least one 1 in each bit. For example, if
#   two random bits experience the sequence (01, 01, 10, 00, 11, ...), then X2 = 3
#   because it took 3 trials for the running bitwise OR to become 11.
# 
# Now consider the expected value of each random variable:
# - E[X0] is obviously 0.
# - E[X1] is the expected value of the geometric distribution with p=0.5, with a
#   well-known answer of 2. But we can go through a more elementary derivation
#   by considering a single trial of the single bit:
#   - It has a half chance of being 0. In this case, the expected value equals the
#     probability (half) times {one plus the same unknown expected value} (because we
#     performed one trial, ended up in the same state, and the process is memoryless).
#   - It has a half chance of being 1. In this case, the expected value equals the
#     probability (half) multiplied by one (because we performed one trial).
#   Altogether, we have that E[X1] = 1/2 * (1 + E[X1]) + 1/2 * 1 = 1 + E[X1]/2.
#   Rearrange to get E[X1]/2 = 1, thus E[X1] = 2 as wanted.
# 
# - As for E[X2], look at what happens in a single trial of the two bits:
#   - If none of the bits are 1, then we have performed one trial and are back to
#     the same situation. There is a 1 in 4 chance of this happening (bit string 00).
#   - If one of the bits is 1, then we have performed one trial and the remaining calculation
#     equals E[X1]. There is a 2 in 4 chance of this happening (bit strings 01 and 10).
#   - If both of the bits are 1, then we have performed one trial and the remaining calculation
#     equals E[X0] which is 0. There is a 1 in 4 chance of this happening (bit string 11).
#   All in all, we have that E[X2] = 1/4 * (1 + E[X2]) + 1/2 * (1 + E[X1]) + 1/4 * (1 + E[X0]).
#   Simplifying, we get 3/4 * E[X2] = 1 + 1/2 * E[X1] + 1/4 * E[X0].
#   Since we know the values of E[X0] and E[X1], we can solve that E[X2] = 8/3.
# - In general for E[X_n], performing one trial results in k (0 <= k <= n) bits
#   being set to 1, with probability (n choose k) / 2^n, and the rest of the
#   expected value calculation reduces to the value of E[X_{n-k}]. Therefore:
#   E[X_n] = sum((n choose k) * (1 + E[X_{n-k}]) / 2^n for k in [0, n]).
#   Simplifying further so that E[X_n] only appears on the left side, we get:
#   (2^n - 1) * E[X_n] = 2^n + sum((n choose k) * E[X_{n-k}] for k in [0, n-1]).
#   E[X_n] = (2^n + sum((n choose k) * E[X_{n-k}] for k in [0, n-1])) / (2^n - 1).
# 
# Finally, E[X32] is the number that we want as the answer.
# Note that this solution algorithm carefully uses entirely integer arithmetic,
# even though it is tempting to use floating-point numbers as a shortcut.
# Calculate the answer
# Round the fraction properly. This is the pedantically
# correct version of doing "{:.10f}".format(float(ans))
# 
# Solution to Project Euler problem 329
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# We simulate by brute force all the possible paths that the frog can take, and
# multiply and sum the probabilities along the way. The frog is initially positioned
# at one of the 500 squares and makes a croak. Then it jumps left or right 14 times
# and makes a croak after each jump (thus there are 15 croaks per simulation).
# Overall, there are exactly 500 * 2^14 = 8.192 million paths to examine.
# 
# Let's look at how the probabilities work for a particular path:
# - Because the frog starts at each square with uniform probability and jumps left/right
#   with equal probability, the probability of any particular path is 1 / (500 * 2^14).
# - For any given path, it can generate exactly 2^15 croak sequences, but each sequence
#   doesn't have the same probability. Look at the sequence of numbers that the frog
#   lands on in this path, e.g. {2, 1, 0, 1, 2, 3, 4, 3, ...}. Now look at sequence of
#   whether each of these numbers is prime, i.e. {P, N, N, N, P, P, N, P, ...}.
#   The probability of the desired croak sequence is equal to (2/3)^(number of indexes
#   where the croak letter matches the primeness sequence) * (1/3)^(number of indexes
#   where the croak letter mismatches the primeness sequence). We can simplify this
#   expression to just 2^(number of matching indexes) / 3^15.
# 
# So for all the 8192000 paths, we calculate the probability that each path matches
# the target croak sequence, sum all these probabilities, and divide by 8192000.
# We perform calculations in fraction or integer form (not floating point),
# and extract the numerator and denominator of the final simplified result.
# 
# Note that this analysis is correct even considering the rule that when
# the frog is at one of the range endpoints, it only has one possible move
# (e.g. if the frog is at square 1, then it must move to square 2).
# For each starting square
# For each sequence of jumps
# Set initial position and croak
# Simulate each jump and croak
# Forced move
# Forced move
# Chosen move
# Chosen move
# Multiply the running probability by 2/3 if primeness of current position
# matches croak sequence at current index, otherwise multiply by 1/3
# Calculate final probability fraction
# 
# Solution to Project Euler problem 345
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Memoization
# Returns the maximum sum when considering the submatrix from row 'startrow' until the bottom,
# with the bit set 'setofcols' indicating which column indexes are still free to be used.
# 
# Solution to Project Euler problem 346
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 1 is a strong repunit because in every base b >= 2, its representation is "1", which is a repunit.
# 2 is not a strong repunit because in base 2 it is "10", but in every base b >= 3 it is "2".
# 
# As for other numbers, first assume that n is an arbitrary integer at least 3.
# It is trivially a repunit in base b = n - 1 (which is at least 2), where its representation is "11".
# For this n to be a strong repunit, it needs to be a repunit in at least one other base.
# Obviously it can't be "11" in another base. So it must be {"111",
# "1111", "11111", or some longer string} in some base smaller than b.
# 
# Phrased differently, if an integer n >= 3 has the representation {"111", "1111", or some longer string}
# in some base b >= 2, then it is automatically a strong repunit because firstly, its value is
# at least 7 ("111" in base 2), and secondly it is equal to "11" in some base b' >= 2.
# 
# Hence all we need to do is for each repunit length 3, 4, 5, etc., we generate the string (e.g. "111"),
# then evaluate its value at base 2, 3, etc. as long as the value stays within the limit,
# and add these values to the set of known strong repunits (to catch possible duplicates).
# 
# Note that the longest repunit length we need to test is at most the bit length of the limit.
# For example, because the limit is 10^12 = 1110100011010100101001010001000000000000 (base 2),
# any repunit longer than "1111111111111111111111111111111111111111" is guaranteed
# to exceed the limit in every base.
# Collect all generated numbers to eliminate duplicates
# Special case
# For each possible length of strong repunits (ignoring the trivial length of 2)
# For each base to evaluate the repunit in, until the value exceeds the limit
# Evaluate value = base^(length-1) + base^(length-2) + ... + base^1 + base^0
# Due to the geometric series, value = (base^length - 1) / (base - 1)
# Sum all the numbers generated
# 
# Solution to Project Euler problem 347
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 348
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Given a range of integers [0, n), we can bulk-calculate how many ways
# each integer can be expressed as a sum of a cube and a square.
# 
# Start by initializing an array of length n with all zeros.
# Next, write a two-level loop to explore all the cubes i^3
# and squares j^2 such that their sum is less than n:
# 
#   ways = new int[n];  // Initially all zero
#   for (i = 2; i^3 < n; i++) {
#     for (j = 2; i^3 + j^2 < n; j++) {
#       ways[i^3 + j^2]++;
#     }
#   }
# 
# The array creation takes O(n) time. The outer loop runs O(n^(1/3)) iterations,
# the inner loop runs O(n^(1/2)) iterations per outer loop, hence the inner loop body
# runs O(n^(5/6)) iterations. Thus the whole process runs in O(n) time and memory.
# 
# Finally we iterate forward through the array, selecting numbers that
# are palindromes and can be summed in the target number of ways.
# 
# If the answer is not found in our range [0, n), then we increase the range and search
# again. If we multiply n by some factor (say 2 or 10), then the geometric series ensures
# that the total work we do is O(n) with respect to the magnitude of the final answer.
# Examines all integers in the range [0, limit), and returns the sum of the lowest
# TARGET_COUNT integers each with the property that it is a palidrome in base 10
# and it can be expressed in exactly TARGET_COUNT ways as a sum of a perfect square
# greater than 1 and a perfect cube greater than 1. If fewer than TARGET_COUNT integers
# in [0, limit) have the desired property, then None is returned. Note that if
# trySearch(n) == k != None, then for every m > n, trySearch(m) == k also holds.
# If i can be expressed as the sum of a square greater than 1 and
# a cube greater than 1, then ways[i] is the number of different ways
# it can be done. Otherwise, i is not a key in the ways dictionary.
# 
# Solution to Project Euler problem 357
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# From the problem statement, we are given the search range of 1 <= n <= 10^8.
# For a given integer n, we know that every divisor d of n is in the range [1, n].
# 
# It is beneficial to precompute a table of primes in this application, but what is
# the maximum value of f(d) = d + n/d for an arbitrary divisor d for 1 <= n <= 10^8?
# Clearly both d and n/d are in the range [1, n], so an upper bound is 2n.
# 
# We can do better; in fact the maximum value of f(d) is n + 1, achieved at the endpoints d = {1, n}.
# The interior values of d yield a smaller value of f(d) because the derivative f'(d) = 1 - n/d^2
# is negative on the interval (1, sqrt(d)) and positive on the interval (sqrt(d), n). Hence on
# the domain [1, n], the function f(d) has a minimum at d = sqrt(n) which is 2*sqrt(n).
# 
# As a sanity check, will 2*sqrt(n) ever be greater than n + 1?
#   (n - 1)^2 >= 0      (because it's a square) (true for all n in reals)
#   n^2 - 2n + 1 >= 0   (expand the multiplication)
#   n^2 + 2n + 1 >= 4n  (add 4n to both sides)
#   (n + 1)^2 >= 4n     (factor)
#   n + 1 >= 2*sqrt(n)  (take square root on both sides, valid for n >= 0)
# Therefore for n >= 1, it is true that for all d in [1, n], we have f(d) <= n + 1.
# 
# Thus we go ahead and precompute a table of primeness for the domain [1, 10^8 + 1],
# and it will be valid for f(d) = d + n/d for any n and d in the appropriate ranges.
# 
# Now we discuss how to test whether an integer n is "prime-generating" or not.
# Every integer n trivially has 1 as a factor. As an optimization, we test whether
# f(1) = 1 + n/1 = 1 + n is prime or not. If it isn't prime then we skip this n.
# If it is prime, then we only need to examine all of n's factors in the range (1, sqrt(n)].
# This is because every factor in the remaining upper range of (sqrt(n), n] can be computed by
# n/d for values of d in the lower range [1, sqrt(n)]. But in this problem, we don't even
# need to look at these complementary upper factors because f(d) has the same value as f(n/d).
# 
# Solution to Project Euler problem 381
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Note about the mathematical simplification:
# (p-5)! + (p-4)! + (p-3)! + (p-2)! + (p-1)!
# = (p-5)! * (1 + (p-4) + (p-4)(p-3) + (p-4)(p-3)(p-2) + (p-4)(p-3)(p-2)(p-1))
# = (p-5)! * (1 + (-4) + (-4)(-3) + (-4)(-3)(-2) + (-4)(-3)(-2)(-1))
# = (p-5)! * (1 + -4 + 12 + -24 + 24)
# = (p-5)! * 9
# = (p-1)! / ((p-1)(p-2)(p-3)(p-4)) * 9
# = (p-1)! / ((-1)(-2)(-3)(-4)) * 9
# = (p-1)! / 24 * 9
# = (p-1)! * (3 * 3) / (3 * 8)
# = (p-1)! * 3 / 8
# = -1 * 3 / 8  (by Wilson's theorem)
# = -3/8 mod p.
# Every part of the equation is modulo a prime p > 4.
# 
# Solution to Project Euler problem 387
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Use a list container as a hack, because Python 2 does not support 'nonlocal' variables
# Note: n must be a right-truncatable Harshad number, and the other arguments are properties of the number n.
# Shift left by 1 digit, and try all 10 possibilities for the rightmost digit
# All one-digit numbers are trivially Harshad numbers
# 
# Solution to Project Euler problem 401
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Consider the set of all integers from 1 to n, inclusive: {1, 2, ..., n}.
# Now form the set of divisors for each number:
#   1: {1}
#   2: {1, 2}
#   3: {1, 3}
#   4: {1, 2, 4}
#   5: {1, 5}
#   6: {1, 2, 3, 6}
#   et cetera until n.
# Next consider the multiset union of all these sets of divisors.
# 
# We know that for a given integer k > 0, it occurs as a divisor in this multiset
# exactly floor(n / k) times (we call this the "count"), which are namely the multiples of k.
# So instead of considering each integer and summing its squared divisors, we can consider
# each divisor from 1 to n and compute how much it contributes to the final sum, namely floor(n / k) * k^2.
# 
# A further observation is that when k is large, the count factor of floor(n / k) does not change often.
# (For example, for k from floor(n/2)+1 to n, this count is always 1.)
# So we can calculate the squared divisor sum for many numbers at a time.
# This is helpful for k > sqrt(n), and we can bring the run time from O(n) down to O(sqrt(n)).
# 
# For a given count of m = floor(n / k), which integer values of k yield this m?
# By the definition of floor, m <= n/k, so mk <= n, and k <= n/m, thus k <= floor(n/m).
# Also by definition, m > n/k - 1, so mk > n - k, and k(m + 1) > n, and k > n/(m+1), so k > floor(n/(m+1)).
# Together, we have: floor(n / (m + 1)) < k <= floor(n / m).
# 
# Useful fact: (sum k^2 for k=1 to n) = n(n + 1)(2n + 1) / 6.
# Can be any number from 1 to LIMIT, but somewhere near sqrt(LIMIT) is preferred
# Consider divisors individually up and including this number
# The sum (s+1)^2 + (s+2)^2 + ... + (e-1)^2 + e^2.
# 
# Solution to Project Euler problem 407
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# If a^2 = a mod n, then this is also true for any m that divides n.
# Let's focus on the moduli that are prime powers, p^k.
# 
# Claim: The only solutions of a^2 = a mod p^k are a = 0, 1 mod p^k.
# Proof:
#   First note that a = 0 mod p^k is always a solution. Now consider the case of 0 < a < p^k.
#   Let a = b * p^j, where 0 < b < p^j and b is coprime with p (thus j is as large as possible).
#   Then (b p^j)^2 = b p^j mod p^k, expanding to b^2 p^2j = b p^j mod p^k.
#   Divide all of the equation (including the modulus) by p^j, giving b^2 p^j = b mod p^(k-j).
#   b is coprime with p (and therefore p^(k-j)), so b^-1 exists.
#   Multiply both sides by b^-2 to get b^-1 = p^j mod p^(k-j).
#   b is coprime with p, so b is not a power of p unless j = 0, i.e. p^j = 1 = b.
#   So when a != 0, a = 1 is the only solution.
# 
# If we factor n as a product of prime powers, i.e. n = p0^k0 * p1^k1 * ... where
# all the p's are distinct (and thus all the k's are as large as possible), then we have
# a system of congruences {a = 0,1 mod p0^k0; a = 0,1 mod p1^k1; ...}.
# Using the Chinese remainder theorem, we can solve these congruences to obtain the
# 2^N distinct solutions (where N is the number of distinct prime factors of n).
# The largest solution among these is what we want for the M() function.
# Compute factorization as coprime prime powers. e.g. 360 = {2^3, 3^2, 5^1}
# Use Chinese remainder theorem; cache parts of it
# 
# Solution to Project Euler problem 425
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Finding all the relatives of 2 can be seen as a single-source shortest path problem,
# which we solve here using Dijkstra's algorithm. The key insight is that at each node (prime number),
# we consider the connection path from 2 to it, and store the maximum path number at the node.
# It is amenable to dynamic programming because it's always best to minimize the maximum path number.
# 
# For example, 2 is connected to 103 because 2 <-> 3 <-> 13 <-> 113 <-> 103.
# The maximum number along this path is 113, and among all paths
# this is the minimum possible maximum, so 103 is not a relative of 2.
# pathmax[i] = None if i is not prime or i is not connected to 2.
# Otherwise, considering all connection paths from 2 to i and for each path computing
# the maximum number, pathmax[i] is the minimum number among all these maxima.
# Process paths in increasing order of maximum number
# This happens if at the time this update was queued, a better
# or equally good update was queued ahead but not processed yet
# Update the target node and explore neighbors
# Try all replacements of a single digit, including the leading zero.
# This generates exactly all (no more, no less) the ways that a number m is connected to n.
# For each digit position
# For each digit value
# Restore the digit
# Returns the given non-negative integer as an array of digits, in big endian, with an extra leading zero.
# e.g. 0 -> [0,0]; 1 -> [0,1]; 8 -> [0,8]; 42 -> [0,4,2]; 596 -> [0,5,9,6].
# Extract base-10 digits in little endian
# 
# Solution to Project Euler problem 429
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Let n be an arbitrary positive integer. Suppose n is factorized as p1^k1 * p2^k2 * ... * {p_m}^{k_m},
# where the p's are prime and distinct (thus the k's are as large as possible).
# Let {p1^k1, p2^k2, ..., {p_m}^{k_m}} be the set of "maximal prime powers".
# Then all the unitary divisors of n are exactly all the subsets of maximal prime powers,
# where each subset is viewed as a product of its elements.
# 
# For n!, its prime factorization uses and only uses all prime numbers from 1 to n (inclusive).
# For each prime p, the number n! has exactly floor(n/p) + floor(n/p^2) + floor(n/p^3) + ... factors of p.
# Thus we can calculate the p's and k's quite easily.
# 
# To solve the remaining parts of the problem, we use dynamic programming.
# Suppose we have found all the unitary divisors that are products of maximal prime powers less than {p_i}^{k_i},
# and suppose this set is {a, b, c}. Then when we include {p_i}^{k_i} into consideration, we double the size of the set
# because now {a * {p_i}^{k_i}, b * {p_i}^{k_i}, c * {p_i}^{k_i}} are also unitary divisors.
# Returns the number of factors of p (prime) in factorial(n).
# 
# Solution to Project Euler problem 451
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Let n be an arbitrary integer such that n >= 3.
# When we say that the modular inverse of m modulo n equals m itself,
# the formula is m^-1 = m mod n, which is equivalent to m^2 = 1 mod n.
# 
# We know that if n is prime, then m^2 = 1 mod n has exactly two solutions:
# m = 1, n-1. It is easy to verify that these two numbers are solutions.
# The equation factorizes as (m - 1)(m + 1) = 0 mod n. Because n is prime,
# the numbers form a field, and there are no zero divisors (two arbitrary
# non-zero numbers x and y such that xy = 0). Hence 1 and -1 mod n are
# the only possible solutions to the equation. (Note that for the excluded
# special prime case where n = 2, the solutions 1 and -1 are the same number.)
# 
# Suppose we can find the smallest prime factor of n quickly. (Note that if n is
# prime, then the smallest prime factor is n itself.) This can be achieved by
# building a table ahead of time, using a modification of the sieve of Eratosthenes.
# 
# Suppose that for every n' < n, we know the set of solutions to m^2 = 1 mod n'.
# This means whenever we solve the equation for the number n, we save its solutions
# in an ever-growing list, so that when we work on the next value of n we can access
# all possible smaller solutions. This is essentially an argument by strong induction.
# 
# Let p be the smallest prime factor of n. If p = n, then the set of
# solutions is {1, n - 1}, and we are finished with this value of n.
# 
# Otherwise p < n, and obviously n is an integer multiple of p. Because we are looking
# for values of m such that m^2 = 1 mod n, these candidate m values also must satisfy
# m^2 = 1 mod k for any k that divides n (i.e. k is a factor of n). We look at the set
# of solutions for the modulus k = n/p, which has already been solved because k < n.
# We know that any solution modulo n must be congruent to these solutions modulo k.
# Hence we can try to extend and check these old solutions by brute force. Namely, suppose
# m' is a solution modulo k. Then we check the sequence m = m' + 0k, m' + 1k, m' + 2k, ...,
# m' + (p-1)k modulo n. Because p is usually a small number, this isn't a lot of work to do.
# Build table of smallest prime factors
# Returns all the solutions (in ascending order) such that
# for each k, 1 <= k < n and k^2 = 1 mod n.
# n is prime
# Process every integer in range
# Second-largest solution
# 
# Solution to Project Euler problem 493
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# 
# Solution to Project Euler problem 500
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Fact: When a number is factorized as a product of powers of unique primes, the number of factors
# the number has is equal to the product of {each exponent plus one}. That is, if n = p_1^k_1 *
# p_2^k_2 * ... * p_m^k_m, then n has exactly (k_1 + 1) * (k_2 + 1) * ... * (k_m + 1) factors.
# 
# Define any natural number n to be a "candidate" iff it has exactly 2^500500 factors (including 1 and n).
# 
# First examine n = 2^1 * 3^1 * 5^1 * 7^1 * ... * 7376497^1 * 7376507^1, which is the product of
# the first 500500 prime numbers. n has (1+1) * (1+1) * ... * (1+1) = 2 * 2 * ... * 2 = 2^500500
# factors, as desired. This candidate n is thus an upper bound on the answer we're looking for.
# 
# But if we drop the last prime and increase the exponent of the prime 2, then we
# can get a smaller candidate of n' = 2^3 * 3^1 * 5^1 * ... * 7376497^1. It has
# (3+1) * (1+1) * ... * (1+1) = 2^500500 factors, which makes it still valid.
# This means when we construct a candidate, we need to choose between including
# new prime factors versus increasing the exponent of an existing prime.
# 
# Let us illustrate the problem for small cases (checkable by brute force):
# - What is the smallest number with exactly 2^0 =  1 factor ? Clearly 1.
# - What is the smallest number with exactly 2^1 =  2 factors? It is 2.
# - What is the smallest number with exactly 2^2 =  4 factors? It is 2 * 3 = 6.
# - What is the smallest number with exactly 2^3 =  8 factors? It is 2^3 * 3 = 24.
# - What is the smallest number with exactly 2^4 = 16 factors? It is 2^3 * 3 * 5 = 120.
# 
# We observe that at each step (except the zeroth), the answer is equal to the
# previous answer times some number (unjustified claim). Some observations can be made:
# - We can multiply a number by an unused prime number to double its number of factors.
#   For example, 120 has 16 factors, and its highest prime factor is 5;
#   if we look at 120 * 7 = 840, then it has 16 * 2 = 32 factors.
# - It never pays to multiply by a larger prime than necessary (unjustified greedy claim).
#   For example, 120 * 11 = 1320 also has 16 * 2 = 32 factors, but 840 is a smaller choice.
#   Because we have an upper bound for the answer, we know we never need to use a prime larger than 7376507.
# - Instead of multiplying a new prime, we can increase the exponent of an existing prime.
#   For example, the prime power p^1 entails a factor of 1+1 = 2^1 in the number of factors of n;
#   the prime power p^3 entails a factor of 3+1 = 2^2 in the number of factors of n;
#   the prime power p^7 entails a factor of 7+1 = 2^3 in the number of factors of n;
#   the prime power p^15 entails a factor of 15+1 = 2^4 in the number of factors of n.
#   So when n does not contain the prime p, we multiply it by p^1 to double the number of factors of n.
#   Later on, we might multiply n by p^2, p^4, p^8, etc. to double the number of factors of n.
# 
# The solution algorithm works like this:
# 0. With respect to the answer product (which starts at 1), we always keep track of the
#    next power of each prime already used in the answer, as well as next unused prime.
#    For example, if the current answer is 2^7 * 3^3 * 5 * 7 * 11 * 13, then the set of next
#    powers is {2^8, 3^4, 5^2, 11^2, 13^2}, and the next prime is 17. We can
#    actually fuse the latter number into the former set, by denoting it as 17^1.
# 1. (Loop invariant) At the beginning of iteration i (0-based counting) of the main loop, the
#    current answer is the smallest number (modulo the modulus) that has exactly 2^i factors.
# 2. From the set of next powers/prime, remove the smallest item (a priority queue is needed), e.g. 17^1.
# 3. Multiply the current answer by the item, and reduce the answer by the modulus.
# 4. Put the square of the item back into the priority queue.
# 5. If the item is equal to the next unused prime, then increment
#    the next unused prime and put it into the priority queue.
# 500500th (1-based) prime number
# 
# Solution to Project Euler problem 518
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https:#www.nayuki.io/page/project-euler-solutions
# https:#github.com/nayuki/Project-Euler-solutions
# 
# Suppose (a+1, b+1, c+1) are three positive integers that form a geometric sequence.
# Then by definition, (c+1)/(b+1) = (b+1)/(a+1) = r for some ratio r.
# r is a rational number because we are given that a, b, c are integers.
# 
# Because of this, we can express r = z / y in lowest terms (i.e. y and z are coprime).
# Note that since the solution requires a < b < c, we require r > 1, hence z > y > 0.
# 
# Let's define x = (a+1) / y^2. Then we rearrange to get a + 1 = x * y * y.
# We argue that x is an integer. Look at (c+1)/(a+1) = z^2/y^2. y^2 and z^2 are coprime,
# thus the simplified denominator y^2 must divide the original denominator of a+1.
# 
# With {x, y, z} defined, we have b + 1 = x * y * z and c + 1 = x * z * z.
# Therefore every possible solution (a+1, b+1, c+1) can be re-expressed as
# a triple of integers (x, y, z) such that x >= 1, y >= 1, z > y, and gcd(y,z) = 1.
# In fact, this mapping of (a+1, b+1, c+1) to (x, y, z) is unique - this is because
# the ratio (b+1)/(a+1) uniquely determines y and z; subsequently a and y together give x.
# 
# The rest of the algorithm is a matter of searching x, y, z in some ascending order, and stopping
# each loop when no more candidates are possible because they all necessarily exceed the limit.
# Search all possible x's. We know that c = x * z * z - 1. With the requirement c < LIMIT, we have x * z * z <= LIMIT.
# Because z > y > 0, we know z >= 2. So at the very least we require x * 4 <= LIMIT. This implies x <= floor(LIMIT/4).
# Search all possible y's. Notice that when y increases, 'a' strictly increases.
# So when some y generates an 'a' such that a >= LIMIT, no candidates are possible with higher values of y.
# Search all valid z's. We require z > y and gcd(y, z) = 1. Notice that when z increases, c strictly increases.
# So when some z generates a c such that c >= LIMIT, no candidates are possible with higher values of z.
# Check whether (a, b, c) is a solution
# 
# Solution to Project Euler problem 549
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# For any n >= 2, how do we compute s(n) = m, where m is the smallest integer such that m! is divisible by n?
# Two important simple observations:
# - n! is clearly divisible by n. So 2 <= s(n) <= n.
# - If n divides m!, then n also divides (m+1)!, (m+2)!, etc. (i.e. all factorials after m).
#   Thus a possible strategy is to find lower bounds for m, and refine our way up to the real answer.
# We begin by factorizing n as a product of powers of unique prime numbers: n = p_0^k_0 * p_1^k^1 * ... .
# 
# Now for each index i in this product, look at the prime power p_i^k_i.
# There is some smallest j such that j! is divisible by p_i^k_i.
# We argue this j must be a multiple of p_i. This is because if j is not a multiple of p_i,
# then the factorization of (j-1)! contains exactly as many copies of the factor p_i as j!.
# Or to look at it another way, as j increases, the value j! gains new copies of the factor p_i
# every time j's factorization contains p_i. (For example if we are interested in p = 2, then
# 2 = 2 (has 1 copy of 2), 4 = 2 * 2 (has 2 copies), 6 = 2 * 3 (has 1 copy), 8 = 2 * 2 * 2 (has 3 copies).)
# 
# For each index i in the prime factorization, we compute the smallest j such that p_i^k_i divides j!.
# We argue that the maximum among all these j's is the answer m = s(n).
# By construction, every p_i^k_i divides this m! and m! > 0. Because all these p_i^k_i's are pairwise coprime,
# by the Chinese remainder theorem, {the product of all these p_i^k_i's} also divides m!.
# 
# One consequence is that if n contains a big prime factor p, then m must be at least p.
# This is because otherwise if m < p, then m! will not contain a factor of p.
# For example if n = 245262 = 2 * 3 * 41 * 997, then s(n) >= 997. In fact s(n) = 997.
# 
# With this derivation in hand, we can work backwards, starting from primes
# and figuring out the smallest divisible factorial for each number.
# 
# Let's look at p = 2, the smallest prime number. Every number that is a multiple of 2 (including 2 itself)
# will be affected by how many copies of 2 are in the factorization of some factorial.
# - First we look at j = p = 2. The factorization of j! = 2! has 1 copy of 2. So we know that every number
#   whose factorization has at least 1 copy of 2 will have a smallest-divisible-factorial of at least j = 2.
#   We update all numbers that are multiples of 2.
# - Next we look at j = 2p = 4. The factorization of j! = 4! has 3 copies of 2. So we know that every number
#   whose factorization has at least 2 copies of 2 will have a smallest-divisible-factorial of at least j = 4.
#   We update all numbers that are multiples of 2^2 = 4.
# - Next we look at j = 3p = 6. The factorization of j! = 6! has 4 copies of 2. So we know that every number
#   whose factorization has at least 4 copies of 2 will have a smallest-divisible-factorial of at least j = 6.
#   We update all numbers that are multiples of 2^4 = 16.
# We keep increasing j until p^j exceeds the limit, in which case there are no more numbers to update.
# Note that in this process, we update all numbers that are multiples of 2, but no numbers that are not multiples of 2.
# Because of this, the next lowest number that has never been updated (i.e. 3) must be a prime number,
# and this process is effectively a modified version of the sieve of Eratosthenes. In other words, we can
# use a single array to both sieve prime numbers and compute the smallest-divisible-factorial simultaneously.
# Modification of the sieve of Eratosthenes
# Now we know that i is prime
# We know j contains at least one factor of i
# Update answer for all multiples of 'power'
# Update power to include the remaining factors of i in j
# 
# Solution to Project Euler problem 587
# Copyright (c) Project Nayuki. All rights reserved.
# 
# https://www.nayuki.io/page/project-euler-solutions
# https://github.com/nayuki/Project-Euler-solutions
# 
# Start by defining the coordinate system in a convenient way. The position and scale of the diagram don't
# matter because we only care about the ratio of areas, not the absolute areas. So, let the bottom left
# of the diagram be the origin (x = 0, y = 0), and let each circle to have a radius of 1.
# 
# The leftmost circle is centered at (1, 1), and its equation is (x - 1)^2 + (y - 1)^2 = 1.
# The diagonal line has slope = s = 1 / n (for any positive n), and the line's equation is y = s * x.
# From basic geometry, the area of the blue L-section is 1 - pi / 4.
# 
# Let's find the x-coordinate where the diagonal line intersects the first circle.
# Take the equation of the circle and substitute y = s * x for the line:
# 
#   (x - 1)^2 + (s*x - 1)^2 = 1.
#   (x^2 - 2x + 1) + (s^2 x^2 - 2s*x + 1) = 1.
#   (1 + s^2)x^2 + (-2 - 2s)x + 1 = 0.
# 
# We can apply the quadratic formula with a = 1 + s^2, b = -2 - 2s, c = 1. There are two solutions for x,
# and we only want the smaller value. Thus, let X = (-b - sqrt(b^2 - 4ac)) / (2a). Or equivalently
# with more numerical stability (using the Citardauq formula), X = (2c) / (-b + sqrt(b^2 - 4ac)).
# 
# The orange concave triangle can be divided into two parts by a vertical line:
# 
# - The left part is a proper triangle, whose area is easily seen as x * y / 2 = X^2 * s / 2.
# 
# - The right part is the region between the circle and the baseline. Let's re-express
#   the circle's equation in terms of y, and only keep the lower semicircle:
#   
#     (x - 1)^2 + (y - 1)^2 = 1.
#     (y - 1)^2 = 1 - (x - 1)^2.
#     y - 1 = -sqrt(1 - (x - 1)^2).
#     y = 1 - sqrt(1 - (x - 1)^2).
#     y = 1 - sqrt(1 - (x^2 - 2x + 1)).
#     y = 1 - sqrt(2x - x^2).
#   
#   Now, the indefinite integral of f(x) = 1 - sqrt(2x - x^2) with respect to x
#   is F(x) = (x - 1) - [sqrt(2x - x^2) * (x - 1) + asin(x - 1)] / 2.
#   Finding this integral is not obvious, but verifying it is a fairly straightforward
#   mechanical procedure involving differentiation and simplification.
#   
#   The area of the right part is the integral of f(x) for x from X to 1, because the start is
#   the x-coordinate where line meets the circle, and the end is where the circle meets the baseline.
#   Hence the area is equal to F(1) - F(X).
# 
# All in all, for any given n, the area of the orange concave triangle is X^2 * s / 2 + F(1) - F(X).
# The rest of the algorithm is a brute-force search with n = 1, 2, 3, ... until the ratio condition is met.
# 
# Additional notes:
# - Intuitively, as n increases and the slope gets smaller, the area of the orange concave triangle should strictly
#   decrease. This statement is in fact true, but proving it involves a big pile of differentiation and algebra.
#   0. We need to show that X (which is the x-coordinate of the line-circle intersection) increases with n.
#      We'd differentiate X with respect to n, and get an expression that is always positive for any positive n.
#   1. Because X increases with n, the area of the right part, with its always-positive integrand, must decrease.
#   2. As for the left part, we'd differentiate X^2 * s / 2 with respect to n, and get a huge messy formula.
#      It turns out this formula is negative for all n > 1. Hence the area of this triangle also decreases with n.
#   After we prove that increasing n leads to decreasing orange area, we could use
#   binary search to find the minimum value of n needed to meet the ratio requirement.
# - The use of floating-point arithmetic, for basic arithmetic operations (+ - * /) and irrational functions (sqrt,
#   asin) alike, is inherently difficult or impossible to prove the correctness of. Furthermore, the algorithms
#   for irrational functions are hard to understand and beyond the scope of this problem, and the error bounds for
#   all operations are difficult to reason about.
#   It should be possible to solve this particular problem using only integer arithmetic in a provably correct way.
#   The basic idea would be to round the result of each operation both down and up to an integer fraction,
#   keep track of pessimistic intervals that are guaranteed to contain the true value, accept a comparison only
#   if the intervals don't overlap, and recompute everything at a higher precision if a comparison is inconclusive.
#   Note: Because it doesn't seem easy to compute pi and asin(), it might be better to
#   approximate integrals directly using the Darboux definition of lower and upper sums.
# The indefinite integral of (1 - sqrt(2x - x^2)) dx.
