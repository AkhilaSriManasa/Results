// First: get the dataset using the record reader. CSVRecordReader handles
// loading/parsing
// Second: the RecordReaderDataSetIterator handles conversion to DataSet
// objects, ready for use in neural network
// 5 values in each row of the iris.txt CSV: 4 input features followed by an
// integer label (class) index. Labels are the 5th value (index 4) in each row
// 3 classes (types of iris flowers) in the iris data set. Classes have integer
// values 0, 1 or 2
// Iris data set: 150 examples total. We are loading all of them into one
// DataSet (not recommended for large data sets)
// Use 65% of data for training
// We need to normalize our data. We'll use NormalizeStandardize (which gives us
// mean 0, unit variance):
// Collect the statistics (mean/stdev) from the training data. This does not
// modify the input data
// Apply normalization to the training data
// Apply normalization to the test data. This is using statistics calculated
// from the *training* set
// run the model
// evaluate the model on the test set
// Save the model
// Where to save
// the network.
// Note: the file
// is in .zip
// format - can
// be opened
// externally
// Updater: i.e., the state for Momentum, RMSProp, Adagrad etc. Save this if you
// want to train your network more in the future
// ModelSerializer.writeModel(model, locationToSave, saveUpdater);
// Load the model
/**
//Save the model
//Where to save the network. Note: the file is in .zip format - can be opened externally
//Load the model
// Inference
/** This is helper class to workaround for Failing stream tests in Windows environment KAFKA-6647.
//issues.apache.org/jira/browse/KAFKA-6647
/** This is helper class to workaround for Failing stream tests in Windows environment KAFKA-6647.
//issues.apache.org/jira/browse/KAFKA-6647
/**
// Generated DL4J model
// Prediction Value
// Iris input data (the model returns probabilities for input being each of Iris
// Type 1, 2 and 3)
// Step 1: Configure and start the processor topology.
// The commit interval for flushing records to state stores and
// downstream must be lower than
// this integration test's timeout (30 secs) to ensure we observe the
// expected processing results.
// Use a temporary directory for storing state, which will be
// automatically removed after the test.
// Create DL4J object (see DeepLearning4J_CSV_Model.java)
// Configure Kafka Streams Application
// Specify default (de)serializers for record keys and for record
// values.
// In the subsequent lines we define the processing topology of the
// Streams application.
// Construct a `KStream` from the input topic "IrisInputTopic", where
// message values
// represent lines of text (for the sake of this example, we ignore
// whatever may be stored
// in the message keys).
// Stream Processor (in this case 'foreach' to add custom logic, i.e. apply the
// analytic model)
// TODO Easier way to map from String[] to double[] !!!
// Inference
// Transform message: Add prediction information
// Send prediction information to Output Topic
// Start Kafka Streams Application to process new incoming messages from
// Input Topic
//
// Step 2: Produce some input data to the input topic.
//
//
// Step 3: Verify the application's output data.
//
/**
// Start Kafka Streams Application to process new incoming messages from Input
// Topic
// Add shutdown hook to respond to SIGTERM and gracefully close Kafka
// Streams
// Give the Streams application a unique name. The name must be unique
// in the Kafka cluster
// against which the application is run.
// Where to find Kafka broker(s).
// Specify default (de)serializers for record keys and for record
// values.
// For illustrative purposes we disable record caches
// Create H2O object (see gbm_pojo_test.java)
// In the subsequent lines we define the processing topology of the
// Streams application.
// Construct a `KStream` from the input topic "AirlineInputTopic", where
// message values
// represent lines of text (for the sake of this example, we ignore
// whatever may be stored
// in the message keys).
// Stream Processor (in this case 'mapValues' to add custom logic, i.e. apply
// the analytic model)
// Year,Month,DayofMonth,DayOfWeek,DepTime,CRSDepTime,ArrTime,CRSArrTime,UniqueCarrier,FlightNum,TailNum,ActualElapsedTime,CRSElapsedTime,AirTime,ArrDelay,DepDelay,Origin,Dest,Distance,TaxiIn,TaxiOut,Cancelled,CancellationCode,Diverted,CarrierDelay,WeatherDelay,NASDelay,SecurityDelay,LateAircraftDelay,IsArrDelayed,IsDepDelayed
// value:
// YES, probably delayed:
// 1987,10,14,3,741,730,912,849,PS,1451,NA,91,79,NA,23,11,SAN,SFO,447,NA,NA,0,NA,0,NA,NA,NA,NA,NA,YES,YES
// NO, probably not delayed:
// 1999,10,14,3,741,730,912,849,PS,1451,NA,91,79,NA,23,11,SAN,SFO,447,NA,NA,0,NA,0,NA,NA,NA,NA,NA,YES,YES
//No prediction
// Send prediction information to Output Topic
/**
// Name of the generated H2O model
// Configure Kafka Streams Application
/**
// Name of the generated H2O model
// Configure Kafka Streams Application
/*
//www.apache.org/licenses/LICENSE-2.0.html
//192.168.178.23:54321/3/h2o-genmodel.jar > h2o-genmodel.jar
//192.168.178.23:54321/3/Models.java/deeplearning-fe7c1f02-08ec-4070-b784-c2531147e451 > deeplearning_fe7c1f02_08ec_4070_b784_c2531147e451.java
// Thread-local storage for input neuron activation values.
// Workspace for storing categorical input variables.
// Workspace for categorical offsets.
// Number of neurons for each layer.
// Thread-local storage for neuron activation values.
/* Input */ new double[278],
/* Rectifier */ new double[200],
/* Rectifier */ new double[200],
/* Softmax */ new double[2]
// Neuron bias values.
/* Input */ deeplearning_fe7c1f02_08ec_4070_b784_c2531147e451_Bias_0.VALUES,
/* Rectifier */ deeplearning_fe7c1f02_08ec_4070_b784_c2531147e451_Bias_1.VALUES,
/* Rectifier */ deeplearning_fe7c1f02_08ec_4070_b784_c2531147e451_Bias_2.VALUES,
/* Softmax */ deeplearning_fe7c1f02_08ec_4070_b784_c2531147e451_Bias_3.VALUES
// Connecting weights between neurons.
/* Input */ deeplearning_fe7c1f02_08ec_4070_b784_c2531147e451_Weight_0.VALUES,
/* Rectifier */ deeplearning_fe7c1f02_08ec_4070_b784_c2531147e451_Weight_1.VALUES,
/* Rectifier */ deeplearning_fe7c1f02_08ec_4070_b784_c2531147e451_Weight_2.VALUES,
/* Softmax */ deeplearning_fe7c1f02_08ec_4070_b784_c2531147e451_Weight_3.VALUES
// Names of columns used by model.
// Number of output classes included in training data response column.
// Column domains. The last array contains domain of response column.
/* Dest */ deeplearning_fe7c1f02_08ec_4070_b784_c2531147e451_ColInfo_0.VALUES,
/* Origin */ deeplearning_fe7c1f02_08ec_4070_b784_c2531147e451_ColInfo_1.VALUES,
/* Year */ null,
/* Month */ null,
/* DayofMonth */ null,
/* DayOfWeek */ null,
/* CRSDepTime */ null,
/* CRSArrTime */ null,
/* FlightNum */ null,
/* Distance */ null,
/* TaxiIn */ null,
/* TaxiOut */ null,
/* IsArrDelayed */ deeplearning_fe7c1f02_08ec_4070_b784_c2531147e451_ColInfo_12.VALUES
// Prior class distribution
// Class distribution used for model building
// Pass in data in a double[], pre-aligned to the Model's requirements.
// Jam predictions into the preds[] array; preds[0] is reserved for the
// main prediction (class for classifiers or value for regression),
// and remaining columns hold a probability distribution for classifiers.
// Neuron bias values for Input layer
// Neuron bias values for Rectifier layer
// Neuron bias values for Rectifier layer
// Neuron bias values for Softmax layer
// Neuron weights connecting Input and Rectifier layer
// Neuron weights connecting Rectifier and Rectifier layer
// Neuron weights connecting Rectifier and Softmax layer
// The class representing training column names
// The class representing column Dest
// The class representing column Origin
// The class representing column IsArrDelayed
/**
//github.com/h2oai/h2o-2/wiki/Hacking-Airline-DataSet-with-H2O
// Names of columns used by model.
// Number of output classes included in training data response column.
// Column domains. The last array contains domain of response column.
/* Year */ null,
/* Month */ null,
/* DayofMonth */ null,
/* DayOfWeek */ null,
/* CRSDepTime */ null,
/* CRSArrTime */ null,
/* UniqueCarrier */ gbm_pojo_test_ColInfo_6.VALUES,
/* FlightNum */ null,
/* CRSElapsedTime */ null,
/* Origin */ gbm_pojo_test_ColInfo_9.VALUES,
/* Dest */ gbm_pojo_test_ColInfo_10.VALUES,
/* IsDepDelayed */ gbm_pojo_test_ColInfo_11.VALUES
// Prior class distribution
// Class distribution used for model building
// Pass in data in a double[], pre-aligned to the Model's requirements.
// Jam predictions into the preds[] array; preds[0] is reserved for the
// main prediction (class for classifiers or value for regression),
// and remaining columns hold a probability distribution for classifiers.
//The class representing training column names
//The class representing column UniqueCarrier
//The class representing column Origin
//The class representing column Dest
//The class representing column IsDepDelayed
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT0, 132, 0, data[9])) ? 
/* DayofMonth */] <5.5f ? 
/* Year */] <2007.5f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(131, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT1, 131, 0, data[9])) ? 
/* CRSArrTime */] <1214.5f ? 
/* CRSArrTime */] <1325.5f ? 
/* CRSArrTime */] <1104.5f ? 
/* Dest */]) || !GenModel.bitSetIsInRange(132, 1, data[10]) || (GenModel.bitSetIsInRange(132, 1, data[10]) && !GenModel.bitSetContains(GRPSPLIT2, 132, 1, data[10])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(66, 51, data[9]) && !GenModel.bitSetContains(GRPSPLIT3, 66, 51, data[9])) ? 
/* Year */] <1998.0f ? 
/* Origin */]) || !GenModel.bitSetIsInRange(131, 0, data[9]) || (GenModel.bitSetIsInRange(131, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT4, 131, 0, data[9])) ? 
/* Dest */]) || !GenModel.bitSetIsInRange(134, 0, data[10]) || (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT5, 134, 0, data[10])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT6, 134, 0, data[10])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT7, 134, 0, data[10])) ? 
/* Origin */]) || !GenModel.bitSetIsInRange(131, 0, data[9]) || (GenModel.bitSetIsInRange(131, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT8, 131, 0, data[9])) ? 
/* CRSArrTime */] <1622.5f ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT9, 134, 0, data[10])) ? 
/* DayofMonth */] <7.5f ? 
/* CRSDepTime */] <917.5f ? 
/* Origin */]) || !GenModel.bitSetIsInRange(124, 3, data[9]) || (GenModel.bitSetIsInRange(124, 3, data[9]) && !GenModel.bitSetContains(GRPSPLIT10, 124, 3, data[9])) ? 
/* Origin */]) || !GenModel.bitSetIsInRange(124, 3, data[9]) || (GenModel.bitSetIsInRange(124, 3, data[9]) && !GenModel.bitSetContains(GRPSPLIT11, 124, 3, data[9])) ? 
/* Year */] <1997.5f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(124, 3, data[9]) && !GenModel.bitSetContains(GRPSPLIT12, 124, 3, data[9])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(124, 3, data[9]) && !GenModel.bitSetContains(GRPSPLIT13, 124, 3, data[9])) ? 
/* DayofMonth */] <7.5f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(129, 3, data[9]) && !GenModel.bitSetContains(GRPSPLIT14, 129, 3, data[9])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(132, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT15, 132, 0, data[10])) ? 
/* Origin */]) || !GenModel.bitSetIsInRange(129, 3, data[9]) || (GenModel.bitSetIsInRange(129, 3, data[9]) && !GenModel.bitSetContains(GRPSPLIT16, 129, 3, data[9])) ? 
/* Year */] <1998.0f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(129, 3, data[9]) && !GenModel.bitSetContains(GRPSPLIT17, 129, 3, data[9])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(129, 3, data[9]) && !GenModel.bitSetContains(GRPSPLIT18, 129, 3, data[9])) ? 
// constant pool size = 456B, number of visited nodes = 31, static init size = 1980B
// {00011110 01100000 10010100 01000111 00100011 00100100 11000111 10000110 11011011 01010100 00000001 11111010 11100111 11010010 11010011 00111010 0001}
// {11000000 00000101 01000000 10000000 01011100 10010000 00000000 00000000 00000000 00001011 01100000 00000001 00011000 00000001 00101100 10000000 011}
// {...1 0-bits... 11111101 11110111 11011111 11111101 11111101 11111011 11110111 11111111 11001111 11101111 11111111 11111111 11101111 11101111 11111001 10011111 111}
// {...51 0-bits... 11111101 1111011}
// {10000000 00000001 01000010 10000000 11010000 10000000 00010000 00000000 00000000 00001000 00000000 00000001 00001000 00100100 00000100 00000000 000}
// {00000000 00000000 01000000 00000000 00000000 00100000 00000000 00000000 00001001 00000000 00000000 11000000 00010000 00000000 00000010 00100000 000010}
// {00000000 00000000 00011010 10000000 01000000 00100000 00101000 01000000 00000001 00100000 00000001 00000010 00001100 00100001 00000010 00000000 000000}
// {00010100 00100111 10010000 10000000 00000000 00100010 10000000 00001000 10010001 00000110 10001100 10000110 11011000 10000111 00000110 10110100 101000}
// {00000000 00010101 00100000 10001000 10000100 10000000 00000000 00000000 00000000 00000000 00000000 00000000 00001000 00000000 00100000 00000000 000}
// {11111101 10101101 00011111 10011001 00001101 10111011 10111101 00001011 01111111 11111101 00000011 11111011 10111110 10111111 11001111 01111100 111101}
// {...3 0-bits... 10000000 00000000 00000000 00010000 00000000 00000000 00000000 00000000 00011010 00000000 00000000 10000001 00000000 10000000 00000000 0}
// {...3 0-bits... 00010000 00000000 00000000 00000000 00000001 00000000 00000000 00110010 00001010 00000000 00000011 10000001 00011010 10000100 00000000 0}
// {...3 0-bits... 11111111 11111111 01111111 11011111 11111111 11111111 11111111 11011111 11111111 11111111 11111111 11101111 11011101 11111111 11111111 1}
// {...3 0-bits... 11111111 11111111 01111111 11110110 11111111 11111111 11101111 11101101 11101111 11011111 11111110 11111010 11111001 11111011 11110111 1}
// {...3 0-bits... 10111100 11111111 01111101 11000111 11111111 11111011 11111011 11111111 01111111 01111111 11111111 11111111 11011011 11101111 01101111 111111}
// {11110110 11111110 11111111 11111111 11111011 11111101 11111111 11111101 11101110 10110011 11111111 01011101 11111011 01011111 00110100 11011111 1100}
// {...3 0-bits... 00000000 00000000 00100000 00000000 00001000 00000000 00000000 00000000 01000010 00100000 00000000 00000000 00010000 00000000 00000000 110000}
// {...3 0-bits... 01111110 11111111 11111101 11111111 11111110 11111111 11110111 11011111 11111101 11111111 11111100 11111110 11111111 11101011 01101111 111011}
// {...3 0-bits... 00110000 00000100 10000000 00100001 00000001 00000010 00000000 00000000 00001000 00000000 00000010 10010000 00100110 00000000 10000001 010100}
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT0, 132, 0, data[9])) ? 
/* DayofMonth */] <5.5f ? 
/* Year */] <2007.5f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(131, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT1, 131, 0, data[9])) ? 
/* CRSDepTime */] <975.5f ? 
/* UniqueCarrier */]) && (GenModel.bitSetIsInRange(32, 0, data[6]) && !GenModel.bitSetContains(GRPSPLIT2, 32, 0, data[6])) ? 
/* CRSArrTime */] <1104.5f ? 
/* Dest */]) || !GenModel.bitSetIsInRange(132, 1, data[10]) || (GenModel.bitSetIsInRange(132, 1, data[10]) && !GenModel.bitSetContains(GRPSPLIT3, 132, 1, data[10])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(66, 51, data[9]) && !GenModel.bitSetContains(GRPSPLIT4, 66, 51, data[9])) ? 
/* Year */] <1998.0f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(131, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT5, 131, 0, data[9])) ? 
/* CRSArrTime */] <1274.5f ? 
/* CRSArrTime */] <1548.5f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(131, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT6, 131, 0, data[9])) ? 
/* CRSArrTime */] <1878.5f ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT7, 134, 0, data[10])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT8, 134, 0, data[10])) ? 
/* DayofMonth */] <7.5f ? 
/* CRSDepTime */] <918.5f ? 
/* Origin */]) || !GenModel.bitSetIsInRange(129, 3, data[9]) || (GenModel.bitSetIsInRange(129, 3, data[9]) && !GenModel.bitSetContains(GRPSPLIT9, 129, 3, data[9])) ? 
/* Origin */]) || !GenModel.bitSetIsInRange(129, 3, data[9]) || (GenModel.bitSetIsInRange(129, 3, data[9]) && !GenModel.bitSetContains(GRPSPLIT10, 129, 3, data[9])) ? 
/* Year */] <1997.5f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(129, 3, data[9]) && !GenModel.bitSetContains(GRPSPLIT11, 129, 3, data[9])) ? 
/* CRSArrTime */] <1441.5f ? 
/* DayofMonth */] <7.5f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(124, 3, data[9]) && !GenModel.bitSetContains(GRPSPLIT12, 124, 3, data[9])) ? 
/* CRSArrTime */] <1180.0f ? 
/* Origin */]) || !GenModel.bitSetIsInRange(124, 3, data[9]) || (GenModel.bitSetIsInRange(124, 3, data[9]) && !GenModel.bitSetContains(GRPSPLIT13, 124, 3, data[9])) ? 
/* Year */] <1998.0f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(124, 3, data[9]) && !GenModel.bitSetContains(GRPSPLIT14, 124, 3, data[9])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(124, 3, data[9]) && !GenModel.bitSetContains(GRPSPLIT15, 124, 3, data[9])) ? 
// constant pool size = 389B, number of visited nodes = 31, static init size = 1578B
// {00011110 01100000 10010100 01000111 00100111 00100100 11000111 10000110 11011011 01010100 00000001 11111010 11100111 11010010 11010011 00111010 0001}
// {11000000 00000101 01000001 10000000 01011000 10010000 00000000 00000000 00000000 00001011 01100000 00000001 00011000 00100001 00101100 10000000 011}
// {11001011 11000000 00000000 00000000}
// {...1 0-bits... 11111101 11110111 11011111 11111101 11111101 11111011 11110111 11111111 11001111 11101111 11111111 11101111 11101111 11101111 11111001 10011111 111}
// {...51 0-bits... 11111101 1111011}
// {10000000 00000001 01000011 10000000 11011000 10000010 00010000 00000000 00000000 10001000 00000000 00000001 00001000 00100100 00000100 10000000 010}
// {01000000 00000101 00000001 10001000 11010000 00000001 00000000 00100000 00000000 10000000 00000000 00000000 00001000 00000000 00001100 10000000 000}
// {01101101 01111111 10110111 10000111 11001011 11111011 11011111 10111011 11110110 11110111 10111101 11000111 11111101 10000011 01111110 11110101 111011}
// {11111101 10101101 00011111 10011011 00001101 10011010 10111101 00001011 01111111 11111101 00000011 11111001 10111110 10111111 01001111 01111100 001101}
// {...3 0-bits... 10000000 00000000 00000000 00010000 00000000 00000000 00000000 00000000 00011010 00000000 00000000 10000001 00000000 10000000 00000000 000000}
// {...3 0-bits... 00000000 00000000 00000000 00001000 00110001 00000000 00000000 00110000 00001010 00000000 00000011 10000011 00011110 10000100 00000000 010000}
// {...3 0-bits... 11111111 11111111 01111111 11011111 11111111 11111111 11110111 11011111 11110111 11111111 11111111 11101111 11011101 11111111 11111111 111011}
// {...3 0-bits... 10111100 11111111 01111101 11000111 11111111 11111011 11101011 11111111 01111111 01111111 11111110 11111111 11011011 11101011 01101111 1}
// {...3 0-bits... 00000000 00000000 00100000 00000000 00001000 00000000 00000000 00000000 01000010 00100000 00000000 00000000 00010000 00000000 00000000 1}
// {...3 0-bits... 01111110 11111111 11111101 11111111 11111110 11111111 11111111 11011111 11111101 11111111 11111100 11111110 11111011 11101011 01101111 1}
// {...3 0-bits... 00110000 00000100 10000000 00100000 00000001 00000010 00000000 00000000 00001000 00000000 00000010 10010000 00100100 00000000 10000001 0}
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT0, 132, 0, data[9])) ? 
/* Year */] <2006.5f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(131, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT1, 131, 0, data[9])) ? 
/* Year */] <1987.5f ? 
/* FlightNum */] <1535.5f ? 
/* Dest */]) && (GenModel.bitSetIsInRange(133, 1, data[10]) && !GenModel.bitSetContains(GRPSPLIT2, 133, 1, data[10])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT3, 134, 0, data[10])) ? 
/* FlightNum */] <679.5f ? 
/* UniqueCarrier */]) && (GenModel.bitSetIsInRange(32, 0, data[6]) && !GenModel.bitSetContains(GRPSPLIT4, 32, 0, data[6])) ? 
/* CRSArrTime */] <1242.5f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(129, 1, data[9]) && !GenModel.bitSetContains(GRPSPLIT5, 129, 1, data[9])) ? 
/* Dest */]) || !GenModel.bitSetIsInRange(132, 1, data[10]) || (GenModel.bitSetIsInRange(132, 1, data[10]) && !GenModel.bitSetContains(GRPSPLIT6, 132, 1, data[10])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(132, 1, data[10]) && !GenModel.bitSetContains(GRPSPLIT7, 132, 1, data[10])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(129, 1, data[9]) && !GenModel.bitSetContains(GRPSPLIT8, 129, 1, data[9])) ? 
/* Dest */]) || !GenModel.bitSetIsInRange(132, 1, data[10]) || (GenModel.bitSetIsInRange(132, 1, data[10]) && !GenModel.bitSetContains(GRPSPLIT9, 132, 1, data[10])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(132, 1, data[10]) && !GenModel.bitSetContains(GRPSPLIT10, 132, 1, data[10])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT11, 134, 0, data[10])) ? 
/* DayofMonth */] <5.5f ? 
/* CRSArrTime */] <1081.5f ? 
/* Origin */]) || !GenModel.bitSetIsInRange(129, 3, data[9]) || (GenModel.bitSetIsInRange(129, 3, data[9]) && !GenModel.bitSetContains(GRPSPLIT12, 129, 3, data[9])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(129, 3, data[9]) && !GenModel.bitSetContains(GRPSPLIT13, 129, 3, data[9])) ? 
/* Year */] <1997.5f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(129, 3, data[9]) && !GenModel.bitSetContains(GRPSPLIT14, 129, 3, data[9])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(129, 3, data[9]) && !GenModel.bitSetContains(GRPSPLIT15, 129, 3, data[9])) ? 
/* DayofMonth */] <7.5f ? 
/* Origin */]) || !GenModel.bitSetIsInRange(124, 3, data[9]) || (GenModel.bitSetIsInRange(124, 3, data[9]) && !GenModel.bitSetContains(GRPSPLIT16, 124, 3, data[9])) ? 
/* CRSDepTime */] <1216.5f ? 
/* UniqueCarrier */]) && (GenModel.bitSetIsInRange(32, 0, data[6]) && !GenModel.bitSetContains(GRPSPLIT17, 32, 0, data[6])) ? 
/* Year */] <1998.0f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(124, 3, data[9]) && !GenModel.bitSetContains(GRPSPLIT18, 124, 3, data[9])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(124, 3, data[9]) && !GenModel.bitSetContains(GRPSPLIT19, 124, 3, data[9])) ? 
// constant pool size = 457B, number of visited nodes = 31, static init size = 1986B
// {00010110 01100000 10010100 01000111 00100111 00100100 11000111 10000110 11011011 01010100 00000001 11111010 11100011 11010110 11010011 00111010 0001}
// {11000000 00000101 01000011 10000000 11010000 10000000 00000000 00000000 00000000 10000001 00001000 00000000 00011100 00100000 00000100 10000000 011}
// {...1 0-bits... 01111101 10111011 11111111 11011111 10111101 11111110 11101111 10111111 01011111 11100111 00101111 11011111 11111111 10101110 11110101 11110111 1111}
// {00000000 00100011 10001010 10000000 01000000 00100010 00001000 00100000 01001010 00100110 10001101 00000010 11011100 10100011 01000110 10100100 101010}
// {11101111 11000000 00000000 00000000}
// {...1 0-bits... 11101111 11011011 11111111 11011111 11111111 11111111 10011111 11111101 11110111 11111111 11111011 11111111 11111111 11111111 11101110 11111110}
// {...1 0-bits... 00000000 00001100 00000000 00000000 00000000 00000001 00000000 00000000 00010000 10000000 00000000 00000000 10010000 00000001 00000000 00000000 001}
// {...1 0-bits... 11111111 11111111 10011111 01111111 11111101 11111011 11111111 11110111 11011111 11001111 11110110 11111111 11101111 11111111 01111101 11011111 101}
// {...1 0-bits... 11111101 11111111 00111111 11011111 11111111 11011111 10011111 01111101 11111111 11111111 11111111 11111111 11111111 11111111 11111110 11111110}
// {...1 0-bits... 00000010 00001000 00000000 10100000 00000000 00000000 00000010 00000000 00011000 00000000 00000000 00100000 10000000 00000000 00010010 00001000 011}
// {...1 0-bits... 01101111 11111111 11011111 11111101 11110111 11111110 11110111 11111110 11011111 11100111 11111111 11101111 11111110 11101111 01111111 11010111 101}
// {11111101 10101100 00011111 10011011 01001101 10011010 10111101 00001001 01111111 11111101 00000011 11111001 10111110 10111111 01001011 01111100 001101}
// {...3 0-bits... 10000000 00000000 00000000 00010000 00000000 00000000 00000000 00000000 00011010 00000000 00000000 10000000 00000000 00000100 00000000 000000}
// {...3 0-bits... 11111111 11111111 01111101 11101111 11111110 11011011 11101111 11111101 11111111 11011111 11110111 01101111 11111011 11111001 01111111 111011}
// {...3 0-bits... 11111111 11111111 01111111 11011111 11111111 11111111 11100111 11011111 11110111 11111111 11111111 11101111 11111101 11111111 11111111 111011}
// {...3 0-bits... 10010000 00000000 00000010 00000000 00100001 00100000 00000000 00000000 00001000 00000000 00000010 01010000 00000100 10000000 10010000 010000}
// {...3 0-bits... 00010000 00000000 00100000 00000000 00001001 00000010 00101000 00010100 01001010 00100000 00001100 10000011 00010000 00000000 00001001 1}
// {11111110 11000000 00000000 00000000}
// {...3 0-bits... 01111110 11111111 01111101 11111111 11111110 11111111 11111111 11011111 11111101 11111111 11111100 11111110 11111011 11101011 01101111 0}
// {...3 0-bits... 00110010 00000100 10000000 00100000 00000001 00000010 00000000 00000000 00001000 00000000 00000010 10010000 00000100 00000000 10000001 0}
/* DayofMonth */] <6.5f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT0, 132, 0, data[9])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT1, 134, 0, data[10])) ? 
/* Origin */]) || !GenModel.bitSetIsInRange(132, 0, data[9]) || (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT2, 132, 0, data[9])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT3, 132, 0, data[9])) ? 
/* CRSArrTime */] <1088.0f ? 
/* Origin */]) || !GenModel.bitSetIsInRange(132, 0, data[9]) || (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT4, 132, 0, data[9])) ? 
/* CRSArrTime */] <1327.5f ? 
/* CRSArrTime */] <1143.5f ? 
/* CRSArrTime */] <1180.0f ? 
/* Origin */]) || !GenModel.bitSetIsInRange(131, 0, data[9]) || (GenModel.bitSetIsInRange(131, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT5, 131, 0, data[9])) ? 
/* Dest */]) || !GenModel.bitSetIsInRange(133, 0, data[10]) || (GenModel.bitSetIsInRange(133, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT6, 133, 0, data[10])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(133, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT7, 133, 0, data[10])) ? 
/* Year */] <2007.5f ? 
/* UniqueCarrier */]) && (GenModel.bitSetIsInRange(32, 0, data[6]) && !GenModel.bitSetContains(GRPSPLIT8, 32, 0, data[6])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(131, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT9, 131, 0, data[9])) ? 
/* Year */] <1998.0f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT10, 132, 0, data[9])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT11, 134, 0, data[10])) ? 
/* UniqueCarrier */]) || !GenModel.bitSetIsInRange(32, 0, data[6]) || (GenModel.bitSetIsInRange(32, 0, data[6]) && !GenModel.bitSetContains(GRPSPLIT12, 32, 0, data[6])) ? 
/* Origin */]) || !GenModel.bitSetIsInRange(132, 0, data[9]) || (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT13, 132, 0, data[9])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT14, 134, 0, data[10])) ? 
/* CRSDepTime */] <1511.5f ? 
/* UniqueCarrier */]) && (GenModel.bitSetIsInRange(32, 0, data[6]) && !GenModel.bitSetContains(GRPSPLIT15, 32, 0, data[6])) ? 
/* Origin */]) || !GenModel.bitSetIsInRange(132, 0, data[9]) || (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT16, 132, 0, data[9])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT17, 134, 0, data[10])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT18, 132, 0, data[9])) ? 
/* CRSArrTime */] <1327.5f ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT19, 134, 0, data[10])) ? 
/* CRSArrTime */] <1770.0f ? 
/* CRSArrTime */] <1475.0f ? 
// constant pool size = 447B, number of visited nodes = 31, static init size = 1926B
// {11010110 01000101 10010100 00000111 01111111 01110100 11000111 10000110 11011011 01001101 00101011 11111111 11111011 01110001 11110101 01111010 0010}
// {10111111 11111110 10101111 11011111 01011110 11111011 11110011 10010111 01001110 11100011 11111001 10111001 11111011 11110110 10111111 10111111 111110}
// {00001000 10110000 01100000 01000000 00000000 10000000 00001000 01001000 00000100 10000010 01000000 00000000 00000000 00000100 00001000 00000000 0000}
// {11011111 11110111 11110101 11100111 11111111 11111111 11101111 11001110 11011111 11111111 11111111 11111111 11111111 11110111 11111111 11111110 1011}
// {00000000 00000010 01000001 10000000 10000000 10000000 00110000 01000000 00000000 00000000 00000000 00000000 00000000 10000000 00000000 10000000 0100}
// {10010010 01000100 10000000 00000001 00101010 00110000 01000001 00000010 10000011 01001101 00000000 00010001 00110010 00000001 01000000 00001000 000}
// {01010000 00101100 01010000 00010001 00100001 10000110 10000100 00000000 10010101 00000111 00000100 10011010 10010100 00010001 00001011 00100100 10100}
// {11111111 11010100 11011111 10111111 11111110 11111101 11111111 11111111 01111111 11111111 11111011 01110011 10111110 01010111 00111111 11101011 11000}
// {01101011 11000000 00000000 00000000}
// {00000000 00000000 00000000 00000000 00000000 00000000 00000001 10000110 00010000 01000000 00001001 10001000 00000010 00000000 10100000 00000000 000}
// {00011110 01111011 11010110 11010111 01110111 01111100 11110110 10011011 11011111 00111100 00000011 11111011 11100101 11011111 11001011 01111000 1001}
// {11111111 11111111 11101111 11011111 11011111 11111111 11110111 11011011 11111111 01111011 11111011 01111011 11110110 11111011 01111110 11111111 111110}
// {01000000 00000000 00000000 00000000}
// {00000000 00000000 00100000 00000000 10001000 10000000 00000000 01000000 00000000 00000000 00000000 00000000 00000000 00100000 00000000 00000010 0100}
// {11011111 10101011 00011011 10111111 01101001 11110010 10111111 01001001 00111101 11111101 11101111 11101001 10111110 11011101 11101111 11111110 101101}
// {11101111 11000000 00000000 00000000}
// {00000110 01000101 10010000 11000100 10110100 00100001 01000000 00000000 00000001 10000000 00000000 01011010 00001100 11000000 00010010 00101010 0000}
// {00000110 00000111 01000000 01000000 00000000 00100000 10000010 00000000 01010001 00001100 00000000 00100100 01011000 00000000 00100110 00110100 001100}
// {01111111 11111101 11111111 11111111 11111111 10101111 11111111 10111111 11111111 11010011 10111110 11111110 11101111 11100111 11111010 00111111 1111}
// {00000000 00100001 00010000 00010010 00010000 00110010 10000000 00000000 10011000 00000100 10001100 10000010 10011000 11000011 01000100 11000100 101000}
/* DayofMonth */] <6.5f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT0, 132, 0, data[9])) ? 
/* CRSArrTime */] <1032.5f ? 
/* Dest */]) || !GenModel.bitSetIsInRange(133, 1, data[10]) || (GenModel.bitSetIsInRange(133, 1, data[10]) && !GenModel.bitSetContains(GRPSPLIT1, 133, 1, data[10])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(131, 1, data[9]) && !GenModel.bitSetContains(GRPSPLIT2, 131, 1, data[9])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(131, 1, data[9]) && !GenModel.bitSetContains(GRPSPLIT3, 131, 1, data[9])) ? 
/* Dest */]) || !GenModel.bitSetIsInRange(133, 1, data[10]) || (GenModel.bitSetIsInRange(133, 1, data[10]) && !GenModel.bitSetContains(GRPSPLIT4, 133, 1, data[10])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(131, 1, data[9]) && !GenModel.bitSetContains(GRPSPLIT5, 131, 1, data[9])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(131, 1, data[9]) && !GenModel.bitSetContains(GRPSPLIT6, 131, 1, data[9])) ? 
/* CRSDepTime */] <1041.5f ? 
/* Origin */]) || !GenModel.bitSetIsInRange(131, 0, data[9]) || (GenModel.bitSetIsInRange(131, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT7, 131, 0, data[9])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(133, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT8, 133, 0, data[10])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(133, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT9, 133, 0, data[10])) ? 
/* Year */] <2007.5f ? 
/* Dest */]) && (GenModel.bitSetIsInRange(133, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT10, 133, 0, data[10])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(131, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT11, 131, 0, data[9])) ? 
/* Year */] <1999.5f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT12, 132, 0, data[9])) ? 
/* UniqueCarrier */]) && (GenModel.bitSetIsInRange(32, 0, data[6]) && !GenModel.bitSetContains(GRPSPLIT13, 32, 0, data[6])) ? 
/* CRSDepTime */] <811.5f ? 
/* Year */] <1992.5f ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT14, 134, 0, data[10])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT15, 132, 0, data[9])) ? 
/* Origin */]) || !GenModel.bitSetIsInRange(132, 0, data[9]) || (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT16, 132, 0, data[9])) ? 
/* Origin */]) || !GenModel.bitSetIsInRange(132, 0, data[9]) || (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT17, 132, 0, data[9])) ? 
/* CRSArrTime */] <1438.5f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(130, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT18, 130, 0, data[9])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(132, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT19, 132, 0, data[10])) ? 
/* Dest */]) || !GenModel.bitSetIsInRange(134, 0, data[10]) || (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT20, 134, 0, data[10])) ? 
/* CRSArrTime */] <1585.5f ? 
/* CRSDepTime */] <1401.5f ? 
// constant pool size = 491B, number of visited nodes = 31, static init size = 2190B
// {10010010 01000100 10000100 00000101 01101111 00110100 01000101 00000110 11011011 01001101 00101001 11111011 11110011 01110001 11110001 00111010 0010}
// {...1 0-bits... 11111101 11111101 11111111 00110101 10110111 11111011 11111111 11110000 11001111 01011110 11111111 10010111 11100111 10101000 01101011 01011111 1101}
// {...1 0-bits... 11101101 11101011 11011100 11111011 11111110 11111111 10011111 11111101 11110110 11111111 11111111 11111111 11110111 11111111 11101110 11111111 11}
// {...1 0-bits... 10000010 01000010 11100010 00000101 00000000 00000001 00000100 10000000 00000000 00000000 00000000 00000000 00001000 00001000 00001101 00000000 00}
// {...1 0-bits... 10100110 01111100 00000001 00100010 00001000 01000101 00000010 00001010 00011100 01100011 00000000 00111001 10100000 01101111 00011000 00001001 0101}
// {...1 0-bits... 10111111 11111111 11101111 11001111 11111111 11101011 11011111 10011101 10111111 11111111 11010111 11111111 11110111 11101111 11111111 11111101 11}
// {...1 0-bits... 11111111 11111111 11111111 11111111 11111111 11111001 11101111 11111111 11111111 11111110 11111011 11111111 11110111 11111011 11101011 11111110 11}
// {10010000 01000000 00000000 00000000 00101000 00100000 01000001 00000010 10000001 01001101 00000000 00000001 10110010 00000000 00010000 00001000 000}
// {10111111 11010110 11011111 11011111 10111110 11011101 11111110 11011111 11111111 11110111 01111011 11101111 11111111 01111101 11111011 10101111 11010}
// {11111111 11001101 11111111 10111111 11111011 11011111 11110111 01011111 01111111 11110100 11111111 01110011 10111111 01000111 10111110 11101111 11110}
// {10101111 11111111 10011111 11110111 01101111 10111111 10101101 10011111 01101111 11111111 01010011 01101110 11111111 00100110 01011011 11011111 01100}
// {00000000 00000000 00000000 00000000 00000000 00000000 00000001 00000110 00010000 01000000 00001001 10001000 00000010 00000000 11000000 00000000 000}
// {00011110 01111011 11010110 11010111 00110111 01111100 11110110 10011011 11011111 00111100 00000011 11111011 11100101 11011100 11000011 01111010 1001}
// {01001111 10000000 00000000 00000000}
// {11011111 10101011 00011011 10011111 01111001 11111010 10110111 01001001 00111101 11111101 11101111 11101001 10111110 11011101 11101111 11111110 001101}
// {00000000 00000000 00000010 01000001 00000000 00000000 00000000 00000000 01000011 00000000 00000001 01010000 10000001 00000000 01000000 00000000 0001}
// {00000010 01000000 10000100 10000000 00000001 00000000 00000110 00000010 11001000 00000100 00000000 00010010 11000000 00000000 00000001 00100010 0000}
// {00010110 01000101 10010000 11000100 10010100 00100001 01000000 00100000 00000001 10000000 00000000 01011010 00001100 00010000 00011110 00000000 0000}
// {01000000 10010010 01100010 00000001 01001000 10000000 00001010 00000100 00000010 00000010 01010000 00000000 10000010 00000000 01000000 00000000 01}
// {00000000 00000011 01000000 01000000 00000000 00100000 00000010 01000100 00001001 00000100 00000000 10000100 01011000 00000000 00100111 00110000 0010}
// {00000000 00000001 00010000 00000010 00010000 00110010 00000000 00000000 00001000 00000100 00000100 10000010 10001000 10000011 01000110 01000100 101000}
/* DayofMonth */] <6.5f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT0, 132, 0, data[9])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT1, 134, 0, data[10])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT2, 132, 0, data[9])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT3, 134, 0, data[10])) ? 
/* CRSDepTime */] <1272.0f ? 
/* CRSDepTime */] <1180.0f ? 
/* Dest */]) || !GenModel.bitSetIsInRange(130, 1, data[10]) || (GenModel.bitSetIsInRange(130, 1, data[10]) && !GenModel.bitSetContains(GRPSPLIT4, 130, 1, data[10])) ? 
/* Dest */]) || !GenModel.bitSetIsInRange(130, 1, data[10]) || (GenModel.bitSetIsInRange(130, 1, data[10]) && !GenModel.bitSetContains(GRPSPLIT5, 130, 1, data[10])) ? 
/* CRSArrTime */] <1327.5f ? 
/* Origin */]) || !GenModel.bitSetIsInRange(131, 0, data[9]) || (GenModel.bitSetIsInRange(131, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT6, 131, 0, data[9])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(133, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT7, 133, 0, data[10])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(133, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT8, 133, 0, data[10])) ? 
/* Year */] <2003.5f ? 
/* Dest */]) && (GenModel.bitSetIsInRange(133, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT9, 133, 0, data[10])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(130, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT10, 130, 0, data[9])) ? 
/* Year */] <1998.0f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT11, 132, 0, data[9])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT12, 134, 0, data[10])) ? 
/* CRSArrTime */] <1106.5f ? 
/* CRSDepTime */] <1364.5f ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT13, 134, 0, data[10])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT14, 134, 0, data[10])) ? 
/* UniqueCarrier */]) && (GenModel.bitSetIsInRange(32, 0, data[6]) && !GenModel.bitSetContains(GRPSPLIT15, 32, 0, data[6])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT16, 132, 0, data[9])) ? 
/* CRSArrTime */] <1881.0f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(130, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT17, 130, 0, data[9])) ? 
/* Dest */]) || !GenModel.bitSetIsInRange(131, 0, data[10]) || (GenModel.bitSetIsInRange(131, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT18, 131, 0, data[10])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT19, 134, 0, data[10])) ? 
/* Year */] <2004.5f ? 
/* CRSDepTime */] <1180.0f ? 
// constant pool size = 473B, number of visited nodes = 31, static init size = 2082B
// {11010110 01000101 11010100 11000111 01111111 11110100 11000111 11000110 11011011 11001111 00101011 11111111 11111011 11110111 11110101 11111010 0110}
// {11111111 11111110 11101111 11011111 11011110 11011111 11110111 11111111 11011110 11100111 11111011 10111001 11111111 11110111 10111111 11111111 111110}
// {11111110 11110101 11010111 11111111 01111111 11111111 11011111 11001110 11011011 11111111 11111111 11111111 11111111 11110111 11111111 11111110 1111}
// {00000000 00000000 00010000 00100000 00000001 00000000 00001000 00000000 00000000 00000000 00000000 00000100 00000000 00000000 00000000 00000000 000001}
// {...1 0-bits... 00000000 00001100 10000001 00000000 00000000 00000001 00000000 00000000 00001000 00000000 00000000 00000000 00000000 00000000 00000000 01000000 0}
// {...1 0-bits... 00000010 00001100 00000000 00000000 00000000 00000000 00000010 00001001 00001000 00000010 00000000 00000000 10000000 00000101 00011000 10001000 0}
// {10010010 01000100 00000000 00000001 00101000 00100000 01000001 00000010 11000011 01001101 00100000 00000001 11110010 00000000 01010000 00001000 001}
// {10110111 11111110 10000111 10001111 10111011 11011101 11111111 11011100 01110110 11100111 01111101 01001111 11111011 01110000 00111011 11101111 11100}
// {01111111 11001100 11011111 10011111 11111011 11011111 11100111 01011011 01111111 11111100 01111011 01110011 11111111 11100111 10111111 11111111 01100}
// {10101111 11111001 11011101 11110111 01101111 10111011 10111101 10010111 10101111 11111111 11110011 01111101 10111101 01111111 11011011 11101011 11101}
// {11111111 10111110 10101111 11111101 11101111 11101111 01111101 00111111 11111111 11111111 11011111 11111111 11111111 10111111 10111111 01111111 10}
// {00011110 01111011 11010110 11010111 11110111 01111110 11110110 10011011 11011111 00111100 00000011 11111011 11100101 11111111 11001111 01111000 1001}
// {11111111 11111111 10101111 11011111 11111111 11111111 11110111 11011011 11111111 01111011 11111011 11111011 11110111 11111111 11111110 11111111 111111}
// {11011111 10101011 00011011 10111111 01101101 11110010 10111111 01001001 00111101 11111101 11101111 01111101 10111110 11011101 11101111 11111110 101101}
// {11111111 11111111 01111111 11111111 11101101 11110111 11111111 01101101 11111111 11111111 11111111 11111111 11111110 11111111 11101111 11111111 111111}
// {11101111 11000000 00000000 00000000}
// {01010110 01000101 10010000 11001100 11110100 00100001 01000000 00100000 00000001 10000000 01000000 01011010 00001100 11010000 11011110 10101010 0000}
// {00000000 10010000 01100001 00000001 00001000 10000000 00000010 00000100 00000000 00000010 00010001 00100000 10100000 00000000 00100000 00000000 01}
// {00000010 00000000 01000000 00000000 00000100 00100010 00000000 01000000 01000001 00000100 00000000 00001100 01011000 00000000 00000101 01100000 000}
// {00000000 00100101 00010000 00010010 01000000 00110010 10000000 00101000 10010001 00000100 10001100 10000010 11011000 11000011 01000110 11010100 101000}
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT0, 132, 0, data[9])) ? 
/* Year */] <2006.5f ? 
/* CRSArrTime */] <1444.5f ? 
/* Dest */]) || !GenModel.bitSetIsInRange(134, 0, data[10]) || (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT1, 134, 0, data[10])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT2, 132, 0, data[9])) ? 
/* Origin */]) || !GenModel.bitSetIsInRange(132, 0, data[9]) || (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT3, 132, 0, data[9])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT4, 134, 0, data[10])) ? 
/* Origin */]) || !GenModel.bitSetIsInRange(132, 0, data[9]) || (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT5, 132, 0, data[9])) ? 
/* UniqueCarrier */]) && (GenModel.bitSetIsInRange(32, 0, data[6]) && !GenModel.bitSetContains(GRPSPLIT6, 32, 0, data[6])) ? 
/* CRSDepTime */] <1124.5f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(129, 1, data[9]) && !GenModel.bitSetContains(GRPSPLIT7, 129, 1, data[9])) ? 
/* Dest */]) || !GenModel.bitSetIsInRange(132, 1, data[10]) || (GenModel.bitSetIsInRange(132, 1, data[10]) && !GenModel.bitSetContains(GRPSPLIT8, 132, 1, data[10])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(132, 1, data[10]) && !GenModel.bitSetContains(GRPSPLIT9, 132, 1, data[10])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(129, 1, data[9]) && !GenModel.bitSetContains(GRPSPLIT10, 129, 1, data[9])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(132, 1, data[10]) && !GenModel.bitSetContains(GRPSPLIT11, 132, 1, data[10])) ? 
/* Dest */]) || !GenModel.bitSetIsInRange(132, 1, data[10]) || (GenModel.bitSetIsInRange(132, 1, data[10]) && !GenModel.bitSetContains(GRPSPLIT12, 132, 1, data[10])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT13, 134, 0, data[10])) ? 
/* DayofMonth */] <5.5f ? 
/* CRSArrTime */] <1081.5f ? 
/* Origin */]) || !GenModel.bitSetIsInRange(124, 3, data[9]) || (GenModel.bitSetIsInRange(124, 3, data[9]) && !GenModel.bitSetContains(GRPSPLIT14, 124, 3, data[9])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(133, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT15, 133, 0, data[10])) ? 
/* Year */] <1997.5f ? 
/* Dest */]) && (GenModel.bitSetIsInRange(133, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT16, 133, 0, data[10])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(124, 3, data[9]) && !GenModel.bitSetContains(GRPSPLIT17, 124, 3, data[9])) ? 
/* Origin */]) || !GenModel.bitSetIsInRange(132, 0, data[9]) || (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT18, 132, 0, data[9])) ? 
/* CRSArrTime */] <1640.5f ? 
/* Year */] <1998.0f ? 
/* Dest */]) || !GenModel.bitSetIsInRange(131, 1, data[10]) || (GenModel.bitSetIsInRange(131, 1, data[10]) && !GenModel.bitSetContains(GRPSPLIT19, 131, 1, data[10])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT20, 134, 0, data[10])) ? 
/* Origin */]) || !GenModel.bitSetIsInRange(132, 0, data[9]) || (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT21, 132, 0, data[9])) ? 
/* CRSArrTime */] <921.5f ? 
// constant pool size = 507B, number of visited nodes = 31, static init size = 2286B
// {00010110 01100000 10010100 01000111 00100111 00100100 11000111 10000110 11011011 01010100 00000001 11111010 11100011 11010100 01010011 00111010 0000}
// {01010110 00000100 00000100 10000000 01000000 00100000 10000000 00000000 10010000 00001000 00000110 00000010 10010101 10010011 01000011 10100000 001010}
// {00000000 00000101 00000011 10100000 11011000 10000011 00000000 00101000 00000000 10000011 01011000 00000001 00000000 00000000 10001000 00000000 0000}
// {11000000 00000101 00000000 10000000 11000000 00000000 00000000 01000000 00000000 00001000 00100000 00000000 00000100 00100000 00000100 00000000 0010}
// {00101100 11111011 10111111 11000111 11001010 11111011 01110111 10110111 00001111 01110111 10011001 11000111 11111101 10100111 01111110 11011101 111010}
// {00000000 00000100 00100010 00000000 00000000 10010000 00000000 00000000 00000000 00000000 00000000 00000000 00001100 00000000 00001000 00000000 0000}
// {10001111 11000000 00000000 00000000}
// {...1 0-bits... 11101111 11111011 11111111 11011111 11111111 11111111 10011111 11111101 11110111 11111111 11111111 11111111 11111111 11111111 11111111 11111110}
// {...1 0-bits... 00000010 00000000 00000000 00000010 00000000 00000001 00000000 00000000 00010000 00000000 00000000 00000000 00000000 00000000 00000000 10000000 010}
// {...1 0-bits... 11101111 11111111 11111111 01111111 11111111 11111011 11111111 11111111 11111111 11011111 11110111 11111111 11111110 11111111 01101111 11011111 111}
// {...1 0-bits... 11111101 11111111 00111111 11011111 11111111 11111111 10011111 01111101 11111111 11111111 11111011 11111111 11111111 11111111 11111110 11111110}
// {...1 0-bits... 01111111 11101111 11111111 11111111 10110101 11111111 11110111 11111111 11011111 01000111 11111111 10111011 11111111 11111111 01111111 01111111 111}
// {...1 0-bits... 01111111 11111011 10011111 11111101 11110111 11111110 11111111 11111110 11001111 11110101 11111111 11101111 11111110 11101111 11111111 10011111 101}
// {01000001 00101000 00010001 00010001 01001101 10010010 10111101 00000001 01011101 00011101 00000000 10111001 10111100 00110011 01001011 01110100 001100}
// {...3 0-bits... 10000010 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00011010 00000000 00000000 10000000 00000000 10000000 00000000 0}
// {11110111 11111111 11111111 11011011 01111111 10111111 11111101 10011111 01111111 11111111 10010111 11111111 11111110 01111111 11011111 11111111 11111}
// {10110010 01000001 00000000 00100000 10100000 00100001 00000000 00000100 10000000 00000000 01000000 00000100 01000000 10001000 10000100 00000000 10000}
// {...3 0-bits... 11111111 11111111 01111111 11110110 11111111 11111111 11101111 11101101 11101111 11011111 11111011 01111010 11111101 11111101 11110111 1}
// {11101111 10011111 11101111 10111001 11011101 11011111 11111111 01111011 11101111 11101111 11111110 10011101 11011111 00111111 10101101 11111111 1111}
// {...1 0-bits... 11111111 10111111 11111111 11111111 01110111 11111110 11110111 11111101 01000111 11111111 11111111 10011101 11000111 11011101 11111001 11010111 11}
// {11111110 11111111 11111111 11111111 11111011 11111111 11100111 11111111 11111111 11100110 11111111 01111111 11111011 11101111 10111110 11111011 111111}
// {11111101 11111111 11111111 11111111 11111111 11111111 01111110 11111101 10111100 11111111 11111111 01101111 01111111 11111111 11111111 11111101 1111}
/* DayofMonth */] <6.5f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT0, 132, 0, data[9])) ? 
/* CRSArrTime */] <1041.5f ? 
/* Dest */]) || !GenModel.bitSetIsInRange(133, 1, data[10]) || (GenModel.bitSetIsInRange(133, 1, data[10]) && !GenModel.bitSetContains(GRPSPLIT1, 133, 1, data[10])) ? 
/* Origin */]) || !GenModel.bitSetIsInRange(132, 0, data[9]) || (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT2, 132, 0, data[9])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT3, 132, 0, data[9])) ? 
/* Dest */]) || !GenModel.bitSetIsInRange(133, 1, data[10]) || (GenModel.bitSetIsInRange(133, 1, data[10]) && !GenModel.bitSetContains(GRPSPLIT4, 133, 1, data[10])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT5, 132, 0, data[9])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT6, 132, 0, data[9])) ? 
/* CRSDepTime */] <829.5f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(128, 3, data[9]) && !GenModel.bitSetContains(GRPSPLIT7, 128, 3, data[9])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(133, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT8, 133, 0, data[10])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(133, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT9, 133, 0, data[10])) ? 
/* Year */] <2007.5f ? 
/* Dest */]) && (GenModel.bitSetIsInRange(133, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT10, 133, 0, data[10])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(133, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT11, 133, 0, data[10])) ? 
/* Year */] <1998.0f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT12, 132, 0, data[9])) ? 
/* Year */] <1987.5f ? 
/* CRSDepTime */] <1211.5f ? 
/* DayofMonth */] <20.5f ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT13, 134, 0, data[10])) ? 
/* Year */] <1993.5f ? 
/* UniqueCarrier */]) && (GenModel.bitSetIsInRange(32, 0, data[6]) && !GenModel.bitSetContains(GRPSPLIT14, 32, 0, data[6])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT15, 134, 0, data[10])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT16, 132, 0, data[9])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT17, 132, 0, data[9])) ? 
/* Year */] <2004.5f ? 
/* Origin */]) || !GenModel.bitSetIsInRange(132, 0, data[9]) || (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT18, 132, 0, data[9])) ? 
/* CRSArrTime */] <1327.5f ? 
/* CRSDepTime */] <1143.5f ? 
// constant pool size = 454B, number of visited nodes = 31, static init size = 1968B
// {00010010 01000000 10000100 00000101 01101111 00110000 01000101 10000110 11001011 01001101 00100000 11111011 11100011 01010001 11100001 00111010 0010}
// {...1 0-bits... 11111111 11111101 00111111 00110101 10111111 11111011 11111111 10110000 11101111 01011110 11111111 10000011 11100111 10111000 01101101 01011111 1101}
// {10000000 00000100 00000000 01000000 00000000 00000010 00000010 01000000 00000000 00000000 00000011 00000000 00000000 10000000 00000000 00000000 1100}
// {11110111 01101101 11111111 10101111 11111111 11111101 11001111 11111110 11111011 11111111 11111100 11111111 11110111 01111111 11110111 11111011 0011}
// {...1 0-bits... 10100110 01010100 00000001 00100010 00000000 01000001 00000010 00001010 00011100 01100011 00000000 00111001 10000010 01100110 00011010 00001001 0101}
// {01011110 11101101 11110111 11100111 01101111 11110100 11100101 11000110 11011111 11001111 11101011 11111111 11111011 11110111 11111101 11111110 0111}
// {11111111 11101111 11111111 11111111 11111111 11111000 11111111 11111110 11111111 11111111 01111101 11111111 11111011 11111101 11111101 11111111 0110}
// {...3 0-bits... 11111111 11111111 11111111 11111101 10111111 11111111 11111011 11011101 11111111 11111110 11111001 10101011 11111101 01111001 11111111 11101}
// {10111111 11111110 11111111 11101111 11111110 11111111 11111111 11011101 11111111 11110111 01111011 11111111 10111111 01011111 01111001 11101111 11110}
// {11111111 11010000 11011111 11101111 11011110 11111101 11111111 11111111 01111111 11110110 11111111 01111111 10111111 01010111 11111111 11001011 11100}
// {11111111 11001101 10011111 11110111 01111111 10111111 10101101 00011111 01111111 11111111 11110111 11101110 11111111 01100110 11011011 11111111 01111}
// {10111111 11110011 11001111 10101110 11111111 11111111 01111110 11111011 11101111 11111011 01111011 11111111 11101111 01110110 10111110 11101011 11011}
// {00011110 01111011 11010110 11010111 01110111 01111100 11110110 10011011 11011111 00111100 00000011 11111011 11000101 11111101 11001011 01111000 1001}
// {01000000 00000001 00011001 00010000 01100000 00000010 10111000 01000000 00001001 00101101 01000001 00000000 10111100 10011001 10000111 00000100 101000}
// {11101111 11000000 00000000 00000000}
// {00000100 00100101 00010000 00010010 00010000 00110010 10000010 00101000 11000001 00000100 10001000 00000110 11011000 11000011 01100100 11100100 101000}
// {00010010 11010101 11010000 10001000 11001110 10100000 01000000 00000000 01000001 00000000 00010000 01110010 10101000 00000000 11110010 00001000 0000}
// {01111111 11111111 11111111 10111111 11111111 11101111 11111111 11011111 11111111 01111011 10110111 01111111 11101101 00000111 11111010 00111111 1111}
// {00000110 01000100 10010000 10000000 10101000 10110001 00000000 01100000 00000001 10000010 01000000 01111011 00000000 10010000 10010110 10101010 0000}
/* DayofMonth */] <6.5f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT0, 132, 0, data[9])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT1, 134, 0, data[10])) ? 
/* Origin */]) || !GenModel.bitSetIsInRange(132, 0, data[9]) || (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT2, 132, 0, data[9])) ? 
/* Dest */]) || !GenModel.bitSetIsInRange(134, 0, data[10]) || (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT3, 134, 0, data[10])) ? 
/* Year */] <1993.5f ? 
/* CRSArrTime */] <1014.5f ? 
/* Dest */]) || !GenModel.bitSetIsInRange(132, 1, data[10]) || (GenModel.bitSetIsInRange(132, 1, data[10]) && !GenModel.bitSetContains(GRPSPLIT4, 132, 1, data[10])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT5, 132, 0, data[9])) ? 
/* UniqueCarrier */]) && (GenModel.bitSetIsInRange(32, 0, data[6]) && !GenModel.bitSetContains(GRPSPLIT6, 32, 0, data[6])) ? 
/* Origin */]) || !GenModel.bitSetIsInRange(132, 0, data[9]) || (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT7, 132, 0, data[9])) ? 
/* DayofMonth */] <2.5f ? 
/* Year */] <1999.0f ? 
/* CRSDepTime */] <1106.5f ? 
/* Dest */]) && (GenModel.bitSetIsInRange(133, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT8, 133, 0, data[10])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(133, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT9, 133, 0, data[10])) ? 
/* Year */] <1999.5f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT10, 132, 0, data[9])) ? 
/* Dest */]) || !GenModel.bitSetIsInRange(134, 0, data[10]) || (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT11, 134, 0, data[10])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT12, 132, 0, data[9])) ? 
/* Origin */]) || !GenModel.bitSetIsInRange(132, 0, data[9]) || (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT13, 132, 0, data[9])) ? 
/* UniqueCarrier */]) && (GenModel.bitSetIsInRange(32, 0, data[6]) && !GenModel.bitSetContains(GRPSPLIT14, 32, 0, data[6])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT15, 132, 0, data[9])) ? 
/* Dest */]) || !GenModel.bitSetIsInRange(134, 0, data[10]) || (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT16, 134, 0, data[10])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT17, 132, 0, data[9])) ? 
/* CRSArrTime */] <1438.5f ? 
/* Origin */]) || !GenModel.bitSetIsInRange(130, 0, data[9]) || (GenModel.bitSetIsInRange(130, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT18, 130, 0, data[9])) ? 
/* Dest */]) || !GenModel.bitSetIsInRange(131, 0, data[10]) || (GenModel.bitSetIsInRange(131, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT19, 131, 0, data[10])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT20, 134, 0, data[10])) ? 
/* Year */] <2004.5f ? 
/* CRSArrTime */] <1548.5f ? 
// constant pool size = 478B, number of visited nodes = 31, static init size = 2112B
// {01010010 01000000 10000100 00000101 01101111 00110000 01000101 00000110 11001011 01001101 00100001 11111011 11110011 01010001 11100001 00111010 0010}
// {11110111 11111110 10110101 11011011 01011111 11111111 11110111 10010101 01011111 10111111 11111101 10011101 11111111 11111110 10111111 11101111 111110}
// {00000000 00010100 01000000 01000000 00000000 10000010 00000000 00000000 00000000 00000000 00001000 00000000 00001000 00000100 00001110 00000000 0000}
// {00001000 00000000 01001010 00000000 00000000 00000000 00000000 00100000 00000000 01000000 00000010 01100010 00000000 00000001 01000000 00000000 000000}
// {...1 0-bits... 10100000 00010000 00000000 00100000 10000010 00000000 00000010 00000000 00000000 00110010 00001000 00000001 10000000 00110000 00000000 01001000 000}
// {01011110 11101111 11011111 11100111 11111111 11111100 11110111 11111110 11111111 11101111 00101011 11111111 11111011 11111101 11110101 11111111 0110}
// {11101111 11000000 00000000 00000000}
// {00000010 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 0000}
// {11111111 11100100 11011111 10001111 10101010 11011111 11100110 01011011 01111111 11110101 01111011 11101011 10111111 01100101 11111111 11101011 11110}
// {10100101 10111111 10011111 11110111 01100111 10111111 10111101 10011111 11111111 11111111 10010011 11101010 10111011 00101110 11011001 11111111 01101}
// {00010010 01000001 11000110 11000101 11100001 00100010 00010110 00000010 11001011 00011100 00000001 01110011 11000101 10000000 11000011 00111010 0000}
// {11111111 11111111 10001111 11011111 11011111 11111111 11110111 11011011 11111111 01111011 11111011 01111011 11110110 11111011 01111110 11111111 110110}
// {11111111 11111111 11111111 11111111 11111111 11111111 11111111 10111111 11011111 11111111 11111111 11111111 11111111 10111111 11111111 11111011 1011}
// {00000000 00000000 00110000 00000000 00001000 10000000 00000000 01000000 00000000 00000000 00000000 00000000 00000000 01100000 00000000 00000000 0100}
// {11101111 11000000 00000000 00000000}
// {11111111 11111111 11111111 11111111 10111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 1111}
// {01000000 00000000 00001001 10010000 01000000 00000010 10100000 01000000 00000000 00101100 01000000 00000000 10101000 00000000 10000110 00000100 001000}
// {00010110 01010101 10110000 11001100 11010100 00100001 01000000 00100000 00000001 10000000 01000000 01011010 00001100 00010000 00011110 00000000 0000}
// {01000000 10000010 01000010 00000001 00001000 10000000 00001010 01000100 00000010 00001010 00010000 00000000 10000010 00100000 01000000 00000000 01}
// {00000010 00000000 01000000 01000000 00000000 00100000 00000010 01000100 00001000 00000000 00000000 00001100 01010000 00000000 00100000 00100000 001}
// {00000000 00100101 00010000 00110010 01000000 00110010 10000000 00100000 10010000 00000100 10001100 10000110 10001100 11000011 01000110 11000100 101000}
/* DayofMonth */] <6.5f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT0, 132, 0, data[9])) ? 
/* CRSArrTime */] <1041.5f ? 
/* Dest */]) || !GenModel.bitSetIsInRange(133, 1, data[10]) || (GenModel.bitSetIsInRange(133, 1, data[10]) && !GenModel.bitSetContains(GRPSPLIT1, 133, 1, data[10])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(131, 1, data[9]) && !GenModel.bitSetContains(GRPSPLIT2, 131, 1, data[9])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(131, 1, data[9]) && !GenModel.bitSetContains(GRPSPLIT3, 131, 1, data[9])) ? 
/* Year */] <2007.5f ? 
/* Dest */]) && (GenModel.bitSetIsInRange(133, 1, data[10]) && !GenModel.bitSetContains(GRPSPLIT4, 133, 1, data[10])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(133, 1, data[10]) && !GenModel.bitSetContains(GRPSPLIT5, 133, 1, data[10])) ? 
/* DayofMonth */] <1.5f ? 
/* Year */] <1998.0f ? 
/* Dest */]) && (GenModel.bitSetIsInRange(133, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT6, 133, 0, data[10])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(133, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT7, 133, 0, data[10])) ? 
/* CRSDepTime */] <717.5f ? 
/* Origin */]) || !GenModel.bitSetIsInRange(131, 0, data[9]) || (GenModel.bitSetIsInRange(131, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT8, 131, 0, data[9])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(133, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT9, 133, 0, data[10])) ? 
/* Year */] <1998.0f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT10, 132, 0, data[9])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT11, 134, 0, data[10])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT12, 132, 0, data[9])) ? 
/* Origin */]) && (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT13, 132, 0, data[9])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(134, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT14, 134, 0, data[10])) ? 
/* CRSArrTime */] <1678.0f ? 
/* Origin */]) || !GenModel.bitSetIsInRange(132, 0, data[9]) || (GenModel.bitSetIsInRange(132, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT15, 132, 0, data[9])) ? 
/* CRSArrTime */] <1631.5f ? 
/* Origin */]) || !GenModel.bitSetIsInRange(130, 0, data[9]) || (GenModel.bitSetIsInRange(130, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT16, 130, 0, data[9])) ? 
/* Dest */]) || !GenModel.bitSetIsInRange(133, 0, data[10]) || (GenModel.bitSetIsInRange(133, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT17, 133, 0, data[10])) ? 
/* Year */] <2000.5f ? 
/* Origin */]) && (GenModel.bitSetIsInRange(130, 0, data[9]) && !GenModel.bitSetContains(GRPSPLIT18, 130, 0, data[9])) ? 
/* Dest */]) || !GenModel.bitSetIsInRange(133, 0, data[10]) || (GenModel.bitSetIsInRange(133, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT19, 133, 0, data[10])) ? 
/* Dest */]) && (GenModel.bitSetIsInRange(133, 0, data[10]) && !GenModel.bitSetContains(GRPSPLIT20, 133, 0, data[10])) ? 
// constant pool size = 504B, number of visited nodes = 31, static init size = 2268B
// {10010010 00000000 10000100 00000101 01101111 00110000 01000101 00000110 11001011 01001101 00100000 11110011 11100011 01010001 11100001 00111010 0010}
// {...1 0-bits... 11011111 10111101 10111111 00110101 10111111 11111011 11111101 11110000 11101111 01011110 11111011 10000111 11100111 10111001 01101101 01011111 1101}
// {...1 0-bits... 11101111 11101011 11111111 11111011 11111111 11111111 10111111 11111101 11011111 11111111 11111111 11101111 11111111 10111111 11111010 11111111 11}
// {...1 0-bits... 11101110 11011011 11111011 01011111 11111110 11111011 10011110 11111111 11110111 11111111 11111001 11111111 11101110 11111111 11101111 11111110 01}
// {...1 0-bits... 11101111 11111101 00100011 10110110 00111111 11110111 11101111 01101010 10011101 01101111 11110110 00101011 11111010 11101110 11111111 00011111 1111}
// {...1 0-bits... 01111111 11110111 11011111 11111111 10111111 11111011 11111111 11111111 11111111 11101111 11111111 11111011 01111111 11111111 01110111 11110111 1111}
// {11111111 11001010 01111111 11011111 01111011 01111101 11110111 01011111 01111111 11111111 10111111 11111100 11111111 11101101 11111110 11101011 00110}
// {10111100 11110101 10111111 11110111 10111111 10111111 11111111 11011111 11110110 11111111 00011111 01101011 11110011 00101111 10010000 10011011 11001}
// {00000000 00000000 00000000 00000001 00100010 00110000 01000000 00000000 10000001 01001001 00000000 00100000 00100010 00010000 11000000 00001010 000}
// {01111111 10001101 11011111 10110111 01110111 10011111 00101100 00011111 11111111 11111111 11110011 11101111 10111010 01101111 11011111 11101111 01110}
// {00010010 01000001 11010110 11000101 01100001 00100000 00000110 00000010 11001011 00011100 00000001 01010011 11000101 11000000 11000011 00011000 0000}
// {11111111 11111111 11101111 11011111 10011111 11111111 11110111 11011011 11111111 01111011 11111011 01111011 11110110 11111011 01111110 11111111 011111}
// {11111111 11111111 11111111 11111111 11111111 11111111 11111111 10111111 11011111 11111111 11111111 11011111 11111111 11111111 11111111 11111011 1011}
// {10000000 00000000 00100000 00001000 10001000 10000010 00010001 01100100 00000000 00000000 00001000 00100000 00101000 00100010 00000100 00000010 0100}
// {11111111 11101011 00111011 10111111 01101101 11110011 11111111 01001101 11111101 11111101 11101111 11111111 11111110 11011111 11101111 11111110 101111}
// {00000010 01000000 10000100 11000100 00000001 00000000 00000110 00000000 11001010 00000100 00000001 00010000 11000001 00000000 00000001 00000000 0000}
// {00010110 00000100 00010000 01000000 10111100 00000001 01000000 00000000 00000001 10000000 00000000 00001000 00000000 10000000 00011000 00001010 00}
// {01000110 01000101 00000000 00010000 00010100 00110000 10000000 00100100 11010000 00001100 11001010 00000010 01001000 00011001 10000000 10000000 00100}
// {01000010 01000101 11010011 00100100 11000000 10100000 00000000 00100000 00000001 00000000 01100000 01111010 00001100 11010000 10010010 10100010 00}
// {00000000 00100100 01010000 10000000 00000000 00100000 00100010 00001000 00001001 00000110 10000000 00001110 11010000 10000111 00100000 01110100 10100}
// {11111111 11111101 11111111 11111111 11111011 11111111 01111111 11011011 11111111 11110101 10111011 11010111 11111011 11110111 11111110 11101011 11100}
/**
// https://issues.apache.org/jira/browse/KAFKA-6647 causes exception when
// executed in Windows, ignoring it
// Logged stacktrace cannot be avoided
/**
/**
// Flight data (one single flight) --> We want to predict if it will be
// delayed or not
// This model predict also another flight to be delayed
/**
// Name of the generated H2O.ai model
// Prediction Value
// Flight data (one single flight) --> We want to predict if it will be
// delayed or not
// Step 1: Configure and start the processor topology.
//
// The commit interval for flushing records to state stores and
// downstream must be lower than
// this integration test's timeout (30 secs) to ensure we observe the
// expected processing results.
// Use a temporary directory for storing state, which will be
// automatically removed after the test.
// Create H2O object (see
// deeplearning_fe7c1f02_08ec_4070_b784_c2531147e451.java)
// Configure Kafka Streams Application
// Specify default (de)serializers for record keys and for record
// values.
// In the subsequent lines we define the processing topology of the
// Streams application.
// Construct a `KStream` from the input topic "AirlineInputTopic", where
// message values
// represent lines of text (for the sake of this example, we ignore
// whatever may be stored
// in the message keys).
// Stream Processor (in this case 'foreach' to add custom logic, i.e.
// apply the analytic model)
// Year,Month,DayofMonth,DayOfWeek,DepTime,CRSDepTime,ArrTime,CRSArrTime,UniqueCarrier,FlightNum,TailNum,ActualElapsedTime,CRSElapsedTime,AirTime,ArrDelay,DepDelay,Origin,Dest,Distance,TaxiIn,TaxiOut,Cancelled,CancellationCode,Diverted,CarrierDelay,WeatherDelay,NASDelay,SecurityDelay,LateAircraftDelay,IsArrDelayed,IsDepDelayed
// value:
// 1987,10,14,3,741,730,912,849,PS,1451,NA,91,79,NA,23,11,SAN,SFO,447,NA,NA,0,NA,0,NA,NA,NA,NA,NA,YES,YES
// Transform message: Add prediction information
// Send prediction information to Output Topic
// Start Kafka Streams Application to process new incoming messages from
// Input Topic
//
// Step 2: Produce some input data to the input topic.
//
//
// Step 3: Verify the application's output data.
//
/**
// https://issues.apache.org/jira/browse/KAFKA-6647 causes exception when
// executed in Windows, ignoring it
// Logged stacktrace cannot be avoided
/**
/**
// Flight data (one single flight) --> We want to predict if it will be
// delayed or not
/**
// public static final EmbeddedSingleNodeKafkaCluster CLUSTER = new
// EmbeddedSingleNodeKafkaCluster();
// Name of the generated H2O.ai model
// Prediction Value
// Flight data (one single flight) --> We want to predict if it will be
// delayed or not
// Step 1: Configure and start the processor topology.
//
// The commit interval for flushing records to state stores and
// downstream must be lower than
// this integration test's timeout (30 secs) to ensure we observe the
// expected processing results.
// Use a temporary directory for storing state, which will be
// automatically removed after the test.
// Create H2O object (see gbm_pojo_test.java)
// Configure Kafka Streams Application
// Specify default (de)serializers for record keys and for record
// values.
// In the subsequent lines we define the processing topology of the
// Streams application.
// Construct a `KStream` from the input topic "AirlineInputTopic", where
// message values
// represent lines of text (for the sake of this example, we ignore
// whatever may be stored
// in the message keys).
// Stream Processor (in this case 'foreach' to add custom logic, i.e.
// apply the analytic model)
// Year,Month,DayofMonth,DayOfWeek,DepTime,CRSDepTime,ArrTime,CRSArrTime,UniqueCarrier,FlightNum,TailNum,ActualElapsedTime,CRSElapsedTime,AirTime,ArrDelay,DepDelay,Origin,Dest,Distance,TaxiIn,TaxiOut,Cancelled,CancellationCode,Diverted,CarrierDelay,WeatherDelay,NASDelay,SecurityDelay,LateAircraftDelay,IsArrDelayed,IsDepDelayed
// value:
// 1987,10,14,3,741,730,912,849,PS,1451,NA,91,79,NA,23,11,SAN,SFO,447,NA,NA,0,NA,0,NA,NA,NA,NA,NA,YES,YES
// Transform message: Add prediction information
// Send prediction information to Output Topic
// Start Kafka Streams Application to process new incoming messages from
// Input Topic
//
// Step 2: Produce some input data to the input topic.
//
//
// Step 3: Verify the application's output data.
//
/**
//issues.apache.org/jira/browse/KAFKA-6647
/**
//issues.apache.org/jira/browse/KAFKA-6647
/**
// do stuff
// only do this in dev - not in prod
// print the topology
// shutdown hook to correctly close the streams application
/**
// Configure Kafka Streams Application
// Start Kafka Streams Application to process new incoming images from the Input
// Topic
// Add shutdown hook to respond to SIGTERM and gracefully close Kafka
// Streams
// Give the Streams application a unique name. The name must be unique
// in the Kafka cluster
// against which the application is run.
// Where to find Kafka broker(s).
// Specify default (de)serializers for record keys and for record
// values.
// Create TensorFlow object
// In the subsequent lines we define the processing topology of the
// Streams application.
// Construct a `KStream` from the input topic "ImageInputTopic", where
// message values represent lines of text
//imageInputLines.print(Printed.toSysOut());
// Stream Processor (in this case inside mapValues to add custom logic, i.e. apply the
// analytic model)
// Transform message: Add prediction information
// Send prediction information to Output Topic
// ########################################################################################
// Private helper class for construction and execution of the pre-built
// TensorFlow model
// ########################################################################################
// Graph construction: using the OperationBuilder class to construct a graph to
// decode, resize and normalize a JPEG image.
// Some constants specific to the pre-trained model at:
// https://storage.googleapis.com/download.tensorflow.org/models/inception5h.zip
//
// - The model was trained with images scaled to 224x224 pixels.
// - The colors, represented as R, G, B in 1-byte each were
// converted to
// float using (value - Mean)/Scale.
// Since the graph is being constructed once per execution here, we
// can use a constant for the
// input image. If the graph were to be re-used for multiple input
// images, a placeholder would
// have been more appropriate.
// Model loading: Using Graph.importGraphDef() to load a pre-trained Inception
// model.
// Graph execution: Using a Session to execute the graphs and find the best
// label for an image.
// In the fullness of time, equivalents of the methods of this class should
// be auto-generated from
// the OpDefs linked into libtensorflow_jni.so. That would match what is
// done in other languages
// like Python, C++ and Go.
/** This is helper class to workaround for Failing stream tests in Windows environment KAFKA-6647.
//issues.apache.org/jira/browse/KAFKA-6647
/** This is helper class to workaround for Failing stream tests in Windows environment KAFKA-6647.
//issues.apache.org/jira/browse/KAFKA-6647
/**
// https://issues.apache.org/jira/browse/KAFKA-6647 causes exception when executed in Windows, ignoring it
// Logged stacktrace cannot be avoided
/** Simple recognition test validating only the recognition part of the output
/** Test based on Kafka_Streams_TensorFlow_Image_Recognition_Example_IntegrationTest
// Images: 'unknown', Airliner, 'unknown', Butterfly
/**
// Prediction Value
// Images: 'unknown', Airliner, 'unknown', Butterfly
// ########################################################
// Step 1: Configure and start the processor topology.
// ########################################################
// Create TensorFlow object
// Configure Kafka Streams Application
// Specify default (de)serializers for record keys and for record
// values.
// In the subsequent lines we define the processing topology of the
// Streams application.
// Construct a `KStream` from the input topic "AirlineInputTopic", where
// message values
// represent lines of text (for the sake of this example, we ignore
// whatever may be stored
// in the message keys).
// Stream Processor (in this case 'foreach' to add custom logic, i.e.
// apply the analytic model)
// Load and execute TensorFlow graph
// Transform message: Add prediction information
// Send prediction information to Output Topic
// Start Kafka Streams Application to process new incoming messages from
// Input Topic
// ########################################################
// Step 2: Produce some input data to the input topic.
// ########################################################
// ########################################################
// Step 3: Verify the application's output data.
// ########################################################
// ########################################################################################
// Private helper class for construction and execution of the pre-built
// TensorFlow model
// ########################################################################################
// Some constants specific to the pre-trained model at:
// https://storage.googleapis.com/download.tensorflow.org/models/inception5h.zip
//
// - The model was trained with images scaled to 224x224 pixels.
// - The colors, represented as R, G, B in 1-byte each were
// converted to
// float using (value - Mean)/Scale.
// Since the graph is being constructed once per execution here, we
// can use a constant for the
// input image. If the graph were to be re-used for multiple input
// images, a placeholder would
// have been more appropriate.
// In the fullness of time, equivalents of the methods of this class should
// be auto-generated from
// the OpDefs linked into libtensorflow_jni.so. That would match what is
// done in other languages
// like Python, C++ and Go.
# Simple Keras Model  (source: https://deeplearning4j.org/docs/latest/keras-import-overview)
/** This is helper class to workaround for Failing stream tests in Windows environment KAFKA-6647.
//issues.apache.org/jira/browse/KAFKA-6647
/** This is helper class to workaround for Failing stream tests in Windows environment KAFKA-6647.
//issues.apache.org/jira/browse/KAFKA-6647
/**
//www.kai-waehner.de">http://www.kai-waehner.de</a>
// ########################################################
// Step 1: Load Keras Model using DeepLearning4J API
// ########################################################
// Create test data which is sent from Kafka Producer into Input Topic
// ####################################################################
// Step 2: Configure and start the Kafka Streams processor topology.
// ####################################################################
// Configure Kafka Streams Application
// Specify default (de)serializers for record keys and for record
// values.
// In the subsequent lines we define the processing topology of the
// Streams application.
// Construct a `KStream` from the input topic, where
// message values represent lines of text (for the sake of this example, we
// ignore whatever may be stored in the message keys).
// ###############################################################
// THIS IS WHERE WE DO REAL TIME MODEL INFERENCE FOR EACH EVENT
// ###############################################################
// Transform input values (list of Strings) to expected DL4J parameters (two
// Integer values):
// Apply the analytic model:
// Transform message: Add prediction result
// Send prediction result to Output Topic
// Start Kafka Streams Application to process new incoming messages from
// Input Topic
// ########################################################
// Step 3: Produce some input data to the input topic.
// ########################################################
// ########################################################
// Step 4: Verify the application's output data.
// ########################################################
