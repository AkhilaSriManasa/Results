rsmckinney = Scott McKinney <scott@manifold.systems>                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
<center>
  <img src="https://i.imgur.com/No1RPUf.png" width="80%"/>
</center>

## What is Manifold?
Manifold [plugins into](https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/util/Plugin.html) Java
and supplements it with powerful features, including:
* [*Type-safe* Meta-programming](https://github.com/manifold-systems/manifold/tree/master/manifold-core-parent/manifold)
* [Extension Methods](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext)
* [Operator Overloading](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#operator-overloading)
* [Unit Expressions](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#unit-expressions)
* [A *Java* Template Engine](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-templates)
* [A Preprocessor](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-preprocessor)
* ...and more

All fully supported in Java 8 - 13 with comprehensive support in IntelliJ IDEA. Simply add Manifold to your existing
project and begin taking advantage of it.

## What can you do with Manifold?

### [Meta-programming](https://github.com/manifold-systems/manifold/tree/master/manifold-core-parent/manifold)
Use the framework to gain direct, type-safe access to *any* type of resource, such as
[**GraphQL**](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-graphql),
[**XML**](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-xml),
[**JSON**](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-json),
[**CSV**](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-csv),
[**YAML**](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-yaml), and even
other languages such as [**JavaScript**](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-js).
Remove the code gen step in your build process. [&nbsp;**▶**&nbsp;Check&nbsp;it&nbsp;out!](http://manifold.systems/images/graphql.mp4)

**GraphQL:** Use types defined in your `movies.graphql` and `queries.graphql` files *directly*, no code gen!
```java
var query = MovieQuery.builder(Action).build();
var result = query.request("http://com.example/graphql").post();
var actionMovies = result.getMovies();
for (var movie : actionMovies) {
  out.println(
    "Title: " + movie.getTitle() + "\n" +
    "Genre: " + movie.getGenre() + "\n" +
    "Year: " + movie.getReleaseDate().getYear() + "\n");
}
```

**JSON:** Use your `User.json` schema file directly as a type, no code gen!
```java
User user = User.builder("myid", "mypassword", "Scott")
  .withGender(male)
  .withDob(LocalDate.of(1987, 6, 15))
  .build();
User.request("http://api.example.com/users").postOne(user);
```

### [Extension Methods](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext)
Add your own methods to existing Java classes, even `String`, `List`, and `File`. Eliminate boilerplate code.
[&nbsp;**▶**&nbsp;Check&nbsp;it&nbsp;out!](http://manifold.systems/images/ExtensionMethod.mp4)
```java
String greeting = "hello";
greeting.myMethod(); // Add your own methods to String!
```

### [Operator Overloading](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#operator-overloading)
Implement *operator* methods on any type to directly support arithmetic, relational, and unit operators.
```java
// BigDecimal expressions
if (bigDec1 > bigDec2) {
  BigDecimal result = bigDec1 + bigDec2;
  ...
}
// Implement operators for any type
MyType value = myType1 + myType2;
```  

### [Unit Expressions](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#unit-expressions)
Unit or *binding* operations are unique to the Manifold framework. They provide a powerfully concise syntax and can be
applied to a wide range of applications.
```java
import static manifold.science.util.UnitConstants.*; // kg, m, s, ft, etc
...
Length distance = 100 mph * 3 hr;
Force f = 5.2 kg m/s/s; // same as 5.2 N
Mass infant = 9 lb + 8.71 oz;
```  

### [Ranges](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-collections#ranges)
Easily work with the `Range` API using [unit expressions]((https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#unit-expressions)).
Simply import the `RangeFun` constants to create ranges.
```java
// imports the `to`, `step`, and other "binding" constants
import static manifold.collections.api.range.RangeFun.*;
...
for (int i: 1 to 5) {
  out.println(i);
}

for (Mass m: 0kg to 10kg step 22r unit g) {
  out.println(m);
}
```

### [Science](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-science)
Use the [manifold-science](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-science)
framework to type-safely incorporate units and precise measurements into your applications.
```java
import static manifold.science.util.UnitConstants.*; // kg, m, s, ft, etc.
...
Velocity rate = 65mph;
Time time = 1min + 3.7sec;
Length distance = rate * time;
```  

### [Preprocessor](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-preprocessor)
Use familiar directives such as `#define` and `#if` to conditionally compile your Java projects. The preprocessor offers
a simple and convenient way to support multiple build targets with a single codebase. [&nbsp;**▶**&nbsp;Check&nbsp;it&nbsp;out!](http://manifold.systems/images/preprocessor.mp4)
```java
#if JAVA_8_OR_LATER
  @Override
  public void setTime(LocalDateTime time) {...)
#else
  @Override
  public void setTime(Calendar time) {...}
#endif
```   

### [Structural Typing](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#structural-interfaces-via-structural)
Unify disparate APIs. Bridge software components you do not control. Access maps through type-safe interfaces. [&nbsp;**▶**&nbsp;Check&nbsp;it&nbsp;out!](http://manifold.systems/images/structural%20typing.mp4)
```java
Map<String, Object> map = new HashMap<>();
MyThingInterface thing = (MyThingInterface) map; // O_o
thing.setFoo(new Foo());
Foo foo = thing.getFoo();
out.println(thing.getClass()); // prints "java.util.HashMap"
```
 
### [Type-safe Reflection](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#type-safe-reflection-via-jailbreak)
Access private features with <b>@Jailbreak</b> to avoid the drudgery and vulnerability of Java reflection. [&nbsp;**▶**&nbsp;Check&nbsp;it&nbsp;out!](http://manifold.systems/images/jailbreak.mp4) 
```java
@Jailbreak Foo foo = new Foo();
// Direct, *type-safe* access to *all* foo's members
foo.privateMethod(x, y, z);
foo.privateField = value;
```

### [Checked Exception Handling](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-exceptions)
You now have an option to make checked exceptions behave like unchecked exceptions!  No more unintended exception
swallowing. No more *try*/*catch*/*wrap*/*rethrow* boilerplate!
```java
List<String> strings = ...;
List<URL> urls = list
  .map(URL::new) // No need to handle the MalformedURLException!
  .collect(Collectors.toList());
```

### [String Templates](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-strings)
Embed variables and expressions in String literals, no more clunky string concat! [&nbsp;**▶**&nbsp;Check&nbsp;it&nbsp;out!](http://manifold.systems/images/string_interpolation.mp4)
```java
int hour = 15;
// Simple variable access with '$'
String result = "The hour is $hour"; // Yes!!!
// Use expressions with '${}'
result = "It is ${hour > 12 ? hour-12 : hour} o'clock";
``` 
       
### [A *Java* Template Engine](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-templates)
Author template files with the full expressive power of Java, use your templates directly in your code as types.
Supports type-safe inclusion of other templates, shared layouts, and more. [&nbsp;**▶**&nbsp;Check&nbsp;it&nbsp;out!](http://manifold.systems/images/mantl.mp4)
```java
List<User> users = ...;
String content = abc.example.UserSample.render(users);
```
A template file `abc/example/UserSample.html.mtl`
```html
<%@ import java.util.List %>
<%@ import com.example.User %>
<%@ params(List<User> users) %>
<html lang="en">
<body>
<% users.stream()
   .filter(user -> user.getDateOfBirth() != null)
   .forEach(user -> { %>
    User: ${user.getName()} <br>
    DOB: ${user.getDateOfBirth()} <br>
<% }); %>
</body>
</html>
```

### [IntelliJ](http://manifold.systems/docs.html#ide--intellij-idea)
Use the [Manifold IntelliJ IDEA plugin](https://plugins.jetbrains.com/plugin/10057-manifold) to fully leverage
Manifold in your development cycle. The plugin provides comprehensive support for IntelliJ features including code
completion, navigation, usage searching, refactoring, incremental compilation, hotswap debugging, full-featured
template editing, integrated preprocessor, and more.

<p><img src="http://manifold.systems/images/ManifoldPlugin.png" alt="manifold ij plugin" width="60%" height="60%"/></p>

>Note the Manifold Plugin for IntelliJ IDEA is **free** for use with IntelliJ IDEA **Community Edition** which like
the Manifold project is free and open source. The plugin is also commercially available on a trial basis via the
JetBrains Marketplace for use with IntelliJ IDEA **Ultimate Edition**.

### [Projects](http://manifold.systems/projects.html)
The Manifold project consists of the core Manifold framework and a collection of sub-projects implementing SPIs provided
by the core framework. Each project represents a separate **dependency** you can easily add to your project:

[Manifold : _Core_](https://github.com/manifold-systems/manifold/tree/master/manifold-core-parent/manifold)<br>

[Manifold : _GraphQL_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-graphql)<br>
[Manifold : _XML_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-xml)<br>
[Manifold : _JSON_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-json)<br>
[Manifold : _CSV_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-csv)<br>
[Manifold : _YAML_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-yaml)<br>
[Manifold : _Properties_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-properties)<br>
[Manifold : _Image_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-image)<br>
[Manifold : _Dark Java_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-darkj)<br>
[Manifold : _JavaScript_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-js)<br>

[Manifold : _Java Extensions_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext)<br>

[Manifold : _Java Template Engine_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-templates)<br>

[Manifold : _String Interpolation_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-strings)<br>
[Manifold : _[Un]checked Exceptions_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-exceptions)<br>

[Manifold : _Preprocessor_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-preprocessor)<br>

[Manifold : _Science_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-science)<br>

[Manifold : _Collections_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-collections)<br>
[Manifold : _I/0_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-io)<br>
[Manifold : _Text_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-text)<br>

[Manifold : _All&nbsp;&nbsp;(Fat JAR)_](https://github.com/manifold-systems/manifold/tree/master/manifold-all)<br>

>Experiment with sample projects:<br>
>* [Manifold : _Sample App_](https://github.com/manifold-systems/manifold-sample-project)<br>
>* [Manifold : _Sample GraphQL App_](https://github.com/manifold-systems/manifold-sample-graphql-app)<br>
>* [Manifold : _Sample REST API App_](https://github.com/manifold-systems/manifold-sample-rest-api)<br>
>* [Manifold : _Sample Web App_](https://github.com/manifold-systems/manifold-sample-web-app)
>* [Manifold : _Gradle Example Project_](https://github.com/manifold-systems/manifold-simple-gradle-project)
<br>

### [Learn More](http://manifold.systems/docs.html)
<br>
---
name: Bug report
about: Create a report to help us improve

---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1.
2.
3.

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem (drag/drop them here).

**Desktop (please complete the following information):**
- OS Type & Version: 
- Java/JDK version:
- IntelliJ IDEA version:
- Manifold version:
- Manifold IntelliJ plugin version: 

**Additional context**
Add any other context about the problem here.

**Stack trace**
Please include a stack trace if applicable
---
name: Feature request
about: Suggest an idea for this project

---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.
---
name: Question or Comment?
about: Ask a question or leave a comment

---

Have a question or something to say?  This is the place.  Check out the Manifold FAQ at  http://manifold.systems/faq.html
---
layout: default
---

# Manifold Cheat Sheet

>#### [IntelliJ IDEA](http://manifold.systems/docs.html#ide--intellij-idea)
>Manifold is best experienced in IntelliJ IDEA. The Manifold plugin provides comprehensive support for IntelliJ features 
including code completion, navigation, usage searching, refactoring, incremental compilation, hotswap debugging, 
full-featured ManTL template editing, and more. 
>
>Install the plugin directly from IntelliJ:
>
><kbd>Settings</kbd> ➜ <kbd>Plugins</kbd> ➜ <kbd>Marketplace</kbd> ➜ search: `Manifold`

## Sample Projects

Clone the [Manifold sample project](https://github.com/manifold-systems/manifold-sample-project) to for a nice
breadthwise demonstration of features.

Clone the [Manifold sample GraphQL project](https://github.com/manifold-systems/manifold-sample-graphql-app) to learn
more about application design with GraphQL using Manifold.

Clone the [Manifold sample REST API project](https://github.com/manifold-systems/manifold-sample-rest-api) to quickly
begin experimenting with a JSON Schema REST API using Manifold.

Clone the [Manifold sample Web App project](https://github.com/manifold-systems/manifold-sample-web-app) to get hooked
on ManTL templates with the Manifold IntelliJ plugin.

Clone the [Manifold : _Gradle Example Project_](https://github.com/manifold-systems/manifold-simple-gradle-project) to
learn how to setup a Manifold project with Gradle.

## Screencasts

* [GraphQL](http://manifold.systems/images/graphql.mp4)
<p>
  <video height="60%" width="60%" controls="controls" preload="auto" onclick="this.paused ? this.play() : this.pause();">
    <source type="video/mp4" src="/images/graphql.mp4">
  </video>
</p>

* [JSON Schema](http://manifold.systems/images/json.mp4)
<p>
  <video height="60%" width="60%" controls="controls" preload="auto" onclick="this.paused ? this.play() : this.pause();">
    <source type="video/mp4" src="/images/json.mp4">
  </video>
</p>
  
* [Extension Methods](http://manifold.systems/images/ExtensionMethod.mp4)
<p>
  <video height="60%" width="60%" controls="controls" preload="auto" onclick="this.paused ? this.play() : this.pause();">
    <source type="video/mp4" src="/images/ExtensionMethod.mp4">
  </video>
</p>

* [Structural Typing](http://manifold.systems/images/structural%20typing.mp4)
<p>
  <video height="60%" width="60%" controls="controls" preload="auto" onclick="this.paused ? this.play() : this.pause();">
    <source type="video/mp4" src="/images/structural%20typing.mp4">
  </video>
</p>

* [Type-safe Reflection (**@Jailbreak**)](http://manifold.systems/images/jailbreak.mp4) 
<p>
  <video height="60%" width="60%" controls="controls" preload="auto" onclick="this.paused ? this.play() : this.pause();">
    <source type="video/mp4" src="/images/jailbreak.mp4">
  </video>
</p>

* [String Templates (aka Interpolation)](http://manifold.systems/images/string_interpolation.mp4)
<p>
  <video height="60%" width="60%" controls="controls" preload="auto" onclick="this.paused ? this.play() : this.pause();">
    <source type="video/mp4" src="/images/string_interpolation.mp4">
  </video>
</p>

* [Manifold Template Language (ManTL)](http://manifold.systems/images/mantl.mp4)
<p>
  <video height="60%" width="60%" controls="controls" preload="auto" onclick="this.paused ? this.play() : this.pause();">
    <source type="video/mp4" src="/images/mantl.mp4">
  </video>
</p>

## [Metaprogramming](http://manifold.systems/docs.html)
Gain direct, **type-safe** access to *any* type of data. Remove the code gen step in your build process.

### Resources
Put data files in your `resource path`.

A typical <b>Maven</b> setup:
```text
src
-- main
---- java
------ <your .java files>
---- resources
------ <your .png, .json, .graphql, .mtl, and other resource files>
```

### [JSON & JSON Schema](http://manifold.systems/docs.html#json-and-json-schema)

You can use both sample JSON files and JSON Schema files.

`resources/abc/Person.json`
```json
{
  "Name": "Joe Jayson",
  "Age": 39,
...
}
```
Use `Person.json` as a JSON-by-example schema: 
```java 
import abc.Person;
...
Person person = Person.fromJsonUrl(url);
person.setFirstName("Scott");
```
Or use JSON Schema files:
`resources/abc/Contact.json`
Here is a simple `User` type defined in `resources/abc/User.json` using JSON Schema:
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "http://example.com/schemas/User.json",
  "type": "object",
  "definitions": {
    "Gender": {
      "type": "string",
      "enum": ["male", "female"]
    }
  },
  "properties": {
    "name": {
      "type": "string",
      "description": "User's full name.",
      "maxLength": 80
    },
    "email": {
      "description": "User's email.",
      "type": "string",
      "format": "email"
    },
    "date_of_birth": {
      "type": "string",
      "description": "Date of uses birth in the one and only date standard: ISO 8601.",
      "format": "date"
    },
    "gender": {
      "$ref" : "#/definitions/Gender"
    }
  },
  "required": ["name", "email"]
}
```
You can use this to create a new instance of the `User` type and then modify it using _setter_ methods to change
optional properties:
```java
import abc.User;
import abc.User.Gender;
import java.time.LocalDate;
...
User user = User.create("Scott McKinney", "scott@manifold.systems");
user.setGender(Gender.male);
user.setDate_of_birth(LocalDate.of(1980, 7, 4));
```

Alternatively, you can use `builder()` to fluently build a new instance:
```java
User user = User.builder("Scott McKinney", "scott@manifold.systems")
  .withGender(Gender.male)
  .withDate_of_birth(LocalDate.of(1980, 7, 4))
  .build();
```
You can load a `User` instance from a String:
```java
// From a YAML string
User user = User.load().fromYaml(
  "name: Scott McKinney\n" +
  "email: scott@manifold.systems\n" +
  "gender: male\n" +
  "date_of_birth: 1980-07-04"
 );
```

Load from a file:
```java
// From a JSON file
User user = User.load().fromJsonFile("/path/to/MyUser.json");
```

You can invoke a REST API to fetch a `User` using HTTP GET:
```java
// Uses HTTP GET to invoke the API
User user = User.load().fromJsonUrl("http://api.example.com/users/$userId");
```

#### Request REST API services
Use the `request()` static method to conveniently navigate an HTTP REST API with GET, POST, PUT, PATCH, & DELETE:
```java
String id = "scott";
User user = User.request("http://api.example.com/users").getOne("/$id");
```
The `request()` method provides support for all basic REST API client usage:
```java
Requester<User> req = User.request("http://api.example.com/users");

// Get all Users via HTTP GET
IJsonList<User> users = req.getMany();

// Add a User with HTTP POST
User user = User.builder("scott", "mypassword", "Scott")
  .withGender(male)
  .build();
req.postOne(user);

// Get a User with HTTP GET
String id = user.getId();
user = req.getOne("/$id");

// Update a User with HTTP PUT
user.setDob(LocalDate.of(1980, 7, 7));
req.putOne("/$id", user);

// Delete a User with HTTP DELETE
req.delete("/$id");
```
> Clone the [Manifold sample REST API project](https://github.com/manifold-systems/manifold-sample-rest-api) to quickly
begin experimenting with a JSON Schema REST API using Manifold.

#### Writing JSON
An instance of a JSON API object can be written as formatted text with `write()`:
* `toJson()` - produces a JSON formatted String
* `toYaml()` - produces a YAML formatted String
* `toXml()` - produces an XML formatted String
* `toCsv()` - produces a CSV formatted String

The following example produces a JSON formatted string:
```java
User user = User.builder("Scott McKinney", "scott@manifold.systems")
  .withGender(Gender.male)
  .withDate_of_birth(LocalDate.of(1980, 7, 4))
  .build();

String json = user.write().toJson();
System.out.println(json);
```
Output:
```json
{
  "name": "Scott McKinney",
  "email": "scott@manifold.systems",
  "gender": "male",
  "date_of_birth": "1980-07-04"
}
```

### [YAML](http://manifold.systems/docs.html#json-and-json-schema)

Manifold fully supports YAML 1.2.  You can use YAML to build JSON Schema files as well.  All that applies to JSON applie to YAML.


### [Properties](http://manifold.systems/docs.html#properties-files)
Avoid strings, access properties type-safely:

`resources/abc/MyProperties.properties`
```properties
chocolate = Chocolate
chocolate.milk = Milk chocolate
chocolate.dark = Dark chocolate
``` 
```java
String myMessage = MyProperties.chocolate.milk;
```

### [Images](http://manifold.systems/docs.html#image-files)
Gain direct type-safe access to all your project's images, efficiently cached:

`resources/abc/images/companyLogo.png`
```java
import abc.images.*;
...
ImageIcon image = companyLogo_png.get();
render(image);
```

### [JavaScript](http://manifold.systems/docs.html#javascript)

`resources/abc/MyJsProgram.js`:
```javascript
var x = 1;

function nextNumber() {
  return x++;
}

function doSomething(x) {
  return x + " from Javascript";
}
```

A JavaScript file and its members are directly accessible as a Java class:

```java
import abc.MyJsProgram;
...
String hello = MyJsProgram.doSomething("Hello");
System.out.println(hello); // prints 'Hello from JavaScript'

double next = JsProgram.nextNumber();
System.out.println(next); // prints '1'
```

## [String Templates](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-strings) (aka string interpolation)
### Enabling

Enable the feature with the `manifold-strings` dependency:
```xml
<dependency>
  <groupId>systems.manifold</groupId>
  <artifactId>manifold-strings</artifactId>
  <!-- it is best to use the latest release -->
  <version>2019.1.32</version>
</dependency>
```

### Using
A **String template** lets you use the `$` character to embed a Java expression directly into a String.  You can 
use `$` to embed a simple variable:
```java
int hour = 8;
String time = "It is $hour o'clock";  // prints "It is 8 o'clock"
```
Or you can embed an expression of any complexity in curly braces:
```java
LocalTime localTime = LocalTime.now();
String ltime = "It is ${localTime.getHour()}:${localTime.getMinute()}"; // prints "It is 8:39"
```
Escape the `$` with `\$`.

Use `@DisableStringLiteralTemplates` to turn string templates off at the class and method levels.  

## [Extensions](http://manifold.systems/docs.html#the-extension-manifold)

### Basic
Add your own methods to any class e.g., `java.lang.String`:

Make a class in a package named `extensions`. Create a sub-package using the full name of the class you want to extend,
in this case `java.lang.String`:
    
```java
package abc.extensions.java.lang.String;

import manifold.ext.api.*;

@Extension
public class MyStringExtension {

  public static void print(@This String thiz) {
    System.out.println(thiz);
  }

  @Extension // required for static extension methods
  public static String lineSeparator() {
    return System.lineSeparator();
  }
}
```
Now the methods are available directly from `String`:
```java
String hello = "hello";
hello.print();

// static method
String.lineSeparator();
```

### Generics
Here `map` is a generic extension method on `Collection` having type variable `R` and conveying `Collection`'s type
variable `E`. Extension methods must reflect the type variable names declared in the extended class.
```java
public static <E, R> Stream<R> map(@This Collection<E> thiz, Function<? super E, R> mapper) {
  return thiz.stream().map(mapper);
}
```

## [@Structural - Structural Interfaces](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#structural-interfaces-via-structural)
Unify disparate APIs. Bridge software components you do not control. Access maps through type-safe interfaces.
```java
@Structural
public interface Coordinate {
  double getX();
  double getY();
}
```
Structural interface applied to `java.awt.Rectangle`:
```java
setLocation((Coordinate)new Rectangle(10, 10, 100, 100));
...
void setLocation(Coordinate location) {
  this.location = location;
}
```
Structural interface applied to `java.util.HashMap` via `ICallHandler`:
```java
Map<String,Integer> map = new HashMap<>();
map.put("x", 10);
map.put("y", 10);

Coordinate coord = (Coordinate)map;
double x = coord.getX();
``` 
  
## [@Jailbreak - Type-safe Reflection](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#type-safe-reflection-via-jailbreak)
Access private features with <b>@Jailbreak</b> to avoid the drudgery and vulnerability of Java reflection.
### Basic
```java
@Jailbreak Foo foo = new Foo(1);
foo.privateMethod();
foo.privateMethod("hey");
foo._privateField = 88;
```
```java
public class Foo {
  private final int _privateField;
  
  public Foo(int value) {
    _privateField = value;
  }
  
  private String privateMethod() {
    return "hi";
  }
  
  private String privateMethod(String param) {
    return param;
  }
}
```
### Static Members
```java
@Jailbreak MyClass myClass = null; // value is insignificant
myClass.staticMethod();
myClass.Static_Field = "hi";
```
```java
public class MyClass {
  private static String Static_Field = "hello";
  
  private static void staticMethod() {
  }
}
```

### Types and Constructors
```java
com.abc. @Jailbreak SecretClass secretClass = 
  new com.abc. @Jailbreak SecretClass("hi");
secretClass._data = "hey";
```

## [@Self - The Self Type](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#the-self-type-via-self)

Manifold supports the *Self* type via the `@Self` annotation. Use `@Self` with method return types, parameter types, and
field types to enforce `subtype of this` where suitable.  Use `@Self` as a simpler, more versatile alternative to Java's
recursive generic types.

### `equals()`

You can use `@Self` to make methods like `equals()` type-safe:
```java
public class MyClass {
  @Override
  public boolean equals(@Self Object obj) {
    ...
  }
}
```
Now your equals() method enforces `MyClass` as the parameter:
```java
myClass.equals("notMyClass"); // Compile Error. :)
```

### Builders

A common use-case for the Self type involves fluent APIs like the *Builder* pattern:

```java
public class VehicleBuilder {
  private int _wheels;

  public VehicleBuilder withWheels(int wheels) {
    _wheels = wheels;
    return this; // returns THIS
  }
}
```

This is fine until we subclass it:

```java
public class AirplaneBuilder extends VehicleBuilder {
  private int _wings;

  public AirplaneBuilder withWings(int wings) {
    _wings = wings;
    return this; // returns THIS
  }
}

...

Airplane airplane = new AirplaneBuilder()
  .withWheels(3) // returns VehicleBuilder :(
  .withWings(1)  // ERROR
```

`withWheels()` returns `VehicleBuilder`, not `AirplaneBuilder`.  This is a classic example where we want to return the
*"the subtype of `this`"*.  This is what the self type accomplishes:

```java
  public @Self VehicleBuilder withWheels(int wheels) {
    _wheels = wheels;
    return this; // returns THIS
  }
```

Now with the return type annotated with `@Self` the example works as desired:

```java
Airplane airplane = new AirplaneBuilder()
  .withWheels(2) // returns AirplaneBuilder :)
  .withWings(1)  // GOOD!
```

Annotate with `@Self` to preserve the *"the subtype of `this`"* anywhere on or in a method return type, parameter type,
or field type.

### Self + Generics

You can also use `@Self` to annotate a _type argument_.  A nice example of this involves a typical graph or tree
structure where the nodes in the structure are homogeneous:

```java
public class Node {
  private List<Node> children;

  public List<@Self Node> getChildren() {
    return children;
  }

  public void addChild(@Self Node child) {
    children.add(child);
  }
}

public class MyNode extends Node {
  ...
}
```

Here you can make the component type of `List` the Self type so you can use the `getChildren` method type-safely from
subtypes of node:

```java
MyNode myNode = findMyNode();
List<MyNode> = myNode.getChildren(); // wunderbar!
```

### Self + Extensions

You can use `@Self` with [extension methods](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#extension-classes-via-extension)
too.  Here we make an extension method as a means to conveniently chain additions to `Map` while preserving its concrete
type:

```java
public static <K,V> @Self Map<K,V> add(@This Map<K,V> thiz, K key, V value) {
  thiz.put(key, value);
  return thiz;
}

HashMap<String, String> map = new HashMap<>()
  .add("nick", "grouper")
  .add("miles", "amberjack");
  .add("alec", "barracuda")
```

### Overriding Methods

Using @Self in a method return type or parameter type has _no_ effect on the method's override characteristics or binary
signature:
```java
public class SinglyNode {
  private @Self SinglyNode next;

  public void setNext(@Self SinglyNode next) {
    this.next = next;
  }
}

public class DoublyNode extends SinglyNode {
  private @Self DoublyNode prev;

  public void setNext(@Self SinglyNode next) {
    if(next instanceof DoublyNode) {
      super.setNext(next);
      ((DoublyNode)next).prev = this;
    }
    else {
      throw new IllegalArgumentException();
    }
  }
}
```

## [Checked Exception Handling](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-exceptions)
Simply add the `manifold-exceptions` dependency to your project. Now checked exceptions behave like unchecked
exceptions!  No more compiler errors, no more boilerplate `try`/`catch`/`wrap`/`rethrow` nonsense.
```java
List<String> strings = ...;
List<URL> urls = list
  .map(URL::new) // No need to handle the MalformedURLException!
  .collect(Collectors.toList());
```

To use Checked Exception handling you must add the `manifold-exceptions` dependency to your build configuration:
```xml
<dependency>
  <groupId>systems.manifold</groupId>
  <artifactId>manifold-exceptions</artifactId>
  <!-- it is best to use the latest release -->
  <version>2019.1.32</version>
</dependency>
```

## [ManTL](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-templates) (Superfast **type-safe** templates, and a lot more)

## [Libraries](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#extension-libraries)
Leverage stock Manifold extension libraries for standard Java classes. Save time and reduce boilerplate code.
```java
File file = new File(path);
// Use refreshing extensions to File
String content = file.readText();
```  
Use the `manifold-all` dependency to access all Manifold's provided extension libraries including I/O, Web, and 
Collections.

## [Learn More](http://manifold.systems/docs.html)
---
layout: default
---

## Table of Contents
* [Overview](#overview)
* [Type-safe Metaprogramming](#type-safe-metaprogramming-via-_type-manifolds_)
* [Java Extensions via the _Extension_ Manifold](#java-extensions-via-the-_extension_-manifold)
* [Benefits](#benefits)
* [Projects](#projects)
* [IDE Support](#ide-support)
* [**Setup**](#setup)
* [Download](#download)
* [License](#license)
* [Author](#author)

# Overview

[Manifold](https://manifold.systems/) plugs directly into Java to supplement it with powerful features you can use
directly in your projects:

* [**Type-safe Metaprogramming**](https://github.com/manifold-systems/manifold/tree/master/manifold-core-parent/manifold) -- _type-safe_ access to structured data.
Use [GraphQL](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-graphql),
[XML](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-xml), 
[JSON](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-json), 
[YAML](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-yaml), 
[CSV](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-csv), 
[JavaScript](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-js),
[Templates](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-templates), etc.
directly and type-safely from Java without a code generator in your build and with comprehensive IDE support. 
* [**Java Extensions**](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext) --
provides extension methods (like [C#](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods)),
[operator overloading](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#operator-overloading),
[unit expressions](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#unit-expressions),
structural typing (like [TypeScript](https://www.typescriptlang.org/docs/handbook/interfaces.html)),
string interpolation (like [Kotlin](https://kotlinlang.org/docs/reference/basic-types.html#string-templates)),
type-safe reflection (via [`@Jailbreak`](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-collections#type-safe-reflection-via-jailbreak)),
and a lot more.


# Type-safe Metaprogramming via _Type Manifolds_ 

Bridging the worlds of data and code, a *type manifold* acts as an adapter to automatically connect data resources to
Java's type system.  The core Manifold framework seamlessly plugs into the Java compiler enabling a type manifold to
transform structured data into a data _type_ directly accessible in your Java code eliminating code generation build
steps otherwise required with conventional tools. Additionally the [Manifold plugin for IntelliJ IDEA](#ide-support)
provides comprehensive integration for type manifolds. Types are always in sync; changes you make to resources are
immediately available in the type system _without a compilation step_.  Code completion, navigation, usage searching,
refactoring, incremental compilation, hotswap debugging -- all seamlessly integrated.  With type manifolds a data file
is a virtual data _type_.

To illustrate, consider this simple properties resource file:

`/abc/MyProperties.properties`
```properties
chocolate = Chocolate
chocolate.milk = Milk chocolate
chocolate.dark = Dark chocolate
``` 

Normally in Java you access a properties file like this:

```java
Properties myProperties = new Properties();
myProperties.load(getClass().getResourceAsStream("/abc/MyProperties.properties"));
String myMessage = myProperties.getProperty("chocolate.milk");
```

As with any resource file a properties file is foreign to Java's type system -- there is no direct, type-safe access to
it. Instead you access it indirectly using boilerplate library code sprinkled with hard-coded strings.

By contrast, with the Properties type manifold you access a properties file directly as a type:

```java
String myMessage = MyProperties.chocolate.milk;
```

Concise and type-safe, with no additional build steps to engage.

Any data resource is a potential type manifold, including file schemas, query languages, database definitions, 
data services, templates, spreadsheets, and programming languages.

Manifold provides type manifolds for:

*   [GraphQL](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-graphql)
*   [JSON and JSON Schema](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-json)
*   [XML](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-xml)
*   [YAML](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-yaml)
*   [CSV](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-csv)
*   [Properties files](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-properties)
*   [Image files](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-image)
*   [Dark Java](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-darkj)
*   [JavaScript](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-js)
*   [Java Templates](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-templates)

# Java Extensions via the _Extension_ Manifold

The extension manifold is a special kind of type manifold that lets you augment existing Java classes including Java's
own runtime classes such as `String`. You can add new methods, annotations, and interfaces to any type your project
uses.

Let's say you want to make a new method on `String` so you can straightforwardly echo a String to the console. Normally
with Java you might write a "Util" library like this:

```java
public class MyStringUtil {
  public static void echo(String value) {
    System.out.println(value);
  }
}
```

And you'd use it like this:

```java
MyStringUtil.echo("Java");
```

Instead with Manifold you create an _**Extension Class**_:

```java
@Extension
public class MyStringExtension {
  public static void echo(@This String thiz) {
    System.out.println(thiz);
  }
}
```  

Here we've added a new `echo()` method to `String`, so we use it like this:

```java
"Java".echo();
```

Extensions eliminate a lot of intermediate code such as "Util" and "Manager" libraries as well as Factory classes. As a
consequence extensions naturally promote higher levels of object-orientation, which result in more readable and
maintainable code. Additionally, with the Manifold IntelliJ plugin you can use code-completion which conveniently
presents all the extension methods available on an extended class:

<p>
  <video height="60%" width="60%" controls="controls" preload="auto" onclick="this.paused ? this.play() : this.pause();">
    <source type="video/mp4" src="/images/ExtensionMethod.mp4">
  </video>
</p>

There's a lot more to the extension manifold including [operator overloading](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#operator-overloading),
[unit expressions](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#unit-expressions),
[structural interfaces](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#structural-interfaces-via-structural),
which are similar to interfaces in the [Go](https://golang.org/) and [TypeScript](https://www.typescriptlang.org/docs/handbook/interfaces.html)
languages. See the [Java Extension Manifold](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext)
for full coverage of these features.


# Benefits

Manifold's core technology is a dramatic departure from conventional Java tooling. There are no code generation steps in
the build, no extra build target files to manage, no annotation processors, and no extra class loaders to engage at
runtime.

Benefits of this approach include:

*   **Zero turnaround** -- direct, type-safe access to structured data
*   **Lightweight** -- requires no special compilers, annotation processors, or runtime agents
*   **Efficient** -- Manifold only produces types as they are needed
*   **Simple, open API** -- use the Manifold API to build your own components and extensions
*   **No code generation build step** -- integrates directly with the Java compiler
*   **Incremental** -- only builds types that have changed
*   **[IntelliJ IDEA](https://www.jetbrains.com/idea/download)** support -- all manifold types and extensions work with IntelliJ

Manifold is just a dependency you can drop into your existing project -- you can begin using it incrementally without
having to rewrite classes or conform to a new way of doing things.

# IDE Support

Use the [Manifold IntelliJ IDEA plugin](https://plugins.jetbrains.com/plugin/10057-manifold) to experience Manifold to its fullest.

The plugin currently supports most high-level IntelliJ features including:
* Feature highlighting
* Error reporting
* Code completion
* Go to declaration
* Usage searching
* Rename/Move refactoring
* Quick navigation
* Operator overloading
* Unit expressions
* Structural typing
* Type-safe reflection with `@Jailbreak`
* Self type support with `@Self`
* Incremental compilation
* Hotswap debugging
* Preprocessor (conditional compilation)
* Professional template file editor

The IntelliJ plugin provides comprehensive support for Manifold. Use code completion to discover and use type manifolds,
extension methods and structural interfaces. Jump directly from usages of extension methods to their declarations.
Likewise, jump directly from references to resource elements and find usages of them in your code. Watch your
JSON/YAML/XML/CSV, images, properties, templates, and custom type manifolds come alive as types. Changes you make are
instantly available in your code.

Install the plugin directly from IntelliJ via:

<kbd>Settings</kbd> ➜ <kbd>Plugins</kbd> ➜ <kbd>Marketplace</kbd> ➜ search: `Manifold`

# Projects

The Manifold framework consists of the *core project* and a collection of *sub-projects* implementing SPIs provided
by the core. Each project represents a separate *dependency* you can use directly in your project. See details in each
projects' docs.

### Core Framework
* [Manifold : _Core_](https://github.com/manifold-systems/manifold/tree/master/manifold-core-parent/manifold)

### Resource Manifolds
* [Manifold : _GraphQL_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-graphql)
* [Manifold : _JSON_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-json)
* [Manifold : _XML_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-xml)
* [Manifold : _CSV_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-csv)
* [Manifold : _YAML_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-yaml)
* [Manifold : _Properties_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-properties)
* [Manifold : _Image_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-image)
* [Manifold : _Dark Java_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-darkj)
* [Manifold : _JavaScript_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-js)

### Java Extension Manifold
* [Manifold : _Java Extension_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext)

### Java Templates Framework
* [Manifold : _Templates_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-templates)

### Java Compiler Extensions
* [Manifold : _String Templates_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-strings) <small>(string interpolation)</small>
* [Manifold : _[Un]checked_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-exceptions)

### Java Preprocessor
* [Manifold : _Preprocessor_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-preprocessor)

### Java Science
* [Manifold : _Science_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-science)

### Java Extension Libraries 
* [Manifold : _Collections_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-collections)
* [Manifold : _I/0_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-io)
* [Manifold : _Text_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-text)

### Manifold "Fat" Jar
[Manifold : _All&nbsp;&nbsp;(Über jar)_](https://github.com/manifold-systems/manifold/tree/master/manifold-all)

### Sample Projects
* [Manifold sample project](https://github.com/manifold-systems/manifold-sample-project)
* [Manifold sample GraphQL project](https://github.com/manifold-systems/manifold-sample-graphql-app)
* [Manifold sample REST API project](https://github.com/manifold-systems/manifold-sample-rest-api)
* [Manifold sample Web App project](https://github.com/manifold-systems/manifold-sample-web-app)
* [Manifold sample Gradle Project](https://github.com/manifold-systems/manifold-simple-gradle-project)

# Setup

Manifold is designed to work with most build systems, including Maven and Gradle.

The Manifold root project consists of several sub-projects you can include separately in your build, see [Projects](#projects)
above for a complete listing. You can also integrate all Manifold dependencies into your build using the "Fat" Jar
dependency, [`manifold-all`](https://github.com/manifold-systems/manifold/tree/master/manifold-all).

Setup instructions are consistent for each sub-project/dependency.  Here are direct links:

* Setup for [Manifold : _All_](https://github.com/manifold-systems/manifold/tree/master/manifold-all#setup)

<hr/>

* Setup for [Manifold : _Core_](https://github.com/manifold-systems/manifold/tree/master/manifold-core-parent/manifold#setup)

<hr/>

* Setup for [Manifold : _GraphQL_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-graphql#setup)
* Setup for [Manifold : _XML_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-xml#setup)
* Setup for [Manifold : _JSON_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-json#setup)
* Setup for [Manifold : _CSV_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-csv#setup)
* Setup for [Manifold : _YAML_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-yaml#setup)
* Setup for [Manifold : _Properties_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-properties#setup)
* Setup for [Manifold : _Image_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-image#setup)
* Setup for [Manifold : _Dark Java_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-darkj#setup)
* Setup for [Manifold : _JavaScript_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-js#setup)

<hr/>

* Setup for [Manifold : _Java Extension_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#setup)

<hr/>

* Setup for [Manifold : _Templates_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-templates#setup)

<hr/>

* Setup for [Manifold : _String Templates_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-strings#setup)
* Setup for [Manifold : _[Un]checked_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-exceptions#setup)

<hr/>

* Setup for [Manifold : _Preprocessor_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-preprocessor#setup)

<hr/>

* Setup for [Manifold : _Science_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-science#setup)

<hr/>
 
* Setup for [Manifold : _Collections_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-collections#setup)
* Setup for [Manifold : _I/0_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-io#setup)
* Setup for [Manifold : _Text_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-text#setup)


# Download

For the convenience of non-maven/non-gradle users you can directly download latest release binaries below. Note, if you
plan to build your project *without* Maven or Gradle using select binaries (as opposed to manifold-all), your classpath
must include the transitive closure of binaries in terms of the *dependencies* declared in corresponding project's POM
file. Additionally, you will need to adapt your build to reflect the Maven or Gradle setup instructions from the list
above.

* Download [manifold : _All_](https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=systems.manifold&a=manifold-all&v=RELEASE):

<hr/>

* Download [Manifold : _Core_](https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=systems.manifold&a=manifold&v=RELEASE)

<hr/>

* Download [Manifold : _GraphQL_](https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=systems.manifold&a=manifold-graphql&v=RELEASE)
* Download [Manifold : _XML_](https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=systems.manifold&a=manifold-xml&v=RELEASE)
* Download [Manifold : _JSON_](https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=systems.manifold&a=manifold-json&v=RELEASE)
* Download [Manifold : _CSV_](https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=systems.manifold&a=manifold-csv&v=RELEASE)
* Download [Manifold : _YAML_](https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=systems.manifold&a=manifold-yaml&v=RELEASE)
* Download [Manifold : _Properties_](https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=systems.manifold&a=manifold-properties&v=RELEASE)
* Download [Manifold : _Image_](https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=systems.manifold&a=manifold-image&v=RELEASE)
* Download [Manifold : _Dark Java_](https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=systems.manifold&a=manifold-darkj&v=RELEASE)
* Download [Manifold : _JavaScript_](https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=systems.manifold&a=manifold-js&v=RELEASE)

<hr/>

* Download [Manifold : _Java Extension_](https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=systems.manifold&a=manifold-ext&v=RELEASE)

<hr/>

* Download [Manifold : _Templates_](https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=systems.manifold&a=manifold-templates&v=RELEASE)

<hr/>

* Download [Manifold : _String Templates_](https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=systems.manifold&a=manifold-strings&v=RELEASE)
* Download [Manifold : _[Un]checked_](https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=systems.manifold&a=manifold-exceptions&v=RELEASE)

<hr/>

* Download [Manifold : _Preprocessor_](https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=systems.manifold&a=manifold-preprocessor&v=RELEASE)

<hr/>

* Download [Manifold : _Science_](https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=systems.manifold&a=manifold-science&v=RELEASE)

<hr/>
 
* Download [Manifold : _Collections_](https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=systems.manifold&a=manifold-collections&v=RELEASE)
* Download [Manifold : _I/0_](https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=systems.manifold&a=manifold-io&v=RELEASE)
* Download [Manifold : _Text_](https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=systems.manifold&a=manifold-text&v=RELEASE)

# License

## Open Source
Manifold is licensed under the [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0) license.  

## Commercial
Commercial licenses for this work are available. These replace the above ASL 2.0 and offer limited warranties, support,
maintenance, and commercial server integrations.

For more information contact: [admin@manifold.systems](mailto:admin@manifold.systems)

# Author

* [Scott McKinney](mailto:scott@manifold.systems)---
layout: default
---

# Manifold F.A.Q.s - Frequently Asked Questions (and Answers)

[Common Questions](#common-questions) • [Getting Help](#getting-help) • [Troubleshooting](#troubleshooting)


## Common Questions

#### Q: Does Manifold support Java 11? 13? 8?
Yes.  Manifold fully supports Java 8 - 13.  Manifold also fully supports the Java Platform Module System (JPMS).  See the
[Setup Guide](http://manifold.systems/docs.html#setup) for more info.

#### Q: Manifold is somehow using Java internal APIs to do its magic. Could it break in a future version of Java?
Unlikely.  Java internal APIs can change from version to version, however Manifold always adjusts to changes ahead of Java
releases.  To understand this better consider Manifold currently works equally well with Java versions 8, 9, 10, 11, 12,
and 13. Over time the internal APIs do indeed change, yet Manifold continues to adapt and improve along the way.

#### Q: Is Manifold free?
Yes, the Manifold project is [open source](https://github.com/manifold-systems/manifold) and publicly available on
github, free for use via Apache License 2.0.

Note the Manifold [IntelliJ plugin](https://plugins.jetbrains.com/plugin/10057-manifold/) is offered separately via
the JetBrains Marketplace. It is *free* for use with IntelliJ IDEA *Community Edition* and is licensed for use with
IntelliJ IDEA *Ultimate Edition*. The plugin remains free for students and faculty using Ultimate. Other discounts apply
and are available from the JetBrains Marketplace.


#### Q: Does Manifold work with Maven?  Gradle?
Yes.  Please refer to the [Setup](http://manifold.systems/docs.html#setup) instructions. 

#### Q: Does Manifold provide IDE support?
Yes.  [IntelliJ IDEA](https://plugins.jetbrains.com/plugin/10057-manifold) provides comprehensive support for Manifold.
Download / Update the plugin directly from within IntelliJ:

<kbd>Settings</kbd> ➜ <kbd>Plugins</kbd> ➜ <kbd>Marketplace</kbd> ➜ search: `Manifold` 
  
>Note: IntelliJ notifies you within 24 hours when an update is available and gives you the opportunity to sync.

#### Q: How do I get manifold-*fill-in-blank* working with my project? 
Add the manifold-*fill-in-blank* dependency to your project along with the `-Xplugin:Manifold` javac argument, the setup
is sensitive to the version of Java you are using, generally whether you are using Java 8 or 9+. See the
[Setup](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-strings#setup) docs for
complete instructions.

## Getting Help

#### Q: Where can I find help?
**Report A Bug**
The Manifold project uses github issues to track bugs, features, and other requests.  If you discover a bug, have a
feature request, or an idea go [here](https://github.com/manifold-systems/manifold/issues) and let it be known. Expect a
response within 24 hours.

**Private E-mail**
If your question or issue is more pressing or confidential, don't hesitate to send an email to [info@manifold.systems](mailto:info@manifold.systems).

**Discussions**
If you have a question or want to start a discussion add a [comment issue](https://github.com/manifold-systems/manifold/issues).

#### Q: I've read the docs page.  Can I learn more about Manifold elsewhere?

Links to recently published Manifold articles are available on the [Articles](http://manifold.systems/articles/articles.html) 
page.  There is always another article on the way, check back for more. 

## Troubleshooting

#### Q: I updated to the latest Manifold IntelliJ plugin and now IntelliJ is complaining with error messages.  What is wrong?
You probably need to update your project dependencies to use the latest manifold release.  If your project's
dependencies are out of sync, the plugin tells you which version of manifold you need with in a warning message
when you load your project.  You can find the latest releases [here](https://github.com/manifold-systems/manifold/tags).

**Important:** If you are using Maven or Gradle, you must update your build files -- do not change the Module dependencies from 
IntelliJ's UI. Please refer to the [Maven](http://manifold.systems/docs.html#maven) and [Gradle](http://manifold.systems/docs.html#gradle)
sections of the [Manifold Setup](http://manifold.systems/docs.html#setup) instructions. 

Please [make some noise](https://github.com/manifold-systems/manifold/issues) if you can't get it working, chances are
you're not alone and help will arrive soon.
---
layout: default
---

## What is Manifold?
Manifold [plugins into](https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/util/Plugin.html) Java
and supplements it with powerful features, including:
* [*Type-safe* Meta-programming](https://github.com/manifold-systems/manifold/tree/master/manifold-core-parent/manifold)
* [Extension Methods](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext)
* [Operator Overloading](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#operator-overloading)
* [Unit Expressions](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#unit-expressions)
* [A *Java* Template Engine](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-templates)
* [A Preprocessor](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-preprocessor)
* ...and more

All fully supported in Java 8 - 13 with comprehensive support in IntelliJ IDEA. Simply add Manifold to your existing
project and begin taking advantage of it.

## What can you do with Manifold?

### [Meta-programming](https://github.com/manifold-systems/manifold/tree/master/manifold-core-parent/manifold)
Use the framework to gain direct, type-safe access to *any* type of resource, such as
[**GraphQL**](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-graphql),
[**XML**](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-xml),
[**JSON**](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-json),
[**CSV**](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-csv),
[**YAML**](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-yaml), and even
other languages such as [**JavaScript**](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-js).
Remove the code gen step in your build process. [&nbsp;**▶**&nbsp;Check&nbsp;it&nbsp;out!](http://manifold.systems/images/graphql.mp4)

**GraphQL:** Use types defined in your **movies.graphql** and **queries.graphql** files *directly*, no code gen!
```java
var query = MovieQuery.builder(Action).build();
var result = query.request("http://com.example/graphql").post();
var actionMovies = result.getMovies();
for (var movie : actionMovies) {
  out.println(
    "Title: " + movie.getTitle() + "\n" +
    "Genre: " + movie.getGenre() + "\n" +
    "Year: " + movie.getReleaseDate().getYear() + "\n");
}
```

**JSON:** Use your **User.json** schema file directly as a type, no code gen!
```java
User user = User.builder("myid", "mypassword", "Scott")
  .withGender(male)
  .withDob(LocalDate.of(1987, 6, 15))
  .build();
User.request("http://api.example.com/users").postOne(user);
```

### [Extension Methods](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext)
Add your own methods to existing Java classes, even *String*, *List*, and *File*. Eliminate boilerplate code.
[&nbsp;**▶**&nbsp;Check&nbsp;it&nbsp;out!](http://manifold.systems/images/ExtensionMethod.mp4)
```java
String greeting = "hello";
greeting.myMethod(); // Add your own methods to String!
```

### [Operator Overloading](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#operator-overloading)
Implement *operator* methods on any type to directly support arithmetic, relational, and unit operators.
```java
// BigDecimal expressions
if (bigDec1 > bigDec2) {
  BigDecimal result = bigDec1 + bigDec2;
  ...
}
// Implement operators for any type
MyType value = myType1 + myType2;
```  

### [Unit Expressions](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#unit-expressions)
Unit or *binding* operations are unique to the Manifold framework. They provide a powerfully concise syntax and can be
applied to a wide range of applications.
```java
import static manifold.science.util.UnitConstants.*; // kg, m, s, ft, etc
...
Length distance = 100 mph * 3 hr;
Force f = 5.2 kg m/s/s; // same as 5.2 N
Mass infant = 9 lb + 8.71 oz;
```  

### [Ranges](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-collections#ranges)
Easily work with the *Range* API using [unit expressions]((https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#unit-expressions)).
Simply import the *RangeFun* constants to create ranges.
```java
// imports the `to`, `step`, and other "binding" constants
import static manifold.collections.api.range.RangeFun.*;
...
for (int i: 1 to 5) {
  out.println(i);
}

for (Mass m: 0kg to 10kg step 22r unit g) {
  out.println(m);
}
```

### [Science](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-science)
Use the [manifold-science](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-science)
framework to type-safely incorporate units and precise measurements into your applications.
```java
import static manifold.science.util.UnitConstants.*; // kg, m, s, ft, etc.
...
Velocity rate = 65mph;
Time time = 1min + 3.7sec;
Length distance = rate * time;
```  

### [Preprocessor](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-preprocessor)
Use familiar directives such as **#define** and **#if** to conditionally compile your Java projects. The preprocessor offers
a simple and convenient way to support multiple build targets with a single codebase. [&nbsp;**▶**&nbsp;Check&nbsp;it&nbsp;out!](http://manifold.systems/images/preprocessor.mp4)
```java
#if JAVA_8_OR_LATER
  @Override
  public void setTime(LocalDateTime time) {...)
#else
  @Override
  public void setTime(Calendar time) {...}
#endif
```   

### [Structural Typing](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#structural-interfaces-via-structural)
Unify disparate APIs. Bridge software components you do not control. Access maps through type-safe interfaces. [&nbsp;**▶**&nbsp;Check&nbsp;it&nbsp;out!](http://manifold.systems/images/structural%20typing.mp4)
```java
Map<String, Object> map = new HashMap<>();
MyThingInterface thing = (MyThingInterface) map; // O_o
thing.setFoo(new Foo());
Foo foo = thing.getFoo();
out.println(thing.getClass()); // prints "java.util.HashMap"
```
 
### [Type-safe Reflection](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#type-safe-reflection-via-jailbreak)
Access private features with <b>@Jailbreak</b> to avoid the drudgery and vulnerability of Java reflection. [&nbsp;**▶**&nbsp;Check&nbsp;it&nbsp;out!](http://manifold.systems/images/jailbreak.mp4) 
```java
@Jailbreak Foo foo = new Foo();
// Direct, *type-safe* access to *all* foo's members
foo.privateMethod(x, y, z);
foo.privateField = value;
```

### [Checked Exception Handling](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-exceptions)
You now have an option to make checked exceptions behave like unchecked exceptions!  No more unintended exception
swallowing. No more *try*/*catch*/*wrap*/*rethrow* boilerplate!
```java
List<String> strings = ...;
List<URL> urls = list
  .map(URL::new) // No need to handle the MalformedURLException!
  .collect(Collectors.toList());
```

### [String Templates](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-strings)
Embed variables and expressions in String literals, no more clunky string concat! [&nbsp;**▶**&nbsp;Check&nbsp;it&nbsp;out!](http://manifold.systems/images/string_interpolation.mp4)
```java
int hour = 15;
// Simple variable access with '$'
String result = "The hour is $hour"; // Yes!!!
// Use expressions with '${}'
result = "It is ${hour > 12 ? hour-12 : hour} o'clock";
``` 
       
### [A *Java* Template Engine](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-templates)
Author template files with the full expressive power of Java, use your templates directly in your code as types.
Supports type-safe inclusion of other templates, shared layouts, and more. [&nbsp;**▶**&nbsp;Check&nbsp;it&nbsp;out!](http://manifold.systems/images/mantl.mp4)
```java
List<User> users = ...;
String content = abc.example.UserSample.render(users);
```
A template file *abc/example/UserSample.html.mtl*
```html
<%@ import java.util.List %>
<%@ import com.example.User %>
<%@ params(List<User> users) %>
<html lang="en">
<body>
<% users.stream()
   .filter(user -> user.getDateOfBirth() != null)
   .forEach(user -> { %>
    User: ${user.getName()} <br>
    DOB: ${user.getDateOfBirth()} <br>
<% }); %>
</body>
</html>
```

### [IntelliJ](http://manifold.systems/docs.html#ide--intellij-idea)
Use the [Manifold IntelliJ IDEA plugin](https://plugins.jetbrains.com/plugin/10057-manifold) to fully leverage
Manifold in your development cycle. The plugin provides comprehensive support for IntelliJ features including code
completion, navigation, usage searching, refactoring, incremental compilation, hotswap debugging, full-featured
template editing, integrated preprocessor, and more.

<p><img src="http://manifold.systems/images/ManifoldPlugin.png" alt="manifold ij plugin" width="60%" height="60%"/></p>

>Note the Manifold Plugin for IntelliJ IDEA is **free** for use with IntelliJ IDEA **Community Edition** which like
the Manifold project is free and open source. The plugin is also commercially available on a trial basis via the
JetBrains Marketplace for use with IntelliJ IDEA **Ultimate Edition**.

### [Projects](http://manifold.systems/projects.html)
The Manifold project consists of the core Manifold framework and a collection of sub-projects implementing SPIs provided
by the core framework. Each project represents a separate **dependency** you can easily add to your project:

[Manifold : _Core_](https://github.com/manifold-systems/manifold/tree/master/manifold-core-parent/manifold)<br>

[Manifold : _GraphQL_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-graphql)<br>
[Manifold : _XML_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-xml)<br>
[Manifold : _JSON_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-json)<br>
[Manifold : _CSV_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-csv)<br>
[Manifold : _YAML_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-yaml)<br>
[Manifold : _Properties_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-properties)<br>
[Manifold : _Image_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-image)<br>
[Manifold : _Dark Java_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-darkj)<br>
[Manifold : _JavaScript_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-js)<br>

[Manifold : _Java Extensions_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext)<br>

[Manifold : _Java Template Engine_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-templates)<br>

[Manifold : _String Interpolation_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-strings)<br>
[Manifold : _[Un]checked Exceptions_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-exceptions)<br>

[Manifold : _Preprocessor_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-preprocessor)<br>

[Manifold : _Science_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-science)<br>

[Manifold : _Collections_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-collections)<br>
[Manifold : _I/0_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-io)<br>
[Manifold : _Text_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-text)<br>

[Manifold : _All&nbsp;&nbsp;(Fat JAR)_](https://github.com/manifold-systems/manifold/tree/master/manifold-all)<br>

>Experiment with sample projects:<br>
>* [Manifold : _Sample App_](https://github.com/manifold-systems/manifold-sample-project)<br>
>* [Manifold : _Sample GraphQL App_](https://github.com/manifold-systems/manifold-sample-graphql-app)<br>
>* [Manifold : _Sample REST API App_](https://github.com/manifold-systems/manifold-sample-rest-api)<br>
>* [Manifold : _Sample Web App_](https://github.com/manifold-systems/manifold-sample-web-app)
>* [Manifold : _Gradle Example Project_](https://github.com/manifold-systems/manifold-simple-gradle-project)

<br>

### [Learn More](http://manifold.systems/docs.html)
<br>
---
layout: default
---

<br>

# Licenses

## Open Source
The Manifold framework is licensed under the [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0) license.  

## Commercial
Commercial licenses for this work are available. These replace the above ASL 2.0 and offer limited warranties, support,
maintenance, and commercial server integrations.

For more information contact: [admin@manifold.systems](mailto:admin@manifold.systems)

## Manifold IntelliJ IDEA Plugin

The [Manifold Plugin for IntelliJ IDEA](https://plugins.jetbrains.com/plugin/10057-manifold) is available separately via
the [JetBrains Marketplace](https://plugins.jetbrains.com/).---
layout: default
---
# The Javascript Manifold

The Javascript Manifold (Manifold.js) is a [Manifold](http://manifold.systems/) extension library that allows for seamless interaction with javascript
resources from Java using the [Rhino](https://github.com/mozilla/rhino) project.

The library supports the use of javascript programs from Java, the use of ES6-flavored javascript classes from
java, the use of Java classes from javascript, as well as the creation of type-safe javascript expressions for
use in Java as a scripting layer.

## Javascript Program Support

Manifold.js makes standard ES5-style Javascript programs available as types in Java.

The entire javascript program is evaluated when the type is first accessed.  Top level functions
are accessible as static methods on the program type.

### Functions

Here is an example top-level function found in `ExampleProgram.js`:

```javascript
    function hello(name) {
        return "Hello " + name;
    }
```

This function could be invoked from Java like so:

```java
    System.out.println( ExampleProgram.hello("Java Programmers") )
```

### Parameter & Return Types

The parameters and the return type of javascript functions are all of type `Object`.

### Variables

Top level variables in javascript programs are treated as global variables and will retain their values
between evaluation.  Given this function:

```javascript
    var i = 0;

    function nextNum() {
        return i++;
    }
```

The following code

```javascript
    System.out.println( ExampleProgram.nextNum() )
    System.out.println( ExampleProgram.nextNum() )
```

will print

    0.0
    1.0

### Typescript-Style Typing (Parameters & Return Types)

In order to allow for greater control and readability in Java, Manifold.js allows you to specify the types parameters and return
types using Typescript syntax.

Javascript:

```javascript
    import java.util.ArrayList;
    class Sample {
        constructor(a : String) {
            this.foo = a;
        }

        foo (bar: String, baz : Integer) : ArrayList {
           var arrlist = new ArrayList();
           for(var i = 0 ; i < baz ; i ++) {
               arrlist.add(bar);
           }
           return arrlist;
        }
    }
```

Java:

```java
    Sample sample = new Sample();
    System.out.println(foo("Hello", 5)) // ["Hello","Hello","Hello","Hello","Hello"]
```

### ES6-style Arrow Functions

Manifold.js supports the use of ES6 Arrow Functions inside any Javascript program or class.

Javascript:

```javascript
    //Arrow function expression
    function filterEvens(list) {
        return list.filter( a => a % 2 == 0);
    }

    //Arrow function statements
    function incrementList(list) {
        return list.map( a => {return a + 1});
    }
```

## Experimental Features

The following features are experimental.

### Javascript Class Support

Javascript classes are exposed as regular classes in Java. They have the same functionality as Java classes,
including constructors, methods, static methods, and properties.

Javascript: foo.js

```javascript
    class Foo {

        //Constructor
        constructor(a) {
            this.foo = a;
            this._bars = 5;
        }

        //Methods
        function bar() {
            return this.foo * 2;
        }

        function baz(a,b) {
            return a+b + this.foo;
        }

        //Static Methods
        static hello() {
            return "hello";
        }

        //Properties
        get bars() {
            return this._bars*2;
        }

        set bars(a) {
            this._bars = a;
        }

    }
```

####  Constructor
The constructor is called when a new object is created. It initializes the properties within the object.

Javascript:

```javascript
    class Foo {
        constructor(a) {
            this.bar = a;
        }
    }
```

Java:

```java
    Foo foo = new Foo(5); // Creates new Foo object and sets this.bar to a
```

#### Methods

Methods are functions that are assigned to classes. They can interact with properties of the class and call other
internal methods.

Javascript:

```javascript
    class Foo {

        constructor(a) {
            this.foo = a;
        }

        function bar() {
            return this.foo * 2;
        }
    }
```

Java:

```java
    Foo foo = new Foo(21);
    System.out.println(foo.bar); // prints 42
```
#### Static Methods

Javascript:

```javascript
    class Foo {
        constructor(a) {
            this.foo = a;
            this._bars = 5;
        }

        static function staticFoo() {
            return 42;
        }
    }
```

Java:

```java
    System.out.println(Foo.staticFoo()); // Prints  42
```

#### Properties
Classes can have getter and setter properties which abstract the properties held within the class.

Javascript:

```javascript
    class Foo {
        constructor(a) {
            this.foo = a;
            this._bars = 5;
        }
        get bars() {
            return this._bars*2;
        }

        set bars(a) {
            this._bars = a;
        }
    }
```

Java:

```javascript
    Foo foo = new Foo();
    foo.setBars(21);
    System.out.println(foo.getBars()) // Prints 42
```

### Javascript Template Support

Javascript templates are supported as first class citizens. A Javascript String Template is a file that ends
in the .jst extension.

Javascript Template: SampleJSTemplate.jst

    <%@ params(names) %>

    All Names: <%for (var i = 0; i < names.length; i++) { %>
        ${names[i]}
    <% } %>

The template declares the parameters using the `<%@ params() %>` directive, and can import Java classes using
the <%@ import %> directive.

Javascript statements can be added between the `<%` and `%>` punctuators, which are evaluated as Javascript but
added directly to the generated string.

Javascript expressions can be added either between the `${` and `}` punctuators or the `<%=` and `%>` punctuators,
and are evaluated and added to the generated string.

Javascript templates can then be rendered from Java like so:

Java:

```java

    String str = SampleJSTemplate.renderToString({"Carson", "Kyle", "Lucca"});
    System.out.println(str)

```

### Accessing Javascript Classes from Java

Javascript classes can be accessed using the same syntax as Java classes.

Java:

```java
    Foo foo = new Foo(10);
    System.out.println(foo.bar()); // 20
    System.out.println(foo.getBars()); // 5

    foo.setBars(20);
    System.out.println(foo.getBars()) // 40
    System.out.println(Foo.hello()) // Hello
```

#### Accessing Java Classes from Javascript

The (non-standard javascript) import statement is used to extend Java classes with javascript methods.

Here is some example javascript: hello.js

```javascript
    import java.util.ArrayList;

    function hello() {
        var arrlist = new ArrayList();
        arrlist.add(1);
        arrlist.add(2);
        arrlist.add(3);
        System.out.println(arrlist.toArray(new Integer[arrlist.size()]));
    }
```

This can be invoked from Java like so:

```java
    hello.hello(); //prints [1,2,3]
```

NB: The import statement in Manifold.js acts like the java import statement, not the (unsupported) javascript version.

#### Extending Java Classes from Javascript

Java classes can be extended using javascript, allowing for the creation of modified classes. One
known limitation is that the constructor of the superclass cannot be overwritten.

Javascript:

```javascript
    import java.util.ArrayList;

    class SizePrints extends ArrayList {
        printSize() {
            System.out.println(super.size());
        }
    }
```

Java:

```java
    SizePrints demo = new sizePrints();
    demo.add(1);
    demo.add(2);
    demo.add(3);
    demo.printSize(); // Prints 3
```
---
layout: default
---

# ManTL (Manifold Template Language)

ManTL is a lightweight & *type-safe* template engine directly integrated with the Java compiler using [Manifold](http://manifold.systems/).
It supports the full Java language, type-safe arguments to templates, type-safe inclusion of other templates,
shared layouts for templates and custom base classes for application-specific logic, among other features.

Templates compile directly in your build as if Java source files _without a separate code generation build step_, therefore
your Java source code can reference and use your template files by name directly as _Java classes_. This level of 
integration and type-safety promotes higher levels of integrity and performance.  It also enables tooling like the [Manifold IntelliJ plugin](https://plugins.jetbrains.com/plugin/10057-manifold)
to provide deterministic code completion, navigation, usage searching, and refactoring.  Additionally the IntelliJ plugin
enables incremental compilation and hot swap debugging, allowing you to make template changes in a running application.

> Clone the [Manifold sample Web App project](https://github.com/manifold-systems/manifold-sample-web-app) to quickly
begin experimenting with ManTL templates using the Manifold IntelliJ plugin.

## Table of Contents
* [Installing](#installing)
* [Usage](#usage)
* [Syntax](#basic-syntax)
  * [Statements](#statements)
  * [Expressions](#expressions)
  * [Comments](#comments)
  * [Directives](#directives)
    * [`import`](#-import-)
    * [`extends`](#-extends-)
    * [`params`](#-params-)
    * [`include`](#-include-)
    * [`section`](#-section-)
    * [`layout`](#-layout-)
    * [`content`](#-layout-)
* [Whitespace](#whitespace)
* [**Spark** Java Support](#spark)
  * [Hello World!](#spark-hello-world)
  * [Tracing](#tracing)
  * [Template Base Class](#spark-template)
  * [Sample Application](#demo)
* [Provided Manifold Features](#provided-manifold-features)  
  
<a id="installing" class="toc_anchor"></a>

# Installing

Use ManTL in your project simply by adding the `manifold-template` dependency.

Maven:
```xml
  <dependency>
    <groupId>systems.manifold</groupId>
    <artifactId>manifold-templates</artifactId>
    <!-- it is best to use the latest release -->
    <version>0.71-alpha</version>
  </dependency>
```

Gradle:
```groovy
  compile group: 'systems.manifold', name: 'manifold-templates', version: 'RELEASE'
```
  
> Note [prebuilt binaries](http://manifold.systems/docs.html#binaries) are also available for non-Maven/Gradle projects.
 
# Usage

Once you have installed ManTL, you can begin using it by placing a new file with the `mtl` extension in your _resources_ 
directory (nb: not in your source directory).  The file can have any sort of string content, as well as [dynamic content](#basic-syntax) 
and [directives](#directives) that change how the template behaves.

> Note it is helpful, but not required, to include the file extension of the target content in the template file name.
For instance, a template that produces HTML as output is named *MyTemplate.html.mtl*

Consider the following template named `HelloWorld.txt.mtl`, located in the `resources/templates` directory:

```jsp
Hello World!
```
This template can be used directly from your Java code:

```java
import templates.HelloWorld;
public class Demo {
  public static void main(String[] args) {
    System.out.println(HelloWorld.render());
  }
}
```

This prints `Hello World` to your console.

If you want to add a parameter to the template, you can change the template to use the [`params`](#-params-) directive:

```jsp
<%@ params(String name) %>
Hello ${name}!
```

>Note you can make changes to your templates in IntelliJ while debugging your application. The Manifold plugin for 
IntelliJ hot swaps incremental compilation changes into your running application.

You can call this parameterized template with a `String` argument:

```java
import templates.HelloWorld;
public class Demo {
  public static void main(String[] args) {
    System.out.println(HelloWorld.render("ManTL"));
  }
}
```

Which prints `Hello ManTL!` to your console.

If you do not wish to materialize the template as a string, you can use the `renderInto()` method to render templates
into any `Appendable` object.  The `renderInto()` method is similar to `render()` but defines an additional `Appendable` 
parameter and returns `void`.

<a id="basic-syntax" class="toc_anchor"></a>

# Syntax

As with most template languages, a ManTL template consists of regular textual content interspersed with language 
constructs such as statements, expressions, comments, and directives.

<a id="statements" class="toc_anchor"></a>

## Statements

ManTL lets you control output of a template with Java language statements.  You embed statements or statement fragments 
in a template using this syntax:

```jsp
<% java-statement-parts %>
```
 
ManTL supports all Java language statements including variable and method declarations and control structures. For 
example, the `if` statement: 

```jsp
<% if(total >= 90) { %>
Grade: A
<% } %>
```
results in the following output if `total` is `90` or greater:
```text
Grade: A
```
otherwise, the statement has no effect on the output.

Notice the statement is fragmented between two sets of `<% %>` delimiters. You can leverage many of Java's
statements in this way to control the output, including `if-else`, `switch`, `for`, `while`, and  `do-while`.

This example demonstrates how a simple `for` statement can repeat a section of the template's content:
```jsp
<% for(String brand: Arrays.asList("Maserati", "Alfa Romeo", "Abarth") { %>
  Fiat brand: ${brand}
<% } %>
``` 
Renders as:
```text
  Fiat brand: Maserati
  Fiat brand: Alfa Romeo
  Fiat brand: Abarth
```

You can achieve the same result using a Java lambda expression:
```jsp
<% Arrays.asList("Maserati", "Alfa Romeo", "Abarth").forEach(brand -> { %>
  Fiat brand: ${brand}
<% }); %>
``` 

<a id="expressions" class="toc_anchor"></a>

## Expressions

A ManTL expression contains a Java language expression, it is evaluated, coerced to a `String`, and
inserted where the expression appears in the ManTL file.

Use expressions with this syntax:
```jsp
<%= java-expression %>
```

Additionally, the following shorthand syntax is also valid:
```jsp
${ java-expression }
```

For example, this template:
```jsp
<html>
  <head><title>Expression Example</title></head>
  <body>
    <% int y = 10; %>
    <p style="font-size: ${y}"> The font size of this paragraph is ${y}. </p>
  </body>
</html>
```

generates the following HTML:

```html
<html>
  <head><title>Expression Example</title></head>
  <body>
    <p style="font-size: 10"> The font size of this paragraph is 10. </p>
  </body>
</html>
```

Note the statement declaring the `y` variable does not directly contribute to the resulting content. This is because a 
statement does not produce a value to display, instead a statement *controls* what displays.  By contrast an expression 
produces a value, thus it directly renders as part of the template's resulting content, hence both `${y}` expressions 
render `10` in the output. 

<a id="comments" class="toc_anchor"></a>

## Comments
Comments are blocks that delimit areas of the template the compiler ignores; they do not contribute to the template's 
output. Use them to make comments and to temporarily mask off sections of a template as you like. 

>Note template comments in no way affect the generated Java code, they are exclusively template file comments.

The syntax of a comment is as follows:
```jsp
<%-- This is a comment --%>
```

<a id="directives" class="toc_anchor"></a>

## Directives

Directives are commands you use to control the compilation and resulting structure of a template.

Directives have the following syntax:

```jsp
<%@ directive-name [options] %>
```

Here is a summary of all the ManTL directives. More detailed descriptions follow.

| Directive&nbsp;&nbsp;&nbsp;&nbsp;      | Syntax              | Description                                                                         |
|----------------|---------------------------------------------|-------------------------------------------------------------------------------------|
| import         | `<%@ import type-name %>`                   | Imports Java types for use in template directives, statements, and expressions      |
| extends        | `<%@ extends class-name %>`                 | Extends a base class having features suitable for the template file                 |
| params         | `<%@ params(parameter-list) %>`             | Parameters for the template, arguments passed via the `render(arg-list)`method      |
| include        | `<%@ include template-name[(parameter-list)] [if <condition>]%>` | Include a separate template in the template                                         |
| section        | `<%@ section section-name(parameter-list) %>` | Creates a sub-template within the template, that can be called from other templates |
| layout         | `<%@ layout template-name %>`               | Specifies the template in which the declaring template nests its content            |
| content        | `<%@ content %>`                            | Used in a `layout` template, denotes where the content of a nested template renders |


<a id="-import-" class="toc_anchor"></a>

### `import`
Use the `import` directive as you would a Java `import` statement so you can use Java classes without
having to qualify them with package names.

The syntax of the `import` directive:
```jsp
<%@ import type-name %>
```

This example imports the `java.util.HashSet` class and uses it to declare the `myHashSet` variable:
```jsp
<html>
<%@ import java.util.HashSet %>
  <head><title>Import Example</title></head>
  <body>
    <% int y = 10;
       HashSet<Integer> myHashSet = new HashSet<>();
       myHashSet.add(y);
       myHashSet.add(15);
       for(Integer a: myHashSet) { %>
         <p> myHashSet contains ${a}. </p>
       <% } %>
  </body>
</html>
```
The above template produces the following HTML:
```html
<html>
  <head><title>Import Example</title></head>
  <body>
    <p> myHashSet contains 10. </p>
    <p> myHashSet contains 15. </p>
  </body>
</html>
```

>Note `import` directives must precede all other directives in your template.

<a id="-extends-" class="toc_anchor"></a>

### `extends`
Use the `extends` directive to make a template extend a custom base class, which you can use to provide
additional application specific functionality e.g., `Request` and `Response` objects in a web application.

A practical example of the `extends` directive:
```java
package demo;

import model.Contact;
import manifold.templates.runtime.BaseTemplate;

public class ExampleTemplate extends BaseTemplate {

  public String displayContact(Contact c) {
    if(c.hasName()) {
      return c.getName();
    } else {
      return c.getEmail();
    }
  }

}
```

This allows the developer to render a clean template:

```jsp
<%@ import model.Contact %>
<%@ extends demo.ExampleTemplate %>
<%@ params(Contact c)%>

<div>
  <div>
    Contact
  </div>
  <div>
    ${displayContact(c)}
  </div>
</div>
```

And easily callable:
```jsp
  get("/contact/:id", (req, resp) -> ShowContact.render(Contact.find(req.getParam("id")));
```

<a id="-params-" class="toc_anchor"></a>

### `params`

Use the `params` directive to declare parameters in a template, similar to declaring parameters for a method.

The syntax of the `params` directive is as follows:
```jsp
<%@ params(parameter-list) %>
```

For example, you can create the template `NameDisplay.html.mtl` as the following:

```jsp
<%@ params(String name) %>
<p>Your name is: ${myName}</p>
```

You can then include it in another template as follows:

```jsp
<html>
  <head><title>PARAMS Example</title></head>
  <body>
    <%@ include NameDisplay("Robert") %>
    <%@ include NameDisplay("Scott") %>
  </body>
</html>
```

Then, the following HTML will be generated:
```html
<html>
  <head><title>PARAMS Example</title></head>
  <body>
    <p>Your name is: Robert </p>
    <p>Your name is: Scott </p>
  </body>
</html>
```

<a id="-include-" class="toc_anchor"></a>

### `include`

The `include` directive allows users to insert other templates inside of the given template in a type
safe manner.

The syntax looks like this:
```jsp
<%@ include [template-name] %>
```

For example, consider the following template, `MyTemplate.html.mtl`:
```jsp
<% int fontSize = 0; %>
<html>
  <head><title>WHILE LOOP Example</title></head>
  <body>
    <% while (fontSize <= 3) { %>
      <font color = "green" size = "<%= fontSize %>">
        ManTL Tutorial
      </font><br />
      <%fontSize++;%>
    <%}%>
  </body>
</html>
```
We can then include it from another template as such:
```jsp
<%@ include MyTemplate %>
```

Both statements will result in the following HTML code:
```html
<html>
  <head><title>WHILE LOOP Example</title></head>
  <body>
    <font color = "green" size = "0">
      ManTL Tutorial
    </font><
    <font color = "green" size = "1">
      ManTL Tutorial
    </font><br />
    <font color = "green" size = "2">
      ManTL Tutorial
    </font><br />
    <font color = "green" size = "3">
      ManTL Tutorial
    </font><br />
  </body>
</html>
```

#### Conditional Include
ManTL supports shorthand for conditional inclusion of templates. The following syntax:
```jsp
<% if (condition) { %>
  <%@ include MyTemplate %>
<% } %>
```
Can be condensed to the following:
```jsp
<%@ include MyTemplate if(condition) %>
```
(Note: In the above, parentheses are optional.)


<a id="-section-" class="toc_anchor"></a>

### `section`

The `section` directive creates a subsection of the current template that can be added using the `include` directive in 
other templates.

The syntax of a `section` block:
```jsp
<%@ section section-name[(symbols-used-in-section)] %>
  SECTION CONTENT HERE
<%@ end section %>
```
Note the corresponding `<%@ end section %>` directive must be used to complete the section, otherwise
a compile error results.

For example, you can create the template `NestedImport.html.mtl` as the following:
```jsp
<%@ import java.util.* %>
<h1>Defines a section</h1>
<%@ section mySection %>
  <% HashSet<Integer> myHashSet = new HashSet<>();
  myHashSet.add(1);
  myHashSet.add(2);
  myHashSet.add(3);
  for(Integer a: myHashSet) { %>
  <h2 style="font-size: ${a}">Font size: ${a}</h2>
  <% } %>
<%@ end section %>
<p> The End </p>
```

The above code will generate the following HTML:
```html
  <h1>Defines a section</h1>
  <h2 style="font-size: 1">Font size: 1</h2>
  <h2 style="font-size: 2">Font size: 2</h2>
  <h2 style="font-size: 3">Font size: 3</h2>
  <p> The End </p>
```

Then, you can include `mySection` in a separate template:
```jsp
  <%@ include NestedImport.mySection %>
```

Which will result in the following HTML:
```html
  <h2 style="font-size: 1">Font size: 1</h2>
  <h2 style="font-size: 2">Font size: 2</h2>
  <h2 style="font-size: 3">Font size: 3</h2>
```


<a id="-layout-" class="toc_anchor"></a>

### `layout`

Layouts can be made and used with the `content` and `layout` directives respectively.

The `content` directive splits the current template into the header and footer of a layout.

The `layout` directive makes the header and footer of the layout frame the current template. 
The current template renders at the location of the `content` directive.

Both the `content` directive and `layout` directive are only valid in the outermost class
(not within sections) and can only appear once in a template.

The `params` directive is not yet supported for a template that contains the `content` directive.

The syntax of a layout template is as follows:
```jsp
HEADER CONTENT HERE
<%@ content %>
FOOTER CONTENT HERE
```

For example, you can create the template `LayoutEx.html.mtl`:
```jsp
</html>
  </body>
    <%@ content %>
  </body>
</html>
```

And use the layout in the following template:
```jsp
<%@ layout LayoutEx %>
<h1>This is a template that uses a layout.</h1>
<h2>The layout directive can appear anywhere in the template.</h2>
```


The above code will generate the following HTML:
```html
</html>
  </body>
    <h1>This is a template that uses a layout.</h1>
    <h2>The directive can appear anywhere in the template.</h2>
  </body>
</html>
```

#### Default Layouts

ManTL also supports the ability to set default layouts for templates in a given package via the
`ManifoldTemplates.java` configuration class:

```java
  // Sets default template for all templates
  ManifoldTemplates.setDefaultLayout(MyLayout.asLayout());
  
  // Sets default templates for all templates in "some.package"
  ManifoldTemplates.setDefaultLayout("some.package", AnotherLayout.asLayout());
```

By default, more specific layout declarations take precedence over less specific ones. For example, templates with a 
declared layout (using the `layout` directive) override the default layout.

Note the generated `asLayout()` static method on layout template classes.  This is useful when you override 
layouts, as specified below.

<a id="layout-overrides" class="toc_anchor"></a>

#### Layout Overrides

Sometimes you may want to manually override the layout of a given template in code,
or render a template with no layout.  ManTL classes include two fluent helper methods:
`withoutLayout()` and `withLayout(ILayout)` to assist in these cases:

```java
  // Renders the template with no layout, regardless of the configuration
  MyTemplate.withoutLayout().render(); 

  // Renders MyTemplate with the MyLayout layout, regardless of other configuration
  MyTemplate.withLayout(MyLayout.asLayout()).render(); 
```

<a id="whitespace" class="toc_anchor"></a>

# Whitespace

ManTL language constructs are silent with respect to the template's output.  That is to say, contiguous whitespace 
characters leading and trailing a language construct are omitted from the template's generated content. Whitespace 
characters include spaces, tabs, and new lines.
```jsp
  <%@ import java.util.ArrayList %>
  <% if(true) { <%>
Hi
  <% } %>
```
The above template renders just one line of text consisting of the two characters in the word `Hi`; none of the 
whitespace immediately preceding or following the language constructs are included.  
  
<a id="spark" class="toc_anchor"></a>

# Spark Java Support

ManTL is designed with web frameworks like [Spark](http://sparkjava.com/) in mind.

<a id="spark-hello-world" class="toc_anchor"></a>

## Hello World!
A simple "Hello World!" Spark application making use of ManTL:

```java
package app;

import manifold.templates.ManifoldTemplates;
import views.Index;
import views.layout.DefaultLayout;

import static spark.Spark.*;

public class WebApp { 
  public static void main(String[] args) {
    // Set up the default layout for the application
    ManifoldTemplates.setDefaultLayout(DefaultLayout.asLayout());

    // Enable tracing
    ManifoldTemplates.trace();

    // Render the Index template
    get("/", (req, resp) -> Index.render("Hello World!"));
  }
}
```

There are two templates in the `resources` directory: `views/Index.html.mtl` and `views/layouts/DefaultLayout.html.mtl`.
Here the code references the `Index` template directly as a Java class.  This is a powerful aspect of ManTL -- the 
compiler verifies your links are never broken and you can fully leverage the strength of IntelliJ for deterministic 
code completion, usage searching, refactoring, navigation, incremental compilation, and hot swap.  
  
> Note the code takes advantage of the _type-safe_ parameters available in ManTL and no Spark "TemplateEngine" is needed.

<a id="spark-template" class="toc_anchor"></a>

### SparkTemplate Base Class

Manifold provides base class `manifold.templates.sparkjava.SparkTemplate` for use with the `extends` directive
in your templates (or, more commonly, you extend this class and add more of your own application functionality).  This
class provides various convenience methods to get the HTTP `Request`, `Response`, etc. and it also automatically escapes
all string content for HTML, to help prevent malicious user input from causing a security issue in your application.

If you wish, you can output raw HTML in a template that extends `manifold.templates.sparkjava.SparkTemplate` using the
`raw()` function:

```jsp
  ${raw("<h1>Some Raw HTML</h1>")}
```
<a id="tracing" class="toc_anchor"></a>

### Tracing

ManTL supports performance tracing with the following syntax:
```java
  ManifoldTemplates.trace();
```
After invoking the `trace()` method, every following `render()` call prints the following to the console:
```
  - Template template-name rendered in time-to-render ms
```

<a id="demo" class="toc_anchor"></a>

### Sample Application

A sample Spark application is available here:

[https://github.com/manifold-systems/manifold-sample-web-app](https://github.com/manifold-systems/manifold-sample-web-app)

<a id="provided-manifold-features" class="toc_anchor"></a>

# Provided Manifold Features

Because ManTL is a [Type Manifold](http://manifold.systems/docs.html#what-is-a-type-manifold) you can leverage other 
aspects of Manifold in your code, including the [Properties Manifold](http://manifold.systems/docs.html#properties-files), 
[Image Manifold](http://manifold.systems/docs.html#image-files), and others.  For instance, just as you have type-safe 
access to `mtl` template files, you also have type-safe access to Java `properties` files and image files such as `png`, 
`gif`, and `jpg`.

You can create and use [Manifold Extensions](http://manifold.systems/docs.html#extension-classes) too.  Instead of 
writing `Util` and `Helper` classes you can write your own extension methods for any Java class. Then use IntelliJ
code completion to improve your development experience with the extended classes.

Use other extension features such as  [@Jailbreak](http://manifold.systems/docs.html#type-safe-reflection) for type-safe 
reflection and avoid the dangers of writing and maintaining reflection code in your app.  Use [@Self](http://manifold.systems/docs.html#the-self-type)
to improve the usability of your *Builder* classes -- avoid complicated recursive generic types and the like.

Utilize [Structural Interfaces](http://manifold.systems/docs.html#structural-interfaces) in your code to avoid the penalties
and tedium involved with reflection and proxies.  Structural interfaces are also quite powerful when combined with other 
Manifold features such as Extension methods -- layer a unified API over different, but similar architectures.

To utilize even more of Manifold's features you can replace your `manifold-templates` dependency with `manifold-all`. 
This change enables type-safe access to other type manifolds such as JSON and YAML files, JSON Schema, CSV and more.  
You also gain access to Manifold's provided extension libraries for I/O, Web, and Collections.

```xml
    <dependency>
      <groupId>systems.manifold</groupId>
      <artifactId>manifold-all</artifactId>
      <!-- it is best to use the latest release -->
      <version>0.71-alpha</version>
    </dependency>
```
---
layout: default
---

# News
<br/><br/>

## New article at Jaxenter (16 August 2019):

<table>
 <tr>
  <td>
  <p><a href="https://jaxenter.com/manifold-say-goodbye-to-checked-exceptions-161065.html"><img width="240" height="135" src="/images/shutterstock_1470545906.jpg" alt="a"></a></p>
  </td>
  <td>
  <p><a href="https://jaxenter.com/manifold-say-goodbye-to-checked-exceptions-161065.html">Say Goodbye to Checked Exceptions</a></p>
  <p>Modern languages don’t do checked exceptions. But you don’t have to jump ship to share the experience. In this
  article Scott McKinney shows you how to stick with Java and completely neutralize checked exceptions with a simple
  new addition to the <a href="http://manifold.systems/">Manifold framework</a>.</p>
  <p><small>jaxenter.com</small></p>
  </td>
 </tr>
</table>
<br/><br/>



## Manifold 2019.1.11 released (12 August 2019)

Some API and structural cleanup and documentation improvements 
* Refined project readme.md files, standardized them, and overall shifted documentation focus more toward Manifold’s
individual projects and away from the current monolithic docs 
* JPMS related changes: 
  * All manifold projects are defined as "automatic" modules now, with explicit names via "Automatic-Module-Name"
  * API changes 
    * renamed 'manifold' package 'manifold.util' to 'manifold.api.util' 
    * renamed 'manifold.ext' package 'manifold.util' to 'manifold.ext.api' 
* Removed 'bootstrap' plugin
* Manifold JavacPlugin is now a self registered Plugin service
* DEPRECATED: '-Xplugin:Manifold' arguments: 'strings' and 'exceptions' 
  * replaced with new dependencies: 'manifold-strings' and 'manifold.exceptions' 
  * renamed package 'manifold.api.templ' to 'manifold.strings.api' 
* Sample application improvements
  * where applicable restructure projects to use only the manifold component frameworks needed (instead of 'manifold-all')

Bug fixes: 
* Fix incremental compilation 
  * fixes problem where types corresponding with resource files appeared to recompile (or not) randomly in IJ during an incremental build 
  * fixes problem where manifold fragments would also appear to randomly recompile (or not) during an incremental build 
* Fix -processorpath v. --processor-module-path involving JPMS named module(s) in a project 
* Fix preprocessor issue where a Java file would not display preprocessor directives correctly in the presence of manifold fragments 
* Fix preprocessor JAVA_N_OR_LATER behavior
 
Manifold version 2019.1.11 is available for download on [Maven Central](https://search.maven.org/artifact/systems.manifold/manifold-all/2019.1.11/jar).
<br/><br/>



## New article at Jaxenter (5 August 2019):

<table>
 <tr>
  <td>
  <p><a href="https://jaxenter.com/manifold-preprocessor-for-java-160712.html"><img width="240" height="135" src="/images/shutterstock_1470545906.jpg" alt="a"></a></p>
  </td>
  <td>
  <p><a href="https://jaxenter.com/type-safe-jailbreak-manifold-159177.html">A Preprocessor for Java</a></p>
  <p>Discover how to build multiple targets from a single Java codebase using the new preprocessor from the Manifold
     project. In this article Scott McKinney explains how the preprocessor plugs directly into Java’s compiler to
     provide seamless conditional compilation using familiar directives.</p>
  <p><small>jaxenter.com</small></p>
  </td>
 </tr>
</table>
<br/><br/>
 


## Neuer Artikel bei Jaxenter (5. August 2019):

<table>
 <tr>
  <td>
  <p><a href="https://jaxenter.de/reflexionscode-jailbreak-manifold-typsicherheit-84641"><img width="240" height="135" src="/images/shutterstock_232482730-350x234.jpg" alt="a"></a></p>
  </td>
  <td>
  <p><a href="https://jaxenter.de/reflexionscode-jailbreak-manifold-typsicherheit-84641">Manifold: Typsicherer Reflexionscode mit @Jailbreak</a></p>
  <p>Fällt Euch die Arbeit mit Reflexionscode schwer? Der Reflexionscode an sich ist nicht typsicher, weshalb es später
     zu Problemen kommen kann. Doch keine Panik, es gibt eine Alternative! Mit @Jailbreak aus dem Manifold-Projekt kann
     man die Typsicherheit bewahren und sich der Effizienz seines Codes sicher sein.</p>
  <p><small>jaxenter.de</small></p>
  </td>
 </tr>
</table>  
<br/><br/>


 
## A Preprocessor for Java (23 July 2019)

Manifold now provides a fully integrated <b>Java Preprocessor</b>.
<br><br>
The Java Preprocessor is designed exclusively for <i>conditional compilation</i> of Java source code. It is directly
integrated into the Java compiler via the Javac Plugin API. Unlike conventional preprocessors it does <i>not</i> incur
separate build steps or additional file I/O, instead it directly contributes to the compilation pipeline.<br>
<br>
<p><img src="http://manifold.systems/images/compilerflow.png" alt="echo method" width="60%" height="60%"/></p>
<br>
The preprocessor offers a simple and convenient way to support multiple build targets with a single codebase.  It
provides advanced features such as tiered symbol definition via `build.properties` files, `-Akey[=value]` compiler
arguments, and environmental symbols such as `JAVA_9_OR_LATER` and `JPMS_NAMED`.  The preprocessor is also fully
integrated into IntelliJ IDEA using the Manifold plugin:

<br>
<p>
  <video height="60%" width="60%" controls="controls" preload="auto" onclick="this.paused ? this.play() : this.pause();" autoplay loop>
    <source type="video/mp4" src="/images/preprocessor.mp4">
  </video>
</p>
<br>

<p>
<a href="https://github.com/manifold-systems/manifold/blob/master/manifold-deps-parent/manifold-preprocessor/readme.md"><b>Learn More</b></a>
</p>
<br/><br/>



## Manifold 2019.1.8 released (23 July 2019)
New Feature
* the [Java Preprocessor](https://github.com/manifold-systems/manifold/blob/master/manifold-deps-parent/manifold-preprocessor/readme.md), a fully integrated preprocessor for Java
* minor fixes and improvements

Manifold version 2019.1.8 is available for download on [Maven Central](https://search.maven.org/artifact/systems.manifold/manifold-all/2019.1.8/jar).
<br/><br/>



## Manifold 2019.1.7 released (8 July 2019)

Manifold **core** changes 
* support a **file fragment** as an r-value embedded in a Java String literal [a la F# type provider](https://fsharp.github.io/FSharp.Data/library/JsonProvider.html) 
* support Manifold fragments values in Java 13 **text blocks** 
* this change is part of the broader [file fragment](http://manifold.systems/docs.html#embedding-with-fragments) set of
changes supporting fragments in comments as type declarations and in String literals as values, to bring type-safe
resources closer to your code 
 
Manifold **JSON** changes 
* add `fromSource()` method for JSON/YAML types to enable quick usage of by-example JSON/YAML resource **data** e.g., 

```java
// Conveniently access the *data* in Preson.json directly and type-safely
Person person = Person.fromSource();
``` 
* enable JSON/YAML **fragments** e.g, as type-safe embedded comments, use `fromSource()` to gain type-safe access to resource data 
 
Manifold **Javascript** changes 
* replace the deprecated nashorn dependency with latest **rhino** 
* remove ScriptEngine usage, instead go straight to rhino 
* using a shared global scope per thread to avoid expensive js initialization 
* each program/class/template has its own scope which in turn delegates to the shared scope 
* support javascript type-safely embedded in a string literal via file **fragments** e.g., 
`int value = (int) "[>.js<] 3 + 4 + 5";` 
* this is more a **proof of concept** to demonstrate: 
1. the relative simplicity to enable any manifold resource for literal embedding 
2. GraphQL is not the only manifold that can be embedded in a literal 
3. to prepare for more languages such a **R** 
4. to get the general feature in place and ready for java 13 where **text blocks** facilitate multiline scripts (intellij's **injection editing** makes this quite attractive) 
 
Bug **fixes**: 
* Fix [#102](https://github.com/manifold-systems/manifold/issues/102) 
* other minor fixes and improvements 

<br>

><sub>Manifold release *2019.1.7* is available for download on [Maven Central](https://search.maven.org/artifact/systems.manifold/manifold-all/2019.1.7/jar).</sub>
>
><sub>Manifold plugin for Intellij IDEA update *2019.1.7* available at [JetBrains Marketplace](https://plugins.jetbrains.com/plugin/10057-manifold).</sub> 

<br/><br/>



## Manifold is "Trick #1" (5 July 2019)
<br>
Catch [Marco Behler's _**Five Minute Friday**_](https://www.youtube.com/watch?v=-x0QuhWJg-8) coverage of Manifold.
<p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/-x0QuhWJg-8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</p>
<br/><br/> 


## JetBrains Marketplace is LIVE with Manifold (25 June 2019):
<br>
JetBrains Marketplace is [LIVE](https://blog.jetbrains.com/platform/2019/06/jetbrains-marketplace-is-live/) today along
with [Manifold IntelliJ plugin release 2019.1.5](https://plugins.jetbrains.com/plugin/10057-manifold).
<br><br> 
<small>The Manifold IntelliJ IDEA plugin version `2019.1.5` is available directly from your IDE or visit the
[JetBrains Plugins Repository](https://plugins.jetbrains.com/plugin/10057-manifold).</small>
<br/><br/> 


## Neuer Artikel bei Jaxenter (8. Juni 2019):
<br>
<table>
 <tr>
  <td>
  <p><a href="https://jaxenter.de/rest-api-vision-mit-manifold-80931"><img width="240" height="135" src="/images/shutterstock_225924757.jpg" alt="a"></a></p>
  </td>
  <td>
  <p><a href="https://jaxenter.de/rest-api-vision-mit-manifold-80931">REST API Vision mit Manifold</a></p>
  <p>Manifold ist eine einzigartige Open-Source-Technologie, die man in jedem Java-Projekt verwenden kann, um innovative
    Sprachfunktionen wie typsichere Metaprogrammierung, Erweiterungsmethoden, Templating und strukturelle Typisierung
    nutzen zu können. Im dritten Teil unserer Artikelserie zeigt Scott McKinney, wie man Manifold einsetzen kann, um
    JSON Schema als REST API Single Source of Truth (SSoT) festzulegen. Er geht dabei auch darauf ein, wie das Framework
    JSON-Schema- und YAML-Ressourcen auf direktem Wege mit Java verbindet, ohne dabei auf Code-Generatoren, kommentierte
    POJOs oder andere Zwischenlösungen angewiesen zu sein.</p>
  <p><small>jaxenter.de</small></p>
  </td>
 </tr>
</table>
<br/><br/> 


## New article at Jaxenter (6 June 2019):
<br>
<table>
 <tr>
  <td>
  <p><a href="https://jaxenter.com/type-safe-jailbreak-manifold-159177.html"><img width="240" height="135" src="/images/shutterstock_232482730.jpg" alt="a"></a></p>
  </td>
  <td>
  <p><a href="https://jaxenter.com/type-safe-jailbreak-manifold-159177.html">Type-safe reflection code with `@Jailbreak`</a></p>
  <p>Ever overexpose fields and methods just so they can be accessed from tests? Ever write reflection code in order to
     access private class members? You can stop doing that now. Maintain integrity and type-safety with @Jailbreak from
     the Manifold project.</p>
  <p><small>jaxenter.com</small></p>
  </td>
 </tr>
</table>
<br/><br/> 


## Manifold 2019.1 is released! (5 June 2019):
<br>
Announcing Manifold's first official release -- 2019.1 is available! From *Type-safe Metaprogramming*,
*Structural Interfaces*, and *Extension Classes* to *GraphQL*, *JSON Schema*, and *Templates* and everything in between.
All ready for your imagination! 

Manifold version `2019.1.2` is available for download on [Maven Central](https://search.maven.org/artifact/systems.manifold/manifold-all/2019.1.2/jar).
The Manifold IntelliJ IDEA plugin version `2019.1.2` is available directly from your IDE or visit the
[JetBrains Plugins Repository](https://plugins.jetbrains.com/plugin/10057-manifold).
<br/><br/> 


## A new screencast showcasing Manifold's new GraphQL support (24 May 2019):
<br>
<p>
  <video height="60%" width="60%" controls="controls" preload="auto" onclick="this.paused ? this.play() : this.pause();">
    <source type="video/mp4" src="/images/graphql.mp4">
  </video>
</p>
<br>
Clone the [GraphQL sample application](https://github.com/manifold-systems/manifold-sample-graphql-app) to experiment 
with type-safe GraphQL. Don't forget to add the [Manifold plugin](https://plugins.jetbrains.com/plugin/10057-manifold),
and while you're at it add the [JS GraphQL plugin](https://plugins.jetbrains.com/plugin/8097-js-graphql) too; it pairs
extremely well with the Manifold plugin when developing with GraphQL.
<br/><br/> 


## Manifold 0.71-alpha released (22 May 2019)

Bug fixes and improvements 
* [#90](https://github.com/manifold-systems/manifold/issues/90): improve identifier encoding, fix JSON create/build parameter coercion
* Fix JPS compiler plugin bug involving projects without manifold dependencies
* Add Copier/Copy API support for GraphQL types and operations
* Fix race condition in IJ plugin involving internal caching
* Several minor GraphQL related fixes

Manifold version 0.71-alpha is available for download on [Maven Central](https://search.maven.org/artifact/systems.manifold/manifold-all/0.71-alpha/jar).
<br/><br/>



## Manifold 0.68-alpha released (16 May 2019)

Bug fixes and improvements 
* [#87](https://github.com/manifold-systems/manifold/issues/87): handle case where a jar file has both a file entry and a directory entry as siblings with the same exact name 
* [#88](https://github.com/manifold-systems/manifold/issues/88): extension classes fix 
* [#89](https://github.com/manifold-systems/manifold/issues/89): support `graphqls` extension 
* fix NPEs related to recent changes involving manifold plugin dormancy when a project is not using manifold dependencies 

Manifold version 0.68-alpha is available for download on [Maven Central](https://search.maven.org/artifact/systems.manifold/manifold-all/0.68-alpha/jar).
<br/><br/>



## Manifold 0.66-alpha released (14 May 2019)

Bug fixes and improvements 
* [#62](https://github.com/manifold-systems/manifold/issues/62): fix "never accessed" warnings for string interpolation 
* [#80](https://github.com/manifold-systems/manifold/issues/80), [#81](https://github.com/manifold-systems/manifold/issues/81): fix static ext methods re IJ usage searching, rename, etc. 
* [#84](https://github.com/manifold-systems/manifold/issues/84): manifold plugin extensions are "dumb" when project has no dependencies on manifold : they have no side effects when called 
* [#85](https://github.com/manifold-systems/manifold/issues/85): fix incremental compile/hotswap of manifold types 
* For a project with no manifold dependencies, invoking UI action to create an extension class or ManTL file produces a warning message indicating the dependencies must be added 

Manifold version 0.66-alpha is available for download on [Maven Central](https://search.maven.org/artifact/systems.manifold/manifold-all/0.66-alpha/jar).
<br/><br/>



## Manifold 0.65-alpha released (8 May 2019)

Bug fixes and improvements
* Improved java source viewer on manifold resources (a debugging aid for type manifold impls in IJ)
* [#75](https://github.com/manifold-systems/manifold/issues/75): Fix stack overflow involving element refs
* [#76](https://github.com/manifold-systems/manifold/issues/76): Define a new [ManTL](http://manifold.systems/manifold-templates.html) directive: `nest`. Behaves exactly like `include` but retains and distributes the indentation whitespace immediately preceding the `nest` directive, and retains whitespace immediately following the directive.  The indentation is applied to each line in the resulting `nest`ed template or section. This behavior facilitates the code generation use-case where whitespace formatting, esp. indentation, is significant.
* [#74](https://github.com/manifold-systems/manifold/issues/74): Handle a missed use-case for checked exception suppression
* [#64](https://github.com/manifold-systems/manifold/issues/64): Provide a compile-time error indicating a method reference is not supported on a structural interface method, instead a lambda expression must be used.
* [#63](https://github.com/manifold-systems/manifold/issues/63): Fully support relative JSON refs
* Other minor changes

Manifold version 0.65-alpha is available for download on [Maven Central](https://search.maven.org/artifact/systems.manifold/manifold-all/0.65-alpha/jar).
<br/><br/>



## Manifold 0.63-alpha released (1 May 2019)

Manifold 0.63-alpha introduces _schema-first_ **GraphQL** support!

With the GraphQL Manifold framework `.graphql` (SDL) files come to life in your Java project -- the entire GraphQL type
system is at your fingertips in your Java code.  Build and execute queries **type-safely**, make changes to GraphQL schema
files and automatically see and use the changes in your code _without recompiling!_  And **no code generation** steps in
your build.

Highlights
* **Schema-first** tooling for Java: `*.graphql` schema files are first-class Java types
* True centralized **single source of truth** development, *ZERO* code generation steps in your build
* **Comprehensive** schema support: queries, mutations, types, inputs, interfaces, unions, scalars, & extensions
* Simple, **type-safe** query building and execution
* Excellent **IntelliJ** support via Manifold plugin

Manifold 0.63-alpha is available for download on [Maven Central](https://search.maven.org/artifact/systems.manifold/manifold-all/0.63-alpha/jar).
<br/><br/>



## Manifold 0.59-alpha released (8 April 2019)

Bug fixes
* fix jps plugin so that a source root suc as 'target/generated-sources/annotations' exists on disk before we handle incremental compilation
* fix [#60](https://github.com/manifold-systems/manifold/issues/60): regression on primitive JSON list types, ensure component type is boxed regardless of nullability
* other minor fixes

Manifold 0.59-alpha is available for download on [Maven Central](https://search.maven.org/artifact/systems.manifold/manifold-all/0.59-alpha/jar).
<br/><br/>



## Manifold 0.56-alpha released (2 April 2019)

Bug fixes
* fix regression involving extension classes where a class in the same project, but a in different module may not work
* fix compilation with module that does not have a dependency on manifold (don't attempt to perform manifold incremental compilation on it)
* only warn about manifold being out of date if the project is already using manifold but is using an older version than the plugin, otherwise no warning
* other minor changes

Manifold 0.59-alpha is available for download on [Maven Central](https://search.maven.org/artifact/systems.manifold/manifold-all/0.59-alpha/jar).
<br/><br/>



## Manifold 0.55-alpha released (31 March 2019)

Manifold provides a new option to **Turn Off Checked Exceptions!**

Highlights
* Simply add the `exceptions` plugin argument e.g., `-Xplugin:Manifold strings exceptions`
  * Now checked exceptions behave like unchecked exceptions! No more compiler errors, no more boilerplate try/catch, no more nonsense.

Bug fixes
* [#55](https://github.com/manifold-systems/manifold/issues/55), don't display warning message re manifold jars for a project without manifold dependencies
* other minor fixes
<br/><br/>



## Manifold 0.53-alpha released (28 March 2019)

Highlights
* **Support Java 12**
* Fix issues with "Create Extension Method Class" dialog
* Some performance improvements esp. faster manifold resource compilation with larger projects
* Other minor improvements and fixes
<br/><br/>



## Manifold 0.50-alpha released (14 March 2019)

Highlights
* Provide means to satisfy a structural interface dynamically via registered IProxyFactory service, major perf improvement
* Self type improvements

Bug fixes
* Fix regression where annotation processing libraries could cause problems with self types, structural types, etc.
* Fix completion issue. A project with multiple unrelated modules can now access extension methods from shared jar files such as Manifold's builtin extensions for String etc.
<br/><br/>



## Manifold 0.48-alpha released (12 March 2019)

Highlights
* Rewrite @Self implementation to provide comprehensive 'self' type support. Essentially, @Self is suitable as a simpler alternative to recursive generic types.
* @Self can be applied to:
  * instance method return type
  * instance method parameter type
  * instance field type
* You can override methods having @Self in a parameter and maintain the super type's signature, but also have your subclass type enforced, no bridge methods or other shenanigans otherwise present with recursive generics
* @Self is fully supported in *extension methods*
>Note the completion of @Self facilitates [#47](https://github.com/manifold-systems/manifold/issues/47) -- use @Self instead of generic methods and recursive generic types.
<br/><br/>



## Manifold 0.45-alpha released (17 February 2019)

Structural Interface improvements
* Structural interface improvements
  * Provide a solution to eliminate the first-time load/cast overhead for a structural interface. Enable a structural interface to provide its own proxy factory via new optional parameters to @Structural(factoryClass, baseClass)

JSON Schema improvements
* JSON array types are now concrete types and define a component type named Item
  * Thus a JSON array declared as "Users" has type "Users" and, if not a $ref, its nested component type is named "UsersItem"
  * The "Users" type is an interface and extends IJsonList, which in extends List
* Added `request(URL)` static method on all JSON API interfaces
  * Use to conveniently navigate an HTTP REST API with GET, POST, PUT, PATCH, & DELETE
* IJsonParser no longer wraps lists in bindings with single "value" property -- returns JSON List as-is now
* Fixed bug dealing with not preserving insertion order of oneOf/anyOf union types
* Several other bug fixes along the way
<br/><br/>



## Manifold 0.43-alpha released (7 February 2019)

Manifold core changes
* Support dynamic compilation/loading of resources in other dependency modules in a multi-module Java 11 (JPMS) project
* Eliminate "built-in" type manifolds, move them all out into separate modules:
  * `manifold-properties`
  * `manifold-image`
  * `manifold-darkj`
>Note although all built-in type manifolds are now registered and loaded separately as services, they are all still included in the `manifold-all` jar

Manifold JSON changes: 
* Support $ref paths of any kind:
``` 
$ref: "#someId/foo" 
$ref: "#/definitions/raw.name" 
etc.
``` 
* Support `/properties` in a $ref path 
* Support non-standard JSON Schema type names with proper-case, `String`, `Object`, `Array` and also support `double` as an alias for `number`. 
* Fix a bug where an errant Json list type has a null component type
* Fix a bug where a $ref to a oneOf type did not add union methods to the ref'ing type
<br/><br/>



## Manifold 0.42-alpha released (2 February 2019)

New **YAML** support with the new YAML Type Manifold.

Highlights
* Use JSON Schema and YAML interchangeably
* New JSON Schema fluent API
* Performance optimizations relating to very large scale IntelliJ projects such as IJ CE EAP
* Enhancements to @Precompile
* Manifold works with Lombok (edge release)
* Very large scale projects supported
<br/><br/>



## Manifold 0.37-alpha (17 January 2019)

Manifold JSON changes
* Support JSON Schema's many curious ways of saying a type is "nullable":
  * The type array: `"type": ["", "null"]`
  * The union type: `"oneOf": [ ..., {"type": "null"}]`
  * The enum type: `"enum": [..., null]`
  * OpenAPI's sane way: `"nullable"`

* Support OpenAPI formats:
  * `byte`, `binary` with backing classes: `Base64Encoding` and `OctetEncoding`
  * `int64` with `Long`/`long`
  * note `int32`, `float`, and `double` formats are naturally accounted for with default backing types Integer/int, Double/double, no need for special formats

* Support `readOnly` and `writeOnly`
* Support `additionalProperties` and `patternProperties`
  * both of these control whether or not a type can be treated as a general map, has methods get(key) and put(key, value)
* Support json schema cycles stemming from `oneOf` i.e., interface Foo extends Foo.InnerClass
  * such a cycle is short-circuited by directly incorporating the super interface's property methods in the extending type
  * Foo.InnerClass remains an inner class of Foo and Foo remains structurally assignable to Foo.InnerClass (JSON interfaces are structural interfaces)
* Add Builders having withXxx() methods
  * a json schema interface now has a static builder(...) method with parameters matching the create(...) method (required properties)
  * returns inner class Builder instance having withXxx(x) matching all non-required properties
* Much refactoring to better accommodate the additional `readOnly`, `additionProperties`, etc. attributes

* support nested `definitions` for JSON Schema
<br/><br/>



## Manifold 0.34-alpha (4 January 2019)

Manifold Templates (ManTL) changes
* support static imports in the `import` directive 
* change template generation to support very large template files esp. content chunks larger than 64k 
* several other template related fixes/refactors/changes 

Manifold JSON changes 
* Remove overhead of JSON dynamic proxy by removing it in favor of improving the interface API to provide its own implementation 
  * Usage of a JSON interface no longer involves a runtime delay the first time it is used
* Type-safe support for JSON Schema `enum` types, generate Java enum to correspond with any JSON `enum` including non-string values 
* Type-safe, pluggable support for JSON Schema `format` types like `date-time` etc. 
  * The JSON type manifold supplies a Java service provider API with `IJsonFormatTypeResolver`
  * Implement `IJsonFormatTypeResolver` to map Java types to your own formats
  * Manifold supports standard JSON Schema formats including `date-time`, `date`, `time` using `java.time.LocalDateTime`, `LocalDate`, and `LocalTime`
  * Manifold supports some non-standard formats too including `utc-millisec` with `java.time.Instant`
  * Additionally Manifold provides new (non-standard) formats such as `big-integer` and `big-decimal`
* Support `default` value and `required` properties type-safely by adding parameters to the JSON interface's static create() method where each parameter corresponds with a `required` property that does not have a `default` value 
* Support `const` as a single value enum type (as described in the JSON Schema) 
* Support `allOf`, `anyOf`, `oneOf` where all the component types are enums such that regardless of the all/any/one operation the resulting type is a single enum composed of all the constants in all the component enum types
<br/><br/>



## Manifold 0.33-alpha released (22 December 2018)

Manifold ext changes
* `@Jailbreak` supports using members of a class to which the JPMS otherwise prohibits access e.g., call a method on a class in a package that is not exported or open to the module of the call site
* small perf improvement on structural proxy generation, test for ICallHandler statically as well as via extension and cache the result
Manifold Templates (ManTL) changes
* fix `section` support involving params
* support lambda usage where the statement block of the lambda is used for generating content
* filter leading spaces associated with some non-content template constructs
<br/><br/>



## Manifold 0.32-alpha (11 December 2018)

* Fix some issues introduced with Jailbreak (from ver 0.30-alpha)
  * Rename `@JailBreak` to proper spelling '@Jailbreak` (doh!)
  * Fix problems related to compile error reporting from javac
  * Prohibit use of @Jailbreak in compound assignment expressions and increment/decrement expressions; it's better to use direct assignment with '='
  * Resolve https://github.com/manifold-systems/manifold/issues/33
<br/><br/>



## Manifold 0.30-alpha (7 December 2018)

New `@JailBreak` feature.

Gain direct, type-safe access to otherwise inaccessible classes/methods/fields.  Use `@JailBreak` to avoid the drudgery and vulnerability of Java reflection:
```java
@JailBreak Foo foo = getFoo();
foo.privateMethodOnFoo();
foo.privateFieldOnFoo = value;
```
Added `jailbreak()` extension method to Object.  Use it like `@JailBreak` but directly in an expression:
```java
foo.jailbreak().privateMethodOnFoo()
```
Bug fixes
* Fixed [#31](https://github.com/manifold-systems/manifold/issues/31)
<br/><br/>



## Manifold 0.28-alpha released (22 November 2018)

Highlights
* Support the [Self type](http://manifold.systems/docs.html#the-self-type) via the new `@Self` feature
* Fix modifier code gen where public was used instead of the original modifier
* Fix ReflectUtil method invocation to unwrap InvocationTargetException and rethrow original exception
* Other minor changes
<br/><br/>

---
layout: default
---

# Projects Quick Reference

The Manifold project consists of the core Manifold framework and a collection of sub-projects implementing SPIs provided
by the core framework. This document serves as a quick reference to these projects.

## Core Framework
* [Manifold : _Core_](https://github.com/manifold-systems/manifold/tree/master/manifold-core-parent/manifold)

## Resource Manifolds
* [Manifold : _GraphQL_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-graphql)
* [Manifold : _XML_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-xml)
* [Manifold : _JSON_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-json)
* [Manifold : _CSV_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-csv)
* [Manifold : _YAML_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-yaml)
* [Manifold : _Properties_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-properties)
* [Manifold : _Image_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-image)
* [Manifold : _Dark Java_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-darkj)
* [Manifold : _JavaScript_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-js)

## Java Extension Manifold
* [Manifold : _Java Extension_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext)

## Java Templates Framework
* [Manifold : _Templates_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-templates)

## Java Compiler Extensions
* [Manifold : _String Templates_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-strings) <small>(string interpolation)</small>
* [Manifold : _[Un]checked_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-exceptions)

## Java Preprocessor
* [Manifold : _Preprocessor_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-preprocessor)

## Java Science
* [Manifold : _Science_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-science)

## Java Extension Libraries 
* [Manifold : _Collections_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-collections)
* [Manifold : _I/0_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-io)
* [Manifold : _Text_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-text)

## Über JAR (Fat JAR)
* [Manifold : _All_](https://github.com/manifold-systems/manifold/tree/master/manifold-all)

## Sample Projects
* [Manifold sample project](https://github.com/manifold-systems/manifold-sample-project)
* [Manifold sample GraphQL project](https://github.com/manifold-systems/manifold-sample-graphql-app)
* [Manifold sample REST API project](https://github.com/manifold-systems/manifold-sample-rest-api)
* [Manifold sample Web App project](https://github.com/manifold-systems/manifold-sample-web-app)
* [Manifold sample Gradle Project](https://github.com/manifold-systems/manifold-simple-gradle-project)---
layout: default
---

# Roadmap
 
![roadmap](http://manifold.systems/images/roadmap.jpg)
 
## Features on the workbench

#### Manifold plugin for VS Code (which is Eclipse)
* [#142](https://github.com/manifold-systems/manifold/issues/142)
#### Manifold plugin for Eclipse
* [#18](https://github.com/manifold-systems/manifold/issues/18)
<br>


## Features on the pile (in no particular order)
 
#### Operator overloading enhancements
* [#126](https://github.com/manifold-systems/manifold/issues/126)

#### New schema type manifolds 
* [#111](https://github.com/manifold-systems/manifold/issues/111)

#### Manifold "inliner" (aka De-Manifold) tool
* [#95](https://github.com/manifold-systems/manifold/issues/95)

#### Default parameter values
* [#93](https://github.com/manifold-systems/manifold/issues/93)

#### Android support
* [#77](https://github.com/manifold-systems/manifold/issues/77)

---
layout: default
---

# Recent Articles

<table>
 <tr>
  <td>
  <p><a href="https://jaxenter.com/manifold-operator-overloading-java-163232.html"><img width="240" height="135" src="/images/math.png" alt="a"></a></p>
  </td>
  <td>
  <p><a href="https://jaxenter.com/manifold-operator-overloading-java-163232.html">Operator Overloading for Java</a></p>
  <p>Finally you can use <i>BigDecimal</i> and other Java types directly in arithmetic and relational operations by
  incorporating a feature called operator overloading into your project. In this article, Scott McKinney walks you
  through this new capability provided by the Manifold project. Along the way he discusses other interesting features
  built atop operator overloading including unit expressions.</p>
  <p><small>jaxenter.com</small></p>
  </td>
 </tr>
 
 <tr><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td></tr>
 
 <tr>
  <td>
  <p><a href="https://jaxenter.com/manifold-java-access-control-161882.html"><img width="240" height="135" src="/images/crazy-pills.jpg" alt="a"></a></p>
  </td>
  <td>
  <p><a href="https://jaxenter.com/manifold-java-access-control-161882.html">Java Access Control, Stop the Insanity!</a></p>
  <p>Java access modifiers <code>protected</code>, <code>package</code>, and <code>private</code> are enforced <i>both</i> by
     the compiler and the JVM. Here Scott McKinney explains why this is <i>insane</i> and how access to internals could
     be made much simpler and <i>type-safe</i>.</p>
  <p><small>jaxenter.com</small></p>
  </td>
 </tr>
 
 <tr><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td></tr>
 
 <tr>
  <td>
  <p><a href="https://jaxenter.com/manifold-say-goodbye-to-checked-exceptions-161065.html"><img width="240" height="135" src="/images/unchecked.png" alt="a"></a></p>
  </td>
  <td>
  <p><a href="https://jaxenter.com/manifold-say-goodbye-to-checked-exceptions-161065.html">Say Goodbye to Checked Exceptions</a></p>
  <p>Modern languages don’t do checked exceptions. But you don’t have to jump ship to share the experience. In this
  article Scott McKinney shows you how to stick with Java and completely neutralize checked exceptions with a simple
  new addition to the <a href="http://manifold.systems/">Manifold framework</a>.</p>
  <p><small>jaxenter.com</small></p>
  </td>
 </tr>
 
 <tr><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td></tr>
 
 <tr>
  <td>
  <p><a href="https://jaxenter.com/manifold-preprocessor-for-java-160712.html"><img width="240" height="135" src="/images/preprocessor_article.png" alt="a"></a></p>
  </td>
  <td>
  <p><a href="https://jaxenter.com/manifold-preprocessor-for-java-160712.html">A <i>Preprocessor</i> for Java</a></p>
  <p>Discover how to build multiple targets from a single Java codebase using the new preprocessor from the Manifold
     project. In this article Scott McKinney explains how the preprocessor plugs directly into Java’s compiler to
     provide seamless conditional compilation using familiar directives.</p>
  <p><small>jaxenter.com</small></p>
  </td>
 </tr>
 
 <tr><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td></tr>
 
 <tr>
  <td>
  <p><a href="https://jaxenter.com/type-safe-jailbreak-manifold-159177.html"><img width="240" height="135" src="/images/jailbreak.png" alt="a"></a></p>
  </td>
  <td>
  <p><a href="https://jaxenter.com/type-safe-jailbreak-manifold-159177.html">Type-safe reflection code with <code>@Jailbreak</code></a></p>
  <p>Ever overexpose fields and methods just so they can be accessed from tests? Ever write reflection code in order to
     access private class members? You can stop doing that now. Maintain integrity and type-safety with @Jailbreak from
     the Manifold project.</p>
  <p><small>jaxenter.com</small></p>
  </td>
 </tr>
 
 <tr><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td></tr>
 
 <tr>
  <td>
  <p><a href="https://jaxenter.com/rest-api-vision-manifold-156110.html"><img width="240" height="135" src="/images/shutterstock_225924757.jpg" alt="a"></a></p>
  </td>
  <td>
  <p><a href="https://jaxenter.com/rest-api-vision-manifold-156110.html">REST API <i>Vision</i> with Manifold</a></p>
  <p>Discover how to use Manifold to enable JSON Schema as your REST API single source of truth (SSoT). Scott McKinney
     explains how the new Manifold framework connects your JSON Schema and YAML resources directly to Java without code
     generators, annotated POJOs, or other go-betweens.</p>
  <p><small>jaxenter.com</small></p>
  </td>
 </tr>
 
 <tr><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td></tr>
 
 <tr>
  <td>
  <p><a href="https://jaxenter.com/manifold-code-generator-part-2-151762.html"><img width="240" height="135" src="/images/shutterstock_739795408-350x197.jpg" alt="a"></a></p>
  </td>
  <td>
  <p><a href="https://jaxenter.com/manifold-code-generator-part-2-151762.html">Manifold: Extension methods for Java?! (Part 2) - JAXenter</a></p>
  <p>Scott McKinney discusses Extension Classes, an innovative feature that enables you to supplement a class with your own methods, interfaces, and other features.</p>
  <p><small>jaxenter.com</small></p>
  </td>
 </tr>

 <tr><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td></tr>

 <tr>
  <td>
  <p><a href="https://jaxenter.com/manifold-code-generators-150738.html"><img width="240" height="135" src="/images/shutterstock_739795408-350x197.jpg" alt="a"></a></p>
  </td>
  <td>
  <p><a href="https://jaxenter.com/manifold-code-generators-150738.html">Manifold: The reinvention of code generators (Part 1) - JAXenter</a></p>
  <p>Manifold offers cutting edge language features for Java devs. 
            Scott McKinney discusses Manifold's reinvention of code generators, 
			namely Type Manifolds.</p>
  <p><small>jaxenter.com</small></p>
  </td>
 </tr>
 
 <tr><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td></tr>
 
 <tr>
  <td>
  <p><a href="https://jaxenter.com/manifold-alien-technology-142755.html"><img width="240" height="135" src="/images/shutterstock_164685149-350x233.jpg" alt="b"></a></p>
  </td>
  <td>
  <p><a href="https://jaxenter.com/manifold-alien-technology-142755.html">Manifold: Alien technology - JAXenter</a></p>
  <p>Manifold is out of this world: this framework allows developers to dynamically and seamlessly 
            extend Java’s type system. In this article, Scott McKinney explores how the Manifold framework 
			makes Java development more appealing and productive.</p>
  <p><small>jaxenter.com</small></p>
  </td>
 </tr>
 
 <tr><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td></tr>
 <tr><td><p><h3>Deutsche</h3></p></td><td><p>&nbsp;</p></td></tr>
  
 <tr>
  <td>
  <p><a href="https://jaxenter.de/manifold-gepruefte-exceptions-86344"><img width="240" height="135" src="/images/unchecked.png" alt="a"></a></p>
  </td>
  <td>
  <p><a href="https://jaxenter.de/manifold-gepruefte-exceptions-86344">Manifold: Adieu und auf Wiedersehen, geprüfte Exceptions</a></p>
  <p>Moderne Sprachen setzen keine geprüften Exceptions ein. Aber man muss nicht das sinkende Schiff verlassen, um an
  der Erfahrung teilzuhaben. In diesem Artikel zeigt uns Scott McKinney, wie man weiterhin bei Java bleiben kann und
  geprüfte Exceptions vollständig neutralisiert: mit einer einfachen und neuen Ergänzung zum Manifold-Framework.</p>
  <p><small>jaxenter.de</small></p>
  </td>
 </tr>
 
  <tr><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td></tr>
 
 <tr>
  <td>
  <p><a href="https://jaxenter.de/manifold-java-preprocessor-85925"><img width="240" height="135" src="/images/preprocessor_article.png" alt="a"></a></p>
  </td>
  <td>
  <p><a href="https://jaxenter.de/manifold-java-preprocessor-85925">Manifold: Ein Präprozessor für Java</a></p>
  <p>In diesem Artikel erfahrt Ihr, wie man mit dem neuen Präprozessor des Manifold-Projekts mehrere Ziele aus einer
  einzigen Java-Codebasis erstellen kann. Scott McKinney, Gründer und Entwickler von Manifold Systems, erklärt, wie der
  Präprozessor sich direkt mit dem Java-Compiler verbindet, um eine nahtlos bedingte Kompilierung mit bekannten
  Directives zu ermöglichen.</p>
  <p><small>jaxenter.de</small></p>
  </td>
 </tr>
 
  <tr><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td></tr>
 
 <tr>
  <td>
  <p><a href="https://jaxenter.de/reflexionscode-jailbreak-manifold-typsicherheit-84641"><img width="240" height="135" src="/images/jailbreak.png" alt="a"></a></p>
  </td>
  <td>
  <p><a href="https://jaxenter.de/reflexionscode-jailbreak-manifold-typsicherheit-84641">Manifold: Typsicherer Reflexionscode mit @Jailbreak</a></p>
  <p>Fällt Euch die Arbeit mit Reflexionscode schwer? Der Reflexionscode an sich ist nicht typsicher, weshalb es später
     zu Problemen kommen kann. Doch keine Panik, es gibt eine Alternative! Mit @Jailbreak aus dem Manifold-Projekt kann
     man die Typsicherheit bewahren und sich der Effizienz seines Codes sicher sein.</p>
  <p><small>jaxenter.de</small></p>
  </td>
 </tr>
 
  <tr><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td></tr>
 
 <tr>
  <td>
  <p><a href="https://jaxenter.de/rest-api-vision-mit-manifold-80931"><img width="240" height="135" src="/images/shutterstock_225924757.jpg" alt="a"></a></p>
  </td>
  <td>
  <p><a href="https://jaxenter.de/rest-api-vision-mit-manifold-80931">REST API Vision mit Manifold</a></p>
  <p>Manifold ist eine einzigartige Open-Source-Technologie, die man in jedem Java-Projekt verwenden kann, um innovative
    Sprachfunktionen wie typsichere Metaprogrammierung, Erweiterungsmethoden, Templating und strukturelle Typisierung
    nutzen zu können. Im dritten Teil unserer Artikelserie zeigt Scott McKinney, wie man Manifold einsetzen kann, um
    JSON Schema als REST API Single Source of Truth (SSoT) festzulegen. Er geht dabei auch darauf ein, wie das Framework
    JSON-Schema- und YAML-Ressourcen auf direktem Wege mit Java verbindet, ohne dabei auf Code-Generatoren, kommentierte
    POJOs oder andere Zwischenlösungen angewiesen zu sein.</p>
  <p><small>jaxenter.de</small></p>
  </td>
 </tr>
 
  <tr><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td></tr>
 
 <tr>
  <td>
  <p><a href="https://entwickler.de/leseproben/manifold-nicht-von-dieser-welt-579872136.html"><img width="240" height="135" src="/images/entwickler.png" alt="c"></a></p>
  </td>
  <td>
  <p><a href="https://entwickler.de/leseproben/manifold-nicht-von-dieser-welt-579872136.html">Manifold: Nicht von dieser Welt - entwickler</a></p>
  <p>Java schließt mit Manifold die Lücke zu vielen Funktionen, die bisher ausschließlich dynamischen Sprachen vorbehalten waren. 
     Darüber hinaus liefert Manifold diese Eigenschaften mit intakter Typsicherheit. Metaprogrammierung, Extension Classes und strukturelle Typisierung sind leicht verfügbar und vollständig in IntelliJ IDEA integriert.</p>
  <p><small>entwickler.de</small></p>
  </td>
 </tr>
 
  <tr><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td></tr>
 
 <tr>
  <td>
  <p><a href="https://jaxenter.de/manifold-code-generator-java-metadata-74906"><img width="240" height="135" src="/images/manifold-java-code-generator.jpg" alt="c"></a></p>
  </td>
  <td>
  <p><a href="https://jaxenter.de/manifold-code-generator-java-metadata-74906">Manifold: Die Neuerfindung des Code-Generators - JAXenter</a></p>
  <p>Mit diesem Artikel startet eine neue Serie zu Manifold.Manifold ist eine einzigartige Open-Source-Technologie, 
            die man in jedem Java-Projekt verwenden kann, um innovative Sprachfunktionen wie typsichere Metaprogrammierung, 
			Erweiterungsmethoden, Templating und strukturelle Typisierung nutzen zu können.</p>
  <p><small>jaxenter.de</small></p>
  </td>
 </tr>
 
  <tr><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td></tr>
 
 <tr>
  <td>
  <p><a href="https://jaxenter.de/manifold-typsystem-dynamisch-erweitern-69685"><img width="240" height="135" src="/images/shutterstock_546213388-768x581.jpg" alt="d"></a></p>
  </td>
  <td>
  <p><a href="https://jaxenter.de/manifold-typsystem-dynamisch-erweitern-69685">Manifold: Eine außeridische Technik für die dynamische Erweiterung von Javas Typsystem - JAXenter</a></p>
  <p>Manifold ist nicht von dieser Welt: Das Framework ermöglicht es Entwicklern, 
            das Typsystem von Java dynamisch und nahtlos zu erweitern. In diesem Artikel 
			untersucht Scott McKinney, Gründer und Engineer bei Manifold Systems, wie das 
			Manifold Framework die Java-Entwicklung attraktiver und produktiver macht.</p>
  <p><small>jaxenter.de</small></p>
  </td>
 </tr>


 <tr><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td></tr>
 <tr><td><p><h3>Miscellany</h3></p></td><td><p>&nbsp;</p></td></tr> 
 
  <tr>
   <td>
   <p><a href="/talks/manifold2019.pptx"><img width="240" height="135" src="/images/manifold2019talk.png" alt="a"></a></p>
   </td>
   <td>
   <p><a href="/talks/manifold2019.pptx">Manifold: X-ray Vision for Java</a></p>
   <p>Slide deck for a talk presenting Manifold as a the reinvention and replacement for conventional code generators.</p>
   <p><small>manifold.systems</small></p>
   </td>
  </tr>
  
</table># Type-safe Reflection with `@Jailbreak`

Ever overexpose fields and methods just so they can be accessed from tests? Ever write reflection code to access
private class members? You can stop doing that now. Maintain integrity and type-safety with `@Jailbreak` from the
[Manifold project](https://github.com/manifold-systems/manifold).

```java
@Jailbreak MyWidget widget = new MyWidget();
String value = widget.privateField; // type-safely access private fields and methods 
```

## The Problem with Reflection

We're not supposed use reflection to access or modify otherwise inaccessible class members, right?  Well, that depends on the
alternatives. There are situations where reflection is the lesser of two evils or the difference between winning customers
and losing them. The fact is reflection is an indispensable JVM feature we all benefit from.  But if you still feel
uneasy about using it, that's a good sign!  Because reflection code is itself nasty stuff primarily because it totally
escapes **type-safety**.

Let's say you need brand information from `MyWidget`:
```java
public class MyWidget implements Widget {
  private String brand;
  ...
}
```  

Since `brand` is private and `MyWidget` is not your class to modify, you must resort to reflection:
```java
MyWidget myWidget = (MyWidget) widget;
...
Field field = MyWidget.class.getDeclaredField("brand");
field.setAccessible(true);
String brand = (String) field.getValue(myWidget);
```

Its use of Strings and casting make reflection not just difficult to read and error prone to write, but worse it escapes
type-safety. The compiler can neither verify your access to the `brand` field nor its `String` type.  If `MyWidget` 2.0
changes any of this, your build will not detect the break. Thus the real trouble with reflection code is that it is
statically unverifiable. 


## `@Jailbreak`

Given the difficulty reading and writing reflection code and its lack of type-safety, there should be a better way. Why
not provide a language construct to declare the *intent* to subvert encapsulation and then leverage the compiler's
strengths to verify your code.  This is precisely what the `@Jailbreak` annotation achieves:

```java
@Jailbreak MyWidget myWidget = (MyWidget) widget;
...
String brand = myWidget.brand;
```

As you can see `@Jailbreak` lets you access otherwise inaccessible members of `MyWidget` from the `myWidget` variable.

`@Jailbreak` mitigates the issues with reflection.  Use it to leverage the convenience and type-safety of the Java
compiler and let Manifold generate reliable, efficient reflection code for you.

## Basic Use

```java
@Jailbreak Foo foo = new Foo(1);
foo.privateMethod();
foo.privateMethod("hey");
foo._privateField = 88;
```
```java
public class Foo {
  private final int _privateField;
  
  public Foo(int value) {
    _privateField = value;
  }
  
  private String privateMethod() {
    return "hi";
  }
  
  private String privateMethod(String param) {
    return param;
  }
}
```

## Using the `jailbreak()` Extension

Similar to `@Jailbreak` you can call the `jailbreak()` [extension method](http://manifold.systems/docs.html#extension-classes)
from any expression to gain type-safe access to private fields, methods, and types.

```java
Foo foo = new Foo();
foo.jailbreak().privateMethodOnFoo();
```
This method is especially handy when you have a chain of member access expressions and you want to use them concisely:

```java
something.foo().jailbreak().bar.jailbreak().baz = value;
``` 

>Note reflection code is also horribly inefficient if not properly cached and accessed. Manifold fixes all that too.

## IntelliJ IDEA

Use `@Jailbreak` with the [Manifold plugin](https://plugins.jetbrains.com/plugin/10057-manifold) for IntelliJ IDEA. The
plugin provides comprehensive support for `@Jailbreak` including code completion, navigation, usage searching, etc.

Visit the [Manifold project](https://github.com/manifold-systems/manifold) on github to learn more.# Manifold: Alien Technology


## Incident Report

**Place of Occurrence**: CLASSIFIED    **Date**: 24/11/17    **Time**: 22:15Z

**Programmer**: CLASSIFIED    **Language**: Java    **Tooling**: IntelliJ IDEA

**Details of Incident**:

Witnessed subject create a JSON file, `Person.json`, as a Java resource in package `com.abc`.  
Subject immediately began using the file from Java classes in the project as if the JSON file 
were a Java class of type `com.abc.Person`.  As subject added and modified properties in the 
JSON file, the changes were immediately available elsewhere in the project using code completion 
etc.  Subject later performed a rename refactor on the JSON file, renaming it from `Person` to 
`Contact`.  All references to `Person` were immediately changed to `Contact`.  Likewise, subject
frequently performed several usage searches and refactors on JSON properties and types, all 
behaving as if the JSON were Java.  
 
Importantly, there were _no generated class files on disk_ corresponding with the JSON file after 
subject compiled the project -- no extra build steps, no artifacts created. Subject created 
several tests for the project and ran them without incident. The JVM appeared to use the JSON file
as a Java class file.  No extra class loaders were involved, no runtime agents were used.  Only a 
single jar file in the classpath was present: **manifold.jar**.   

Witnessed similar events involving Javascript files, Properties files, and several others.  This
technology appears to be capable of working with any type of data source.  Essentially, the 
technology somehow extends and enhances Java's type system at will.

More recently observed subject perform other bizarre activities, such as declare and use 
_Extension Methods_ as defined in C# and use _Structural Typing_ similar to TypeScript and Go languages.
More to follow regarding these accounts.


**Conclusion**:

Incident demonstrates beyond-next-generation technology.  Recommend further investigation.

## Earthly Origin?

As dreamy as the "incident report" appears, it is 100% factual.  Manifold is real and available as
an open source project from [Manifold Systems](http://manifold.systems/); whether or not
it is reverse-engineered alien technology is yet to be determined.  In any case you can begin using
it with your new or existing Java project.

Using Manifold is easy, simply add it as a dependency to your project. Manifold is designed to work 
with IntelliJ IDEA, which is available free from JetBrains.  Visit the Manifold 
[Setup](http://manifold.systems/docs.html#setup) instructions for information about using Manifold with
your project and build tools.  

Manifold provides three high-level features:

* **Type-safe Metaprogramming** -- similar in concept to F# type providers
* **Extension Methods** -- comparable to the same feature in Kotlin and C#
* **Structural Typing** -- much like interfaces in TypeScript and Go 

## Type-safe Metaprogramming

_Metaprogramming_, a term usually reserved for dynamic languages like Javascript, Ruby, and Python, is a powerful 
feature used for dynamic type creation that exploits the lack of design-time type-safety in 
these languages -- all the metaprogramming hocus pocus is a runtime phenomenon.  While flexible, metaprogramming 
presents a challenge for programmers using it because there is no design-time type information available for 
 them to readily discover and use; you just have to "know".

The allure of Manifold is squarely centered on its ability to perform _compile-time_ as well as runtime 
metaprogramming.  This capability is achieved via _Type Manifolds_.
 
Bridging the worlds of information and programming, type manifolds act as adapters 
to automatically connect schematized data sources with Java.  More specifically, 
a type manifold transforms a data source into a data _type_ directly accessible in 
your Java code eliminating code generation build steps involved with conventional tools. 
Manifold automatically keeps types in sync with data sources as you make changes.
In essence with Manifold a data source **_is_** a data type.

To illustrate, normally you access Java properties resources like this:

```java
Properties myProperties = new Properties();
myProperties.load(getClass().getResourceAsStream("/abc/MyProperties.properties"));
String myMessage = myProperties.getProperty("my.message");
```

As with any resource file a properties file is foreign to Java's type system -- there is no direct,
type-safe access to it. Instead you access it indirectly using boilerplate library code sprinkled
with hard-coded strings.

By contrast, with the Properties type manifold you access a properties file directly as a type:

```java
String myMessage = MyProperties.my.message;
```

Concise and type-safe, with no generated files or other build steps to engage.

Almost any type of data source imaginable is a potential type manifold. These
include resource files, schemas, query languages, database definitions, templates,
spreadsheets, web services, and programming languages.

Currently Manifold provides type manifolds for:

*   JSON and [JSON Schema](http://json-schema.org/)
*   JavaScript
*   Properties files
*   Image files
*   Dark Java
*   ManTL (Manifold Template Language)
*   DDL and SQL (work in progress)

Discover more about type manifolds here: http://manifold.systems/docs.html#what_is_a_type_manifold


## Extensions

The extension manifold is a special kind of type manifold that lets you augment existing Java classes
including Java's own runtime classes such as `String`. You can add new methods, annotations, and 
interfaces to any type your project uses.

Let's say you want to make a new method on `String` so you can straightforwardly echo a String to the
console. Normally with Java you might write a "Util" library like this:

```java
public class MyStringUtil {
  public static void echo(String value) {
    System.out.println(value);
  }
}
```

And you'd use it like this:

```java
MyStringUtil.echo("Java");
```

Instead with Manifold you create an _**Extension Class**_:

```java
@Extension
public class MyStringExtension {
  public static void echo(@This String thiz) {
    System.out.println(thiz);
  }
}
```  

Here we've added a new `echo()` method to `String`, so we use it like this:

```java
"Java".echo();
```

Extensions eliminate a lot of intermediate code such as "Util" and "Manager"
libraries as well as Factory classes. As a consequence extensions naturally
promote higher levels of object-orientation, which result in more readable and
maintainable code. Perhaps the most beneficial aspect of extensions, however, relate more
to your overall experience with your development environment.  For instance,
code-completion conveniently presents all the extension methods available on an
extended class: http://manifold.systems/images/ExtensionMethod.mp4

Extensions provide a lot more capability, learn more here: http://manifold.systems/docs.html#extension_classes


## Structural Typing

Java is a _nominally_ typed language -- types are assignable based on the names declared in their
definitions. For example:

```java
public class Foo {
  public void hello() {
    println("hello");
  }
}

public interface Greeting {
  void hello();
}

Greeting foo = new Foo(); // error
```

This does not compile because `Foo` does not explicitly implement `Greeting` by name in its `implements`
clause.

By contrast a _structurally_ typed language like TypeScript or Go has no problem with this example. 
Basically, structural typing requires only that the interface _methods_ are implemented, there is no 
need for a class to declare that it implements a structural interface.

Manifold provides this capability via the `@Structural` annotation:

```java
@Structural
public interface Greeting {
  void hello();
}
```  
Adding `@Structural` to `Greeting` effectively changes it to behave _structurally_ -- Java no longer
requires classes to implement it by name, only its methods must be implemented.

Note a class can still implement a structural interface nominally. Doing so helps both people and tooling 
comprehend your code faster. The general idea is to use an interface structurally when you otherwise can't 
use it nominally or doing so overcomplicates your code.

Learn more about Manifold structural interfaces here: http://manifold.systems/docs.html#structural_interfaces


## Benefits

Manifold's core technology is a dramatic departure from conventional Java tooling. There is no code
generation step in the build, no extra .class files or .java files to manage, no annotation processors, and no extra
class loaders to engage at runtime.

Benefits of this approach include:

*   **Zero turnaround** -- live, type-safe access to data; make, discover, and use changes instantly
*   **Lightweight** -- direct integration with standard Java, requires no special compilers, annotation
processors, or runtime agents
*   **Efficient, dynamic** -- Manifold only produces types as they are needed
*   **Simple, open API** -- you can build your own Manifolds
*   **No code generation build step** -- no generated files, no special compilers
*   **[IntelliJ IDEA](https://www.jetbrains.com/idea/download)** support -- all manifold types and extensions work with IntelliJ

Additionally, Manifold is just a JAR file you can drop into your existing project -- you can begin using
it incrementally without having to rewrite classes or conform to a new way of doing things.

## Conclusion

Finally, with Manifold, Java bridges the gap separating it from many of the features previously granted 
exclusively to dynamic languages. What's more, Manifold delivers these features with type-safety intact. 
Meta-programming, extension classes, and structural typing are readily available and fully integrated in 
IntelliJ IDEA.  While this may sound impossible or far fetched, you can verify it first-hand -- explore
Manifold at [Manifold Systems](http://manifold.systems/).  The truth is out there!# Manifold: Part I

This is the first in a series of articles covering [Manifold](http://manifold.systems/), a unique, open source technology you can use 
in any Java project to enable cutting edge language features such as type-safe metaprogramming, extension 
methods, templating, and structural typing.  In this segment I discuss Manifold's reinvention of code generators, namely
_Type Manifolds_.


# ☠ Death to Code Generators ☠

While Manifold provides a broad host of high-level features, its primary focus is to eliminate the gap separating source 
code from metadata. Software developers overwhelmingly use code generators to bridge the gap, however this decades-old 
tactic is notorious for slowing or impeding progress and is not well suited for many contemporary software architectures. 
If a project you develop involves one or more code generators, perhaps you are familiar with the disadvantages. Read on 
for a more productive alternative.

## The Metadata Disconnect

Our modern lives are replete with structured information, or metadata.  It is _everywhere_ and it is produced by near 
everything with a power cord. As a consequence the software industry has become much less code-centric and much more 
information-centric. Despite this transformation the means by which our software consumes metadata has remained 
virtually unchanged for half a century. Whether it's JSON, XSD/XML, WSDL, CSV, DDL, SQL, JavaScript, XLS, or any one of 
a multitude of other metadata sources, most modern languages, including Java, do very little to connect them with your code:

**../abc/Person.json**
```json
{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "Person",
  "type": "object",
  "properties": {
    "firstName": {
      "type": "string"
    },
    "lastName": {
      "type": "string"
    },
    "age": {
      "type": "integer",
      "minimum": 0
    }
  },
  "required": ["firstName", "lastName"]
}
```
                                           
As Java developers we want to use metadata in a type-safe manner -- we want to use the `Person` JSON schema file as a 
`Person` Java class:

```java
class Foo {
  private abc.Person person; // ERROR: Cannot resolve symbol 'abc.Person'
}
```  

Of course the Java compiler has no idea what to do with `abc.Person`, so we resort to running a code generator in a 
separate build step to generate _all_ our JSON classes beforehand so the compiler can readily use them. The effects of 
this build step on the development lifecycle range from mild irritation to utter devastation, depending on the rate of metadata
change, number and size of metadata files, density of usage in project, number of developers, etc. The problems include:
* stale generated classes
* long build times
* code bloat esp. with large metadata domain
* changes to structured data don't invalidate generated code
* no support for incremental compilation, all or nothing
* can't navigate from code reference to corresponding element in the structured data
* can't find code usages of elements from the structured data  
* can't refactor / rename structured data elements 
* complicated custom class loader issues, generated classes loaded in separate loader
* concurrency problems with the shared thread context loader
* generated code is often cached and shared, which leads to stale cache issues
* customers often need to change metadata, which requires access to code generators

## The Manifold Framework

The Manifold framework represents a rethinking of code generators.  It altogether avoids the many disadvantages often
involved with them by directly integrating with the Java compiler via the [javac plug-in mechanism](https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/util/Plugin.html). 
Implementations of the Type Manifold API, called _type manifolds_, establish a type supplier relationship with the Java 
compiler -- the Manifold framework hooks into the compiler so that as the compiler encounters type names the type 
manifolds contribute toward resolving them, generating code in memory as needed.  As such your application code 
can reference metadata sources directly by name as Java types, effectively enabling the prior example to work:
```java
class Foo {
  private abc.Person person; // OK :)
}
```

Think of a type manifold as a new domain of types for the compiler to access.  As such the Manifold framework serves as 
a gateway between javac and type manifolds, effectively expanding Java's type system to include whole new domains of 
types.  Any number of type manifolds can operate in concert; they can also cooperate so that the types contributed from 
one can feed into the next and so on, forming a type building pipeline. 

<p><img src="http://manifold.systems/images/manifold_diagram.png" alt="echo method" width="60%" height="60%"/></p>

As the diagram illustrates a type manifold contributes to the definition of types in its domain. For example, the [JSON
type manifold](http://manifold.systems/docs.html#json-and-json-schema) produces types defined in JSON files.  A type manifold can contribute toward a type in different ways. Most
often a type manifold registers as a `primary` contributor, it supplies the main body of the type.  The JSON type manifold 
is a primary contributor because it supplies the full type definition according to a JSON Schema file or JSON sample file.
Alternatively, a type manifold can be a `partial` or `supplementary` contributor.  The [Extension type manifold](http://manifold.systems/docs.html#extension-classes), for instance, 
is a supplementary contributor because it augments an existing type with additional methods, interfaces, and other features.  Thus 
both the JSON and Extension type manifolds can contribute to the same type, where the JSON manifold supplies the main 
body of the type and the Extension type manifold contributes methods and other features provided by extension classes 
(I'll cover Extensions in a later article).   

Altogether this strategy eliminates many problems plaguing conventional code generators and metadata access in general.
In essence the Type Manifold API redefines what it means to be a code generator. Benefits include:
* **Zero turnaround** – live, type-safe access to metadata; make, discover, and use changes instantly
* **Lightweight** – direct integration with standard Java, requires no special compilers, annotation processors, class loaders, or runtime agents
* **Efficient, dynamic** – Manifold only produces types as they are needed by the compiler
* **Simple, open API** – you can build your own type manifolds
* **No code generation build step** – eliminates code generators from your development build process (when dynamic mode is used) 
* **IntelliJ IDEA** – comprehensive IDE support: incremental compilation, code completion, navigation, usage searching, refactoring, debugging, etc.

Further, the Type Manifold API unifies code generator architecture by providing much needed structure and consistency 
for developers writing code generators. It puts an end to "lone wolf" code generator projects only one developer fully understands.
Moreover, you don't have to invest in one-off IDE integration projects; the [Manifold plugin for IntelliJ](http://manifold.systems/docs.html#working-with-intellij) handles everything 
for you, from incremental compilation to usage searching to refactoring.  Finally, even if you've already invested in an 
existing code generator, you can still recycle it as a wrapped type manifold -- the wrapper can delegate 
source production to your existing framework.  Learn more about implementing type manifolds [here](http://manifold.systems/docs.html#build-your-own-manifold).


## Synergy

Perhaps the most refreshing benefit from using Manifold is the synergy resulting from its presence in all stages of development.  With Manifold you
can define and use metadata that best suits your needs without having to concern yourself with build implications or 
IDE integration; you can create a metadata file, use it directly as a type, modify it, and access the changes 
immediately in your code; no awkward build/compilation steps involved, no caches to update.  With comprehensive IDE 
support, you can readily navigate to and from metadata elements, find usages from metadata, refactor, etc.  
Finally metadata has first-class representation in the Java development lifecycle!  [View it in action](http://manifold.systems/images/JsonDemo.mp4).

## Using Manifold

### Setup

Using Manifold in your Java project is easy:

* Add the Manifold jar as a plugin argument to java**c**
* Add the Manifold jar to your java classpath (optional)

That's all.

Manifold fully supports [Java 8](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html), [Java 9](http://www.oracle.com/technetwork/java/javase/downloads/jdk9-downloads-3848520.html), and [Java 10](http://www.oracle.com/technetwork/java/javase/downloads/jdk10-downloads-4416644.html).

Manifold works well with Maven and Gradle too.  Learn more about adding Manifold to your project [here](http://manifold.systems/docs.html#setup).

### Working with IntelliJ

Manifold is best experienced using [IntelliJ IDEA](https://www.jetbrains.com/idea/download).

**Install**

Get the [Manifold plugin](https://plugins.jetbrains.com/plugin/10057-manifold) for IntelliJ IDEA directly from IntelliJ via:

<kbd>Settings</kbd> ➜ <kbd>Plugins</kbd> ➜ <kbd>Marketplace</kbd> ➜ search: `Manifold`

<p><img src="http://manifold.systems/images/ManifoldPlugin.png" alt="echo method" width="60%" height="60%"/></p>


**New Project**

Creating a new project with Manifold support is easy.  [Check it out](http://manifold.systems/images/NewProject.mp4).

**Add Manifold to Existing Module**

You can add manifold to module[s] of an existing project too. [Check it out](http://manifold.systems/images/ManifoldModule.png).

**Sample Project**

Experiment with the [Manifold Sample Project](https://github.com/manifold-systems/manifold-sample-project).


## Conclusion

As a long time Java developer I've personally worked on several projects involving heavy code generation.  I've seen
the sometimes devastating effects of its use: build times measured in hours at customer sites, dev lifecycle demoralization, 
code generator development and maintenance consuming precious time, etc.  It's about time for a better solution and I think Manifold
makes good progress toward that goal.

There's much more to cover.  Future articles in this series will address:
* Using the [JSON type manifold](http://manifold.systems/docs.html#json-and-json-schema)
* The Extension Manifold and writing [Extension Classes](http://manifold.systems/docs.html#extension-classes)
* [Structural Interfaces](http://manifold.systems/docs.html#structural-interfaces)
* [Templates](http://manifold.systems/docs.html#templating)
* The SQL type manifold

As a bonus for reading this far, I'll touch on one of Manifold's latest features...

A **String template** lets you use the `$` character to embed a Java expression directly into a String.  You can 
use `$` to embed a simple variable:
```java
int hour = 8;
String time = "It is $hour o'clock";  // prints "It is 8 o'clock"
```
Or you can embed an expression of any complexity in curly braces:
```java
LocalTime localTime = LocalTime.now();
String ltime = "It is ${localTime.getHour()}:${localTime.getMinute()}"; // prints "It is 8:39"
```

Learn more [here](http://manifold.systems/docs.html#templating).
 #### Innovative language features for Java - Part 2

This is the second in a series of articles covering [Manifold](http://manifold.systems/), a new breed of tooling for
Java. [Part 1](https://jaxenter.com/manifold-code-generators-150738.html) introduces the *Type Manifold API*, a powerful 
alternative to conventional code generation.  This segment explores *Extension Classes*, an innovative feature that 
enables you to supplement a class with your own methods, interfaces, and other features without subclassing and without
changing the original class. 

## Extension Methods for _Java?!_

Quick! Write some code to read the contents of a `File` into a `String`.  Ready, go!

As a pragmatic developer you hope for something like this:
```java
  String contents = file.readText();
```   
Regrettably, you type `file.` in your IDE and quickly discover no such method exists.  Next you search *stackoverflow*
for boilerplate solutions and find a useful snippet. You want to save yourself and others from duplicating this effort, 
so you wrap the boilerplate snippet in a *Util* library:

```java
public class MyFileUtil {
  public static String readText(File file) {
    // boilerplate code...
  }
} 
```   

Now you can write:
```java
String contents = MyFileUtil.readText(file);
```

Is this as good as it gets?

You deserve a friendlier, more practical `File` API -- `readText()` is better suited and more easily discoverable 
as an instance method *directly* on `File`.  This is where a feature commonly known in the language community as 
*Extension Methods* makes all the difference.  This is also where Manifold picks up where Java leaves off. 

Manifold fully implements Extension Methods for Java via [Extension Classes](http://manifold.systems/docs.html#extension-classes):

```java
package extensions.java.io.File;

import manifold.ext.api.*;

@Extension
public class MyFileExtension {
  public static String readText(@This File thiz) {
    // boilerplate code...
  }
}
``` 

`MyFileExtension` supplements `File` with `readText()` as an instance method:
```java
String contents = file.readText();
```

Which is exactly what the pragmatist in you wants!

What's more, [IntelliJ IDEA](https://plugins.jetbrains.com/plugin/10057-manifold) provides comprehensive support for 
Manifold. You can use features such as code completion to easily discover and use extension methods:

![completion](https://dl.dropbox.com/s/nnnv3juw14j7z79/manifold_article_je_p2_completion.png) 

See it in action. Create new extension classes, refactor them, find usages, and more:
<p>
  <video height="60%" width="60%" controls="controls" preload="auto" onclick="this.paused ? this.play() : this.pause();">
    <source type="video/mp4" src="http://manifold.systems/images/ExtensionMethod.mp4">
  </video>
</p>

## Anatomy of an Extension Class

Extension classes are easy to implement using simple conventions and annotations:

```java 
package extensions.java.io.File;
```
An extension class' package name must end with `extensions.<extended class name>`.  With Java 8 you may
root all extension classes in the `extensions` package.  In Java 9 or later, if you are using explicit modules, you must prepend 
the name of the module to the package eg., `package foo.extensions.java.io.File`, where `foo` is the name of the module.
To maintain unique names across dependencies, it's generally good practice to further qualify extension classes anyway.

```java
@Extension
public class MyFileExtension {
```
An extension class must be annotated with `@Extension`, this helps Manifold quickly identify extension classes in
your project.

```java
public static String readText(@This File thiz) {
```
All extension methods must be declared `static`, more on this later. As the receiver of the call the first parameter of
an extension *instance* method must be the same type as the extended class, in this case `File`.  The parameter name
`thiz` is conventional, you can use any name you like.

That's basically it for the common case.

## Static Methods

You can define `static` extension methods like this:

```java
@Extension
public static FileSystem getLocalFileSystem() {
  return FileSystems.getDefault();
}
```
Since static methods don’t have a receiver, the method itself must be annotated with `@Extension` so Manifold can 
identify it as such.

Call it as if it were a normal static method on `File`:
```java
File.getLocalFileSystem()
```

## Generics

You can make extensions for generic classes too and define generic extension methods. This is how Manifold extension 
libraries work with collections and other generic classes. For example, here is the `first()` extension method on
`Iterable`:

```java
public static <T> T first(@This Iterable<T> thiz, Predicate<T> predicate) {
  for (T element: thiz) {
    if (predicate.test(element)) {
      return element;
    }
  }
  throw new NoSuchElementException();
}
```

Notice the extension is a generic method with the same type variable designation as the
extended class: `T` from `Iterable<T>`. Since extension methods are static this is how you convey type
variables from the extended class to the extension method.

To define a generic extension method you append the type variables of the *method* to the list of the
extended class' type variables. Manifold's `map()` extension illustrates this format:

```java
public static <E, R> Stream<R> map(@This Collection<E> thiz, Function<? super E, R> mapper) {
  return thiz.stream().map(mapper);
}
```
Here `map` is a generic extension method having type variable `R` and conveying `Collection`'s type
variable `E`.

## Static Dispatching

An extension class does not physically alter its extended class; the methods defined in an extension are
not really inserted into the extended class. Instead the Java compiler and Manifold cooperate to make a
call to a static method in an extension look like a call to an instance method on the extended class. As a
consequence extension calls dispatch *statically*. Thus unlike a virtual method call an extension call is 
always made based on the *compile-time* type of the receiver.

Another consequence of static dispatching is that an extension method can receive a call even if the value
of the extended object is `null` at the call site. Manifold extension libraries exploit this feature to
improve readability and null-safety. For example, `CharSequence.isNullOrEmpty()` compares the
receiver's value to null so you don't have to:

```java
public static boolean isNullOrEmpty(@This CharSequence thiz) {
  return thiz == null || thiz.length() == 0;
}

String name = null;
if (name.isNullOrEmpty()) {
  println("empty");
}
```

Here the example doesn't check for null and instead shifts the burden to the extension.

## Accessibility and Scope

An extension method never shadows or overrides a class method; when an extension method's name and
parameters match a class method, the class method always has precedence over the extension. For example:

```java
public class Tree {
  public void kind() {
    println("evergreen");
  }
}

public static void kind(@This Tree thiz) {
  println("binary");
}
```

The extension method never wins, a call to `kind()` always prints `"evergreen"`. Additionally, if at
compile-time `Tree` and the extension conflict as in the example, the compiler warns of the conflict
in the extension class.

An extension method can still _overload_ a class method where the method names are the same, but the 
parameter types are different:

```java
public class Tree {
  public void harvest() {
    println("nuts");
  }
}

public static void harvest(@This Tree thiz, boolean all) {
  println(all ? "wood" : thiz.harvest());
}
```

A call to `tree.harvest(true)` prints "wood".


## Extension Libraries

An extension library is a logical grouping of functionality defined by a set of extension classes.
Manifold includes several extension libraries for commonly used classes, many of which are adapted
from Kotlin extensions.  Each library is available as a separate module or Jar file you can add 
to your project separately depending on your needs.

*   **Collections**

    Defined in module `manifold-collections` this library extends:
    - java.lang.Iterable
    - java.util.Collection
    - java.util.List
    - java.util.stream.Stream

*   **Text**

    Defined in module `manifold-text` this library extends:
    - java.lang.CharSequence
    - java.lang.String

*   **I/O**

    Defined in module `manifold-io` this library extends:
    - java.io.BufferedReader
    - java.io.File
    - java.io.InputStream
    - java.io.OutputStream
    - java.io.Reader
    - java.io.Writer

*   **Web/Json**
 
    Defined in module `manifold-json` this library extends:
    - java.net.URL
    - javax.script.Bindings

## Summary

Extension methods offer a powerful alternative to *Util* libraries.  The feature is widely supported in modern languages
including C#, Scala, and Kotlin.  Now with Manifold you can use extension methods with Java. Use it to boost
developer productivity with APIs and to benefit from Manifold's built in extension libraries on common classes.  The
easiest and best way to begin using extension methods and other Manifold features is via the Manifold plugin for 
[IntelliJ IDEA](https://www.jetbrains.com/idea/download/).  

**More to come:**
Later in the series I'll cover [Structural Typing](http://manifold.systems/docs.html#structural-interfaces), 
a powerful abstraction similar to interfaces in TypeScript and Go.  Combined with extension classes, structural 
typing makes possible several exciting features including [Extension Interfaces](http://manifold.systems/docs.html#extension-interfaces)
and [Implementation by Extension](http://manifold.systems/docs.html#implementation-by-extension).
  

 

#### Synopsis

Finally you can use `BigDecimal` and other Java types directly in arithmetic and relational operations by incorporating
a feature called [*operator overloading*](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext)
into your project. In this article Scott McKinney walks you through this new capability provided by the
[Manifold](https://github.com/manifold-systems/manifold) project. Along the way he discusses other interesting features
built atop operator overloading including [unit expressions](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#unit-expressions).

# Operator Overloading for Java

The [Manifold extension](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#unit-expressions)
dependency plugs into Java to provide seamless operator overloading capability. You can type-safely provide arithmetic,
relational, and [unit](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#unit-expressions)
operators for any class by implementing one or more predefined *operator methods*. You can implement operator methods
directly in your class or use [extension methods](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#extension-classes-via-extension)
to implement operators for classes you don't otherwise control. For example, using extension methods Manifold provides
operator implementations for `BigDecimal` so you can write code like this:

```java
BigDecimal result = bigValue1 + bigValue2;
```
With unit expressions it gets even better where you can work with `BigDecimal` and other types more easily:
```java
BigDecimal result = 3.14bd * 10.75bd; // `bd` makes BigDecimals
```
Precise measurements via units and operator overloading:
```java
Length distance = 65 mph * 3.2 hr;
HeatCapacity kBoltzmann = 1.380649e-23r J/dK;
```

## Arithmetic and Negation Operators

Any type can support arithmetic operators by implementing one or more of the following operator methods: 

**Arithmetic**

| Operation | Method       |
|:----------|:-------------|
| `a + b`   | `a.plus(b)`  |
| `a - b`   | `a.minus(b)` |
| `a * b`   | `a.times(b)` |
| `a / b`   | `a.div(b)`   |
| `a % b`   | `a.rem(b)`   |

**Negation**

| Operation | Method           |
|:----------|:-----------------|
| `-a`      | `a.unaryMinsu()` |

Note operator methods do not belong to a class or interface you implement. Instead you implement them *structurally*
simply by defining a method with the same signature. Note you can implement several different versions of the same
method differing by parameter type. 

Here's a simple example demonstrating how to implement the `+` operator:
```java
public class Point {
  public final int x, y;
  public Point(int x, int y) {this.x = x; this.y = y;}
  
  public Point plus(Point that) {
    return new Point(x + that.x, y + that.y);
  }
}

var a = new Point(1, 2);
var b = new Point(3, 4);

var sum = a + b; // Point(4, 6)
```

Since operator methods are structural, you can define *multiple* `plus()` methods:
```java
public Point plus(int[] coord) {
  if(coord.length != 2) {
    throw new IllegalArgumentException();
  }
  return new Point(x + coord[0], y + coord[1]);
}
```
   
## Relational Operators

You can implement relational operators using a combination of the `ComparableUsing` and/or `Comparable` interfaces.

### `manifold.ext.api.ComparableUsing`

Relational operators can be implemented all together with the `ComparableUsing` interface, which extends `Comparable`
to provide an operator-specific API.                           
```java
boolean compareToUsing( T that, Operator op );
```
Where `Operator` is an `enum` which specifies constants for relational operators.

| Operation | ComparableUsing Impl      | Comparable Impl       |
|-----------|---------------------------|-----------------------|
| `a > b`   | `a.compareToUsing(b, GT)` | `a.compareTo(b) > 0`  |
| `a >= b`  | `a.compareToUsing(b, GE)` | `a.compareTo(b) >= 0` |
| `a < b`   | `a.compareToUsing(b, LT)` | `a.compareTo(b) < 0`  |
| `a <= b`  | `a.compareToUsing(b, LE)` | `a.compareTo(b) <= 0` |

`ComparableUsing` provides a default implementation for `compareToUsing()` that delegates to `Comparable`'s
`compareTo()` implementation for the `>`, `>=`, `<`, `<=` subset of relational operators.  For the `==` and `!=` subset
`ComparableUsing` delegates to the type's `equals()` method (more on equality later).  This behavior is suitable for
most types, so normally you only need to add `ComparableUsing` to your type's `implements` or `extends` clause and
implement just `Comparable` as you normally would. Thus adding relational operator support to the `Point` example we
have:

```java
public class Point implements ComparableUsing<Point> {
  public final int x, y;
  public Point(int x, int y) {this.x = x; this.y = y;}
  
  public Point plus(Point that) {
    return new Point(x + that.x, y + that.y);
  }
  
  public int compareTo(Point that) {
    return x - that.x;
  }
}
```
Now you can easily compare `Point` values like this:
```java
if (pt1 >= pt2) ...
```

### `java.lang.Comparable`

If you're not interested in supporting `==` and `!=` and your type implements the `Comparable` interface, it
automatically supports the `>`, `>=`, `<`, `<=` subset of relational operators. For example, both `java.lang.String` and
`java.time.LocalDate` implement the `compareTo()` method from `Comparable`, which means they can be used in relational
expressions:

```java
String name1;
String name2;
...
if (name1 > name2) {...}
```   

```java
LocalDate date1;
LocalDate date2;
...
if (date1 > date2) {...}
```

## Equality Operators

To implement the `==` and `!=` subset of relational operators you must implement the `ComparableUsing` interface. By
default `ComparableUsing` delegates to your type's `equals()` method, but you can easily override this behavior by
overriding the `equalityMode()` method in your `CopmarableUsing` implementation. The `EqualityMode` enum provides the
available modes:     

```java
/**
 * The mode indicating the method used to implement {@code ==} and {@code !=} operators.
 */
enum EqualityMode
{
  /** Use the {@code #compareTo()} method to implement `==` and `!=` */
  CompareTo,

  /** Use the {@code equals()} method to implement `==` and `!=` (default) */
  Equals,

  /** Use {@code identity} comparison for `==` and `!=`, note this is the same as Java's normal {@code ==} behavior } */
  Identity
}
```

Based on the `EqualityMode` returned by your implementation of `CompareToUsing#equalityMode()`, the `==` and `!=`
operators compile using the following methods: 

| Operation | `Equals` <small>(default)</small> | `CompareTo`| `Identity` |
|:----------|:-------------------|:--------------------------|:-----------|
| `a == b`  | `a.equals(b)`      | `a.compareToUsing(b, EQ)` | `a == b`   |
| `a != b`  | `!a.equals(b)`     | `a.compareToUsing(b, NE)` | `a != b`   |

Note Manifold generates efficient, **null-safe** code for `==` and `!=`. For example, `a == b` using `Equals` mode
compiles as:
```java
a == b || a != null && b != null && a.equals(b)
``` 

If you need something more customized you can override `compareToUsing()` with your own logic for any of the operators,
including `==` and `!=`.
 
To enable `==` on `Point` more effectively, you can accept the default behavior of `ComparableUsing` and implement
`equals()`:
 
```java
public boolean equals(Object that) {
  return this == that || that != null && getClass() == that.getClass() && 
         x == ((Point)that).x && y == ((Point)that).y;
}
```
>Note always consider implementing `hashCode()` if you implement `equals()`, otherwise your type may not function
>properly when used with `Map` and other data structures:
>```java
>public int hashCode() {
>  return Objects.hash(x, y); 
>}
>```

Sometimes it's better to use the `CompareTo` mode.  For instance, the `==` and `!=` implementations for `Rational`,
`BigDecimal`, and `BigInteger` use the `CompareTo` mode because in those classes `compareTo()` reflects equality in
terms of the *face value* of the number they model e.g., 1.0 == 1.00, which is desirable behavior in many use-cases. In
that case simply override `equalityMode()` to return `CompareTo`:
```java
@Override
public EqualityMode equalityMode() {
  return CompareTo;
}
```
 
## Unit Operators

Unit or "binding" operations are unique to the Manifold framework. They provide a powerfully concise syntax and can be
applied to a wide range of applications. You implement the operator with the `prefixBind()` and `postfixBind()` methods:

| Operation  | Postfix Bind       | Prefix Bind       |
|------------|--------------------|-------------------|
| `a b`      | `b.postfixBind(a)` | `a.prefixBind(b)` |

If the type of `a` implements `R prefixBind(B)` where `B` is assignable from the type of `b`, then `a b` compiles as the
method call `a.prefixBind(b)` having type `R`. Otherwise, if the type of `b` implements `R postfixBind(A)` where `A` is
assignable from the type of `a`, then `a b` compiles as the method call `b.postfixBind(a)` having type `R`.

This feature enables expressions such as:
```java
Mass m = 5 kg;
Force f = 5 kg * 9.8 m/s/s;
for (int i: 1 to 10) {...}
```
Read more about [unit expressions](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#unit-expressions).
 
## Operators by Extension Methods 

Using [extension methods](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#extension-classes-via-extension)
you can provide operator implementations for classes you don't otherwise control. For instance, Manifold provides
operator extensions for [`BigDecimal`](https://github.com/manifold-systems/manifold/blob/master/manifold-deps-parent/manifold-ext/src/main/java/manifold/ext/extensions/java/math/BigDecimal/ManBigDecimalExt.java)
and [`BigInteger`](https://github.com/manifold-systems/manifold/blob/master/manifold-deps-parent/manifold-ext/src/main/java/manifold/ext/extensions/java/math/BigInteger/ManBigIntegerExt.java).
These extensions are implemented in the [`manifold-science`](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-science)
dependency.  

Here's what the `+` extension for `BigDecimal` looks like:
```java
@Extension
public abstract class ManBigDecimalExt implements ComparableUsing<BigDecimal> {
  /** Supports binary operator {@code +} */
  public static BigDecimal plus(@This BigDecimal thiz, BigDecimal that) {
    return thiz.add(that);
  }
  ...
}
```
Now you can perform arithmetic and comparisons using operator expressions:
```java
if (bd1 >= bd2) {
  BigDecimal result = bd1 + bd2;
  . . .
}
```

>Note the [`manifold-science`](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-science)
and [`manifold-collections`](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-collections)
modules use operator overloading and unit expressions extensively.
   
# A Preprocessor for Java

Discover how to build multiple targets from a single Java codebase using [the new preprocessor](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-preprocessor)
from [the Manifold project](https://github.com/manifold-systems/manifold). In this article Scott McKinney explains how
the preprocessor plugs directly into Java's compiler to provide seamless conditional compilation using familiar
directives.


# Preview

Here's a quick preview to give you a taste of Manifold's preprocessor.
<br>
<p>
  <video height="60%" width="60%" controls="controls" preload="auto" onclick="this.paused ? this.play() : this.pause();" autoplay loop>
    <source type="video/mp4" src="/images/preprocessor.mp4">
  </video>
</p>
<br>
We'll dive into what's going on here later in the article.
  
  
# Rationale

There is an undeniable stigma associated with preprocessors, mostly rooted in the C/C++ community. Indeed anyone who has
transitioned from the C++ world to the Java world has their favorite horror story involving the preprocessor.  The
antagonist in the story is invariably *The Macro*. This character is a demonic trickster luring programmers with the
notion that smaller equals simpler and, therefore, better.  But *The Macro's* ultimate goal is obfuscation and he's
remarkably good at achieving that goal. Every other C++ library in use is a testament to this, but I digress. So without
further ado I'll conclude with pointing out the decision to keep *The Macro* out of Java's screenplay proved salutary and
productive. The End.

Oh wait. What about conditional compilation? You know, the other half of the preprocessor. Did Java's designers throw
the baby out with the bathwater by altogether avoiding the preprocessor? Most Java "historians" will cite Java's
*platform independence* as the designers' rationale, after all most usage of `#ifdef` in C/C++ libraries relates to the
many platforms they target. True, however there are a multitude of other dimensions by which a build target may be
determined. For example:
* Java source version (6 v. 8 v. 11)
* Host version (what version of X is running me?)
* Production v. Development v. Test
* Licensed v. Free
* Novice v. Pro
* Feature grouping
* Experimental features
* Prototyping 
* etc.

While you can model your architecture around these dimensions, for example using dependency injection, sometimes that's
a bridge too far, especially when new target dimensions arise with a pre-existing architecture. And sometimes it's not
an either/or proposition -- given the option, some of your architecture can be reasonably refactored, while other
parts may be better off using a preprocessor. In any case having a preprocessor to fall back on is a nice convenience
and deserves a spot in the Java tool chest. This is the rationale behind the new preprocessor from the Manifold project.
  
>Note Java does offer a very limited version of conditional compilation via compile-time constant conditions where
unreachable branches of code are excluded from bytecode. But this type of conditional compilation is restricted to
method bodies, can only reference static final variables, and requires all code to compile regardless of the conditions,
far from a complete solution.  


# Overview

First things first, the preprocessor is a *javac plugin* which means it plugs directly into your Java compiler and runs
as part of javac -- you don't have to add intermediate build steps, manage source generation targets, or any of that.
It also means it's effing *fast* and allows you to easily build multiple targets from a single codebase.

Next, the preprocessor is exclusively designed for conditional compilation, _**No Macros!**_  You can still `#define` a
symbol, but you can't assign a value to it -- a `#define` symbol is always boolean and its value is always `true`,
unless of course the symbol is not defined or is undefined with `#undef`.

As you may have surmised the preprocessor doesn't try to reinvent anything; the directives are taken straight from the
C-family of preprocessors.  These include:

* [`#define`](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-preprocessor#define)
* [`#undef`](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-preprocessor#undef)
* [`#if`](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-preprocessor#if)
* [`#elif`](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-preprocessor#elif)
* [`#else`](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-preprocessor#eles)
* [`#endif`](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-preprocessor#endif)
* [`#error`](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-preprocessor#error) 
* [`#warning`](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-preprocessor#warning)

I've hyperlinked Manifold's documentation for these guys.

An extremely useful feature involves the symbols you can reference from `#if`.  Not only can you reference symbols
you've defined with `#define`, you can also define and use symbols from a host of other sources that are visible to all
your project's files. These include `build.properties` files, which you can place in parent directories starting
with the source root, and javac's `-Akey[=value]` compiler arguments.  Additionally, the preprocessor provides builtin
symbols reflecting environment settings such as `JAVA_9_OR_LATER` and `JPMS_NAMED`.

Note unlike with `#define` symbols, you can define symbols with *string values* using `build.properties` and
`-Akey[=value]` compiler arguments.  In this case you can use *equality expressions* `==` and `!=` to test the value:

```java
#if FOO_VERSION == "1.2.0"
  public void foo(Bar bar) {...}
#endif  
``` 
bulid.properties:
```properties
FOO_VERSION=1.2.0
BAR_VERSION=2019.1.2
EXPERIMENTAL=
```

The environment settings symbols can be extra useful if you target multiple Java versions:
```java
public class MyClass implements
#if JAVA_11_OR_LATER
  SomeJava11Interface
#elif JAVA_8_OR_LATER
  SomeJava8Interface
#else
  #error "Unexpected Java source version"
#endif
{
  ...
}  
```

# A Simple Example

Let's dive into the screencast from the preview earlier in the article.
<br>
<p>
  <video height="60%" width="60%" controls="controls" preload="auto" onclick="this.paused ? this.play() : this.pause();" autoplay loop>
    <source type="video/mp4" src="/images/preprocessor.mp4">
  </video>
</p>
<br>

Here the screencast demonstrates the preprocessor via IntelliJ IDEA using the [Manifold plugin](https://plugins.jetbrains.com/plugin/10057-manifold).
The example uses `#define` to define the `MY_API_X` symbol where valid values for `X` are `1` and `2`. Note in real life
we would define this symbol in a `build.properties` file so other files can access it, but here we use `#define` to
simplify the demo.

The `#if` statements use the symbol to conditionally include or exclude code from compilation. As the value of the
symbol changes you can see the code enabling/disabling to reflect the value. Note you can turn this feature off from the
IntelliJ Settings view in the Manifold section, in this mode only the directives are shaded. In either case the
command line compiler always respects the symbol values.

Notice you can place preprocessor directives anywhere in the class: around `import` statements, classes, methods,
fields, pretty much anywhere. This feature is one of many that distinguishes the preprocessor from Java's compile-time
constant based conditional compilation.

Another cool capability you won't find in conventional preprocessors is the use of multiple directives in a single line.
You can see this in action in the `implements` clause.
 
You can also comment out directives, a feature that is not well supported in many preprocessors.

If you have a C++ background, you might be wondering where `#ifdef` and `#if defined` went. They're simply not needed
because with this preprocessor a symbol evaluates to either `true` or `false`, depending on whether or not the symbol is
defined. Only if you use the `==` or `!=` operator can you access a symbol's *string value*, which as stated earlier can
only be defined with `build.properties` or `-Akey[=value]` compiler arguments. Thus, `#if` covers all the bases. Read
more about this is the [docs](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-preprocessor).

Also of note is the `#elif` directive. This is not a new concept, but if you don't have a C++ background, it may seem
odd. The simple explanation is there's no concise way to say `else if` as you would in Java:

```java
#if FOO
  out.println("FOO");
#else
  #if BAR
    out.println("BAR");
  #else
    #if BAZ
      out.println("BAZ");  
    #endif
  #endif    
#endif
```
It's easier on the eye to use `#elif`:
```java
#if FOO
  out.println("FOO");
#elif BAR
  out.println("BAR");  
#elif BAZ
  out.println("BAZ");  
#endif
```

Finally notice the use of `#error` to respond to an invalid state regarding `MY_API_X`.  This directive produces a
compile-time error at the location of its use. It's perfect for detecting and reporting a misconfigured build at
*compile-time*.
 
 
# Conclusion

Manifold reimagines the time-tested C/C++ preprocessor as a more effective means to meet today's conditional compilation
demands. It directly integrates with your Java compiler so you can quickly and easily build multiple targets from a
single codebase. You can define and use symbols from a variety of sources including properties files and environment
settings to conditionally compile every aspect of your source code. Using plugin support for IntelliJ IDEA you can
visualize exactly how your code reacts to the preprocessor directives and symbols you use. [Check it out](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-preprocessor).

Check out the [Manifold project](https://github.com/manifold-systems/manifold) for more Java goodness.   

# Java Access Control, Stop the Insanity!

![crazy pills](http://manifold.systems/images/crazy-pills.jpg)

Java access modifiers `protected`, `package-private`, and `private` are enforced *both* by the compiler and the JVM.
Here Scott McKinney explains why this is insane and how access to internals could be made much simpler and type-safe.

## Crazy Talk

You use access modifiers as a means to separate API from implementation (aka encapsulation). The modifiers provide a 
clean way for you to tell other developers, "Here's the stuff I intend for you to use, all the rest is internal to my
implementation."  In essence access modifiers help you define, identify, and safely use an API.

Fortunately the Java compiler ensures you don't unintentionally cross the boundaries established by the modifiers.
There's no way you can call a private method illegally without the compiler complaining about it. So why does the JVM
also enforce access control when the compiler has already done the work? Is it a form of *security*? Sadly this
is a widely held misconception. Allow me to explain. 

The lock on your front door is a form of security, right?  The lock's purpose is to prevent an intruder from entering
your home.  One thing you wouldn't do is devise a way for intruders to evade your security. And you certainly would not
advertise this information for all to see, right?  For example, you wouldn't post a sign on your front lawn describing
the spare bedroom window you leave wide open specifically for intruders, right?  Otherwise by definition the lock on
your door is not a form of security, but is instead an indication of insanity.  

The Java Reflection API is the sign posted on the JVM's front lawn. It explains precisely how to bypass access control;
you can call any method you like using reflection. Therefore under normal circumstances<sup>[1](#f1)</sup> JVM access
control is not in any logical sense a form of security.

Repeat after me:
* *JVM access control is not security*
* *My class internals will be "abused" at runtime and that is okay by me*

## Wishful Thinking

As previously stated under normal circumstances there is no reason the JVM should prevent bytecode from accessing a
type's internals since the compiler already makes the necessary guarantees. Furthermore there should be a way to use
normal, type-safe syntax to access internals -- nothing is accomplished by making it hard and slow and dangerous with
reflection.

As a productive alternative the Java language could provide a simpler, type-safe syntax to access otherwise hidden
symbols:
```java
unsafe Foo foo = new Foo();
foo.privateMethod();
foo.privateField = null;
```
The `unsafe` modifier informs the compiler of your *intention* to type-safely use internal symbols of `Foo`. As such
the compiler grants `foo` with open access to `Foo`.  The advantages of this approach are compelling:
* Your code is **type-safe**, the compiler verifies access to internal symbols
* If the internals change, your code breaks at **compile-time**, not runtime
* Your code is much **easier to read** and maintain
* Your code is visible to **static analysis tooling** 
* It **eliminates caching** and other complications associated with reflection

All of this could be achieved with or without the cooperation of the JVM.  If access control were removed from runtime,
great! Aside from the support for the new `unsafe` modifier, nothing else is needed from the compiler and performance is
optimal.  Otherwise, the compiler could generate reflection code for usages of `unsafe` variables, still a big win.

## Back to Reality

Of course all of this is make believe, `unsafe` will never see the light of day in Redwood City. But should we give up?
[Was it over when the Germans bombed Pearl Harbor?](https://www.youtube.com/watch?v=Wv5c2YR1lVE) Heck no! Where there's
a will, there's a way... 

Increasingly the [Manifold framework](http://manifold.systems) picks up where Java leaves off in terms of type system
limitations. In the case of access control Manifold provides a feature aptly named [Type-safe Reflection](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#type-safe-reflection-via-jailbreak).
It is nearly identical to the `unsafe` proposal:
```java
@Jailbreak Foo foo = new Foo();
foo.privateMethod();
foo.privateField = null;
```       
As with `unsafe` the `@Jailbreak` annotation grants `foo` full access to `Foo`, all type-safe and compiler friendly.
Additionally IntelliJ IDEA provides comprehensive support for Manifold via plugin. Read more about Type-safe Reflection
and other features at [Manifold.io](http://manifold.io).  
 

<small><a name="f1">1</a>: Standard JVMs and conventional JDKs and application environments are the focus of this
article.</small> # Say Goodbye to Checked Exceptions

Modern languages don't do checked exceptions. But you don't have to jump ship to share the experience. In this article
Scott McKinney shows you how to stick with Java and completely neutralize checked exceptions with a simple new addition
to the [Manifold framework](http://manifold.systems/).
 
## Overview

Most contemporary JVM languages including Scala, [Kotlin](https://kotlinlang.org/docs/reference/exceptions.html), and [Ceylon](https://ceylon-lang.org/documentation/1.3/reference/statement/throw/),
do not distinguish between checked and unchecked exceptions, they're all treated as unchecked.  Similarly, the .NET CLR
does not have checked exceptions.  This is not a coincidence as there is an abundance of evidence to backup their
collective decision not to follow Java's example. Since this subject can be rather controversial, I'll defer to one of
my favorite language authors, Anders Hejlsberg, on the subject with [The Trouble with Checked Exceptions](https://www.artima.com/intv/handcuffs.html)
and move on.

## Exhibit A

Checked exceptions tend to result in boilerplate code where in order to handle an exception a call site is nested in a
`try/catch` statement and the checked exception is wrapped in an unchecked exception and rethrown:

```java
URL url;
try {
    url = new URL("http://manifold.systems/");
} catch (MalformedURLException e) {
    throw new RuntimeException(e);  // the boilerplate of boilerplates
}
try (BufferedReader reader = new BufferedReader( new InputStreamReader(url.openStream()))) {
  reader.lines().forEach(out::println);
} catch (IOException e) {
    // Whoops! Unintentionally swallowed!
}
```

As you can see the code is made much less readable with checked exceptions. Unfortunately this is not the worst part.
You can see one of the exceptions is not rethrown, but is instead *ignored*.  Unintentional exception swallowing is
a common cause for critical, hard to resolve bugs.

What is most frustrating, however, is all of this boilerplate code is written, basically, to say "I don't handle this,
please go away."  Indeed what you really mean to write is this:

```java
URL url = new URL("http://manifold.systems/");
try (BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()))) {
    reader.lines().forEach(out::println);
}
```

Concise, readable, and exception friendly.


## Good News!
 
With Manifold's new `manifold-exceptions` dependency you can now *choose* whether or not your Java project enforces
checked exceptions.  If you like checked exceptions, that's fine, simply do nothing.  Otherwise, you can effectively
neutralize checked exceptions and improve your productivity simply by adding a dependency and a javac argument to your
existing project:

```groovy
dependencies {
    // Add manifold-exceptions to neutralize checked exceptions
    compile group: 'systems.manifold', name: 'manifold-exceptions', version: '2019.1.32'

    // Add manifold-exceptions to -processorpath for javac (for Java 9+, not needed for Java 8)
    annotationProcessor group: 'systems.manifold', name: 'manifold-exceptions', version: '2019.1.32'
}

tasks.withType(JavaCompile) {
    options.compilerArgs += '-Xplugin:Manifold'
    options.fork = true
}
```

Now checked exceptions can safely rise unimpeded and you can avoid writing unsightly boilerplate madness. Additionally,
you can use the [Manifold plugin for IntelliJ IDEA](https://plugins.jetbrains.com/plugin/10057-manifold) to write clean
code in a nice, fully Manifold-aware environment.  

Enjoy!

>Read more about the [`manifold-exception` dependency](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-exceptions)
online. While you're there check out more of the [Manifold framework](http://manifold.systems/) including [extension methods](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext),
comprehensive, type-safe access to [GraphQL](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-graphql),
[JSON](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-json), and a ton more.

---
layout: default
---

<div>
  <div class="col-md-3">

### Projects

The Manifold framework consists of the *core project* and a collection of *sub-projects* implementing SPIs provided
by the core.

[Manifold : _Core_](https://github.com/manifold-systems/manifold/tree/master/manifold-core-parent/manifold)
---
[Manifold :
_GraphQL_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-graphql)
[Manifold : _JSON_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-json)
[Manifold : _YAML_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-yaml)
[Manifold :
_Properties_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-properties)
[Manifold : _Image_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-image)
[Manifold : _Dark
Java_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-darkj)
[Manifold : _JavaScript_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-js)
---
[Manifold : _Java
Extension_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext)
---
[Manifold :
_Templates_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-templates)
---
[Manifold : _String
Templates_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-strings)
<small>(string interpolation)</small>
[Manifold :
_[Un]checked_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-exceptions)
---
[Manifold :
_Preprocessor_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-preprocessor)
---
[Manifold :
_Collections_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-collections)
[Manifold : _I/0_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-io)
[Manifold : _Text_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-text)

### Sample Projects

[Sample Project](https://github.com/manifold-systems/manifold-sample-project)
[GraphQL Sample App](https://github.com/manifold-systems/manifold-sample-graphql-app)
[EST API Sample App](https://github.com/manifold-systems/manifold-sample-rest-api)
[Sample Web App](https://github.com/manifold-systems/manifold-sample-web-app)
  </div>
  <div class="col-md-9">
    {{ content }}
  </div>
</div># Manifold : All

The `manifold-all` dependency is an "uber" JAR (aka "fat" JAR) for manifold.  It conveniently bundles all the Manifold
dependencies into a single JAR. 


# IDE Support

Use the [Manifold plugin](https://plugins.jetbrains.com/plugin/10057-manifold) for IntelliJ IDEA to really boost your
productivity. 

# Setup

## Building this project

The `manifold-all` project is defined with Maven.  To build it install Maven and run the following command.

```
mvn compile
```

## Using this project

The `manifold-all` dependency works with all build tooling, including Maven and Gradle. It also works with Java
versions 8 - 13.

## Binaries

If you are *not* using Maven or Gradle, you can download the latest `manifold-all` release here: [manifold-all](https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=systems.manifold&a=manifold-all&v=RELEASE)

## Gradle

Here is a sample `build.gradle` script. Change `targetCompatibility` and `sourceCompatibility` to your desired Java
version (8 - 13), the script takes care of the rest. 
```groovy
plugins {
    id 'java'
}

group 'systems.manifold'
version '1.0-SNAPSHOT'

targetCompatibility = 11
sourceCompatibility = 11

repositories {
    jcenter()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
}

dependencies {
    compile group: 'systems.manifold', name: 'manifold-all', version: '2019.1.32'
    testCompile group: 'junit', name: 'junit', version: '4.12'

    if (JavaVersion.current() == JavaVersion.VERSION_1_8) {
        // tools.jar dependency (for Java 8 only), primarily to support structural typing without static proxies.
        // Thus if you are *not* using structural typing, you **don't** need tools.jar
        compile files( "${System.properties['java.home']}/../lib/tools.jar" )
    }
    // Add manifold to -processorpath for javac
    annotationProcessor group: 'systems.manifold', name: 'manifold-all', version: '2019.1.32'
}

if (JavaVersion.current() != JavaVersion.VERSION_1_8 &&
    sourceSets.main.allJava.files.any {it.name == "module-info.java"}) {
    tasks.withType(JavaCompile) {
        // if you DO define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold', '--module-path', it.classpath.asPath]
    }
} else {
    tasks.withType(JavaCompile) {
        // If you DO NOT define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold']
    }
}

tasks.compileJava {
    classpath += files(sourceSets.main.output.resourcesDir) //adds build/resources/main to javac's classpath
    dependsOn processResources
}
tasks.compileTestJava {
    classpath += files(sourceSets.test.output.resourcesDir) //adds build/resources/test to test javac's classpath
    dependsOn processTestResources
}
```
Use with accompanying `settings.gradle` file:
```groovy
rootProject.name = 'MyProject'
```

## Maven

### Java 8

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-manifold-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Manifold App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-all</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>8</source>
                    <target>8</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
        </plugins>
    </build>
    
    <profiles>
        <!-- tools.jar dependency (for Java 8 only), primarily to support structural typing without static proxies.
             Thus if you are not using structural typing, you **don't** need tools.jar -->
        <profile>
            <id>internal.tools-jar</id>
            <activation>
                <file>
                    <exists>\${java.home}/../lib/tools.jar</exists>
                </file>
            </activation>
            <dependencies>
                <dependency>
                    <groupId>com.sun</groupId>
                    <artifactId>tools</artifactId>
                    <version>1.8.0</version>
                    <scope>system</scope>
                    <systemPath>\${java.home}/../lib/tools.jar</systemPath>
                </dependency>
              </dependencies>
        </profile>
    </profiles>    
</project>
```

### Java 9 or later
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-manifold-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Manifold App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-all</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                    <!-- Add the processor path for the plugin (required for Java 9+) -->
                    <annotationProcessorPaths>
                        <path>
                            <groupId>systems.manifold</groupId>
                            <artifactId>manifold-all</artifactId>
                            <version>${manifold.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

# License

## Open Source
Open source Manifold is free and licensed under the [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0) license.  

## Commercial
Commercial licenses for this work are available. These replace the above ASL 2.0 and offer 
limited warranties, support, maintenance, and commercial server integrations.

For more information, please visit: http://manifold.systems//licenses

Contact: admin@manifold.systems

# Versioning

For the versions available, see the [tags on this repository](https://github.com/manifold-systems/manifold/tags).

# Author

* [Scott McKinney](mailto:scott@manifold.systems)
![manifold framwork](http://manifold.systems/images/manifold_framework.png)

# Manifold : Core

The core framework plugs directly into the Java compiler via the [Javac plugin API](https://docs.oracle.com/en/java/javase/11/docs/api/jdk.compiler/com/sun/source/util/Plugin.html)
as a universal *type* adapter to allow for a direct and seamless supply of types and features otherwise inaccessible to
Java's type system. As such the Manifold core framework provides a foundation and plugin SPI to dynamically resolve
type names and produce corresponding Java sources, and to more generally augment Java's type system. Such a plugin is
called a *type manifold* and implements the `ITypeManifold` SPI. 

## Table of Contents
* [The Big Picture](#the-big-picture)
* [The API](#the-api)
* [Anatomy of a Type Manifold](#anatomy-of-a-type-manifold)
* [Modes](#modes)
* [Embedding with _Fragments_ (experimental)](#embedding-with-fragments-experimental)
* [Using `@Precompile`](#using-precompile)
* [IDE Support](#ide-support)
* [Projects](#projects)
* [Sample Projects](#sample-projects)
* [Setup](#setup)
* [License](#license)
* [Versioning](#versioning)
* [Author](#author)


# The Big Picture

You can think of a type manifold as a **_just-in-time_ code generator**. Essentially the Manifold framework plugs in and
overrides the compiler's type resolver so that, via the `ITypeManifold` SPI, a type manifold can claim ownership of
type names as the compiler encounters them and dynamically provide source code corresponding with the types. As a
consequence this core functionality serves as a productive alternative to conventional code generation techniques, a
long overdue advancement for static typing. 

To begin with, because the framework plugs directly into the compiler, a code generator as a type manifold *is no longer
a separate build step*. What's more a type manifold generates code on-demand as the compiler asks for types. Not only
does this significantly reduce the complexity of code generators, it also enables them to function *incrementally*. This
means resources on which the generated sources are based can be edited and only the types corresponding with the changes
will be regenerated and recompiled. Thus, contrary to conventional code generators, type manifolds:
* require **_zero_ build steps**
* produce **_zero_ on-disk source code**
* are by definition **always in sync** with resources
* are **inherently incremental** resulting in **optimal build times** 
* are **dead simple to use** - just add a dependency to your project

Moreover, type manifolds can *cooperate* and contribute source to types in different ways. Most often a type manifold
registers as a *primary* contributor to supply the main body of the type. The [JSON type manifold](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-json),
for example, is a *primary* contributor because it supplies the full type definition corresponding with a JSON Schema
file or sample file. Alternatively, a type manifold can be a *partial* or *supplementary* contributor. For instance, the
[Extension type manifold](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext)
is a *supplementary* contributor because it augments an existing type with additional methods, interfaces, and other
features.  Thus both the JSON and Extension type manifolds can contribute to the same type, where the JSON manifold
supplies the main body and the Extension type manifold contributes custom methods and other features provided by [extension classes](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext##extension-classes-via-extension).
As a consequence any number of type manifolds can operate in concert to form an efficient and powerful type building
pipeline, thus unlike conventional code generators, type manifolds:
* can easily **have dependencies on one another**
* can easily **contribute to one another's types**
* are **customizable with _extensions_**

Finally, the Manifold core framework can be used from IDEs and other tooling to provide consistent, unified access to
the types and features produced from all type manifolds. For instance, the [Manifold plugin for IntelliJ IDEA](https://plugins.jetbrains.com/plugin/10057-manifold)
provides comprehensive support for the Manifold framework. All types and features produced from type manifolds and other
Manifold SPIs are fully supported. You can edit resources such as JSON and GraphQL files and immediately use the changes
in Java without a compilation step. Features like code completion, resource/code navigation, deterministic usage
searching, refactoring/renaming, incremental compilation, hotswap debugging, etc. work seamlessly with *all* type
manifolds past, present, and future. This represents a tremendous leap in productivity compared with the conventional
code generation world where the burden is on the code generator author or third party to invest in one-off IDE tooling
projects, which typically results in poor or no IDE representation. Thus another big advantage type manifolds possess
over conventional code generators is:
* a **unified framework**...
* ...which enables **comprehensive IDE support** and more

To summarize, the Manifold framework provides a clear advantage over conventional code generation techniques. Type
manifolds do not entail build steps, are always in sync, operate incrementally, and are simple to add to any project.
They also cooperate naturally to form a powerful type building pipeline, which via the core framework is uniformly
accessible to IDEs such as IntelliJ IDEA. Putting it all together, the synergy resulting from these improvements has the
potential to significantly increase Java developer productivity and to open minds to new possibilities. 

# The API

The framework consists of the several SPIs:

* [ITypeManifold]() This SPI is the basis for implementing a _type manifold_. See existing type manifold projects such as [`manifold-graphql`](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-graphql). 
* [ICompilerComponent]() Implement this low-level SPI to supplement Java with new or enhanced behavior e.g., [`manifold-strings`](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-strings) and [`manifold-exceptions`](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-exceptions).
* [IPreprocessor]() Implement this SPI to provide a _preprocessor_ to filter source before it enters Java's parser e.g., [`manifold-preprocessor`](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-preprocessor).
* [IProxyFactory]() This SPI addresses _structural interface_ performance; you implement this to provide a compile-time
proxy for a specific structural interface.

# Anatomy of a Type Manifold

Any data resource is a potential type manifold.  These include file schemas, query languages, database definitions, 
data services, templates, spreadsheets, programming languages, and more.  So while the Manifold team provides several 
type manifolds out of the box the domain of possible type manifolds is virtually unlimited.  Importantly, their is 
nothing special about the ones we provide -- you can build type manifolds using the same public API with which ours
are built.

The API is comprehensive and aims to fulfill the 80/20 rule -- the common use-cases are straightforward to implement,
but the API is flexible enough to achieve almost any kind of type manifold. For instance, since most type manifolds are
resource file based the API foundation classes handle most of the tedium with respect to file management, caching, and
modeling. Also, since the primary responsibility for a type manifold is to dynamically produce Java source, Manifold
provides a simple API for building and rendering Java classes. But the API is flexible so you can use other tooling as
you prefer.

Most resource file based type manifolds consist of three basic classes:
* `JavaTypeManifold` subclass
* A class to produce Java source 
* `Model` subclass
 
The `Image` manifold is relatively simple and nicely illustrates this structure:


**JavaTypeManifold Subclass**
```java
public class ImageTypeManifold extends JavaTypeManifold<Model> {
  private static final Set<String> FILE_EXTENSIONS = new HashSet<>(Arrays.asList("jpg", "png", "bmp", "wbmp", "gif"));

  @Override
  public void init(IModule module) {
    init(module, Model::new);
  }

  @Override
  public boolean handlesFileExtension(String fileExtension) {
    return FILE_EXTENSIONS.contains(fileExtension.toLowerCase());
  }

  @Override
  protected String aliasFqn(String fqn, IFile file) {
    return fqn + '_' + file.getExtension();
  }

  @Override
  protected boolean isInnerType(String topLevel, String relativeInner) {
    return false;
  }

  @Override
  protected String produce(String topLevelFqn, String existing, Model model, DiagnosticListener<JavaFileObject> errorHandler) {
    SrcClass srcClass = new ImageCodeGen(model._url, topLevelFqn).make();
    StringBuilder sb = srcClass.render(new StringBuilder(), 0);
    return sb.toString();
  }
}
```
Like most type manifolds the image manifold is file extension based, specifically it handles the domain of files having 
image extensions: jpg, png, etc.  As you'll see, the `JavaTypeManifold` base class is built to handle this use-case.
First, `ImageTypeManifold` overrides the `init()` method to supply the base class with its `Model`.  We'll cover
that shortly.  Next, it overrides `handlesFileExtension()` to tell the base class which file extensions it handles.
Next, since the image manifold produces classes with a slightly different name than the base file name, it overrides 
`aliasFqn()` to provide an alias for the qualified name of the form `<package>.<image-name>_<ext>`.  The name must
match the class name the image manifold produces. There are no inner classes produced by this manifold, therefore
it overrides `isInnerType()` returning false; the base class must ask the subclass to resolve inner types.  Finally,
the image manifold overrides `contribute()`, this is where you contribute Java source for a specified class name.


**Source Production Class**

Most often, you'll want to create a separate class to handle the production of Java source.  The image manifold does 
that with `ImageCodeGen`:

```java
public class ImageCodeGen {
  private final String _fqn;
  private final String _url;

  ImageCodeGen(String url, String topLevelFqn) {
    _url = url;
    _fqn = topLevelFqn;
  }

  public SrcClass make() {
    String simpleName = ManClassUtil.getShortClassName(_fqn);
    return new SrcClass(_fqn, SrcClass.Kind.Class).imports(URL.class, SourcePosition.class)
      .superClass(new SrcType(ImageIcon.class))
      .addField(new SrcField("INSTANCE", simpleName).modifiers(Modifier.STATIC))
      .addConstructor(new SrcConstructor()
        .addParam(new SrcParameter("url")
          .type(URL.class))
        .modifiers(Modifier.PRIVATE)
        .body(new SrcStatementBlock()
          .addStatement(new SrcRawStatement()
            .rawText("super(url);"))
          .addStatement(new SrcRawStatement()
            .rawText("INSTANCE = this;"))))
      .addMethod(new SrcMethod().modifiers(Modifier.STATIC)
        .name("get")
        .returns(simpleName)
        .body(new SrcStatementBlock()
          .addStatement(
            new SrcRawStatement()
              .rawText("try {")
              .rawText("  return INSTANCE != null ? INSTANCE : new " + simpleName + 
                "(new URL("\\" + ManEscapeUtil.escapeForJavaStringLiteral(_url) + "\\"));")
              .rawText("} catch(Exception e) {")
              .rawText("  throw new RuntimeException(e);")
              .rawText("}"))));
  }
}
```

Here the image manifold utilizes `SrcClass` to build a Java source model of image classes.  `SrcClass` is a
source code production utility in the Manifold API.  It's simple and handles basic code generation use-cases.
Feel free to use other Java source code generation tooling if `SrcClass` does not suit your use-case, because
ultimately your only job here is to produce a `String` consisting of Java source for your class.


**Model Subclass**

The third and final class the image manifold provides is the `Model` class:

```java
class Model extends AbstractSingleFileModel {
  String _url;

  Model(String fqn, Set<IFile> files) {
    super(fqn, files);
    assignUrl();
  }

  private void assignUrl() {
    try {
      _url = getFile().toURI().toURL().toString();
    } catch (MalformedURLException e) {
      throw new RuntimeException(e);
    }
  }

  public String getUrl() {
    return _url;
  }

  @Override
  public void updateFile(IFile file) {
    super.updateFile(file);
    assignUrl();
  }
}
```

This class models the image data necessary for `ImageCodeGen` to produce source as a `AbstractSingleFileModel` subclass. 
In this case the model data is simply the URL for the image. Additionally, `Model` overrides `updateFile()` to keep the
URL up to date in environments where it can change, such as in an IDE.


**Registration**

In order to use a type manifold in your project, it must be registered as a service.  Normally, as a type
manifold provider to save users of your manifold from this step, you self-register your manifold in your 
META-INF directly like so:
```
src
-- main
---- resources
------ META-INF
-------- services
---------- manifold.api.type.ITypeManifold
```
Following standard Java [ServiceLoader protocol](https://docs.oracle.com/javase/7/docs/api/java/util/ServiceLoader.html)
you create a text file called `manifold.api.type.ITypeManifold` in the `service` directory under your `META-INF` directory.
The file should contain the fully qualified name of your type manifold class (the one that implements `ITypeManifold`) followed
by a new blank line:
```
com.abc.MyTypeManifold

```

As you can see building a type manifold can be relatively simple. The image manifold illustrates the basic structure of
most file-based manifolds. Of course there's much more to the API. Examine the source code for other manifolds such as
the GraphQL manifold ([manifold-graphql](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-graphql))
and the JavaScript manifold ([manifold-js](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-js)).
These serve as decent reference implementations for wrapping parsers and binding to existing languages.

>Note with Java 9+ with named modules you register a service provider in your `module-info.java` file using the
`provides` keyword:
>```java
>provides manifold.api.type.ITypeManifold with com.abc.MyTypeManifold
>```

# Modes

You can use Manifold in one of two modes which you control as an optional argument to the Manifold plugin for javac:

* **static**: `-Xplugin:Manifold` (default) compiles resource types statically at compile-time

* **dynamic**: `-Xplugin:Manifold dynamic` compiles resource types _dynamically_ at _runtime_
(alternatively `-Xplugin:"Manifold dynamic"`, some tools may require quotes)

Most projects benefit most using the default (static) mode. Dynamic mode in most cases should be reserved for specific
type manifolds that are better suited to dynamic compilation.

> Note if you're not sure which mode to use, try the default static mode -- it's usually the right choice.

General information considering the static v. dynamic mode:

* Both modes operate _lazily_: a type is not compiled unless it is used. For example, if you are using the [JSON manifold](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-json), 
only the JSON files you reference in your code will be processed and compiled. This means Manifold will not try to
compile resources your project does not expect to use directly as types.

* Even if you use static mode, you can still reference type manifold classes dynamically e.g., _reflectively_.
In such a case Manifold will dynamically compile the referenced class as if you were operating in dynamic mode. In
general, your code will work regardless of the mode you're using, hence the general recommendation to stay with static
mode where you get the best of both worlds. 

* Dynamic mode requires `tools.jar` at runtime for **Java 8**.  Note tools.jar may still be required with static mode,
depending on the Manifold features you use.  For example, if you use [structural interfaces](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#structural-interfaces-via-structural)
your project _may_ require tools.jar, regardless of mode. This largely depends on whether or not the an [`IProxyFactory`](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#implementation-by-proxy)
implementations exist for the structural interfaces involved.

* Static mode is generally faster at runtime since it pre-compiles all the type manifold resources along with Java 
sources when you build your project

* Static mode automatically supports **incremental compilation** and **hotswap debugging** of modified resources in IntelliJ
   
> Note, you can use `@Precompile` to instruct the Java compiler to compile a set of specified types regardless of 
whether or not you use them directly in your code e.g., if your code is an API.  See [Using @Precompile](#using-precompile).
 

# Embedding with Fragments (experimental)

You can now *embed* resource content such as JSON, GraphQL, XML, YAML, CSV, etc. directly in a Java source file as a type-safe
resource _**fragment**_.  A fragment has the same format and grammar as a resource file and, if used with the Manifold
IDE plugin, can be authored with rich editor features like code highlighting, parser feedback, code completion, etc.
This means you can directly embed resources closer to where you use them in your code.  For instance, you can
type-safely write a query in the query language your application uses directly in the Java method that uses the query.

You can embed a fragment as a *declaration* or a *value*.

## Type Declaration

You can type-safely embed resources directly in your Java code as declarations.  Here's a simple example using
Javascript:
```java
public class MyJavaClass {
  void foo() {
    /*[>Barker.js<]
    function callBark(aBarker) {
      aBarker.bark();
    }
    */
    Barker.callBark(new Dog());
    Barker.callBark(new Tree());
    class Dog {
      public String bark() {
        return "ruff";
      }
    }
    class Tree {
      public String bark() {
        return "rough";
      }
    }
  }
}
``` 
Notice the Javascript is embedded in a multiline comment. This is how you embed any kind of resource fragment as a type
declaration.  Here the Javascript type is declared as `Barker` with a `.js` extension indicating the resource type. Note
a fragment must use `[>` and `<]` at the beginning of the comment to delimit the type name and extension.  A fragment
covers the remainder of the comment and must follow the format of the declared extension.

You can embed any Manifold enabled resource as a fragment type declaration.  Here's another example using JSON:
```java
void foo() {
  /*[>Planet.json<]
  {
    "name": "Earth",
    "system": {
      "name": "Sol",
      "mass": 1.0014
    }
  }
  */
  // Work with the content type-safely
  Planet planet = Planet.fromSource();
  String name = planet.getName();
  Planet.system sys = planet.getSystem();
  
  // Make a REST call
  Planet.request(endpoint).postOne(planet);
  
  // Use the JSON bindings 
  Map<String, Object> jsonBindings = planet.getBindings();
  
  // Make a new Planet
  Planet mars = Planet.builder()
  .withName("Mars")
  .withSystem(sys)
  .build();
  
  // Transform to another format
  String yaml = planet.writer().toYaml();
}
```
 
## Scoping 
A fragment can be embedded anywhere in your code.  The type declared in the fragment is scoped to the package of the
enclosing class.  Thus in the example `Barker` is accessible anywhere in the enclosing `foo` method *as well as* foo's
declaring class and other classes in its package.

>Note, even though the declared type is package scoped, for the sake of readability it is best to define the fragment
nearest to its intended use. In a future release this level of scoping may be enforced.

## Rich Editing
If used with the Manifold IntelliJ IDEA plugin, you can edit fragments as if they were in a separate file with all the
editor features you'd expect like highlighting, parser feedback, code completion, etc.  This is especially useful with
GraphQL, SQL, and similar resources where editing a fragment in place provides a more fluid development experience. 
 
## Value Fragments (experimental)
Sometimes it's more convenient to use a fragment as a *value* as opposed to a type declaration. For example, you can
create a GraphQL query as a fragment value and assign it to a variable:
 
```java 
var moviesByGenre = "[>.graphql<] query MoviesByGenre($genre: genre) { movies(genre: $genre) { title } }";
var query = moviesByGenre.builder().withGenre(Action).build();
var actionMovies = query.request(ENDPOINT).post();
``` 

Here a GraphQL query is embedded directly in a String literal as a fragment *value*.  The resulting type is based on
the fragment type in use.  In this case the GraphQL type manifold provides a special type with the single purpose of
exposing a query `builder` method matching the one the `MoviesByGenre` query defines.

Note not all manifold resources can be used as fragment values. The fragment value concept is not always a good fit.
For instance, the Properties manifold does not implement fragment values because a properties type is used statically.

Note fragments as values will become more useful with multiline String literals via the new
[Text Blocks](https://openjdk.java.net/jeps/355) feature in Java 13:
```java
var query = """
  [>.graphql<]
  query Movies($genre: Genre!, $title: String, $releaseDate: Date) {
    movies(genre: $genre, title: $title, releaseDate: $releaseDate) {
      id
      title
      genre
      releaseDate
    }
  }
  """;
var result = query.create(Action).request(ENDPOINT).post();
```    

>**Note to Type Manifold service providers**
>
>To support fragments as *values* you must annotate your toplevel types with `@FragmentValue`.
This annotation defines two parameters: `methodName` and `type`, where `methodName` specifies the name of a static 
method to call on the top-level type that represents the type's value, and where `type` is the qualified name of the
value type, which must be contravariant with the `methodName` return type. See the 
[GraphQL type manifold implementation](https://github.com/manifold-systems/manifold/blob/master/manifold-deps-parent/manifold-graphql/src/main/java/manifold/graphql/type/GqlParentType.java)
for a reference.


# Using `@Precompile`

By default a Type Manifold compiles a resource type only if you use it somewhere in your code.  Normally this is 
desirable because if you don't use it as a Java class, why compile it?  There are cases, however, where *your*
code may not be the only code that potentially uses the resources.  For instance, if your project provides an API
in terms of JSON Schema files, there's a good chance your project doesn't use the JSON directly -- but consumers of your API do.
A similar case involves a mutli-module Java 11 project where a module provides resource files, but only dependent modules
use them as Manifold types.  Although Manifold works in both of these situations, it compiles the types dynamically,
which entails a one time performance bump the first time each class is used at runtime. For cases like these you can
avoid dynamic compilation using the `@Precompile` annotation.

You can annotate any class in your project/module with `@Precompile`. For example, if you are using the JSON manifold,
you can instruct the Java compiler to compile all `.json` files regardless of whether or not your module uses them as
types:
```java
@Precompile(fileExtension = "json")
public class Main {
  ...
}
```

You can refine `@Precompile` to compile only files matching a regex pattern:
```java
@Precompile(fileExtension = "yml", typeNames = "com.abc.(My)+")
```
This tells the compiler to precompile YAML files in package `com.abc` starting with `"My"`.

You can also specify the type manifold class.  This example is logically the same as the previous one:
```java
@Precompile(typeManifold = YamlTypeManifold.class, typeNames = "com.abc.(My)+")
```

You can also stack `@Precompile`:
```java
@Precompile(fileExtension = "json", typeNames = "com.abc.(My)+")
@Precompile(fileExtension = "yml", typeNames = "com.abc.(My)+")
```
This tells the compiler to precompile all JSON and YAML files in package `com.abc` starting with `"My"`.

Finally, an easy way to tell the Java compiler to compile *all* the files corresponding with all the type manifolds
enabled in your module:
```java
@Precompile
```

# IDE Support 

Manifold is best experienced using [IntelliJ IDEA](https://www.jetbrains.com/idea/download).

## Install

Get the [Manifold plugin](https://plugins.jetbrains.com/plugin/10057-manifold) for IntelliJ IDEA directly from IntelliJ
via:

<kbd>Settings</kbd> ➜ <kbd>Plugins</kbd> ➜ <kbd>Marketplace</kbd> ➜ search: `Manifold`

<p><img src="http://manifold.systems/images/ManifoldPlugin.png" alt="echo method" width="60%" height="60%"/></p>


# Projects
The Manifold framework consists of the core project and a collection of sub-projects implementing SPIs provided
by the core. Each project represents a separate **dependency** you can easily add to your project:

[Manifold : _Core_](https://github.com/manifold-systems/manifold/tree/master/manifold-core-parent/manifold)<br>

[Manifold : _GraphQL_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-graphql)<br>
[Manifold : _XML_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-xml)<br>
[Manifold : _CSV_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-csv)<br>
[Manifold : _JSON_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-json)<br>
[Manifold : _YAML_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-yaml)<br>
[Manifold : _Properties_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-properties)<br>
[Manifold : _Image_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-image)<br>
[Manifold : _Dark Java_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-darkj)<br>
[Manifold : _JavaScript_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-js)<br>

[Manifold : _Java Extension_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext)<br>

[Manifold : _Templates (ManTL)_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-templates)<br>

[Manifold : _String Interpolation_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-strings)<br>
[Manifold : _[Un]checked Exceptions_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-exceptions)<br>

[Manifold : _Preprocessor_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-preprocessor)<br>

[Manifold : _Science_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-science)<br>

[Manifold : _Collections_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-collections)<br>
[Manifold : _I/0_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-io)<br>
[Manifold : _Text_](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-text)<br>

[Manifold : _All&nbsp;&nbsp;(Über jar)_](https://github.com/manifold-systems/manifold/tree/master/manifold-all)<br>

# Sample Projects
Use the sample projects for nice working examples of how to configure and use Manifold in your project.  
* [Manifold : _Sample App_](https://github.com/manifold-systems/manifold-sample-project)<br>
* [Manifold : _Sample GraphQL App_](https://github.com/manifold-systems/manifold-sample-graphql-app)<br>
* [Manifold : _Sample REST API App_](https://github.com/manifold-systems/manifold-sample-rest-api)<br>
* [Manifold : _Sample Web App_](https://github.com/manifold-systems/manifold-sample-web-app)
* [Manifold : _Gradle Example Project_](https://github.com/manifold-systems/manifold-simple-gradle-project)

# Setup

## Building this project

The `manifold` project is defined with Maven.  To build it install Maven and run the following command.

```
mvn compile
```

## Using this project

The `manifold` core dependency works with all build tooling, including Maven and Gradle. It also works with Java
versions 8 - 13.

Here are some sample build configurations references.

>Note you can replace the `manifold` core dependency with [`manifold-all`](https://github.com/manifold-systems/manifold/tree/master/manifold-all) as a quick way to gain access to all of
Manifold's features.

## Binaries

If you are *not* using Maven or Gradle, you can download the latest binaries [here](http://manifold.systems/docs.html#download).

## Gradle

Here is a sample `build.gradle` script. Change `targetCompatibility` and `sourceCompatibility` to your desired Java
version (8 - 13), the script takes care of the rest. 
```groovy
plugins {
    id 'java'
}

group 'systems.manifold'
version '1.0-SNAPSHOT'

targetCompatibility = 11
sourceCompatibility = 11

repositories {
    jcenter()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
}

dependencies {
    compile group: 'systems.manifold', name: 'manifold', version: '2019.1.32'
    testCompile group: 'junit', name: 'junit', version: '4.12'

    // Add manifold to -processorpath for javac
    annotationProcessor group: 'systems.manifold', name: 'manifold', version: '2019.1.32'
}

if (JavaVersion.current() != JavaVersion.VERSION_1_8 &&
    sourceSets.main.allJava.files.any {it.name == "module-info.java"}) {
    tasks.withType(JavaCompile) {
        // if you DO define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold', '--module-path', it.classpath.asPath]
    }
} else {
    tasks.withType(JavaCompile) {
        // If you DO NOT define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold']
    }
}

tasks.compileJava {
    classpath += files(sourceSets.main.output.resourcesDir) //adds build/resources/main to javac's classpath
    dependsOn processResources
}
tasks.compileTestJava {
    classpath += files(sourceSets.test.output.resourcesDir) //adds build/resources/test to test javac's classpath
    dependsOn processTestResources
}
```

Use with accompanying `settings.gradle` file:
```groovy
rootProject.name = 'MyProject'
```

## Maven

### Java 8

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-manifold-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Manifold App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>8</source>
                    <target>8</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

### Java 9 or later
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-manifold-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Manifold App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                    <!-- Add the processor path for the plugin (required for Java 9+) -->
                    <annotationProcessorPaths>
                        <path>
                            <groupId>systems.manifold</groupId>
                            <artifactId>manifold</artifactId>
                            <version>${manifold.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

# License

## Open Source
Open source Manifold is free and licensed under the [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0) license.  

## Commercial
Commercial licenses for this work are available. These replace the above ASL 2.0 and offer 
limited warranties, support, maintenance, and commercial server integrations.

For more information, please visit: http://manifold.systems//licenses

Contact: admin@manifold.systems

# Versioning

For the versions available, see the [tags on this repository](https://github.com/manifold-systems/manifold/tags).

# Author

* [Scott McKinney](mailto:scott@manifold.systems)
The .class files in this directory are compiled with Java 9.  The corresponding source files end with *.java9 in
the src directory.  To compile them:

- use maven
- set java_home=<your java9 path>
- temporarily rename *.java9 to *.java, and rename corresponding Xxx_8.java to Xxx_8.java8
- mvn clean compile (only manifold core needs to compile, there will be errors in other modules)
- copy the corresponding class files from the target dir and place them in the this resource directory
- revert java9 files back to *.java9 and java8 files back to *.java# Manifold : Collections

The `manifold-collections` dependency consists of [extension methods](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#extension-classes-via-extension)
on Java's collection classes and the `Range` API, which leverages the unit (or binding) expressions from the
[`manifold-ext`](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext) dependency
for concise syntax. 

```java
// Use unit expressions with the Range API  
for( Mass m: 10kg to 100kg ) {
  . . .
}
``` 
 
## Table of Contents
* [Collections](#collections-extensions)
* [Ranges](#ranges)
* [IDE Support](#ide-support)
* [Setup](#setup)
* [License](#license)
* [Versioning](#versioning)
* [Author](#author)


# Collections Extensions

The `manifold-collections` library uses the `manifold-ext` framework to provide extension methods for Java collection
classes such as `List`, `Iterator`, and `Map`.  The new methods aim to add a bit more convenience to Java collections.

Simply add the `manifold-collections` dependency to your application to automatically access the extensions directly on
the collection classes.  See the [Using this project](#using-this-project) section below for instructions to use this
dependency with your build environment.

# Ranges 

You can easily work with ranges using Manifold's [unit expressions](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#unit-expressions).
Simply import the the `RangeFun` constants to create ranges:
```java
// imports the `to`, `step`, and other "binding" constants
import static manifold.collections.api.range.RangeFun.*;

if (2 inside 1 to 5) {
  out.println("yer in");
}
```
Although `inside` and `to` look like new Java keywords, they are instead normal variables defined as constants in
`RangeFun`. They use Manifold's unit expressions to type-safely build ranges with sensible syntax.

All `Number` types from `int` and `float` to `BigInteger`, `BigDecimal`, and `Rational` support *sequential* ranges that
can be iterated:
```java
for (int i: 1 to 5) {
  out.println(i);
}
``` 
To iterate in reverse order, simply reorder the range endpoints:
```java
for (int i: 5 to 1) {
  out.println(i);
}
``` 

`RangeFun` also defines constants for iterating over a range with a *step*:
```java
for (int i: 10 to 0 step 2) {
  out.println(i);
}
``` 

If you are using [Dimensions](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-science)
for the endpoints, you can use the `unit` constant to define unit increments: 
```java
for (Mass m: 2kg to 10kg unit oz) {
  out.println(m);
}
``` 

You can use variations of the `to` constant to exclude the range endpoints:
```java
for (int i: 1 _to 5) {
  out.println(i); // 1 is excluded
}
for (int i: 1 to_ 5) {
  out.println(i); // 5 is excluded
}
for (int i: 1 _to_ 5) {
  out.println(i); // both 1 and 5 are excluded
}
``` 

## Kinds of Ranges

Use the `to` constant with any `Comparable`, `Sequential`, or `Number` type to create a range. A range consisting of
`Sequential` endpoints is a `SequentialRange`, which means it can be iterated, while a range with just `Comparable`
endpoints can only be tested for containment using the `inside` RangeFun constant:

```java
if ("ockham" inside "n" to "zzz") {
  out.println("ok");
}
```
 
Note the `Sequential`, `Range`, `SequentialRange` and others abstractions are defined as part of the Range API in the
`manifold.collections.api.range` package.

 
# IDE Support 

Manifold is best experienced using [IntelliJ IDEA](https://www.jetbrains.com/idea/download).

## Install

Get the [Manifold plugin](https://plugins.jetbrains.com/plugin/10057-manifold) for IntelliJ IDEA directly from IntelliJ via:

<kbd>Settings</kbd> ➜ <kbd>Plugins</kbd> ➜ <kbd>Marketplace</kbd> ➜ search: `Manifold`

<p><img src="http://manifold.systems/images/ManifoldPlugin.png" alt="echo method" width="60%" height="60%"/></p>

## Sample Project

Experiment with the [Manifold Sample Project](https://github.com/manifold-systems/manifold-sample-project) via:

<kbd>File</kbd> ➜ <kbd>New</kbd> ➜ <kbd>Project from Version Control</kbd> ➜ <kbd>Git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProjectMenu.png" alt="echo method" width="60%" height="60%"/></p>

Enter: <kbd>https://github.com/manifold-systems/manifold-sample-project.git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProject.png" alt="echo method" width="60%" height="60%"/></p>

Use the [plugin](https://plugins.jetbrains.com/plugin/10057-manifold) to really boost your productivity. Use code
completion to conveniently access extension methods. Create extension methods using a convenient user interface. Make
changes to your extensions and use the changes immediately, no compilation! Use extensions provided by extension library
dependencies. Find usages of any extension. Use the `Range` API and unit expressions with complete type-safety.

# Setup

## Building this project

The `manifold-collections` project is defined with Maven.  To build it install Maven and run the following command.

```
mvn compile
```

## Using this project

The `manifold-collections` dependency works with all build tooling, including Maven and Gradle. It also works with Java versions
8 - 13.

>Note you can replace the `manifold-collections` dependency with [`manifold-all`](https://github.com/manifold-systems/manifold/tree/master/manifold-all) as a quick way to gain access to all of
Manifold's features.

## Binaries

If you are *not* using Maven or Gradle, you can download the latest binaries [here](http://manifold.systems/docs.html#download).


## Gradle

Here is a sample `build.gradle` script. Change `targetCompatibility` and `sourceCompatibility` to your desired Java
version (8 - 13), the script takes care of the rest.  
```groovy
plugins {
    id 'java'
}

group 'systems.manifold'
version '1.0-SNAPSHOT'

targetCompatibility = 11
sourceCompatibility = 11

repositories {
    jcenter()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
}

dependencies {
    compile group: 'systems.manifold', name: 'manifold-collections', version: '2019.1.32'
    testCompile group: 'junit', name: 'junit', version: '4.12'
                       
    if (JavaVersion.current() == JavaVersion.VERSION_1_8) {
        // tools.jar dependency (for Java 8 only), primarily to support structural typing without static proxies.
        // Thus if you are *not* using structural typing, you **don't** need tools.jar
        compile files( "${System.properties['java.home']}/../lib/tools.jar" )
    }
    // Add manifold to -processorpath for javac
    annotationProcessor group: 'systems.manifold', name: 'manifold-collections', version: '2019.1.32'
}

if (JavaVersion.current() != JavaVersion.VERSION_1_8 &&
    sourceSets.main.allJava.files.any {it.name == "module-info.java"}) {
    tasks.withType(JavaCompile) {
        // if you DO define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold', '--module-path', it.classpath.asPath]
    }
} else {
    tasks.withType(JavaCompile) {
        // If you DO NOT define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold']
    }
}

tasks.compileJava {
    classpath += files(sourceSets.main.output.resourcesDir) //adds build/resources/main to javac's classpath
    dependsOn processResources
}
tasks.compileTestJava {
    classpath += files(sourceSets.test.output.resourcesDir) //adds build/resources/test to test javac's classpath
    dependsOn processTestResources
}
```
Use with accompanying `settings.gradle` file:
```groovy
rootProject.name = 'MyExtProject'
```

## Maven

### Java 8

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-ext-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Java App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-collections</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>8</source>
                    <target>8</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
        </plugins>
    </build>

    <profiles>
        <!-- tools.jar dependency (for Java 8 only), primarily to support structural typing without static proxies.
             Thus if you are not using structural typing, you **don't** need tools.jar -->
        <profile>
            <id>internal.tools-jar</id>
            <activation>
                <file>
                    <exists>\${java.home}/../lib/tools.jar</exists>
                </file>
            </activation>
            <dependencies>
                <dependency>
                    <groupId>com.sun</groupId>
                    <artifactId>tools</artifactId>
                    <version>1.8.0</version>
                    <scope>system</scope>
                    <systemPath>\${java.home}/../lib/tools.jar</systemPath>
                </dependency>
              </dependencies>
        </profile>
    </profiles>
</project>
```

### Java 9 or later
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-ext-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Java App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-collections</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                    <!-- Add the processor path for the plugin (required for Java 9+) -->
                    <annotationProcessorPaths>
                        <path>
                            <groupId>systems.manifold</groupId>
                            <artifactId>manifold-collections</artifactId>
                            <version>${manifold.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

# License

## Open Source
Open source Manifold is free and licensed under the [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0) license.  

## Commercial
Commercial licenses for this work are available. These replace the above ASL 2.0 and offer 
limited warranties, support, maintenance, and commercial server integrations.

For more information, please visit: http://manifold.systems//licenses

Contact: admin@manifold.systems

# Versioning

For the versions available, see the [tags on this repository](https://github.com/manifold-systems/manifold/tags).

# Author

* [Scott McKinney](mailto:scott@manifold.systems)
# Manifold : CSV (comma-separated values)

>Warning: **Experimental Feature**

Manifold plugs into the Java compiler enabling you to use CSV data seamlessly -- CSV files are types. You use CSV
directly and type-safely without a code generator or extra build steps.

```java
// Type-safely use resource file "resources/com/example/Sales.csv" without a code generator in your build
import com.example.Sales;

Sales sales = Sales.fromSource();
for(Sales.SalesItem item: sales) {
  out.println(item.getCustomer());
  ...
}
```

>#### CSV, JSON, XML, and YAML are _Interchangeable_
>You can use CSV, JSON, XML, and YAML interchangeably, as such please refer to the [**JSON and JSON Schema**](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-json)
>project reference.

## Table of Contents
* [Overview](#overview)
* [Naming](#naming)
* [Header, separators, spaces, etc.](#header-separators-spaces-etc)
* [Type Inference](#type-inference)
* [Fluent API](#fluent-api)
* [Creating & Building JSON](#creating--building-csv)
* [Loading CSV](#loading-csv)
* [Writing CSV](#writing-csv)
* [Copying CSV](#copying-csv)
* [Using CSV with JSON Schema](#using-csv-with-json-schema)
* [IDE Support](#ide-support)
* [Setup](#setup)
* [License](#license)
* [Versioning](#versioning)
* [Author](#author)

## Overview
The CSV type manifold provides comprehensive support for CSV resource files, supporting extensions `csv`, `tsv`, `psv`, 
`tab`. You can define a CSV API using a sample CSV resource file. You can also define a [JSON Schema](https://json-schema.org/) version 4 or 
later and use that as the schema to provide extra type information for your CSV files. Your CSV resource files serve as the **single source of truth**
regarding CSV data and API.  You use CSV-expressed types *directly* in your code without maintaining a separate set of classes
or wedging a code generator into your build.

Here is a sample CSV file `resources/com/example/Sales.csv`:
```csv
Customer,Date,Retail,Discount,State,Invoice
Dunedin Glassworks,2019-05-22,55.49,,FL,110020
Lotta Taxes Co.,2019-05-25,395.89,0.05,CA,110021
"Palm Harbor Tuning, Inc.",2019-05-26,202.18,,FL,110022
Milesov Firewood,2019-06-01,1396.61,,CA,110023
``` 

## Naming

Most type manifolds, including the CSV, XML, JSON, & YAML manifolds, follow the Java naming convention where a type name is based on the
resource file name relative to its location in the classpath or resource path. Thus the CSV resource file `resources/com/example/Sales.csv`
has the Java type `com.example.Sales`.

All top-level CSV types extend the Java `List` type, where the items in the list are rows from the CSV file.  For
instance, the `Sales` type is an interface extending `List<SalesItem>` where `SalesItem` is an interface having get/set
methods matching the CSV header row, if provided. 

## Header, separators, spaces, etc.

Although a standard for the CSV format exists with [RFC 4180](https://tools.ietf.org/html/rfc4180), there are many
differing versions of the format in use. Additionally, some aspects of CSV are unspecific and make parsing CSV difficult
without supplemental information and/or applying heuristics on samples of the data. The CSV manifold infers much of this
information via sampling.

### Header row 

While it is impossible to detect a header row with 100% accuracy, the heuristics the CSV manifold uses work with most
types of CSV data.

### Separators

The CSV manifold supports comma, semicolon, colon, and pipe (`, ; : |`) as field separators. Just as with header
sampling, the separator used for a given file is inferred by finding patterns in the data.

### Leading/trailing spaces  

Some dialects of CSV include leading and trailing spaces in unquoted data, others do not. The CSV manifold samples the
data to find patterns with usage of spaces and infers whether or not spaces are significant.  
                   
Note quoted data always includes leading and trailing spaces in the data.

### Empty fields

An empty field value is specified using a zero-length value. Both quoted and unquoted forms are supported.

### Empty lines

Since many CSV dialects support empty lines (lines beginning with a linebreak character), the CSV manifold ignores
empty lines.
                   
### Quotes

Many CSV dialects support quoted data.  The CSV manifold considers data that begins and ends with the double quote
character as quoted data where the data between the quotes is taken as-is, minus the enclosing quotes. It is useful as
a means to directly include the separator character and linebreak characters in data. Note unquoted data may treat the
double quote character normally, while quoted data must escape it with another quote (`""`) to distinguish it from a
closing quote.   

## Type Inference

Field types are inferred by finding patterns in samples of columnar data. Fields can have the following basic types:
* `String`
* `Integer`
* `Long`
* `Double`
* `Boolean`
* `BigInteger`
* `BigDecimal`
* `LocalDateTime`
* `LocalDate`
* `LocalTime`   

For direct control over data types and formatting you can provide a *JSON Schema* resource file for the CSV format. As
such you can use additional types such as enum classes, provide custom data types and formats, and verify the CSV data
conforms to schema constraints.
```java
// A type-safe JSON Schema resource file "resources/com/example/MySalesSchema.json" modeling sales data for CSV files
import com.example.MySalesSchema;
...
MySalesSchema sales = MySalesSchema.load().fromCsvFile("/path/to/sales.csv");
```
 
## Fluent API

CSV types are defined as a set of fluent _interface_ APIs.  For example, the `Sales` CSV type is an interface and
provides type-safe methods to:
* **create** a `Sales` list or `SalesItem`
* **build** a `SalesItem`
* **modify** properties of a `SalesItem`  
* **load** a `Sales` list from a string, a CSV file, or a URL using HTTP GET
* **write** a `Sales` and `SalesItem` as formatted CSV, XML, JSON, & YAML
* **copy** a `Sales` and `SalesItem`
* **cast** to `SalesItem` from any structurally compatible type including `Map`s, all *without proxies*

## Creating & Building CSV
You create an instance of a CSV type using either the `create()` method or the `builder()` method. Note if you want to
load data from preexisting CSV files or even load directly from the sample data you can use the `load()` method or
the `fromSource()` method, discussed later in this document. 

The `create()` method defines parameters matching the `required` properties defined in the JSON Schema, if the type is
plain CSV or no `required` properties are specified, `create()` has no parameters.

Since `Sales` is a plain CSV file, as opposed to a JSON Schema structured CSV file, you can create an empty
instance of `Sales` with `create()` and then modify it using _setter_ methods to change properties:
```java
import com.example.Sales;
...
Sales sales = Sales.create();
sales.setCustomer( "" );
```

You can use `builder()` to fluently build a new `SalesItem` instance:
```java
var salesItem = Sales.SalesItem.builder()
  .withCustomer("Purdue University")
  .withDate(LocalDate.of(2019,11,9))
  .withRetail(79.99)
  .withDiscount(0.15)
  .withState("IN")
  .withInvoice(177192)
  .build();
sales.add(salesItem);
```

You can initialize several properties in a chain of `with` calls in the builder. This saves a bit of typing with
heavier APIs.  Call the `build()` method to construct the type.

> Note if using JSON Schema `with` methods also serve as a means to initialize values for `readOnly` properties.

## Loading CSV
In addition to creating an object from scratch with `create()` and `build()` you can also load an instance from 
a variety of existing sources using `fromSource()` and `load()`.

You can load the contents of the file directly using `fromSource()`.
```java
// Load from the contents of the Sales type's origin file 
Sales sales = Sales.fromSource();
for(Sales.SalesItem item: sales) {
  out.println(item.getCustomer());
  ...
}
```
You can load a `Sales` instance from a CSV, JSON, or YAML String:
```java
// From a JSON String
Sales sales = Sales.load().fromJson("..."); 
```
Load from a file:
```java
// From a CSV file
Sales sales = Sales.load().fromCsvFile("/path/to/WinterSales.csv");

// From an JSON file
Sales sales = Sales.load().fromJsonFile("/path/to/Sales.json");
```
Invoke a REST API to load a `Sales` using HTTP GET:
```java
// From HTTP GET
Sales sales = Sales.load().fromJsonUrl("http://api.example.com/sales/$Id");
```

## Writing CSV
An instance of a CSV API object can be written as formatted text with `write()`:
* `toCsv()` - produces a CSV formatted String
* `toJson()` - produces a JSON formatted String
* `toXml()` - produces a XML formatted String
* `toYaml()` - produces a YAML formatted String

The following example produces a JSON formatted string:
```java
String json = sales.write().toJson();
System.out.println(json);
```

## Copying CSV
Use the `copy()` method to make a deep copy of any CSV API object:
```java
SalesItem salesItem = . . .;
...
SalesItem copy = salesItem.copy();
```
Alternatively, you can use the `copier()` static method for a richer set of features:
```java
SalesItem copy = SalesItem.copier(salesItem).withDiscount(0.25).copy();
```
`copier()` is a lot like `builder()` but lets you start with an already built object you can modify.  Also like
`builder()` it maintains the integrity of the schema's declared mutability -- you can't change
`readOnly` fields after the `copy()` method constructs the object.

# Using CSV with JSON Schema

You can use CSV, JSON, and YAML interchangeably using the JSON manifold's universal JSON API. This means you can also
use CSV with any JSON Schema API or REST API.  As such please refer to the [**JSON and JSON Schema**](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-json)
project reference regarding API usage specific to JSON Schema.


# IDE Support 

Manifold is best experienced using [IntelliJ IDEA](https://www.jetbrains.com/idea/download).

## Install

Get the [Manifold plugin](https://plugins.jetbrains.com/plugin/10057-manifold) for IntelliJ IDEA directly from IntelliJ
via:

<kbd>Settings</kbd> ➜ <kbd>Plugins</kbd> ➜ <kbd>Marketplace</kbd> ➜ search: `Manifold`

<p><img src="http://manifold.systems/images/ManifoldPlugin.png" alt="echo method" width="60%" height="60%"/></p>

## Sample Project

Experiment with the [Manifold Sample Project](https://github.com/manifold-systems/manifold-sample-project) via:

<kbd>File</kbd> ➜ <kbd>New</kbd> ➜ <kbd>Project from Version Control</kbd> ➜ <kbd>Git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProjectMenu.png" alt="echo method" width="60%" height="60%"/></p>

Enter: <kbd>https://github.com/manifold-systems/manifold-sample-project.git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProject.png" alt="echo method" width="60%" height="60%"/></p>

Use the [plugin](https://plugins.jetbrains.com/plugin/10057-manifold) to really boost your productivity.

# Setup

## Building this project

The `manifold-csv` project is defined with Maven.  To build it install Maven and run the following command.

```
mvn compile
```

## Using this project

The `manifold-csv` dependency works with all build tooling, including Maven and Gradle. It also works with Java versions 8 - 13.

>Note you can replace the `manifold-csv` dependency with [`manifold-all`](https://github.com/manifold-systems/manifold/tree/master/manifold-all) as a quick way to gain access to all of
Manifold's features.

## Binaries

If you are *not* using Maven or Gradle, you can download the latest binaries [here](http://manifold.systems/docs.html#download).


## Gradle

Here is a sample `build.gradle` script. Change `targetCompatibility` and `sourceCompatibility` to your desired Java
version (8 - 13), the script takes care of the rest. 
```groovy
plugins {
    id 'java'
}

group 'systems.manifold'
version '1.0-SNAPSHOT'

targetCompatibility = 11
sourceCompatibility = 11

repositories {
    jcenter()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
}

dependencies {
    compile group: 'systems.manifold', name: 'manifold-csv', version: '2019.1.32'
    testCompile group: 'junit', name: 'junit', version: '4.12'

    // Add manifold to -processorpath for javac
    annotationProcessor group: 'systems.manifold', name: 'manifold-csv', version: '2019.1.32'
}

if (JavaVersion.current() != JavaVersion.VERSION_1_8 &&
    sourceSets.main.allJava.files.any {it.name == "module-info.java"}) {
    tasks.withType(JavaCompile) {
        // if you DO define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold', '--module-path', it.classpath.asPath]
    }
} else {
    tasks.withType(JavaCompile) {
        // If you DO NOT define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold']
    }
}

tasks.compileJava {
    classpath += files(sourceSets.main.output.resourcesDir) //adds build/resources/main to javac's classpath
    dependsOn processResources
}
tasks.compileTestJava {
    classpath += files(sourceSets.test.output.resourcesDir) //adds build/resources/test to test javac's classpath
    dependsOn processTestResources
}
```
Use with accompanying `settings.gradle` file:
```groovy
rootProject.name = 'MyProject'
```

## Maven

### Java 8

```csv
<?csv version="1.0" encoding="UTF-8"?>
<project csvns="http://maven.apache.org/POM/4.0.0" csvns:xsi="http://www.w3.org/2001/CSVSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-csv-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Csv App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-csv</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>8</source>
                    <target>8</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

### Java 9 or later
```csv
<?csv version="1.0" encoding="UTF-8"?>
<project csvns="http://maven.apache.org/POM/4.0.0" csvns:xsi="http://www.w3.org/2001/CSVSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-csv-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Csv App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-csv</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                    <!-- Add the processor path for the plugin (required for Java 9+) -->
                    <annotationProcessorPaths>
                        <path>
                            <groupId>systems.manifold</groupId>
                            <artifactId>manifold-csv</artifactId>
                            <version>${manifold.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

# License

## Open Source
Open source Manifold is free and licensed under the [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0) license.  

## Commercial
Commercial licenses for this work are available. These replace the above ASL 2.0 and offer 
limited warranties, support, maintenance, and commercial server integrations.

For more information, please visit: http://manifold.systems//licenses

Contact: admin@manifold.systems

# Versioning

For the versions available, see the [tags on this repository](https://github.com/manifold-systems/manifold/tags).

# Author

* [Scott McKinney](mailto:scott@manifold.systems)
# Manifold : Dark Java

## Table of Contents
* [Usage](#usage)
* [IDE Support](#ide-support)
* [Setup](#setup)
* [License](#license)
* [Versioning](#versioning)
* [Author](#author)

## Usage

A Dark Java file is a Java *resource* source file with the extension, `.darkj`. A Dark Java file is "dark" because the
compiler does not produce a `.class` file for it.  The basic properties of a type manifold are what makes Dark Java
interesting:
* You can reference a Dark Java class as a normal Java class directly from any `.java` source file in your project
* The JRE compiles and loads a Dark Java class *dynamically* at *runtime* only if and when it is first used, otherwise
it is ignored 
* Despite the absence of a `.class` file, you can access a Dark Java class using reflection
 
To illustrate, the following example is statically compiled with Java 8; it runs with Java 8 or later.  
It demonstrates how you can target Java versions dynamically -- Java 8 with `Foo8` and Java 9+ with `Foo9` using an
interface to abstract their use:

```java
public interface Foo {
  Set<Integer> makeSet();
  
  static Foo create() {
    if(JreUtil.isJava8()) {
      return (Foo)Class.forName("abc.Foo8").newInstance();
    }
    return (Foo)Class.forName("abc.Foo9").newInstance();
  }
}

// File: Foo8.darkj
public class Foo8 implements Foo {
  @Override
  public Set<Integer> makeSet() {
    Set<Integer> set = new HashSet<>();
    set.add(1);
    set.add(2);
    set.add(3);
    return Collections.unmodifiableSet(set);
  }
}

// File: Foo9.darkj
public class Foo9 implements Foo {
  @Override
  public Set<Integer> makeSet() {
    return Set.of(1, 2, 3);
  }
}
```

When run in Java 8 the `Main` class uses `Foo8`, when run in Java 9 or later it uses `Foo9`:

```java
public class Main {
  public static void main( String[] args ) {
    Foo foo = Foo.create();
    Set<Integer> set = foo.makeSet();
  }
}
```

This basic interface factory pattern can be used anywhere late-bound compilation is desirable.
 
# IDE Support 

Manifold is best experienced using [IntelliJ IDEA](https://www.jetbrains.com/idea/download).

## Install

Get the [Manifold plugin](https://plugins.jetbrains.com/plugin/10057-manifold) for IntelliJ IDEA directly from IntelliJ via:

<kbd>Settings</kbd> ➜ <kbd>Plugins</kbd> ➜ <kbd>Marketplace</kbd> ➜ search: `Manifold`

<p><img src="http://manifold.systems/images/ManifoldPlugin.png" alt="echo method" width="60%" height="60%"/></p>


## Sample Project

Experiment with the [Manifold Sample Project](https://github.com/manifold-systems/manifold-sample-project) via:

<kbd>File</kbd> ➜ <kbd>New</kbd> ➜ <kbd>Project from Version Control</kbd> ➜ <kbd>Git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProjectMenu.png" alt="echo method" width="60%" height="60%"/></p>

Enter: <kbd>https://github.com/manifold-systems/manifold-sample-project.git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProject.png" alt="echo method" width="60%" height="60%"/></p>

Use the [plugin](https://plugins.jetbrains.com/plugin/10057-manifold) to really boost your productivity. Use code
completion to conveniently access Dark Java. Make changes to your Dark Java files and use the changes immediately, no
compilation!  Find usages of any element in your Dark Java files. Perform rename refactors to quickly and safely make
project-wide changes.

# Setup

## Building this project

The `manifold-darkj` project is defined with Maven.  To build it install Maven and run the following command.

```
mvn compile
```

## Using this project

The `manifold-darkj` dependency works with all build tooling, including Maven and Gradle. It also works with Java versions 8 - 13.

>Note you can replace the `manifold-darkj` dependency with [`manifold-all`](https://github.com/manifold-systems/manifold/tree/master/manifold-all) as a quick way to gain access to all of
Manifold's features.

## Binaries

If you are *not* using Maven or Gradle, you can download the latest binaries [here](http://manifold.systems/docs.html#download).


## Gradle

Here is a sample `build.gradle` script. Change `targetCompatibility` and `sourceCompatibility` to your desired Java
version (8 - 13), the script takes care of the rest. 
```groovy
plugins {
    id 'java'
}

group 'systems.manifold'
version '1.0-SNAPSHOT'

targetCompatibility = 11
sourceCompatibility = 11

repositories {
    jcenter()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
}

dependencies {
    compile group: 'systems.manifold', name: 'manifold-darkj', version: '2019.1.32'
    testCompile group: 'junit', name: 'junit', version: '4.12'

    if (JavaVersion.current() == JavaVersion.VERSION_1_8) {
        // tools.jar dependency (for Java 8 only), primarily to support structural typing without static proxies.
        // Thus if you are *not* using structural typing, you **don't** need tools.jar
        compile files( "${System.properties['java.home']}/../lib/tools.jar" )
    }
    // Add manifold to -processorpath for javac
    annotationProcessor group: 'systems.manifold', name: 'manifold-darkj', version: '2019.1.32'
}

if (JavaVersion.current() != JavaVersion.VERSION_1_8 &&
    sourceSets.main.allJava.files.any {it.name == "module-info.java"}) {
    tasks.withType(JavaCompile) {
        // if you DO define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold', '--module-path', it.classpath.asPath]
    }
} else {
    tasks.withType(JavaCompile) {
        // If you DO NOT define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold']
    }
}

tasks.compileJava {
    classpath += files(sourceSets.main.output.resourcesDir) //adds build/resources/main to javac's classpath
    dependsOn processResources
}
tasks.compileTestJava {
    classpath += files(sourceSets.test.output.resourcesDir) //adds build/resources/test to test javac's classpath
    dependsOn processTestResources
}
```
Use with accompanying `settings.gradle` file:
```groovy
rootProject.name = 'MyDarkJavaProject'
```

## Maven

### Java 8

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-darkj-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Dark Java App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-darkj</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>8</source>
                    <target>8</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
        </plugins>
    </build>

    <profiles>
        <!-- Java 8 only, for tools.jar  -->
        <profile>
            <id>internal.tools-jar</id>
            <activation>
                <file>
                    <exists>\${java.home}/../lib/tools.jar</exists>
                </file>
            </activation>
            <dependencies>
                <dependency>
                    <groupId>com.sun</groupId>
                    <artifactId>tools</artifactId>
                    <version>1.8.0</version>
                    <scope>system</scope>
                    <systemPath>\${java.home}/../lib/tools.jar</systemPath>
                </dependency>
              </dependencies>
        </profile>
    </profiles>
</project>
```

### Java 9 or later
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-darkj-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Dark Java App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-darkj</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                    <!-- Add the processor path for the plugin (required for Java 9+) -->
                    <annotationProcessorPaths>
                        <path>
                            <groupId>systems.manifold</groupId>
                            <artifactId>manifold-darkj</artifactId>
                            <version>${manifold.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

# License

## Open Source
Open source Manifold is free and licensed under the [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0) license.  

## Commercial
Commercial licenses for this work are available. These replace the above ASL 2.0 and offer 
limited warranties, support, maintenance, and commercial server integrations.

For more information, please visit: http://manifold.systems//licenses

Contact: admin@manifold.systems

# Versioning

For the versions available, see the [tags on this repository](https://github.com/manifold-systems/manifold/tags).

# Author

* [Scott McKinney](mailto:scott@manifold.systems)
# Manifold : Exceptions

Simply add the `manifold-exceptions` dependency to your project. Now checked exceptions behave like unchecked
exceptions!  No more compiler errors, no more unintentional exception swallowing, no more boilerplate
try/catch/wrap/rethrow nonsense. This is how most modern JVM languages behave, now you have the option to make Java do
the same.

## Table of Contents
* [No More Catch-n-Wrap](#no-more-catch-n-wrap)
* [Lambdas](#lambdas)
* [IDE Support](#ide-support)
* [Setup](#setup)
* [License](#license)
* [Versioning](#versioning)
* [Author](#author)

## No More Catch-n-Wrap
The vast majority of checked exceptions go unhandled, instead they are caught, wrapped in unchecked exceptions, and
rethrown like this:
```java
URL url;
try {
  url = new URL("http://manifold.systems");
}
catch(MalformedURLException e) {
  throw new RuntimeException(e);
}
process(url);
```
This code alone explains why the designers of modern languages such as Scala, Kotlin, and others chose not to follow
Java's example.  The `exceptions` plugin option provides you with the same choice.  With it enabled you can write the
same code like this:
```java
process(new URL("http://manifold.systems"));
```
Sells itself.

## Lambdas
Perhaps the most offensive checked exception use-cases involve lambdas:
```java
List<String> strings = ...;
List<URL> urls = list
  .map(URL::new) // Unhandled exception error: MalformedURLException
  .collect(Collectors.toList());
```
The checked exception prevents concise lambda usage here.  With Manifold, however, you are free to write code as you
like:
```java
List<String> strings = ...;
List<URL> urls = list
  .map(URL::new) // Mmm, life is good
  .collect(Collectors.toList());
```

# IDE Support 

Manifold is best experienced using [IntelliJ IDEA](https://www.jetbrains.com/idea/download).

## Install

Get the [Manifold plugin](https://plugins.jetbrains.com/plugin/10057-manifold) for IntelliJ IDEA directly from IntelliJ via:

<kbd>Settings</kbd> ➜ <kbd>Plugins</kbd> ➜ <kbd>Marketplace</kbd> ➜ search: `Manifold`

<p><img src="http://manifold.systems/images/ManifoldPlugin.png" alt="echo method" width="60%" height="60%"/></p>

## Sample Project

Experiment with the [Manifold Sample Project](https://github.com/manifold-systems/manifold-sample-project) via:

<kbd>File</kbd> ➜ <kbd>New</kbd> ➜ <kbd>Project from Version Control</kbd> ➜ <kbd>Git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProjectMenu.png" alt="echo method" width="60%" height="60%"/></p>

Enter: <kbd>https://github.com/manifold-systems/manifold-sample-project.git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProject.png" alt="echo method" width="60%" height="60%"/></p>

Use the [plugin](https://plugins.jetbrains.com/plugin/10057-manifold) to really boost your productivity. With the plugin
installed IntelliJ is aware of all things Manifold, including checked exception handling e.g., the editor won't complain
about checked exceptions.

# Setup

## Building this project

The `manifold-exceptions` project is defined with Maven.  To build it install Maven and run the following command.

```
mvn compile
```

## Using this project

The `manifold-exceptions` dependency works with all build tooling, including Maven and Gradle. It also works with Java versions
8 - 13.

>Note you can replace the `manifold-exceptions` dependency with [`manifold-all`](https://github.com/manifold-systems/manifold/tree/master/manifold-all) as a quick way to gain access to all
of Manifold's features.

## Binaries

If you are *not* using Maven or Gradle, you can download the latest binaries [here](http://manifold.systems/docs.html#download).


## Gradle

Here is a sample `build.gradle` script. Change `targetCompatibility` and `sourceCompatibility` to your desired Java
version (8 - 13), the script takes care of the rest.  
```groovy
plugins {
    id 'java'
}

group 'systems.manifold'
version '1.0-SNAPSHOT'

targetCompatibility = 11
sourceCompatibility = 11

repositories {
    jcenter()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
}

dependencies {
    compile group: 'systems.manifold', name: 'manifold-exceptions', version: '2019.1.32'
    testCompile group: 'junit', name: 'junit', version: '4.12'

    // Add manifold to -processorpath for javac
    annotationProcessor group: 'systems.manifold', name: 'manifold-exceptions', version: '2019.1.32'
}

if (JavaVersion.current() != JavaVersion.VERSION_1_8 &&
    sourceSets.main.allJava.files.any {it.name == "module-info.java"}) {
    tasks.withType(JavaCompile) {
        // if you DO define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold', '--module-path', it.classpath.asPath]
    }
} else {
    tasks.withType(JavaCompile) {
        // If you DO NOT define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold']
    }
}

tasks.compileJava {
    classpath += files(sourceSets.main.output.resourcesDir) //adds build/resources/main to javac's classpath
    dependsOn processResources
}
tasks.compileTestJava {
    classpath += files(sourceSets.test.output.resourcesDir) //adds build/resources/test to test javac's classpath
    dependsOn processTestResources
}
```
Use with accompanying `settings.gradle` file:
```groovy
rootProject.name = 'MyProject'
```

## Maven

### Java 8

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-exceptions-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Exceptions App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-exceptions</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>8</source>
                    <target>8</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

### Java 9 or later
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-exceptions-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Exceptions App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-exceptions</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                    <!-- Add the processor path for the plugin (required for Java 9+) -->
                    <annotationProcessorPaths>
                        <path>
                            <groupId>systems.manifold</groupId>
                            <artifactId>manifold-exceptions</artifactId>
                            <version>${manifold.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

# License

## Open Source
Open source Manifold is free and licensed under the [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0) license.  

## Commercial
Commercial licenses for this work are available. These replace the above ASL 2.0 and offer 
limited warranties, support, maintenance, and commercial server integrations.

For more information, please visit: http://manifold.systems//licenses

Contact: admin@manifold.systems

# Versioning

For the versions available, see the [tags on this repository](https://github.com/manifold-systems/manifold/tags).

# Author

* [Scott McKinney](mailto:scott@manifold.systems)
# Manifold : Java Extensions

## Table of Contents
* [Extension classes](#extension-classes-via-extension) via `@Extension`
* [Operator Overloading](#operator-overloading)
* [Unit Expressions](#unit-expressions)
* [Structural interfaces](#structural-interfaces-via-structural) via `@Structural`
* [Type-safe reflection](#type-safe-reflection-via-jailbreak) via `@Jailbreak`
* [The *Self* type](#the-self-type-via-self) via `@Self`
* [IDE Support](#ide-support)
* [Setup](#setup)
* [License](#license)
* [Versioning](#versioning)
* [Author](#author)

# Extension Classes via `@Extension`

Similar to other languages such as [C#](https://docs.microsoft.com/en-us/dotnet/csharp/csharp),
[Kotlin](https://kotlinlang.org/), and [Gosu](https://gosu-lang.github.io/), with Manifold you can define methods and
other features as logical extensions to existing Java classes. This is achieved using _extension classes_. An extension
class is a normal Java class you define as a container for features you want to apply to another class, normally to one
you can't modify directly, such as `java.lang.String`:

```java
package extensions.java.lang.String;

import manifold.ext.api.*;

@Extension
public class MyStringExtension {

  public static void print(@This String thiz) {
    System.out.println(thiz);
  }

  @Extension
  public static String lineSeparator() {
    return System.lineSeparator();
  }
}
```

All extension classes must be sub-rooted in the `extensions` package where the remainder of the package
must be the qualified name of the extended class. As the example illustrates, an extension
class on `java.lang.String` must reside directly in a package equal to or ending with `extensions.java.lang.String`. Note this
convention facilitates the extension discovery process and avoids the overhead and ceremony of
alternative means such as annotation processors.

In **Java 9** because a package must reside in a single module, you should prepend your module name to the extension package
name to avoid illegal sharing of packages between modules.  For example, if your module were named `foo.widget` you
should define your extension class as `foo.widget.extensions.java.lang.String`.  In Java 8 all extension classes can be 
directly rooted in the `extensions` package, however it is still best to qualify extension classes with your project
or module name to prevent naming collisions.

Additionally, an extension class must be annotated with `manifold.ext.api.Extension`, which distinguishes
extension classes from other classes that may reside in the same package.

## Extension Method Basics

An extension method must be declared `static` and non-`private`. As the receiver of the call, the first
parameter of an extension _instance_ method must have the same type as the extended class. The
`MyStringExtension` example illustrates this; the first parameter of instance method `print` is
`java.lang.String`. Note the parameter name _thiz_ is conventional, you can use any name you like.
Finally, the receiver parameter must be annotated with `manifold.ext.api.This` to distinguish it from 
regular methods in the class.

That's all there is to it. You can use extensions just like normal methods on the extended class:

```java
String name = "Manifold";
name.print();
```

You can define `static` extension methods too. Since static methods don't have a receiver, the method
itself must be annotated with `manifold.ext.api.Extension`:

```java
@Extension
public static String lineSeparator() {
  return System.lineSeparator();
}
```

Call static extensions just as if they were on the extended class:

```java
String.lineSeparator()
```

## Generics

You can extend generic classes too and define generic methods. This is how Manifold extension libraries
work with collections and other generic classes. For example, here is the `first()` extension method on
`Iterable`:

```java
public static <T> T first(@This Iterable<T> thiz, Predicate<T> predicate) {
  for (T element: thiz) {
    if (predicate.test(element)) {
      return element;
    }
  }
  throw new NoSuchElementException();
}
```

Notice the extension is a generic method with the same type variable designation as the
extended class: `T` from `Iterable<T>`. Since extension methods are static this is how we convey type
variables from the extended class to the extension method. Note type variable names must match the 
extended type's type variables and must be declared in the same order.

To define a generic extension method you append the type variables of the method to the list of the
extended class' type variables. Manifold's `map()` extension illustrates this format:

```java
public static <E, R> Stream<R> map(@This Collection<E> thiz, Function<? super E, R> mapper) {
  return thiz.stream().map(mapper);
}
```

Here `map` is a generic extension method having type variable `R` and conveying `Collection`'s type
variable `E`.

## Static Dispatching

An extension class does not physically alter its extended class; the methods defined in an extension are
not really inserted into the extended class. Instead the Java compiler and Manifold cooperate to make a
call to a static method in an extension look like a call to an instance method on the extended class. As a
consequence extension calls dispatch **statically**.

So unlike a virtual method call an extension call is always made based on the extended type declared in
the extension, not the runtime type of the left hand side of the call. To illustrate:

```java
public class Tree {
}

public class Dogwood extends Tree {
}

public static void bark(@This Tree thiz) {
  println("rough");
}
public static void bark(@This Dogwood thiz) {
  println("ruff");
}

Tree tree = new Dogwood();
tree.bark(); // "rough"
```

At compile-time `tree` is of type `Tree`, therefore it transforms to a static invocation of `bark(Tree)`,
which prints "rough".

Another consequence of static dispatching is that an extension method can receive a call even if the value
of the extended object is `null` at the call site. Manifold extension libraries exploit this feature to
improve readability and null-safety. For example, `CharSequence.isNullOrEmpty()` compares the
receiver's value to null so you don't have to:

```java
public static boolean isNullOrEmpty(@This CharSequence thiz) {
  return thiz == null || thiz.length() == 0;
}

String name = null;
if (name.isNullOrEmpty()) {
  println("empty");
}
```

Here the example doesn't check for null and instead shifts the burden to the extension.

## Accessibility and Scope

An extension method never shadows or overrides a class method; when an extension method's name and
parameters match a class method, the class method always has precedence over the extension. For example:

```java
public class Tree {
  public void kind() {
    println("evergreen");
  }
}

public static void kind(@This Tree thiz) {
  println("binary");
}
```

The extension method never wins, a call to `kind()` always prints "evergreen". Additionally, if at
compile-time `Tree` and the extension conflict as in the example, the compiler warns of the conflict
in the extension class.

An extension method can still _overload_ a class method where the method names are the same, but the 
parameter types are different:

```java
public class Tree {
  public void harvest() {
    println("nuts");
  }
}

public static void harvest(@This Tree thiz, boolean all) {
  println(all ? "wood" : thiz.harvest());
}
```

A call to `tree.harvest(true)` prints "wood".

Since extension method references resolve at compile-time, you can limit the compile-time accessibility
of an extension class simply by limiting the scope of the JAR file containing the extension. For example,
if you're using Maven the scope of an extension matches the dependency relationship you assign in your
pom.xml file. Similarly in module-aware IDEs such as IntelliJ IDEA, an extension's scope is the same as
the module's.

## Annotation Extensions

In addition to adding new methods, extension classes can also add _annotations_ to a class. At present
annotation extensions are limited to the extended _class_; you can't yet add annotations to members of 
the class.

Beware, extensions are limited to a compile-time existence. Therefore, even if an 
annotation has `RUNTIME` retention, it will only be present on the extended class at compile-time. This 
feature is most useful when using annotation processors and you need to annotate classes you otherwise 
can't modify.

Also it's worth pointing out you can make existing interfaces _structural_ using annotation extensions:

```java
package extensions.abc.Widget;
@Extension
@Structural // makes the interface structural
public class MyWidgetExtension {
}
```

This extension effectively changes the `abc.Widget` _nominal_ interface to a _structural_ interface. In the context
of your project classes no longer have to declare they implement it nominally.  

See [Structural Interfaces](#structural-interfaces-via-structural) later in this guide for fuller coverage of the topic.

## Extension Interfaces

An extension class can add structural interfaces to its extended class.  This feature helps with a 
variety of use-cases.  For example, let's say we have a class `Foo` and interface `Hello`:
  
```java
public final class Foo {
  public String sayHello() {
    return "hello";      
  }
}

@Structural
public interface Hello {
  String sayHello();
}
```

Although `Foo` does not implement `Hello` nominally, it defines the `sayHello()` method that otherwise 
satisfies the interface.  Let's assume we don't control `Foo`'s implementation, but we need it to
implement `Hello` nominally.  We can do that with an extension interface:

```java
@Extension
public class MyFooExtension implements Hello {
}
```

Now the compiler believes `Foo` directly implements `Hello`: 

```java
Hello hello = new Foo();
hello.sayHello();
```
Note `Hello` is structural, so even without the extension interface, instances of `Foo` are still 
compatible with `Hello`. It's less convenient, though, because you have to explicitly cast `Foo` to `Hello` --
a purely structural relationship in Manifold requires a cast. Basically extension interfaces save you
from casting. This not only
improves readability, it also prevents confusion in cases involving type inference where it may not be 
obvious that casting is necessary.

It's worth pointing out you can both add an interface _and_ implement its methods
by extension:
```java
public final class Shy {
}

@Extension
public abstract class MyShyExtension implements Hello {
  public static String sayHello(@This Shy thiz) {
    return "hi";    
  }
}
```
This example extends `Shy` to nominally implement `Hello` _and_ provides the `Hello` implementation. Note
the abstract modifier on the extension class.  This is necessary because it doesn't really implement the
interface, the extended class does.

You can also use extension interfaces to extract interfaces from classes you don't
control.  For example, if you want to provide an immutable view of a collection class
such as `java.util.List`, you could use extension interfaces to extract immutable and
mutable interfaces from the class.  As such your code is better suited to confine
`List` operations on otherwise fully mutable lists.


## Extension Libraries

An extension library is a logical grouping of functionality defined by a set of extension classes.
Manifold includes several extension libraries for commonly used classes, many of which are adapted
from Kotlin extensions.  Each library is available as a separate module or Jar file you can add 
to your project separately depending on its needs.

*   **Collections**

    Defined in module `manifold-collections` this library extends:
    - java.lang.Iterable
    - java.util.Collection
    - java.util.List
    - java.util.stream.Stream

*   **Text**

    Defined in module `manifold-text` this library extends:
    - java.lang.CharSequence
    - java.lang.String

*   **I/O**

    Defined in module `manifold-io` this library extends:
    - java.io.BufferedReader
    - java.io.File
    - java.io.InputStream
    - java.io.OutputStream
    - java.io.Reader
    - java.io.Writer

*   **Web/JSON**
 
    Defined in module `manifold-json` this library extends:
    - java.net.URL
    - javax.script.Bindings

> 
> **&#x1f6c8;** **IMPORTANT!**  
> You can create your own custom extension libraries.  There's nothing special about a "library", it's just a normal
> dependency in a project.  However for manifold to recognize extensions, as a performance measure, the library must
> declare it has extensions to process. Do that using the `Contains-Sources` manifest entry.
>
> With **Maven** use the `maven-jar-plugin` to add the `Contains-Sources` manifest entry to your Jar file:
>```xml
><build>
>  <plugins>
>    <plugin>
>      <groupId>org.apache.maven.plugins</groupId>
>      <artifactId>maven-jar-plugin</artifactId>
>      <configuration>
>        <archive>
>          <manifestEntries>
>            <!--class files as source must be available for extension method classes-->
>            <Contains-Sources>java,class</Contains-Sources>
>          </manifestEntries>
>        </archive>
>      </configuration>
>    </plugin>
>  </plugins>
></build>
>```
> Similarly with **Gradle** add the `Contains-Sources` manifest attribute:
>```groovy
>jar {
>  manifest {
>    attributes('Contains-Sources':'java,class')
>  }
>}
>```

## Generating Extension Classes

Sometimes the contents of an extension class reflect metadata from other resources.  In this case rather 
than painstakingly writing such classes by hand it's easier and less error prone to produce them via 
type manifold.  To facilitate this use-case, your type manifold must implement the `IExtensionClassProducer`
interface so that the `ExtensionManifold` can discover information about the classes your type
manifold produces. For the typical use case your type manifold should extend `AbstractExtensionProducer`.

See the `manifold-ext-producer-sample` module for a sample type manifold implementing `IExtensionClassProvider`.

>Note the [`manifold-science`](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-science)
and [`manifold-collections`](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-collections)
projects use operator overloading and unit expressions extensively.

# Operator Overloading

>Warning: **Experimental Feature**

The Manifold extension framework plugs into Java to provide seamless operator overloading capability. You can
type-safely provide arithmetic, relational, and [unit](#unit-expressions) operators for any class by implementing one or
more predefined operator methods. You can implement operator methods directly in your class or use [extension methods](#extension-classes-via-extension)
to implement operators for classes you don't otherwise control. For example, using extension methods Manifold provides
operator implementations for `BigDecimal` so you can write code like this:
```java
BigDecimal result = bigValue1 + bigValue2;
```


## Arithmetic and Negation Operators

Any type can support arithmetic operators by implementing one or more of the following operator methods: 

**Arithmetic**

| Operation | Method       |
|:----------|:-------------|
| `a + b`   | `a.plus(b)`  |
| `a - b`   | `a.minus(b)` |
| `a * b`   | `a.times(b)` |
| `a / b`   | `a.div(b)`   |
| `a % b`   | `a.rem(b)`   |

**Negation**

| Operation | Method           |
|:----------|:-----------------|
| `-a`      | `a.unaryMinus()` |

Note operator methods do not belong to a class or interface you implement. Instead you implement them *structurally*
simply by defining a method with the same signature. Note you can implement several different versions of the same
method differing by parameter type. 

Here's a simple example demonstrating how to implement the `+` operator:
```java
public class Point {
  public final int x, y;
  public Point(int x, int y) {this.x = x; this.y = y;}
  
  public Point plus(Point that) {
    return new Point(x + that.x, y + that.y);
  }
}

var a = new Point(1, 2);
var b = new Point(3, 4);

var sum = a + b; // Point(4, 6)
```

Since operator methods are structural, you can define *multiple* `plus()` methods:
```java
public Point plus(int[] coord) {
  if(coord.length != 2) {
    throw new IllegalArgumentException();
  }
  return new Point(x + coord[0], y + coord[1]);
}
```
   
## Relational Operators

You can implement relational operators using a combination of the `ComparableUsing` and/or `Comparable` interfaces.

### `manifold.ext.api.ComparableUsing`

Relational operators can be implemented all together with the `ComparableUsing` interface, which extends `Comparable`
to provide an operator-specific API.                           
```java
boolean compareToUsing( T that, Operator op );
```
Where `Operator` is an `enum` which specifies constants for relational operators.

| Operation | ComparableUsing Impl      | Comparable Impl       |
|-----------|---------------------------|-----------------------|
| `a > b`   | `a.compareToUsing(b, GT)` | `a.compareTo(b) > 0`  |
| `a >= b`  | `a.compareToUsing(b, GE)` | `a.compareTo(b) >= 0` |
| `a < b`   | `a.compareToUsing(b, LT)` | `a.compareTo(b) < 0`  |
| `a <= b`  | `a.compareToUsing(b, LE)` | `a.compareTo(b) <= 0` |

`ComparableUsing` provides a default implementation for `compareToUsing()` that delegates to `Comparable`'s
`compareTo()` implementation for the `>`, `>=`, `<`, `<=` subset of relational operators.  For the `==` and `!=` subset
`ComparableUsing` delegates to the type's `equals()` method (more on equality later).  This behavior is suitable for
most types, so normally you only need to add `ComparableUsing` to your type's `implements` or `extends` clause and
implement just `Comparable` as you normally would. Thus adding relational operator support to the `Point` example we
have:

```java
public class Point implements ComparableUsing<Point> {
  public final int x, y;
  public Point(int x, int y) {this.x = x; this.y = y;}
  
  public Point plus(Point that) {
    return new Point(x + that.x, y + that.y);
  }
  
  public int compareTo(Point that) {
    return x - that.x;
  }
}
```
Now you can easily compare `Point` values like this:
```java
if (pt1 >= pt2) ...
```

### `java.lang.Comparable`

If you're not interested in supporting `==` and `!=` and your type implements the `Comparable` interface, it
automatically supports the `>`, `>=`, `<`, `<=` subset of relational operators. For example, both `java.lang.String` and
`java.time.LocalDate` implement the `compareTo()` method from `Comparable`, which means they can be used in relational
expressions:

```java
String name1;
String name2;
...
if (name1 > name2) {...}
```   

```java
LocalDate date1;
LocalDate date2;
...
if (date1 > date2) {...}
```

## Equality Operators

To implement the `==` and `!=` subset of relational operators you must implement the `ComparableUsing` interface. By
default `ComparableUsing` delegates to your type's `equals()` method, but you can easily override this behavior by
overriding the `equalityMode()` method in your `CopmarableUsing` implementation. The `EqualityMode` enum provides the
available modes:     

```java
/**
 * The mode indicating the method used to implement {@code ==} and {@code !=} operators.
 */
enum EqualityMode
{
  /** Use the {@code #compareTo()} method to implement `==` and `!=` */
  CompareTo,

  /** Use the {@code equals()} method to implement `==` and `!=` (default) */
  Equals,

  /** Use {@code identity} comparison for `==` and `!=`, note this is the same as Java's normal {@code ==} behavior } */
  Identity
}
```

Based on the `EqualityMode` returned by your implementation of `CompareToUsing#equalityMode()`, the `==` and `!=`
operators compile using the following methods: 

| Operation | `Equals` <small>(default)</small> | `CompareTo`| `Identity` |
|:----------|:-------------------|:--------------------------|:-----------|
| `a == b`  | `a.equals(b)`      | `a.compareToUsing(b, EQ)` | `a == b`   |
| `a != b`  | `!a.equals(b)`     | `a.compareToUsing(b, NE)` | `a != b`   |

Note Manifold generates efficient, **null-safe** code for `==` and `!=`. For example, `a == b` using `Equals` mode
compiles as:
```java
a == b || a != null && b != null && a.equals(b)
``` 

If you need something more customized you can override `compareToUsing()` with your own logic for any of the operators,
including `==` and `!=`.
 
To enable `==` on `Point` more effectively, you can accept the default behavior of `ComparableUsing` and implement
`equals()`:
 
```java
public boolean equals(Object that) {
  return this == that || that != null && getClass() == that.getClass() && 
         x == ((Point)that).x && y == ((Point)that).y;
}
```
>Note always consider implementing `hashCode()` if you implement `equals()`, otherwise your type may not function
>properly when used with `Map` and other data structures:
>```java
>public int hashCode() {
>  return Objects.hash(x, y); 
>}
>```

Sometimes it's better to use the `CompareTo` mode.  For instance, the `==` and `!=` implementations for `Rational`,
`BigDecimal`, and `BigInteger` use the `CompareTo` mode because in those classes `compareTo()` reflects equality in
terms of the *face value* of the number they model e.g., 1.0 == 1.00, which is desirable behavior in many use-cases. As
such override `equalityMode()` to return `CompareTo`:
```java
@Override
public EqualityMode equalityMode() {
  return CompareTo;
}
```
 
## Unit Operators

Unit or "binding" operations are unique to the Manifold framework. They provide a powerfully concise syntax and can be
applied to a wide range of applications. You implement the operator with the `prefixBind()` and `postfixBind()` methods:

| Operation  | Postfix Bind       | Prefix Bind       |
|------------|--------------------|-------------------|
| `a b`      | `b.postfixBind(a)` | `a.prefixBind(b)` |

If the type of `a` implements `R prefixBind(B)` where `B` is assignable from the type of `b`, then `a b` compiles as the
method call `a.prefixBind(b)` having type `R`. Otherwise, if the type of `b` implements `R postfixBind(A)` where `A` is
assignable from the type of `a`, then `a b` compiles as the method call `b.postfixBind(a)` having type `R`.

Read more about [unit expressions](#unit-expressions) later in this document.
 
## Operators by Extension Methods 

Using [extension methods](#extension-classes-via-extension) you can provide operator implementations for classes you
don't otherwise control. For instance, Manifold provides operator extensions for
[`BigDecimal`](https://github.com/manifold-systems/manifold/blob/master/manifold-deps-parent/manifold-ext/src/main/java/manifold/ext/extensions/java/math/BigDecimal/ManBigDecimalExt.java)
and [`BigInteger`](https://github.com/manifold-systems/manifold/blob/master/manifold-deps-parent/manifold-ext/src/main/java/manifold/ext/extensions/java/math/BigInteger/ManBigIntegerExt.java).
These extensions are implemented in the [`manifold-science`](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-science)
dependency.  

Here's what the `+` extension for `BigDecimal` looks like:
```java
@Extension
public abstract class ManBigDecimalExt implements ComparableUsing<BigDecimal> {
  /** Supports binary operator {@code +} */
  public static BigDecimal plus(@This BigDecimal thiz, BigDecimal that) {
    return thiz.add(that);
  }
  ...
}
```
Now you can perform arithmetic and comparisons using operator expressions:
```java
if (bd1 >= bd2) {
  BigDecimal result = bd1 + bd2;
  . . .
}
```

>Note the [`manifold-science`](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-science)
and [`manifold-collections`](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-collections)
projects use operator overloading and unit expressions extensively.
   

# Unit Expressions
>Warning: **Experimental Feature**

Extending [operator overloading](#operator-overloading) further, Manifold seamlessly plugs into Java to provide Unit
(or *Binding*) Expressions.  This feature is unique to the Manifold framework and provides a powerfully concise syntax
that can be applied to a wide range of applications.

Units are just normal identifiers, you can define them anywhere with fields and local variables and use them directly.
Normally you import predefined unit constants like the ones provided in `UnitConstants` from the
`manifold.science.util` package:
```java
import static manifold.science.util.UnitConstants.kg;
import static manifold.science.util.UnitConstants.hr;
import static manifold.science.util.UnitConstants.mph;
. . .
```
Using imported constants such as `kg` for `Kilogram`, `hr` for `Hour`, `mph` for `Mile/Hour`, etc. you can
begin working with unit expressions:

**Simple and easy to read syntax**
```java
Length distance = 100 mph * 3 hr;
```
**Type-safe**
```java
Force force = 5kg * 9.807 m/s/s; // 49.035 Newtons
```
**Logically equivalent units are equal**
```java
var force = 49.035 kg m/s/s;
force == 49.035 N // true
```
**Maintain integrity with different units**
```java
Mass m = 10 lb + 10 kg; 
```
**Easily make Ranges with the `to` constant from [`RangeFun`](https://github.com/manifold-systems/manifold/blob/master/manifold-deps-parent/manifold-collections/src/main/java/manifold/collections/api/range/RangeFun.java)**
```java
for( Mass m: 10kg to 100kg ) {...}
```
**Conveniently work with Money**
```java
Money payment = 1.5M USD; 
Money vat = 162k EUR;
Money total = payment + vat; // naturally works with multiple currencies
``` 
>Note unit expressions and *operator overloading* are often used together, read more about [operator overloading](#operator-overloading).

## How does it work?
Normally a *binary* expression in Java and most other languages involves two operands separated by an operator such as
`+` for addition:
```java
int sum = a + b;
```

But with a unit expression the operands are directly adjacent without an operator separating them:
```java
Mass m = 10 kg;
```

The operation is _declared_ in an operand's type with one of the following methods:
```java
public R prefixBind(T rhs);
public R postfixBind(T lhs);
``` 
Where either the left operand defines `prefixBind(T rhs)` or the right operand defines `postfixBind(T lhs)`.

In the example, `10` is a literal value of type `int` and `kg` is a variable of type `MassUnit`. Since `kg` is on the
right-hand side of `10` and the `MassUnit` class defines the method:
```java
public Mass postfixBind(Number magnitude) {...}
``` 
the compiler translates the expression as the method call `kg.postfixBind(10)` resulting in type `Mass`.

Note `postfixBind()` and `prefixBind()` do not belong to a class or interface you implement. Instead you implement
them *structurally* simply by defining a method with the same name, parameter, and non-void return type. This is
necessary because a type may implement multiple versions of the same method. This level of flexibility is otherwise not
supported with Java's name-based type system. 

## Operator Precedence

The empty or "binding" operator has a *phased* precedence. Lexically, its precedence lies between addition and
multiplication, thus during the compiler's parsing phase it produces an untyped AST reflecting this order.  However,
in the course of the compiler's type attribution phase the compiler restructures the AST to reflect binding operator
methods `prefixBind()` and `postfixBind()` declared in the operand types, during which the compiler considers the
binding operator as having a precedence *equal to* multiplication.

To illustrate consider the following expression:
```java
a b * c
```

The binding operator, having a lexical precedence less than multiplication, parses like this:
```java
a (b * c)
```

In a later stage when operand types are available the expression may restructure if:
1. `a` and `b` have a binding relationship declared with `A.postfixBind(B)` or `B.prefixBind(A)` and
2. the type of the resulting `(a b)` expression implements multiplication with the type of `c`
```java
(a b) * c
``` 

For example, the expression `5 kg * 2` reflects this example exactly.

As you can see unit expressions demand a level of flexibility beyond that of conventional compilers such as Java's. But
Java is flexible enough in its architecture so that Manifold can reasonably plug in to augment it with this capability.
    
## Type-safe and Simple

There is nothing special about a unit, it is just a simple expression, most of the time just a variable. You can easily
define your own aliases for units like the ones defined in `manifold.science.util.UnitConstants`.
```java
LengthUnit m = LengthUnit.Meter;
Length twoMeters = 2 m;
``` 

## More Than Units

What makes unit expressions work is simple, just a pair of methods you can implement on any types you like: 
```java
public R postfixBind(T lhs);
public R prefixBind(T rhs);
``` 
If your type implements either of these, it is the basis of a potential "unit" expression. Thus, the application of
these methods goes beyond just units. To illustrate, let's say you want to make date "literal" expressions such as:   
```java
LocalMonthDay d1 = May 15;
LocalYearMonth d2 = 2019 May;
LocalDate d3 = 2019 May 15;
```
Binding expressions easily accommodate this use-case.  Something like:
```java
package com.example;

public enum Month {
  January,
  February,
  March,
  April,
  May,
  ... // etc.
  
  public LocalMonthDay prefixBind(Integer date) {
    return new LocalMonthDay(this, date);
  }
  
  public LocalYearMonth postfixBind(Integer year) {
    return new LocalYearMonth(this, date);
  }
}
```
In turn `LocalYearMonth` can define `LocalDate prefixBind(Integer)`. That's all there is to it. Now you have type-safe
date expressions:
```java
import static com.example.Month.*;
...
LocalDate date = 2019 October 9;
```

Essentially you can implement binding expressions to make use of juxtaposition wherever your imagination takes you.

## Science & Ranges
Of course, as some of the examples illustrate, unit expressions are especially well suited as the basis for a library
modeling physical dimensions such as length, time, mass, etc. Indeed, check out the [`manifold-science`](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-science)
dependency.

Another application of units involves the [Range API](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-collections#ranges)
provided by the [`manifold-collections`](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-collections)
dependency. Simply by importing the static constants from `RangeRun` you can easily work with ranges:
```java
Range range = 1 to 5;
```
```java
for (Rational csr: 5.2r to 15.7r step 0.3r) {...}
```
```java
for (Mass mass: 10kg to 100kg unit lb) {...}
```
```java
if ("le matos" inside "a" to "m~") {...}
``` 

# Structural Interfaces via `@Structural`

Java is a _nominally_ typed language -- types are assignable based on the names declared in their definitions. For
example:

```java
public class Foo {
  public void hello() {
    println("hello");
  }
}

public interface Greeting {
  void hello();
}

Greeting foo = new Foo(); // error
```

This does not compile because `Foo` does not explicitly implement `Greeting` by name in its `implements`
clause.

By contrast a _structurally_ typed language has no problem with this example.  Basically, structural typing
requires only that a class implement interface _methods_, there is no need for a class to declare that it
implements an interface.

Although nominal typing is perhaps more sound and easier for both people and machines to digest, in some
circumstances the flexibility of structural typing makes it more suitable. Take the following classes:

```java
public class Rectangle {
  public double getX();
  public double getY();
  ...
}

public class Point {
  public double getX();
  public double getY();
  ...
}

public class Component {
  public int getX();
  public int getY();
  ...
}
```

Let's say we're tasked with sorting instances of these according to location in the coordinate plane, say
as a `Comparator` implementation. Each class defines methods for obtaining X, Y coordinates, but these
classes don't implement a common interface. We don't control the implementation of the classes, so we're
faced with having to write three distinct, yet nearly identical, Comparators.

This is where the flexibility of structural interfaces could really help. If Java supported it, we'd
declare a structural interface with `getX()` and` getY()` methods and write only one `Comparator`:

```java
public interface Coordinate {
  double getX();
  double getY();
}

Comparator<Coordinate> coordSorter = new Comparator<>() {
  public int compare(Coordinate c1, Coordinate c2) {
    int res = c1.Y == c2.Y ? c1.X - c2.X : c2.Y - c1.Y;
    return res < 0 ? -1 : res > 0 ? 1 : 0;
  }
}

List<Point> points = Arrays.asList(new Point(2, 1), new Point(3, 5), new Point(1, 1));
Collections.sort(points, coordSorter); // error
```

Of course Java is not happy with this because because `Point` does not nominally implement `Coordinate`. 

This is where Manifold can help with structural interfaces:

```java
@Structural
public interface Coordinate {
  double getX();
  double getY();
}
```

Adding `@Structural` to `Coordinate` effectively changes it to behave _structurally_ -- Java no longer
requires classes to implement it by name, only its methods must be implemented.

Note a class can still implement a structural interface nominally. Doing so helps both people and tooling 
comprehend your code faster. The general idea is to use an interface structurally when you otherwise can't 
use it nominally or doing so overcomplicates your code.


## Type Assignability and Variance

A type is assignable to a structural interface if it provides compatible versions of all the
methods declared in the interface. The use of the term _compatible_ here instead of _identical_ is
deliberate. The looser term concerns the notion that a structural interface method is variant with respect
to the types in its signature:

```java
@Structural
public interface Capitalizer {
  CharSequence capitalize(String s);
}

public static class MyCapitalizer {
  public String capitalize(CharSequence s) {
    return s.isNullOrEmpty() ? "" : Character.toUpperCase(s.charAt(0)) + s.substring(1);
  }
}
```

At first glance it looks like `MyCapitalizer` does not satisfy the structure of `Capitalizer`, neither the
parameter type nor the return type of the method match the interface. After careful inspection, however,
it is clear the methods are call-compatible from the perspective of `Capitalizer`:

```java
Capitalizer cap = (Capitalizer) new MyCapitalizer();
CharSequence properName = cap.capitalize("tigers");
```

`MyCapitalizer`'s method can be called with `Capitalizer`'s `String` parameter because `MyCapitalizer`'s
`CharSequence` parameter is assignable from `String` -- _contravariant_ parameter types support
call-compatibility. Similarly we can accept `MyCapitalizer`'s `String` return type because it is
assignable to `Capitalizer`'s `CharSequence` return type -- _covariant_ return types support
call-compatibility. Therefore, even though their method signatures aren't identical, `MyCapitalizer` is
structurally assignable to `Capitalizer` because it is safe to use in terms of `Capitalizer`'s methods.

Signature variance also supports primitive types.  You may have spotted this in the `Component`
class referenced earlier in the `Coordinate` example where `Component.getX()` returns `int`, not `double`
as declared in `Coordinate.getX()`. Because `int` coerces to `double` with no loss of precision
the method is call-compatible. As a result signature variance holds for primitive types as well as
reference types.

## Implementation by Field

Another example where classes have wiggle room implementing structural interfaces involves property 
getter and setter methods, a.k.a. accessors and mutators. Essentially, a property represents a value you 
can access and/or change. Since a field is basically the same thing a class can implement a getter and/or 
a setter with a field:

```java
@Structural
public interface Name {
  String getName();
  void setName(String name);
}

public class Person {
  public String name;
}

Name person = (Name) new Person();
person.setName("Bubba");
String name = person.getName();
```                                                             

Basically a field implements a property method if its name matches the method's name minus the 
is/get/set prefixes and taking into account field naming conventions. For example, fields `Name`, `name`, 
and `_name` all match the `getName()` property method and are weighted in that order.


## Implementation by Extension

It's possible to implement methods of a structural interface via extension methods.  Looking back at the
`Coordinate` example, consider this class:
```java
public class Vector {
  private double _magnitude;
  private double _direction;
  
  public Vector(double magnitude, double direction) {
    _magnitude = magnitude;
    _direction = direction;
  }
  
  // Does not have X, Y coordinate methods  :(
}
```

In physics a vector and a coordinate are different ways of expressing the same thing; they can be converted 
from one to another.  So it follows the `coordSorter` example can sort `Vector` instances in terms of X, Y 
`Coordinates`... if `Vector` supplied `getX()` and `getY()` methods, which it does not.

What if an extension class supplied the methods?
  
```java
@Extension
public class MyVectorExtension {
  public double getX(@This Vector thiz) {
    return thiz.getMagnitude() * Math.cos(thiz.getDirection()); 
  }
  public double getY(@This Vector thiz) {
    return thiz.getMagnitude() * Math.sin(thiz.getDirection()); 
  }
}
```

Voila! `Vector` now structurally implements `Coordinate` and can be used with `coordSorter`.

Generally _implementation by extension_ is a powerful technique to provide a common API for classes your 
project does not control.

Nevertheless if you'd rather not add extension methods to `Vector`, or the extension class strategy is unsuitable for
your use-case e.g., the `Comparable<T>` interface sometimes makes this impossible, you can instead go a more direct
route and implement your own proxy factory...

## Implementation by Proxy

You can provide your own proxies the compiler can use to delegate structural calls.  This is especially useful to avoid
the one-time runtime overhead of the first call through a structural interface. Consider the `Coordinate` structural
interface earlier.
```java
Coordinate coord = (Coordinate) new Point(4,5);
coord.getX();
```
The first time `Point` is called through a `Coordinate` Manifold dynamically generates and compiles a proxy for `Point`
as a `Coordinate`.  Most of the time this does not matter -- avoid premature optimization! -- but when it does matter the
delay can be a problem.  To address that you can provide your own proxy ahead of time via the `IProxyFactory` service.
```java
public class Point_To_Coordinate implements IProxyFactory<Point, Coordinate> {
  @Override
  public Coordinate proxy(Point pt, Class<Coordinate> cls) {
    return new Proxy(pt);
  }

  public static class Proxy implements Coordinate
  {
    private final Point _delegate;

    public Proxy(Point pt) {
      _delegate = tp;
    }

    public double getX() {
      return _delegate.getX();
    }

    public double getY() {
      return _delegate.getY();
    }
  }
}
```
The compiler uses this proxy factory to make `Point` calls through `Coordinate`, which vastly improves the first time
call performance since it saves Manifold from dynamically generating and compiling a similar class.

Your proxy factory must be registered as a service in `META-INF` directly like so:
```
src
-- main
---- resources
------ META-INF
-------- services
---------- manifold.ext.api.IProxyFactory
```
Following standard Java [ServiceLoader protocol](https://docs.oracle.com/javase/7/docs/api/java/util/ServiceLoader.html)
you create a text file called `manifold.ext.api.IProxyFactory` in the `service` directory under your `META-INF` directory.
The file should contain the fully qualified name of your proxy factory class (the one that implements `IProxyFactory`) followed
by a new blank line:
```
com.abc.Point_To_Coordinate

```

### Using `factoryClass`
If you are the declarer of the structural interface, you can skip the Java service and specify a proxy factory
directly in the `@Structural` call site:

```java
@Structural(factoryClass = Point_To_Coordinate.class)
public interface Coordinate {
  ...
}
```

Manifold inspects the `facotryClass` to see whether or not it is appropriate for a given proxy.  For instance, from
the super class declaration `IProxyFactory<Point, Coordinate>` Manifold determines `Point_To_Coordinate` is exclusively
a proxy factory for `Point`, other classes go through the default dynamic proxy generation/compilation.  
 
 
## Dynamic Typing with `ICallHandler`

Manifold supports a form of dynamic typing via `manifold.ext.api.ICallHandler`:  

```java
public interface ICallHandler {
  /**
   * A value resulting from #call() indicating the call could not be dispatched.
   */
  Object UNHANDLED = new Object() {
    @Override
    public String toString() {
      return "Unhandled";
    }
  };

  /**
   * Dispatch a call to an interface method.
   *
   * @param iface The extended interface and owner of the method
   * @param name The name of the method
   * @param returnType The return type of the method
   * @param paramTypes The parameter types of the method
   * @param args The arguments from the call site
   * @return The result of the method call or UNHANDLED if the method is not dispatched.  
   *   Null if the method's return type is void.
   */
  Object call(Class iface, String name, Class returnType, Class[] paramTypes, Object[] args);
}
```

A class can implement `ICallHandler` nominally or it can be made to implement it via extension class.
Either way instances of the class can be cast to _any_ structural interface where structural calls
dispatch to `ICallHandler.call()`.  The class' implementation of `call()` can delegate the call any 
way it chooses.

For instance, via class extension Manifold provides `ICallHandler` support for `java.util.Map` so that 
getter and setter calls work directly with values in the map:

```java
Map<String,Object> map = new HashMap<>();
Name person = (Name) map;
person.setName("Manifold");
println(person.getName());
```
 
Because `Map` is a `ICallHandler` instances of it can be cast to any structural interface, such as
`Name` from the earlier example.  The `ICallHandler` implementation transforms get/set property calls
to get/put calls into the map using the name of the property in the method.  Additionally, method calls
can be made on map entries where the entry key matches the name of the method and the value is an instance
of a functional interface matching the signature of the call:

```java
map.put( "run", (Runnable)()-> println("hello") );
Runnable runner = (Runnable) map;
runner.run();
```

This example prints "hello" because `Map.call()` dispatches the call to the "run" entry having a 
`Runnable` functional interface value.

Note the similarity of this functionality on `Map` with _expando_ types in dynamic languages.  The
main difference is that invocations must be made through structural interfaces and not directly on 
the map, otherwise `Map` behaves much like an expando object.

See `manifold.collections.extensions.java.util.Map.MapStructExt.java` for details.

# Type-safe Reflection via `@Jailbreak`

Sometimes you have to use Java reflection to access fields, methods, and types that are not directly accessible from
your code. But writing reflection code is not only tedious and error-prone, it also loses type-safety in the process. 
Manifold mitigates these issues with the `@Jailbreak` annotation and the `jailbreak()` extension method.  Use them to
leverage the convenience and type-safety of the Java compiler and let Manifold generate reliable, efficient reflection 
code for you.

## Using `@Jailbreak`

Annotate the type of any variable with `@Jailbreak` to gain direct, type-safe access to private fields, methods, and
types.

>Note, `@Jailbreak` is ideal for use within tests. It saves you from losing type-safety that is otherwise the case with
reflection code and it enables you to maintain private methods and fields.

### Basic Use

```java
@Jailbreak Foo foo = new Foo(1);
foo.privateMethod();
foo.privateMethod("hey");
foo._privateField = 88;
```
```java
public class Foo {
  private final int _privateField;
  
  public Foo(int value) {
    _privateField = value;
  }
  
  private String privateMethod() {
    return "hi";
  }
  
  private String privateMethod(String param) {
    return param;
  }
}
```

### Use With Static Members

Since Java does not permit you to annotate the type in a static expression, you must use an instance:

```java
@Jailbreak MyClass myClass = null; // value is insignificant
myClass.staticMethod();
myClass.Static_Field = "hi";
```
```java
public class MyClass {
  private static String Static_Field = "hello";
  
  private static void staticMethod() {
  }
}
```

### Use With Types and Constructors

Use `@Jailbreak` to access hidden types and constructors:
```java
com.abc. @Jailbreak SecretClass secretClass = 
  new com.abc. @Jailbreak SecretClass("hi");
secretClass._data = "hey";
```
```java
package com.abc;
// not public
class SecretClass {
  private final String _data;

  // not public
  SecretClass(String data){
    _data = data;
  }
}
```

### Break JPMS Barriers

Access fields, methods, and constructors from packages otherwise prohibited for use in your module by the JPMS:
```java
jdk.internal.misc. @Jailbreak VM vm = null;
String[] args = vm.getRuntimeArguments();
```
        
## Using the `jailbreak()` Extension

Similar to `@Jailbreak` you can call the `jailbreak()` extension method from any expression to gain type-safe access to 
private fields, methods, and types.

```java
Foo foo = new Foo();
foo.jailbreak().privateMethodOnFoo();
```
This method is especially handy when you have a chain of member access expressions and you want to quickly use
inaccessible members:

```java
something.foo().jailbreak().bar.jailbreak().baz = value;
``` 

# The *Self* Type via `@Self`

The *Self* type is a common term used in the language community to mean *"the subtype of `this`"* and is most useful
in situations where you want a return type or parameter type of a method in a base type to reflect the subtype
i.e., the *invoking* type.  For instance, consider the `equals()` method. We all know it suffers from Java's lack of a
Self type:
```java
public class MyClass {
  @Override
  public boolean equals(Object obj) { // why Object?!
    ...
  }
}

MyClass myClass = new MyClass();
myClass.equals("nope"); // this compiles! :(
```
What we want is to somehow override `equals()` to enforce `MyClass` symmetry:
```java
public boolean equals(MyClass obj) {
  ...
}
```
But Java does not support covariance in parameter types, and for good reason. It would break if we called it like this:
```java
((Object)myClass).equals("notMyClass"); // BOOM! String is not assignable to MyClass
```

Manifold's **`@Self`** type provides an elegant solution:
```java
public boolean equals(@Self Object obj) {
  ...
}
```
Now we have the behavior we want:
```java
MyClass myClass = new MyClass();
myClass.equals("notMyClass"); // Compile Error. YES!!!
```

> Note although Java does not provide a Self type, it does provide some of its capabilities with *recursive generic types*.
But this feature can be difficult to understand and use, and the syntax it imposes is often unsuitable for class
hierarchies and APIs. Additionally, it is ineffective for cases like `equals()` -- it requires that we change the base
class definition! E.g., `public class Object<T extends Object<T>>`... oy!

But as you'll see Manifold's `@Self` annotation altogether removes the need for recursive generics. It provides Java with
a simpler, more versatile alternative.  Use it on method return types, parameter types, and field types to enforce
*"the subtype of `this`"* where suitable.

## Builders

A common use-case for the Self type involves fluent APIs like the *Builder* pattern:

```java
public class VehicleBuilder {
  private int _wheels;
  
  public VehicleBuilder withWheels(int wheels) {
    _wheels = wheels;
    return this; // returns THIS
  }
}
```  

This is fine until we subclass it:

```java
public class AirplaneBuilder extends VehicleBuilder {
  private int _wings;
  
  public AirplaneBuilder withWings(int wings) {
    _wings = wings;
    return this; // returns THIS
  }
}

...

Airplane airplane = new AirplaneBuilder()
  .withWheels(3) // returns VehicleBuilder :(
  .withWings(1)  // ERROR
```

`withWheels()` returns `VehicleBuilder`, not `AirplaneBuilder`.  This is a classic example where we want to return the 
*"the subtype of `this`"*.  This is what the self type accomplishes:

```java
  public @Self VehicleBuilder withWheels(int wheels) {
    _wheels = wheels;
    return this; // returns THIS
  }
```

Now with the return type annotated with `@Self` the example works as desired:

```java
Airplane airplane = new AirplaneBuilder()
  .withWheels(2) // returns AirplaneBuilder :)
  .withWings(1)  // GOOD!
``` 

Annotate with `@Self` to preserve the *"the subtype of `this`"* anywhere on or in a method return type, parameter type,
or field type.

## Self + Generics

You can also use `@Self` to annotate a _type argument_.  A nice example of this involves a typical graph or tree
structure where the nodes in the structure are homogeneous:

```java
public class Node {
  private List<Node> children;
  
  public List<@Self Node> getChildren() {
    return children;
  }

  public void addChild(@Self Node child) {
    children.add(child);
  }
}

public class MyNode extends Node {
  ...
}
```

Here you can make the component type of `List` the Self type so you can use the `getChildren` method type-safely from
subtypes of node:

```java
MyNode myNode = findMyNode();
List<MyNode> = myNode.getChildren(); // wunderbar! 
```

## Self + Extensions

You can use `@Self` with [extension methods](#extension-classes-via-extension) too.  Here we make an extension method as
a means to conveniently chain additions to `Map` while preserving its concrete type:

```java
public static <K,V> @Self Map<K,V> add(@This Map<K,V> thiz, K key, V value) {
  thiz.put(key, value);
  return thiz;
}

HashMap<String, String> map = new HashMap<>()
  .add("nick", "grouper")
  .add("miles", "amberjack");
  .add("alec", "barracuda")
```

## Overriding Methods

Using @Self in a method return type or parameter type has _no_ effect on the method's override characteristics or binary
signature:
```java
public class SinglyNode {
  private @Self SinglyNode next;
  
  public void setNext(@Self SinglyNode next) {
    this.next = next;
  }
}

public class DoublyNode extends SinglyNode {
  private @Self DoublyNode prev;

  public void setNext(@Self SinglyNode next) {
    if(next instanceof DoublyNode) {
      super.setNext(next);
      next.prev = this;
    }
    else {
      throw new IllegalArgumentException();
    }
  }
}
```
Of particular interest is the `@Self SinglyNode` parameter in the `DoublyNode` override. As mentioned earlier Java does not
permit covariant parameter overrides -- we can't override the method using a `DoublyNode` parameter type.  To make up for
this `@Self` informs the compiler that the parameter is indeed a `DoublyNode` when invoked from a `DoublyNode`:
```java
doublyNode.setNext(singlyNode); // Compile Error :)
doublyNode.setNext(doublyNode); // OK :)
```
This is precisely the arrangement we want.  Type-safety is enforced at the call site.  But, equally important, the
subclass handles the parameter as a base class.  Why?  Because this:
```java
((SinglyNode)doublyNode).setNext(singlyNode);
```
Here `setNext()`, although invoked as a `SinglyNode`, dispatches to the `DoublyNode` override.  Thus the `SinglyNode` parameter
type enforces that a `SinglyNode` cannot be mistaken for `DoublyNode`, hence the necessity of the `instanceof` check in
`setNext()`.

# IDE Support 

Manifold is best experienced using [IntelliJ IDEA](https://www.jetbrains.com/idea/download).

## Install

Get the [Manifold plugin](https://plugins.jetbrains.com/plugin/10057-manifold) for IntelliJ IDEA directly from IntelliJ via:

<kbd>Settings</kbd> ➜ <kbd>Plugins</kbd> ➜ <kbd>Marketplace</kbd> ➜ search: `Manifold`

<p><img src="http://manifold.systems/images/ManifoldPlugin.png" alt="echo method" width="60%" height="60%"/></p>

## Sample Project

Experiment with the [Manifold Sample Project](https://github.com/manifold-systems/manifold-sample-project) via:

<kbd>File</kbd> ➜ <kbd>New</kbd> ➜ <kbd>Project from Version Control</kbd> ➜ <kbd>Git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProjectMenu.png" alt="echo method" width="60%" height="60%"/></p>

Enter: <kbd>https://github.com/manifold-systems/manifold-sample-project.git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProject.png" alt="echo method" width="60%" height="60%"/></p>

Use the [plugin](https://plugins.jetbrains.com/plugin/10057-manifold) to really boost your productivity. Use code
completion to conveniently access extension methods. Create extension methods using a convenient user interface. Make
changes to your extensions and use the changes immediately, no compilation! Use extensions provided by extension library
dependencies. Find usages of any extension. Use structural interfaces, `@Jailbreak`, `@Self`, etc. Perform rename
refactors to quickly and safely make project-wide changes.

# Setup

## Building this project

The `manifold-ext` project is defined with Maven.  To build it install Maven and run the following command.

```
mvn compile
```

## Using this project

The `manifold-ext` dependency works with all build tooling, including Maven and Gradle. It also works with Java versions
8 - 13.

>Note you can replace the `manifold-ext` dependency with [`manifold-all`](https://github.com/manifold-systems/manifold/tree/master/manifold-all) as a quick way to gain access to all of
Manifold's features.

## Binaries

If you are *not* using Maven or Gradle, you can download the latest binaries [here](http://manifold.systems/docs.html#download).


## Gradle

Here is a sample `build.gradle` script. Change `targetCompatibility` and `sourceCompatibility` to your desired Java
version (8 - 13), the script takes care of the rest.  
```groovy
plugins {
    id 'java'
}

group 'systems.manifold'
version '1.0-SNAPSHOT'

targetCompatibility = 11
sourceCompatibility = 11

repositories {
    jcenter()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
}

dependencies {
    compile group: 'systems.manifold', name: 'manifold-ext', version: '2019.1.32'
    testCompile group: 'junit', name: 'junit', version: '4.12'
                       
    if (JavaVersion.current() == JavaVersion.VERSION_1_8) {
        // tools.jar dependency (for Java 8 only), primarily to support structural typing without static proxies.
        // Thus if you are *not* using structural typing, you **don't** need tools.jar
        compile files( "${System.properties['java.home']}/../lib/tools.jar" )
    }
    // Add manifold to -processorpath for javac
    annotationProcessor group: 'systems.manifold', name: 'manifold-ext', version: '2019.1.32'
}

if (JavaVersion.current() != JavaVersion.VERSION_1_8 &&
    sourceSets.main.allJava.files.any {it.name == "module-info.java"}) {
    tasks.withType(JavaCompile) {
        // if you DO define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold', '--module-path', it.classpath.asPath]
    }
} else {
    tasks.withType(JavaCompile) {
        // If you DO NOT define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold']
    }
}

tasks.compileJava {
    classpath += files(sourceSets.main.output.resourcesDir) //adds build/resources/main to javac's classpath
    dependsOn processResources
}
tasks.compileTestJava {
    classpath += files(sourceSets.test.output.resourcesDir) //adds build/resources/test to test javac's classpath
    dependsOn processTestResources
}
```
Use with accompanying `settings.gradle` file:
```groovy
rootProject.name = 'MyExtProject'
```

## Maven

### Java 8

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-ext-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Java Extension App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-ext</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>8</source>
                    <target>8</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
        </plugins>
    </build>

    <profiles>
        <!-- tools.jar dependency (for Java 8 only), primarily to support structural typing without static proxies.
             Thus if you are not using structural typing, you **don't** need tools.jar -->
        <profile>
            <id>internal.tools-jar</id>
            <activation>
                <file>
                    <exists>\${java.home}/../lib/tools.jar</exists>
                </file>
            </activation>
            <dependencies>
                <dependency>
                    <groupId>com.sun</groupId>
                    <artifactId>tools</artifactId>
                    <version>1.8.0</version>
                    <scope>system</scope>
                    <systemPath>\${java.home}/../lib/tools.jar</systemPath>
                </dependency>
              </dependencies>
        </profile>
    </profiles>
</project>
```

### Java 9 or later
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-ext-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Java Extension App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-ext</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                    <!-- Add the processor path for the plugin (required for Java 9+) -->
                    <annotationProcessorPaths>
                        <path>
                            <groupId>systems.manifold</groupId>
                            <artifactId>manifold-ext</artifactId>
                            <version>${manifold.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

# License

## Open Source
Open source Manifold is free and licensed under the [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0) license.  

## Commercial
Commercial licenses for this work are available. These replace the above ASL 2.0 and offer 
limited warranties, support, maintenance, and commercial server integrations.

For more information, please visit: http://manifold.systems//licenses

Contact: admin@manifold.systems

# Versioning

For the versions available, see the [tags on this repository](https://github.com/manifold-systems/manifold/tags).

# Author

* [Scott McKinney](mailto:scott@manifold.systems)
# Extension Class Producer Sample

The manifold-ext-producer-sample module demonstrates how to implement a 
[type manifold](http://manifold.systems/docs.html#what-is-a-type-manifold) 
to dynamically add [Extension Classes](http://manifold.systems/docs.html#extension-classes) from resource files.

This example creates the `ExtensionProducerSampleTypeManifold` class and 
uses the contrived `.favs` resource files with the following simple format:

```ebnf
grammar = entry | { entry "\n" };
entry = type-name "|" property-name "|" property-value 
type-name = Qualified Java type name
property-name = Java identifier rules
property-value = any text  
```  

For example, file `MyFavorites.favs`:
```text
java.lang.Integer|Color|Red
java.lang.Integer|Food|Chicago-style pizza
abc.MyClass|Color|Blue
```

There can be any number of `.favs` resource files in your project, each
having any number of entries.  `ExtensionProducerSampleTypeManifold`
reads all the `.favs` files, determines the full set of types and properties 
per type, and produces Extension classes for each type.  If `MyFavorites.favs` 
were the only `.favs` file, `ExtensionProducerSampleTypeManifold` would create
two Extension classes:

```java
import manifold.ext.api.Extension;
import manifold.ext.api.This;

@Extension
public class ManIntegerExt {
  public static String favoriteColor(@This String thiz) {
    return "Red";
  }
 
  public static String favoriteFood(@This String thiz) {
    return "Chicago-style pizza";
  }
} 
``` 
and 
```java
import manifold.ext.api.Extension;
import manifold.ext.api.This;

@Extension
public class ManMyClassExt {
  public static String favoriteColor(@This String thiz) {
    return "Blue";
  }
} 
```  

In turn the [Extension type manifold](http://manifold.systems/docs.html#the-extension-manifold)
consumes these extension classes and augments `Integer` and `MyClass` with `favorite` methods 
accordingly.# The GraphQL Manifold

[![graphql](http://manifold.systems/images/graphql_slide_1.png)](http://manifold.systems/images/graphql.mp4)

Use the GraphQL Manifold for productive _Schema-First_ [GraphQL](https://graphql.org/) development in any Java project.
**Type-safely** build and execute queries and mutations without introducing a code generation step in your build
process. Access GraphQL types defined in standard `.graphql` schemas directly in your Java code. Build queries 
using native `.graphql` query files and immediately access changes as you make them from Java code -- without 
recompiling!  Your code is always in sync with GraphQL definitions.

> Clone the [sample GraphQL application](https://github.com/manifold-systems/manifold-sample-graphql-app) to quickly
begin experimenting with GraphQL using Manifold.

## Table of Contents
* [GraphQL Files](#graphql-files)
* [Fluent API](#fluent-api)
* [Creating Types & Queries](#building-types--queries)
* [Execute Queries](#execute-queries)
* [Execute Mutations](#execute-mutations)
* [HTTP Request Configuration](#http-request-configuration)
* [Loading a GraphQL Object](#loading-a-graphql-object)
* [Writing GraphQL Objects](#writing-graphql-objects)
* [Copying GraphQL Objects](#copying-graphql-objects)
* [Types](#type)
* [Scalar Types](#scalar-types)
* [Embedding Queries with Fragments](#embedding-queries-with-fragments)
* [IDE Support](#ide-support)
* [Setup](#setup)
* [License](#license)
* [Versioning](#versioning)
* [Author](#author)

## GraphQL Files

The GraphQL Manifold enables your Java code to directly access types and queries defined in native GraphQL schema files.
Drop a schema file into your project and start using and building queries in your code, no code generators to engage, no
recompiling between schema changes. Supports all standard file extensions including `.graphql`, `.graphqls`, and `.gql`.    

When you add a GraphQL file to your project it becomes a Java *resource*.  A resource, like a class, is rooted in a resource or
source directory, depending on your build configuration.  Maven and Gradle projects, for example, typically define a
`src/main/resources` root for all the resource files in a given module.

The path from the resource root determines the fully qualified name of the types derived from the GraphQL files.  For
example, GraphQL type definitions from file `src/main/resources/com/example/Movies.graphql` are accessible from Java
interface `com.example.Movies` where `com.example` is the package and `Movies` is the top-level interface name.  Type
definitions are inner classes defined inside the `Movies` interface.

>You can provide any number of GraphQL resource files; all files form a collective GraphQL type domain.  This means you
can organize schema types in separate files and also separate queries and mutations from schema definitions.
 
### Schema File Sample: `com/example/Movies.graphql`
```graphql
type Query {
    movies(genre: Genre!, title: String, releaseDate: Date) : [Movie!]
    reviews(genre: Genre) : [Review!]
}

type Movie {
    id: ID!
    title: String!
    genre: [Genre!]!
    releaseDate: Date!
}

type Mutation {
    createReview(movie: ID!, review: ReviewInput) : Review
}

input MovieInput {
    title: String!
    genre: Genre!
    releaseDate: Date
}

input ReviewInput {
    stars: Int!
    comment: String
}

type Review {
    id: ID!
    movie: Movie!
    stars: Int!
    comment: String
}

enum Genre {
    Action, Comedy, Drama, Fantasy, Horror, Romance, SciFi, Western
}

scalar Date
```  

### Query File Sample: `com/example/MovieQueries.graphql`
```graphql
query MovieQuery($genre: Genre!, $title: String, $releaseDate: Date) {
    movies(genre: $genre, title: $title, releaseDate: $releaseDate) {
        id
        title
        genre
        releaseDate
    }
}

query ReviewQuery($genre: Genre) {
    reviews(genre: $genre) {
        id
        stars
        comment
        movie {
            id
            title
        }
    }
}

mutation ReviewMutation($movie: ID!, $review: ReviewInput!) {
    createReview(movie: $movie, review: $review) {
        id
        stars
        comment
    }
}

extend type Query {
    reviewsByStars(stars: Int) : [Review!]!
}
```

## Fluent API

GraphQL is a language-neutral, type-safe API.  The GraphQL Manifold provides a concise, fluent mapping of the API to
Java.  For example, the `MovieQuery` type is a Java interface and provides type-safe methods to:
* **create** a `MovieQuery`
* **build** a `MovieQuery`
* **modify** properties of a `MovieQuery`  
* **load** a `MovieQuery` from a string, a file, or a URL
* **execute** a `MovieQuery` with *type-safe* response 
* **write** a `MovieQuery` as formatted JSON, YAML, or XML
* **copy** a `MovieQuery`
* **cast** to `MovieQuery` from any structurally compatible type including `Map`s, all *without proxies*

## Building Types & Queries
You create an instance of a GraphQL type using either the `create()` method or the `builder()` method.

The `create()` method defines parameters matching the `non-null` parameters declared in the query schema; if no non-null
parameters exist, `create()` has an empty parameter list.

For example, the `MovieQuery.create()` method declares one parameter corresponding with the non-null `Genre` parameter:
```java
static MovieQuery create(@NotNull Genre genre) {...}
```
You can use this to create a new `MovieQuery` with a `Genre` then modify it using _setter_ methods to change optional
properties:
```java
import com.example.MovieQueries.*;
import java.time.LocalDate;
import static com.example.Movies.Genre.Action;
...
MovieQuery query = MovieQuery.create(Action);
query.setTitle("Le Mans");
query.setReleaseDate(LocalDate.of(1971, 6, 3));
```

Alternatively, you can use `builder()` to fluently build a new instance:
```java
MovieQuery query = MovieQuery.builder(Action)
  .withTitle("Le Mans")
  .withReleaseDate(LocalDate.of(1971, 6, 3))
  .build();
```

You can initialize several properties in a chain of `with` calls in the builder. This saves a bit of typing with
heavier APIs.  After it is fully configured call the `build()` method to construct the type.

## Execute Queries
You can execute queries and mutations using a concise, fluent API.  Simply provide the endpoint as a URL, and get or
post your request. Query results are type-safe and constrained to the properties defined in the GraphQL query.

```java
import com.example.MovieQueries.*;
import java.time.LocalDate;
import static com.example.Movies.Genre.Action;
...
private static String ENDPOINT = "http://com.example/graphql";
...
var query = MovieQuery.builder(Action).build();
var result = query.request(ENDPOINT).post();
var actionMovies = result.getMovies();
for (var movie : actionMovies) {
  out.println(
    "Title: " + movie.getTitle() + "\n" +
    "Genre: " + movie.getGenre() + "\n" +
    "Year: " + movie.getReleaseDate().getYear() + "\n");
}
```

## Execute Mutations
You execute a mutation exactly as you would a query using the same API.  Note this example creates a `ReviewInput`
instance also using the same API.  

```java
// Find the movie to review ("Le Mans")
var movie = MovieQuery.builder(Action).withTitle("Le Mans").build()
  .request(ENDPOINT).post().getMovies().first();
// Submit a review for the movie
var review = ReviewInput.builder(5).withComment("Topnotch racing film.").build();
var mutation = ReviewMutation.builder(movie.getId(), review).build();
var createdReview = mutation.request(ENDPOINT).post().getCreateReview();
out.println(
  "Review for: " + movie.getTitle() + "\n" +
  "Stars: " + createdReview.getStars() + "\n" +
  "Comment: " + createdReview.getComment() + "\n"
);
```

## HTTP Request Configuration

You can configure the HTTP request to your needs.  For instance, you can use a variety of authorization options, set
header values, specify a timeout, etc.

```java
// Specify an authorization token
query.request(ENDPOINT).withAuthorization(...)

// Supply header values
query.request(ENDPOINT).withHeader(...)

// Set a timeout
query.request(ENDPOINT).withTimeout(...)
```

## Loading a GraphQL Object
In addition to creating an object from scratch with `create()` and `build()` you can also load an instance from 
a variety of existing sources using `load()`.

You can load a `MovieQuery` instance from a variety of formats including JSON, XML, and YAML:
```java
MovieQuery query = MovieQuery.load().fromYaml(
  "genre: Action\n" +
  "title: Le Mans\n" +
  "releaseDate: 1971-06-03");
```

Load from a file:
```java
User user = User.load().fromJsonFile("/path/to/MyMovieQuery.json");
```

## Writing GraphQL Objects
An instance of a GraphQL object can be written as formatted text with `write()`:
* `toJson()` - produces a JSON formatted String
* `toYaml()` - produces a YAML formatted String
* `toXml()` - produces an XML formatted String

The following example produces a JSON formatted string:
```java
MovieQuery query = MovieQuery.builder(Action)
  .withTitle("Le Mans")
  .withReleaseDate(LocalDate.of(1972, 6, 3))
  .build();

String json = query.write().toJson();
System.out.println(json);
```
Output:
```json
{
  "genre": "Action",
  "title": "Le Mans",
  "releaseDate": "1971-06-03"
}
```

## Copying GraphQL Objects
Use the `copy()` method to make a deep copy of any GraphQL object:
```java
MovieQuery query = MovieQuery.create(...);
...
MovieQuery copy = query.copy();
```
Alternatively, you can use the `copier()` static method for a richer set of features:
```java
MovieQuery copy = MovieQuery.copier(query).withGenre(Drama).copy();
```
`copier()` is a lot like `builder()` but lets you start with an already built object you can modify.


## Types

GraphQL provides several useful type abstractions these include:
* `schema`
* `type`
* `input`
* `interface`
* `enum`
* `union`
* `scalar`
* `fragment`
* `query`
* `mutation`
* `subscription`
* `extend`

The GraphQL manifold supports all type abstractions except the subscription type, which will be supported in a later
release.

### `schema`
`schema` is a simple type that lets you specify the root query type, the root mutation type, and the root subscription
type.  Without a schema type, the default root type names are `Query`, `Mutation`, and `Subscription`.

### `type`
`type` is the GraphQL foundational abstraction. The manifold API reflects a `type` as a structural _interface_. 
As the basis of the GraphQL manifold API, interfaces hide implementation detail that may otherwise complicate
the evolution of the API e.g., as new features are added to the GraphQL specification.

### `input`
An `input` is basically a `type` intended for use as a mutation constraint. It is identical to `type` in terms of
representation in the manifold API.  

### `interface`
`interface` abstractions are structural interfaces in the manifold API.  They are structured just like `type`
abstractions, but do not have creation methods.

### `enum`
The `enum` abstraction maps directly to a Java enum in the manifold API.

### `union`
Since the JVM does not provide a union type the manifold API approximates it as an interface extending the least
upper bound (LUB) `interface` abstraction of the union component types, or extends nothing if no LUB `interface` exists.
Its declared properties consist of the intersection of all the properties of the union component types.  As such a
property outside the intersection must be accessed by casting a union to a union component type declaring the
property.  Note a GraphQL query can provide a discriminator in terms of the `__typename` property to facilitate
conditional access to union properties.

### `scalar`
The manifold API fully supports GraphQL scalars and also provides a host of non-standard but commonly used types. See
_Scalar Types_ below.
 
### `fragment`
Not to be confused with [Manifold Fragments](#embedding-queries-with-fragments), a GraphQL fragment is generally a query
you can directly reference inside other queries so you don't have to copy and paste the same set of fields. Instead you
simply reference the name of the fragment. This not only helps reduce the size of queries, but also prevents copy/paste
errors and makes your queries more readable.
 
### `query`
Similar to the `type` abstraction, the manifold API exposes a `query` as a structural interface. Non-null query
parameters translate to parameters in the `create` and `builder` methods, and the nullable parameters are _getter_/_setter_
methods and _with_ methods in the builder.  Additionally the _structural_ interfaces allow the query implementation to be free
of POJOs, marshalling, and other mapping code present in conventional API tooling.  As such a query structural interface
*directly* overlays a raw GraphQL query response; there is absolutely *zero* processing of query results after a query
HTTP request.  The only processing involved happens when a scalar value must be coerced to a type-safe value; this
happens lazily on a per call-site basis.

### `mutation`
The manifold API treatment of mutations is identical to queries. See `query` above.
 
### `subscription`
_not implemented_

### `extend`
You can add properties, interfaces, and annotations to existing types using the `extend` construct.  The manifold API
fully supports all type extensions.


## Scalar Types

GraphQL specifies several standard scalar types, in addition to these Manifold provides several other non-standard, but
commonly used types.  These include:

| Name             | Persists&nbsp;As  | Java Type                                     |
|------------------|--------------|-----------------------------------------------|
| **Byte**         | _byte_       | `byte` or `java.lang.Byte` if nullable        |
| **Char**         | _char_       | `char` or `java.lang.Character` if nullable   |
| **Character**    | _char_       | `char` or `java.lang.Character` if nullable   |
| **Int**          | _integer_    | `int` or `java.lang.Integer` if nullable      |
| **Integer**      | _integer_    | `int` or `java.lang.Integer` if nullable      |
| **Long**         | _long_       | `long` or `java.lang.Long` if nullable        |
| **Float**        | _double_     | `double` or `java.lang.Double` if nullable    |
| **Double**       | _double_     | `double` or `java.lang.Double` if nullable    |
| **Boolean**      | _boolean_    | `boolean` or `java.lang.Boolean` if nullable  |
| **String**       | _string_     | `java.lang.String`                            |
| **ID**           | _string_     | `java.lang.String`                            |
| **Date**         | _string_     | `java.time.LocalDate`                         |
| **LocalDate**    | _string_     | `java.time.LocalDate`                         |
| **Time**         | _string_     | `java.time.LocalTime`                         |
| **LocalTime**    | _string_     | `java.time.LocalTime`                         |
| **DateTime**     | _string_     | `java.time.LocalDateTime`                     |
| **LocalDateTime**| _string_     | `java.time.LocalDateTime`                     |
| **Instant**      | _integer_    | `java.time.Instant`                           |
| **BigInteger**   | _string_     | `java.math.BigInteger`                        |
| **BigDecimal**   | _string_     | `java.math.BigDecimal`                        |
| **Binary**       | _string_     | `manifold.api.json.codegen.schema.OctetEncoding`      |
| **Octet**        | _string_     | `manifold.api.json.codegen.schema.OctetEncoding`      |
| **Base64**       | _string_     | `manifold.api.json.codegen.schema.Base64Encoding`     | 

Additionally, Manifold includes an API you can implement to provide your own custom scalar types.  Implement the 
`manifold.api.json.codegen.schema.IJsonFormatTypeResolver` interface as a 
[service provider](https://docs.oracle.com/javase/tutorial/ext/basics/spi.html#register-service-providers).

>If you've implemented format type resolvers for JSON Schema, you can share them with your GraphQL APIs.  No need to
reinvent the wheel!

# Embedding Queries with Fragments

<small>
(Note this is a completely separate feature from GraphQL fragments and does not involve the `fragment` keyword)
</small><br>

>Note fragments are an experimental feature

You can now *embed* resource content such as GraphQL directly in Java source as a type-safe resource _**fragment**_. This
means you can embed a type-safe GraphQL query exactly where you use it in your Java code -- no need to create a separate
resource file.

A fragment can be either a *declaration* or an *expression*.  A fragment declaration is embedded in a multi-line
comment like this:
```java
/*[>MyQuery.graphql<]
query Movies($title: String, $genre: Genre, $releaseDate: Date) {
    movies(title: $title, genre: $genre, releaseDate: $releaseDate) {
        id
        title
        genre
        releaseDate
    }
}
*/

var query = MyQuery.Movies.builder().withGenre(Action).build();
out.println(query.toString());
```
>**IntelliJ users...**
>
>Get the [JS GraphQL plugin](https://plugins.jetbrains.com/plugin/8097-js-graphql) for rich editing of embedded
>GraphQL fragments, it pairs exceptionally well with the [Manifold plugin](https://plugins.jetbrains.com/plugin/10057-manifold).
 
A fragment *expression* is embedded in a String literal:
```java
var query = "[>.graphql<] query MovieQuery($genre: Genre){ movies(genre: $genre){ genre } }";
var result = query.builder().build().request("").post();
result.getMovies().forEach( e -> e.getGenre() );
```

With Java 13 [text block](https://openjdk.java.net/jeps/355) String literals you can easily author multi-line fragment
expressions like this:
```java
var query = """
  [>.graphql<]
  query Movies($genre: Genre!, $title: String, $releaseDate: Date) {
    movies(genre: $genre, title: $title, releaseDate: $releaseDate) {
      id
      title
      genre
      releaseDate
    }
  }
  """;
var result = query.create(Action).request(ENDPOINT).post();
```  
 
Read more about fragments in the [core Manifold docs](https://github.com/manifold-systems/manifold/tree/master/manifold-core-parent/manifold#embedding-with-fragments-experimental).

# IDE Support 

Manifold is best experienced using [IntelliJ IDEA](https://www.jetbrains.com/idea/download).

## Install

Get the [Manifold plugin](https://plugins.jetbrains.com/plugin/10057-manifold) for IntelliJ IDEA directly from IntelliJ
via:

<kbd>Settings</kbd> ➜ <kbd>Plugins</kbd> ➜ <kbd>Marketplace</kbd> ➜ search: `Manifold`

<p><img src="http://manifold.systems/images/ManifoldPlugin.png" alt="echo method" width="60%" height="60%"/></p>

## Sample Project

Experiment with the [Manifold GraphQL Sample Project](https://github.com/manifold-systems/manifold-sample-graphql-app)
via:

<kbd>File</kbd> ➜ <kbd>New</kbd> ➜ <kbd>Project from Version Control</kbd> ➜ <kbd>Git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProjectMenu.png" alt="echo method" width="60%" height="60%"/></p>

Enter: <kbd>*https://github.com/manifold-systems/manifold-sample-graphql-app.git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProject_graphql.png" alt="echo method" width="60%" height="60%"/></p>

Use the [plugin](https://plugins.jetbrains.com/plugin/10057-manifold) to really boost your productivity. Use code
completion to conveniently build queries and discover the schema's API.  Navigate to/from call-sites and GraphQL schema
file elements.  Make changes to your query schema files and use the changes immediately, no compilation!  Find usages of
any element in your schema files. Perform rename refactors to quickly and safely make project-wide changes.

>**Note:** Don't forget to install the [JS GraphQL](https://plugins.jetbrains.com/plugin/8097-js-graphql) plugin
for superb GraphQL file editing support in your project. It pairs well with the Manifold plugin.

# Setup

## Building this project

The `manifold-graphql` project is defined with Maven.  To build it install Maven and a Java 8 JDK and run the following
command.
```
mvn compile
```

## Using this project

The `manifold-graphql` dependency works with all build tooling, including Maven and Gradle. It fully supports Java
versions 8 - 13.

>Note you can replace the `manifold-graphql` dependency with [`manifold-all`](https://github.com/manifold-systems/manifold/tree/master/manifold-all)
as a quick way to gain access to all of Manifold's features.  But `manifold-graphql` already brings in a lot of
Manifold including [Extension Methods](http://manifold.systems/docs.html#extension-classes),
[String Templates](http://manifold.systems/docs.html#templating), and more.

## Binaries

If you are *not* using Maven or Gradle, you can download the latest binaries [here](http://manifold.systems/docs.html#download).


## Gradle

Here is a sample `build.gradle` script. Change `targetCompatibility` and `sourceCompatibility` to your desired Java
version (8 - 13), the script takes care of the rest. 
```groovy
plugins {
    id 'java'
}

group 'systems.manifold'
version '1.0-SNAPSHOT'

targetCompatibility = 11
sourceCompatibility = 11

repositories {
    jcenter()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
}

dependencies {
    compile group: 'systems.manifold', name: 'manifold-graphql', version: '2019.1.32'
    testCompile group: 'junit', name: 'junit', version: '4.12'

    // Add manifold to -processorpath for javac
    annotationProcessor group: 'systems.manifold', name: 'manifold-graphql', version: '2019.1.32'
}

if (JavaVersion.current() != JavaVersion.VERSION_1_8 &&
    sourceSets.main.allJava.files.any {it.name == "module-info.java"}) {
    tasks.withType(JavaCompile) {
        // if you DO define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold', '--module-path', it.classpath.asPath]
    }
} else {
    tasks.withType(JavaCompile) {
        // If you DO NOT define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold']
    }
}

tasks.compileJava {
    classpath += files(sourceSets.main.output.resourcesDir) //adds build/resources/main to javac's classpath
    dependsOn processResources
}
tasks.compileTestJava {
    classpath += files(sourceSets.test.output.resourcesDir) //adds build/resources/test to test javac's classpath
    dependsOn processTestResources
}
```
Use with accompanying `settings.gradle` file:
```groovy
rootProject.name = 'MyProject'
```

## Maven

### Java 8

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-graphql-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My GraphQL App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-graphql</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>8</source>
                    <target>8</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

### Java 9 or later
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-graphql-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My GraphQL App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-graphql</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                    <!-- Add the processor path for the plugin (required for Java 9+) -->
                    <annotationProcessorPaths>
                        <path>
                            <groupId>systems.manifold</groupId>
                            <artifactId>manifold-graphql</artifactId>
                            <version>${manifold.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

# License

## Open Source
Open source Manifold is free and licensed under the [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0) license.  

## Commercial
Commercial licenses for this work are available. These replace the above ASL 2.0 and offer 
limited warranties, support, maintenance, and commercial server integrations.

For more information, please visit: http://manifold.systems//licenses

Contact: admin@manifold.systems

# Versioning

For the versions available, see the [tags on this repository](https://github.com/manifold-systems/manifold/tags).

# Author

* [Scott McKinney](mailto:scott@manifold.systems)
# Manifold : Highjump

(under construction)# Manifold : Image

User interfaces frequently use image resource files for one purpose or another.  Java supports most of the popular
formats including png, jpg, gif, and bmp via a collection of utility classes such as `javax.swing.ImageIcon` and
`javax.scene.image.Image`.
  
As with any library, access to the underlying data resource is indirect. Here we manually create an `ImageIcon` with a raw
String naming the image file.  This is error prone because there is no type-safety connecting the String with the file
on disk -- your build process will not catch typos or file rename related errors:

```java
ImageIcon image = new ImageIcon("abc/widget/images/companyLogo.png");
```

Custom library layers often contribute toward image caching and other services:
```java
import abc.widget.util.ImageUtilities;

ImageIcon image = ImageUtilities.getCachedImage("abc/widget/images/companyLogo.png");
render(image);
```

The image manifold eliminates much of this with direct, type-safe access to image resources.
```java
import abc.widget.images.*;

ImageIcon image = companyLogo_png.get();
render(image);
```

All image resources are accessible as classes where each class has the same name as its image file including a suffix
encoding the image extension, this helps distinguish between images of different types sharing a single name.
Additionally image classes are direct subclasses of the familiar `ImageIcon` class to conform with existing frameworks.
As with all type manifolds there are no code gen files or other build steps involved.

# IDE Support 

Manifold is best experienced using [IntelliJ IDEA](https://www.jetbrains.com/idea/download).

## Install

Get the [Manifold plugin](https://plugins.jetbrains.com/plugin/10057-manifold) for IntelliJ IDEA directly from IntelliJ
via:

<kbd>Settings</kbd> ➜ <kbd>Plugins</kbd> ➜ <kbd>Marketplace</kbd> ➜ search: `Manifold`

<p><img src="http://manifold.systems/images/ManifoldPlugin.png" alt="echo method" width="60%" height="60%"/></p>

## Sample Project

Experiment with the [Manifold Sample Project](https://github.com/manifold-systems/manifold-sample-project) via:

<kbd>File</kbd> ➜ <kbd>New</kbd> ➜ <kbd>Project from Version Control</kbd> ➜ <kbd>Git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProjectMenu.png" alt="echo method" width="60%" height="60%"/></p>

Enter: <kbd>https://github.com/manifold-systems/manifold-sample-project.git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProject.png" alt="echo method" width="60%" height="60%"/></p>

Use the [plugin](https://plugins.jetbrains.com/plugin/10057-manifold) to really boost your productivity. Use code
completion to conveniently access images. Perform rename refactors to quickly and safely make project-wide changes.

# Setup

## Building this project

The `manifold-image` project is defined with Maven.  To build it install Maven and run the following command.

```
mvn compile
```

## Using this project

The `manifold-image` dependency works with all build tooling, including Maven and Gradle. It also works with Java
versions 8 - 13.

>Note you can replace the `manifold-image` dependency with [`manifold-all`](https://github.com/manifold-systems/manifold/tree/master/manifold-all) as a quick way to gain access to all of
Manifold's features.

## Binaries

If you are *not* using Maven or Gradle, you can download the latest binaries [here](http://manifold.systems/docs.html#download).


## Gradle

Here is a sample `build.gradle` script. Change `targetCompatibility` and `sourceCompatibility` to your desired Java
version (8 - 13), the script takes care of the rest. 
```groovy
plugins {
    id 'java'
}

group 'systems.manifold'
version '1.0-SNAPSHOT'

targetCompatibility = 11
sourceCompatibility = 11

repositories {
    jcenter()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
}

dependencies {
    compile group: 'systems.manifold', name: 'manifold-image', version: '2019.1.32'
    testCompile group: 'junit', name: 'junit', version: '4.12'

    // Add manifold to -processorpath for javac
    annotationProcessor group: 'systems.manifold', name: 'manifold-image', version: '2019.1.32'
}

if (JavaVersion.current() != JavaVersion.VERSION_1_8 &&
    sourceSets.main.allJava.files.any {it.name == "module-info.java"}) {
    tasks.withType(JavaCompile) {
        // if you DO define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold', '--module-path', it.classpath.asPath]
    }
} else {
    tasks.withType(JavaCompile) {
        // If you DO NOT define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold']
    }
}

tasks.compileJava {
    classpath += files(sourceSets.main.output.resourcesDir) //adds build/resources/main to javac's classpath
    dependsOn processResources
}
tasks.compileTestJava {
    classpath += files(sourceSets.test.output.resourcesDir) //adds build/resources/test to test javac's classpath
    dependsOn processTestResources
}
```
Use with accompanying `settings.gradle` file:
```groovy
rootProject.name = 'MyProject'
```

## Maven

### Java 8

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-image-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Image App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-image</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>8</source>
                    <target>8</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

### Java 9 or later
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-image-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Image App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-image</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                    <!-- Add the processor path for the plugin (required for Java 9+) -->
                    <annotationProcessorPaths>
                        <path>
                            <groupId>systems.manifold</groupId>
                            <artifactId>manifold-image</artifactId>
                            <version>${manifold.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

# License

## Open Source
Open source Manifold is free and licensed under the [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0) license.  

## Commercial
Commercial licenses for this work are available. These replace the above ASL 2.0 and offer 
limited warranties, support, maintenance, and commercial server integrations.

For more information, please visit: http://manifold.systems//licenses

Contact: admin@manifold.systems

# Versioning

For the versions available, see the [tags on this repository](https://github.com/manifold-systems/manifold/tags).

# Author

* [Scott McKinney](mailto:scott@manifold.systems)
# Manifold : Javascript

The JavaScript type manifold provides direct, type-safe access to JavaScript files
as if they were Java files.

Here we have JavaScript resource file, `abc/JsProgram.js`:
```javascript
var x = 1;

function nextNumber() {
  return x++;
}

function exampleFunction(x) {
  return x + " from Javascript";
}
```

The type manifold maps type information directly to Java's type system so that
this JavaScript program is accessible as a Java class:

```java
import abc.JsProgram;

...

  String hello = JsProgram.exampleFunction("Hello");
  System.out.println(hello); // prints 'Hello from JavaScript'
  
  double next = JsProgram.nextNumber();
  System.out.println(next); // prints '1'
  next = JsProgram.nextNumber();
  System.out.println(next); // prints '2'
```

In addition to JavaScript programs you can also access JavaScript _classes_ directly.

This JavaScript defines class `Person` from file `abc/Person.js':
```javascript
class Person {
  constructor(firstName, lastName) {
    this._f = firstName
    this._l = lastName
  }

  displayName() {
    return this._f + " " + this._l
  }

  get firstName() {
    return this._f
  }
  set firstName(s) {
    this._f = s
  }

  get lastName() {
    return this._l
  }
  set lastName(s) {
    this._l = s
  }
}
```

You can access this JavaScript class file directly as a Java class:
```java
import abc.Person;

Person person = new Person("Joe", "Bloe");
String first = person.getFirstName();
System.out.println(first);
```

You can also create simple, type-safe Javascript _templates_.  Javascript template files have a `.jst` extension
and work very similar to JSP syntax. To illustrate:

File `com/foo/MyTemplate.jst`:
```
<%@ params(names) %>
This template lists each name provided in the 'names' parameter
Names:
<%for (var i = 0; i < names.length; i++) { %>
-${names[i]}
<% } %>
The end
```
From Java we can use this template in a type-safe manner:
```java
import com.foo.MyTemplate;
...
String results = MyTemplate.renderToString(Arrays.asList("Orax", "Dynatron", "Lazerhawk", "FM-84"));
System.out.println(results);
``` 
This prints the following to the console:
```
This template lists each name provided in the 'names' parameter
Names:
-Orax
-Dynatron
-Lazerhawk
-FM-84
The end
```

For full-featured template engine functionality see project [ManTL](http://manifold.systems/manifold-templates.html).


# IDE Support 

Manifold is best experienced using [IntelliJ IDEA](https://www.jetbrains.com/idea/download).

## Install

Get the [Manifold plugin](https://plugins.jetbrains.com/plugin/10057-manifold) for IntelliJ IDEA directly from IntelliJ
via:

<kbd>Settings</kbd> ➜ <kbd>Plugins</kbd> ➜ <kbd>Marketplace</kbd> ➜ search: `Manifold`

<p><img src="http://manifold.systems/images/ManifoldPlugin.png" alt="echo method" width="60%" height="60%"/></p>

## Sample Project

Experiment with the [Manifold Sample Project](https://github.com/manifold-systems/manifold-sample-project) via:

<kbd>File</kbd> ➜ <kbd>New</kbd> ➜ <kbd>Project from Version Control</kbd> ➜ <kbd>Git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProjectMenu.png" alt="echo method" width="60%" height="60%"/></p>

Enter: <kbd>https://github.com/manifold-systems/manifold-sample-project.git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProject.png" alt="echo method" width="60%" height="60%"/></p>

Use the [plugin](https://plugins.jetbrains.com/plugin/10057-manifold) to really boost your productivity. Use code
completion to conveniently access javascript. Make changes to your Javascript files and use the changes immediately,
no compilation!  Find usages of any element in your Javascript files. Perform rename refactors to quickly and safely
make project-wide changes.

# Setup

## Building this project

The `manifold-js` project is defined with Maven.  To build it install Maven and run the following command.

```
mvn compile
```

## Using this project

The `manifold-js` dependency works with all build tooling, including Maven and Gradle. It also works with Java versions
8 - 13.

>Note you can replace the `manifold-js` dependency with [`manifold-all`](https://github.com/manifold-systems/manifold/tree/master/manifold-all) as a quick way to gain access to all of
Manifold's features.

## Binaries

If you are *not* using Maven or Gradle, you can download the latest binaries [here](http://manifold.systems/docs.html#download).


## Gradle

Here is a sample `build.gradle` script. Change `targetCompatibility` and `sourceCompatibility` to your desired Java
version (8 - 13), the script takes care of the rest. 
```groovy
plugins {
    id 'java'
}

group 'systems.manifold'
version '1.0-SNAPSHOT'

targetCompatibility = 11
sourceCompatibility = 11

repositories {
    jcenter()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
}

dependencies {
    compile group: 'systems.manifold', name: 'manifold-js', version: '2019.1.32'
    testCompile group: 'junit', name: 'junit', version: '4.12'

    // Add manifold to -processorpath for javac
    annotationProcessor group: 'systems.manifold', name: 'manifold-js', version: '2019.1.32'
}

if (JavaVersion.current() != JavaVersion.VERSION_1_8 &&
    sourceSets.main.allJava.files.any {it.name == "module-info.java"}) {
    tasks.withType(JavaCompile) {
        // if you DO define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold', '--module-path', it.classpath.asPath]
    }
} else {
    tasks.withType(JavaCompile) {
        // If you DO NOT define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold']
    }
}

tasks.compileJava {
    classpath += files(sourceSets.main.output.resourcesDir) //adds build/resources/main to javac's classpath
    dependsOn processResources
}
tasks.compileTestJava {
    classpath += files(sourceSets.test.output.resourcesDir) //adds build/resources/test to test javac's classpath
    dependsOn processTestResources
}
```
Use with accompanying `settings.gradle` file:
```groovy
rootProject.name = 'MyProject'
```

## Maven

### Java 8

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-js-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Javascript App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-js</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>8</source>
                    <target>8</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

### Java 9 or later
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-js-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Javascript App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-preprocessor</artifactId>
            <version>${manifold.js}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                    <!-- Add the processor path for the plugin (required for Java 9+) -->
                    <annotationProcessorPaths>
                        <path>
                            <groupId>systems.manifold</groupId>
                            <artifactId>manifold-js</artifactId>
                            <version>${manifold.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

# License

## Open Source
Open source Manifold is free and licensed under the [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0) license.  

## Commercial
Commercial licenses for this work are available. These replace the above ASL 2.0 and offer 
limited warranties, support, maintenance, and commercial server integrations.

For more information, please visit: http://manifold.systems//licenses

Contact: admin@manifold.systems

# Versioning

For the versions available, see the [tags on this repository](https://github.com/manifold-systems/manifold/tags).

# Author

* [Scott McKinney](mailto:scott@manifold.systems)
# Manifold : JSON and JSON Schema

[![json](http://manifold.systems/images/json_slide_1.png)](http://manifold.systems/images/json.mp4)

## Table of Contents
* [Overview](#overview)
* [Naming](#naming)
* [Fluent API](#fluent-api)
* [Creating & Building JSON](#creating--building-json)
* [Loading JSON](#loading-json)
* [Request REST API services](#request-rest-api-services)
* [Writing JSON](#writing-json)
* [Copying JSON](#copying-json)
* [Properties Marked `readOnly` or `writeOnly`](#properties-marked-readonly-or-writeonly)
* [Nullable Properties](#nullable-properties)
* ['additionalProperties' and 'patternProperties'](#additionalproperties-and-patternproperties)
* Types
  * [Nested Types](#nested-types)
  * [Format Types](#format-types)
  * [Composition Types with `allOf`](#composition-types-with-allof)
  * [Union Types with `oneOf`/`anyOf`](#union-types-with-oneofanyof)
  * [Interfaces are _Structural_](#interfaces-are-_structural_)
* [Extensions](#extensions)
* [JSON, XML, CSV, & YAML Utilities](#json-xml--yaml-utilities)
* [IDE Support](#ide-support)
* [Setup](#setup)
* [License](#license)
* [Versioning](#versioning)
* [Author](#author)

>#### *** JSON, XML, CSV, and YAML are Interchangeable ***
>It is important to note, although the JSON manifold targets JSON and JSON schema files, it equally targets XML and YAML. In fact the
>[XML manifold](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-xml) and
>[YAML manifold](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-yaml) are just
>thin layers on top of the JSON manifold -- the types the JSON manifold projects from JSON files are the same exact
>types the XML and YAML manifolds project. This means you can use JSON, XML, CSV, and YAML interchangeably. As covered in
>this document you use the same objects to create, build, modify, load, request, write, and copy all three formats.
>```java
>import com.example.MyJson; // types-safely use the JSON resource file: /com/example/MyJson.json
>
>MyJson myJson  = MyJson.fromSource();       // load the data in the file into an instance of MyJson
>String xml = myJson.write().toXml();        // write the JSON as formatted XML
>myJson = (MyJson) Xml.fromXml( xml, true ); // read the object back from XML!
>```
>Indeed, any mention of JSON and `.json` files in this document equally applies to XML and `.xml` files as well as YAML
>and `.yml`/`.yaml` files.

## Overview
The JSON type manifold provides comprehensive support for JSON resource files (extension `.json`).  You can define a 
JSON API with JSON resources consisting of either sample JSON or [JSON Schema](https://json-schema.org/) version 4 or 
later. Your JSON resource files serve as the **single source of truth** regarding JSON APIs.  You use JSON-expressed
types *directly* in your code without maintaining a separate set of classes or wedging a code generator into your build.

> Clone the [Manifold sample REST API project](https://github.com/manifold-systems/manifold-sample-rest-api) to quickly
begin experimenting with a JSON Schema REST API using Manifold.

Here is a simple `User` type defined in `resources/com/example/schemas/User.json` using JSON Schema:
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "http://example.com/schemas/User.json",
  "type": "object",
  "definitions": {
    "Gender": {
      "type": "string",
      "enum": ["male", "female"]
    }
  },
  "properties": {
    "name": {
      "type": "string",
      "description": "User's full name.",
      "maxLength": 80
    },
    "email": {
      "description": "User's email.",
      "type": "string",
      "format": "email"
    },
    "date_of_birth": {
      "type": "string",
      "description": "Date of uses birth in the one and only date standard: ISO 8601.",
      "format": "date"
    },
    "gender": {
      "$ref" : "#/definitions/Gender"
    }
  },
  "required": ["name", "email"]
}
```

## Naming

Most type manifolds, including the JSON, XML, CSV, & YAML manifolds, follow the Java naming convention where a type name is based on the
resource file name relative to its location in the resource path. Thus the JSON resource file `resources/com/example/schemas/User.json`
has the Java type `com.example.schemas.User`.

The name *should* also match the schema `$id`, if one is provided.  The `User` type declares `"$id": "http://example.com/schemas/User.json"`,
which corresponds with the name `com.example.schemas.User`.

## Fluent API

JSON types are defined as a set of fluent _interface_ APIs.  For example, the `User` JSON type is an interface and
provides type-safe methods to:
* **create** a `User`
* **build** a `User`
* **modify** properties of a `User`  
* **load** a `User` from a string, a file, or a URL using HTTP GET
* **request** Web service operations using HTTP GET, POST, PUT, PATCH, & DELETE
* **write** a `User` as formatted JSON, CSV, YAML, or XML
* **copy** a `User`
* **cast** to `User` from any structurally compatible type including `Map`s, all *without proxies*

## Creating & Building JSON
You create an instance of a JSON type using either the `create()` method or the `builder()` method.

The `create()` method defines parameters matching the `required` properties defined in the JSON Schema, if the type is
plain JSON or no `required` properties are specified, `create()` has no parameters.

The `User.create()` method declares two parameters matching the `required` properties:
```java
static User create(String name, String email) {...}
```
You can use this to create a new instance of the `User` type with `name` and `email` arguments and then modify it using
_setter_ methods to change optional properties:
```java
import com.example.schemas.User;
import com.example.schemas.User.Gender;
import java.time.LocalDate;
...
User user = User.create("Scott McKinney", "scott@manifold.systems");
user.setGender(Gender.male);
user.setDate_of_birth(LocalDate.of(1980, 7, 4));
```

Alternatively, you can use `builder()` to fluently build a new instance:
```java
User user = User.builder("Scott McKinney", "scott@manifold.systems")
  .withGender(Gender.male)
  .withDate_of_birth(LocalDate.of(1980, 7, 4))
  .build();
```

You can initialize several properties in a chain of `with` calls in the builder. This saves a bit of typing with
heavier APIs.  After it is fully configured call the `build()` method to construct the type.

> Note `with` methods also serve as a means to initialize values for `readOnly` properties.

## Loading JSON
In addition to creating an object from scratch with `create()` and `build()` you can also load an instance from 
a variety of existing sources using `load()`.

You can load a `User` instance from a JSON, XML, CSV, or YAML String:
```java
// From a YAML string
User user = User.load().fromYaml( 
  "name: Scott McKinney\n" + 
  "email: scott@manifold.systems\n" +
  "gender: male\n" +
  "date_of_birth: 1980-07-04"
 );
```

Load from a file:
```java
// From a JSON file
User user = User.load().fromJsonFile("/path/to/MyUser.json");

// From an XML file
User user = User.load().fromJsonFile("/path/to/MyUser.xml");
```

You can invoke a REST API to fetch a `User` using HTTP GET:
```java
// Uses HTTP GET to invoke the API
User user = User.load().fromJsonUrl("http://api.example.com/users/$userId");
```

## Request REST API services
Use the `request()` static method to conveniently navigate an HTTP REST API with GET, POST, PUT, PATCH, & DELETE:
```java
String id = "scott";
User user = User.request("http://api.example.com/users").getOne("/$id");
```
The `request()` methods provides support for all basic REST API client usage:
```java
Requester<User> req = User.request("http://api.example.com/users");

// Get all Users via HTTP GET
IJsonList<User> users = req.getMany();

// Add a User with HTTP POST
User user = User.builder("scott", "mypassword", "Scott")
  .withGender(male)
  .build();
req.postOne(user);

// Get a User with HTTP GET
String id = user.getId();
user = req.getOne("/$id");

// Update a User with HTTP PUT
user.setDob(LocalDate.of(1980, 7, 7));
req.putOne("/$id", user);

// Delete a User with HTTP DELETE
req.delete("/$id");
```

## Writing JSON
An instance of a JSON API object can be written as formatted text with `write()`:
* `toJson()` - produces a JSON formatted String
* `toYaml()` - produces a YAML formatted String
* `toXml()` - produces an XML formatted String
* `toCsv()` - produces a CSV formatted String

The following example produces a JSON formatted string:
```java
User user = User.builder("Scott McKinney", "scott@manifold.systems")
  .withGender(Gender.male)
  .withDate_of_birth(LocalDate.of(1980, 7, 4))
  .build();

String json = user.write().toJson();
System.out.println(json);
```
Output:
```json
{
  "name": "Scott McKinney",
  "email": "scott@manifold.systems",
  "gender": "male",
  "date_of_birth": "1980-07-04"
}
```

## Copying JSON
Use the `copy()` method to make a deep copy of any JSON API object:
```java
User user = User.create(...);
...
User copy = user.copy();
```
Alternatively, you can use the `copier()` static method for a richer set of features:
```java
User copy = User.copier(user).withName("Bob").copy();
```
`copier()` is a lot like `builder()` but lets you start with an already built object you can modify.  Also like
`builder()` it maintains the integrity of the schema's declared mutability -- you can't change
`readOnly` fields after the `copy()` method constructs the object.

## Properties Marked `readOnly` or `writeOnly` 
If a property is set to `readOnly` in a schema you can initialize it as a parameter in the `create()` and `builder()`
methods. A `readOnly` property does not have a corresponding setter method in the API, thus you can't modify it after a
type is initialized.

Conversely, a `writeOnly` property such as a password is only writable -- you cannot read such a property using a `get`
method.

## Nullable Properties
Manifold supports JSON Schema's many curious ways to say that a property can have a `null` value. These include:
* The type array:  `"type": ["", "null"]`
* The union type:  `"oneOf": [ ..., {"type": "null"}]`
* The enum type: `"enum": [..., null]`
* [OpenAPI 3.0](https://swagger.io/docs/specification/about/) _nullable_ attribute: `"nullable": true`

## **'additionalProperties'** and **'patternProperties'**
If a schema defines `additionalProperties` and/or `patternProperties`, the API provides a pair of methods to get/put 
arbitrary properties for a JSON instance, these are in addition to the getter/setter methods for named properties.
For instance, if a type `Thing` declares `additionalProperties` you can do this:
```java
Thing thing = Thing.create();
thing.put("MyProperty", "MyValue");
String value = (String)thing.get("MyProperty");
```  

For improved type-safety you can define structural interfaces for applicable properties:
```java
@Structural
public interface HasColor extends Bindings {
  default String getColor() {
    return (String)get("color");
  }  
  default void setColor(String value) {
    put("color", value);
  }  
} 
```
```java
HasColor hasColor = (HasColor)thing;
hasColor.setColor("blue");
String color = hasColor.getColor();
```

## Nested Types
Nested types defined within a JSON type, such as the `Gender` enum type in `User`, are available in the `User` API as
inner interfaces or enum types.  An nested interface type has all the same features as a top-level type including `create()`,
`builder()`, `load()`, etc.

## `format` Types
As you can see from the `User` example Manifold supports standard JSON Schema `format` types.  These include:

| Format           | JSON Type    | Java Type                                     |
|------------------|--------------|-----------------------------------------------|
| `"date-time"`    | `"string"`   | `java.time.LocalDateTime`                     |
| `"date"`         | `"string"`   | `java.time.LocalDate`                         |
| `"time"`         | `"string"`   | `java.time.LocalTime`                         |
| `"utc-millisec"` | `"integer"`  | `java.time.Instant`                           |
| `"int64"`        | `"integer"`  | `long` or `java.lang.Long` if nullable        |
| `"int32"`        | `"integer"`  | `int` or `java.lang.Integer` if nullable      |
| `"big-integer"`  | `"string"`   | `java.math.BigInteger`                        |
| `"big-decimal"`  | `"string"`   | `java.math.BigDecimal`                        |
| `"binary"`       | `"string"`   | `manifold.api.json.codegen.schema.OctetEncoding`      |
| `"byte"`         | `"string"`   | `manifold.api.json.codegen.schema.Base64Encoding`     | 

Other standard format types not listed here are supported but remain as `java.lang.String` or whichever `type` is 
specified along with the `format`.

Additionally, Manifold includes an API you can implement to provide your own custom formats.  Implement the 
`manifold.api.json.codegen.schema.IJsonFormatTypeResolver` interface as a 
[service provider](https://docs.oracle.com/javase/tutorial/ext/basics/spi.html#register-service-providers).


## Composition Types with `allOf`
JSON Schema's `allOf` construct is a way to reuse types by composing a type with references to other types. A Manifold 
JSON type involving `allOf` uses interface composition to define the type.  
```yaml
definitions:
  Address:
    type: object
    properties:
       ...
 
type: object
properties: 
  BillingAddress:
  - $ref: '#/definitions/Address'      
  ShippingAddress:
    allOf:
    - $ref: '#/definitions/Address'
    - properties:
        Kind:
          enum:
          - residential
          - commercial
      required:
      - Kind
```
The resulting type for `ShippingAddress` is a composition of types utilizing interface inheritance:
```java
@Structural
public interface ShippingAddress extends Address {
  Kind getKind();
  void setKind(Kind value);
}
``` 

Note all JSON API interfaces are [structural](#structural_interfaces), which means JSON API types are assignable if the
methods they define are compatible.  Although `allOf` types conveniently use interface inheritance for re-use, it is
not necessary for assignability.


## Union Types with `oneOf`/`anyOf`
Normally you define a property with a single type, like `string` or `Address`.  However, using `oneOf` or `anyOf` you
can declare a _set_ of possible types for a property, where a property value can be an instance of any one of the types.  
The language community commonly refers to this as a [union type](https://en.wikipedia.org/wiki/Union_type). 

Although Java does not directly support unions, they can be synthesized with method naming conventions.
```yaml
pet:
  oneOf:
  - $ref: '#/definitions/Cat'
  - $ref: '#/definitions/Dog'
```  
The enclosing interface's `pet` property declares methods to reflect the possible types:
```java
Cat getPetAsCat();
void setPetAsCat(Cat value);
Dog getPetAsDog();
void setPetAsDog(Dog value);
Object getPet();
void setPet(Object value);
``` 
There is still only one value backing the `pet` property.

## Interfaces are _Structural_
JSON API interfaces are *structural* interfaces. You can read all about what a structural interface is [here](#structural-interfaces).  In short
a structural interface doesn't have to be implemented directly in order to be used.  For instance, you can make a
type-safe call through a structural interface method on an object so long as the object has a method with the same name
and compatible parameters:
```java
User user = (User) new FooUser();
user.setName("Scott");

public class FooUser {
...
  public void setName(String name) {...}
...
}
```
Even though `FooUser` does not directly implement our `User` API, we can still use `FooUser` as our `User` if it
satisfies the parts of `User` we need to invoke, such as the `setName()` method.  This can be handy when integrating
with other systems that may have generated classes from the same schemas.

Another example illustrating the utility of structural interfaces involves a more dynamic application. Manifold
provides an extension class to enable dynamic structural typing on any class deriving from Java's `Map`. This means you
can do this:
```java
HashMap<String, Object> map = new HashMap<>();
User user = (User) map;
user.setFirstName("Bob");
String bob = (String) map.get("name");
```
So useful is this that it is the foundation of the JSON API implementation.  All JSON API objects are directly backed by
the JSON `Bindings` map that is parsed from the JSON payload. This is also part of what makes the Manifold JSON API
uniquely both type-safe and the *single source of truth*.  There is literally nothing between your JSON Schema API documents and
the code that consumes them.

Read more about [dynamic structural typing](#dynamic-typing-with-icallhandler).

## Extensions

You and the consumers of your JSON API can use Manifold extension classes to tailor it to specific lines of business.

You can add new methods:
```java
user.needsPasswordRemind();
...
```
```java
package extensions.com.example.schemas.User;
import com.example.schemas.User;
@Extension
public class MyUserExtension {
  public static boolean needsPasswordRemind(@This User thiz) {
    return passwordCheck(thiz, otherInfo);
  }

  public static void postAHyperMediaLink(...) {...}

  // more extension methods...
}
```

You can add new interfaces:
```java
package extensions.com.example.schemas.User;
import com.example.schemas.User;
@Extension
public class MyUserExtension extends EmailContact {
  // implement EmailContact methods User does not already satisfy here...
}
```
Now `User` also logically extends `EmailContact` and can be directly used as such in code.

> Note extensions do NOT physically alter the classes they extend, they only provide type information so the compiler can
resolve method calls and perform static type analysis.

You can even write your own type manifolds to dynamically generate extension classes and have your code automatically
resolve against the extensions. This can be useful to seamlessly add hypermedia linkage to your JSON API.  See
[Generating Extension Classes](#generating-extension-classes) for more info.


## JSON, XML, CSV, & YAML Utilities
In addition to the JSON type manifold other forms of JSON, XML, CSV, and YAML support include:
* Extension methods on `URL` and `Bindings` e.g.,
```json
// Easily convert JSON for use as a HTTP query
myUrl.append(query.getBindings().makeArguments());
```
* The `Json`, `Xml`, `Yaml` and `JsonUtil` classes
* The `OctetEncoding` and `Base64Encoding` classes facilitate sending/receiving binary information
* Structural interfaces on `Bindings` -- you can define your own structural interfaces for improved type-safety on
bindings (or maps)


# IDE Support 

Manifold is best experienced using [IntelliJ IDEA](https://www.jetbrains.com/idea/download).

## Install

Get the [Manifold plugin](https://plugins.jetbrains.com/plugin/10057-manifold) for IntelliJ IDEA directly from IntelliJ
via:

<kbd>Settings</kbd> ➜ <kbd>Plugins</kbd> ➜ <kbd>Marketplace</kbd> ➜ search: `Manifold`

<p><img src="http://manifold.systems/images/ManifoldPlugin.png" alt="echo method" width="60%" height="60%"/></p>

## Sample Project

Experiment with the [Manifold Sample REST API Project](https://github.com/manifold-systems/manifold-sample-rest-api)
via:

<kbd>File</kbd> ➜ <kbd>New</kbd> ➜ <kbd>Project from Version Control</kbd> ➜ <kbd>Git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProjectMenu.png" alt="echo method" width="60%" height="60%"/></p>

Enter: <kbd>https://github.com/manifold-systems/manifold-sample-rest-api.git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProject_json.png" alt="echo method" width="60%" height="60%"/></p>

Use the [plugin](https://plugins.jetbrains.com/plugin/10057-manifold) to really boost your productivity. Make changes to
your JSON, XML, CSV, and YAML files and use the changes immediately in your code, no compilation step.  You can use features such
as Find Usages, Refactor/Rename, and Navigation directly between elements in JSON, XML, CSV, and YAML resources files and Java
files. Additionally you can make and test changes in a live application or service using IntelliJ's Hotswap debugger.

# Setup

## Building this project

The `manifold-json` project is defined with Maven.  To build it install Maven and a Java 8 JDK and run the following
command.
```
mvn compile
```

## Using this project

The `manifold-json` dependency works with all build tooling, including Maven and Gradle. It fully supports Java versions
8 - 13.

>Note you can replace the `manifold-json` dependency with [`manifold-all`](https://github.com/manifold-systems/manifold/tree/master/manifold-all) as a quick way to gain access to all of
Manifold's features.  But `manifold-json` already brings in a lot of Manifold including
[Extension Methods](http://manifold.systems/docs.html#extension-classes),
[String Templates](http://manifold.systems/docs.html#templating), and more.

## Binaries

If you are *not* using Maven or Gradle, you can download the latest binaries [here](http://manifold.systems/docs.html#download).


## Gradle

Here is a sample `build.gradle` script. Change `targetCompatibility` and `sourceCompatibility` to your desired Java
version (8 - 13), the script takes care of the rest. 
```groovy
plugins {
    id 'java'
}

group 'systems.manifold'
version '1.0-SNAPSHOT'

targetCompatibility = 11
sourceCompatibility = 11

repositories {
    jcenter()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
}

dependencies {
    compile group: 'systems.manifold', name: 'manifold-json', version: '2019.1.32'
    testCompile group: 'junit', name: 'junit', version: '4.12'

    // Add manifold to -processorpath for javac
    annotationProcessor group: 'systems.manifold', name: 'manifold-json', version: '2019.1.32'
}

if (JavaVersion.current() != JavaVersion.VERSION_1_8 &&
    sourceSets.main.allJava.files.any {it.name == "module-info.java"}) {
    tasks.withType(JavaCompile) {
        // if you DO define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold', '--module-path', it.classpath.asPath]
    }
} else {
    tasks.withType(JavaCompile) {
        // If you DO NOT define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold']
    }
}

tasks.compileJava {
    classpath += files(sourceSets.main.output.resourcesDir) //adds build/resources/main to javac's classpath
    dependsOn processResources
}
tasks.compileTestJava {
    classpath += files(sourceSets.test.output.resourcesDir) //adds build/resources/test to test javac's classpath
    dependsOn processTestResources
}
```
Use with accompanying `settings.gradle` file:
```groovy
rootProject.name = 'MyProject'
```

## Maven

### Java 8
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-json-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Json App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-json</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>8</source>
                    <target>8</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

### Java 9 or later
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-json-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Json App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-json</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                    <!-- Add the processor path for the plugin (required for Java 9+) -->
                    <annotationProcessorPaths>
                        <path>
                            <groupId>systems.manifold</groupId>
                            <artifactId>manifold-json</artifactId>
                            <version>${manifold.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

# License

## Open Source
Open source Manifold is free and licensed under the [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0) license.  

## Commercial
Commercial licenses for this work are available. These replace the above ASL 2.0 and offer 
limited warranties, support, maintenance, and commercial server integrations.

For more information, please visit: http://manifold.systems//licenses

Contact: admin@manifold.systems

# Versioning

For the versions available, see the [tags on this repository](https://github.com/manifold-systems/manifold/tags).

# Author

* [Scott McKinney](mailto:scott@manifold.systems)
# Java Preprocessor

## Table of Contents
* [Overview](#overview)
* [Directives](#directives)
* [Symbols](#directives)
* [IDE Support](#ide-support)
* [Setup](#setup)
* [License](#license)
* [Versioning](#versioning)
* [Author](#author)

## Overview

The Java Preprocessor is designed exclusively for *conditional compilation* of Java source code. It is directly
integrated into the Java compiler via the Javac _Plugin_ API. Unlike conventional preprocessors it does *not* incur
separate build steps or additional file I/O, instead it directly contributes to the compilation pipeline.

<p><img src="http://manifold.systems/images/compilerflow.png" alt="javac" width="60%" height="60%"/></p>

The preprocessor offers a simple and convenient way to support multiple build targets with a single codebase.  It
provides advanced features such as tiered symbol definition via `build.properties` files, `-Akey[=value]` compiler
arguments, and environment settings symbols such as `JAVA_9_OR_LATER` and `JPMS_NAMED`.  The preprocessor is also fully
integrated into IntelliJ IDEA using the [Manifold](https://plugins.jetbrains.com/plugin/10057-manifold) plugin:  

[![preprocessor](http://manifold.systems/images/preprocessor_slide_1_play.png)](http://manifold.systems/images/preprocessor.mp4)

## Directives

The Manifold preprocessor uses familiar directives to conditionally filter source code before it is parsed.  The
preprocessor supports the following directives:

* [`#define`](#define)
* [`#undef`](#undef)
* [`#if`](#if)
* [`#elif`](#elif)
* [`#else`](#else)
* [`#endif`](#endif)
* [`#error`](#error) 
* [`#warning`](#warning)

>Note the nomenclature is borrowed from the C-family of preprocessors for the sake of familiarity.
 
### `#define`
Use `#define` to define a symbol.  When a symbol evaluates it is either `true` or `false`, it is `true` if and only if
it is defined.  You use symbols in expressions as conditions for compilation with `#if` and `#elif` directives. 
 
The preprocessor's symbols are not accessible to Java code, likewise variables in Java code are not accessible to the
preprocessor. This means symbols specified with `#define` never conflict with fields or variables of the same name.

The effects of `#define` are limited to the file scope, as such symbols defined in one file are not accessible to others.

`#define` directives can appear anywhere in a file following the `package` statement.

```java
package com.example;

#define EXPERIMENTAL

import java.math.BigDecimal;
#if EXPERIMENTAL
import com.example.features.NewFeature;
#endif

public class MyClass #if EXPERIMENTAL implements NewFeature #endif {
  ...
#if EXPERIMENTAL
  @Override
  public void newFeatureMethod() {
    ...
  }
#endif
}
``` 
  
>Note additional symbols are available to the preprocessor to access JVM and compiler settings as well as custom
build properties. These are covered below in the [Symbols](#symbols) section.

### `#undef`

Use `#undef` to *undefine* a symbol so that when evaluated, such as in an `#if` expression, its value is `false`.

A symbol can be defined either with the `#define` directive or other means including `-Akey[=value]` compiler arguments,
`build.properties` files, and environment settings such as the Java source mode (see [Symbols](#symbols)).
Regardless of a symbol's origin or scope, the `#undef` can be used to undefine it, however its effects are limited to
the scope of the containing file.

```csharp
package com.example;
  
#define FOO
#undef FOO
 
public class MyClass {  
  public static void main(Stirng[] args) {  
#if FOO  
    System.out.println("FOO is defined");
#else
    System.out.println("FOO is not defined");  
#endif  
  }  
} 
```

### `#if`

Code between `#if` and `#endif` directives is included for compilation based on the *expression* used with `#if` -- if
the expression is `true` the code compiles. The expression always evaluates as either `true` or `false`.  If the
expression is a symbol, such as one defined with `#define`, the symbol evaluates to `true` if the symbol is accessible
and has not been undefined with `#undef`.

This example uses `#if` to conditionally compile code based on whether `JAVA_8` is defined: 

```csharp
#if JAVA_8
  out.println("Compiled with Java source version 8");
#endif
``` 

The full structure of an `#if` directive looks like this:
```csharp
#if <expression>
<code>
#elif <expression>
<code>
#else
<code>
#endif
```
Details concerning [`#elif`](#elif), [`#else`](#else), and [`#endif`](#endif) directives are covered in separate sections below.
 
You can use more than symbols with `#if`. Condition expressions can have operators `&&` (and), `||` (or), and `!` (not)
to evaluate whether multiple symbols have been defined. You can also group symbols and operators with parentheses.

Expressions can also test for equality with `==` and `!=`. Two expressions are equal if:
1. They are both undefined *or*
2. They are both defined *and* their *string values* are the same

The string value of a symbol defined with `#define` is the empty string `""`. Symbols defined with `build.properties`
files or `-Akey[=value]` command line arguments may have values assigned to them explicitly.

>Note it is impossible for a symbol to have a `null` value. When referenced in an equality expression, if a symbol
is not assigned a value, its value is the empty string `""`.

### `#elif`

Use `#elif` to divide an `#if` directive into multiple conditions. The first `true` condition in the series of `#if`/`#elif`
directives determines which of the directives executes:

```csharp
public class MyClass {}
  @Override 
#if JAVA_8
  public void myJava8Method() {}
#elif JAVA_9
  public void myJava9Method() {}
#elif JAVA_10
  public void myJava10Method() {}
#else
  public void myJava11Method() {}
#endif  
``` 

Here if compiling with Java 10 source compatibility mode, only `myJava10Method()` will be compiled.
  
Note `#elif` is a more convenient and easier to read alternative to writing nested `#if` directives in `#else`:
```csharp
#if FOO
  out.println("FOO");
#else
  #if BAR
  out.println("BAR");  
  #endif
#endif
```
It's easier on the eye to use `#elif`:
```csharp
#if FOO
  out.println("FOO");
#elif BAR
  out.println("BAR");  
#endif
```
  
### `#else`

If none of the conditions are `true` for `#if` and `#elif` directives, the code between `#else` and `#endif` is
compiled:

```csharp
#if DEV
  out.println("DEV mode");
#else
  out.println("Customer mode");
#endif  
``` 

### `#endif`

The `#endif` directive marks the end of the series of directives beginning with `#if`.  See the [`#if`](#if) directive
for more details and examples.
   
>Note unlike conventional preprocessors, you can place more than one directive on the same line.  Here the `#if` and `#endif`
>directives share the same line to conditionally implement an interface:
>```csharp
>public class MyClass #if(JAVA_8) implements MyInterface #endif {
>  ...
>}
>```
   
### `#error`

Use the `#error` directive to generate a compiler error from a specific location in your code:

```csharp
#if MODE_A
  out.println("MODE A");
#elif MODE_B
  out.println("MODE B");
#elif MODE_C
  out.println("MODE C");
#else
  #error "Expecting a MODE to be defined"
#endif
```

You can also generate a compiler warning with the [`#warning`](#warning) directive.
 
### `#warning`

Use the `#warning` directive to generate a compiler warning from a specific location in your code:

```csharp
#if MODE_A
  out.println("MODE A");
#elif MODE_B
  out.println("MODE B");
#else
  #warning "No MODE defined, defaulting to MODE_C"
#endif
```

You can also generate a compiler error with the [`#error`](#error) directive.


## Symbols
Similar to a variable in Java, a preprocessor symbol has a name and an optional value. There are four ways a symbol can
be defined:
1. Locally in the source file via `#define`
2. Using a `build.properties` file in the directory ancestry beginning with the root source directory
3. Using the `-Akey[=value]` option on the javac command line
4. From compiler and JVM environment settings such as Java source version, JPMS mode, operating system, etc.    

Symbol scoping rules model a hierarchy of maps, where symbols are accessed in leaf-first order where the leaf
symbols are controlled by the `#define` and `#undef` directives in the compiling source file.  Parent symbols
correspond with 2 - 4 above.

Note the effects of `#define` and `#undef` are limited to the file scope. This means `#define` symbols are not
available to other files.  Similarly, parent symbols masked with `#undef` are unaffected in other files.

>Note Manifold's preprocessor is designed exclusively for conditional compilation, you can't use `#define` for
constant values or macro substitution as you can with a C/C++ preprocessor.


### `build.properties` files

You can provide global symbols using `build.properties` files placed in the ancestry of directories beginning with a
source root directory.  Although a symbol defined as a property can have a string value, sometimes it is preferable to
design property names to have the value encoded in the name.

Instead of this:

```properties
customer.type = ABC
customer.level = Ultimate
```

Do this:

```properties
CUSTOMER_TYPE_ABC =
CUSTUMER_LEVEL_ULTIMATE =
```

### Symbols as compiler arguments

Similar to `build.properties` you can define symbols on the javac command line via the `-Akey[=value]` option.  For
example:
```
javac -Acustomer.level=Ultimate ...
```
or
```
javac -ACUSTOMER_LEVEL_ULTIMATE ...
```

### Environment settings symbols

You get some symbols for free.  These symbols come from compiler, JVM, and IDE settings.  For instance, the Java source
compatibility mode provided on the command line via `-source` or inherited from IDE settings translates to symbols
having the following format:
```java
JAVA_N
JAVA_N_OR_LATER
```
Where `N` is the source version obtained from the environment.
  
Symbols for the JPMS mode are defined as:
```java
JPMS_NONE     // If compiling with Java 8, or Java 8 source compatibility
JPMS_UNNAMED  // If compiling with Java 9 or later and no module-info.java file is defined
JPMS_NAMED    // If compiling with Java 9 or later and a module-info.java file is defined
```  

Symbols for the operating system on which javac is running:
```java
OS_FREE_BSD
OS_LINUX
OS_MAC
OS_SOLARIS
OS_UNIX // Same as !OS_WINDOWS
OS_WINDOWS
```

The O/S architecture:
```java
ARCH_32
ARCH_64
``` 

# IDE Support 

Manifold is best experienced using [IntelliJ IDEA](https://www.jetbrains.com/idea/download).

## Install

Get the [Manifold plugin](https://plugins.jetbrains.com/plugin/10057-manifold) for IntelliJ IDEA directly from IntelliJ
via:

<kbd>Settings</kbd> ➜ <kbd>Plugins</kbd> ➜ <kbd>Marketplace</kbd> ➜ search: `Manifold`

<p><img src="http://manifold.systems/images/ManifoldPlugin.png" alt="echo method" width="60%" height="60%"/></p>

## Sample Project

Experiment with the [Manifold Sample Project](https://github.com/manifold-systems/manifold-sample-project) via:

<kbd>File</kbd> ➜ <kbd>New</kbd> ➜ <kbd>Project from Version Control</kbd> ➜ <kbd>Git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProjectMenu.png" alt="echo method" width="60%" height="60%"/></p>

Enter: <kbd>https://github.com/manifold-systems/manifold-sample-project.git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProject.png" alt="echo method" width="60%" height="60%"/></p>

Use the [plugin](https://plugins.jetbrains.com/plugin/10057-manifold) to really boost your productivity. The plugin
fully supports the Manifold Preprocessor. It provides an interactive mode in which you can see the effects of the
directives and symbols you define and use in your code. 

# Setup

## Building this project

The `manifold-preprocessor` project is defined with Maven.  To build it install Maven and run the following command.

```
mvn compile
```

## Using this project

The `manifold-preprocessor` dependency works with all build tooling, including Maven and Gradle. It also works with Java versions
8 - 13.

>Note you can replace the `manifold-preprocessor` dependency with [`manifold-all`](https://github.com/manifold-systems/manifold/tree/master/manifold-all) as a quick way to gain access to all of
Manifold's features.

## Binaries

If you are *not* using Maven or Gradle, you can download the latest binaries [here](http://manifold.systems/docs.html#download).


## Gradle

Here is a sample `build.gradle` script using `manifold-preprocessor`. Change `targetCompatibility` and
`sourceCompatibility` compatibility to your desired Java version (8 - 13), the script takes care of the rest. 
```groovy
plugins {
    id 'java'
}

group 'systems.manifold'
version '1.0-SNAPSHOT'

targetCompatibility = 11
sourceCompatibility = 11

repositories {
    jcenter()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
}

dependencies {
    compile group: 'systems.manifold', name: 'manifold-preprocessor', version: '2019.1.32'
    testCompile group: 'junit', name: 'junit', version: '4.12'

    // Add manifold to -processorpath for javac
    annotationProcessor group: 'systems.manifold', name: 'manifold-preprocessor', version: '2019.1.32'
}

if (JavaVersion.current() != JavaVersion.VERSION_1_8 &&
    sourceSets.main.allJava.files.any {it.name == "module-info.java"}) {
    tasks.withType(JavaCompile) {
        // if you DO define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold', '--module-path', it.classpath.asPath]
    }
} else {
    tasks.withType(JavaCompile) {
        // If you DO NOT define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold']
    }
}

tasks.compileJava {
    classpath += files(sourceSets.main.output.resourcesDir) //adds build/resources/main to javac's classpath
    dependsOn processResources
}
tasks.compileTestJava {
    classpath += files(sourceSets.test.output.resourcesDir) //adds build/resources/test to test javac's classpath
    dependsOn processTestResources
}
```
Use with accompanying `settings.gradle` file:
```groovy
rootProject.name = 'MyPreprocessorProject'
```

## Maven

### Java 8

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-preprocessor-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Preprocessor App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-preprocessor</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>8</source>
                    <target>8</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

### Java 9 or later
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-preprocessor-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Preprocessor App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-preprocessor</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin -->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                    <!-- Add the processor path for the plugin (required for Java 9+) -->
                    <annotationProcessorPaths>
                        <path>
                            <groupId>systems.manifold</groupId>
                            <artifactId>manifold-preprocessor</artifactId>
                            <version>${manifold.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

# License

## Open Source
Open source Manifold is free and licensed under the [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0) license.  

## Commercial
Commercial licenses for this work are available. These replace the above ASL 2.0 and offer 
limited warranties, support, maintenance, and commercial server integrations.

For more information, please visit: http://manifold.systems//licenses

Contact: admin@manifold.systems

# Versioning

For the versions available, see the [tags on this repository](https://github.com/manifold-systems/manifold/tags).

# Author

* [Scott McKinney](mailto:scott@manifold.systems)# Manifold : Properties

Many Java applications incorporate [properties resource files](https://docs.oracle.com/javase/7/docs/api/java/util/Properties.html)
(*.properties files) as a means of separating configurable text from code:

`resources/abc/MyProperties.properties`:
```properties
my.chocolate = Chocolate
my.chocolate.dark = Dark Chocolate
my.chocolate.milk = Milk Chocolate
```

Unfortunately access to these files requires boilerplate library code and the use
of hard-coded strings:
```java
Properties myProperties = new Properties();
myProperties.load(getClass().getResourceAsStream("/abc/MyProperties.properties"));

println(myProperties.getProperty("my.chocolate.dark"));
```

With the Properties type manifold we can access properties directly using simple, type-safe code:
```java
println(abc.MyProperties.my.chocolate.dark);
```

Behind the scenes the properties type manifold creates a Java class for the properties file, which reflects its
hierarchy of properties.  As you develop your application, changes you make in the file are immediately available in
your code with no user intervention in between -- no code gen files and no compiling between changes.

# IDE Support 

Manifold is best experienced using [IntelliJ IDEA](https://www.jetbrains.com/idea/download).

## Install

Get the [Manifold plugin](https://plugins.jetbrains.com/plugin/10057-manifold) for IntelliJ IDEA directly from IntelliJ
via:

<kbd>Settings</kbd> ➜ <kbd>Plugins</kbd> ➜ <kbd>Marketplace</kbd> ➜ search: `Manifold`

<p><img src="http://manifold.systems/images/ManifoldPlugin.png" alt="echo method" width="60%" height="60%"/></p>

## Sample Project

Experiment with the [Manifold Sample Project](https://github.com/manifold-systems/manifold-sample-project) via:

<kbd>File</kbd> ➜ <kbd>New</kbd> ➜ <kbd>Project from Version Control</kbd> ➜ <kbd>Git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProjectMenu.png" alt="echo method" width="60%" height="60%"/></p>

Enter: <kbd>https://github.com/manifold-systems/manifold-sample-project.git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProject.png" alt="echo method" width="60%" height="60%"/></p>

Use the [plugin](https://plugins.jetbrains.com/plugin/10057-manifold) to really boost your productivity. Use code
completion to conveniently access properties. Make changes to your Properties files and use the changes immediately, no
compilation!  Find usages of any element in your Properties files. Perform rename refactors to quickly and safely make
project-wide changes.

# Setup

## Building this project

The `manifold-properties` project is defined with Maven.  To build it install Maven and run the following command.

```
mvn compile
```

## Using this project

The `manifold-properties` dependency works with all build tooling, including Maven and Gradle. It also works with Java versions 8 - 13.

>Note you can replace the `manifold-properties` dependency with [`manifold-all`](https://github.com/manifold-systems/manifold/tree/master/manifold-all) as a quick way to gain access to all of
Manifold's features.

## Binaries

If you are *not* using Maven or Gradle, you can download the latest binaries [here](http://manifold.systems/docs.html#download).


## Gradle

Here is a sample `build.gradle` script. Change `targetCompatibility` and `sourceCompatibility` to your desired Java
version (8 - 13), the script takes care of the rest. 
```groovy
plugins {
    id 'java'
}

group 'systems.manifold'
version '1.0-SNAPSHOT'

targetCompatibility = 11
sourceCompatibility = 11

repositories {
    jcenter()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
}

dependencies {
    compile group: 'systems.manifold', name: 'manifold-properties', version: '2019.1.32'
    testCompile group: 'junit', name: 'junit', version: '4.12'

    // Add manifold to -processorpath for javac
    annotationProcessor group: 'systems.manifold', name: 'manifold-properties', version: '2019.1.32'
}

if (JavaVersion.current() != JavaVersion.VERSION_1_8 &&
    sourceSets.main.allJava.files.any {it.name == "module-info.java"}) {
    tasks.withType(JavaCompile) {
        // if you DO define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold', '--module-path', it.classpath.asPath]
    }
} else {
    tasks.withType(JavaCompile) {
        // If you DO NOT define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold']
    }
}

tasks.compileJava {
    classpath += files(sourceSets.main.output.resourcesDir) //adds build/resources/main to javac's classpath
    dependsOn processResources
}
tasks.compileTestJava {
    classpath += files(sourceSets.test.output.resourcesDir) //adds build/resources/test to test javac's classpath
    dependsOn processTestResources
}
```
Use with accompanying `settings.gradle` file:
```groovy
rootProject.name = 'MyProject'
```

## Maven

### Java 8

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-properties-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Properties App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-properties</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>8</source>
                    <target>8</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

### Java 9 or later
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-properties-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Properties App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-properties</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                    <!-- Add the processor path for the plugin (required for Java 9+) -->
                    <annotationProcessorPaths>
                        <path>
                            <groupId>systems.manifold</groupId>
                            <artifactId>manifold-properties</artifactId>
                            <version>${manifold.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

# License

## Open Source
Open source Manifold is free and licensed under the [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0) license.  

## Commercial
Commercial licenses for this work are available. These replace the above ASL 2.0 and offer 
limited warranties, support, maintenance, and commercial server integrations.

For more information, please visit: http://manifold.systems//licenses

Contact: admin@manifold.systems

# Versioning

For the versions available, see the [tags on this repository](https://github.com/manifold-systems/manifold/tags).

# Author

* [Scott McKinney](mailto:scott@manifold.systems)
# Manifold : Science

>Warning: **Experimental Feature**

Use the `manifold-science` framework to type-safely incorporate units & measures into your application. `Dimension`
type-safely models quantities. The framework provides comprehensive support for physical quantities such as `Length`,
`Mass`, and `Temperature`, as well as abstract quantities such as `StorageCapacity` and `Money`. Together with
[unit expressions](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#unit-expressions)
these classes provide an expressive units & measures foundation for a variety of applications.

Conveniently and type-safely express physical quantities of any type and unit of measure using *unit expressions*:

```java
import static manifold.science.util.UnitConstants.*; // kg, m, s, ft, etc.
...
Force f = 5 kg * 9.807 m/s/s; // result: 49.035 Newtons

Area space = (20ft + 2in) * (37ft + 7.5in); // result: 758 37/48 ft²
```
>Note dimensions work directly in arithmetic expressions by integrating with [operator overloading](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#operator-overloading)
and [unit expressions](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#unit-expressions),
both of these features are provided by the [`manifold-ext`](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#unit-expressions)
dependency.

 
## Table of Contents
* [Dimensions & Units API](#dimensions--units-api)
* [Library](#library)
* [Rational Numbers](#rational-numbers)
* [IDE Support](#ide-support)
* [Setup](#setup)
* [License](#license)
* [Versioning](#versioning)
* [Author](#author)


# Dimensions & Units API

Physical quantities have a fundamental *dimension* that is independent of units of measurement. The primary physical
dimensions are: length, mass, time, electrical charge, temperature and luminous intensity. Derived physical dimensions
include area, volume, velocity, force, energy, power and so on. The `manifold-science` framework provides an API to
model both primary and derived dimensions. Using this API the framework supplies a class library consisting of all of
the primary dimensions and many of the derived mechanical dimensions used with classical physics computations.

## API

The foundational API of the science framework consists of a small set of base classes and interfaces defined in the
`manifold.science.api` package.  

## Measures

`Dimension` interface is the root of the API. It models a dimension as having a unitless measure represented as a
`Rational` value as well as common [operator methods](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#operator-overloading)
for arithmetic operations. Since common dimensions define a unit of measure you will rarely implement `Dimension`
directly, instead you should extend `AbstractMeasure`.  This class adds a unit of measure to `Dimension` so you can
extend it to reuse unit functionality common to all physical quantities.

Instances of this class store the value (or magnitude) of the measure in terms of *base units*. Thus all arithmetic on
measures is performed using base units, which permits measures of differing input units to work in calculations. A
measure instance also maintains a *display unit*, which is used for display purposes and for working with other systems
requiring specific units.

For example, the `Length` dimension is defined like this:

```java
public final class Length extends AbstractMeasure<LengthUnit, Length> {
  public Length(Rational value, LengthUnit unit, LengthUnit displayUnit) {
    super(value, unit, displayUnit);
  }

  public Length(Rational value, LengthUnit unit) {
    this( value, unit, unit );
  }

  @Override
  public LengthUnit getBaseUnit() {
    return LengthUnit.BASE;
  }
...
}
```   

## Units

The `Unit` interface provides a base abstraction for unit types. Primary unit types `Length`, `Mass`, `Time`, `Charge`,
and `Temperature` implement `Unit` indirectly via `AbstractPrimaryUnit`. For instance, `LengthUnit`:

```java
public final class LengthUnit extends AbstractPrimaryUnit<Length, LengthUnit> {
  ...
  // SI Units
  public static final LengthUnit Femto = get(FEMTO, "Femtometer", "fm");
  public static final LengthUnit Pico = get(PICO, "Picometer", "pm");
  public static final LengthUnit Angstrom = get(1e-10r, "Angstrom", "Å");
  public static final LengthUnit Nano = get(NANO, "Nanometer", "nm");
  public static final LengthUnit Micro = get(MICRO, "Micrometre", "µm");
  public static final LengthUnit Milli = get(MILLI, "Millimeter", "mm");
  public static final LengthUnit Centi = get(CENTI, "Centimeter", "cm");
  public static final LengthUnit Deci = get(DECI, "Decimeter", "dm");
  public static final LengthUnit Meter = get(1r, "Meter", "m");
  public static final LengthUnit Kilometer = get(KILO, "Kilometer", "km");
  public static final LengthUnit Megameter = get(KILO.pow(2), "Megameter", "Mm");
  public static final LengthUnit Gigameter = get(KILO.pow(3), "Gigameter", "Gm");
  public static final LengthUnit Terameter = get(KILO.pow(4), "Terameter", "Tm");

  // US Standard
  public static final LengthUnit Caliber = get(0.000254r, "Caliber", "cal.");
  public static final LengthUnit Inch = get(0.0254r, "Inch", "in");
  public static final LengthUnit Foot = get(12 * 0.0254r, "Foot", "ft");
  public static final LengthUnit Yard = get(3 * 12 * 0.0254r, "Yard", "yd");
  public static final LengthUnit Rod = get(5.0292r, "Rod", "rd");
  public static final LengthUnit Chain = get(20.1168r, "Chain", "ch");
  public static final LengthUnit Furlong = get(201.168r, "Furlong", "fur");
  public static final LengthUnit Mile = get(1609.344r, "Mile", "mi");

  // Navigation
  public static final LengthUnit NauticalMile = get(1852r, "NauticalMile", "n.m.");

  // Very large
  public static final LengthUnit IAU = get(1.49597870e11r, "IAU-length", "au");
  public static final LengthUnit LightYear = get(9.460730473e+15r, "LightYear", "ly");

  // Very small
  public static final LengthUnit Planck = get(1.61605e-35r, "Planck-length", "ℓP");

  // Ancient
  public static final LengthUnit Cubit = get(0.4572r, "Cubit", "cbt");
  ...
}
```

Derived unit types consist of products or quotients of other unit types, so they extend `AbstractProductUnit` and
`AbstractQuotientUnit`.  For instance, `VelocityUnit` is the quotient of `LengthUnit` and `TimeUnit`, therefore it
derives from `AbstractQuotientUnit`:

```java
final public class VelocityUnit extends AbstractQuotientUnit<LengthUnit, TimeUnit, Velocity, VelocityUnit> {
  
  public static final VelocityUnit BASE = get( Meter, Second );

  ...
}
```  

## Operator Methods

You can use *all* Dimensions and Units directly in arithmetic, relational, and [unit (or "binding") expressions](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#unit-expressions).

The `Length` class, for example, implements method operators for all arithmetic, relational, and unit operators. This is
what allows you to write expressions like this:
```java
 *   // commonly used unit abbreviations e.g., m, ft, hr, mph, etc.
 *   import static manifold.science.util.UnitConstants.*;
 *   ...
 *   Length l = 5m; // 5 meters
 *   Length height = 5 ft + 9.5 in;
 *   Area room = 20 ft * 15.5 ft;
 *   Length distance = 80 mph * 2.3 hr;
``` 

See the documentation for [operator overloading](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#operator-overloading)
and [unit expressions](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#unit-expressions)
for detail about working with these features.
 
# Library

All of the primary dimensions and many of the derived dimensions are directly provided in the `manifold.science`
package. These include:

* `Acceleration` & `AccelerationUnit`
* `Angle` & `AngleUnit`
* `Area` & `AreaUnit`
* `Capacitance` & `CapacitanceUnit`
* `Charge` & `ChargeUnit`
* `Conductance` & `ConductanceUnit`
* `Current` & `CurrentUnit`
* `Density` & `DensityUnit`
* `Energy` & `EnergyUnit`
* `Force` & `ForceUnit`
* `Frequency` & `FrequencyUnit`
* `HeatCapacity` & `HeatCapacityUnit`
* `Inductance` & `InductanceUnit`
* `Length` & `LengthUnit`
* `MagneticFlux` & `MagneticFluxUnit`
* `MagneticFluxDensity` & `MagneticFluxDensityUnit`
* `Mass` & `MassUnit`
* `MetricScaleUnit`
* `Momentum` & `MomentumUnit`
* `Potential` & `PotentialUnit`
* `Power` & `PowerUnit`
* `Pressure` & `PressureUnit`
* `Resistance` & `ResistanceUnit`
* `SolidAngle` & `SolidAngleUnit`
* `StorageCapacity` & `StorageCapacityUnit`
* `Temperature` & `TemperatureUnit`
* `Time` & `TimeUnit`
* `Velocity` & `VelocityUnit`
* `Volume` & `VolumeUnit`

A small library of experimental vector classes are available in the `manifold.science.vector` package. These classes
support vector math and can be used directly within arithmetic expressions: 

* `Vector`
* `LengthVector`
* `TimeVector`
* `VelocityVector`
 
Utility classes providing useful constants are available in the `manifold.science.util` package, these include:

* `AngleConstants`
* `CoercionConstants`
* `DimensionlessConstants`
* `MetricFactorConstants`
* `Rational`
* `UnitConstants`

# Rational Numbers

The `Rational` class in the `manifold.science.util` package is similar to `BigDecimal` in that it can model rational
numbers with arbitrary precision. However `Rational` differs from `BigDecimal` in that it models a rational number as 
the quotient of two `BigIntenger` numbers.  This has the advantage of maintaining what is otherwise a repeating decimal
for values such as `1/3`. For instance, dividing a number by 3 then later multiplying that number by 3 should result
in the original number without rounding errors. While you can handle rounding with `BigDecimal`, using `Rational` can
be less error prone in some cases especially when working with equations. For this reason, all the Dimensions and Units
defined in the `manifold.science` package use `Rational`. [Feedback](https://github.com/manifold-systems/manifold/issues)
on this subject is welcome!

>Note as a performance measure this class does *not* maintain its value in reduced form. You must call `reduce()` to get
a separate instance for the reduced form. Call `isReduced()` to determine if an instance is in reduced form.

Use the `CoercionConstants` and `MetricScaleUnit` classes to conveniently use literal values as `Rational` numbers:
```java
  import static manifold.science.measures.MetricScaleUnit.M;
  import static manifold.science.util.CoercionConstants.r;
  ...
  Rational pi = 3.14159r;
  Rational yocto = "1/1000000000000000000000000"r;
  Rational fiveMillion = 5M;
```
`Rational` implements arithmetic, negation, and relational operators via [operator overloading](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#operator-overloading)
provided by the manifold-ext dependency. Operator overloading lets you use `Rataional` numbers directly in arithmetic,
negation, and relational expressions:
```java
Rational oneThird = 1r/3;
Rational circumference = 3.14159r * 5.27r;

if (oneThird > 1r/4) {...}
if (3.14159r == pi) {...}
``` 

Note `Dimension` implements the `==` and `!=` operators with `compareTo()`.  Read more about implementing relational
operators with [operator overloading](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-ext#operator-overloading).

# IDE Support 

Manifold is best experienced using [IntelliJ IDEA](https://www.jetbrains.com/idea/download).

## Install

Get the [Manifold plugin](https://plugins.jetbrains.com/plugin/10057-manifold) for IntelliJ IDEA directly from IntelliJ via:

<kbd>Settings</kbd> ➜ <kbd>Plugins</kbd> ➜ <kbd>Marketplace</kbd> ➜ search: `Manifold`

<p><img src="http://manifold.systems/images/ManifoldPlugin.png" alt="echo method" width="60%" height="60%"/></p>

## Sample Project

Experiment with the [Manifold Sample Project](https://github.com/manifold-systems/manifold-sample-project) via:

<kbd>File</kbd> ➜ <kbd>New</kbd> ➜ <kbd>Project from Version Control</kbd> ➜ <kbd>Git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProjectMenu.png" alt="echo method" width="60%" height="60%"/></p>

Enter: <kbd>https://github.com/manifold-systems/manifold-sample-project.git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProject.png" alt="echo method" width="60%" height="60%"/></p>

Use the [plugin](https://plugins.jetbrains.com/plugin/10057-manifold) to really boost your productivity. Use code
completion to conveniently access extension methods. Create extension methods using a convenient user interface. Make
changes to your extensions and use the changes immediately, no compilation! Use extensions provided by extension library
dependencies. Find usages of any extension. Use the `Range` API and unit expressions with complete type-safety.

# Setup

## Building this project

The `manifold-science` project is defined with Maven.  To build it install Maven and run the following command.

```
mvn compile
```

## Using this project

The `manifold-science` dependency works with all build tooling, including Maven and Gradle. It also works with Java versions
8 - 13.

>Note you can replace the `manifold-science` dependency with [`manifold-all`](https://github.com/manifold-systems/manifold/tree/master/manifold-all) as a quick way to gain access to all of
Manifold's features.

## Binaries

If you are *not* using Maven or Gradle, you can download the latest binaries [here](http://manifold.systems/docs.html#download).


## Gradle

Here is a sample `build.gradle` script. Change `targetCompatibility` and `sourceCompatibility` to your desired Java
version (8 - 13), the script takes care of the rest.  
```groovy
plugins {
    id 'java'
}

group 'systems.manifold'
version '1.0-SNAPSHOT'

targetCompatibility = 11
sourceCompatibility = 11

repositories {
    jcenter()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
}

dependencies {
    compile group: 'systems.manifold', name: 'manifold-science', version: '2019.1.32'
    testCompile group: 'junit', name: 'junit', version: '4.12'
                       
    if (JavaVersion.current() == JavaVersion.VERSION_1_8) {
        // tools.jar dependency (for Java 8 only), primarily to support structural typing without static proxies.
        // Thus if you are *not* using structural typing, you **don't** need tools.jar
        compile files( "${System.properties['java.home']}/../lib/tools.jar" )
    }
    // Add manifold to -processorpath for javac
    annotationProcessor group: 'systems.manifold', name: 'manifold-science', version: '2019.1.32'
}

if (JavaVersion.current() != JavaVersion.VERSION_1_8 &&
    sourceSets.main.allJava.files.any {it.name == "module-info.java"}) {
    tasks.withType(JavaCompile) {
        // if you DO define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold', '--module-path', it.classpath.asPath]
    }
} else {
    tasks.withType(JavaCompile) {
        // If you DO NOT define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold']
    }
}

tasks.compileJava {
    classpath += files(sourceSets.main.output.resourcesDir) //adds build/resources/main to javac's classpath
    dependsOn processResources
}
tasks.compileTestJava {
    classpath += files(sourceSets.test.output.resourcesDir) //adds build/resources/test to test javac's classpath
    dependsOn processTestResources
}
```
Use with accompanying `settings.gradle` file:
```groovy
rootProject.name = 'MyExtProject'
```

## Maven

### Java 8

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-ext-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Java App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-science</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>8</source>
                    <target>8</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
        </plugins>
    </build>

    <profiles>
        <!-- tools.jar dependency (for Java 8 only), primarily to support structural typing without static proxies.
             Thus if you are not using structural typing, you **don't** need tools.jar -->
        <profile>
            <id>internal.tools-jar</id>
            <activation>
                <file>
                    <exists>* ${java.home}/../lib/tools.jar</exists>
                </file>
            </activation>
            <dependencies>
                <dependency>
                    <groupId>com.sun</groupId>
                    <artifactId>tools</artifactId>
                    <version>1.8.0</version>
                    <scope>system</scope>
                    <systemPath>* ${java.home}/../lib/tools.jar</systemPath>
                </dependency>
              </dependencies>
        </profile>
    </profiles>
</project>
```

### Java 9 or later
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-ext-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Java App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-science</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                    <!-- Add the processor path for the plugin (required for Java 9+) -->
                    <annotationProcessorPaths>
                        <path>
                            <groupId>systems.manifold</groupId>
                            <artifactId>manifold-science</artifactId>
                            <version>${manifold.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

# License

## Open Source
Open source Manifold is free and licensed under the [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0) license.  

## Commercial
Commercial licenses for this work are available. These replace the above ASL 2.0 and offer 
limited warranties, support, maintenance, and commercial server integrations.

For more information, please visit: http://manifold.systems//licenses

Contact: admin@manifold.systems

# Versioning

For the versions available, see the [tags on this repository](https://github.com/manifold-systems/manifold/tags).

# Author

* [Scott McKinney](mailto:scott@manifold.systems)
# Manifold : String Templates (aka String Interpolation)

# Basics

A **String template** lets you use the `$` character to embed a Java expression directly into a String.  You can use `$`
to embed a simple variable:
```java
int hour = 8;
String time = "It is $hour o'clock";  // prints "It is 8 o'clock"
```
Or you can embed an expression of any complexity in curly braces:
```java
LocalTime localTime = LocalTime.now();
String ltime = "It is ${localTime.getHour()}:${localTime.getMinute()}"; // prints "It is 8:39"
```

# Bypassing String Template Processing

## `@DisableStringLiteralTemplates`

If you need to turn the feature off in specific areas in your code, you can use the `@DisableStringLiteralTemplates` 
annotation to control its use.  You can annotate a class, method, field, or local variable declaration to turn it on 
or off in that scope:
```java
@DisableStringLiteralTemplates // turns off String templating inside this class
public class MyClass
{
  void foo() {
    int hour = 8;
    String time = "It is $hour o'clock";  // prints "It is $hour o'clock"
  }
  
  @DisableStringLiteralTemplates(false) // turns on String templating inside this method
  void bar() {
    int hour = 8;
    String time = "It is $hour o'clock";  // prints "It is 8 o'clock"
  }
}
```

## `ITemplateProcessorGate` SPI

Additionally, you can exclude types from string template processing programmatically by implementing the
[`ITemplateProcessorGate`](https://github.com/manifold-systems/manifold/blob/master/manifold-deps-parent/manifold-strings/src/main/java/manifold/strings/api/ITemplateProcessorGate.java)
SPI. This option mostly applies to use-cases where you don't have access to source code you are building e.g., generated
source. Importantly, because the service provider is used at compile-time the provider class implementation must be
precompiled. Typically this means you define the class in a separate module and then make a dependency on that module.
To use the provider you register it in the `META-INF/services` directory in your `resources` path. See the
[string template tests](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-strings-test-excl)
for an example of this. See the [Java SPI documentation](https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html)
for more details regarding Java services.
 
## Escaping '$'

Finally, you can use the `$` literally and bypass string templates using standard Java character escape syntax:
```java
String verbatim = "It is \$hour o'clock"; // prints "It is $hour o'clock"
```
Or, if you prefer, you can use template syntax:
```java
String verbatim = "It is ${'$'}hour o'clock"; // prints "It is $hour o'clock"
``` 

# Template Files

Template **_files_** are much more powerful and are documented in project [ManTL](http://manifold.systems/manifold-templates.html).

> Clone the [Manifold sample Web App project](https://github.com/manifold-systems/manifold-sample-web-app) to quickly
begin experimenting with ManTL templates using the Manifold IntelliJ plugin.

# IDE Support 

Manifold is best experienced using [IntelliJ IDEA](https://www.jetbrains.com/idea/download).

## Install

Get the [Manifold plugin](https://plugins.jetbrains.com/plugin/10057-manifold) for IntelliJ IDEA directly from IntelliJ
via:

<kbd>Settings</kbd> ➜ <kbd>Plugins</kbd> ➜ <kbd>Marketplace</kbd> ➜ search: `Manifold`

<p><img src="http://manifold.systems/images/ManifoldPlugin.png" alt="echo method" width="60%" height="60%"/></p>

## Sample Project

Experiment with the [Manifold Sample Project](https://github.com/manifold-systems/manifold-sample-project) via:

<kbd>File</kbd> ➜ <kbd>New</kbd> ➜ <kbd>Project from Version Control</kbd> ➜ <kbd>Git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProjectMenu.png" alt="echo method" width="60%" height="60%"/></p>

Enter: <kbd>https://github.com/manifold-systems/manifold-sample-project.git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProject.png" alt="echo method" width="60%" height="60%"/></p>

Use the [plugin](https://plugins.jetbrains.com/plugin/10057-manifold) to really boost your productivity. Use code
completion to conveniently access symbols within a string literal. Jump to symbol references, perform rename refactors,
etc.

# Setup

## Building this project

The `manifold-strings` project is defined with Maven.  To build it install Maven and run the following command.

```
mvn compile
```

## Using this project

The `manifold-strings` dependency works with all build tooling, including Maven and Gradle. It also works with Java
versions 8 - 13.

>Note you can replace the `manifold-strings` dependency with [`manifold-all`](https://github.com/manifold-systems/manifold/tree/master/manifold-all) as a quick way to gain access to all of
Manifold's features.

## Binaries

If you are *not* using Maven or Gradle, you can download the latest binaries [here](http://manifold.systems/docs.html#download).


## Gradle

Here is a sample `build.gradle` script. Change `targetCompatibility` and `sourceCompatibility` to your desired Java
version (8 - 13), the script takes care of the rest. 
```groovy
plugins {
    id 'java'
}

group 'systems.manifold'
version '1.0-SNAPSHOT'

targetCompatibility = 11
sourceCompatibility = 11

repositories {
    jcenter()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
}

dependencies {
    compile group: 'systems.manifold', name: 'manifold-strings', version: '2019.1.32'
    testCompile group: 'junit', name: 'junit', version: '4.12'

    // Add manifold to -processorpath for javac
    annotationProcessor group: 'systems.manifold', name: 'manifold-strings', version: '2019.1.32'
}

if (JavaVersion.current() != JavaVersion.VERSION_1_8 &&
    sourceSets.main.allJava.files.any {it.name == "module-info.java"}) {
    tasks.withType(JavaCompile) {
        // if you DO define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold', '--module-path', it.classpath.asPath]
    }
} else {
    tasks.withType(JavaCompile) {
        // If you DO NOT define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold']
    }
}

tasks.compileJava {
    classpath += files(sourceSets.main.output.resourcesDir) //adds build/resources/main to javac's classpath
    dependsOn processResources
}
tasks.compileTestJava {
    classpath += files(sourceSets.test.output.resourcesDir) //adds build/resources/test to test javac's classpath
    dependsOn processTestResources
}
```
Use with accompanying `settings.gradle` file:
```groovy
rootProject.name = 'MyProject'
```

## Maven

### Java 8

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-strings-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My StringTemplates App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-strings</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>8</source>
                    <target>8</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

### Java 9 or later
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-strings-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My StringTemplates App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-strings</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin -->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                    <!-- Add the processor path for the plugin (required for Java 9+) -->
                    <annotationProcessorPaths>
                        <path>
                            <groupId>systems.manifold</groupId>
                            <artifactId>manifold-strings</artifactId>
                            <version>${manifold.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

# License

## Open Source
Open source Manifold is free and licensed under the [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0) license.  

## Commercial
Commercial licenses for this work are available. These replace the above ASL 2.0 and offer 
limited warranties, support, maintenance, and commercial server integrations.

For more information, please visit: http://manifold.systems//licenses

Contact: admin@manifold.systems

# Versioning

For the versions available, see the [tags on this repository](https://github.com/manifold-systems/manifold/tags).

# Author

* [Scott McKinney](mailto:scott@manifold.systems)


# ManTL (Manifold Template Language)

ManTL is a lightweight & *type-safe* template engine directly integrated with the Java compiler using [Manifold](http://manifold.systems/).
It supports the full Java language, type-safe arguments to templates, type-safe inclusion of other templates,
shared layouts for templates and custom base classes for application-specific logic, among other features.

Templates compile directly in your build as if Java source files _without a separate code generation build step_, therefore
your Java source code can reference and use your template files by name directly as _Java classes_. This level of 
integration and type-safety promotes higher levels of integrity and performance.  It also enables tooling like the [Manifold IntelliJ plugin](https://plugins.jetbrains.com/plugin/10057-manifold)
to provide deterministic code completion, navigation, usage searching, and refactoring.  Additionally the IntelliJ plugin
enables incremental compilation and hot swap debugging, allowing you to make template changes in a running application.

> Clone the [Manifold sample Web App project](https://github.com/manifold-systems/manifold-sample-web-app) to quickly
begin experimenting with ManTL templates using the Manifold IntelliJ plugin.

## Table of Contents
* [Usage](#usage)
* [Syntax](#syntax)
  * [Statements](#statements)
  * [Expressions](#expressions)
  * [Comments](#comments)
  * [Directives](#directives)
    * [`import`](#import)
    * [`extends`](#extends)
    * [`params`](#params)
    * [`include`](#include)
    * [`nest`](#nest)
    * [`section`](#section)
    * [`layout`](#layout)
    * [`content`](#layout)
* [Whitespace](#whitespace)
* [**Spark** Java Support](#spark-java-support)
  * [Hello World!](#hello-world)
  * [Tracing](#tracing)
  * [Template Base Class](#sparktemplate-base-class)
  * [Sample Application](#sample-application)
* [Provided Manifold Features](#provided-manifold-features)  
* [IDE Support](#ide-support)
* [Setup](#setup)
* [License](#license)
* [Versioning](#versioning)
* [Author](#authors)
  
<a id="installing" class="toc_anchor"></a>
 
# Usage

After incorporating the `manifold-templates` dependency in your build (see the [Building](#setup) section), you can
begin using ManTL by placing a new file with the `mtl` extension in your _resources_ directory (nb: not in your source
directory). The file can have any sort of string content, as well as [dynamic content](#syntax) and [directives](#directives)
that change how the template behaves.

> Note it is helpful, but not required, to include the file extension of the target content in the template file name.
For instance, a template that produces HTML as output is named *MyTemplate.html.mtl*

Consider the following template named `HelloWorld.txt.mtl`, located in the `resources/templates` directory:

```jsp
Hello World!
```
This template can be used directly from your Java code:

```java
import templates.HelloWorld;
public class Demo {
  public static void main(String[] args) {
    System.out.println(HelloWorld.render());
  }
}
```

This prints `Hello World` to your console.

If you want to add a parameter to the template, you can change the template to use the [`params`](#params) directive:

```jsp
<%@ params(String name) %>
Hello ${name}!
```

>Note you can make changes to your templates in IntelliJ while debugging your application. The Manifold plugin for 
IntelliJ hot swaps incremental compilation changes into your running application.

You can call this parameterized template with a `String` argument:

```java
import templates.HelloWorld;
public class Demo {
  public static void main(String[] args) {
    System.out.println(HelloWorld.render("ManTL"));
  }
}
```

Which prints `Hello ManTL!` to your console.

If you do not wish to materialize the template as a string, you can use the `renderInto()` method to render templates
into any `Appendable` object.  The `renderInto()` method is similar to `render()` but defines an additional `Appendable` 
parameter and returns `void`.

# Syntax

As with most template languages, a ManTL template consists of regular textual content interspersed with language 
constructs such as statements, expressions, comments, and directives.

## Statements

ManTL lets you control output of a template with Java language statements.  You embed statements or statement fragments 
in a template using this syntax:

```jsp
<% java-statement-parts %>
```
 
ManTL supports all Java language statements including variable and method declarations and control structures. For 
example, the `if` statement: 

```jsp
<% if(total >= 90) { %>
Grade: A
<% } %>
```
results in the following output if `total` is `90` or greater:
```text
Grade: A
```
otherwise, the statement has no effect on the output.

Notice the statement is fragmented between two sets of `<% %>` delimiters. You can leverage many of Java's
statements in this way to control the output, including `if-else`, `switch`, `for`, `while`, and  `do-while`.

This example demonstrates how a simple `for` statement can repeat a section of the template's content:
```jsp
<% for(String brand: Arrays.asList("Maserati", "Alfa Romeo", "Abarth") { %>
  Fiat brand: ${brand}
<% } %>
``` 
Renders as:
```text
  Fiat brand: Maserati
  Fiat brand: Alfa Romeo
  Fiat brand: Abarth
```

You can achieve the same result using a Java lambda expression:
```jsp
<% Arrays.asList("Maserati", "Alfa Romeo", "Abarth").forEach(brand -> { %>
  Fiat brand: ${brand}
<% }); %>
``` 

## Expressions

A ManTL expression contains a Java language expression, it is evaluated, coerced to a `String`, and
inserted where the expression appears in the ManTL file.

Use expressions with this syntax:
```jsp
<%= java-expression %>
```

Additionally, the following shorthand syntax is also valid:
```jsp
${ java-expression }
```

For example, this template:
```jsp
<html>
  <head><title>Expression Example</title></head>
  <body>
    <% int y = 10; %>
    <p style="font-size: ${y}"> The font size of this paragraph is ${y}. </p>
  </body>
</html>
```

generates the following HTML:

```html
<html>
  <head><title>Expression Example</title></head>
  <body>
    <p style="font-size: 10"> The font size of this paragraph is 10. </p>
  </body>
</html>
```

Note the statement declaring the `y` variable does not directly contribute to the resulting content. This is because a 
statement does not produce a value to display, instead a statement *controls* what displays.  By contrast an expression 
produces a value, thus it directly renders as part of the template's resulting content, hence both `${y}` expressions 
render `10` in the output. 

## Comments
Comments are blocks that delimit areas of the template the compiler ignores; they do not contribute to the template's 
output. Use them to make comments and to temporarily mask off sections of a template as you like. 

>Note template comments in no way affect the generated Java code, they are exclusively template file comments.

The syntax of a comment is as follows:
```jsp
<%-- This is a comment --%>
```

## Directives

Directives are commands you use to control the compilation and resulting structure of a template.

Directives have the following syntax:

```jsp
<%@ directive-name [options] %>
```

Here is a summary of all the ManTL directives. More detailed descriptions follow.

| Directive&nbsp;&nbsp;&nbsp;&nbsp;      | Syntax              | Description                                                                         |
|----------------|---------------------------------------------|-------------------------------------------------------------------------------------|
| import         | `<%@ import type-name %>`                   | Imports Java types for use in template directives, statements, and expressions      |
| extends        | `<%@ extends class-name %>`                 | Extends a base class having features suitable for the template file                 |
| params         | `<%@ params(parameter-list) %>`             | Parameters for the template, arguments passed via the `render(arg-list)`method      |
| include        | `<%@ include template-name[(parameter-list)] [if <condition>]%>` | Include a separate template in the template                                         |
| nest           | `<%@ nest template-name[(parameter-list)] [if <condition>]%>` | Nest a separate template in the template                                         |
| section        | `<%@ section section-name(parameter-list) %>` | Creates a sub-template within the template, that can be called from other templates |
| layout         | `<%@ layout template-name %>`               | Specifies the template in which the declaring template nests its content            |
| content        | `<%@ content %>`                            | Used in a `layout` template, denotes where the content of a nested template renders |


### `import`
Use the `import` directive as you would a Java `import` statement so you can use Java classes without
having to qualify them with package names.

The syntax of the `import` directive:
```jsp
<%@ import type-name %>
```

This example imports the `java.util.HashSet` class and uses it to declare the `myHashSet` variable:
```jsp
<html>
<%@ import java.util.HashSet %>
  <head><title>Import Example</title></head>
  <body>
    <% int y = 10;
       HashSet<Integer> myHashSet = new HashSet<>();
       myHashSet.add(y);
       myHashSet.add(15);
       for(Integer a: myHashSet) { %>
         <p> myHashSet contains ${a}. </p>
       <% } %>
  </body>
</html>
```
The above template produces the following HTML:
```html
<html>
  <head><title>Import Example</title></head>
  <body>
    <p> myHashSet contains 10. </p>
    <p> myHashSet contains 15. </p>
  </body>
</html>
```

>Note `import` directives must precede all other directives in your template.

### `extends`
Use the `extends` directive to make a template extend a custom base class, which you can use to provide
additional application specific functionality e.g., `Request` and `Response` objects in a web application.

A practical example of the `extends` directive:
```java
package demo;

import model.Contact;
import manifold.templates.runtime.BaseTemplate;

public class ExampleTemplate extends BaseTemplate {

  public String displayContact(Contact c) {
    if(c.hasName()) {
      return c.getName();
    } else {
      return c.getEmail();
    }
  }

}
```

This allows the developer to render a clean template:

```jsp
<%@ import model.Contact %>
<%@ extends demo.ExampleTemplate %>
<%@ params(Contact c)%>

<div>
  <div>
    Contact
  </div>
  <div>
    ${displayContact(c)}
  </div>
</div>
```

And easily callable:
```jsp
  get("/contact/:id", (req, resp) -> ShowContact.render(Contact.find(req.getParam("id")));
```

### `params`

Use the `params` directive to declare parameters in a template, similar to declaring parameters for a method.

The syntax of the `params` directive is as follows:
```jsp
<%@ params(parameter-list) %>
```

For example, you can create the template `NameDisplay.html.mtl` as the following:

```jsp
<%@ params(String name) %>
<p>Your name is: ${myName}</p>
```

You can then include it in another template as follows:

```jsp
<html>
  <head><title>PARAMS Example</title></head>
  <body>
    <%@ include NameDisplay("Bob") %>
    <%@ include NameDisplay("Scott") %>
  </body>
</html>
```

Then, the following HTML will be generated:
```html
<html>
  <head><title>PARAMS Example</title></head>
  <body>
    <p>Your name is: Bob </p>
    <p>Your name is: Scott </p>
  </body>
</html>
```

### `include`

The `include` directive allows users to insert other templates inside of the given template in a type
safe manner.

The syntax looks like this:
```jsp
<%@ include [template-name] %>
```

For example, consider the following template, `MyTemplate.html.mtl`:
```jsp
<% int fontSize = 0; %>
<html>
  <head><title>WHILE LOOP Example</title></head>
  <body>
    <% while (fontSize <= 3) { %>
      <font color = "green" size = "<%= fontSize %>">
        ManTL Tutorial
      </font><br />
      <%fontSize++;%>
    <%}%>
  </body>
</html>
```
We can then include it from another template as such:
```jsp
<%@ include MyTemplate %>
```

Both statements will result in the following HTML code:
```html
<html>
  <head><title>WHILE LOOP Example</title></head>
  <body>
    <font color = "green" size = "0">
      ManTL Tutorial
    </font><
    <font color = "green" size = "1">
      ManTL Tutorial
    </font><br />
    <font color = "green" size = "2">
      ManTL Tutorial
    </font><br />
    <font color = "green" size = "3">
      ManTL Tutorial
    </font><br />
  </body>
</html>
```

#### Conditional Include
ManTL supports shorthand for conditional inclusion of templates. The following syntax:
```jsp
<% if (condition) { %>
  <%@ include MyTemplate %>
<% } %>
```
Can be condensed to the following:
```jsp
<%@ include MyTemplate if(condition) %>
```

### `nest`

The `nest` directive behaves like `include` but retains and distributes the indentation whitespace immediately preceding
and following the `nest` directive. The indentation is applied to each line in the resulting nested template or section.
This behavior facilitates code generation and other use-cases where indentation is significant.  

For example, consider the following template `MyNesting.txt.mtl`:
```jsp
abc
  <%@ nest Inner%>
def
```  
which nests the template `Inner.txt.mtl`:
```jsp
some
code
```
Rendering `MyNesting.txt.mtl` results in:
```text
abc
  some
  code
def
```

#### Conditional Nest
ManTL supports shorthand for conditional nesting of templates. The following syntax:
```jsp
<% if (condition) { %>
  <%@ nest MyTemplate %>
<% } %>
```
Can be condensed to the following:
```jsp
<%@ nest MyTemplate if(condition) %>
```


### `section`

The `section` directive creates a subsection of the current template that can be added using the `include` and `nest`
directives in other templates.

The syntax of a `section` block:
```jsp
<%@ section section-name[(symbols-used-in-section)] %>
  SECTION CONTENT HERE
<%@ end section %>
```
Note the corresponding `<%@ end section %>` directive must be used to complete the section, otherwise
a compile error results.

For example, you can create the template `NestedImport.html.mtl` as the following:
```jsp
<%@ import java.util.* %>
<h1>Defines a section</h1>
<%@ section mySection %>
  <% HashSet<Integer> myHashSet = new HashSet<>();
  myHashSet.add(1);
  myHashSet.add(2);
  myHashSet.add(3);
  for(Integer a: myHashSet) { %>
  <h2 style="font-size: ${a}">Font size: ${a}</h2>
  <% } %>
<%@ end section %>
<p> The End </p>
```

The above code will generate the following HTML:
```html
  <h1>Defines a section</h1>
  <h2 style="font-size: 1">Font size: 1</h2>
  <h2 style="font-size: 2">Font size: 2</h2>
  <h2 style="font-size: 3">Font size: 3</h2>
  <p> The End </p>
```

Then, you can include `mySection` in a separate template:
```jsp
  <%@ include NestedImport.mySection %>
```

Which will result in the following HTML:
```html
  <h2 style="font-size: 1">Font size: 1</h2>
  <h2 style="font-size: 2">Font size: 2</h2>
  <h2 style="font-size: 3">Font size: 3</h2>
```


### `layout`

Layouts can be made and used with the `content` and `layout` directives respectively.

The `content` directive splits the current template into the header and footer of a layout.

The `layout` directive makes the header and footer of the layout frame the current template. 
The current template renders at the location of the `content` directive.

Both the `content` directive and `layout` directive are only valid in the outermost class
(not within sections) and can only appear once in a template.

The `params` directive is not yet supported for a template that contains the `content` directive.

The syntax of a layout template is as follows:
```jsp
HEADER CONTENT HERE
<%@ content %>
FOOTER CONTENT HERE
```

For example, you can create the template `LayoutEx.html.mtl`:
```jsp
</html>
  </body>
    <%@ content %>
  </body>
</html>
```

And use the layout in the following template:
```jsp
<%@ layout LayoutEx %>
<h1>This is a template that uses a layout.</h1>
<h2>The layout directive can appear anywhere in the template.</h2>
```


The above code will generate the following HTML:
```html
</html>
  </body>
    <h1>This is a template that uses a layout.</h1>
    <h2>The directive can appear anywhere in the template.</h2>
  </body>
</html>
```

#### Default Layouts

ManTL also supports the ability to set default layouts for templates in a given package via the
`ManifoldTemplates.java` configuration class:

```java
  // Sets default template for all templates
  ManifoldTemplates.setDefaultLayout(MyLayout.asLayout());
  
  // Sets default templates for all templates in "some.package"
  ManifoldTemplates.setDefaultLayout("some.package", AnotherLayout.asLayout());
```

By default, more specific layout declarations take precedence over less specific ones. For example, templates with a 
declared layout (using the `layout` directive) override the default layout.

Note the generated `asLayout()` static method on layout template classes.  This is useful when you override 
layouts, as specified below.

#### Layout Overrides

Sometimes you may want to manually override the layout of a given template in code,
or render a template with no layout.  ManTL classes include two fluent helper methods:
`withoutLayout()` and `withLayout(ILayout)` to assist in these cases:

```java
  // Renders the template with no layout, regardless of the configuration
  MyTemplate.withoutLayout().render(); 

  // Renders MyTemplate with the MyLayout layout, regardless of other configuration
  MyTemplate.withLayout(MyLayout.asLayout()).render(); 
```

# Whitespace

With the exception of the `nest` directive ManTL language constructs are silent with respect to the template's output.
That is to say, contiguous whitespace characters leading and trailing a language construct are omitted from the
template's generated content. Whitespace characters include spaces, tabs, and new lines.
```jsp
  <%@ import java.util.ArrayList %>
  <% if(true) { <%>
Hi
  <% } %>
```
The above template renders just one line of text consisting of the two characters in the word `Hi`; none of the 
whitespace immediately preceding or following the language constructs are included.

>Note the [`nest`](#nest) directive retains indentation to support use-cases such as *code generation* where whitespace
>is significant.   
  
# Spark Java Support

ManTL is designed with web frameworks like [Spark](http://sparkjava.com/) in mind.

## Hello World!
A simple "Hello World!" Spark application making use of ManTL:

```java
package app;

import manifold.templates.ManifoldTemplates;
import views.Index;
import views.layout.DefaultLayout;

import static spark.Spark.*;

public class WebApp { 
  public static void main(String[] args) {
    // Set up the default layout for the application
    ManifoldTemplates.setDefaultLayout(DefaultLayout.asLayout());

    // Enable tracing
    ManifoldTemplates.trace();

    // Render the Index template
    get("/", (req, resp) -> Index.render("Hello World!"));
  }
}
```

There are two templates in the `resources` directory: `views/Index.html.mtl` and `views/layouts/DefaultLayout.html.mtl`.
Here the code references the `Index` template directly as a Java class.  This is a powerful aspect of ManTL -- the 
compiler verifies your links are never broken and you can fully leverage the strength of IntelliJ for deterministic 
code completion, usage searching, refactoring, navigation, incremental compilation, and hot swap.  
  
> Note the code takes advantage of the _type-safe_ parameters available in ManTL and no Spark "TemplateEngine" is needed.

### SparkTemplate Base Class

Manifold provides base class `manifold.templates.sparkjava.SparkTemplate` for use with the `extends` directive
in your templates (or, more commonly, you extend this class and add more of your own application functionality).  This
class provides various convenience methods to get the HTTP `Request`, `Response`, etc. and it also automatically escapes
all string content for HTML, to help prevent malicious user input from causing a security issue in your application.

If you wish, you can output raw HTML in a template that extends `manifold.templates.sparkjava.SparkTemplate` using the
`raw()` function:

```jsp
  ${raw("<h1>Some Raw HTML</h1>")}
```

### Tracing

ManTL supports performance tracing with the following syntax:
```java
  ManifoldTemplates.trace();
```
After invoking the `trace()` method, every following `render()` call prints the following to the console:
```
  - Template template-name rendered in time-to-render ms
```

### Sample Application

A sample Spark application is available here:

[https://github.com/manifold-systems/manifold-sample-web-app](https://github.com/manifold-systems/manifold-sample-web-app)

# Provided Manifold Features

Because ManTL is a [Type Manifold](http://manifold.systems/docs.html#what-is-a-type-manifold) you can leverage other 
aspects of Manifold in your code, including the [Properties Manifold](http://manifold.systems/docs.html#properties-files), 
[Image Manifold](http://manifold.systems/docs.html#image-files), and others.  For instance, just as you have type-safe 
access to `mtl` template files, you also have type-safe access to Java `properties` files and image files such as `png`, 
`gif`, and `jpg`.

You can create and use [Manifold Extensions](http://manifold.systems/docs.html#extension-classes) too.  Instead of 
writing `Util` and `Helper` classes you can write your own extension methods for any Java class. Then use IntelliJ
code completion to improve your development experience with the extended classes.

Use other extension features such as  [@Jailbreak](http://manifold.systems/docs.html#type-safe-reflection) for type-safe 
reflection and avoid the dangers of writing and maintaining reflection code in your app.  Use [@Self](http://manifold.systems/docs.html#the-self-type)
to improve the usability of your *Builder* classes -- avoid complicated recursive generic types and the like.

Utilize [Structural Interfaces](http://manifold.systems/docs.html#structural-interfaces) in your code to avoid the penalties
and tedium involved with reflection and proxies.  Structural interfaces are also quite powerful when combined with other 
Manifold features such as Extension methods -- layer a unified API over different, but similar architectures.

To utilize even more of Manifold's features you can replace your `manifold-templates` dependency with `manifold-all`. 
This change enables type-safe access to other type manifolds such as JSON and YAML files, JSON Schema, CSV and more.  
You also gain access to Manifold's provided extension libraries for I/O, Web, and Collections.

```xml
    <dependency>
      <groupId>systems.manifold</groupId>
      <artifactId>manifold-all</artifactId>
      <!-- it is best to use the latest release -->
      <version>2019.1.32</version>
    </dependency>
```

# IDE Support 

Manifold is best experienced using [IntelliJ IDEA](https://www.jetbrains.com/idea/download).

## Install

Get the [Manifold plugin](https://plugins.jetbrains.com/plugin/10057-manifold) for IntelliJ IDEA directly from IntelliJ
via:

<kbd>Settings</kbd> ➜ <kbd>Plugins</kbd> ➜ <kbd>Marketplace</kbd> ➜ search: `Manifold`

<p><img src="http://manifold.systems/images/ManifoldPlugin.png" alt="echo method" width="60%" height="60%"/></p>

## Sample Project

Experiment with the [Manifold Sample Project](https://github.com/manifold-systems/manifold-sample-project) via:

<kbd>File</kbd> ➜ <kbd>New</kbd> ➜ <kbd>Project from Version Control</kbd> ➜ <kbd>Git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProjectMenu.png" alt="echo method" width="60%" height="60%"/></p>

Enter: <kbd>https://github.com/manifold-systems/manifold-sample-project.git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProject.png" alt="echo method" width="60%" height="60%"/></p>

Use the [plugin](https://plugins.jetbrains.com/plugin/10057-manifold) to really boost your productivity. Every bit of
ManTL is supported in the Manifold plugin. Use it to author professional quality templates with the full expressive
power of Java in IntelliJ.

# Setup

## Building this project

The `manifold-templates` project is defined with Maven.  To build it install Maven and run the following command.

```
mvn compile
```

## Using this project

The `manifold-templates` dependency works with all build tooling, including Maven and Gradle. It also works with Java
versions 8 - 13.

>Note you can replace the `manifold-templates` dependency with [`manifold-all`](https://github.com/manifold-systems/manifold/tree/master/manifold-all) as a quick way to gain access to all of
Manifold's features.

## Binaries

If you are *not* using Maven or Gradle, you can download the latest binaries [here](http://manifold.systems/docs.html#download).


## Gradle

Here is a sample `build.gradle` script. Change `targetCompatibility` and `sourceCompatibility` to your desired Java
version (8 - 13), the script takes care of the rest. 
```groovy
plugins {
    id 'java'
}

group 'systems.manifold'
version '1.0-SNAPSHOT'

targetCompatibility = 11
sourceCompatibility = 11

repositories {
    jcenter()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
}

dependencies {
    compile group: 'systems.manifold', name: 'manifold-templates', version: '2019.1.32'
    testCompile group: 'junit', name: 'junit', version: '4.12'

    // Add manifold to -processorpath for javac
    annotationProcessor group: 'systems.manifold', name: 'manifold-templates', version: '2019.1.32'
}

if (JavaVersion.current() != JavaVersion.VERSION_1_8 &&
    sourceSets.main.allJava.files.any {it.name == "module-info.java"}) {
    tasks.withType(JavaCompile) {
        // if you DO define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold', '--module-path', it.classpath.asPath]
    }
} else {
    tasks.withType(JavaCompile) {
        // If you DO NOT define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold']
    }
}

tasks.compileJava {
    classpath += files(sourceSets.main.output.resourcesDir) //adds build/resources/main to javac's classpath
    dependsOn processResources
}
tasks.compileTestJava {
    classpath += files(sourceSets.test.output.resourcesDir) //adds build/resources/test to test javac's classpath
    dependsOn processTestResources
}
```
Use with accompanying `settings.gradle` file:
```groovy
rootProject.name = 'MyProject'
```

## Maven

### Java 8

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-templates-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Templates App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-templates</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>8</source>
                    <target>8</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

### Java 9 or later
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-templates-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Templates App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-templates</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin -->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                    <!-- Add the processor path for the plugin (required for Java 9+) -->
                    <annotationProcessorPaths>
                        <path>
                            <groupId>systems.manifold</groupId>
                            <artifactId>manifold-templates</artifactId>
                            <version>${manifold.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

# License

## Open Source
Open source Manifold is free and licensed under the [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0) license.  

## Commercial
Commercial licenses for this work are available. These replace the above ASL 2.0 and offer 
limited warranties, support, maintenance, and commercial server integrations.

For more information, please visit: http://manifold.systems//licenses

Contact: admin@manifold.systems

# Versioning

For the versions available, see the [tags on this repository](https://github.com/manifold-systems/manifold/tags).

# Authors

* [Scott McKinney](mailto:scott@manifold.systems)
* [Carson Gross]()
# Manifold : XML

>Warning: **Experimental Feature**

Manifold plugs into the Java compiler to enable you to use XML and Java seamlessly -- XML files are types. You use XML
directly in Java type-safely without a code generator or extra build steps.

>#### XML, JSON, CSV, and YAML are _Interchangeable_
>You can use XML, JSON, CSV, and YAML interchangeably, as such please refer to the [**JSON and JSON Schema**](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-json)
>project reference. _All_ that applies to JSON applies to XML.

## Table of Contents
* [Overview](#overview)
* [Naming](#naming)
* [Fluent API](#fluent-api)
* [Creating & Building JSON](#creating--building-xml)
* [Loading XML](#loading-xml)
* [Request REST API services](#request-rest-api-services)
* [Writing XML](#writing-xml)
* [Copying XML](#copying-xml)
* [Using XML with JSON Schema](#using-xml-with-json-schema)
* [IDE Support](#ide-support)
* [Setup](#setup)
* [License](#license)
* [Versioning](#versioning)
* [Author](#author)

## Overview
The XML type manifold provides comprehensive support for XML resource files (extension `.xml`).  You can define an 
XML API using a sample XML resource file. You can also define a [JSON Schema](https://json-schema.org/) version 4 or 
later and use that as the schema for your XML files. Your XML resource files serve as the **single source of truth**
regarding XML APIs.  You use XML-expressed types *directly* in your code without maintaining a separate set of classes
or wedging a code generator into your build.

Here is a sample XML file `resources/com/example/Catelog.xml`:
```xml
<ProductListing season="Fall">
    <Store name="Valley #2">
        <Address city="Cupertino" state="CA" postal="95014">
            <Line order="1">1101 Broadway Dr</Line>
            <Line order="2">Suite #123</Line>
        </Address>
    </Store>
    <Product department="Men's" brand="Joe's" price="65.00"
        description="Joe’s® 430™ Athletic Cut Jeans">
        <Size waste="26-42" inseam="28-38" cut="Athletic"/>
    </Product>
    <Product department="Men's" brand="Squarepants" price="35.00"
        description="Squarepants® Unround™ Pants">
        <Size waste="25-49" inseam="25-36" cut="Athletic"/>
    </Product>
    <Product department="Jewelry" brand="RiteTwice" price="100.00"
        description="RiteTwice® The 5 o'clock watch">
        <Size wrist="XS-XL"/>
    </Product>
</ProductListing>
```

## Naming

Most type manifolds, including the XML, JSON, CSV, & YAML manifolds, follow the Java naming convention where a type name is based on the
resource file name relative to its location in the resource path. Thus the XML resource file `resources/com/example/Catelog.xml`
has the Java type `com.example.Catelog`.

## Fluent API

XML types are defined as a set of fluent _interface_ APIs.  For example, the `Catelog` XML type is an interface and
provides type-safe methods to:
* **create** a `Catelog`
* **build** a `Catelog`
* **modify** properties of a `Catelog`  
* **load** a `Catelog` from a string, a file, or a URL using HTTP GET
* **request** Web service operations using HTTP GET, POST, PUT, PATCH, & DELETE
* **write** a `Catelog` as formatted JSON, YAML, CSV, or XML
* **copy** a `Catelog`
* **cast** to `Catelog` from any structurally compatible type including `Map`s, all *without proxies*

## Creating & Building XML
You create an instance of a XML type using either the `create()` method or the `builder()` method. Note if you want to
load data from preexisting XML files or even load directly from the sample data you can use the `load()` method or
the `fromSource()` method, discussed later in this document. 

The `create()` method defines parameters matching the `required` properties defined in the JSON Schema, if the type is
plain XML or no `required` properties are specified, `create()` has no parameters.

Since `Catelog` is a plain XML file, as opposed to a JSON Schema structured XML file, you can create an empty
instance of `Catelog` with `create()` and then modify it using _setter_ methods to change properties:
```java
import com.example.Catelog;
...
Catelog catelog = Catelog.create();
catelog.setProductListing( makeProductListing() );
```

Alternatively, you can use `builder()` to fluently build a new instance:
```java
var listing = Catelog.ProductListing.builder()
  .withSeason("Spring")
  .withStore(Store.builder()
    .withName("Valley #2")
    .withAddress(Store.Address.builder()
      .withCity("Cupertino")
      .withState("CA")
      .withPostal("95104")
      .withLine(lines)
      .build())
    .build())
  .withProduct(loadProducts())
  .build();
catelog.setProductListing(listing);
```

You can initialize several properties in a chain of `with` calls in the builder. This saves a bit of typing with
heavier APIs.  After it is fully configured call the `build()` method to construct the type.

> Note if using JSON Schema `with` methods also serve as a means to initialize values for `readOnly` properties.

## Loading XML
In addition to creating an object from scratch with `create()` and `build()` you can also load an instance from 
a variety of existing sources using `fromSource()` and `load()`.

You can load the contents of the file directly using `fromSource()`.
```java
// Load from the contents of the Catelog type's origin file 
Catelog catelog = Catelog.fromSource();
```
You can load a `Catelog` instance from a XML, JSON, CSV, or YAML String:
```java
// From a JSON String
Catelog catelog = Catelog.load().fromJson("..."); 
```
Load from a file:
```java
// From an XML file
Catelog catelog = Catelog.load().fromXmlFile("/path/to/WinterCatelog.xml");

// From an JSON file
Catelog catelog = Catelog.load().fromJsonFile("/path/to/SummerCatelog.json");
```
Invoke a REST API to load a `Catelog` using HTTP GET:
```java
// From HTTP GET
Catelog catelog = Catelog.load().fromJsonUrl("http://api.example.com/catelog/$catelogId");
```

## Request REST API services
Use the `request()` static method to conveniently navigate an HTTP REST API with GET, POST, PUT, PATCH, & DELETE:
```java
String id = "2019.fall";
Catelog catelog = Catelog.request("http://api.example.com/catelogs").getOne("/$id");
```
The `request()` methods provides support for all basic REST API client usage:
```java
Requester<Catelog> req = Catelog.request("http://api.example.com/catelogs");

// Get all Catelogs via HTTP GET
List<Catelog> catelogs = req.getMany();

// Add a Catelog with HTTP POST
Catelog catelog = Catelog.builder()
  .withSeason("Spring")
  .withStore(Store.builder() 
  . . .
req.postOne(catelog);

// Get a Catelog with HTTP GET
String id = catelog.getId();
catelog = req.getOne("/$id");

// Update a Catelog with HTTP PUT
catelog.getStore().setName("Valley #2");
req.putOne("/$id", catelog);

// Delete a Catelog with HTTP DELETE
req.delete("/$id");
```

## Writing XML
An instance of an XML API object can be written as formatted text with `write()`:
* `toXml()` - produces an XML formatted String
* `toJson()` - produces a JSON formatted String
* `toYaml()` - produces a YAML formatted String
* `toCsv()` - produces a CSV formatted String

The following example produces a JSON formatted string:
```java
Catelog catelog = Catelog.builder()
  .withSeason("Fall")
  .withStore(Store.builder() 
  . . .
String json = catelog.write().toJson();
System.out.println(json);
```
Output:
```json
{
  "ProductListing": {
    "season": "Fall",
    "Store": {
      "name": "Valley #2",
      "Address": {
        "city": "Cupertino", "state": "CA", "postal": "95014",
        "Line": [
          {"order": "1", "textContent": "1101 Broadway Dr"},
          {"order": "2", "textContent": "Suite #123"}
        ]
      }
    },
    "Product": [
      {
        "department": "Men's", "brand": "Joe's", "price": "65.00",
        "description": "Joe\u2019s\u00ae 430\u2122 Athletic Cut Jeans",
        "Size": {"waste": "26-42", "inseam": "28-38", "cut": "Athletic"}
      },
      {
        "department": "Men's", "brand": "Squarepants", "price": "35.00",
        "description": "Squarepants\u00ae Unround\u2122 Pants",
        "Size": {"waste": "25-49", "inseam": "25-36", "cut": "Athletic"}
      },
      {
        "department": "Jewelry", "brand": "RiteTwice", "price": "100.00",
        "description": "RiteTwice\u00ae The 5 o'clock watch",
        "Size": {"wrist": "XS-XL"}
      }
    ]
  }
}
```

## Copying XML
Use the `copy()` method to make a deep copy of any XML API object:
```java
Catelog catelog = . . .;
...
Catelog copy = catelog.copy();
```
Alternatively, you can use the `copier()` static method for a richer set of features:
```java
Catelog copy = Catelog.copier(catelog).withProductListing(. . .).copy();
```
`copier()` is a lot like `builder()` but lets you start with an already built object you can modify.  Also like
`builder()` it maintains the integrity of the schema's declared mutability -- you can't change
`readOnly` fields after the `copy()` method constructs the object.

# Using XML with JSON Schema

You can use XML, JSON, CSV, and YAML interchangeably, via the universal JSON API. This means you can also use XML with any
JSON Schema API.  You can also define a JSON Schema API using XML.  As such please refer to the
[**JSON and JSON Schema**](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-json)
project reference regarding API usage specific to JSON Schema. _All_ that applies to JSON Schema applies to XML.

# IDE Support 

Manifold is best experienced using [IntelliJ IDEA](https://www.jetbrains.com/idea/download).

## Install

Get the [Manifold plugin](https://plugins.jetbrains.com/plugin/10057-manifold) for IntelliJ IDEA directly from IntelliJ
via:

<kbd>Settings</kbd> ➜ <kbd>Plugins</kbd> ➜ <kbd>Marketplace</kbd> ➜ search: `Manifold`

<p><img src="http://manifold.systems/images/ManifoldPlugin.png" alt="echo method" width="60%" height="60%"/></p>

## Sample Project

Experiment with the [Manifold Sample Project](https://github.com/manifold-systems/manifold-sample-project) via:

<kbd>File</kbd> ➜ <kbd>New</kbd> ➜ <kbd>Project from Version Control</kbd> ➜ <kbd>Git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProjectMenu.png" alt="echo method" width="60%" height="60%"/></p>

Enter: <kbd>https://github.com/manifold-systems/manifold-sample-project.git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProject.png" alt="echo method" width="60%" height="60%"/></p>

Use the [plugin](https://plugins.jetbrains.com/plugin/10057-manifold) to really boost your productivity.

# Setup

## Building this project

The `manifold-xml` project is defined with Maven.  To build it install Maven and run the following command.

```
mvn compile
```

## Using this project

The `manifold-xml` dependency works with all build tooling, including Maven and Gradle. It also works with Java versions 8 - 13.

>Note you can replace the `manifold-xml` dependency with [`manifold-all`](https://github.com/manifold-systems/manifold/tree/master/manifold-all) as a quick way to gain access to all of
Manifold's features.

## Binaries

If you are *not* using Maven or Gradle, you can download the latest binaries [here](http://manifold.systems/docs.html#download).


## Gradle

Here is a sample `build.gradle` script. Change `targetCompatibility` and `sourceCompatibility` to your desired Java
version (8 - 13), the script takes care of the rest. 
```groovy
plugins {
    id 'java'
}

group 'systems.manifold'
version '1.0-SNAPSHOT'

targetCompatibility = 11
sourceCompatibility = 11

repositories {
    jcenter()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
}

dependencies {
    compile group: 'systems.manifold', name: 'manifold-xml', version: '2019.1.32'
    testCompile group: 'junit', name: 'junit', version: '4.12'

    // Add manifold to -processorpath for javac
    annotationProcessor group: 'systems.manifold', name: 'manifold-xml', version: '2019.1.32'
}

if (JavaVersion.current() != JavaVersion.VERSION_1_8 &&
    sourceSets.main.allJava.files.any {it.name == "module-info.java"}) {
    tasks.withType(JavaCompile) {
        // if you DO define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold', '--module-path', it.classpath.asPath]
    }
} else {
    tasks.withType(JavaCompile) {
        // If you DO NOT define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold']
    }
}

tasks.compileJava {
    classpath += files(sourceSets.main.output.resourcesDir) //adds build/resources/main to javac's classpath
    dependsOn processResources
}
tasks.compileTestJava {
    classpath += files(sourceSets.test.output.resourcesDir) //adds build/resources/test to test javac's classpath
    dependsOn processTestResources
}
```
Use with accompanying `settings.gradle` file:
```groovy
rootProject.name = 'MyProject'
```

## Maven

### Java 8

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-xml-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Xml App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-xml</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>8</source>
                    <target>8</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

### Java 9 or later
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-xml-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Xml App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-xml</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                    <!-- Add the processor path for the plugin (required for Java 9+) -->
                    <annotationProcessorPaths>
                        <path>
                            <groupId>systems.manifold</groupId>
                            <artifactId>manifold-xml</artifactId>
                            <version>${manifold.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

# License

## Open Source
Open source Manifold is free and licensed under the [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0) license.  

## Commercial
Commercial licenses for this work are available. These replace the above ASL 2.0 and offer 
limited warranties, support, maintenance, and commercial server integrations.

For more information, please visit: http://manifold.systems//licenses

Contact: admin@manifold.systems

# Versioning

For the versions available, see the [tags on this repository](https://github.com/manifold-systems/manifold/tags).

# Author

* [Scott McKinney](mailto:scott@manifold.systems)
# Manifold : YAML

The YAML type manifold provides comprehensive support for YAML (1.2).  You can define a YAML or JSON API with YAML resource
files (`.yml` and `.yaml` files).  Manifold can derive an API from sample data in YAML format or you can build [JSON Schema](https://json-schema.org/)
APIs directly with YAML.

Manifold lets you use YAML and JSON interchangeably, as such please refer to the [JSON and JSON Schema](https://github.com/manifold-systems/manifold/tree/master/manifold-deps-parent/manifold-json)
project reference.  All that applies to JSON applies to YAML.

# IDE Support 

Manifold is best experienced using [IntelliJ IDEA](https://www.jetbrains.com/idea/download).

## Install

Get the [Manifold plugin](https://plugins.jetbrains.com/plugin/10057-manifold) for IntelliJ IDEA directly from IntelliJ
via:

<kbd>Settings</kbd> ➜ <kbd>Plugins</kbd> ➜ <kbd>Marketplace</kbd> ➜ search: `Manifold`

<p><img src="http://manifold.systems/images/ManifoldPlugin.png" alt="echo method" width="60%" height="60%"/></p>

## Sample Project

Experiment with the [Manifold Sample Project](https://github.com/manifold-systems/manifold-sample-project) via:

<kbd>File</kbd> ➜ <kbd>New</kbd> ➜ <kbd>Project from Version Control</kbd> ➜ <kbd>Git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProjectMenu.png" alt="echo method" width="60%" height="60%"/></p>

Enter: <kbd>https://github.com/manifold-systems/manifold-sample-project.git</kbd>

<p><img src="http://manifold.systems/images/OpenSampleProject.png" alt="echo method" width="60%" height="60%"/></p>

Use the [plugin](https://plugins.jetbrains.com/plugin/10057-manifold) to really boost your productivity. Use code
completion to conveniently build queries and discover the schema's API.  Navigate to/from call-sites and YAML/schema
file elements.  Make changes to your YAML/schema files and use the changes immediately, no compilation!  Find usages of
any element in your YAML/schema files. Perform rename refactors to quickly and safely make project-wide changes.

# Setup

## Building this project

The `manifold-yaml` project is defined with Maven.  To build it install Maven and run the following command.

```
mvn compile
```

## Using this project

The `manifold-yaml` dependency works with all build tooling, including Maven and Gradle. It also works with Java
versions 8 - 13.

>Note you can replace the `manifold-yaml` dependency with [`manifold-all`](https://github.com/manifold-systems/manifold/tree/master/manifold-all) as a quick way to gain access to all of
Manifold's features.  But `manifold-yaml` already brings in a lot of Manifold including
[Extension Methods](http://manifold.systems/docs.html#extension-classes),
String Templates](http://manifold.systems/docs.html#templating), and more.

## Binaries

If you are *not* using Maven or Gradle, you can download the latest binaries [here](http://manifold.systems/docs.html#download).


## Gradle

Here is a sample `build.gradle` script. Change `targetCompatibility` and `sourceCompatibility` to your desired Java
version (8 - 13), the script takes care of the rest. 
```groovy
plugins {
    id 'java'
}

group 'systems.manifold'
version '1.0-SNAPSHOT'

targetCompatibility = 11
sourceCompatibility = 11

repositories {
    jcenter()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
}

dependencies {
    compile group: 'systems.manifold', name: 'manifold-yaml', version: '2019.1.32'
    testCompile group: 'junit', name: 'junit', version: '4.12'

    // Add manifold to -processorpath for javac
    annotationProcessor group: 'systems.manifold', name: 'manifold-yaml', version: '2019.1.32'
}

if (JavaVersion.current() != JavaVersion.VERSION_1_8 &&
    sourceSets.main.allJava.files.any {it.name == "module-info.java"}) {
    tasks.withType(JavaCompile) {
        // if you DO define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold', '--module-path', it.classpath.asPath]
    }
} else {
    tasks.withType(JavaCompile) {
        // If you DO NOT define a module-info.java file:
        options.compilerArgs += ['-Xplugin:Manifold']
    }
}

tasks.compileJava {
    classpath += files(sourceSets.main.output.resourcesDir) //adds build/resources/main to javac's classpath
    dependsOn processResources
}
tasks.compileTestJava {
    classpath += files(sourceSets.test.output.resourcesDir) //adds build/resources/test to test javac's classpath
    dependsOn processTestResources
}
```
Use with accompanying `settings.gradle` file:
```groovy
rootProject.name = 'MyProject'
```

## Maven

### Java 8

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-yaml-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Yaml App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-yaml</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>8</source>
                    <target>8</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin-->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

### Java 9 or later
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>my-yaml-app</artifactId>
    <version>0.1-SNAPSHOT</version>

    <name>My Yaml App</name>

    <properties>
        <!-- set latest manifold version here --> 
        <manifold.version>2019.1.32</manifold.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>systems.manifold</groupId>
            <artifactId>manifold-yaml</artifactId>
            <version>${manifold.version}</version>
        </dependency>
    </dependencies>

    <!--Add the -Xplugin:Manifold argument for the javac compiler-->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                    <encoding>UTF-8</encoding>
                    <compilerArgs>
                        <!-- Configure manifold plugin -->
                        <arg>-Xplugin:Manifold</arg>
                    </compilerArgs>
                    <!-- Add the processor path for the plugin (required for Java 9+) -->
                    <annotationProcessorPaths>
                        <path>
                            <groupId>systems.manifold</groupId>
                            <artifactId>manifold-yaml</artifactId>
                            <version>${manifold.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

# License

## Open Source
Open source Manifold is free and licensed under the [Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0) license.  

## Commercial
Commercial licenses for this work are available. These replace the above ASL 2.0 and offer 
limited warranties, support, maintenance, and commercial server integrations.

For more information, please visit: http://manifold.systems//licenses

Contact: admin@manifold.systems

# Versioning

For the versions available, see the [tags on this repository](https://github.com/manifold-systems/manifold/tags).

# Authors

* [Scott McKinney](mailto:scott@manifold.systems)/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// FIXME: For some reason, WebSphere changes JARs in WEB-INF/lib, breaking signatures. So ignore errors.
// Ignore
// No instances.
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// ignore
// Do nothing
/*
//www.apache.org/licenses/LICENSE-2.0
/** Facilitates virtual files e.g., IFileFragment */
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/** The file element hosting the fragment e.g., a comment or string literal */
/*
//www.apache.org/licenses/LICENSE-2.0
//  IFile getFakeFile( URL url, IModule module );
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// this check is too aggressive eg., including many jars we don't need to process
//!Extensions.getExtensions( root, "Main-Class" ).isEmpty() ||
// Weblogic packages all WEB-INF/classes content into this JAR
// http://middlewaremagic.com/weblogic/?p=408
// http://www.coderanch.com/t/69641/BEA-Weblogic/wl-cls-gen-jar-coming
// So we need to always treat it as containing sources
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
// We do not want to support this.
/*
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// no-op
// TODO - Throw if no more elements
/**
/**
/**
/**
/**
// We don't want to add the separator character after the windows network root; otherwise
// we want to add the separator in before adding in our name
/**
// no-op
/**
// Special hack:  the path string for the root element needs to
// include the separator unless it's the windows network root symbol
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Exclude directories that are not actual packages such as META-INF that exist in jar files
//## todo: also consider excluding a user-defined list of directories e.g., the ../config directories for XCenter
// add only if absent; respect class/sourcepath order
/*
//www.apache.org/licenses/LICENSE-2.0
//    try( InputStreamReader reader = new InputStreamReader( _enclosingFile.openInputStream() ) )
//    {
//      char[] fragment = new char[_length];
//      int length = reader.read( fragment, _offset, _length );
//      if( length != _length )
//      {
//        throw new IOException( "Expected fragment length " + _length + " but was " + length );
//      }
//      return new ByteArrayInputStream( new String( fragment ).getBytes() );
//    }
//    return getEnclosingFile().getBaseName() + '#' + _name;
// using enclosing file's uri for now because some type manifold Model's report() methods use the uri as file
//## todo: make a "filefragment" uri scheme like filefragment://C:/path/to/file.json#offset109length24
/*
//www.apache.org/licenses/LICENSE-2.0
// PL-21817 in OSGi/Equinox JAR could be named as "bundlefile"
// debug getting IAE only in TH - unable to parse URL with fragment identifier
/*
//www.apache.org/licenses/LICENSE-2.0
//    try {
/*.getCanonicalFile()*/;
//    } catch (IOException e) {
//      throw new RuntimeException(e);
//    }
//    try {
/*.getCanonicalFile()*/;
//    } catch (IOException e) {
//      throw new RuntimeException(e);
//    }
// This should always be called with the CACHED_FILE_SYSTEM_LOCK monitor already acquired
// This should always be called with the CACHED_FILE_SYSTEM_LOCK monitor already acquired
// If the timestamp is 0, assume it's been deleted
// in ms, absolute time
// in ms, absolute time
// This should always be called with the CACHED_FILE_SYSTEM_LOCK monitor already acquired
// If the timestamp is 0, assume it's been deleted
// Do nothing
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// Do nothing
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// IJarFileDirectory methods
// IDirectory methods
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/* Generated by Manifold */\n" );
// fields //\n" );
// methods //\n" );
// static blocks //\n" );
// constructors //\n" );
// properties //\n" );
//  private String getTypeVariables( StringBuilder sb )
//  {
//    if( _typeVars.isEmpty() )
//    {
//      return "";
//    }
//
//    sb.append( '<' );
//    for( int i = 0; i < gtvs.size(); i++ )
//    {
//      SrcTypeVar gtv = gtvs[i];
//      sb.append( i > 0 ? ", " : "" ).append( gtv.getSimpleName() );
//      String boundingType = gtv.getBoundingType();
//      if( boundingType != null )
//      {
//        sb.append( " extends ").append( boundingType );
//      }
//    }
//    sb.append( "> " );
//    return sb.toString();
//  }
// inner classes //\n" );
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Modifier.VARARGS
// Canonical order
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// prevent overriding Object#getClass()
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
// type annotations apply to class name part:  "java.util. @Foo List"
//!! ALWAYS USE FULLY QUALIFIED NAMES -- SOME USE CASES DEPEND ON FULLY QUALIFIED NAMES
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Handle "<any>" type used in javac to represent an Error type
// produce a type to reflect the errant javac <any> Type
//## note: ignoring type args for outer type of inner type e.g., abc.Outer<E>.Inner become abc.Outer.Inner
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//manifold.systems/docs.html#working-with-intellij">IntelliJ plugin</a>.
/**
/**
/**
/**
/**
// note type manifolds are sorted via getTypeManifoldSorter(), hence the use of TreeSet
/**
//noinspection ComparatorMethodParameterNotUsed
// Exclude type manifolds listed in the "manifold.exclude" sys property
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
// reflectively make modules accessible such as java.base and jdk.compiler
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// for subclasses
// for subclasses
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//en.wikipedia.org/wiki/Comma-separated_values">CSV</a> file.
// tolerate adding a file even though this is a single file model
// the idea is to issue a warning during compilation if this model has more than one file
// tolerate adding a file even though this is a single file model
// the idea is to issue a warning during compilation if this model has more than one file
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Sample code using embedded SQL
// Generated from Manifold
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/** Used to specify the preferred order a preprocessor runs wrt others */
/** Indicates a preprocessor should run before others */
/** Indicates a preprocessor should run after others */
/** Indicates the order is insignificant */
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/** Java source */
/** JavaScript source */
/** The {@ITypeManifold} does not contribute source */
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
//boolean filterError( TypeProcessor typeProcessor, Diagnostic diagnostic );
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
// Map primary type to model
// Map additional types to same model
// use same model as base fqn
// Add peripheral (global) types having separate model scheme
/**
/**
/**
/**
/**
// some environments (intellij) sometimes allow crazy stuff to parse as a name, ignore this
/**
// Now remove the model since we don't need it anymore
//.replace( "\r\n", "\n" );
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/** The location of the resource containing the feature "declaration" */
/** The offset of the feature declaration from the beginning of the file */
/** The length of the feature declaration */
/** The qualified type of the feature */
/** The name of the feature */
/** What kind of feature is this according to the resource's schema taxonomy? Optional. */
/** The line where the feature begins. Optional. */
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//www.w3.org/RDF/">RDF</a> could
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
// c.toArray might (incorrectly) not return Object[] (see 6260652)
/**
/**
/**
// minCapacity is usually close to size, so this is a win:
/**
/**
/**
/**
/**
/**
/**
// Make a new array of a's runtime type, but my contents:
// Positional Access Operations
/**
/**
/**
// Increments modCount!!
/**
// Increments modCount!!
/**
// Let gc do its work
/**
/*
// Let gc do its work
/**
// Let gc do its work
/**
// Increments modCount
/**
// Increments modCount
/**
// Let gc do its work
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// raw message includes {i} params
//noinspection ResultOfMethodCallIgnored
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// skip leading whitespace
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
// Defaulting
//-----------------------------------------------------------------------
/**
/**
/**
// Identity ToString
//-----------------------------------------------------------------------
/**
/**
/**
/**
// ToString
//-----------------------------------------------------------------------
/**
/**
// Min/Max
//-----------------------------------------------------------------------
/**
/**
// Null
//-----------------------------------------------------------------------
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//jakarta.apache.org/turbine/">Apache Jakarta Turbine</a>
/*
/**
/**
/**
/**
// Empty checks
//-----------------------------------------------------------------------
/**
/**
/**
/**
// Trim
//-----------------------------------------------------------------------
/**
/**
/**
/**
// Stripping
//-----------------------------------------------------------------------
/**
/**
/**
/**
/**
/**
// StripAll
//-----------------------------------------------------------------------
/**
/**
// Equals
//-----------------------------------------------------------------------
/**
/**
// IndexOf
//-----------------------------------------------------------------------
/**
/**
/**
/**
/**
// JDK1.2/JDK1.3 have a bug, when startPos > str.length for "", hence
// LastIndexOf
//-----------------------------------------------------------------------
/**
/**
/**
/**
// Contains
//-----------------------------------------------------------------------
/**
/**
/**
// IndexOfAny chars
//-----------------------------------------------------------------------
/**
/**
// ContainsAny
//-----------------------------------------------------------------------
/**
/**
// IndexOfAnyBut chars
//-----------------------------------------------------------------------
/**
/**
// ContainsOnly
//-----------------------------------------------------------------------
/**
// All these pre-checks are to maintain API with an older version
/**
// ContainsNone
//-----------------------------------------------------------------------
/**
/**
// IndexOfAny strings
//-----------------------------------------------------------------------
/**
// String's can't have a MAX_VALUEth index.
/**
// Substring
//-----------------------------------------------------------------------
/**
// handle negatives, which means last n characters
// remember start is negative
/**
// handle negatives
// remember end is negative
// remember start is negative
// check length next
// if start is greater than end, return ""
// Left/Right/Mid
//-----------------------------------------------------------------------
/**
/**
/**
// SubStringAfter/SubStringBefore
//-----------------------------------------------------------------------
/**
/**
/**
/**
// Substring between
//-----------------------------------------------------------------------
/**
/**
/**
// Nested extraction
//-----------------------------------------------------------------------
/**
/**
// Splitting
//-----------------------------------------------------------------------
/**
/**
/**
/**
/**
/**
/**
/**
/**
// Split on whitespace.
// The following is OK, because String.substring( beg, end ) excludes
// the character at the position 'end'.
// Set the starting point for the next search.
// The following is equivalent to beg = end + (separatorLength - 1) + 1,
// which is the right calculation:
// We found a consecutive occurrence of the separator, so skip it.
// String.substring( beg ) goes from 'beg' to the end of the String.
// -----------------------------------------------------------------------
/**
/**
/**
// Performance tuned for 2.0 (JDK1.4)
/**
/**
/**
// Performance tuned for 2.0 (JDK1.4)
// Direct code is quicker than StringTokenizer.
// Also, StringTokenizer uses isSpace() not isWhitespace()
// Null separator means use whitespace
// Optimise 1 character case
// standard case
/**
/**
/**
// Joining
//-----------------------------------------------------------------------
/**
/**
/**
/**
/**
/**
// endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))
//           (Assuming that all Strings are roughly equally long)
/**
// handle null, zero and one elements before building a buffer
// two or more elements
// Java default is 16, probably too small
/**
// handle null, zero and one elements before building a buffer
// two or more elements
// Java default is 16, probably too small
/**
/**
/**
// Remove
//-----------------------------------------------------------------------
/**
/**
/**
/**
/**
/**
// Replacing
//-----------------------------------------------------------------------
/**
/**
/**
/**
/**
// timeToLive should be 0 if not used or nothing to replace, else it's
// the length of the replace array
/**
// mchyzer Performance note: This creates very few new objects (one major goal)
// let me know if there are performance requests, we can create a harness to measure
// if recursing, this shouldnt be less than 0
// make sure lengths are ok, these need to be equal
// keep track of which still have matches
// index on index that the match was found
// index of replace array that will replace the search string found
// NOTE: logic duplicated below START
// see if we need to keep searching for this
// NOTE: logic mostly below END
// no search strings found, we are done
// get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit
// count the replacement text elements that are larger than their corresponding text being replaced
// assume 3 matches
// have upper-bound at 20% increase, then let Java take over
// find the next earliest match
// NOTE: logic mostly duplicated above START
// see if we need to keep searching for this
// NOTE: logic duplicated above END
// Replace, character based
//-----------------------------------------------------------------------
/**
/**
// Overlay
//-----------------------------------------------------------------------
/**
/**
// Chomping
//-----------------------------------------------------------------------
/**
/**
/**
/**
/**
/**
/**
// Chopping
//-----------------------------------------------------------------------
/**
/**
// Padding
//-----------------------------------------------------------------------
/**
// Performance tuned for 2.0 (JDK1.4)
/**
//www.unicode.org/glossary/#supplementary_character">Unicode Supplementary Characters</a>
/**
/**
// returns original String when possible
/**
// returns original String when possible
/**
/**
// returns original String when possible
/**
// returns original String when possible
/**
// Centering
//-----------------------------------------------------------------------
/**
/**
/**
// Case conversion
//-----------------------------------------------------------------------
/**
/**
/**
/**
/**
/**
/**
/**
/**
// Count matches
//-----------------------------------------------------------------------
/**
/**
// Character Tests
//-----------------------------------------------------------------------
/**
/**
/**
/**
/**
/**
/**
/**
/**
// Defaults
//-----------------------------------------------------------------------
/**
/**
/**
// Reversing
//-----------------------------------------------------------------------
/**
// Abbreviating
//-----------------------------------------------------------------------
/**
/**
// Difference
//-----------------------------------------------------------------------
/**
/**
/**
// find the min and max string lengths; this avoids checking to make
// sure we are not exceeding the length of the string each time through
// the bottom loop.
// handle lists containing all nulls or all empty strings
// handle lists containing some nulls or some empty strings
// find the position with the first difference across all strings
// we compared all of the characters up to the length of the
// shortest string and didn't find a match, but the string lengths
// vary, so return the length of the shortest string.
/**
// all strings were identical
// there were no common demo characters
// we found a common demo character sequence
// Misc
//-----------------------------------------------------------------------
/**
//www.merriampark.com/ld.htm">http://www.merriampark.com/ld.htm</a></p>
//www.merriampark.com/ldjava.htm">http://www.merriampark.com/ldjava.htm</a></p>
/*
// length of s
// length of t
// swap the input strings to consume less memory
//'previous' cost array, horizontally
// cost array, horizontally
//placeholder to assist in swapping p and d
// indexes into strings s and t
// iterates through s
// iterates through t
// jth character of t
// cost
// minimum of cell to the left+1, to the top+1, diagonally left and up +cost
// copy current distance counts to 'previous row' distance counts
// our last action in the above loop was to switch d and p, so p now
// actually has the most recent cost counts
/**
/*
// Method copied from NumberUtils to avoid dependency on subpackage
// startsWith
//-----------------------------------------------------------------------
/**
/**
/**
/**
// endsWith
//-----------------------------------------------------------------------
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Use the "user.dir" system property because we set this property to the experiment root.
// Note there is no way to set the current working directory at the OS level in Java, so we
// must use something like this.
// creates zip/jar file if not already exists
//## todo: find a better way, Files.isWritable() does not work e.g., returns true for ZipPath, which is wrong
/*
//www.apache.org/licenses/LICENSE-2.0
//noinspection ConstantConditions
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Capitalize/Uncapitalize reserved keywords to avoid parse errors.
// Internally we perserve the case of the keys, but in structure types
// we expose them as alternate versions of the reserved words.
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Load from Thread Context Loader
// (currently the IJ plugin creates loaders for accessing type manifolds from project classpath)
// not in the loader, check thread ctx loader next
// Also load from this loader
// avoid chicken/egg errors from attempting to build a module that self-registers a source producer
// it's important to allow a source producer module to specify its xxx.ITypeManifold file in its META-INF
// directory so that users of the source producer don't have to
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//## slow: warnIfRoot( p );
//## slow: warnIfRoot( p );
// necessary since java 9
// (surefile creates a classpath jar where the classpaths are formatted as URLs e.g., file://c:/blah, which blows up java 9)
// since we don't need this jar anyway, we omit it from the path
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// Using a relatively large block size to reduce the number of (very slow)
// native calls into the file system
/* disable construction */
/**
// shouldn't happen since UTF-8 is supported by all JVMs per spec
/**
// shouldn't happen since UTF-8 is supported by all JVMs per spec
/**
// shouldn't happen since UTF-8 is supported by all JVMs per spec
/**
// shouldn't happen with BAIS
/**
/**
// shouldn't happen since UTF-8 is supported by all JVMs per spec
/**
// shouldn't happen since UTF-8 is supported by all JVMs per spec
/**
/**
/**
/**
//    if( in instanceof FileInputStream && out instanceof FileOutputStream )
//    {
//      copy( (FileInputStream)in, (FileOutputStream)out );
//    }
//    else
//    {
//    }
/**
/**
/**
/**
//noinspection ResultOfMethodCallIgnored
//noinspection ResultOfMethodCallIgnored
/**
//noinspection ResultOfMethodCallIgnored
//noinspection ResultOfMethodCallIgnored
/**
/**
// done
// ignore io exceptions for input streams and readers
//  /**
/**
//   */
//  public static void copy( File fileOrDirectory, File toDir )
//  {
//    copy( fileOrDirectory, toDir, null );
//  }
//  /**
/**
//   */
//  public static void copy( File fileOrDirectory, File toDir, Predicate<Path> filter )
//  {
//    copy( fileOrDirectory.toPath(), toDir.toPath(), filter );
//  }
//
//  /**
/**
//   */
//  public static void copy( Path fileOrDirectory, Path toDir )
//  {
//    copy( fileOrDirectory, toDir, null );
//  }
//  /**
/**
//   */
//  public static void copy( Path fileOrDirectory, Path toDir, Predicate<Path> filter )
//  {
//    try
//    {
//      Files.walkFileTree( fileOrDirectory,
//                          EnumSet.of( FileVisitOption.FOLLOW_LINKS ), Integer.MAX_VALUE,
//                          new CopyFileVisitor( toDir, filter ) );
//    }
//    catch( IOException ioe )
//    {
//      throw new RuntimeException( ioe );
//    }
//  }
//
//  private static class CopyFileVisitor extends SimpleFileVisitor<Path>
//  {
//    private Path _from;
//    private Path _to;
//    private Predicate<Path> _filter;
//
//    CopyFileVisitor( Path to, Predicate<Path> filter )
//    {
//      _to = to;
//      _filter = filter;
//    }
//
//    @Override
//    public FileVisitResult preVisitDirectory( Path dir, BasicFileAttributes attrs ) throws IOException
//    {
//      if( _filter != null && !_filter.test( dir ) )
//      {
//        return FileVisitResult.SKIP_SUBTREE;
//      }
//
//      if( _from == null )
//      {
//        _from = dir;
//      }
//      else
//      {
//        Files.createDirectories( _to.resolve( _from.relativize( dir ) ) );
//      }
//      return FileVisitResult.CONTINUE;
//    }
//
//    @Override
//    public FileVisitResult visitFile( Path file, BasicFileAttributes attrs ) throws IOException
//    {
//      if( _filter == null || _filter.test( file ) )
//      {
//        Files.copy( file, _to.resolve( _from.relativize( file ) ) );
//      }
//      return FileVisitResult.CONTINUE;
//    }
//  }
/*
//www.apache.org/licenses/LICENSE-2.0
//todo: this prevents some names from working e.g., csv header column names tend to be pretty arbitrary and long and not very identifier-like
//          if( theRest.charAt( theRest.length() - 1 ) != '>' )
//          {
//            throw new IllegalTypeNameException( "\"" + theRest + "\" does not end with '>'" );
//          }
/*
//www.apache.org/licenses/LICENSE-2.0
// adding a child and setting userData must be an atomic operation,
// therefore userdata is assigned before child is added
// update reverse cache
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//  public static String get( String value ) {
//    String existing = INSTANCE._map.get( value );
//    INSTANCE._total++;
//    if( existing != null ) {
//      return existing;
//    }
//    INSTANCE._misses++;
//    INSTANCE._size += value.length();
//    INSTANCE._map.put( value, value );
//    return value;
//  }
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//    removeReleasedEntries();
//    removeReleasedEntries();
//    removeReleasedEntries();
//  private void removeReleasedEntries() {
//    while( true ) {
//      KeyedReference<T> ref = (KeyedReference<T>)_queue.poll();
//      if( ref == null ) {
//        break;
//      }
//      FqnCacheNode<WeakReference<T>> node = getNode( ref._fqn );
//      if( node != null && node.isLeaf() && node.getUserData() == ref ) {
//        _remove( ref._fqn );
//      //  System.out.println( "XXXXXX: " + (++_removed) + " : " + ref._fqn );
//      }
//    }
//  }
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*INOUT*/ byte[] buff )
/**
/**
/**
/**
/**
/**
/**
/**
/**
// NOTE pdalbora 23-Jul-2009 -- The following check is intentional. We don't extend the high order byte when it's
// zero, in order to avoid "weakening" the fingerprint of primarily ASCII data by adding unnecessary bits. The
// tradeoff for doing this is that two characters in the low order byte range (<= 0x00FF) will be
// indistinguishable from the corresponding character in the high order byte range (> 0x00FF). For example, the
// character sequence (0x0022, 0x0021) will have the same fingerprint as the character sequence (0x2122). However,
// it would be highly unlikely for this to happen, as ASCII data and non-ASCII data are unlikely to mix together.
// Even in the case where such a sequence pair occurred in two strings, the likelihood of it yielding a collision
// would be very low, when there other characters in the strings.
/**
/**
/* This class provides methods that construct fingerprints of
// implementation constants
// polynomials are represented with the coefficient for x^0
// in the most significant bit
// coefficient of x^63
/* This is the table used for extending fingerprints.  The
// Initialization code
// Maximum power needed == 64 + 8
//System.out.println("pow[" + i + "] = " + Long.toHexString(t));
// t = t * x
// group bit-wise overflows into bytes
//System.out.println("ByteModTable[" + j + "] = " + Long.toHexString(v));
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//## todo: move this to RuntimeManifoldHost after factoring ExtensionManifold#isInnerToJavaClass()
//    if( JavacPlugin.instance() == null )
//    {
//      // runtime
//      return Thread.currentThread().getContextClassLoader();
//    }
//    // compile-time
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// ensure output path is in the classpath
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Allow for the IRuntimeManifoldHost impl to be customised as a Java Service
// report, but do not throw, the exception; let the default host takeover
// default
/**
//ignore
// IntelliJ's PluginClassLoader is special
//    addBootstrapClasses( ll );
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//noinspection unchecked
//## todo: use location to select more specifically (in Java 9+ with the location's module)
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//noinspection ConstantConditions
// Must assign _module BEFORE initializeTypeManifolds() to prevent double bootstrapping
// Full type system monitoring is only necessary for an environment like an IDE where types change.
// Compilation and runtime environments should only care about *creation* events e.g., from a type embedded via @Type.
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
//  void modified( IResource file )
//  {
//    notify( file, RefreshKind.MODIFICATION );
//  }
//  void deleted( IResource file )
//  {
//    notify( file, RefreshKind.DELETION );
//  }
// for creation the file system needs to be updated *before* other listeners
// for deletion the file system needs to be updated *after* other listeners
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//noinspection unchecked
//noinspection unchecked
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// If an annotation processor is active, a class can be processed multiple times,
// so we check to see if we've already added the bootstrap block.
// don't bootstrap from an annotation class,
// many tools do not handle the presence of the <clinit> method well
// Don't insert bootstrap in a IManifoldHost impl
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// report errors to console
// report errors to console
// For the case where the class is generated from a type manifold esp. from a IExtensionClassProducer
//## want this instead, but the typeElement is not complete in this case, investigate this
//      if( JavacPlugin.instance() != null )
//      {
//        typeElement = IDynamicJdk.instance().getTypeElement( JavacPlugin.instance().getContext(), moduleCtx, fqn );
//        typeElement.complete();
//      }
// TreePath is only applicable to a source file;
// if fqn is not a source file, there is no compilation unit available
// For the case where the class is generated from a type manifold esp. from a IExtensionClassProducer
// need javac with ManifoldJavaFileManager because the produced class must come from manifold
// TreePath is only applicable to a source file;
// if fqn is not a source file, there is no compilation unit available
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//  /**
/**
//   */
//  public abstract boolean filterError( Diagnostic diagnostic );
//
// Process trees that were generated and therefore not available during ANALYZE
// For instance, we must process bridge methods
//
//
// Process fully analyzed trees (full type information is in the trees)
//
// already processed
//    if( visited == null && !isNested( e.getTypeElement().getEnclosingElement() ) && !isOuter( fqn ) )
//    {
//      // also process inner types of types to process and (outer type if processing inner type first)
//      return;
//    }
// mark processed
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*[>Foo.graphql<]
/*[>Foo.graphql<] query Persons { name address }*/
//[>Foo.graphql<] query Persons { name address }
/**
// skip '//'
// skip '/*'
/*'
// skip '/**'
/**'
// skip "
// end before terminating "
// skip """
// end before terminating """
// Name is optional if fragment is in a String literal e.g., "[>.sql<] blah blah" // just the dot is ok
//(note the reason why the dot is needed for anonymity is so multi-extension names can be distinguished
//esp. for template languages e.g., .html.mtl)
// name must be uniquely deterministic wrt content
/*
//www.apache.org/licenses/LICENSE-2.0
/**
///" + name.replace( '.', '/' ) + Kind.SOURCE.extension ), Kind.SOURCE );
///" + getName() );
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Java 9 & 10
// Java 11 or later
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
///" + className.replace( '.', '/' ) + kind.extension ), kind );
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//## would rather use javax.annotation.processing.Messager, but it doesn't give us what we want
/*
//www.apache.org/licenses/LICENSE-2.0
// Handle operator overloading
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
// Java 9 introduces StandardJavaFileManager#getLocationAsPaths() for validation, but there is a bug in their code
// where it does not check for empty iterable, which is what we do here
// exclusive to Java 9
//noinspection unchecked
/**
/**
/**
/**
/**
//return fileManager.getLocationForModule(location, moduleName);
/**
//return fileManager.getLocationForModule(location, fo);
/**
//return fileManager.getServiceLoader(location, service);
//noinspection unchecked
/**
//return fileManager.inferModuleName( location );
/**
//return fileManager.listLocationsForModules( location );
//noinspection unchecked
/**
//return fileManager.contains( location, fo );
//noinspection unchecked
//## todo: ...
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/** dynamic compilation mode */
/** disables &lt;clinit&gt; bootstap */
/** turns off checked exceptions (deprecated, use manifold-exceptions dependency) */
/** static mode (deprecated, now the default) */
/** enables string literal templating (deprecated, use manifold-strings dependency) */
/** all plugin args */
// ClassFinder is new in Java 9, its presence indicates Java 9 or later
// calling this here because the line below this references the type `BasicJavacTask`, which is in a jdk module needing exposure
// maven doesn't like the -Xplugin:"Manifold strings", it doesn't parse "Manifold string" as plugin name and argument, so we do it here:
// For type processing (##todo is this still necessary?)
//
// Both Java 8 and Java 9 alterations
//
// Override javac's Log for error suppression (@Jailbreak too, but that's only if extensions are enabled, see below)
// No need to hook up all the extension stuff if it's not enabled
// Override javac's Attr
// Override javac's ClassWriter
// Override javac's Resolve
// Override javac's TransTypes
// Override javac's Types
//
// Java 9 specific alterations
//
// Override javac's ClassFinder
// Override javac's JavaFileManager
// Assign our file manager to javac's various components
// Hack for using "-source 8" with Java 9
//noinspection ConstantConditions
//JavaFileObject classFile = _jpe.getFiler().createClassFile( ping );
// an explicit is compiling, determine the class path from its dependencies, which are allModules visible via Modules util
// Remove a path that is a parent of another path.
// For instance, "/foo/." is a parent of "/foo/classes", this must be unintentional
//noinspection StringEquality
//noinspection unchecked
/**
// If compiling from IntelliJ, we provide the resource paths definitively via a comment in
// the _Manifold_Temp_Main_.java file provided by our JPS plugin.
//noinspection unchecked
/**
//## ResourceRoots:";
// Must perform shenanigans early
// Initialize the Javac host environment
// Initialize the runtime host for dynamically loading darkj classes Manifold itself uses during compilation e.g., ManClassFinder_9
// Override javac's ClassFinder and Resolve so that we can safely load class symbols corresponding with extension classes
// override the ParserFactory to support fragments in comments and string literals
// add the fragments created during parsing
// If annotation processors are present, javac creates a whole new JavaCompiler and ctx before Analyze phase...
// Override javac's stuff again for the new ctx
// we construct BootstrapInserter reflectively because it extends TreeTranslator,
// which we have yet to open/export as JavacPlugin is loaded before that time
//noinspection Java8CollectionRemoveIf
//## todo: add compile warning
// ensure path cache is created before creation notify
/*
/*
//www.apache.org/licenses/LICENSE-2.0
// Adapted from JavacMessager.printMessage.  Following same basic routine regarding use of Log
// should be just one
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
// Share our existing Manifold file manager from Javac
// Make a new Manifold file manager exclusively for this JavaParser
//!! Do not init() here; do not use _javac or _mfm for parseExpr() since this method is generally used
//!! during the Parse phase, which happens earlier than the Enter phase where the plugin initializes much
//!! of its state i.e., if parseExpr() is called before an Enter phase, it could use Manifold prematurely
//!! and screw the pooch.  Also, we don't need Manifold for parsing expressions since it only produces a
//!! simple AST with nothing resolved.
// init();
/**
/**
/**
// short-circuit reentrancy during init()
/*
//www.apache.org/licenses/LICENSE-2.0
// note ==, !=, >, >=, <, <=  are covered via ComparableUsing
// Handle operator overloading
// pose with boolean return to satisfy type checker, this call will be transformed in ext transformer
// Attribute arguments
// Handle operator overloading
// replace the tree with JCBinary expressions reflecting the correct associativity and bindingOperator
// todo: maybe factor this out into a more efficient method from IDynamicJdk where Kind, KindSelector, and VAL can be referenced directly
// although this is only called for bonding expressions, so is somewhat infrequent
// Binding expr
// Support > >= < <= on any Comparable implementor
// Look for default interface methods impls
/*
//www.apache.org/licenses/LICENSE-2.0
// Override logger to handle final field assignment for @Jailbreak
/**
// record JCFieldAccess trees as they are visited so we can access them elsewhere while in context
/**
/**
// since method-calls can be nested, we need a tree of stacks TreeNode(JCTree.JCFieldAccess, Stack<JCDiagnostic>>)
// set qualifier type to supertype to handle private methods
// retry with supertype
// restore original type
// apply any issues logged for the found method (only the top of the suspend stack)
// binding expr
// Handle binding expressions
// pose as a MUL expr to pass binary expr checks
// Handle operator overloading
// Everything after left/right operand attribution (see super.visitBinary())
// Find operator.
// This will figure out when unboxing can happen and
// choose the right comparison operator.
// If both arguments are constants, fold them.
// Check that argument types of a reference ==, != are
// castable to each other, (JLS 15.21).  Note: unboxing
// comparisons will not have an acmp* opc at this point.
// Handle negation overloading
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
//System.err.println( "PATCH: " + fo.getName() );
// only retain primary class files e.g., don't keep stubbed class files from extension classes
// it's ok to write a type manifold class to disk if we're running javac and the class is not an extended java class
// ManChangedResourceBuilder from IJ plugin
// make a copy because this super call likes to remove the SOURCE kind in a multi-module project
// note, a null module indicates JavacPlugin is not initialized at ENTER phase yet
// Get a list of class files from the patch module location; these are patch candidates
//noinspection ConstantConditions
// NOT a ManPatchModuleLocation means NOT an extended class...
// and also NOT a class in a dependency that is not compiled, but
// needs to be dynamically compiled from the dependent module
// true if type is not exclusively an extended type
//noinspection unchecked
// type is from a dependency module, but was not compiled there, yet is
// referenced outside the module and needs to be dynamically compiled
// existing type is extended
// Module module = Modules.instance( _ctx ).getObservableModule( Names.instance( _ctx ).fromString( location.getName() ) );
// return module.classLocation;
// note userdata can be null in the case where an innerclass is loaded before the enclosing
// note we cache even if file is null, fqn cache is also a miss cache
// Remove all affected types for any refresh kind.
// Note we remove types for CREATION request because we could have cached misses to the type name.
// Since Java 10 javac uses .sig files...
/*
//www.apache.org/licenses/LICENSE-2.0
//      LambdaToMethod.instance( ctx ),
//      Lower.instance( ctx ),
//      MemberEnter.instance( ctx ),
//      TransTypes.instance( ctx ),
//      TypeAnnotations.instance( ctx ),
// Reassign Log fields
// Note this is only relevant when compiling with annotation processors
// Also reassign the 'log' fields in Check's various MandatoryWarningHandlers...
//noinspection StatementWithEmptyBody
// For @Jailbreak assignments, change error to warning re final var assignment
//## todo: the error message can't be converted to a warning, make up a custom warning
// report( diags.warning( source, pos, key, args ) );
//noinspection ConstantConditions
// found method in superclass, already recorded any issues from that attempt
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//override Java 9+
/**
// todo: passing raw characters means we must parse string literal escaped chars esp. '"', '\n', unicode
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// If using JavaParser.compile(), say from Lab, we don't care about modules, otherwise we run into trouble
/*ModuleElement*/ ms : (Iterable)ReflectUtil.method( elementUtils, "getAllModuleElements" ).invoke() )
//noinspection unchecked
//noinspection unchecked
// must return the fragment's enclosing class name to infer the module
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// handle the case where the class itself is inaccessible:
//
// // the *type* must be @Jailbreak as well as the constructor
// com.foo.@Jailbreak PrivateClass privateThing = new com.foo.@Jailbreak PrivateClass();
// privateThing.privateMethod();
// ...
// Java 9 +
// Allow augmented classes to access modules as if defined in both the extended class' module and
// the extension class' module.
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
//noinspection ConstantConditions
// Replace self type with qualifier type
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// sort according to preferred order
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// will become .java files
// wil become .javaX files
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//!! Note we preload because some environments (maven cough) reuse closed URLClassLoaders from earlier Javac runs,
//!! which will barf when trying to load any classes not already loaded e.g., those loaded during getCharContent() below
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// include private members because:
// 1. @Jailbreak can expose private members
// 2. Compiler error messages are better when referencing an inaccessible method vs. a non-existent one
//        long modifiers = SrcAnnotated.modifiersFrom( sym.getModifiers() );
//        if( Modifier.isPrivate( (int)modifiers ) )
//        {
//          continue;
//        }
// Add default no-arg ctor because enum constant stubs do not call a ctor explicitly
// Modifier.VARARGS
// Note we can't just throw an exception for the ctor body, the compiler will
// still complain about the missing super() call if the super class does not have
// an accessible default ctor. To appease the compiler we generate a super(...)
// call to the first accessible constructor we can find in the super class.
//noinspection ConstantConditions
//noinspection ConstantConditions
// Since java 10 we have to keep these out of stubbed java source
// Since java 10 we have to keep these out of stubbed java source
// cast to disambiguate when used as an argument
/*
//www.apache.org/licenses/LICENSE-2.0
/**
///" + name.replace( '.', '/' ) + Kind.SOURCE.extension ), Kind.SOURCE );
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//  @Override
//  public boolean filterError( Diagnostic diagnostic )
//  {
//    for( ITypeManifold sp: RuntimeManifoldHost.get().getSingleModule().getTypeManifolds() )
//    {
//      if( sp instanceof ITypeProcessor )
//      {
//        if( ((ITypeProcessor)sp).filterError( this, diagnostic ) )
//        {
//          return true;
//        }
//      }
//    }
//    return false;
//  }
// avoid re-entry of dynamic jdk construction
//JavacProcessingEnvironment.instance( getContext() ).getMessager().printMessage( Diagnostic.Kind.NOTE, "Processing: " + element.getQualifiedName() );
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//noinspection ResultOfMethodCallIgnored
//noinspection ResultOfMethodCallIgnored
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//= null;
//System.out.println( "WARNING: Can't wrap loader: " + loader.getClass().getTypeName() );
// we don't bother messing with any loaders above the system loader e.g., ExtClassLoader
/*
//    boolean bSysLoader = loader == ClassLoader.getSystemClassLoader();
//    if( bSysLoader )
//    {
//    }
//    else
//    {
//      ClassLoader parent = loader.getParent();
//      canWrap = wrapped != null && (parent == null || canWrapChain( parent ));
//    }
//" + loaderAddress + "/";
//    try
//    {
//      url = new URL( null, spec );
//    }
//    catch( Exception e )
//    {
// If our Handler class is not in the system loader and not accessible within the Caller's
// classloader from the URL constructor (3 activation records deep), then our Handler class
// is not loadable by the URL class, so we do this...
//    }
// Do not add protocol package since OSGi implementation of URLStreamFactory
// first delegates to those and only then calls service from Service Registry
// Remove our protocol from the list
// flag to prevent re-entry
//!! Do Not Rename or Remove this method.  Calls to it are generated by the compiler and javac hook.
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//ReflectUtil.method( classPath, "initLoader", URL.class, ReflectUtil.type( "com.intellij.util.lang.Loader" ) ).invoke( url, urlLoader );
//## todo: log error
//noinspection ConstantConditions
//## todo: log error
/*
//www.apache.org/licenses/LICENSE-2.0
//import java.lang.module.ModuleReader;
//import jdk.internal.loader.Resource;
//import jdk.internal.loader.URLClassPath;
/**
//implements ModuleReader
/*ModuleReader*/_delegate;
/*URLClassPath*/ _ucp;
/*ModuleReader*/ delegate, Object /*URLClassPath*/ ucp )
//@Override
//@Override
/*Resource*/ resource = ReflectUtil.method( _ucp, "getResource", String.class, boolean.class ).invoke( name, false );
//@Override
/*Resource*/ resource = ReflectUtil.method( _ucp, "getResource", String.class, boolean.class ).invoke( name, false );
//@Override
//@Override
//@Override
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Already visited
/*<ModuleReference, ModuleReader>*/ moduleToReader = (Map)ReflectUtil.field( _loader, "moduleToReader" ).get();
//noinspection unchecked
//## note: "jmod" files are not supported here because they are currently (2018) supported exclusively at compiler/linker time
/*ModuleReader*/ proxy = Proxy.newProxyInstance( moduleReaderClass.getClassLoader(), new Class<?>[]{moduleReaderClass},
//noinspection unchecked
/*ManModuleReader*/ _wrapper;
/*ManModuleReader*/ wrapper )
//## todo: look at other JRE impls (IBM) to see if they provide a different class loader / field name (other than Oracle's BuiltinClassLoader)
/*<String, ModuleReference>*/nameToModule = (Map)nameToModuleField.get();
//noinspection unchecked
//## note: "jmod" files are not supported here because they are currently (2018) supported exclusively at compiler/linker time
//noinspection unchecked
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Preload the Url Connection classes to prevent LinkageErrors during demo load
//## todo: we should try hard so that this never happens -- the type sys tries to resolve inner classes,
// which come back around here and always fail
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//noinspection deprecation
// Some tools (Equinox) expect to find a jar manifest file in the path entry, so we fake an empty one here
// If there were a class file for the Java type on disk, it would have loaded by now (the manifoldclass protocol is last).
// Therefore we compile and load the java class from the Java source file, eventually a JavaType based on the resulting class
// may load, if a source-based one hasn't already loaded.
// tools.jar likely not in the path...
// Avoid compiling until the bytes are actually requested;
// sun.misc.URLClassPath grabs the inputstream twice, the first time is for practice :)
//System.out.println( "Compiling: " + _type.getName() );
//        if( _bytecodeSupplier != null )
//        {
//          _buf = _bytecodeSupplier.get();
//        }
//noinspection ResultOfMethodCallIgnored
//noinspection ResultOfMethodCallIgnored
//noinspection ResultOfMethodCallIgnored
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
//noinspection unchecked
//noinspection unchecked
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// both endpoints included
// left endpoint excluded
// right endpoint excluded
// both endpoints excluded
// provides a `step` clause
// provides a `unit` clause
// test for range membership
// negative test for range membership
/**
/** Comparable */
/** Sequential */
/** BigDecimal */
/** BigInteger */
/** Double */
/** Long */
/** Integer */
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
//noinspection unchecked
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
//=================================================================
// Straight stream pass throughs
//=================================================================
//=================================================================
// Remove Optional
//=================================================================
//=================================================================
// Embellishments
//=================================================================
/**
//noinspection unchecked
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// expected
// expected
/**
// expected
// expected
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Dark Java files are intended to be compiled dynamically at runtime, they
// should never be compiled statically, otherwise just use normal Java.
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Dark Java is only available at runtime, bootstrap runtime
// Use reflection to work with Dark Java
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
//example.com/test" );
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//
// For now these are only used in the IntelliJ plugin
//
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
//noinspection ConstantConditions
//noinspection ConstantConditions
//noinspection ConstantConditions
//noinspection ConstantConditions
//noinspection ConstantConditions
//noinspection ConstantConditions
//noinspection ConstantConditions
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// Nominally implements ICallHandler
// Structurally implements ICallHandler
// maybe has an extension satisfying ICallHandler
// Nominally implements ICallHandler
// Structurally implements ICallHandler
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Interface methods
/*append( getTypeVarList( mi ) ).append( ' ' ).*/append( returnType.getCanonicalName() ).append( ' ' ).append( mi.getName() ).append( "(" );
//## todo: maybe we need to explicitly parameterize if the method is generic for some cases?
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//## todo: if fqn (the extension class) is source file, delegate the call to makeSrcClassStub() to the host somehow
//## todo: so that IJ can use it's virtual file, otherwise this uses the file on disk, which does not have local changes
// _location );
// short-circuit e.g., extension producers
//## todo: This is disabled because it involves calls to ClassSymbols#getClassSymbol() where another javac compiler task
//## todo: is spawned which can lead to perf problems because the same graph of types is recompiled over and over.
//## todo: Instead find a different way to get the type information e.g., ASM, dumb AST trees, etc.
//## todo: -- or ---
//## todo: Instead of checking for duplicates at this time, wait and do it during type processing i.e.,
//    if( warnIfDuplicate( method, extendedType, errorHandler ) )
//    {
//      return;
//    }
// the class is a produced class, therefore we must delegate the calls since calls are not replaced
// extension method must be default method in interface to not require implementation
//## Don't mark extension methods on classes as final, it otherwise blocks extended
//   classes from implementing an interface with the same method signature
//    else
//    {
//      // extension method must be final in class to prohibit override
//      modifiers |= Modifier.FINAL;
//    }
// remove static for instance method
// mark as extension method for efficient lookup during method call replacement
// extension method must reflect extended type's type vars before its own
// exclude This param
// delegate to the extension method
// stub the body
//## note: we are checking interfaces even for a non-abstract class because it could be
//## inheriting default interface methods, which must not be shadowed by an extension.
//noinspection SimplifiableIfStatement
//noinspection SimplifiableIfStatement
// checking only for simple name for cases where the name cannot be resolved yet e.g., extension method on another source producer type
//  private Symbol.MethodSymbol resolveMethod( Context ctx, JCDiagnostic.DiagnosticPosition pos, Name name, Type qual, com.sun.tools.javac.util.List<Type> args )
//  {
//    Resolve rs = Resolve.instance( ctx );
//    AttrContext attrContext = new AttrContext();
//    Env<AttrContext> env = new AttrContextEnv( pos.getTree(), attrContext );
//    env.toplevel = _tp.getCompilationUnit();
//    return rs.resolveInternalMethod( pos, env, qual, name, args, null );
//  }
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//## note: this is pretty sloppy science here, but we don't want to parse
// java or use asm here i.e., handlesFile() this has to be *fast*.
// .class file
// eat
// Include types extended by dynamically provided extension classes from IExtensionClassProducers
//## todo: This applies only to precompiled Java class files.
//## todo: Need to move this method to IManifoldHost for different use-cases (class files, javac symbols, and IJ psi)
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Don't process tree during GENERATE, unless the tree was generated e.g., a bridge method
// Handle operator overload expressions
// Equality requires null check before calling compareTo/Using():
//
// a == b
// ? true/false
// : a == null || b == null
//   ? false/true
//   : a.compareToUsing( b, op );
// (x > y) generated as: (x.compareTo(y) > 0)
// (x > y) generated as: (x.compareToUsing(y, GT))
// Create a temporary variable and corresonding identifier to avoid cop
// If methodCall is an extension method, rewrite it
// Replace with extension method call
// Concrete type set in attr
/**
// since the source may be preprocessed we attempt to get it in its preprocessed form
/** Expand a boxing or unboxing conversion if needed. */
//e.g. Character c = 89;
/** Box up a single primitive expression. */
/** Box up a single primitive expression. */
/** Unbox an object to a primitive value. */
// There must be a conversion from unboxedType to primitive.
// x.intValue()
/**
// Don't process tree during GENERATE, unless the tree was generated e.g., a bridge method
// Flag.Flag.PARAMETER.value
// Don't process tree during GENERATE, unless the tree was generated e.g., a bridge method
/**
// Don't process tree during GENERATE, unless the tree was generated e.g., a bridge method
// Flag.Flag.PARAMETER.value
// Don't process tree during GENERATE, unless the tree was generated e.g., a bridge method
// Don't process tree during GENERATE, unless the tree was generated e.g., a bridge method
// +=, -=, etc. operators not supported with jailbreak, only direct assignment
// Don't process tree during GENERATE, unless the tree was generated e.g., a bridge method
// handle negation overload
// Handle operator overload expressions
// If methodCall is an extension method, rewrite it accordingly
// Replace with extension method call
// ++, -- operators not supported with jailbreak access to fields, only direct assignment
// Don't process tree during GENERATE, unless the tree was generated e.g., a bridge method
// Don't process tree during GENERATE, unless the tree was generated e.g., a bridge method
// if the type itself is inaccessible and annotated with @Jailbreak, it will be erased to Object
// Don't process tree during GENERATE, unless the tree was generated e.g., a bridge method
// Don't process tree during GENERATE, unless the tree was generated e.g., a bridge method
// type
// the javac compiler generates casts e.g., for a generic call such as List#get()
// don't erase cast if we generated it here e.g.., for structural call cast on constructProxy
/**
// handle compiler-generated call to iterator(), sometimes a structural interface is involved here (lists in JSON)
// Don't process tree during GENERATE, unless the tree was generated e.g., a bridge method
// Replace with extension method call
// The structural interface method is implemented directly in the type or supertype hierarchy,
// replace with proxy call
// Method references not supported on extension methods
// Method references not supported on structural interface methods
// called reflectively from manifold core
// Called reflectively from manifold core
//## todo: shouldn't happen
// @Self not allowed on type param
// @Self allowed only on return type and parameters of an instance method
// @Self allowed only on class var, not local var
// This call surfaces the type in the compiler.  If compiling in "static" mode, this means
// the type will be compiled to disk.
// Keep track of Manifold types compiled, for hotswap compile drivers
// Ensure modified resource files are compiled, stemming from incremental compilation only
//noinspection unchecked
// nothing to compile
// This call surfaces the type in the compiler.  If compiling in "static" mode, this means
// the type will be compiled to disk.
// not a Manifold generated type
// nothing to add
// Keep track of compiled Manifold types during a Rebuild.
//
// Generally, since Manifold types are magically added to the build as
// they are referenced, they need to be mapped in the JPS compilation
// process to support hotswap debugging, etc.
//noinspection unchecked
// extension interfaces must be structural
/**
// we process bridge methods during Generation, since they don't exist prior to Generation
// Don't process tree during GENERATE, unless the tree was generated e.g., a bridge method
// Keep track of anonymous classes so we can process any bridge methods added to them
//    if( JavacPlugin.instance() == null )
//    {
//      // don't perform verification at runtime, slow
//      return;
//    }
// an extended class could be made a structural interface which results in Object as @This param, ignore this
// should not really get here, but should be static block scope if possible
// field initializers have a block scope
//## todo: maybe try to avoid reflection if the method is accessible -- at least check if the method and its enclosing nest of classes are all public
// No such field/method or wrong params
// receiver or class
// method name
// param types
// args
// handled in visitAssign() or visitAssignOp()
// supporting -, +, !, ~  not supporting --, ++
// No such field/method
// receiver or class
// field name
// receiver or class
// field name
// field value
//assert tree.constructor.kind == com.sun.tools.javac.code.Kinds.ERR;
// the class
// param types
// args
// class is publicly accessible, assume we can use class literal
// generate `ReflectUtil.type( typeName )`
//JavacHook.instance() != null ? (JavacTaskImpl)JavacHook.instance().getJavacTask_PlainFileMgr() : ClassSymbols.instance( _sp.getModule() ).getJavacTask_PlainFileMgr();
// In module mode if a package in another module is not exported, classes in the package
// will not be accessible to other modules, hence the null classSymbol
// This can happen during bootstrapping with Dark Java classes from Manifold itself
// So we short-circuit that here (ManClassFinder_9 or any other darkj class used during bootstrapping doesn't really need to use extensions)
//## todo: cache these
//## todo: cache these
//## todo: cache this
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// do not throw here, file creation events sometimes come in late after the
// model is created with a newly created file e.g., the Create Extension Class dialog
//
// throw new IllegalStateException( "Model already contains " + file.getName() );
/*
//www.apache.org/licenses/LICENSE-2.0
//noinspection ConstantConditions
//noinspection ConstantConditions
//noinspection ConstantConditions
//noinspection ConstantConditions
/*
//www.apache.org/licenses/LICENSE-2.0
// return findCachedProxy( root, iface ); // this is only beneficial when structural invocation happens in a loop, otherwise too costly
//## note: we'd like to avoid the operation if the obj not a ICallHandler,
// but that is an expensive structural check, more expensive than this call...
//  if( obj is a ICallHandler )
//  {
//   }
/**
// Person is a JsonTypeManifold interface; the runtime type of person here is really just a Map (or Binding)
// Extension method[s] satisfying IMyStructureThing on Person make this work e.g., via MyPersonExt extension methods class
// foo() is an extension method on Person e.g., defined in MyPersonExt, however the runtime type of thing is just a Map (or Binding) thus the Person type identity is lost
//## todo: this is inefficient, we should consider caching the methods by signature along with the interfaces
/**
//noinspection unchecked
// empty string is null e.g., CSV empty values are empty strings
//noinspection unchecked
// let the ClassCastException happen
// in Java 9+ in modular mode the proxy class belongs to the owner's module,
// therefore we need to make it accessible from the manifold module before
// calling newInstance()
//noinspection unchecked
// The self-proxy strategy avoids costs otherwise involved with generating and compiling the proxy at runtime via
// ICallHandler
// If the proxy factory declared in @Structural handles the rootClass, create the proxy via the factory
// See if there is a registered IProxyFactory for the rootClass and iface, so create one that way,
// otherwise return null
//noinspection ConstantConditions
// In Java 9+ in modular mode the proxy factory class belongs to the owner's module,
// therefore we need to use the constructor and make it accessible from the manifold module
// before calling newInstance() (as opposed to calling newInstance() from the class)
//return (IProxyFactory)factoryClass.newInstance();
//noinspection unchecked
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//  @Override
//  public Type visitMethodType( Type.MethodType mt, Void aVoid )
//  {
//    boolean erased = false;
//    ArrayList<Type> paramTypes = new ArrayList<>();
//    for( Type paramType: mt.getParameterTypes() )
//    {
//      Type param = visit( paramType );
//      if( param != paramType )
//      {
//        erased = true;
//      }
//      paramTypes.add( param );
//    }
//    Type returnType = visit( mt.getReturnType() );
//
//    if( returnType != mt.getReturnType() )
//    {
//      erased = true;
//    }
//    if( erased )
//    {
//      List<Type> pt = List.from( paramTypes );
//      mt = new Type.MethodType( pt, returnType, mt.getThrownTypes(), mt.asElement() );
//    }
//    return mt;
//  }
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Interface methods
/*append( getTypeVarList( mi ) ).append( ' ' ).*/append( returnType.getCanonicalName() ).append( ' ' ).append( mi.getName() ).append( "(" );
//## todo: maybe we need to explicitly parameterize if the method is generic for some cases?
// try not to let a field match when a method should match
// try not to let a field match when a method should match
//## todo:
//return isStructurallyAssignable( mi.getOwnersType(), type, mi, new TypeVarToTypeMap() );
//## todo:
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// use the raw type
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/** Use the {@code #compareTo()} method to implement `==` and `!=` */
/** Use the {@code equals()} method to implement `==` and `!=` (default) */
/** Use {@code identity} comparison for `==` and `!=`, note this is the same as Java's normal {@code ==} behavior } */
/** The method used to handle {@code ==} and {@code !=} */
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//manifold.systems/docs.html#type-safe-reflection">Type-safe Reflection</a> documentation for
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//manifold.systems/docs.html#the-self-type">Self Type</a> documentation
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//manifold.systems/docs.html#structural-interfaces">Structural Interfaces</a>
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//noinspection unchecked
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// Using LinkedHashMap to preserve insertion order, an impl detail currently required by the IJ plugin for rename
// refactoring i.e., renaming a json property should result in a source file that differs only in the naming
// difference -- there should be no difference in ordering of methods etc.
// eof
/*
//www.apache.org/licenses/LICENSE-2.0
//noinspection ConstantConditions
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// this test exercises ext-producer on a manifold type
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/**
//noinspection ResultOfMethodCallIgnored
//noinspection ResultOfMethodCallIgnored
//noinspection ResultOfMethodCallIgnored
//    leaf.foo(leaf.foo(leaf.foo(8)), false);
//    leaf.foo(leaf.foo());
//
//    leaf.foo("err");
//    leaf.foooo();
//
//    Leaf leaf2 = new Leaf();
//    leaf2.foo();
//    leaf2.foo(9);
//    leaf2.foo(9.0d);
//
//    leaf2.foo(leaf2.foo(8));
//    leaf2.foo(leaf2.foo());
//
//    leaf2.foo("err");
//    leaf2.foooo();
// instance method
// static method
// instance field
// static field
// new expr
// Test a class that is extended
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// returns CarBuilder
//    Bar bar = zeeBar.getMe();
//    bar.barMethod();
//    Bar[] bars = zeeBar.getArrayFoo();
//    zeeBar.addChild( new Bar() );
//    Bar child = zeeBar._children.get(0);
//"".hi();
//java.util.Date date = new java.util.Date( asdfg );
/**
/**
//assertEquals( "ok", list.stiff( "hi" ) );
// asserts object identity is not lost
// asserts object identity is not lost
// asserts object identity is not lost
// expected, cannot use structural type outside module scope of declared @Structural
// implements ITestFields
//implements Coordinate
// implements Coordinate
// implemnets Runnable
// implemnets Runnable
/**
// test warning for missing @This
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/** for static ext method test */
/**
//  // error, overloads method in StringBuffer
//  public static void append( @This StringBuffer thiz ) {}
//
//  // error, overloads method in CharSequence
//  public static void chars( @This StringBuffer thiz ) {}
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
// make Callable a structural interface
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//noinspection deprecation
// Date month is 0-based
// still a date, only a Chrono upon Chrono invocation
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// not public
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//localhost:8080/graphql?query=mutation+M{newTodo:createTodo(text:"This+is+a+mutation+example"){text+done}}'
//localhost:8080/graphql -H 'Content-Type: application/graphql' -d 'mutation M { newTodo: createTodo(text: "This is a mutation example") { text done } }'
//localhost:8080/graphql -H 'Content-Type: application/json' -d '{"query": "mutation M { newTodo: createTodo(text: \"This is a mutation example\") { text done } }"}'
/**
//en.wikipedia.org/wiki/List_of_HTTP_header_fields">HTTP header fields</a>
/**
/**
//[domain]/[oauth-service]
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
//noinspection unchecked
// used for tests
//noinspection unchecked
//noinspection unchecked
// DO NOT CHANGE THIS TO A LAMBDA, YOU WILL HAVE BAD LUCK FOR 9 YEARS
//noinspection Convert2Lambda
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// types, interfaces, unions, inputs, scalars, extensions
// register scalar type
// queries, mutations, subscriptions
// fragments
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Queries and mutations are the same thing -- web requests
// todo:
//noinspection unused
// Map of union type member to union types, facilitates nominal typing (for performance) e.g.,
//
//     union PointyShape = Triangle | Diamond
//
//     interface PointyShape { /* intersection methods of Triangle and Diamond */ }
/* intersection methods of Triangle and Diamond */ }
//
// Since we model a union as an interface consisting of the intersection of methods of its member types, by
// definition the member types logically implement the union, therefore the member type explicitly declares that it
// implements all unions of which it is a member:
//
//     interface Triangle extends PointyShape { ... }
//
// Thus we can nominally address a Triangle as a PointyShape:
//
//     PointyShape pointy = triangle;
//
// Note because we model graphql types as *structural* interfaces the nominal typing added here is unnecessary --
// because PointyShape is structural we could cast triangle. However, from a performance standpoint it is worthwhile
// because it saves us the initial cost of dynamic proxy generation, which otherwise adds considerable lag on first
// use.
// Queries and mutations are the same thing -- web requests
// todo:
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
// e.g., by convention a 'type' named "Query" is considered the root query type
// if one is not specified in the 'schema'
// The discriminator for the union
//noinspection unused
//noinspection unused
//## no setters for queries?
//      SrcSetProperty setter = new SrcSetProperty( propName, type )
//        .modifiers( Flags.DEFAULT )
//        .body( "getBindings().put(\"$name\", " + RuntimeMethods.class.getSimpleName() + ".coerceToBindingValue(${'$'}value));\n" );
//      addActualNameAnnotation( setter, name, true );
//      addSourcePositionAnnotation( srcClass, field, name, setter );
//      srcClass.addSetProperty( setter ).modifiers( Modifier.PUBLIC );
// assume the parser exposes the error
//noinspection unused
//noinspection unused
//## no setters for queries?
//      SrcSetProperty setter = new SrcSetProperty( propName, type1 )
//        .modifiers( Flags.DEFAULT )
//        .body( "getBindings().put(\"$name\", " + RuntimeMethods.class.getSimpleName() + ".coerceToBindingValue(${'$'}value));\n" );
//      addActualNameAnnotation( setter, name, true );
//      addSourcePositionAnnotation( srcClass, field, name, setter );
//      srcClass.addSetProperty( setter ).modifiers( Modifier.PUBLIC );
//noinspection unused
//noinspection unused
//## no setters for queries?
//      SrcSetProperty setter = new SrcSetProperty( propName, type1 )
//        .modifiers( Flags.DEFAULT )
//        .body( "getBindings().put(\"$name\", " + RuntimeMethods.class.getSimpleName() + ".coerceToBindingValue(${'$'}value));\n" );
//      addActualNameAnnotation( setter, name, true );
//      addSourcePositionAnnotation( srcClass, field, name, setter );
//      srcClass.addSetProperty( setter ).modifiers( Modifier.PUBLIC );
// inner interface of Result interface
/**
/**
/**
// There are two fields that differ in name only by the case of the first character "Foo" v. "foo".
// Since the get/set methods capitalize the name, we must differentiate the method names
// e.g., getFoo() and get_foo()
//noinspection unused
//noinspection unused
//noinspection OptionalGetWithoutIsPresent
// no common interface
// can only use one
// skip space
// not a scalar type, therefore it must be a 'type'
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// The Gql interfaces know how to convert value
/* [> MyEmbedded.graphql <]
/**[>MyEmbedded2.graphql<]
/*
//www.apache.org/licenses/LICENSE-2.0
// no cast
// no cast
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
//
// todo
//
// todo: make a unique class for each Symbol *instance* where the class has a static field with the Symbol's name.
// Then generate code to statically import the field.
//todo: add call to "Highjump.getInitialValue(\"" + symbol.getUid() + '$' + symbol.getName() + "\")" which will
// get the initialValue from the _fqnToSymbol map.
//
// IFileConnected (not file connected...)
//
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
//    Object result = Highjump.instance().evaluate( "2 + 2", Collections.emptyList(), Collections.emptyList(), null );
//    result = Highjump.instance().evaluate( "3 + 2", Collections.emptyList(), Collections.emptyList(), null );
//    System.out.println( result );
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//= FileWalkDirection.TOP_DOWN;
// = Integer.MAX_VALUE;
/**
/**
/**
/**
// Stack of directory states, beginning from the start directory
// There is nothing in the state
// Take next file from the top of the stack
// There is nothing more on the top of the stack, go back
// Check that file/directory matches the filter
// Proceed to a root directory or a simple file
// Proceed to a sub-directory
/**
/**
// First visit all files
// Then visit root
// That's all
/**
/**
// First visit root
// Then read an array of files, if any
// Then visit all files
// That's all
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
//noinspection ResultOfMethodCallIgnored
/**
/**
/**
/**
/**
/**
/**
/**
// Check roots
// Annihilate differing base components by adding required number of .. parts
// Add remaining this components
// If some .. were appended
/**
/**
//network.name/root as possible root names.
//network.name/root, but can detect Windows roots like C:/.
// Note: separators should be already replaced to system ones
// Network names like //my.host/home/something ? => //my.host/home/ should be root
// NB: does not work in Unix because //my.host/home is converted into /my.host/home there
// So in Windows we'll have root of //my.host/home but in Unix just /
// C:\
// C:
/**
//network.name/root as possible root names.
//network.name/root, but can detect Windows roots like C:/.
/**
//my.host/home for //my.host/home/user
/**
/**
//noinspection ResultOfMethodCallIgnored
/**
/**
/**
/**
/**
/**
// We cannot break for loop from inside a lambda, so we have to use an exception here
//noinspection ResultOfMethodCallIgnored
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*buffer*/, Integer/*bytesRead*/> action )
/**
/*buffer*/, Integer/*bytesRead*/> action )
/**
/*line*/> action )
// Note: close is called at forEachLine
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/** Creates a reader on this input stream using UTF-8 or the specified {@code charset}. */
/** Creates a buffered reader on this input stream using UTF-8 or the specified {@code charset}. */
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/** Creates a writer on this output stream using UTF-8 or the specified {@code charset}. */
/** Creates a buffered writer on this output stream using UTF-8 or the specified {@code charset}. */
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/** Returns a buffered reader wrapping this Reader, or this Reader itself if it is already buffered. */
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/** Returns a buffered reader wrapping this Writer, or this Writer itself if it is already buffered. */
/** Returns a buffered reader wrapping this Writer, or this Writer itself if it is already buffered. */
/**
//noinspection ResultOfMethodCallIgnored
/**
//    testCoverage(ManFileExt.class);
/*
//www.apache.org/licenses/LICENSE-2.0
//impl
// params
//impl
//impl
//noinspection unchecked
//noinspection unchecked
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
//noinspection unchecked
/*
//www.apache.org/licenses/LICENSE-2.0
//Calls the generated renderToString function with raw strings from template
//make argument list including the raw string list
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
//Constructor sets the src from which the parser reads
//Can only import classes at top of program
//Maybe parse class
//Parse program otherwise
//parse class name
//parse any super classes
//parse class body
//TODO: learn semi-colon syntax
//properties and functions can both be static
//'constructor'
//name of function
//Name of function
// property identifier
/*Concats parameters into a node*/
//ending paren or comma can follow identifier
//identifier must follow commas
/* Function: parseReturnType
/* Function: parseType()
/*starting from the opening parens for function parameters, parses the function params, return type,
/*Parses filler code and adds onto parent, as well watching for es6 features such as arrow functions
//Pause when seeing an arrow so we can add an arrow node
//Add filler node and create a new one
//continue parsing filler after consuming arrow node
//Pause when we see a backtick, and use the template parser to consume the template string
//continue parsing filler after consuming template string
//Pause when we see a function declaration to parse typescript style types
//reached the end token passed in to the argument; end parsing filler
//Concatenate tokens onto a filler node until a token is matched
//========================================================================================
// Utilities
//========================================================================================
/*Concats current token to a string builder*/
//Used to create lambda functions for matching tokens
/*assert an expectation for the current token then skip*/
/*Match single character punctuation*/
/*Match operators*/
/*Match reserved keywords only*/
/*Matches conditional keywords such as "constructor", which are sometimes keywords within a class
//If these class keywords aren't followed by an identifier, treat them as regular identifiers
//TODO: figure out when overriding java method if neccessary
//    IType superType = TypeSystem.getByFullName(packageName);
//    if (superType == null) return false;
//    for (IMethodInfo method : superType.getTypeInfo().getMethods()) {
//      if (method.getDisplayName().equals(functionName)) return true;
//    }
/*Move current token to the next token (including whitespace)*/
/*Move current token to the next non-whitespace token*/
/*
//www.apache.org/licenses/LICENSE-2.0
//Expressions either start with <% and and with %>; or start with ${ and end with }
/*Match template specific punctuation only*/
/*
//www.apache.org/licenses/LICENSE-2.0
//true if a JST template file, false if a template literal in a Util file
//token that enters an expressionOrStatement
//maps enter punctuation to exit punctuation (ex: "${" : "}")
//used to match curlies when exiting an expression
//transition from expression to rawstring
//if in statement, tokenize as normal
//transition from rawstring to expression; ${, <%, <%@, or <%=
//
// Entrance punctuations
//
//should be '{'
//
// Exit punctuations
//
//should be '>'
//skip over the \r in \r\n for windows files
//escape newlines since template literals can be multiline
//If escaped, skip escape character and return false
//'}' only exits expression if it matches with at the top of the stack ${
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
//Keeps track of beginning position of tokens
//Keeps track of current position of tokenizer
//Line number and col are 1 indexed; offset is 0 indexed (nextchar increments col and offset)
//keep track of position when we begin consuming a token
//For numbers that start with the decimal point
/*Forward slash will either result in a single line comment, multiline comment, or a operator token*/
//Throw away comments
/*Possible numbers are integers (decimal, hex, octal or binary)
//Mark if explicitly hex, octal, or binary
//Octal is implied if number starts with 0, but can still be dec if a 8 or 9 follows
//Limit one decimal point to floating point num
//Only dec can have decimal points
//changes octal to dec, so 0777 will be octal and 0778 will be dec
//If explicitly starts with 0x, 0o, or 0b; throw an error if nothing after
/* Helper for consume number; Consumes the exponent segment of a number, which will start with e (or E),
//consume 'e' or 'E'
//Consume optional + or -
/* Consumes and returns an word (either a identifier, keyword, boolean literal, or null)
/* Syntax for string literal taken from emca 6 language specs 11.8.4
//Can be either ' or "
//Consume string until we find a non-escaped quote matching the enter quote
//error if EOF comes before terminating quote
//error if line terminator in string
//Make sure escape sequences are legal
//add closing quote
/* Consume template string as a entire raw string. Template tokenizing and parsing are handled
//skip over `
//skip over closing backtick
/*Helper to consume and validate escape sequences;
/* Consumes single escapes (' " \ b \f n r t v), and non-escaped (such as 'a' where \ will be ignored)
/*Unicode escape sequence are either uHexHexHexHex or u{Hex+}*/
//consume 'u'
//keep track of hex number to check if valid unicode
//consume closing }
//error if exceeds max unicode number
//Must have exactly 4 hex digits in this pattern
/*hex escape sequences must be uHexHex*/
//consume 'x'
/*Consumes punctuation, which are all single characters*/
/*Keep consuming until we reach a non operator character or when adding the character makes a
/*" );
//Consume first two chars, which we know make '/*'
/*'
//error if EOF comes before terminating quote
//append closing slash
//" );
//Consume first two chars, which we know make '//'
//========================================================================================
// Utilities
//========================================================================================
//Returns the next character in the stream without updating _ch
//Updates the start token position when consuming a new token
/*
//www.apache.org/licenses/LICENSE-2.0
//For template files
//Keywords taken from ecma-262 6 11.6.2.1, excluding class which is its own token
//Taken from mozilla expressions and operators guide
//Assignment operators
//Comparator operators
//Arithmetic operators
//Bitwise operators
//Logical operators
//Ternary operators
//Arrow operator
//Rules for identifier names from emca-262 section 11.6.1
//todo: add unicode characters
//Taken from emca 6 language spec 11.3
/*
//www.apache.org/licenses/LICENSE-2.0
//If prev token is not ')', then there is only one parameter
//Otherwise, backtrack through list until opening parens
//## todo: this was ok with nashorn, but maybe not with rhino...
/*For expressions, use closure extension function (ex. function square(x) x*x;)*/
/*
//www.apache.org/licenses/LICENSE-2.0
//Test constructors
//If it's an override function, give as key value pair for Java.extend codegen from ClassNode
//If static, can be method of class directly
/*
//www.apache.org/licenses/LICENSE-2.0
/*Boiler plate code segments taken from babel.js*/
//Used for defining object properties
//Used to make sure classes can not be called as a function
//name of generated supertype object
//Makes sure constructor is called correctly
//Defines getters and setters
//Gen default constructor if no child found
//Should only have one constructor
//If superclass exists, instantiate superclass object inside constructor
//Create extended superclass object
//Add overridden methods
//Create property reference for the superclass object
//Create method for getting super object
//Possibly give superclass as arg
//Wrapper to hold getters and setters for the same property
//combines getters and setters for each property
//Separate static and non-static properties
//Get wrapper by property name, and insert name
//Combine the properties into an array
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*(Hopefully) Temporary Node to hold tokens that we don't parse and blindly concatenate*/
/*Either consists of a list of tokens or just a string of concatenated tokens*/
//Replace super with Java.super(_superClassObject) to support java-style super
//needs "this._superClassObject" to reference super if not function does not override
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/* Generates ES5 code */
/*
//www.apache.org/licenses/LICENSE-2.0
//Takes in parameter and type in string form
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*Returns the full package name of imported class (ex. java.util.ArrayList)
/*
//www.apache.org/licenses/LICENSE-2.0
//Test Constructor
//Should have one FunctionBodyNode child
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*Serves as the root for template files (.jst) . Generates a function with the template parameters as well as a
//boiler plate code for constructing string
//javascript variable that builds and returns string
//parameter of raw strings inputted into the template
//name of function; leaves room for parameters
//initializes str builder
//Add the header and parameters for the generated function
//Keep track of number of raw strings added to know which index of the raw string array to add
//Add whatever the expression evaluates to into the generated code
//Statement code not directly included in template output; instead is simply added into the genCode logic
/*raw strings will be passed into the function as a list, so just add the element from the argument list*/
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*Holds template literals inside javascript files. Supports interpolation and multiline characters*/
/**
//import demo.ExtendedArrayList;
//    ExtendedArrayList extendedArrayList = new ExtendedArrayList();
//    List asList = extendedArrayList;
//
//    asList.add(1);  // Overwritten function add, prints what was added when called
//    asList.add(2);
//    asList.add(3);
//
//    assertEquals(3, extendedArrayList.size());
//    assertEquals(42, extendedArrayList.demo());
/**
//success
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//tools.ietf.org/html/rfc4180">RFC 4180</a>. Note data in all fields is enclosed in double quotes.
/**
//tools.ietf.org/html/rfc4180">RFC 4180</a>. Note data in all fields is enclosed in double quotes.
// single entry with no name implies root, defer to the root
//todo: factor out Csv.CSV_DEFAULT_ROOT
// a single row of data consisting of the name/value pairs in the map
// A list of data
// a single row of data consisting of just one column of the name/value pair
// Csv header
// row of data
// single column of data
// Csv records
// Lists of lists not supported with CSV, just dumping text for each element to a single value
// single column of data
//json-schema.org/draft-04/schema#" );
// indicates this schema is not directly in the data file
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// leading/trailing whitespace significant?
// skip whitespace
// is quoted?
// when sampling favor the probability that one of these chars is the actual separator
// Assume NOT quoted because more data follows what would be a closing quote; let's be lenient and let
// this value be non-quoted (as opposed to making this an error).
//todo: add a warning here
// backtrack to quote
// separator
//todo: if quoted, add warning about missing terminal '"'
//noinspection ForLoopReplaceableByForEach
// EOF
// all header fields must be non-empty
// more fields in data row than header row! bail
// empty values are excluded from analysis
// more fields in header row than data row! bail
// skip header
// more fields in data row than header row! bail
// more fields in header row than data row! bail
// all null sample values for a column => String.class
// nothing merges with string
// nothing merges with boolean
// empty data does not contribute toward type inference
// none of the separators resulted in a consistent record size (rows had differing number of fields)
// default to comma, but the file may parse with errors
// always return '\n' as linebreak
// EOF
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/** Loader is a fluent API with methods for loading content from String, URL, file, etc. */
/** Writer is a fluent API to write this JSON object in various formats including JSON, YAML, CSV, and XML */
/** Provides a deep copy of this list */
//noinspection unchecked
/** For Internal Use Only */
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
// handle case for mixed array where component types are different (object and array)
// handle case for mixed array where component types are different (object and array)
// Empty list implies dynamic component type
// if the existing type is dynamic, override it with a more specific type,
// otherwise the types disagree...
// Keep the more specific type (Dynamic type is inferred from a 'null', thus the more specific type wins)
// Keep the more specific type
// merge the types
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//
// JSON methods
//
//
// YAML methods
//
//
// XML methods
//
//
// CSV methods
//
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//example.com/users").getOne("/$id");
// or
//example.com/users")
// eg., using OAuth token
/**
//example.com/users")
// eg., using OAuth token
//example.com/users"
/**
/**
//en.wikipedia.org/wiki/List_of_HTTP_header_fields>HTTP header fields</a>
/**
/**
//[domain]/[oauth-service]
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
//noinspection unchecked
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// String is compatible with all simple types
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// this is most likely a "definitions" inner class
//noinspection unused
//noinspection unused
//      addSourcePositionAnnotation( sb, indent + 2, key );
//noinspection unused
//noinspection unused
//noinspection UnusedAssignment
// Add a static create(...) method having parameters corresponding with "required" properties not having
// a "default" value.
// Provide a loader(...) method, returns Loader<typeName> with methods for loading content from String, URL, file, etc.
// Provide a requester(urlBase) method, returns Requester<typeName> with for performing HTTP requests using HTTP GET, POST, PUT, PATCH, & DELETE
// Allow non-schema files to load from themselves easily, also corresponds with @FragmentValue added to toplevel class
//noinspection unused
/**
//noinspection unused
//noinspection unused
//noinspection unused
// Json Schema types must be identity compared
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//
// State used exclusively during code generation, after resolve
//
// Using State to encapsulate state which facilitates cloning
// (this state must be shared across cloned versions, only the TypeAttributes state is separate per clone)
// Using LinkedHashMap to preserve insertion order, an impl detail currently required by the IJ plugin for rename
// refactoring i.e., renaming a json property should result in a source file that differs only in the naming
// difference -- there should be no difference in ordering of methods etc.
//      if( type instanceof JsonStructureType )
//      {
//        resolveInvertedUnionMember( entry.getKey(), (JsonStructureType)type );
//      }
/**
// union supers are not included for code gen
// assign required names, removing names that do not correspond to a property, and marking such names with an error
// verify each name corresponds with a property
//noinspection unchecked
//noinspection unchecked
// look in inner types
// look in definitions (json schema)
// look in union types
// Keep the more specific type (the dynamic type was inferred from a 'null' value, which should not override a static type)
// if the existing type is dynamic, override it with a more specific type,
// otherwise the types disagree...
// dump stack to diagnose unexpected error
// this is most likely a "definitions" inner class
//noinspection unused
// Include methods from super interfaces that are inner classes of this type
// Since Java does not allow a type to extend its own inner classes.  Note such
// a super type is not in the extends list of this interface.
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
// If additionalProperties is not defined, defaults to 'true'
// note if additionalProperties is false, there can still be patternProperties if they are defined, hence
// checking both values
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection UnusedAssignment
//noinspection unused
// Java does not allow extending your own inner class,
// instead we will grab all the methods from this later.
// See renderProperties().
// Add a static create(...) method having parameters corresponding with "required" properties not having
// a "default" value.
// Provide a builder(...) method having parameters matching create(...) above and providing
// withXxx( x ) methods corresponding with non "required" properties
// Similar to builder(), copier() takes an instance to copy and has withXxx() methods, and a copy() method
// Add a simple copy method for a deep copy
// Provide a loader(...) method, returns Loader<typeName> with methods for loading content from String, URL, file, etc.
// Provide a requester(urlBase) method, returns Requester<typeName> with for performing HTTP requests using HTTP GET, POST, PUT, PATCH, & DELETE
// Allow non-schema json files to load from themselves easily, also corresponds with @FragmentValue added to toplevel class
//noinspection unused
//noinspection unused
/**
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
// constructor
//noinspection unused
//noinspection unused
//noinspection unused
// constructor
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
//noinspection unused
/**
// Json Schema types must be identity compared
//noinspection ConstantConditions
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// not storing in _bytes because the string is in the bindings
// release potentially large array
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//
// From JSON value to Java value
//
//
// From Java value to JSON value
//
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//github.com/OAI/OpenAPI-Specification/blob/3.0.0-rc0/versions/3.0.md#schemaObject">OpenAPI Specification</a>
//
// From JSON value to Java value
//
//
// From Java value to JSON value
//
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Handle enum type
// Handle format types
// Enum type & Union type
// Format types
//noinspection ConstantConditions
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Standard temporal formats (JSON Schema 6)
// Non-standard temporal formats
// Non-standard number formats (see also BigNumberFormatResolver)
//noinspection ConstantConditions
//noinspection ConstantConditions
//
// From JSON value to Java value
//
// "date-time"
// "date"
// "time"
// "utc-millisec"
// "int64"
//
// From Java value to JSON value
//
// "date-time", "date", "time"
// "utc-millisec"
// "int64"
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// this is most likely a "definitions" inner class
// Enum constants with values
// static URL field
// _value field
// Constructor
// toBindingValue() method
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
//## todo: maybe be smarter about merging two format types?
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Ideally the "$schema" element would be required, but JSON Schema does not require it.
// As a fallback check for "$id" as this is pretty uniquely Json Schema
// As a fallback to the fallback, check for: "type": "object" or "type": "array"
// As a fallback to the fallback to the fallback, check for: "properties": (lots of use-cases like this unfortunately)
// move issues from errant cached type to the actual type
// Find by ref "id"
// Find by ref "location path"
// an empty "#" ref must resolve to the enclosing URL
// If the original ref is prefixed with '#', it was removed by the URI parser, try prepending it and roll dice.
// (Not sure why the JSON Schema docs uses an example where the 'id' begins with '#', which is the fragment
// separator char in a URI...)
// ref looks like: "#someType/foo/bar"
// thus we first lookup "#someType", and prepend its path
// {
//   "definitions": {
//     "Foo": {
//       "$id": "#someType"
//       ...
//     }
//   }
// }
// "#someType/foo/bar => "#/definitions/foo/bar"
// not an id
// build a path to the type
// Cache by FQN
// Also cache by Id (if defined)
// Copy format type to allow format type services to reuse types
// refParent is just a placeholder for definitions until the ref or combo type is constructe.
// Assign the definitions from the refParent to the actual parent
//noinspection unchecked
// No type or other means of deriving a type could be found.
// Default type is Dynamic (in Java this is Object)
// Note the "const" type is shorthand for a single element "enum" type
//
// "required"
//
//
// "$ref"
//
//
// "enum"
//
// Note enunType can't really be a super type. Basically if any types in an "allOf" are enum, they all have
// to be, thus the code gen logic can turn this structure type into a single enum type collapsing all enums
// into one. This includes any $ref enum types that may be super types.
//
// "properties"
//
//
// allOf", "oneOf", "anyOf"
//
// special handling required for combo as super type
// support refs like: "#/properties/blah".  They are the same as: "#/blah"
// relative to this file
// absolute address
// assume file system relative path
// use use IFile if url is a file e.g., IDE file system change caching
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
// shared state across type copies
// non-shared state that is different per type copy
//noinspection unused
//## todo: this switch is ripe, should be configurable as part of AbstractJsonTypeManifold somehow?
// include fragment directly as string literal
// avoid using a string literal, file could be very large, instead reference the corresponding resource file
//## todo: using getFqn(), which may not correspond with resource file name
//noinspection unused
//noinspection unused
// Must box primitive type for List<T>
//      if( parent instanceof JsonListType && parent.getParent() != null )
//      {
//        return getParentFromMe( parent, qualifiedWithMe );
//      }
//noinspection StringConcatenationInLoop
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// must cache now to handle recursive refs
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// not storing in _bytes because the string is stored in the bindings
// release potentially large array
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//noinspection unchecked
// Given o1 and o2, if o1 and o2 are not null, o1 && o2, otherwise the non-null value
// Given o1 and o2, if o1 and o2 are not null, o1 || o2, otherwise the non-null value
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
// jsonText = value.
// array = "[" [ value { "," value } ] "]".
// object = "{" [ member { "," member } ] "}".
// using a LinkedHashMap to preserve insertion order, necessary for IJ plugin
// member = string ":" value.
// value = object | array | number | string | "true" | "false" | "null" .
// we have an overflow, the tokenizer guarantees the format is correct
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
// handle hex numbers: 'A' = 65, '0' = 48. 'A'-'0' = 17, 17 - 7 = 10
/*
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// single entry with no name implies root, defer to the root
//todo: factor out Xml.XML_DEFAULT_ROOT
/**
// Add to parent
// Attributes
// Element text
// Child Elements
// Duplicates are put into a list and indirectly exposed through it
// Use the location of the first occurrence
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// Generated from XMLParser.g4 by ANTLR 4.4
/*
//www.apache.org/licenses/LICENSE-2.0
// Generated from XMLParser.g4 by ANTLR 4.4
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// Generated from XMLParser.g4 by ANTLR 4.7
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// Generated from XMLParser.g4 by ANTLR 4.4
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// Generated from XMLParser.g4 by ANTLR 4.7
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// Generated from XMLLexer.g4 by ANTLR 4.4
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// check circular dependencies
/*
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// add support for "PATCH"
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
//noinspection unchecked
//noinspection unchecked
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*[>MyObject.json<]
/**
/**
//assertNotNull( a );
// root array with dissimilar component types (object and array)
// repeat to test releasing of memory
// repeat to test releasing of memory
// Since the person interface is an inner class of FootballPlayer, FootballPlayer cannot extend it.  Here we
// test that FootballPlayer still implements person structurally.
//    angular.create(1).setSchematics(abc.angular.schematicOptions.create());
//    angular.create().
//
//    apple_app_site_association.create(apple_app_site_association.applinks.create(apple_app_site_association.applinks.apps.__, Arrays.asList(apple_app_site_association.applinks.details.builder().withAppID("foo").build())));
//    resume.builder().withBasics(
//            resume.basics.builder().withProfiles(Arrays.asList(resume.basics.profiles.builder().build())).build() );
/*
//www.apache.org/licenses/LICENSE-2.0
//## todo: enable after https://bitbucket.org/asomov/snakeyaml-engine/issues/8 is fixed
// assertEquals( "{\n}\n", empty.toYaml() );
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// EOF
// IDE
/*
//www.apache.org/licenses/LICENSE-2.0
// IDE
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// go up two since we already have the build.properties for its own parent
//noinspection unchecked
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/** Java source version*/
/** JPMS mode, defined by presence of module-info.java and if source version is > 8 */
/** Operating System of the compiler/IDE process */
/** Architecture of the compiler/IDE process */
//noinspection ConstantConditions
/**
//docs.oracle.com/javase/8/docs/technotes/tools/windows/javac.html">Standard Options</a>.
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// shouldn't happen
//noinspection AssignmentToForLoopParameter
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
//## todo: handle _isError, add logWarning()
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
// line comment 
// ding!
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// this is a crappy way to approximate the offset, we really need to parse the file ourselves and store the offsets
//assert offset >= 0;
// ignore indentation
//.replace( "\r\n", "\n" );
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//[>MyPropertiesRightHere.properties<] Foo=bar
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// note we don't want name here since we look up based on just left & right units
// i.e., we don't want to have to name units all the time, just look them up by left & right units
// && _name == that._name
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/** The magnitude stored in Base units */
/** The unit used to display the value of this instance */
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
//noinspection unchecked
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// reifies to same type :(
//abstract public A divide( B b )
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/* Default arithmetic implementation */
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// Extract the Period from the date-based time and add that
// Extract the Period from the date-based time and add that
/*
//www.apache.org/licenses/LICENSE-2.0
// Extract the Period from the date-based time and add that
// Now add the remaining fractional day part, if non-zero, as a Duration (added to the date-time's time component)
// Extract the Period from the date-based time and add that
// Now add the remaining fractional day part, if non-zero, as a Duration (added to the date-time's time component)
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
//@BinderSeparators( :accepted = {":"} )
//@BinderSeparators( :accepted = {":"} )
//@BinderSeparators( :accepted = {":"} )
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// x squared
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// commonly used unit abbreviations e.g., m, ft, hr, mph, etc.
// 5 meters
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//www.npl.co.uk/si-units/metre">npl.co.uk</a>)
/**
// SI Units
// US Standard
// Navigation
// Very large
// Very small
// Ancient
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// commonly used unit abbreviations e.g., m, ft, hr, kg, etc.
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//www.npl.co.uk/si-units/kilogram">npl.co.uk</a>)
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// 1.25 Million
// 1.25 Million
// 1.25 milli or 0.00125
// 'fe', not 'f' because conflicts with number literal float suffix
// 'de', not 'd' because conflicts with number literal float suffix
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// commonly used unit abbreviations e.g., m, ft, hr, dC, etc.
// rational coercion
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//www.npl.co.uk/si-units/kelvin">npl.co.uk</a>)
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// commonly used unit abbreviations e.g., m, ft, hr, mph, etc.
// add hours to seconds
//
// TemporalAmount impl
//
//
// Operators
//
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//www.npl.co.uk/si-units/second">npl.co.uk</a>)
/**
// SI Units
// Mean Gregorian (ISO Calendar) units
// Mean Tropical (Solar) units
// Planck-time
// For compatibility with java.time
//
// TemporalUnit Impl
//
//
// Operators
//
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
//
// Compass
//
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// SI metric unit factors
//
// Byte unit factors for quantities of digital information (International Electrotechnical Commission)
//
// kibibyte (prev. kilobyte)
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
// calling reduce() has a side effect of setting _reduced to true if this instance is found to be in reduced form
/**
//todo: a rational impl
// note: cast to Object to avoid using Rational's operator impl on == which is this method (avoids stack overflow)
//noinspection RedundantCast
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// pound-force unit </code></pre>
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
//!! Highly experimental!
// todo: add trig functions for Rational
// todo: add trig functions for Rational
//todo: for better accuracy use magnitude and angle components instead of x, y coords
// todo: add trig functions for Rational
//noinspection unchecked
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// Length / Time = Velocity
// Length / Velocity = Time
// Length * Area = Volume
// Length * Force = Energy
// multiplication undefined
// Time * Velocity = Length
// Time * Acceleration = Velocity
// Time * Current = Charge
// Time * Frequency = Angle
// Time * Power = Energy
// Time * Force = Momentum
// multiplication undefined
// Mass * Acceleration = Force
// Mass * Velocity = Momentum
// Mass * Area = Pressure
// Mass * Volume = Density
// multiplication undefined
// multiplication undefined
// multiplication undefined
/*
//www.apache.org/licenses/LICENSE-2.0
// A Time value expressed in non-date based units e.g., Seconds, works using the raw amount of time as opposed to
// the calendar amount derived from a date-based time amount.
// A Time value expressed in date-based units such as Month works in terms of calendar value
// A Time value expressed in non-date based units e.g., Seconds, works using the raw amount of time as opposed to
// the calendar amount derived from a date-based time amount.
// A Time value expressed in date-based units such as Month works in terms of calendar value
/*
//www.apache.org/licenses/LICENSE-2.0
// tests javac internals re binding expr in arg position of an overloaded method,
// deals with speculative multi-pass attribution for method scoring (note assertEquals() is an overloaded method)
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// first, establish that double loses precision
// now test that rational coercion preserves precision even though coded as a double literal 
// first, establish that double loses precision
// now test that rational coercion preserves precision even though coded as a double literal
/*
//www.apache.org/licenses/LICENSE-2.0
//  @Test
//  public void testSequence() {
//    StringBuilder sb = new StringBuilder();
//    for( rat : (-2r..2r).step( 1r/3 ) ) {
//      sb.append( rat.toMixedString() ).append( ", " );
//    }
//    assertEquals( "-2, -1 2/3, -1 1/3, -1, -2/3, -1/3, 0, 1/3, 2/3, 1, 1 1/3, 1 2/3, 2, ", sb.toString() );
//  }
// tests with comparableWith equality
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// don't allow string templates in fragments e.g., interferes with graphql and awkward to use @DisableStringLiteralTemplates
// add
/*
//www.apache.org/licenses/LICENSE-2.0
// Install the handler so we can filter the 'illegal escape character' errors for \$
// Uninstall the handler after the file parses (we create new handler for each file)
// processor
// Disable string templates inside annotations. Reasons:
// 1. spring framework has its own $ processing that interferes
// 2. annotation processors in IDEs won't work with it
// 3. there's not enough benefit to justify the cost of fixing the above problems
// See https://github.com/manifold-systems/manifold/issues/102
// enforce concatenation
// insert an empty string so concat will make the expr a string
// Log#error() will prepend "compiler.err", so we must remove it to avoid double-basing the message
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
// Note the MyTemplateProcessorGate class from the manifold-strings-test-excl dependency
// excludes this class from string template processing. This is what makes the test work.
/*
//www.apache.org/licenses/LICENSE-2.0
// this is for testing only
// for test
/*
//www.apache.org/licenses/LICENSE-2.0
// NO-OP tracer by default
/*
//www.apache.org/licenses/LICENSE-2.0
//only for the outermost class
//continue;
//TODO: Fix this to get the correct line number (of the end of the file?)
//className
//className
//           params, paramsList
//className, params,            conditional
//className, params,            conditional
//className, params, paramsList
//
//
//className
//the directive is invalid
//imports "[static] [class_name]"
//extends "[class_name]"
//params ([paramType paramName], [paramType paramName],...)                  <---nothing stored for params or end section
//include "[templateName]"([paramVal], [paramVal],...) (conditional)
//nest "[templateName]"([paramVal], [paramVal],...) (conditional)
//section "[sectionName]"([paramType paramName], [paramType paramName],...)
//end section
//iff section, params, nest, and include (empty string if params not given for include/nest)
//iff section and params only (include/nest doesn't need it broken down bc types aren't given)
//iff include/nest
/**
/**
// todo: this needs grownup attention (it's using hard-coded offsets, instead it should be tokenized etc.)
/**
//given a list of 2 element String lists (0th elem is type and 1st elem is value), returns the string form
//ex. [[String, str],[int,5]] returns "String str, int 5"
//First Group: Matches Type arg format
//Second & Third Group: Deals with matching within strings
// for tests to avoid files
// eg. can happen during editing in IJ
// constructor
// render
// renderInto
// nestInto
// close class
//       sb.newLine( '@'+DisableStringLiteralTemplates.class.getTypeName() );
//close class
//!! only for tests
// verbatim
// sb.newLine( "                buffer.append(\"" ).append( text.replaceAll( "\"", "\\\\\"" ).replaceAll( "\r", "" ).replaceAll( "\n", "\\\\n" ) + "\");" );
// remove leading new line (which follows the preceding non-content token)
// remove leading new line (which follows the preceding non-content token)
// remove trailing indentation (which precedes the following non-content token)
//noinspection unused
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// No secondary extension in name, keep fqn as-is
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
// E.g., to trigger indentation for the `nest` directive
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// append directly to target
// buffer appends, append to target in `complete()`
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
//noinspection ConditionalBreakInInfiniteLoop
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/*[>MyFragmentTest.html.mtl<]
//manifold.systems/manifold-templates.html",
//these errors have to be tested by hand and eye-balled
//    @Test
//    public void basicErrorWorks() {
//        BasicRuntimeError.render();
//    }
//
//    @Test
//    public void layoutErrorWorks() {
//        HasLayoutRuntimeError.render();
//    }
/**
//        assertLineColPosAre(tokenizer.tokenize("<html>${2 + 2}</html>"),1, 1, 0, 1, 7, 6, 1, 15, 14);
//assertLineColPosAre(tokenizer.tokenize("<html><% if(true) { %> foo <% } else { %> bar <% } %></html>"),
//        1, 1, 0, 1, 1, 8, 1, 1, 14);
//
//    @Test
//    public void statementErrorTest() {
//        Tokenizer tokenizer = new Tokenizer();
//        tokenizer.tokenize("<% foo");
//        tokenizer.tokenize("<% abc <% abc %> %>");
//        tokenizer.tokenize("<% ${ } %>");
//        tokenizer.tokenize("<% Abc <%@ abc %> %>");
//
//        List<String> expectedMessages = new ArrayList<>();
//        expectedMessages.add("Tokenization Error: STATEMENT is not closed");
//        expectedMessages.add("Attempted to open new statement within STATEMENT");
//        expectedMessages.add("Attempted to open new expression within STATEMENT");
//        expectedMessages.add("Attempted to open new directive within STATEMENT");
//
//        assertEquals(tokenizer.getIssues().size(), expectedMessages.size());
//        for(int i = 0; i < expectedMessages.size(); i += 1) {
//            assertEquals(tokenizer.getIssues().get(i).getMessage(), expectedMessages.get(i));
//        }
//
//    }
//
//    @Test
//    public void directiveErrorTest() {
//        Tokenizer tokenizer = new Tokenizer();
//        tokenizer.tokenize("<%@ foo");
//        tokenizer.tokenize("<%@ abc <% abc %> %>");
//        tokenizer.tokenize("<%@ ${ } %>");
//        tokenizer.tokenize("<%@ Abc <%@ abc %> %>");
//
//        List<String> expectedMessages = new ArrayList<>();
//        expectedMessages.add("Tokenization Error: DIRECTIVE is not closed");
//        expectedMessages.add("Attempted to open new statement within DIRECTIVE");
//        expectedMessages.add("Attempted to open new expression within DIRECTIVE");
//        expectedMessages.add("Attempted to open new directive within DIRECTIVE");
//
//        assertEquals(tokenizer.getIssues().size(), expectedMessages.size());
//        for(int i = 0; i < expectedMessages.size(); i += 1) {
//            assertEquals(tokenizer.getIssues().get(i).getMessage(), expectedMessages.get(i));
//        }
//    }
//
//    @Test
//    public void expressionErrorTest() {
//        Tokenizer tokenizer = new Tokenizer();
//        tokenizer.tokenize("${ foo");
//        tokenizer.tokenize("${ abc <% abc %> }");
//        tokenizer.tokenize("${ ${ } }");
//        tokenizer.tokenize("${ Abc <%@ abc %> }");
//
//        List<String> expectedMessages = new ArrayList<>();
//        expectedMessages.add("Tokenization Error: EXPRESSION is not closed");
//        expectedMessages.add("Attempted to open new statement within EXPRESSION");
//        expectedMessages.add("Attempted to open new expression within EXPRESSION");
//        expectedMessages.add("Attempted to open new directive within EXPRESSION");
//
//        assertEquals(tokenizer.getIssues().size(), expectedMessages.size());
//        for(int i = 0; i < expectedMessages.size(); i += 1) {
//            assertEquals(tokenizer.getIssues().get(i).getMessage(), expectedMessages.get(i));
//        }
//
//    }
/**
/**
//    private void assertTokenContentsAre(List<Token> tokenize, String... stringContent) {
//        assertEquals(tokenize.size(), stringContent.length);
//        for (int i = 0; i < tokenize.size(); i++) {
//            Token token = tokenize.get(i);
//            assertEquals(stringContent[i], token.getText());
//        }
//    }
//  }
//    private void assertTokenContentsAre(List<Token> tokenize, String... stringContent) {
//        assertEquals(tokenize.size(), stringContent.length);
//        for (int i = 0; i < tokenize.size(); i++) {
//            Token token = tokenize.get(i);
//            assertEquals(stringContent[i], token.getText());
//        }
//    }
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
// indexOfAny()
/**
/**
/**
/**
/**
/**
// indexOf
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*[>MyYamlObject.yaml<]
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*Context*/ ctx )
//noinspection ConstantConditions
//noinspection ConstantConditions
/*Module*/ manifoldModule = ReflectUtil.method( Class.class, "getModule" ).invoke( JreUtil.class );
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// above statement always throws, this is unreachable
//noinspection unchecked
/*
//www.apache.org/licenses/LICENSE-2.0
// Shutdown Oracle's attempt at blacklisting fields and methods from reflection in Java 12
// runtime
// compile-time
// Disable Java 9 warnings re "An illegal reflective access operation has occurred"
//
// Module: manifold jars
//
//      Object /*Module*/ manifoldModule = ReflectUtil.method( Class.class, "getModule" ).invoke( NecessaryEvilUtil.class );
/*Module*/ manifoldModule = ReflectUtil.method( Class.class, "getModule" ).invoke( NecessaryEvilUtil.class );
/*Module*/ manifoldModule = ReflectUtil.field( "java.lang.Module", "EVERYONE_MODULE" ).getStatic();
//
// Module: java.base
//
/*Module*/ javaBaseModule = ReflectUtil.method( Class.class, "getModule" ).invoke( String.class );
// for jailbreak
//
// Module: jdk.compiler
//
/*Module*/ jdkCompilerModule = ReflectUtil.method( Class.class, "getModule" )
//
// Module: jdk.javadoc
//
// Warn and continue
//System.out.println( "\nWARNING: Failed to find class 'jdk.javadoc.internal.doclets.formats.html.HtmlDoclet'\n" );
/*Module*/ jdkJavadoc = ReflectUtil.method( Class.class, "getModule" ).invoke( HtmlDoclet );
// `com.sun.tools.doclets.standard.Standard` and `com.sun.tools.javadoc.main.Main` are removed in JDK 13
// not modular java 9+
//System.err.println( "PACKAGE: " + pkg );
/* to root module[s], you must add the following argument to jave.exe:\n" +
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//manifold.systems/docs.html#type-safe-reflection">Type-safe Reflection</a>.)
//private static final ConcurrentHashMap<String, Boolean> _openPackages = new ConcurrentHashMap<>();
/**
//openPackage( fqn, null );
/**
//openPackage( fqn, cl );
/**
/**
/**
/**
/**
/**
/**
/**
/**
// already loaded
/**
/**
//## not necessary (until Unsafe goes away), using Unsafe.putObjectVolatile() to set 'override' directly
//
//  private static void openPackage( String fqn, ClassLoader cl )
//  {
//    if( JreUtil.isJava8() || _openPackages.containsKey( fqn ) )
//    {
//      return;
//    }
//
//    int iDot = fqn.lastIndexOf( '.' );
//    if( iDot < 0 )
//    {
//      return;
//    }
//
//    String pkg = fqn.substring( 0, iDot );
//    cl = cl == null ? ReflectUtil.class.getClassLoader() : cl;
//    LiveFieldRef packageToModule = WithNull.field( cl, "packageToModule" );
//    if( packageToModule != null )
//    {
//      Object loadedModule = ((Map)packageToModule.get()).get( pkg );
//      if( loadedModule != null )
//      {
//        if( method( loadedModule, "loader" ).invoke() == cl )
//        {
//          String moduleName = (String)method( loadedModule, "name" ).invoke();
//          //noinspection unchecked
//          Object module = ((Optional)ReflectUtil.method( ReflectUtil.method( "java.lang.ModuleLayer", "boot" ).invokeStatic(), "findModule", String.class ).invoke( moduleName )).orElse( null );
//          if( module != null )
//          {
//            Class<?> classModule = ReflectUtil.type( "java.lang.Module" );
//            ReflectUtil.MethodRef addExportsOrOpens = method( classModule, "implAddExportsOrOpens", String.class, classModule, boolean.class, boolean.class );
//            //noinspection ConstantConditions
//            Object /*Module*/ manifoldModule = method( Class.class, "getModule" ).invoke( ReflectUtil.class );
/*Module*/ manifoldModule = method( Class.class, "getModule" ).invoke( ReflectUtil.class );
//            //noinspection ConstantConditions
//            addExportsOrOpens.invoke( module, pkg, manifoldModule, true, true );
//            _openPackages.put( pkg, true );
//            return;
//          }
//        }
//      }
//    }
//    _openPackages.put( pkg, false );
//  }
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//statistics
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
// walk up the list until a node can be linked
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
// do nothing
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//creativecommons.org/licenses/publicdomain
/**
/*
/* ---------------- Constants -------------- */
/**
/**
/**
/**
/**
// slightly conservative
/**
/* ---------------- Fields -------------- */
/**
/**
/**
/* ---------------- Small Utilities -------------- */
/**
// Spread bits to regularize both segment and index locations,
// using variant of single-word Wang/Jenkins hash.
/**
/* ---------------- Inner Classes -------------- */
/**
/**
/**
/*
/**
/**
/**
/**
/**
/**
/**
/**
/**
/* Specialized implementations of map methods */
// read-volatile
// recheck
// read-volatile
// read-volatile
// recheck
// ensure capacity
// adjust from possible weak cleanups
// write-volatile
// write-volatile
/*
// We need to guarantee that any existing reads of old Map can
//  proceed. So we cannot yet null out each bin.
//  Single node on list
// Reuse trailing consecutive sequence at same slot
// Clone all remaining nodes
// Skip GC'd weak refs
/**
// a weak remove operation compares the WeakReference instance
// All entries following removed node can stay
// in list, but all preceding ones need to be
// cloned.
// Skip GC'd keys
// write-volatile
// replace the reference queue to avoid unnecessary stale cleanups
// write-volatile
/* ---------------- Public operations -------------- */
/**
// Find power-of-two sizes best matching arguments
/**
/**
/**
/**
/**
/*
// If mcsum happens to be zero, then we know we got a snapshot
// before any modifications at all were made.  This is
// probably common enough to bother tracking.
/**
// Try a few times to get accurate count. On failure due to
// continuous async changes in table, resort to locking.
// force retry
// Resort to locking all segments
/**
/**
/**
// See explanation of modCount use above
// Try a few times without locking
// Resort to locking all segments
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/**
/* ---------------- Iterator Support -------------- */
// Strong reference to weak key (prevents gc)
// Skip GC'd keys
/*
/**
/**
/* ---------------- Serialization Support -------------- */
/**
// Skip GC'd keys
/**
// Initialize each segment to be minimally sized, and let grow.
// Read the keys and values, and put the mappings in the table
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//?
//?
/*
//www.apache.org/licenses/LICENSE-2.0
/**
//The extra space makes all the difference
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/*
//www.apache.org/licenses/LICENSE-2.0
// Duplicate the field layout of AccessibleObject so we can get the offset of the `override` field
// since we run this test in Java 8, we can test that the approximated offset for Java 12 matches the actual offset
