________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Common\Comparers.cs
/// <summary>
/// Determines if a specific value is a number.
/// </summary>
/// <returns><c>true</c> if the value is a number; otherwise, <c>false</c>.</returns>
/// <param name="value">Value.</param>
/// <typeparam name="T">The Type of value.</typeparam>
/// <summary>
/// Determines if firstValue is equals to the specified secondValue.
/// </summary>
/// <returns><c>true</c> if firstValue is equals to the specified secondValue; otherwise, <c>false</c>.</returns>
/// <param name="firstValue">The first value.</param>
/// <param name="secondValue">The second value.</param>
/// <typeparam name="T">The Type of values.</typeparam>
/// <summary>
/// Determines if thisValue is greater than the specified otherValue.
/// </summary>
/// <returns><c>true</c> if thisValue is greater than the specified otherValue; otherwise, <c>false</c>.</returns>
/// <param name="firstValue">The first value.</param>
/// <param name="secondValue">The second value.</param>
/// <typeparam name="T">The Type of values.</typeparam>
/// <summary>
/// Determines if thisValue is less than the specified otherValue.
/// </summary>
/// <returns><c>true</c> if thisValue is less than the specified otherValue; otherwise, <c>false</c>.</returns>
/// <param name="firstValue">The first value.</param>
/// <param name="secondValue">The second value.</param>
/// <typeparam name="T">The Type of values.</typeparam>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Common\Helpers.cs
/// <summary>
/// Swaps two values in an IList<T> collection given their indexes.
/// </summary>
//This check is not required but Partition function may make many calls so its for perf reason
/// <summary>
/// Swaps two values in an ArrayList<T> collection given their indexes.
/// </summary>
//This check is not required but Partition function may make many calls so its for perf reason
/// <summary>
/// Populates a collection with a specific value.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Graphs\BellmanFordShortestPaths.cs
/// <summary>
/// INSTANCE VARIABLES
/// </summary>
// A dictionary that maps node-values to integer indeces
// A dictionary that maps integer index to node-value
// A const that represent an infinite distance
/// <summary>
/// CONSTRUCTOR
/// </summary>
// Init
// Traverse the graph
/************************************************************************************************************/
/// <summary>
/// The Bellman-Ford Algorithm.
/// </summary>
/// <returns>True if shortest-path computation is finished with no negative-weight cycles detected; otehrwise, false.</returns>
// First pass
// Calculate shortest paths and relax all edges.
// calculate a new possible weighted path if the edge weight is less than infinity
// Handles overflow
// Relax the edge
// if check is true, a shorter path is found from current to adjacent
// Second pass
// Check for negative-weight cycles.
// calculate a new possible weighted path if the edge weight is less than infinity
// Handles overflow
// if check is true a negative-weight cycle is detected
// return false;
// Completed shortest paths computation.
// No negative edges were detected.
/// <summary>
/// Constructors helper function. Initializes some of the data memebers.
/// </summary>
// Reset the information arrays
/// <summary>
/// Constructors helper function. Checks Optimality Conditions:
/// (i) for all edges e:            distTo[e.to()] <= distTo[e.from()] + e.weight()
/// (ii) for all edge e on the SPT: distTo[e.to()] == distTo[e.from()] + e.weight()
/// </summary>
// Get the source index (to be used with the information arrays).
// check that distTo[v] and edgeTo[v] are consistent
// check that all edges e = v->w satisfy distTo[w] <= distTo[v] + e.weight()
// check that all edges e = v->w on SPT satisfy distTo[w] == distTo[v] + e.weight()
/************************************************************************************************************/
/// <summary>
/// Determines whether there is a path from the source vertex to this specified vertex.
/// </summary>
/// <summary>
/// Returns the distance between the source vertex and the specified vertex.
/// </summary>
/// <summary>
/// Returns an enumerable collection of nodes that specify the shortest path from the source vertex to the destination vertex.
/// </summary>
// Push the source vertex
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Graphs\BipartiteColoring.cs
/***
/// <summary>
/// The Bipartite Colors type.
/// </summary>
/// <summary>
/// Bipartite Graph Coloring/Labeling.
/// </summary>
// A dictionary that maps node-values to integer indeces
// A dictionary that maps integer index to node-value
/// <summary>
/// CONTRUSTOR
/// </summary>
// Validate Graph parameter
// Init data members
// Set bipartite flag to true
// Compute bipartiteness
// Check the bipartite from this vertex, if it was not visited
// Stop discovery of graph when bipartiteness doesn't hold 
/// <summary>
/// Constructors helper function. Initializes some of the data memebers.
/// </summary>
// Reset the visited, distances and predeccessors arrays
/// <summary>
/// Constructors helper function. Computes the bipartite of graph from a source vertex.
/// </summary>
// Visit node
// Discover bfs-level neighbors
//end-foreach
//end-while
/// <summary>
/// Determines the graph is bipartite.
/// </summary>
/// <summary>
/// Returns the color of a vertex.
/// </summary>
/// <summary>
/// Returns the odd-cycle in graoh, if any.
/// </summary>
/// <returns>The cycle.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Graphs\BreadthFirstSearcher.cs
/***
/// <summary>
/// Iterative BFS implementation.
/// Traverses nodes in graph starting from a specific node, printing them as they get visited.
/// </summary>
// Check if graph is empty
// Check if graph has the starting vertex
/// <summary>
/// Iterative BFS implementation.
/// Traverses all the nodes in a graph starting from a specific node, applying the passed action to every node.
/// </summary>
// Check if graph is empty
// Check if graph has the starting vertex
// keeps track of level
// keeps track of previous levels, i - 1
// keeps track of visited nodes and their distances
// keeps track of tree-nodes
// BFS VISIT CURRENT NODE
// TRAVERSE GRAPH
// keeps track of the current level, i
// not visited yet
// BFS VISIT NODE STEP
// level[node] + 1
/// <summary>
/// Iterative BFS Implementation.
/// Given a predicate function and a starting node, this function searches the nodes of the graph for a first match.
/// </summary>
// Check if graph is empty
// Check if graph has the starting vertex
// keeps track of levels
// keeps track of previous levels, i - 1
// keeps track of visited nodes and their distances
// keeps track of tree-nodes
// BFS VISIT CURRENT NODE
// TRAVERSE GRAPH
// keeps track of the current level, i
// not visited yet
// BFS VISIT NODE STEP
// level[node] + 1
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Graphs\BreadthFirstShortestPaths.cs
/***
// A dictionary that maps node-values to integer indeces
// A dictionary that maps integer index to node-value
// A const that represent an infinite distance
/// <summary>
/// CONSTRUCTOR.
/// Breadth First Searcher from Single Source.
/// </summary>
// Init
// Single source BFS
//bool optimalityConditionsSatisfied = checkOptimalityConditions (Graph, Source);
/// <summary>
/// CONSTRUCTOR.
/// Breadth First Searcher from Multiple Sources.
/// </summary>
// Init
// Multiple sources BFS
/************************************************************************************************************/
/// <summary>
/// Constructors helper function. Initializes some of the data memebers.
/// </summary>
// Reset the visited, distances and predeccessors arrays
/// <summary>
/// Privat helper. Breadth First Search from Single Source.
/// </summary>
// Set distance to current to zero
// Set current to visited: true.
//end-foreach
//end-while
/// <summary>
/// Privat helper. Breadth First Search from Multiple Sources.
/// </summary>
// Define helper variables.
//end-foreach
//end-while
/// <summary>
/// Private helper. Checks optimality conditions for single source
/// </summary>
// check that the distance of s = 0
// check that for each edge v-w dist[w] <= dist[v] + 1
// provided v is reachable from s
// check that v = edgeTo[w] satisfies distTo[w] + distTo[v] + 1
// provided v is reachable from source
/************************************************************************************************************/
/// <summary>
/// Determines whether there is a path from the source vertex to this specified vertex.
/// </summary>
/// <summary>
/// Returns the distance between the source vertex and the specified vertex.
/// </summary>
/// <summary>
/// Returns an enumerable collection of nodes that specify the shortest path from the source vertex to the destination vertex.
/// </summary>
// Push the source vertex
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Graphs\ConnectedComponents.cs
/***
/// <summary>
/// Private helper. Discovers a connected component and return from a source vertex in a graph.
/// </summary>
/// <summary>
/// Return the the connected components in graph as list of lists of nodes. Each list represents a connected component.
/// </summary>
// Validate the graph parameter
// Get connected components using BFS
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Graphs\CyclesDetector.cs
/***
/// <summary>
/// Implements Cycles Detection in Graphs
/// </summary>
/// <summary>
/// [Undirected DFS Forest].
/// Helper function used to decide whether the graph explored from a specific vertex contains a cycle.
/// </summary>
/// <param name="graph">The graph to explore.</param>
/// <param name="source">The vertex to explore graph from.</param>
/// <param name="parent">The predecessor node to the vertex we are exploring the graph from.</param>
/// <param name="visited">A hash set of the explored nodes so far.</param>
/// <returns>True if there is a cycle; otherwise, false.</returns>
// Mark the current node as visited
// Recur for all the vertices adjacent to this vertex
// If an adjacent node was not visited, then check the DFS forest of the adjacent for UNdirected cycles.
// If an adjacent is visited and NOT parent of current vertex, then there is a cycle.
/// <summary>
/// [Directed DFS Forest]
/// Helper function used to decide whether the graph explored from a specific vertex contains a cycle.
/// </summary>
/// <param name="graph">The graph to explore.</param>
/// <param name="source">The vertex to explore graph from.</param>
/// <param name="parent">The predecessor node to the vertex we are exploring the graph from.</param>
/// <param name="visited">A hash set of the explored nodes so far.</param>
/// <param name="recursionStack">A set of element that are currently being processed.</param>
/// <returns>True if there is a cycle; otherwise, false.</returns>
// Mark the current node as visited and add it to the recursion stack
// Recur for all the vertices adjacent to this vertex
// If an adjacent node was not visited, then check the DFS forest of the adjacent for directed cycles.
// If an adjacent is visited and is on the recursion stack then there is a cycle.
// Remove the source vertex from the recursion stack
/// <summary>
/// Returns true if Graph has cycle.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Graphs\DepthFirstSearcher.cs
/***
/// <summary>
/// DFS Recursive Helper function. 
/// Visits the neighbors of a given vertex recusively, and applies the given Action<T> to each one of them.
/// </summary>
// DFS VISIT NODE
// Save adjacents parent into dictionary
// Recusively visit adjacent nodes
/// <summary>
/// Recursive DFS Implementation with helper.
/// Traverses all the nodes in a graph starting from a specific node, applying the passed action to every node.
/// </summary>
// Check if graph is empty
// Check if graph has the starting vertex
// keeps track of visited nodes and tree-edges
// DFS VISIT NODE
// Add to parents dictionary
// Visit neighbors using recusrive helper
/// <summary>
/// Iterative DFS Implementation.
/// Given a starting node, dfs the graph and print the nodes as they get visited.
/// </summary>
// Check if graph is empty
// Check if graph has the starting vertex
// DFS VISIT NODE STEP
// Get the adjacent nodes of current
/// <summary>
/// Iterative DFS Implementation.
/// Given a predicate function and a starting node, this function searches the nodes of the graph for a first match.
/// </summary>
// Check if graph is empty
// Check if graph has the starting vertex
// keeps track of visited nodes and tree-edges
// Skip loop if node was already visited
// Save its parent into the dictionary
// Mark it as visited
// DFS VISIT NODE STEP
// Get currents adjacent nodes (might add already visited nodes).
// Mark current as the father of its adjacents. This helps keep track of tree-nodes.
//end-while
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Graphs\DijkstraAllPairsShortestPaths.cs
/***
/// <summary>
/// INSTANCE VARIABLES
/// </summary>
/// <summary>
/// CONSTRUCTOR
/// </summary>
// Initialize the all pairs dictionary
/// <summary>
/// Determines whether there is a path from source vertex to destination vertex.
/// </summary>
/// <summary>
/// Returns the distance between source vertex and destination vertex.
/// </summary>
/// <summary>
/// Returns an enumerable collection of nodes that specify the shortest path from source vertex to destination vertex.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Graphs\DijkstraShortestPaths.cs
/// <summary>
///     Computes Dijkstra's Shortest-Paths for Directed Weighted Graphs from a single-source to all destinations.
/// </summary>
/// <summary>
///     The Dijkstra's algorithm.
/// </summary>
/// <summary>
///     Determines whether there is a path from the source vertex to this specified vertex.
/// </summary>
/// <summary>
///     Returns the distance between the source vertex and the specified vertex.
/// </summary>
/// <summary>
///     Returns an enumerable collection of nodes that specify the shortest path from the source vertex to the destination vertex.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Graphs\TopologicalSorter.cs
/***
/// <summary>
/// Private recursive helper.
/// </summary>
/// <summary>
/// The Topological Sorting algorithm
/// </summary>
// If the graph is either null or is not a DAG, throw exception.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Numeric\BinomialCoefficients.cs
/// <summary>
/// Calculate binomial coefficients, C(n, k).
/// </summary>
/// <param name="n"></param>
/// <returns></returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Numeric\CatalanNumbers.cs
/***
//en.wikipedia.org/wiki/Catalan_number
/// <summary>
/// Internal cache.
/// By default contains the first two catalan numbers for the ranks: 0, and 1.
/// </summary>
/// <summary>
/// Helper method.
/// </summary>
/// <param name="rank"></param>
/// <returns></returns>
/// <summary>
/// Public API.
/// </summary>
/// <param name="rank"></param>
/// <returns></returns>
// Assert the cache is not empty.
/// <summary>
/// Calculate the number using the Binomial Coefficients algorithm
/// </summary>
/// <param name="rank"></param>
/// <returns></returns>
// Calculate by binomial coefficient.
/// <summary>
/// Return the list of catalan numbers between two ranks, inclusive
/// </summary>
/// <param name="fromRank"></param>
/// <param name="toRank"></param>
/// <returns></returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Numeric\GreatestCommonDivisor.cs
/// <summary>
///     Returns the greatest common divisor of two numbers using Euclidean Algorithm.
/// </summary>
/// <summary>
///     Returns the greatest common divisor of two numbers using Stein Algorithm.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Numeric\SieveOfAtkin.cs
/***
//en.wikipedia.org/wiki/Sieve_of_Atkin
/// <summary>
/// Calculate primes up to a given number
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Numeric\SieveOfEratosthenes.cs
/***
//en.wikipedia.org/wiki/Sieve_of_Eratosthenes
/// <summary>
/// Calculate primes up to a given number
/// </summary>
//The hash of primes that will be returned
//Returns an empty list if x is a value under 2
//Adds every number between 2 and x to the hashset
//integer that all multiples of will be removed from the hashset
//Finds the next number that hasn't been removed and removes all multiples of that number 
//from the hashset
//The list of primes is returned
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Search\BinarySearcher.cs
/// <summary>
/// The value of the current item
/// </summary>
/// <summary>
/// Class constructor
/// </summary>
/// <param name="collection">A list</param>
/// <param name="comparer">A comparer</param>
/// <summary>
/// Apply Binary Search in a list.
/// </summary>
/// <param name="item">The item we search</param>
/// <returns>If item found, its' index, -1 otherwise</returns>
/// <summary>
/// An implementation of IEnumerator's MoveNext method.
/// </summary>
/// <returns>true if iteration can proceed to the next item, false otherwise</returns>
//not implementing this, since there are no managed resources to release 
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Sorting\BinarySearchTreeSorter.cs
/// <summary>
/// Unbalanced Binary Search Tree sort.
/// </summary>
/// <typeparam name="T"></typeparam>
/// <param name="collection"></param>
// Get a handle on root.
// Go left
// Go right
//end-while
//end-for
// Reference handle to root again.
/// <summary>
/// Used to travel a node's subtrees and add the elements to the collection.
/// </summary>
/// <typeparam name="T">Type of tree elements.</typeparam>
/// <param name="currentNode">Node to start from.</param>
/// <param name="collection">Collection to add elements to.</param>
/// <summary>
/// Minimal BST Node class, used only for unbalanced binary search tree sort.
/// </summary>
/// <typeparam name="T"></typeparam>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Sorting\BubbleSorter.cs
/// <summary>
/// Public API: Sorts ascending
/// </summary>
/// <summary>
/// Public API: Sorts descending
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Sorting\BucketSorter.cs
/// <summary>
/// Only support IList<int> Sort
/// </summary>
/// <summary>
/// Public API: Sorts ascending
/// </summary>
/// <summary>
/// Public API: Sorts descending
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Sorting\CombSorter.cs
/// <summary>
/// Public API: Sorts ascending
/// </summary>
/// <summary>
/// Public API: Sorts descending
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Sorting\CountingSorter.cs
// Get the maximum number in array.
// The array of keys, used to sort the original array.
// populate it with zeros
// Assign the keys
// Reset index.
// Sort the elements
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Sorting\CycleSorter.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Sorting\GnomeSorter.cs
/// <summary>
/// Also called Stupid Sort
/// </summary>
/// <summary>
/// Public API: Sorts ascending
/// </summary>
/// <summary>
/// Public API: Sorts descending
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Sorting\HeapSorter.cs
/// <summary>
/// Public API: Default functionality.
/// Sorts in ascending order. Uses Max-Heaps.
/// </summary>
/// <summary>
/// Public API: Sorts ascending
/// Uses Max-Heaps
/// </summary>
// Handle the comparer's default null value
/// <summary>
/// Public API: Sorts ascending
/// Uses Min-Heaps
/// </summary>
// Handle the comparer's default null value
/****************************************************************************/
/// <summary>
/// Private Max-Heap Builder.
/// Builds a max heap from an IList<T> collection.
/// </summary>
/// <summary>
/// Private Max-Heapifier. Used in BuildMaxHeap.
/// Heapfies the elements between two indexes (inclusive), maintaining the maximum at the top.
/// </summary>
// assume left(i) and right(i) are max-heaps
// If collection[left] > collection[nodeIndex]
// If collection[right] > collection[largest]
// Swap and heapify
/// <summary>
/// Private Min-Heap Builder.
/// Builds a min heap from an IList<T> collection.
/// </summary>
/// <summary>
/// Private Min-Heapifier. Used in BuildMinHeap.
/// Heapfies the elements between two indexes (inclusive), maintaining the minimum at the top.
/// </summary>
// assume left(i) and right(i) are max-heaps
// If collection[left] > collection[nodeIndex]
// If collection[right] > collection[largest]
// Swap and heapify
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Sorting\InsertionSorter.cs
/// <summary>
/// Implements this Insertion Sort algorithm over ArrayLists.
/// </summary>
//
// The quick insertion sort algorithm.
// For any collection that implements the IList interface.
//
// If the comparer is Null, then initialize it using a default typed comparer
// Do sorting if list is not empty.
//
// The quick insertion sort algorithm.
// For the internal ArrayList<T>. Check the DataStructures.ArrayList.cs.
//
// If the comparer is Null, then initialize it using a default typed comparer
//(j)th is less than (j-1)th
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Sorting\LSDRadixSorter.cs
/// <summary>
/// LSD (Least Significat Digit) Radix Sort.
///
/// Sorts ASCII-encoded strings.
/// Implemented as a static class of extension methods.
/// </summary>
/// <summary>
/// Extension method for sorting strings.
/// </summary>
// LSD Radix Sort the character arrapy representation of the string
/// <summary>
/// Extension method for sorting character arrays, in place.
/// </summary>
// extend ASCII alphabet size
// compute frequency counts
// compute cumulates
// move data
// copy back
/// <summary>
/// Extension method for sorting collections of strings of the same width, in place.
/// </summary>
// Validate input
// extend ASCII alphabet size
// compute frequency counts
// compute cumulates
// move data
// copy back
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Sorting\MergeSorter.cs
//
// Public merge-sort API
//
// Private static method
// Implements the recursive merge-sort algorithm
//
// Private static method
// Implements the merge function inside the merge-sort
// rightElement <= leftElement
//resultArray.Add(rightCollection[right]);
//result.Add(leftCollection[left]);
//
// At most one of left and right might still have elements left
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Sorting\OddEvenSorter.cs
/// <summary>
/// Based on bubble sort
/// </summary>
/// <summary>
/// Public API: Sorts ascending
/// </summary>
/// <summary>
/// Public API: Sorts descending
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Sorting\PigeonHoleSorter.cs
/// <summary>
/// Only support IList<int> Sort
/// Also called CountSort (not CountingSort)
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Sorting\QuickSorter.cs
//
// The public APIs for the quick sort algorithm.
//
// If the comparer is Null, then initialize it using a default typed comparer
//
// Private static method
// The recursive quick sort algorithm
//
// Recursive call check
//
// Private static method
// The partition function, used in the quick sort algorithm
// Choose the pivot
// Compare remaining array elements against pivotValue
// Loop until pivot: exclusive!
// check if collection[i] <= pivotValue
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Sorting\SelectionSorter.cs
/// <summary>
/// Public API: Sorts ascending
/// </summary>
/// <summary>
/// Public API: Sorts ascending
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Sorting\ShellSorter.cs
/// <summary>
/// Public API: Sorts ascending
/// </summary>
/// <summary>
/// Public API: Sorts descending
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Strings\EditDistance.cs
/// <summary>
/// The Edit Distance computation algorithm.
/// Uses a custom class for receiving the costs.
/// </summary>
/// <summary>
/// Computes the Minimum Edit Distance between two strings.
/// </summary>
// Validate parameters and TCost.
// Dynamic Programming 3D Table
// Initialize table
// Compute min edit distance cost
// Get min edit distance cost
/// <summary>
/// Overloaded method for 32-bits Integer Distances
/// </summary>
// Validate parameters and TCost.
/// <summary>
/// Overloaded method for 16-bits Integer Distances
/// </summary>
// Validate parameters and TCost.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Strings\EditDistanceCostsMap.cs
/// <summary>
/// Edit Distance Costs Map.
/// Helper class used with the EditDistance class.
/// </summary>
/// <summary>
/// CONSTRUCTOR
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Strings\Permutations.cs
/***
/// <summary>
/// Private Helper. Computes permutations recursively for string source.
/// </summary>
/// <summary>
/// Private helper. Merges a set of permutations with a character.
/// </summary>
/// <summary>
/// Computes the permutations of a string.
/// </summary>
/// <summary>
/// Determines if the Other string is an anargram of the Source string.
/// </summary>
// Hash set which will contains all the characters present in input source.
// Inputs are not Anargram if characers from *other are not present in *source.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Trees\BinaryTreeIterativeWalker.cs
/// <summary>
/// Simple Iterative Tree Traversal and Search Algorithms.
/// </summary>
/// <summary>
/// Specifies the mode of travelling through the tree.
/// </summary>
/************************************************************************************
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\Algorithms\Trees\BinaryTreeRecursiveWalker.cs
/// <summary>
/// Simple Recursive Tree Traversal and Search Algorithms.
/// </summary>
/// <summary>
/// Specifies the mode of travelling through the tree.
/// </summary>
/************************************************************************************
/// <summary>
/// Private helper method for Preorder Traversal.
/// </summary>
/// <summary>
/// Private helper method for Inorder Traversal.
/// </summary>
/// <summary>
/// Private helper method for Preorder Traversal.
/// </summary>
/// <summary>
/// Private helper method for Preorder Searcher.
/// </summary>
/// <summary>
/// Private helper method for Inorder Searcher.
/// </summary>
/// <summary>
/// Private helper method for Inorder Searcher.
/// </summary>
/************************************************************************************
/// <summary>
/// Recusrsivley walks the tree and prints the values of all nodes.
/// By default this method traverses the tree in inorder fashion.
/// </summary>
/// <summary>
/// Recursively Visits All nodes in tree applying a given action to all nodes.
/// By default this method traverses the tree in inorder fashion.
/// </summary>
// Traverse
/// <summary>
/// Search the tree for the specified value.
/// By default this method traverses the tree in inorder fashion.
/// </summary>
// Traverse
// Traverse
/// <summary>
/// Search the tree for the specified value.
/// By default this method traverses the tree in inorder fashion.
/// </summary>
// Traverse
// Traverse
/// <summary>
/// Search the tree for all matches for a given predicate function.
/// By default this method traverses the tree in inorder fashion.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Common\Comparers.cs
/// <summary>
/// Determines if a specific value is a number.
/// </summary>
/// <returns><c>true</c> if the value is a number; otherwise, <c>false</c>.</returns>
/// <param name="value">Value.</param>
/// <typeparam name="T">The Type of value.</typeparam>
//
// METHODS FOR BINARY SEARCH TREE
// COMAPRES THE VALUE OF TWO NODES TOGETHER
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Common\Helpers.cs
/// <summary>
/// Swap two values in an IList<T> collection given their indexes.
/// </summary>
//This check is not required but Partition function may make many calls so its for perf reason
/// <summary>
/// Swap two values in an ArrayList<T> collection given their indexes.
/// </summary>
//This check is not required but Partition function may make many calls so its for perf reason
/// <summary>
/// Centralize a text.
/// </summary>
//add a space to the left if the string is an odd number
/// <summary>
/// Populates the specified two-dimensional with a default value.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Common\PrimesList.cs
/// <summary>
/// Provides a list of the first 10,000 primes.
/// This class is a singleton, and read the primes from the file @"Data\PrimesList_10K.csv".
/// </summary>
//
// Singleton implementation with an attempted thread-safety using double-check locking
// internal datastorage singleton container
// lock for thread-safety laziness
//
// INSTANCE VARIABLES
// Picked the HashPrime to be (101) because it is prime, and if the ‘hashSize - 1’ is not a multiple of this HashPrime, which is 
// enforced in _getUpperBoundPrime, then expand function has the potential of being every value from 1 to hashSize - 1. 
// The choice is largely arbitrary.
/// <summary>
/// Empty private constructor.
/// </summary>
/// <summary>
/// Returns the singleton instance of this class.
/// </summary>
/// <summary>
/// Initializes the primes document path and list.
/// </summary>
// Split the line by commas and convert the collection to a list.
// defensive check against empty strings.
// cast them into integers and add them to the primes list
/// <summary>
/// Return count of primes.
/// </summary>
/// <summary>
/// Returns prime number at the specified index.
/// </summary>
/// <summary>
/// Checks if a number is a Prime Number.
/// </summary>
/// <summary>
/// Returns the next biggest prime number.
/// </summary>
/// <param name="number"></param>
/// <returns></returns>
// Outside of our predefined table. Compute the prime the hard way. 
/// <summary>
/// Returns the next minimum prime number.
/// </summary>
// Outside of our predefined table. Compute the prime the hard way. 
/// <summary>
/// Returns the list of primes
/// </summary>
/// <summary>
/// Copy the primes list to an array, starting from a specified index.
/// </summary>
/// <summary>
/// Reads an embedded resource as a text file.
/// </summary>
/// <returns></returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Dictionaries\ChainedHashTable.cs
/***
/// <summary>
/// Hash Table with Chaining.
/// </summary>
/// <summary>
/// Used in the ensure capacity function
/// </summary>
/// <summary>
/// INSTANCE VARIABLES.
/// </summary>
// Keys and Values Comparers
// The C# Maximum Array Length (before encountering overflow)
// Reference: http://referencesource.microsoft.com/#mscorlib/system/array.cs,2d2b551eabe74985
// Initial hash value.
/// <summary>
/// CONSTRUCTOR
/// </summary>
/// <summary>
/// Rehash the the current collection elements to a new collection.
/// </summary>
// Reset the free slots count
//end-for
/// <summary>
/// Contracts the capacity of the keys and values arrays.
/// </summary>
// Try to expand the size
// Rehash
//end-if
/// <summary>
/// Expands the capacity of the keys and values arrays.
/// </summary>
// Make sure it doesn't divide by 2 or 10
// Handle overflow
// Try to expand the size
// Rehash
//end-if
/// <summary>
/// A high-level functon that handles both contraction and expansion of the internal collection.
/// </summary>
/// <param name="mode">Contract or Expand.</param>
/// <param name="newSize">The new expansion size.</param>
// If the size of the internal collection is less than or equal to third of 
// ... the total capacity then contract the internal collection
/// <summary>
/// Hash Function.
/// The universal hashing principle method.
/// </summary>
// Hashes
// Primes
/// <summary>
/// Hash Function.
/// The division method hashing.
/// </summary>
/// <summary>
/// Returns an integer that represents the key.
/// Used in the _hashKey function.
/// </summary>
/// <summary>
/// Returns a key from 0 to m where m is the size of the keys-and-values map. The hash serves as an index.
/// </summary>
/// <summary>
/// Returns a key from 0 to m where m is the size of the keys-and-values map. The hash serves as an index.
/// Division Method.
/// </summary>
/// <summary>
/// Return count of elements in the hash table.
/// </summary>
/// <summary>
/// Checks if the hash table is readonly.
/// </summary>
/// <summary>
/// Checks if the hash table is empty.
/// </summary>
/// <summary>
/// Checks whether key exists in the hash table.
/// </summary>
// Get hash of the key
// The chain of colliding keys are found at _keysValuesMap[hashcode] as a doubly-linked-list.
// else
/// <summary>
/// Checks whether a key-value pair exist in the hash table.
/// </summary>
// Get hash of the key
// The chain of colliding keys are found at _keysValuesMap[hashcode] as a doubly-linked-list.
// do nothing
// else
/// <summary>
/// List of hash table keys.
/// </summary>
/// <summary>
/// List of hash table values.
/// </summary>
/// <summary>
/// Tries to get the value of key which might not be in the dictionary.
/// </summary>
// Get hash of the key
// The chain of colliding keys are found at _keysValuesMap[hashcode] as a doubly-linked-list.
// do nothing
// NOT FOUND
/// <summary>
/// Gets or sets the value of a key.
/// </summary>
// Get hash of the key
// The chain of colliding keys are found at _keysValuesMap[hashcode] as a doubly-linked-list.
// do nothing
// NOT FOUND
// Get hash of the key
// The chain of colliding keys are found at _keysValuesMap[hashcode] as a doubly-linked-list.
// NOT FOUND
/// <summary>
/// Add a key and value to the hash table.
/// </summary>
// Get hash of the key
// The chain of colliding keys are found at _keysValuesMap[hashcode] as a doubly-linked-list.
// This is an empty slot. Initialize the chain of collisions.
// Decrease the number of free slots.
//Add the key-value to the keys and values collections
// Capacity management
/// <summary>
/// Add a key-value pair to the hash table.
/// </summary>
/// <summary>
/// Remove a key from the hash table and return the status.
/// </summary>
// Get hash of the key
// The chain of colliding keys are found at _keysValuesMap[hashcode] as a doubly-linked-list.
// check if no other keys exist in this slot.
// Nullify the chain of collisions at this slot.
// Increase the number of free slots.
// Capacity management
// do nothing
// else
/// <summary>
/// Remove a key-value pair from the hash table and return the status.
/// </summary>
// Get hash of the key
// The chain of colliding keys are found at _keysValuesMap[hashcode] as a doubly-linked-list.
// check if no other keys exist in this slot.
// Nullify the chain of collisions at this slot.
// Increase the number of free slots.
// Capacity management
// do nothing
// else
/// <summary>
/// Copy the key-value pairs in the hash table to an array starting from the specified index.
/// </summary>
/// <summary>
/// Clears this instance.
/// </summary>
// Clear the elements in the store
// Re-initialize to empty collection.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Dictionaries\CuckooHashTable.cs
/***
/// <summary>
/// THE CUCKOO HASH TABLE Data Structure.
/// </summary>
/// <summary>
/// THE CUCKOO HASH TABLE ENTERY
/// </summary>
/// <summary>
/// INSTANCE VARIABLES
/// </summary>
// number of hash functions to use, selected 7 because it's prime. The choice was arbitrary.
// Random number generator
// The C# Maximum Array Length (before encountering overflow)
// Reference: http://referencesource.microsoft.com/#mscorlib/system/array.cs,2d2b551eabe74985
/// <summary>
/// CONSTRUCTOR
/// </summary>
/// <summary>
/// Expands the size of internal collection.
/// </summary>
// Handle overflow
/// <summary>
/// Contracts the size of internal collection to half.
/// </summary>
/// <summary>
/// Rehashes the internal internal collection.
/// Table size stays the same, but generates new hash functions.
/// </summary>
/// <summary>
/// Rehashes the internal collection to a new size.
/// New hash table size, but the hash functions stay the same.
/// </summary>
// Reset size
// In case a memory overflow happens, return the data to it's old state
// ... then throw the exception.
/// <summary>
/// Hashes a key, using the specified hash function number which belongs to the internal hash functions family.
/// </summary>
/// <summary>
/// Checks whether there is an entry at the specified position and that the entry is active.
/// </summary>
/// <summary>
/// Returns the array position (index) of the specified key.
/// </summary>
// The hash functions numbers are indexed from 1 not zero
/// <summary>
/// Inserts a key-value pair into hash table.
/// </summary>
// The hash functions numbers are indexed from 1 not zero
// Increment size
// Eviction strategy:
// No available spot was found. Choose a random one.
// SWAP ENTRY
//end-for
// Expand the table.
// Reset number of rehashes.
// Rehash the table with the same current size.
//end-while
/// <summary>
/// Returns number of items in hash table.
/// </summary>
/// <returns></returns>
/// <summary>
/// Returns true if hash table is empty; otherwise, false.
/// </summary>
/// <summary>
/// Returns the value of the specified key, if exists; otherwise, raises an exception.
/// </summary>
/// <summary>
/// Checks if a key exists in the hash table.
/// </summary>
/// <param name="key"></param>
/// <returns></returns>
/// <summary>
/// Insert key-value pair into hash table.
/// </summary>
/// <summary>
/// Updates a key-value pair with a new value.
/// </summary>
/// <summary>
/// Remove the key-value pair specified by the given key.
/// </summary>
// Mark the entry as not active
// Decrease the size
/// <summary>
/// Clears this hash table.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Dictionaries\OpenAddressingHashTable.cs
/// <summary>
/// Open Addressing Data Structure
/// </summary>
/// <typeparam name="TKey"></typeparam>
/// <typeparam name="TValue"></typeparam>
/// <summary>
/// Open Addressing Entry
/// </summary>
/// <typeparam name="TKey"></typeparam>
/// <typeparam name="TValue"></typeparam>
/// <summary>
/// CONSTRUCTOR
/// </summary>
/// 
//initialize all values to -1
//initialize each slot
//doubles the size of the table
//will hold contents of _table to copy over
//double the size and rehash
//initialize each slot
//rehash over the newly sized table
//this should rehash since the size is now doubled so the hashing will be different
//inserts the key into _table
//rehashes table
//will hold contents of _table to copy over
//initialize each slot
//rehash over the newly sized table
//this should rehash since the size is now doubled so the hashing will be different
//inserts the key into _table
//grabs hash value for a string
//https://stackoverflow.com/questions/4092393/value-of-type-t-cannot-be-converted-to
//https://stackoverflow.com/questions/400733/how-to-get-ascii-value-of-string-in-c-sharp
//calculates first hash values
//calculate second hash value
//grabs a hash value for a char
//https://stackoverflow.com/questions/4092393/value-of-type-t-cannot-be-converted-to
//calculates first hash values
//calculate second hash value
//calculates first hash values
//calculate second hash value
//slot index based on first hash value, second hash value as an offset based on a counter, will also guarentee that the slot will be within the range 0 to size
//makes sure there are no duplicate keys
//calculate index
//set value and key
//increment how many items are in the table
//every slot is in the table is occupied
//expand and rehash
//returns value
//removes key-value pair from the table
//find position and reset values
//number of items in the table decreases
//rehash table --necessary for Open Addressing since keys could have different positions due to this key
//removes key-value pair from the table
//clears table of all values
//Tries to get the value of key which might not be in the dictionary.
//not found
//finds the key and returns index in the table
//calculate index
//returns true if the key is in the table
//returns true if the key is in the table
//returns the number of items in the table
//returns bool depending on whether or not the table is read only
//returns a list of keys in the table
//returns a list of values in the table
//----------------------------------------------------------------------
//-----------------------NOT IMPLEMENTED YET----------------------------
//----------------------------------------------------------------------
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Dictionaries\OpenScatterHashTable.cs
/// <summary>
/// Hash Table with Open Addressing.
/// </summary>
/// <summary>
/// Hash Table Cell.
/// </summary>
/// <summary>
/// INSTANCE VARIABLES
/// </summary>
// Initialization-related
// Helper collections.
// Keys and Values Comparers
// A collection of prime numbers to use as hash table sizes. 
// This is the maximum prime that is smaller than the C# maximum allowed size of arrays.
// Check the following reference: 
// C# Maximum Array Length (before encountering overflow).
// Link: http://referencesource.microsoft.com/#mscorlib/system/array.cs,2d2b551eabe74985
// Picked the HashPrime to be (101) because it is prime, and if the ‘hashSize - 1’ is not a multiple of this HashPrime, which is 
// enforced in _getUpperBoundPrime, then expand function has the potential of being every value from 1 to hashSize - 1. 
// The choice is largely arbitrary.
/// <summary>
/// The hash table cell status modes: Empty cell, Occupied cell, Deleted cell.
/// </summary>
/// <summary>
/// Used in the ensure capacity function
/// </summary>
/// <summary>
/// Returns the next biggest prime that is greater than twice the size of the interal array (size * 2).
/// </summary>
// Allow the hashtables to grow to maximum possible size (~2G elements) before encoutering capacity overflow.
// Note that this check works even when _items.Length overflowed thanks to the (uint) cast
/// <summary>
/// Get the next smaller prime that is smaller than half the size of the internal array (size / 2);
/// </summary>
/// <summary>
/// Contracts the capacity of the keys and values arrays.
/// </summary>
// Only contract the array if the number of elements is less than 1/3 of the total array size.
// Try to expand the size
// REHASH
/// <summary>
/// Expands the capacity of the keys and values arrays.
/// </summary>
// Try to expand the size
// REHASH
/// <summary>
/// A high-level functon that handles both contraction and expansion of the internal collection.
/// </summary>
/// <param name="mode">Contract or Expand.</param>
/// <param name="newSize">The new expansion size.</param>
// If the size of the internal collection is less than or equal to third of 
// ... the total capacity then contract the internal collection
/// <summary>
/// Returns an integer that represents the key.
/// Used in the _hashKey function.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Graphs\CliqueGraph.cs
/// <summary>
/// Represents an unweighted undirected graph, modeling with a set of its maximal complete subgraphs of it.
/// Should be fast in clustered graphs
/// </summary>
/// <summary>
/// Vertices of the graph.
/// </summary>
/// <summary>
/// A set of cliques minimal with the hability of charaterize the graph.
/// </summary>
/// <summary>
/// Initializes a new instance of the <see cref="DataStructures.Graphs.CliqueGraph`1"/> class.
/// Copies the model from another graph.
/// </summary>
/// <param name="graph">Graph.</param>
// Add vortex
/// <summary>
/// Initializes a new instance of the <see cref="DataStructures.Graphs.CliqueGraph`1"/> class.
/// </summary>
/// <param name="vertices">Initial vertices of the graph</param>
/// <summary>
/// Determines if a set of vertices is complete as a subgraph of this
/// </summary>
/// <returns><c>true</c>, if the set is a complete subgraph, <c>false</c> otherwise.</returns>
/// <param name="vertices">A set of vertices of this graph.</param>
/*
/// <summary>
/// Determines if a set of vertices is complete as a subgraph of another graph
/// </summary>
/// <returns><c>true</c>, if the set is a complete subgraph, <c>false</c> otherwise.</returns>
/// <param name="graph">A graph to determine 'completness'</param>
/// <param name="vertices">A set of vertices of graph.</param>
/// <summary>
/// Expands a clique to a maximal complete
/// </summary>
/// <param name="clan">Clique to expand</param>
// Temporal clique for checking maximality
// Expand NewClique to a maximal complete subgraph
// Destroy every no maximal elements of the graph
// Iterate over a clone of _cliques
/// <summary>
/// Expands a clique to a maximal complete in a given graph
/// </summary>
/// <param name="graph">Graph to use to determine maximality.</param>
/// <param name="clan">Clique to expand.</param>
// Temporal clique for checking maximality
// Expand NewClique to a maximal complete subgraph
/// <summary>
/// Some (temporary) class to compare unorderer pairs.
/// </summary>
/// <summary>
/// Return the subsets of cardinality 2 of a given collection. ie [vertices]².
/// </summary>
/// <returns>Returns an ISet whose elements are every subset of a given set of cardinality 2.</returns>
/// <param name="vertices">Collection whose pairs are going to be returned.</param>
/// <summary>
/// An enumerable collection of all graph edges.
/// </summary>
/// <summary>
/// Get all incoming edges to vertex.
/// </summary>
/// <summary>
/// Get all outgoing edges from a vertex.
/// </summary>
/// <summary>
/// Connects two vertices together.
/// </summary>
/// <returns><c>true</c>, if edge was added, <c>false</c> otherwise.</returns>
/// <param name="firstVertex">First vertex.</param>
/// <param name="secondVertex">Second vertex.</param>
// The new clique that contains the edge (firstVertex, secondVertex)
/// <summary>
/// Deletes an edge, if exists, between two vertices.
/// </summary>
/// <returns><c>true</c>, if edge was removed, <c>false</c> otherwise.</returns>
/// <param name="firstVertex">First vertex.</param>
/// <param name="secondVertex">Second vertex.</param>
//Iterating over a clone of cliques
// clan should be eliminated from cliques and replaced by maximal refinements
// return true when finished
/// <summary>
/// Adds a list of vertices to the graph.
/// </summary>
/// <param name="collection">Collection.</param>
/// <summary>
/// Adds a list of vertices to the graph.
/// </summary>
/// <param name="collection">Collection.</param>
/// <summary>
/// Adds a new vertex to graph.
/// </summary>
/// <returns><c>true</c>, if vertex was added, <c>false</c> otherwise.</returns>
/// <param name="vertex">Vertex.</param>
/// <summary>
/// Removes the specified vertex from graph.
/// </summary>
/// <returns><c>true</c>, if vertex was removed, <c>false</c> otherwise.</returns>
/// <param name="vertex">Vertex.</param>
// Remove vertex from set of vertices, return false if nothing was removed.
// Make the cliques consistent
// clone _cliques and iterate
// if clan was exhausted, remove it;
// else make it maximal
/// <summary>
/// Determines whether this instance has edge the specified firstVertex secondVertex.
/// </summary>
/// <returns><c>true</c> if this instance has edge the specified firstVertex secondVertex; otherwise, <c>false</c>.</returns>
/// <param name="firstVertex">First vertex.</param>
/// <param name="secondVertex">Second vertex.</param>
// If [edge]² (= edge) is contained in some clan, there is an edge.
/// <summary>
/// Determines whether this graph has the specified vertex.
/// </summary>
/// <returns><c>true</c> if this instance has vertex the specified vertex; otherwise, <c>false</c>.</returns>
/// <param name="vertex">Vertex.</param>
/// <summary>
/// Returns the neighbours doubly-linked list for the specified vertex.
/// </summary>
/// <param name="vertex">Vertex.</param>
/// <summary>
/// Clear this graph.
/// </summary>
/// <summary>
/// Returns true, if graph is directed; false otherwise.
/// </summary>
/// <value><c>true</c> if this instance is directed; otherwise, <c>false</c>.</value>
/// <summary>
/// Returns true, if graph is weighted; false otherwise.
/// </summary>
/// <value><c>true</c> if this instance is weighted; otherwise, <c>false</c>.</value>
/// <summary>
/// Gets the count of vetices.
/// </summary>
/// <value>The vertices count.</value>
/// <summary>
/// Returns the list of edges.
/// </summary>
/// <returns></returns>
/// <summary>
/// Returns the list of Vertices.
/// </summary>
/// <value>The vertices.</value>
/// <summary>
/// Returns the list of Vertices.
/// </summary>
/// <value>The vertices.</value>
/// <summary>
/// Gets the cloud of a collection of vetices.
/// A cloud of a collection is the union if the neighborhoods of its elements
/// </summary>
/// <returns>The cloud.</returns>
/// <param name="collection">Collection.</param>
/// <summary>
/// Gets the cloud of a collection of vetices.
/// A cloud of a collection is the union if the neighborhoods of its elements
/// </summary>
/// <returns>The cloud.</returns>
/// <param name="collection">Collection.</param>
/// <param name="useCliques">A set of cliques to use</param>
/// <summary>
/// Returns the conext component of a collection
/// </summary>
/// <returns>The component.</returns>
/// <param name="collection">Collection.</param>
/// <summary>
/// Returns the only connected component containing a given vertex.
/// </summary>
/// <returns>A collection containing the vertex of a connected component</returns>
/// <param name="vertex">Vertex.</param>
/// <summary>
/// Returns the list of maximal cliques
/// </summary>
/// <value>The get cliques.</value>
// TODO: getCliques, this does not return all the maximal cliques; 
// only return enough of them.
/// <summary>
/// Returns the clique number of the current graph.
/// </summary>
/// <value>The clique number.</value>
/// <summary>
/// Returns the collection of the maxium-sized cliques
/// </summary>
/// <value>The get maximum cliques.</value>
/// <summary>
/// Determines if a set of vertices is complete as a subgraph of another graph
/// </summary>
/// <returns><c>true</c>, if the set is a complete subgraph, <c>false</c> otherwise.</returns>
/// <param name="certices">A set of vertices of graph.</param>
/// <summary>
/// Builds the graph of cliques of this graph
/// </summary>
/// <returns>The dual graph.</returns>
// Equals = SetEquals here since cliques are maximal.
/// <summary>
/// Given a path in a dual graph, it return a corresponding path in this graph
/// </summary>
/// <returns>An equivalent path of the clique path.</returns>
/// <param name="path">Path.</param>
// Pick any element of each intersection
// intersection is never empty because 'path' should be a path in a dual graph.
/// <summary>
/// Picks any object in a ISet
/// </summary>
/// <param name="Set">Set.</param>
/// <typeparam name="V">The 1st type parameter.</typeparam>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Graphs\DirectedDenseGraph.cs
/***
/// <summary>
/// INSTANCE VARIABLES
/// </summary>
/// <summary>
/// CONSTRUCTOR
/// </summary>
/// <summary>
/// Helper function. Checks if edge exist in graph.
/// </summary>
/// <summary>
/// Returns true, if graph is directed; false otherwise.
/// </summary>
/// <summary>
/// Returns true, if graph is weighted; false otherwise.
/// </summary>
/// <summary>
/// Gets the count of vetices.
/// </summary>
/// <summary>
/// Gets the count of edges.
/// </summary>
/// <summary>
/// Returns the list of Vertices.
/// </summary>
/// <summary>
/// An enumerable collection of all directed unweighted edges in graph.
/// </summary>
/// <summary>
/// Get all incoming directed unweighted edges to a vertex.
/// </summary>
// from
// to
//end-for
/// <summary>
/// Get all outgoing directed unweighted edges from a vertex.
/// </summary>
// from
// to
//end-for
/// <summary>
/// Connects two vertices together in the direction: first->second.
/// </summary>
// Get indices of vertices
// Check existence of vertices and non-existence of edge
// Increment edges count
/// <summary>
/// Removes edge, if exists, from source to destination.
/// </summary>
// Get indices of vertices
// Check existence of vertices and non-existence of edge
// Increment edges count
/// <summary>
/// Add a collection of vertices to the graph.
/// </summary>
/// <summary>
/// Add vertex to the graph
/// </summary>
// Return of the capacity is reached
// Return if vertex already exists
// Initialize first inserted node
// Try inserting vertex at previously lazy-deleted slot
// Increment vertices count
/// <summary>
/// Removes the specified vertex from graph.
/// </summary>
// Return if graph is empty
// Get index of vertex
// Return if vertex doesn't exists
// Lazy-delete the vertex from graph
//_vertices.Remove (vertex);
// Decrement the vertices count
// Remove all outgoing and incoming edges to this vertex
// Source edge
// Decrement the edges count
// Destination edge
// Decrement the edges count
/// <summary>
/// Checks whether there is an edge from source to destination.
/// </summary>
// Get indices of vertices
// Check the existence of vertices and the directed edge
/// <summary>
/// Determines whether this graph has the specified vertex.
/// </summary>
/// <summary>
/// Returns the neighbours doubly-linked list for the specified vertex.
/// </summary>
// Check existence of vertex
/// <summary>
/// Returns the degree of the specified vertex.
/// </summary>
/// <summary>
/// Returns a human-readable string of the graph.
/// </summary>
/// <summary>
/// A depth first search traversal of the graph starting from the first inserted node.
/// Returns the visited vertices of the graph.
/// </summary>
/// <summary>
/// A depth first search traversal of the graph, starting from a specified vertex.
/// Returns the visited vertices of the graph.
/// </summary>
/// <summary>
/// A breadth first search traversal of the graphstarting from the first inserted node.
/// Returns the visited vertices of the graph.
/// </summary>
/// <summary>
/// A breadth first search traversal of the graph, starting from a specified vertex.
/// Returns the visited vertices of the graph.
/// </summary>
/// <summary>
/// Clear this graph.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Graphs\DirectedSparseGraph.cs
/***
/// <summary>
/// INSTANCE VARIABLES
/// </summary>
/// <summary>
/// CONSTRUCTOR
/// </summary>
/// <summary>
/// Helper function. Checks if edge exist in graph.
/// </summary>
/// <summary>
/// Returns true, if graph is directed; false otherwise.
/// </summary>
/// <summary>
/// Returns true, if graph is weighted; false otherwise.
/// </summary>
/// <summary>
/// Gets the count of vetices.
/// </summary>
/// <summary>
/// Gets the count of edges.
/// </summary>
/// <summary>
/// Returns the list of Vertices.
/// </summary>
/// <summary>
/// An enumerable collection of all directed unweighted edges in graph.
/// </summary>
// from
// to
/// <summary>
/// Get all incoming directed unweighted edges to a vertex.
/// </summary>
// from
// to
//end-foreach
/// <summary>
/// Get all outgoing directed unweighted edges from a vertex.
/// </summary>
// from
// to
/// <summary>
/// Connects two vertices together in the direction: first->second.
/// </summary>
// Check existence of nodes and non-existence of edge
// Add edge from source to destination
// Increment edges count
/// <summary>
/// Removes edge, if exists, from source to destination.
/// </summary>
// Check existence of nodes and non-existence of edge
// Remove edge from source to destination
// Decrement the edges count
/// <summary>
/// Add a collection of vertices to the graph.
/// </summary>
/// <summary>
/// Add vertex to the graph
/// </summary>
/// <summary>
/// Removes the specified vertex from graph.
/// </summary>
// Check existence of vertex
// Subtract the number of edges for this vertex from the total edges count
// Remove vertex from graph
// Remove destination edges to this vertex
// Decrement the edges count.
/// <summary>
/// Checks whether there is an edge from source to destination.
/// </summary>
/// <summary>
/// Checks whether a vertex exists in the graph
/// </summary>
/// <summary>
/// Returns the neighbours doubly-linked list for the specified vertex.
/// </summary>
/// <summary>
/// Returns the degree of the specified vertex.
/// </summary>
/// <summary>
/// Returns a human-readable string of the graph.
/// </summary>
/// <summary>
/// A depth first search traversal of the graph starting from the first inserted node.
/// Returns the visited vertices of the graph.
/// </summary>
/// <summary>
/// A depth first search traversal of the graph, starting from a specified vertex.
/// Returns the visited vertices of the graph.
/// </summary>
// Check for existence of source
/// <summary>
/// A breadth first search traversal of the graphstarting from the first inserted node.
/// Returns the visited vertices of the graph.
/// </summary>
/// <summary>
/// A breadth first search traversal of the graph, starting from a specified vertex.
/// Returns the visited vertices of the graph.
/// </summary>
// Check for existence of source
/// <summary>
/// Clear this graph.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Graphs\DirectedWeightedDenseGraph.cs
/***
/// <summary>
/// This class represents the graph as an adjacency-matrix (two dimensional integer array).
/// </summary>
/// <summary>
/// INSTANCE VARIABLES
/// </summary>
// Store edges and their weights as integers.
// Any edge with a value of zero means it doesn't exist. Otherwise, it exist with a specific weight value.
// Default value for positive edges is 1.
/// <summary>
/// CONSTRUCTOR
/// </summary>
/// <summary>
/// Helper function. Checks if edge exist in graph.
/// </summary>
/// <summary>
/// Helper function. Gets the weight of a directed edge.
/// </summary>
/// <summary>
/// Returns true, if graph is weighted; false otherwise.
/// </summary>
/// <summary>
/// An enumerable collection of all weighted directed edges in graph.
/// </summary>
/// <summary>
/// Get all incoming unweighted edges to a vertex.
/// </summary>
// from
// to
// weight
//end-for
/// <summary>
/// Get all outgoing unweighted edges from a vertex.
/// </summary>
// from
// to
// weight
//end-for
/// <summary>
/// Obsolete. Another AddEdge function is implemented with a weight parameter.
/// </summary>
/// <summary>
/// Connects two vertices together with a weight, in the direction: first->second.
/// </summary>
// Return if the weight is equals to the empty edge value
// Get indices of vertices
// Check existence of vertices and non-existence of edge
// Increment edges count
/// <summary>
/// Removes edge, if exists, from source to destination.
/// </summary>
// Get indices of vertices
// Check existence of vertices and non-existence of edge
// Increment edges count
/// <summary>
/// Updates the edge weight from source to destination.
/// </summary>
// Return if the weight is equals to the empty edge value
// Get indices of vertices
// Check existence of vertices and non-existence of edge
/// <summary>
/// Removes the specified vertex from graph.
/// </summary>
// Return if graph is empty
// Get index of vertex
// Return if vertex doesn't exists
// Lazy-delete the vertex from graph
//_vertices.Remove (vertex);
// Decrement the vertices count
// Remove all outgoing and incoming edges to this vertex
// Outgoing edge
// Decrement the edges count
// Incoming edge
// Decrement the edges count
/// <summary>
/// Get edge object from source to destination.
/// </summary>
// Get indices of vertices
// Check the existence of vertices and the directed edge
/// <summary>
/// Returns the edge weight from source to destination.
/// </summary>
/// <summary>
/// Returns the neighbours of a vertex as a dictionary of nodes-to-weights.
/// </summary>
// Check existence of vertex
/// <summary>
/// Returns a human-readable string of the graph.
/// </summary>
/// <summary>
/// Clear this graph.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Graphs\DirectedWeightedSparseGraph.cs
/***
/// <summary>
/// INSTANCE VARIABLES
/// </summary>
/// <summary>
/// CONSTRUCTOR
/// </summary>
/// <summary>
/// Helper function. Returns edge object from source to destination, if exists; otherwise, null.
/// </summary>
// Predicate
// Try to find a match
// Return!
// Might return a null object.
/// <summary>
/// Helper function. Checks if edge exist in graph.
/// </summary>
/// <summary>
/// Helper function. Gets the weight of a directed edge.
/// Presumes edge does already exist.
/// </summary>
/// <summary>
/// Returns true, if graph is directed; false otherwise.
/// </summary>
/// <summary>
/// Returns true, if graph is weighted; false otherwise.
/// </summary>
/// <summary>
/// Gets the count of vetices.
/// </summary>
/// <summary>
/// Gets the count of edges.
/// </summary>
/// <summary>
/// Returns the list of Vertices.
/// </summary>
/// <summary>
/// An enumerable collection of all directed weighted edges in graph.
/// </summary>
/// <summary>
/// Get all incoming directed weighted edges to a vertex.
/// </summary>
//end-foreach
/// <summary>
/// Get all outgoing directed weighted edges from a vertex.
/// </summary>
/// <summary>
/// Obsolete. Another AddEdge function is implemented with a weight parameter.
/// </summary>
/// <summary>
/// Connects two vertices together with a weight, in the direction: first->second.
/// </summary>
// Check existence of nodes, the validity of the weight value, and the non-existence of edge
// Add edge from source to destination
// Increment edges count
/// <summary>
/// Removes edge, if exists, from source to destination.
/// </summary>
// Check existence of nodes and non-existence of edge
// Try get edge
// Return false if edge doesn't exists
// Remove edge from source to destination
// Decrement the edges count
// Check existence of vertices and validity of the weight value
/// <summary>
/// Get edge object from source to destination.
/// </summary>
// Check the existence of edge
// Try get edge
/// <summary>
/// Returns the edge weight from source to destination.
/// </summary>
/// <summary>
/// Add a collection of vertices to the graph.
/// </summary>
/// <summary>
/// Add vertex to the graph
/// </summary>
/// <summary>
/// Removes the specified vertex from graph.
/// </summary>
// Check existence of vertex
// Subtract the number of edges for this vertex from the total edges count
// Remove vertex from graph
// Remove destination edges to this vertex
// Decrement the edges count.
/// <summary>
/// Checks whether there is an edge from source to destination.
/// </summary>
/// <summary>
/// Checks whether a vertex exists in the graph
/// </summary>
/// <summary>
/// Returns the neighbours doubly-linked list for the specified vertex.
/// </summary>
/// <summary>
/// Returns the neighbours of a vertex as a dictionary of nodes-to-weights.
/// </summary>
/// <summary>
/// Returns the degree of the specified vertex.
/// </summary>
/// <summary>
/// Returns a human-readable string of the graph.
/// </summary>
/// <summary>
/// A depth first search traversal of the graph starting from the first inserted node.
/// Returns the visited vertices of the graph.
/// </summary>
/// <summary>
/// A depth first search traversal of the graph, starting from a specified vertex.
/// Returns the visited vertices of the graph.
/// </summary>
// Check for existence of source
/// <summary>
/// A breadth first search traversal of the graphstarting from the first inserted node.
/// Returns the visited vertices of the graph.
/// </summary>
/// <summary>
/// A breadth first search traversal of the graph, starting from a specified vertex.
/// Returns the visited vertices of the graph.
/// </summary>
// Check for existence of source
/// <summary>
/// Clear this graph.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Graphs\IEdge.cs
/// <summary>
/// This interface should be implemented by all edges classes.
/// </summary>
/// <summary>
/// Gets a value indicating whether this edge is weighted.
/// </summary>
/// <value><c>true</c> if this edge is weighted; otherwise, <c>false</c>.</value>
/// <summary>
/// Gets or sets the source.
/// </summary>
/// <value>The source.</value>
/// <summary>
/// Gets or sets the destination.
/// </summary>
/// <value>The destination.</value>
/// <summary>
/// Gets or sets the weight of edge.
/// Unwighted edges can be thought of as edges of the same weight
/// </summary>
/// <value>The weight.</value>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Graphs\IGraph.cs
/// <summary>
/// Returns true, if graph is directed; false otherwise.
/// </summary>
/// <summary>
/// Returns true, if graph is weighted; false otherwise.
/// </summary>
/// <summary>
/// Gets the count of vetices.
/// </summary>
/// <summary>
/// Gets the count of edges.
/// </summary>
/// <summary>
/// Returns the list of Vertices.
/// </summary>
/// <summary>
/// An enumerable collection of edges.
/// </summary>
/// <summary>
/// Get all incoming edges from vertex
/// </summary>
/// <summary>
/// Get all outgoing edges from vertex
/// </summary>
/// <summary>
/// Connects two vertices together.
/// </summary>
/// <summary>
/// Deletes an edge, if exists, between two vertices.
/// </summary>
/// <summary>
/// Adds a list of vertices to the graph.
/// </summary>
/// <summary>
/// Adds a new vertex to graph.
/// </summary>
/// <summary>
/// Removes the specified vertex from graph.
/// </summary>
/// <summary>
/// Checks whether two vertices are connected (there is an edge between firstVertex & secondVertex)
/// </summary>
/// <summary>
/// Determines whether this graph has the specified vertex.
/// </summary>
/// <summary>
/// Returns the neighbours doubly-linked list for the specified vertex.
/// </summary>
/// <summary>
/// Returns the degree of the specified vertex.
/// </summary>
/// <summary>
/// Returns a human-readable string of the graph.
/// </summary>
/// <summary>
/// A depth first search traversal of the graph. Prints nodes as they get visited.
/// It considers the first inserted vertex as the start-vertex for the walk.
/// </summary>
/// <summary>
/// A depth first search traversal of the graph, starting from a specified vertex. Prints nodes as they get visited.
/// </summary>
/// <summary>
/// A breadth first search traversal of the graph. Prints nodes as they get visited.
/// It considers the first inserted vertex as the start-vertex for the walk.
/// </summary>
/// <summary>
/// A breadth first search traversal of the graph, starting from a specified vertex. Prints nodes as they get visited.
/// </summary>
/// <summary>
/// Clear this graph.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Graphs\IWeightedGraph.cs
/// <summary>
/// This interface should be implemented alongside the IGraph interface.
/// </summary>
/// <summary>
/// Connects two vertices together with a weight, in the direction: first->second.
/// </summary>
/// <summary>
/// Updates the edge weight from source to destination.
/// </summary>
/// <summary>
/// Get edge object from source to destination.
/// </summary>
/// <summary>
/// Returns the edge weight from source to destination.
/// </summary>
/// <summary>
/// Returns the neighbours of a vertex as a dictionary of nodes-to-weights.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Graphs\UndirectedDenseGraph.cs
/***
/// <summary>
/// INSTANCE VARIABLES
/// </summary>
/// <summary>
/// CONSTRUCTORS
/// </summary>
/// <summary>
/// Helper function. Checks if edge exist in graph.
/// </summary>
/// <summary>
/// Helper function that checks whether a vertex exist.
/// </summary>
/// <summary>
/// Returns true, if graph is directed; false otherwise.
/// </summary>
/// <summary>
/// Returns true, if graph is weighted; false otherwise.
/// </summary>
/// <summary>
/// Gets the count of vetices.
/// </summary>
/// <summary>
/// Gets the count of edges.
/// </summary>
/// <summary>
/// Returns the list of Vertices.
/// </summary>
/// <summary>
/// An enumerable collection of edges.
/// </summary>
// Check existence of vertex
//end-foreach
/// <summary>
/// Get all incoming edges to a vertex
/// </summary>
// from
// to
//end-for
/// <summary>
/// Get all outgoing edges from a vertex.
/// </summary>
// from
// to
//end-for
/// <summary>
/// Connects two vertices together.
/// </summary>
// Increment the edges count.
/// <summary>
/// Deletes an edge, if exists, between two vertices.
/// </summary>
// Decrement the edges count.
/// <summary>
/// Adds a list of vertices to the graph.
/// </summary>
/// <summary>
/// Adds a new vertex to graph.
/// </summary>
// Return if graph reached it's maximum capacity
// Return if vertex exists
// Initialize first inserted node
// Try inserting vertex at previously lazy-deleted slot
// Increment the vertices count
/// <summary>
/// Removes the specified vertex from graph.
/// </summary>
// Return if graph is empty
// Get index of vertex
// Return if vertex doesn't exists
// Lazy-delete the vertex from graph
//_vertices.Remove (vertex);
// Decrement the vertices count
// Delete the edges
// Decrement the edges count
/// <summary>
/// Checks whether two vertices are connected (there is an edge between firstVertex & secondVertex)
/// </summary>
// Check the existence of vertices and the directed edge
/// <summary>
/// Determines whether this graph has the specified vertex.
/// </summary>
/// <summary>
/// Returns the neighbours doubly-linked list for the specified vertex.
/// </summary>
/// <summary>
/// Returns the degree of the specified vertex.
/// </summary>
/// <summary>
/// Returns a human-readable string of the graph.
/// </summary>
/// <summary>
/// A depth first search traversal of the graph starting from the first inserted node.
/// Returns the visited vertices of the graph.
/// </summary>
/// <summary>
/// A depth first search traversal of the graph, starting from a specified vertex.
/// Returns the visited vertices of the graph.
/// </summary>
/// <summary>
/// A breadth first search traversal of the graphstarting from the first inserted node.
/// Returns the visited vertices of the graph.
/// </summary>
/// <summary>
/// A breadth first search traversal of the graph, starting from a specified vertex.
/// Returns the visited vertices of the graph.
/// </summary>
/// <summary>
/// Clear this graph.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Graphs\UndirectedSparseGraph.cs
/***
/// <summary>
/// INSTANCE VARIABLES
/// </summary>
/// <summary>
/// CONSTRUCTORS
/// </summary>
/// <summary>
/// Helper function. Checks if edge exist in graph.
/// </summary>
/// <summary>
/// Returns true, if graph is directed; false otherwise.
/// </summary>
/// <summary>
/// Returns true, if graph is weighted; false otherwise.
/// </summary>
/// <summary>
/// Gets the count of vetices.
/// </summary>
/// <summary>
/// Gets the count of edges.
/// </summary>
/// <summary>
/// Returns the list of Vertices.
/// </summary>
/// <summary>
/// An enumerable collection of all unweighted edges in Graph.
/// </summary>
//end-foreach
/// <summary>
/// Get all incoming unweighted edges to a vertex
/// </summary>
/// <summary>
/// Get all outgoing unweighted edges from a vertex.
/// </summary>
/// <summary>
/// Connects two vertices together.
/// </summary>
// Increment the edges count
/// <summary>
/// Deletes an edge, if exists, between two vertices.
/// </summary>
// Decrement the edges count
/// <summary>
/// Adds a list of vertices to the graph.
/// </summary>
/// <summary>
/// Adds a new vertex to graph.
/// </summary>
// Check existence of vertex
/// <summary>
/// Removes the specified vertex from graph.
/// </summary>
// Check existence of vertex
// Decrement the edges count.
/// <summary>
/// Checks whether two vertices are connected (there is an edge between firstVertex & secondVertex)
/// </summary>
// Check existence of vertices
/// <summary>
/// Determines whether this graph has the specified vertex.
/// </summary>
/// <summary>
/// Returns the neighbours doubly-linked list for the specified vertex.
/// </summary>
/// <summary>
/// Returns the degree of the specified vertex.
/// </summary>
/// <summary>
/// Returns a human-readable string of the graph.
/// </summary>
/// <summary>
/// A depth first search traversal of the graph starting from the first inserted node.
/// Returns the visited vertices of the graph.
/// </summary>
/// <summary>
/// A depth first search traversal of the graph, starting from a specified vertex.
/// Returns the visited vertices of the graph.
/// </summary>
/// <summary>
/// A breadth first search traversal of the graphstarting from the first inserted node.
/// Returns the visited vertices of the graph.
/// </summary>
/// <summary>
/// A breadth first search traversal of the graph, starting from a specified vertex.
/// Returns the visited vertices of the graph.
/// </summary>
/// <summary>
/// Clear this graph.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Graphs\UndirectedWeightedDenseGraph.cs
/***
/// <summary>
/// This class represents the graph as an adjacency-matrix (two dimensional integer array).
/// </summary>
/// <summary>
/// INSTANCE VARIABLES
/// </summary>
// Store edges and their weights as integers.
// Any edge with a value of zero means it doesn't exist. Otherwise, it exist with a specific weight value.
// Default value for positive edges is 1.
/// <summary>
/// CONSTRUCTOR
/// </summary>
/// <summary>
/// Helper function. Checks if edge exist in graph.
/// </summary>
/// <summary>
/// Helper function. Gets the weight of a undirected edge.
/// </summary>
/// <summary>
/// Returns true, if graph is weighted; false otherwise.
/// </summary>
/// <summary>
/// An enumerable collection of edges.
/// </summary>
// Check existence of vertex
// Undirected edges should be checked once
//end-foreach
/// <summary>
///     Get all incoming edges to a vertex
/// </summary>
// from
// to
// weight
/// <summary>
///     Get all outgoing weighted edges from vertex
/// </summary>
// from
// to
// weight
/// <summary>
/// Connects two vertices together with a weight, in the direction: first->second.
/// </summary>
// Return if the weight is equals to the empty edge value
// Get indices of vertices
// Check existence of vertices and non-existence of edge
// Use only one triangle of the matrix
// Increment edges count
/// <summary>
/// Removes edge, if exists, from source to destination.
/// </summary>
/// <summary>
/// Updates the edge weight from source to destination.
/// </summary>
/// <summary>
/// Removes the specified vertex from graph.
/// </summary>
// Return if graph is empty
// Get index of vertex
// Return if vertex doesn't exists
// Lazy-delete the vertex from graph
//_vertices.Remove (vertex);
// Decrement the vertices count
// Remove all outgoing and incoming edges to this vertex
// Decrement the edges count
/// <summary>
///     Get edge object from source to destination.
/// </summary>
/// <summary>
///     Returns the edge weight from source to destination.
/// </summary>
/// <summary>
/// Returns the neighbours of a vertex as a dictionary of nodes-to-weights.
/// </summary>
// Check existence of vertex
/// <summary>
/// Returns a human-readable string of the graph.
/// </summary>
/// <summary>
/// Clear this graph.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Graphs\UndirectedWeightedSparseGraph.cs
/***
/// <summary>
/// INSTANCE VARIABLES
/// </summary>
/// <summary>
/// CONSTRUCTOR
/// </summary>
/// <summary>
/// Helper function. Returns edge object from source to destination, if exists; otherwise, null.
/// </summary>
// Could return a null object.
/// <summary>
/// Helper function. Checks if edge exist in graph.
/// </summary>
/// <summary>
/// Helper function. Gets the weight of a undirected edge.
/// Presumes edge does already exist.
/// </summary>
/// <summary>
/// Returns true, if graph is undirected; false otherwise.
/// </summary>
/// <summary>
/// Returns true, if graph is weighted; false otherwise.
/// </summary>
/// <summary>
/// Gets the count of vetices.
/// </summary>
/// <summary>
/// Gets the count of edges.
/// </summary>
/// <summary>
/// Returns the list of Vertices.
/// </summary>
/// <summary>
/// An enumerable collection of all weighted edges in Graph.
/// </summary>
//end-foreach
/// <summary>
/// Get all incoming weighted edges to a vertex
/// </summary>
/// <summary>
/// Get all outgoing weighted edges from a vertex.
/// </summary>
/// <summary>
/// Obsolete. Another AddEdge function is implemented with a weight parameter.
/// </summary>
/// <summary>
/// Connects two vertices together with a weight, in the direction: first->second.
/// </summary>
// Check existence of nodes, the validity of the weight value, and the non-existence of edge
// Add edge from source to destination
// Increment edges count
/// <summary>
/// Removes edge, if exists, from source to destination.
/// </summary>
// Check existence of nodes and non-existence of edge
// If edge doesn't exist, return false
// If edge exists in the source neighbors, remove it
// If edge exists in the destination neighbors, remove it.
// Decrement the edges count
// Check existence of vertices and validity of the weight value
// Status flag of updating an edge
// Check the source neighbors
// Check the destination neighbors
/// <summary>
/// Get edge object from source to destination.
/// </summary>
// Check the existence of edge
// Try get edge
/// <summary>
/// Returns the edge weight from source to destination.
/// </summary>
/// <summary>
/// Add a collection of vertices to the graph.
/// </summary>
/// <summary>
/// Add vertex to the graph
/// </summary>
/// <summary>
/// Removes the specified vertex from graph.
/// </summary>
// Check existence of vertex
// Remove vertex from graph
// Remove destination edges to this vertex
/// <summary>
/// Checks whether there is an edge from source to destination.
/// </summary>
/// <summary>
/// Checks whether a vertex exists in the graph
/// </summary>
/// <summary>
/// Returns the neighbours doubly-linked list for the specified vertex.
/// </summary>
/// <summary>
/// Returns the neighbours of a vertex as a dictionary of nodes-to-weights.
/// </summary>
/// <summary>
/// Returns the degree of the specified vertex.
/// </summary>
/// <summary>
/// Returns a human-readable string of the graph.
/// </summary>
/// <summary>
/// A depth first search traversal of the graph starting from the first inserted node.
/// Returns the visited vertices of the graph.
/// </summary>
/// <summary>
/// A depth first search traversal of the graph, starting from a specified vertex.
/// Returns the visited vertices of the graph.
/// </summary>
// Check for existence of source
/// <summary>
/// A breadth first search traversal of the graphstarting from the first inserted node.
/// Returns the visited vertices of the graph.
/// </summary>
/// <summary>
/// A breadth first search traversal of the graph, starting from a specified vertex.
/// Returns the visited vertices of the graph.
/// </summary>
// Check for existence of source
/// <summary>
/// Clear this graph.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Graphs\UnweightedEdge.cs
/// <summary>
/// The graph edge class.
/// </summary>
/// <summary>
/// Gets or sets the source vertex.
/// </summary>
/// <value>The source.</value>
/// <summary>
/// Gets or sets the destination vertex.
/// </summary>
/// <value>The destination.</value>
/// <summary>
/// [PRIVATE MEMBER] Gets or sets the weight.
/// </summary>
/// <value>The weight.</value>
/// <summary>
/// Gets a value indicating whether this edge is weighted.
/// </summary>
/// <summary>
/// CONSTRUCTOR
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Graphs\WeightedEdge.cs
/// <summary>
/// The graph weighted edge class.
/// </summary>
/// <summary>
/// Gets or sets the source.
/// </summary>
/// <value>The source.</value>
/// <summary>
/// Gets or sets the destination.
/// </summary>
/// <value>The destination.</value>
/// <summary>
/// Gets or sets the weight of edge.
/// </summary>
/// <value>The weight.</value>
/// <summary>
/// Gets a value indicating whether this edge is weighted.
/// </summary>
/// <summary>
/// CONSTRUCTOR
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Hashing\PrimeHashingFamily.cs
/***
/// <summary>
/// Implements a family of randomized Hash Functions
/// </summary>
/// <summary>
/// Initializes the family with a specified number of hash functions.
/// </summary>
/// <summary>
/// Returns number of member hash functions.
/// </summary>
/// <summary>
/// Generates new hash functions with new randomized multipliers.
/// </summary>
// Clear the multipliers vectors
/// <summary>
/// Returns hash value of an integer prehash key, given the specified number of the hash function to use.
/// </summary>
/// <param name="preHashedKey">Int pre-hash code of an object.</param>
/// <param name="whichHashFunction">Non-zero, non-negative integer that specified the number of the hash function to use.</param>
/// <returns></returns>
/// <summary>
/// Returns hash value of a string, given the specified number of the hash function to use.
/// </summary>
/// <param name="key">string key.</param>
/// <param name="whichHashFunction">Non-zero, non-negative integer that specified the number of the hash function to use.</param>
/// <returns></returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Hashing\UniversalHashingFamily.cs
/***
/// <summary>
/// Implements a family of Universal Hash Functions
/// </summary>
// A large prime, arbitrarily chosen
// In decimal = 2,146,435,069;
/// <summary>
/// Initializes the family with a specified number of hash functions.
/// </summary>
/// <summary>
/// Returns number of member hash functions.
/// </summary>
/// <summary>
/// Generates new hash functions with new randomized multipliers.
/// </summary>
// Clear the multipliers vectors
// Get only the primes that are smaller than the biggest-chosen prime.
// make sure the next prime we choose is different than the first one and less than the biggest-prime.
/// <summary>
/// Returns hash value of a string, given the specified number of the hash function to use.
/// </summary>
/// <param name="preHashedKey">Int pre-hash code of an object.</param>
/// <param name="whichHashFunction">Non-zero, non-negative integer that specified the number of the hash function to use.</param>
/// <returns></returns>
/// <summary>
/// Returns hash value of a string, given the specified number of the hash function to use.
/// </summary>
/// <param name="key">string key.</param>
/// <param name="whichHashFunction">Non-zero, non-negative integer that specified the number of the hash function to use.</param>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Heaps\BinaryMaxHeap.cs
/// <summary>
/// Maximum Heap Data Structure.
/// </summary>
/// <summary>
/// Instance Variables.
/// _collection: The list of elements. Implemented as an array-based list with auto-resizing.
/// </summary>
/// <summary>
/// CONSTRUCTORS
/// </summary>
/// <summary>
/// Private Method. Builds a max heap from the inner array-list _collection.
/// </summary>
/// <summary>
/// Private Method. Used to restore heap condition after insertion
/// </summary>
/// <summary>
/// Private Method. Used in Building a Max Heap.
/// </summary>
// assume that the subtrees left(node) and right(node) are max-heaps
// If collection[left] > collection[nodeIndex]
// If collection[right] > collection[largest]
// Swap and heapify
/// <summary>
/// Returns the number of elements in heap
/// </summary>
/// <summary>
/// Checks whether this heap is empty
/// </summary>
/// <summary>
/// Gets or sets the at the specified index.
/// </summary>
// greater than or equal to max
/// <summary>
/// Heapifies the specified newCollection. Overrides the current heap.
/// </summary>
// Reset and reserve the size of the newCollection
// Copy the elements from the newCollection to the inner collection
// Build the heap
/// <summary>
/// Adding a new key to the heap.
/// </summary>
/// <summary>
/// Find the maximum node of a max heap.
/// </summary>
/// <summary>
/// Removes the node of minimum value from a min heap.
/// </summary>
/// <summary>
/// Returns the node of maximum value from a max heap after removing it from the heap.
/// </summary>
/// <summary>
/// Clear this heap.
/// </summary>
/// <summary>
/// Rebuilds the heap.
/// </summary>
/// <summary>
/// Returns an array version of this heap.
/// </summary>
/// <summary>
/// Returns a list version of this heap.
/// </summary>
/// <summary>
/// Union two heaps together, returns a new min-heap of both heaps' elements, 
/// ... and then destroys the original ones.
/// </summary>
// Create a new heap with reserved size.
// Insert into the new heap.
// Destroy the two heaps.
/// <summary>
/// Returns a new min heap that contains all elements of this heap.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Heaps\BinaryMinHeap.cs
/// <summary>
/// Minimum Heap Data Structure.
/// </summary>
/// <summary>
/// Instance Variables.
/// _collection: The list of elements. Implemented as an array-based list with auto-resizing.
/// </summary>
/// <summary>
/// CONSTRUCTORS
/// </summary>
/// <summary>
/// Builds a min heap from the inner array-list _collection.
/// </summary>
/// <summary>
/// Private Method. Used to restore heap condition after insertion
/// </summary>
/// <summary>
/// Private Method. Used in Building a Min Heap.
/// </summary>
/// <typeparam name="T">Type of Heap elements</typeparam>
/// <param name="nodeIndex">The node index to heapify at.</param>
/// <param name="lastIndex">The last index of collection to stop at.</param>
// assume that the subtrees left(node) and right(node) are max-heaps
// If collection[left] < collection[nodeIndex]
// If collection[right] < collection[smallest]
// Swap and heapify
/// <summary>
/// Returns the number of elements in heap
/// </summary>
/// <summary>
/// Checks whether this heap is empty
/// </summary>
/// <summary>
/// Gets or sets the at the specified index.
/// </summary>
/// <param name="index">Index.</param>
// less than or equal to min
/// <summary>
/// Heapifies the specified newCollection. Overrides the current heap.
/// </summary>
/// <param name="newCollection">New collection.</param>
// Reset and reserve the size of the newCollection
// Copy the elements from the newCollection to the inner collection
// Build the heap
/// <summary>
/// Adding a new key to the heap.
/// </summary>
/// <param name="heapKey">Heap key.</param>
/// <summary>
/// Find the minimum node of a min heap.
/// </summary>
/// <returns>The minimum.</returns>
/// <summary>
/// Removes the node of minimum value from a min heap.
/// </summary>
/// <summary>
/// Returns the node of minimum value from a min heap after removing it from the heap.
/// </summary>
/// <returns>The min.</returns>
/// <summary>
/// Clear this heap.
/// </summary>
/// <summary>
/// Rebuilds the heap.
/// </summary>
/// <summary>
/// Returns an array version of this heap.
/// </summary>
/// <summary>
/// Returns a list version of this heap.
/// </summary>
/// <summary>
/// Union two heaps together, returns a new min-heap of both heaps' elements, 
/// ... and then destroys the original ones.
/// </summary>
// Create a new heap with reserved size.
// Insert into the new heap.
// Destroy the two heaps.
/// <summary>
/// Returns a new max heap that contains all elements of this heap.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Heaps\BinomialMinHeap.cs
/// <summary>
/// BINOMIAL MIN HEAP Data Structure
/// </summary>
/// <summary>
/// The Heap Node class.
/// </summary>
// Right-Sibling
// Left-Child
// Constructors
// Helper boolean flags
/// <summary>
/// INSTANCE VARIABLES
/// </summary>
/// <summary>
/// CONSTRUCTORS
/// </summary>
// Empty constructor
/************************************************************************************************/
/** PRIVATE HELPER FUNCTIONS                                                                    */
/// <summary>
/// Removes root of tree at he specified index.
/// </summary>
// Get the deletedTree
// The min-root lies at _forest[minIndex]
// Exit if there was no children under old-min-root
// CONSTRUCT H'' (double-prime)
// CONSTRUCT H' (single-prime)
// Decrease the size
/// <summary>
/// Returns index of the tree with the minimum root's value.
/// </summary>
// Loop until you reach a slot in the _forest that is not null.
// The final value of "i" will be pointing to the non-null _forest slot.
// Loop over the trees in forest, and return the index of the slot that has the tree with the min-valued root
/// <summary>
/// Combines two trees and returns the new tree root node.
/// </summary>
/// <summary>
/// Clones a tree, given it's root node.
/// </summary>
/************************************************************************************************/
/** PUBLIC API FUNCTIONS                                                                        */
/// <summary>
/// Returns count of elements in heap.
/// </summary>
/// <summary>
/// Checks if heap is empty
/// </summary>
/// <returns></returns>
/// <summary>
/// Initializes this heap with a collection of elements.
/// </summary>
/// <summary>
/// Inserts a new item to heap.
/// </summary>
// Merge this with tempHeap
// Increase the _size
/// <summary>
/// Return the min element.
/// </summary>
/// <summary>
/// Remove the min element from heap.
/// </summary>
/// <summary>
/// Return the min element and then remove it from heap.
/// </summary>
// Get the min-node index
// Remove min from heap
/// <summary>
/// Merges the elements of another heap with this heap.
/// </summary>
// Avoid aliasing problems
// Avoid null or empty cases
// One capacity-change step
/*** SINGLE CASES ***/
/* No trees */
/* Only this */
/* Only otherHeap */
/* Only carryNode */
/*** BINARY CASES ***/
/* this and otherHeap */
/* this and carryNode */
/* otherHeap and carryNode */
/* all the nodes */
//end-switch
//end-for
// Clear otherHeap
/// <summary>
/// Returns an array copy of heap.
/// </summary>
/// <summary>
/// Rebuilds the heap.
/// </summary>
/// <summary>
/// Returns a list copy of heap.
/// </summary>
/// <summary>
/// Returns a binomial max-heap copy of this instance.
/// </summary>
/// <summary>
/// Clear this instance.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Heaps\IMaxHeap.cs
/// <summary>
/// Returns the number of elements in heap
/// </summary>
/// <summary>
/// Checks whether this heap is empty
/// </summary>
/// <summary>
/// Heapifies the specified newCollection. Overrides the current heap.
/// </summary>
/// <param name="newCollection">New collection.</param>
/// <summary>
/// Adding a new key to the heap.
/// </summary>
/// <param name="heapKey">Heap key.</param>
/// <summary>
/// Find the maximum node of a max heap.
/// </summary>
/// <returns>The maximum.</returns>
/// <summary>
/// Removes the node of maximum value from a max heap.
/// </summary>
/// <summary>
/// Returns the node of maximum value from a max heap after removing it from the heap.
/// </summary>
/// <returns>The max.</returns>
/// <summary>
/// Clear this heap.
/// </summary>
/// <summary>
/// Rebuilds the heap.
/// </summary>
/// <summary>
/// Returns an array version of this heap.
/// </summary>
/// <returns>The array.</returns>
/// <summary>
/// Returns a list version of this heap.
/// </summary>
/// <returns>The list.</returns>
/// <summary>
/// Returns a new max heap that contains all elements of this heap.
/// </summary>
/// <returns>The max heap.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Heaps\IMinHeap.cs
/// <summary>
/// Returns the number of elements in heap
/// </summary>
/// <summary>
/// Checks whether this heap is empty
/// </summary>
/// <summary>
/// Heapifies the specified newCollection. Overrides the current heap.
/// </summary>
/// <param name="newCollection">New collection.</param>
/// <summary>
/// Adding a new key to the heap.
/// </summary>
/// <param name="heapKey">Heap key.</param>
/// <summary>
/// Find the minimum node of a min heap.
/// </summary>
/// <returns>The minimum.</returns>
/// <summary>
/// Removes the node of minimum value from a min heap.
/// </summary>
/// <summary>
/// Returns the node of minimum value from a min heap after removing it from the heap.
/// </summary>
/// <returns>The min.</returns>
/// <summary>
/// Clear this heap.
/// </summary>
/// <summary>
/// Rebuilds the heap.
/// </summary>
/// <summary>
/// Returns an array version of this heap.
/// </summary>
/// <returns>The array.</returns>
/// <summary>
/// Returns a list version of this heap.
/// </summary>
/// <returns>The list.</returns>
/// <summary>
/// Returns a new min heap that contains all elements of this heap.
/// </summary>
/// <returns>The min heap.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Heaps\KeyedPriorityQueue.cs
/// <summary>
/// Implements the Keyed Priority Queue Data Structure.
/// All nodes have: a Key, a Value, a Priority
/// <typeparam name="K">Node's Key type</typeparam>
/// <typeparam name="V">Node's Value type</typeparam>
/// <typeparam name="P">Node's Priority type</typeparam>
/// </summary>
/// <summary>
/// Instance variables
/// </summary>
/// <summary>
/// CONSTRUCTOR
/// </summary>
/// <summary>
/// CONSTRUCTOR
/// </summary>
/// <param name="capacity">Capacity of priority queue.</param>
/// <summary>
/// CONSTRUCTOR
/// </summary>
/// <param name="capacity">Capacity of priority queue.</param>
/// <param name="priorityComparer">The node's priority comparer.</param>
/// <summary>
/// Returns the count of elements in the queue.
/// </summary>
/// <summary>
/// Checks if the queue is empty
/// <returns>True if queue is empty; false otherwise.</returns>
/// </summary>
/// <summary>
/// Returns an array of keys
/// </summary>
/// <summary>
/// Returns the highest priority element.
/// </summary>
/// <returns>The at highest priority.</returns>
/// <summary>
/// Enqueue the specified key and value without priority.
/// </summary>
/// <param name="key">Key.</param>
/// <param name="value">Value.</param>
/// <summary>
/// Enqueue the specified key, value and priority.
/// </summary>
/// <param name="key">Key.</param>
/// <param name="value">Value.</param>
/// <param name="priority">Priority.</param>
/// <summary>
/// Dequeue this instance.
/// </summary>
// Decrement the key's counter
/// <summary>
/// Sets the priority.
/// </summary>
/// <param name="key">Key.</param>
/// <param name="newPriority">New priority.</param>
// Handle boundaries errors
/// <summary>
/// Clear this priority queue.
/// </summary>
///// <summary>
///// Removes the node that has the specified key.
///// </summary>
///// <param name="key">Key.</param>
//public void Remove(K key)
//{
//    if (_heap.IsEmpty)
//    {
//        throw new ArgumentOutOfRangeException ("Queue is empty.");
//    }
//
//    var keyComparer = Comparer<K>.Default;
//
//    Predicate<PriorityQueueNode<K, V, P>> match = 
//        new Predicate<PriorityQueueNode<K, V, P>> (
//            item => keyComparer.Compare(item.Key, key) == 0);
//
//    _heap.RemoveAll (match);
//}
///// <summary>
///// Removes the node that has the specified key and value.
///// </summary>
///// <param name="key">Key.</param>
///// <param name="value">Value.</param>
//public void Remove(K key, V value)
//{
//    if (_heap.IsEmpty)
//    {
//        throw new ArgumentOutOfRangeException ("Queue is empty.");
//    }
//
//    var keyComparer = Comparer<K>.Default;
//    var valueComparer = Comparer<V>.Default;
//
//    Predicate<PriorityQueueNode<K, V, P>> match = 
//        new Predicate<PriorityQueueNode<K, V, P>> (
//            item => 
//            keyComparer.Compare(item.Key, key) == 0 && 
//            valueComparer.Compare(item.Value, value) == 0);
//
//    _heap.RemoveAll (match);
//}
/// <summary>
/// The Priority-queue node.
/// </summary>
/// <typeparam name="K">Node's Key type</typeparam>
/// <typeparam name="V">Node's Value type</typeparam>
/// <typeparam name="P">Node's Priority type</typeparam>
//end-of-node-class
/// <summary>
/// Keyed Priority-queue node comparer.
/// </summary>
//end-of-comparer-class
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Heaps\MinPriorityQueue.cs
/// <summary>
/// Implements the Priority Queue Data Structure.
/// <typeparam name="TKey">Node's Value type</typeparam>
/// <typeparam name="TPriority">Node's Priority type</typeparam>
/// </summary>
/// <summary>
/// Instance variables
/// </summary>
// A dictionary of keys and number of copies in the heap.
// The internal heap.
// The priorities value comparer.
/// <summary>
/// CONSTRUCTOR
/// </summary>
// Make sure the TPriority is elegible for a priority
// Initialize comparer
// Initialize.
/// <summary>
/// Validates the Type of TPriority. Returns true if acceptable, false otherwise.
/// </summary>
/// <returns></returns>
//case TypeCode.DateTime:
/// <summary>
/// Returns the count of elements in the queue.
/// </summary>
/// <summary>
/// Checks if the queue is empty
/// </summary>
/// <summary>
/// Get the default max priority, if set, raises an exception if not set.
/// Also sets the default max priority.
/// </summary>
/// <summary>
/// Returns the highest priority element.
/// </summary>
/// <returns>The at highest priority.</returns>
/// <summary>
/// Checks for the existence of a key in the queue
/// </summary>
/// <summary>
/// Enqueue the specified key, with the default-max-priority value.
/// </summary>
/// <summary>
/// Enqueue the specified key, value and priority.
/// </summary>
/// <param name="value">Value.</param>
/// <param name="priority">Priority.</param>
/// <summary>
/// Dequeue this instance.
/// </summary>
// Decrease the key count.
// Remove key if its count is zero
/// <summary>
/// Sets the priority.
/// </summary>
// Handle boundaries errors
/// <summary>
/// Clear this priority queue.
/// </summary>
/// <summary>
/// The Priority-queue node.
/// </summary>
/// <typeparam name="K">Node's Key type</typeparam>
/// <typeparam name="TKey">Node's Value type</typeparam>
//end-of-node-class
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Lists\ArrayList.cs
/// <summary>
/// The Array-Based List Data Structure.
/// </summary>
/// <summary>
/// Instance variables.
/// </summary>
// This sets the default maximum array length to refer to MAXIMUM_ARRAY_LENGTH_x64
// Set the flag IsMaximumCapacityReached to false
// The C# Maximum Array Length (before encountering overflow)
// Reference: http://referencesource.microsoft.com/#mscorlib/system/array.cs,2d2b551eabe74985
//x64
//x86
// This is used as a default empty list initialization.
// The default capacity to resize to, when a minimum is lower than 5.
// The internal array of elements.
// NOT A PROPERTY.
// This keeps track of the number of elements added to the array.
// Serves as an index of last item + 1.
/// <summary>
/// CONSTRUCTORS
/// </summary>
// Zerofiy the _size;
/// <summary>
/// Ensures the capacity.
/// </summary>
/// <param name="minCapacity">Minimum capacity.</param>
// If the length of the inner collection is less than the minCapacity
// ... and if the maximum capacity wasn't reached yet, 
// ... then maximize the inner collection.
// Allow the list to grow to maximum possible capacity (~2G elements) before encountering overflow.
// Note that this check works even when _items.Length overflowed thanks to the (uint) cast
/// <summary>
/// Resizes the collection to a new maximum number of capacity.
/// </summary>
/// <param name="newCapacity">New capacity.</param>
/// <summary>
/// Gets the the number of elements in list.
/// </summary>
/// <value>Int.</value>
/// <summary>
/// Returns the capacity of list, which is the total number of slots.
/// </summary>
/// <summary>
/// Determines whether this list is empty.
/// </summary>
/// <returns><c>true</c> if list is empty; otherwise, <c>false</c>.</returns>
/// <summary>
/// Gets the first element in the list.
/// </summary>
/// <value>The first.</value>
/// <summary>
/// Gets the last element in the list.
/// </summary>
/// <value>The last.</value>
/// <summary>
/// Gets or sets the item at the specified index.
/// example: var a = list[0];
/// example: list[0] = 1;
/// </summary>
/// <param name="index">Index.</param>
/// <summary>
/// Add the specified dataItem to list.
/// </summary>
/// <param name="dataItem">Data item.</param>
/// <summary>
/// Adds an enumerable collection of items to list.
/// </summary>
/// <param name="elements"></param>
// make sure the size won't overflow by adding the range
// grow the internal collection once to avoid doing multiple redundant grows
/// <summary>
/// Adds an element to list repeatedly for a specified count.
/// </summary>
// grow the internal collection once to avoid doing multiple redundant grows
/// <summary>
/// Inserts a new element at an index. Doesn't override the cell at index.
/// </summary>
/// <param name="dataItem">Data item to insert.</param>
/// <param name="index">Index of insertion.</param>
// If the inner array is full and there are no extra spaces, 
// ... then maximize it's capacity to a minimum of _size + 1.
// If the index is not "at the end", then copy the elements of the array
// ... between the specified index and the last index to the new range (index + 1, _size);
// The cell at "index" will become available.
// Write the dataItem to the available cell.
// Increase the size.
/// <summary>
/// Removes the specified dataItem from list.
/// </summary>
/// <returns>>True if removed successfully, false otherwise.</returns>
/// <param name="dataItem">Data item.</param>
/// <summary>
/// Removes the list element at the specified index.
/// </summary>
/// <param name="index">Index of element.</param>
// Decrease the size by 1, to avoid doing Array.Copy if the element is to be removed from the tail of list. 
// If the index is still less than size, perform an Array.Copy to override the cell at index.
// This operation is O(N), where N = size - index.
// Reset the writable cell to the default value of type T.
/// <summary>
/// Clear this instance.
/// </summary>
/// <summary>
/// Resize the List to a new size.
/// </summary>
/// <summary>
/// Resize the list to a new size.
/// </summary>
// Optimisation step.
// This is just to avoid multiple automatic capacity changes.
/// <summary>
/// Reverses this list.
/// </summary>
/// <summary>
/// Reverses the order of a number of elements. Starting a specific index.
/// </summary>
/// <param name="startIndex">Start index.</param>
/// <param name="count">Count of elements to reverse.</param>
// Handle the bounds of startIndex
// Handle the bounds of count and startIndex with respect to _size.
// Use Array.Reverse
// Running complexity is better than O(N). But unknown.
// Array.Reverse uses the closed-source function TrySZReverse.
/// <summary>
/// For each element in list, apply the specified action to it.
/// </summary>
/// <param name="action">Typed Action.</param>
// Null actions are not allowed.
/// <summary>
/// Checks whether the list contains the specified dataItem.
/// </summary>
/// <returns>True if list contains the dataItem, false otherwise.</returns>
/// <param name="dataItem">Data item.</param>
// Null-value check
// Construct a default equality comparer for this Type T
// Use it to get the equal match for the dataItem
/// <summary>
/// Checks whether the list contains the specified dataItem.
/// </summary>
/// <returns>True if list contains the dataItem, false otherwise.</returns>
/// <param name="dataItem">Data item.</param>
/// <param name="comparer">The Equality Comparer object.</param>
// Null comparers are not allowed.
// Null-value check
/// <summary>
/// Checks whether an item specified via a Predicate<T> function exists exists in list.
/// </summary>
/// <param name="searchMatch">Match predicate.</param>
// Use the FindIndex to look through the collection
// If the returned index != -1 then it does exist, otherwise it doesn't.
/// <summary>
/// Finds the index of the element that matches the predicate.
/// </summary>
/// <returns>The index of element if found, -1 otherwise.</returns>
/// <param name="searchMatch">Match predicate.</param>
/// <summary>
/// Finds the index of the element that matches the predicate.
/// </summary>
/// <returns>The index of the element if found, -1 otherwise.</returns>
/// <param name="startIndex">Starting index to search from.</param>
/// <param name="searchMatch">Match predicate.</param>
/// <summary>
/// Finds the index of the first element that matches the given predicate function.
/// </summary>
/// <returns>The index of element if found, -1 if not found.</returns>
/// <param name="startIndex">Starting index of search.</param>
/// <param name="count">Count of elements to search through.</param>
/// <param name="searchMatch">Match predicate function.</param>
// Check bound of startIndex
// CHeck the bounds of count and startIndex with respect to _size
// Null match-predicates are not allowed
// Start the search
// Not found, return -1
/// <summary>
/// Returns the index of a given dataItem.
/// </summary>
/// <returns>Index of element in list.</returns>
/// <param name="dataItem">Data item.</param>
/// <summary>
/// Returns the index of a given dataItem.
/// </summary>
/// <returns>Index of element in list.</returns>
/// <param name="dataItem">Data item.</param>
/// <param name="startIndex">The starting index to search from.</param>
/// <summary>
/// Returns the index of a given dataItem.
/// </summary>
/// <returns>Index of element in list.</returns>
/// <param name="dataItem">Data item.</param>
/// <param name="startIndex">The starting index to search from.</param>
/// <param name="count">Count of elements to search through.</param>
// Check the bound of the starting index.
// Check the bounds of count and starting index with respect to _size.
// Everything is cool, start looking for the index
// Use the Array.IndexOf
// Array.IndexOf has a O(n) running time complexity, where: "n = count - size".
// Array.IndexOf uses EqualityComparer<T>.Default to return the index of element which loops
// ... over all the elements in the range [startIndex,count) in the array.
/// <summary>
/// Find the specified element that matches the Search Predication.
/// </summary>
/// <param name="searchMatch">Match predicate.</param>
// Null Predicate functions are not allowed. 
// Begin searching, and return the matched element
// Not found, return the default value of the type T.
/// <summary>
/// Finds all the elements that match the typed Search Predicate.
/// </summary>
/// <returns>ArrayList<T> of matched elements. Empty list is returned if not element was found.</returns>
/// <param name="searchMatch">Match predicate.</param>
// Null Predicate functions are not allowed. 
// Begin searching, and add the matched elements to the new list.
// Return the new list of elements.
/// <summary>
/// Get a range of elements, starting from an index..
/// </summary>
/// <returns>The range as ArrayList<T>.</returns>
/// <param name="startIndex">Start index to get range from.</param>
/// <param name="count">Count of elements.</param>
// Handle the bound errors of startIndex
// Handle the bound errors of count and startIndex with respect to _size
// Use Array.Copy to quickly copy the contents from this array to the new list's inner array.
// Assign count to the new list's inner _size counter.
/// <summary>
/// Return an array version of this list.
/// </summary>
/// <returns>Array.</returns>
/// <summary>
/// Return an array version of this list.
/// </summary>
/// <returns>Array.</returns>
/// <summary>
/// Return a human readable, multi-line, print-out (string) of this list.
/// </summary>
/// <returns>The human readable string.</returns>
/// <param name="addHeader">If set to <c>true</c> a header with count and Type is added; otherwise, only elements are printed.</param>
/********************************************************************************/
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Lists\CircularBuffer.cs
/// <summary>
/// Returns the length of the buffer
/// </summary>
/// <summary>
///  Checks if no element is inserted into the buffer
/// </summary>
/// <summary>
/// Checks if the buffer is filled up
/// </summary>
/// <summary>
/// Controls whether data should be overridden when it is continously inserted without reading
/// </summary>
/// <summary>
/// Initializes a circular buffer with initial length of 10
/// </summary>
/// <summary>
/// Initializes a circular buffer with given length
/// </summary>
/// <param name="length">The length of the buffer</param>
/// <summary>
/// Writes value to the back of the buffer
/// </summary>
/// <param name="value">value to be added to the buffer</param>
// Inserts data into the buffer without checking if it is full
// Count should not be greater than the length of the buffer when overriding 
/// <summary>
///     Reads and removes the value in front of the buffer, and places the next value in front.
/// </summary>
//Count should not go below Zero when poping an empty buffer.
/// <summary>
/// Returns the number of elements.
/// </summary>
/// <summary>
/// Checks whether this collection is readonly
/// </summary>
/// <summary>
/// Clears this instance
/// </summary>
/// <summary>
/// Checks whether the buffer contains an item
/// </summary>
/// <summary>
/// Copies this buffer to an array
/// </summary>
// Get enumerator
// Copy elements if there is any in the buffer and if the index is within the valid range
/// <summary>
/// Removes an item from the buffer
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Lists\DLinkedList.cs
/// <summary>
/// The Doubly-Linked List Node class.
/// </summary>
/// <typeparam name="T">Type</typeparam>
/***********************************************************************************/
/// <summary>
/// Doubly-Linked List Data Structure.
/// </summary>
/// <typeparam name="T">Type</typeparam>
/// <summary>
/// Instance variables.
/// </summary>
/// <summary>
/// Gets the element at the specified index
/// </summary>
/// <param name="index">Index of element</param>
/// <returns>Element</returns>
// Decide from which reference to traverse the list, and then move the currentNode reference to the index
// If index > half then traverse it from the end (_lastNode reference)
// Otherwise, traverse it from the beginning (_firstNode refrence)
/// <summary>
/// Sets the value of the element at the specified index
/// </summary>
/// <param name="index">Index of element to update.</param>
/// <returns>Element</returns>
// Decide from which reference to traverse the list, and then move the currentNode reference to the index
// If index > half then traverse it from the end (_lastNode reference)
// Otherwise, traverse it from the beginning (_firstNode refrence)
/// <summary>
/// CONSTRUCTOR
/// </summary>
/// <summary>
/// Determines whether this List is empty.
/// </summary>
/// <returns><c>true</c> if this list is empty; otherwise, <c>false</c>.</returns>
/// <summary>
/// Getter function that returns the first element
/// </summary>
/// <summary>
/// Getter function that returns the last element
/// </summary>
/// <summary>
/// Implements the collection-index operator.
/// Gets or sets the element at the specified index
/// </summary>
/// <param name="index">Index of element.</param>
/// <summary>
/// Returns the index of an item if exists.
/// </summary>
// Get currentNode to reference the element at the index.
//end-while
/// <summary>
/// Prepend the specified dataItem at the beginning of the list.
/// </summary>
/// <param name="dataItem">Data item.</param>
// Increment the count.
/// <summary>
/// Append the specified dataItem at the end of the list.
/// </summary>
/// <param name="dataItem">Data item.</param>
// Increment the count.
/// <summary>
/// Inserts the dataItem at the specified index.
/// </summary>
/// <param name="dataItem">Data item.</param>
/// <param name="index">Index.</param>
// Increment the count
/// <summary>
/// Inserts the dataItem after specified index.
/// </summary>
/// <param name="dataItem">Data item.</param>
/// <param name="index">Index.</param>
// Insert at previous index.
/// <summary>
/// Remove the specified dataItem.
/// </summary>
// Handle index out of bound errors
// Remove
// Get currentNode to reference the element at the index.
//end-while
// Throw exception if item was not found
// Remove element
// Decrement count.
/// <summary>
/// Remove the specified dataItem.
/// </summary>
// Handle index out of bound errors
// Remove
// Get currentNode to reference the element at the index.
//end-while
// If we reached the last node and item was not found
// Throw exception
// Remove element
// Decrement count.
/// <summary>
/// Removes the item at the specified index.
/// </summary>
/// <returns>True if removed successfully, false otherwise.</returns>
/// <param name="index">Index of item.</param>
// Handle index out of bound errors
// Remove
// Get currentNode to reference the element at the index.
//end-while
// Remove element
//end-else
// Decrement count.
/// <summary>
/// Clears the list.
/// </summary>
/// <summary>
/// Chesk whether the specified element exists in the list.
/// </summary>
/// <param name="dataItem">Value to check for.</param>
/// <returns>True if found; false otherwise.</returns>
/// <summary>
/// Find the specified item in the list.
/// </summary>
/// <param name="dataItem">Value to find.</param>
/// <returns>value.</returns>
/// <summary>
/// Tries to find a match for the predicate. Returns true if found; otherwise false.
/// </summary>
// Initialize the output parameter
/// <summary>
/// Find the first element that matches the predicate from all elements in list.
/// </summary>
/// <summary>
/// Find all elements in list that match the predicate.
/// </summary>
/// <param name="match">Predicate function.</param>
/// <returns>List of elements.</returns>
/// <summary>
/// Returns a number of elements as specified by countOfElements, starting from the specified index.
/// </summary>
/// <param name="index">Starting index.</param>
/// <param name="countOfElements">The number of elements to return.</param>
/// <returns>Doubly-Linked List of elements</returns>
// Handle Index out of Bound errors
// Decide from which reference to traverse the list, and then move the currentNode reference to the index
// If index > half then traverse it from the end (_lastNode reference)
// Otherwise, traverse it from the beginning (_firstNode refrence)
// Append the elements to the new list using the currentNode reference
/// <summary>
/// Sorts the entire list using Selection Sort.
/// </summary>
/// <summary>
/// Return an array version of this list.
/// </summary>
/// <returns></returns>
/// <summary>
/// Returns a System.List version of this DLList instace.
/// </summary>
/// <returns>System.List of elements</returns>
/// <summary>
/// Returns the list items as a readable multi--line string.
/// </summary>
/// <returns></returns>
/********************************************************************************/
// Alternative: IEnumerator class instance
// return new DLinkedListEnumerator(this);
// Alternative: IEnumerator class instance
// return new DLinkedListEnumerator(this);
/********************************************************************************/
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Lists\DLinkedList_KeyValue.cs
/// <summary>
/// The Doubly-Linked List Node class.
/// </summary>
/// <typeparam name="T">Type</typeparam>
/// <summary>
/// Doubly-Linked List Data Structure.
/// </summary>
/// <typeparam name="T">Type</typeparam>
/// <summary>
/// Instance variables.
/// </summary>
/// <summary>
/// Gets the element at the specified index
/// </summary>
// Decide from which reference to traverse the list, and then move the currentNode reference to the index
// If index > half then traverse it from the end (_lastNode reference)
// Otherwise, traverse it from the beginning (_firstNode refrence)
/// <summary>
/// Gets the element by the specified key
/// </summary>
/// <summary>
/// Sets the node's value by index.
/// </summary>
// Decide from which reference to traverse the list, and then move the currentNode reference to the index
// If index > half then traverse it from the end (_lastNode reference)
// Otherwise, traverse it from the beginning (_firstNode refrence)
/// <summary>
/// Sets the node's value by key.
/// </summary>
/// <summary>
/// Sets the node object by index.
/// </summary>
// Decide from which reference to traverse the list, and then move the currentNode reference to the index
// If index > half then traverse it from the end (_lastNode reference)
// Otherwise, traverse it from the beginning (_firstNode refrence)
/// <summary>
/// CONSTRUCTOR
/// </summary>
/// <summary>
/// Determines whether this List is empty.
/// </summary>
/// <returns><c>true</c> if this list is empty; otherwise, <c>false</c>.</returns>
/// <summary>
/// Getter function that returns the first element
/// </summary>
/// <summary>
/// Getter function that returns the last element
/// </summary>
/// <summary>
/// Returns a list of the keys.
/// </summary>
/// <summary>
/// Returns a list of the values.
/// </summary>
/// <summary>
/// Prepend the key-value at the beginning of the list.
/// </summary>
// Increment the count.
/// <summary>
/// Append the key-value item at the end of the list.
/// </summary>
// Increment the count.
/// <summary>
/// Inserts the a new key-value item at the specified index.
/// </summary>
// Decide from which reference to traverse the list, and then move the currentNode reference to the index
// If index > half then traverse it from the end (_lastNode reference)
// Otherwise, traverse it from the beginning (_firstNode refrence)
// Increment the count
/// <summary>
/// Inserts the key-value after specified index.
/// </summary>
// Insert at previous index.
/// <summary>
/// Removes the item at the specified index.
/// </summary>
// Handle index out of bound errors
// Remove
// Decrement count.
// Decrement count.
// Get currentNode to reference the element at the index.
//end-while
// Remove element
// Decrement count.
//end-else
/// <summary>
/// Removes the item with the specified key.
/// </summary>
// Remove
// Decrement count.
// Decrement count.
// Get currentNode to reference the element at the index.
//end-while
// Remove element
// Decrement count.
//end-else
/// <summary>
/// Updates the value of an element at the specified index.
/// </summary>
/// <summary>
/// Updates the value of an element by it's key.
/// </summary>
/// <summary>
/// Updates the key and value of an element at the specified index.
/// </summary>
/// <summary>
/// Clears the list.
/// </summary>
/// <summary>
/// Chesk whether the specified key exists in the list.
/// </summary>
/// <summary>
/// Find the specified item in the list.
/// </summary>
/// <summary>
/// Find all elements in list that match the predicate.
/// </summary>
/// <param name="match">Predicate function.</param>
/// <returns>List of elements.</returns>
/// <summary>
/// Returns a number of elements as specified by countOfElements, starting from the specified index.
/// </summary>
/// <param name="index">Starting index.</param>
/// <param name="countOfElements">The number of elements to return.</param>
/// <returns>Doubly-Linked List of elements</returns>
// Handle Index out of Bound errors
// Decide from which reference to traverse the list, and then move the currentNode reference to the index
// If index > half then traverse it from the end (_lastNode reference)
// Otherwise, traverse it from the beginning (_firstNode refrence)
// Append the elements to the new list using the currentNode reference
/// <summary>
/// Sorts the entire list using Selection Sort.
/// </summary>
/// <summary>
/// Returns the list items as a readable multi--line string.
/// </summary>
/// <returns></returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Lists\Queue.cs
/// <summary>
/// The Queue (FIFO) Data Structure.
/// </summary>
/// <summary>
/// INSTANCE VARIABLE.
/// </summary>
// The internal collection.
// This sets the default maximum array length to refer to MAXIMUM_ARRAY_LENGTH_x64
// Set the flag IsMaximumCapacityReached to false
// The C# Maximum Array Length (before encountering overflow)
// Reference: http://referencesource.microsoft.com/#mscorlib/system/array.cs,2d2b551eabe74985
//x64
//x86
/// <summary>
/// CONSTRUCTOR
/// </summary>
/// <summary>
/// Resize the internal array to a new size.
/// </summary>
// Allow the list to grow to maximum possible capacity (~2G elements) before encountering overflow.
// Note that this check works even when _items.Length overflowed thanks to the (uint) cast
// Handle the new proper size
// Try resizing and handle overflow
//Array.Resize (ref _collection, newSize);
/// <summary>
/// Returns count of elements in queue
/// </summary>
/// <summary>
/// Checks whether the queue is empty.
/// </summary>
/// <summary>
/// Returns the top element in queue
/// </summary>
/// <summary>
/// Inserts an element at the end of the queue
/// </summary>
/// <param name="dataItem">Element to be inserted.</param>
// Enqueue item at tail and then increment tail
// Wrap around
// Increment size
/// <summary>
/// Removes the Top Element from queue, and assigns it's value to the "top" parameter.
/// </summary>
/// <return>The top element container.</return>
// Decrement the size
// Increment the head pointer
// Reset the pointer
// Shrink the internal collection
// Get head and tail
// Shrink
// Update head and tail pointers
/// <summary>
/// Returns an array version of this queue.
/// </summary>
/// <returns>System.Array.</returns>
/// <summary>
/// Returns a human-readable, multi-line, print-out (string) of this queue.
/// </summary>
/********************************************************************************/
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Lists\SkipList.cs
/***
/// <summary>
/// THE SKIP-LIST DATA STRUCTURE
/// </summary>
// The skip-list root node
// Readonly values
/// <summary>
/// Private helper. Used in Add method.
/// </summary>
/// <returns></returns>
/// <summary>
/// CONSTRUCTOR
/// </summary>
/// <summary>
/// Getter accessor for the first node
/// </summary>
/// <summary>
/// Checks if list is empty or not
/// </summary>
/// <summary>
/// Return count of elements
/// </summary>
/// <summary>
/// Return current max-node level
/// </summary>
/// <summary>
/// Access elements by index
/// </summary>
// TODO:
/// <summary>
/// Adds item to the list
/// </summary>
// Get the next node level, and update list level if required.
// New node
// Insert the new node into the skip list
// Increment the count
/// <summary>
/// Remove element from the list.
/// </summary>
/// <summary>
/// Remove an element from list and then return it
/// </summary>
// Find the node in each of the levels
// Walk after all the nodes that have values less than the node we are looking for.
// Mark all nodes as toBeUpdated.
// Return default value of T if the item was not found
// We know that the node is in the list.
// Unlink it from the levels where it exists.
// Decrement the count
// Check to see if we've deleted the highest-level node
// Decrement level
// Assign the deleted output parameter to the node.Value
/// <summary>
/// Checks if an item is in the list
/// </summary>
/// <summary>
/// Look for an element and return it if found
/// </summary>
// Walk after all the nodes that have values less than the node we are looking for
// Return true if we found the element; false otherwise
/// <summary>
/// Deletes the min element if the list is empty; otherwise throws exception
/// </summary>
/// <summary>
/// Tries to delete the min element, returns false if list is empty
/// </summary>
/// <summary>
/// Returns the first element if the list is not empty; otherwise throw an exception
/// </summary>
/// <summary>
/// Tries to return the first element, if the list is empty it returns false
/// </summary>
/// <summary>
/// IEnumerable method implementation
/// </summary>
/// <summary>
/// IEnumerable method implementation
/// </summary>
/// <summary>
/// Checks whether this collection is readonly
/// </summary>
/// <summary>
/// Copy this list to an array
/// </summary>
// Validate the array and arrayIndex
// Get enumerator
// Copy elements as long as there is any in the list and as long as the index is within the valid range
/// <summary>
/// Clears this instance
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Lists\SkipListNode.cs
/// <summary>
/// Instance variables
/// </summary>
/// <summary>
/// CONSTRUCTORS
/// </summary>
/// <summary>
/// Get and set node's value
/// </summary>
/// <summary>
/// Get and set node's forwards links
/// </summary>
/// <summary>
/// Return level of node.
/// </summary>
/// <summary>
/// IComparable method implementation
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Lists\SLinkedList.cs
/// <summary>
/// The Singly-Linked List Node class
/// </summary>
/// <typeparam name="T"></typeparam>
/// <summary>
/// Singly Linked List Data Structure
/// </summary>
/// <summary>
/// Instance variables
/// </summary>
/// <summary>
/// CONSTRUCTOR
/// </summary>
/// <summary>
/// The Is List Empty check.
/// </summary>
/// <returns>true, if the list is empty, false otherwise.</returns>
/// <summary>
/// Getter function that returns the first element
/// </summary>
/// <summary>
/// Getter function that returns the last element
/// </summary>
/// <summary>
/// Inserts the specified dataItem at the beginning of the list.
/// </summary>
/// <param name="dataItem">The data value to be inserted to the list.</param>
// Increment the count.
/// <summary>
/// Inserts the specified dataItem at the end of the list.
/// </summary>
/// <param name="dataItem">The data value to be inserted to the list.</param>
// Increment the count.
/// <summary>
/// Inserts a specified item dataItem at an index.
/// </summary>
/// <param name="dataItem">Data item.</param>
/// <param name="index">Index.</param>
// Handle scope of insertion.
// Prepend? Append? Or Insert in the range?
// Increment the count
/// <summary>
/// Removes the item at the specified index.
/// </summary>
/// <param name="index">The index of the list node to be removed.</param>
// Handle index out of bound errors
// Remove
// Decrement count.
// Decrement count.
// Decrement the count.
/// <summary>
/// Clears all the items in the list.
/// </summary>
/// <summary>
/// Get the element at the specified index
/// </summary>
/// <param name="index">Index of element</param>
/// <returns>Element</returns>
/// <summary>
/// Returns a number of elements as specified by countOfElements, starting from the specified index.
/// </summary>
/// <param name="index">Starting index.</param>
/// <param name="countOfElements">The number of elements to return.</param>
/// <returns>Singly-Linked List of elements</returns>
// Handle Index out of Bound errors
// Move the currentNode reference to the specified index
// Append the elements to the new list using the currentNode reference
/// <summary>
/// Sorts the entire list using Selection Sort.
/// </summary>
/// <summary>
/// Return an array version of this list.
/// </summary>
/// <returns></returns>
/// <summary>
/// Returns a System.List version of this SLinkedList instace.
/// </summary>
/// <returns>System.List of elements</returns>
/// <summary>
/// Returns the list items as a readable multi--line string.
/// </summary>
/// <returns></returns>
/********************************************************************************/
/********************************************************************************/
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Lists\Stack.cs
/// <summary>
/// The Stack (LIFO) Data Structure.
/// </summary>
/// <typeparam name="T">Type</typeparam>
/// <summary>
/// Instance variables.
/// _collection: Array-Based List.
/// Count: Public Getter for returning the number of elements.
/// </summary>
/// <summary>
/// CONSTRUCTORS
/// </summary>
// The internal collection is implemented as an array-based list.
// See the ArrayList.cs for the list implementation.
// The internal collection is implemented as an array-based list.
// See the ArrayList.cs for the list implementation.
/// <summary>
/// Checks whether the stack is empty.
/// </summary>
/// <returns>True if stack is empty, false otherwise.</returns>
/// <summary>
/// Returns the top element in the stack.
/// </summary>
/// <summary>
/// Inserts an element at the top of the stack.
/// </summary>
/// <param name="dataItem">Element to be inserted.</param>
/// <summary>
/// Removes the top element from stack.
/// </summary>
/// <summary>
/// Returns an array version of this stack.
/// </summary>
/// <returns>System.Array.</returns>
/// <summary>
/// Returns a human-readable, multi-line, print-out (string) of this stack.
/// </summary>
/// <returns>String.</returns>
/********************************************************************************/
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\SortedCollections\SortedDictionary.cs
/// <summary>
/// Sorted Dictionary collection (Red-Black Tree based).
/// </summary>
/// <summary>
/// The internal collection is a Red-Black Tree Map.
/// </summary>
/// <summary>
/// Constructor.
/// </summary>
/// <summary>
/// Gets the count of enteries in dictionary.
/// </summary>
/// <summary>
/// Returns true if dictionary is empty; otherwise, false.
/// </summary>
/// <summary>
/// Determines whether the current dictionary contains an entry with the specified key.
/// </summary>
/// <summary>
/// Determines whether the current collection contains a specific key-value pair.
/// </summary>
/// <summary>
/// Try to get the value of a key or default(TValue). Returns true if key exists; otherwise, false.
/// </summary>
// Set value to the default value of type TValue
// Assign the returned object to value
// return Success.
// No entry was found with the specified key.
// return Failure.
/// <summary>
/// Gets or sets the value at the specified key.
/// </summary>
// In case dictionary is empty
// Mask the tree's exception with a new one.
/// <summary>
/// Gets the collection of keys in the dictionary.
/// </summary>
/// <summary>
/// Gets the collection of values in the dictionary.
/// </summary>
/// <summary>
/// Add the specified key and value to the dictionary.
/// </summary>
// Throw an duplicate key exception if an entry with the same key exists
/// <summary>
/// Removes the item with specific Key from the dictionary.
/// </summary>
// Try removing it and return Success
// Item was not found. Return Failure.
/// <summary>
/// Add the key-value pair to the dictionary.
/// </summary>
/// <summary>
/// Removes the first occurrence of an item from the current collection Key and Value will be matched.
/// </summary>
// Get the entry from collection
// If the entry's value match the value of the specified item, remove it
/// <summary>
/// Copies the key-value pairs to a given array starting from specified index.
/// </summary>
/// <summary>
/// Clears this instance.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\SortedCollections\SortedList.cs
/// <summary>
/// Sorted List (RBTree-based).
/// </summary>
/// <summary>
/// The internal collection is a Red-Black Tree.
/// </summary>
/// <summary>
/// Constructor.
/// </summary>
/// <summary>
/// Returns true if list is empty; otherwise, false.
/// </summary>
/// <summary>
/// Gets the count of items in list.
/// </summary>
/// <summary>
/// Determines whether the current collection contains a specific value.
/// </summary>
/// <summary>
/// Determines the index of a specific item in the current collection.
/// </summary>
// If the item doesn't exist in collection, return -1
// If the current item is found return index
// Increment index
/// <summary>
/// Gets or sets the item at the specified index.
/// </summary>
// In case list is empty
// Validate index range
// Keep moving to the next item until index becomes 0
// Return the enumerator's Current value
// Masks the get method (see above) exception with a new one.
/// <summary>
/// Adds the item to list.
/// </summary>
/// <summary>
/// Removes the first occurrence of an item from list.
/// </summary>
/// <summary>
/// Inserts the item at the specified index.
/// </summary>
// It is meaningless to insert at a specific index since after every
// insert operation, the collection will be rebalanced and the insertion
// operation itself needs to ensure the sorting criteria, therefore the item
// item insert at index i might not be the same after the operation has completed.
/// <summary>
/// Removes an item at a specific index.
/// </summary>
// Validate index range
// Keep moving to the next item until index becomes 0
// Remove the enumerator's Current value from collection
/// <summary>
/// Copies the items in list to an array starting from a given index.
/// </summary>
// Validate the array argument
// Copy the items from the inorder-walker of the tree to the passed array
/// <summary>
/// Clears this instance.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Trees\AugmentedBinarySearchTree.cs
/// <summary>
/// Binary Search Tree node.
/// This node extends the vanilla BSTNode class and adds an extra field to it for augmentation.
/// The BST now augments the subtree-sizes on insert, delete and get-height.
/// </summary>
// Size of subtrees
/******************************************************************************/
/// <summary>
/// Binary Search Tree Data Structure.
/// This is teh augmented version of BST. It is augmented to keep track of the nodes subtrees-sizes.
/// </summary>
/// <summary>
/// Override the Root node accessors.
/// </summary>
/// <summary>
/// CONSTRUCTOR.
/// Allows duplicates by default.
/// </summary>
/// <summary>
/// CONSTRUCTOR.
/// If allowDuplictes is set to false, no duplicate items will be inserted.
/// </summary>
/// <summary>
/// Returns the height of the tree.
/// </summary>
/// <returns>Hight</returns>
/// <summary>
/// Returns the Subtrees size for a tree node if node exists; otherwise 0 (left and right nodes of leafs).
/// This is used in the recursive function UpdateSubtreeSize.
/// </summary>
/// <returns>The size.</returns>
/// <param name="node">BST Node.</param>
/// <summary>
/// Updates the Subtree Size of a tree node.
/// Used in recusively calculating the Subtrees Sizes of nodes.
/// </summary>
/// <param name="node">BST Node.</param>
/// <summary>
/// Remove the specified node.
/// </summary>
/// <param name="node">Node.</param>
/// <returns>>True if removed successfully; false if node wasn't found.</returns>
// if both children are present
// if the node has only a LEFT child
// if the node has only a RIGHT child
//this node has no children
/// <summary>
/// Calculates the tree height from a specific node, recursively.
/// </summary>
/// <param name="node">Node</param>
/// <returns>Height of node's longest subtree</returns>
// it has both a right child and a left child
// return-functions-fix
/// <summary>
/// Inserts an element to the tree
/// </summary>
/// <param name="item">Item to insert</param>
// Invoke the super BST insert node method.
// This insert node recursively starting from the root and checks for success status (related to allowDuplicates flag).
// The functions increments count on its own.
// Update the subtree-size for the newNode's parent.
/// <summary>
/// Inserts an array of elements to the tree.
/// </summary>
/// <summary>
/// Inserts a list of elements to the tree.
/// </summary>
/// <summary>
/// Deletes an element from the tree
/// </summary>
/// <param name="item">item to remove.</param>
// If the element was found, remove it.
/// <summary>
/// Removes the min value from tree.
/// </summary>
// Update the subtrees-sizes
/// <summary>
/// Removes the max value from tree.
/// </summary>
// Update the subtrees-sizes
/// <summary>
/// Returns the rank of the specified element
/// </summary>
/// <param name="item">Tree element</param>
/// <returns>Rank(item) if found; otherwise throws an exception.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Trees\AVLTree.cs
/// <summary>
/// AVL Tree Data Structure.
/// </summary>
/// <summary>
/// Override the Root node accessors
/// </summary>
/// <summary>
/// CONSTRUCTOR.
/// Allows duplicates by default.
/// </summary>
/// <summary>
/// CONSTRUCTOR.
/// If allowDuplictes is set to false, no duplicate items will be inserted.
/// </summary>
/// <summary>
/// Returns the height of a node.
/// </summary>
/// <summary>
/// Updates the height of a node.
/// </summary>
// height = 1 + the max between left and right children.
/// <summary>
/// Updates the height of a node and it's parents' recursivley up to the root of the tree.
/// </summary>
// height = 1 + the max between left and right children.
/// <summary>
/// Returns the AVL balance factor for a node.
/// </summary>
/// <summary>
/// Rotates a node to the left in the AVL tree.
/// </summary>
// We check the right child because it's going to be a pivot node for the rotation
// Pivot on *right* child
// Parent of currentNode
// Check if currentNode is it's parent's left child.
// Check if currentNode is the Root
// Perform the rotation
// Update parents references
//Update the entire tree's Root if necessary
// Update the original parent's child node
// Update the AVL Heights of each node.
// _updateHeightRecursive(pivotNode);
/// <summary>
/// Rotates a node to the right in the AVL tree.
/// </summary>
// We check the right child because it's going to be a pivot node for the rotation
// Pivot on *left* child
// Parent of currentNode
// Check if currentNode is it's parent's left child.
// Check if currentNode is the Root
// Perform the rotation
// Update parents references
// Update the entire tree's Root if necessary
// Update the original parent's child node
// Update the AVL Heights of each node.
// _updateHeightRecursive(pivotNode);
/// <summary>
/// Rebalances the tree around a node.
/// </summary>
// Balance the tree only if the balance factor was less than -1 or greater than +1.
// -2 or 2; -3 or 3 ... etc
// if balance is a positive number: 2, 3 ... etc
// right subtree outweighs
// Rotate *LEFT* on current node
// Rotate *RIGHT* on right child
// Rotate *LEFT* on current node
// if balance is a negative number: -2, -3 ... etc
// left subtree outweighs
// Rotate *RIGHT* on current node
// Rotate *LEFT* on left child
// Rotate *RIGHT* on right child
/// <summary>
/// Rebalances the whole tree around a node.
/// </summary>
// Update this node's height value.
// Get left and right for comparisons
/// <summary>
/// Inserts an item to the tree.
/// </summary>
// New node object
// Invoke the super BST insert node method.
// This insert node recursively starting from the root and checks for success status (related to allowDuplicates flag).
// The functions increments count on its own.
// Rebalance the tree
/// <summary>
/// Inserts an array of elements to the tree.
/// </summary>
/// <summary>
/// Inserts a list of elements to the tree.
/// </summary>
/// <summary>
/// Removes an item fromt he tree
/// </summary>
// Get the node from the tree
// Invoke the BST remove node method.
// Rebalance the tree
// node.parent is actually the old parent of the node,
// which is the first potentially out-of-balance node.
//// Update the node's parent height.
//_updateHeightRecursively(node.Parent);
//// Rebalance the tree
//var parent = node.Parent;
//while(parent != null)
//{
//    _rebalanceSubtreeTreeAt(node.Parent);
//}
/// <summary>
/// Removes the min value from tree.
/// </summary>
// Get the node from the tree
// Invoke the BST remove node method.
// Rebalance the tree
// node.parent is actually the old parent of the node,
// which is the first potentially out-of-balance node.
/// <summary>
/// Removes the max value from tree.
/// </summary>
// Get the node from the tree
// Invoke the BST remove node method.
// Rebalance the tree
// node.parent is actually the old parent of the node,
// which is the first potentially out-of-balance node.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Trees\AVLTreeNode.cs
/// <summary>
/// AVL Tree Node.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Trees\BinarySearchTree.cs
/// <summary>
/// Implements a generic Binary Search Tree data structure.
/// </summary>
/// <typeparam name="T">Type of elements.</typeparam>
/// <summary>
/// Specifies the mode of travelling through the tree.
/// </summary>
/// <summary>
/// TREE INSTANCE VARIABLES
/// </summary>
/// <returns></returns>
/// <summary>
/// CONSTRUCTOR.
/// Allows duplicates by default.
/// </summary>
/// <summary>
/// CONSTRUCTOR.
/// If allowDuplictes is set to false, no duplicate items will be inserted.
/// </summary>
/// <summary>
/// Replaces the node's value from it's parent node object with the newValue.
/// Used in the recusive _remove function.
/// </summary>
/// <param name="node">BST node.</param>
/// <param name="newNode">New value.</param>
/// <summary>
/// Remove the specified node.
/// </summary>
/// <param name="node">Node.</param>
/// <returns>>True if removed successfully; false if node wasn't found.</returns>
// if both children are present
// if the node has only a LEFT child
// if the node has only a RIGHT child
//this node has no children
/// <summary>
/// Inserts a new node to the tree.
/// </summary>
/// <param name="currentNode">Current node to insert afters.</param>
/// <param name="newNode">New node to be inserted.</param>
// Handle empty trees
// Check for value equality and whether inserting duplicates is allowed
// Go Left
// newNode < parent
// Increment count.
// Go Right
// Increment count.
/// <summary>
/// Calculates the tree height from a specific node, recursively.
/// Time-complexity: O(n), where n = number of nodes.
/// </summary>
/// <param name="node">Node</param>
/// <returns>Height of node's longest subtree</returns>
// Is leaf node
// Has two children
// Has only left
// Has only right
/// <summary>
/// Finds a node inside another node's subtrees, given it's value.
/// </summary>
/// <param name="currentNode">Node to start search from.</param>
/// <param name="item">Search value</param>
/// <returns>Node if found; otherwise null</returns>
// Return-functions-fix
/// <summary>
/// Returns the min-node in a subtree.
/// Used in the recusive _remove function.
/// </summary>
/// <returns>The minimum-valued tree node.</returns>
/// <param name="node">The tree node with subtree(s).</param>
/// <summary>
/// Returns the max-node in a subtree.
/// Used in the recusive _remove function.
/// </summary>
/// <returns>The maximum-valued tree node.</returns>
/// <param name="node">The tree node with subtree(s).</param>
/// <summary>
/// Finds the next smaller node in value compared to the specified node.
/// </summary>
/// <summary>
/// Finds the next larger node in value compared to the specified node.
/// </summary>
/// <summary>
/// A recursive private method. Used in the public FindAll(predicate) functions.
/// Implements in-order traversal to find all the matching elements in a subtree.
/// </summary>
/// <param name="currentNode">Node to start searching from.</param>
/// <param name="match"></param>
// call the left child
// match
// call the right child
/// <summary>
/// In-order traversal of the subtrees of a node. Returns every node it vists.
/// </summary>
/// <param name="currentNode">Node to traverse the tree from.</param>
/// <param name="list">List to add elements to.</param>
// call the left child
// visit node
// call the right child
/// <summary>
/// Return the number of elements in this tree
/// </summary>
/// <returns></returns>
/// <summary>
/// Checks if tree is empty.
/// </summary>
/// <returns></returns>
/// <summary>
/// Returns the height of the tree.
/// Time-complexity: O(n), where n = number of nodes.
/// </summary>
/// <returns>Hight</returns>
/// <summary>
/// Inserts an element to the tree
/// </summary>
/// <param name="item">Item to insert</param>
// Insert node recursively starting from the root. check for success status.
/// <summary>
/// Inserts an array of elements to the tree.
/// </summary>
/// <summary>
/// Inserts a list of elements to the tree.
/// </summary>
/// <summary>
/// Deletes an element from the tree
/// </summary>
/// <param name="item">item to remove.</param>
// If the element was found, remove it.
/// <summary>
/// Removes the min value from tree.
/// </summary>
/// <summary>
/// Removes the max value from tree.
/// </summary>
/// <summary>
/// Clears all elements from tree.
/// </summary>
/// <summary>
/// Checks for the existence of an item
/// </summary>
/// <summary>
/// Finds the minimum in tree 
/// </summary>
/// <returns>Min</returns>
/// <summary>
/// Finds the next smaller element in tree, compared to the specified item.
/// </summary>
/// <summary>
/// Finds the next larger element in tree, compared to the specified item.
/// </summary>
/// <summary>
/// Finds the maximum in tree 
/// </summary>
/// <returns>Max</returns>
/// <summary>
/// Find the item in the tree. Throws an exception if not found.
/// </summary>
/// <param name="item">Item to find.</param>
/// <returns>Item.</returns>
/// <summary>
/// Given a predicate function, find all the elements that match it.
/// </summary>
/// <param name="searchPredicate">The search predicate</param>
/// <returns>ArrayList<T> of elements.</returns>
/// <summary>
/// Returns an array of nodes' values.
/// </summary>
/// <returns>The array.</returns>
/// <summary>
/// Returns a list of the nodes' value.
/// </summary>
/*********************************************************************/
/// <summary>
/// Returns an enumerator that visits node in the order: parent, left child, right child
/// </summary>
/// <summary>
/// Returns an enumerator that visits node in the order: left child, parent, right child
/// </summary>
/// <summary>
/// Returns an enumerator that visits node in the order: left child, right child, parent
/// </summary>
/*********************************************************************/
/// <summary>
/// Returns an preorder-traversal enumerator for the tree values
/// </summary>
//Build queue
/// <summary>
/// Returns an inorder-traversal enumerator for the tree values
/// </summary>
//Build queue
/// <summary>
/// Returns a postorder-traversal enumerator for the tree values
/// </summary>
//Build queue
//end-of-binary-search-tree
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Trees\BinarySearchTreeMap.cs
/// <summary>
/// Implements a generic Binary Search Tree Map data structure.
/// </summary>
/// <summary>
/// Specifies the mode of travelling through the tree.
/// </summary>
/// <summary>
/// TREE INSTANCE VARIABLES
/// </summary>
/// <summary>
/// CONSTRUCTOR.
/// Allows duplicates by default.
/// </summary>
/// <summary>
/// CONSTRUCTOR.
/// If allowDuplictes is set to false, no duplicate items will be inserted.
/// </summary>
/// <summary>
/// Calculates the tree height from a specific node, recursively.
/// Time-complexity: O(n), where n = number of nodes.
/// </summary>
// Is leaf node
// Has two children
// Has only left
// Has only right
/// <summary>
/// Inserts a new node to the tree.
/// </summary>
// Handle empty trees
// Check for value equality and whether inserting duplicates is allowed
// Go Left
// newNode < parent
// Increment count.
// Go Right
// Increment count.
/// <summary>
/// Replaces the node's value from it's parent node object with the newValue.
/// Used in the recusive _remove function.
/// </summary>
/// <summary>
/// Remove the specified node.
/// </summary>
// if both children are present
// if the node has only a LEFT child
// if the node has only a RIGHT child
//this node has no children
/// <summary>
/// Finds a node inside another node's subtrees, given it's value.
/// </summary>
// Return-functions-fix
/// <summary>
/// Returns the min-node in a subtree.
/// Used in the recusive _remove function.
/// </summary>
/// <summary>
/// Returns the max-node in a subtree.
/// Used in the recusive _remove function.
/// </summary>
/// <summary>
/// Finds the next smaller node in value compared to the specified node.
/// </summary>
/// <summary>
/// Finds the next larger node in value compared to the specified node.
/// </summary>
/// <summary>
/// A recursive private method. Used in the public FindAll(predicate) functions.
/// Implements in-order traversal to find all the matching elements in a subtree.
/// </summary>
// call the left child
// match
// call the right child
/// <summary>
/// In-order traversal of the subtrees of a node. Returns every node it vists.
/// </summary>
// call the left child
// visit node
// call the right child
/// <summary>
/// Return the number of elements in this tree
/// </summary>
/// <summary>
/// Checks if tree is empty.
/// </summary>
/// <summary>
/// Returns the height of the tree.
/// Time-complexity: O(n), where n = number of nodes.
/// </summary>
/// <summary>
/// Inserts a key-value pair to the tree
/// </summary>
// Insert node recursively starting from the root. check for success status.
/// <summary>
/// Inserts a key-value pair to the tree
/// </summary>
/// <summary>
/// Inserts an array of elements to the tree.
/// </summary>
/// <summary>
/// Inserts an array of key-value pairs to the tree.
/// </summary>
/// <summary>
/// Inserts a list of elements to the tree.
/// </summary>
/// <summary>
/// Inserts a list of elements to the tree.
/// </summary>
/// <summary>
/// Updates the node of a specific key with a new value.
/// </summary>
/// <summary>
/// Deletes an element from the tree with a specified key.
/// </summary>
/// <summary>
/// Removes the min value from tree.
/// </summary>
/// <summary>
/// Removes the max value from tree.
/// </summary>
/// <summary>
/// Clears all elements from tree.
/// </summary>
/// <summary>
/// Checks for the existence of an item
/// </summary>
/// <summary>
/// Finds the minimum in tree 
/// </summary>
/// <returns>Min</returns>
/// <summary>
/// Finds the next smaller element in tree, compared to the specified item.
/// </summary>
/// <summary>
/// Finds the next larger element in tree, compared to the specified item.
/// </summary>
/// <summary>
/// Finds the maximum in tree 
/// </summary>
/// <returns>Max</returns>
/// <summary>
/// Find the item in the tree. Throws an exception if not found.
/// </summary>
/// <param name="item">Item to find.</param>
/// <returns>Item.</returns>
/// <summary>
/// Given a predicate function, find all the elements that match it.
/// </summary>
/// <param name="searchPredicate">The search predicate</param>
/// <returns>ArrayList<T> of elements.</returns>
/// <summary>
/// Returns an array of nodes' values.
/// </summary>
/// <returns>The array.</returns>
/// <summary>
/// Returns a list of the nodes' value.
/// </summary>
/*********************************************************************/
/// <summary>
/// Returns an enumerator that visits node in the order: parent, left child, right child
/// </summary>
/// <summary>
/// Returns an enumerator that visits node in the order: left child, parent, right child
/// </summary>
/// <summary>
/// Returns an enumerator that visits node in the order: left child, right child, parent
/// </summary>
/*********************************************************************/
/// <summary>
/// Returns an preorder-traversal enumerator for the tree values
/// </summary>
//Build queue
/// <summary>
/// Returns an inorder-traversal enumerator for the tree values
/// </summary>
//Build queue
/// <summary>
/// Returns a postorder-traversal enumerator for the tree values
/// </summary>
//Build queue
//end-of-binary-search-tree
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Trees\BinarySearchTreeMapNode.cs
/// <summary>
/// The Binary Search Tree Map node.
/// </summary>
/// <summary>
/// Checks whether this node has any children.
/// </summary>
/// <summary>
/// Checks whether this node has left child.
/// </summary>
/// <summary>
/// Checks whether this node has right child.
/// </summary>
/// <summary>
/// Checks whether this node is the left child of it's parent.
/// </summary>
/// <summary>
/// Checks whether this node is the left child of it's parent.
/// </summary>
/// <summary>
/// Checks whether this node is a leaf node.
/// </summary>
/// <summary>
/// Returns number of direct descendents: 0, 1, 2 (none, left or right, or both).
/// </summary>
/// <returns>Number (0,1,2)</returns>
/// <summary>
/// Compares to.
/// </summary>
//end-of-bstnode
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Trees\BinarySearchTreeNode.cs
/// <summary>
/// The binary search tree node.
/// </summary>
/// <summary>
/// Checks whether this node has any children.
/// </summary>
/// <summary>
/// Checks whether this node has left child.
/// </summary>
/// <summary>
///     Check if this node has only one child and whether it is the right child.
/// </summary>
/// <summary>
/// Checks whether this node has right child.
/// </summary>
/// <summary>
///     Check if this node has only one child and whether it is the left child.
/// </summary>
/// <summary>
/// Checks whether this node is the left child of it's parent.
/// </summary>
/// <summary>
/// Checks whether this node is the left child of it's parent.
/// </summary>
/// <summary>
/// Checks whether this node is a leaf node.
/// </summary>
/// <summary>
/// Returns number of direct descendents: 0, 1, 2 (none, left or right, or both).
/// </summary>
/// <returns>Number (0,1,2)</returns>
/// <summary>
/// Compares to.
/// </summary>
//end-of-bstnode
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Trees\BTree.cs
/// <summary>
/// B Tree Data Structure. Heavily influenced by Geeks for Geeks article.
/// https://www.geeksforgeeks.org/b-tree-set-1-introduction-2/
/// </summary>
/// <summary>
/// CONSTRUCTOR.
/// </summary>
/// <summary>
/// Inserts an item to the tree.
/// </summary>
// Which of the 2 children should hold the new value?
/// <summary>
/// Finds the Node that holds the given value.
/// </summary>
/// <summary>
/// Removes an item from the tree
/// </summary>
/// <summary>
/// A utility function that returns the index of the first key
/// that is greater than or equal to k.
/// </summary>
// We found the key!
// If the last child has been merged, it must have merged with the previous 
// child and so we recurse on the (idx-1)th child. Else, we recurse on the 
// (idx)th child which now has atleast t keys 
/// <summary>
/// Removes the key at index from this leaf node.
/// </summary>
/// <summary>
/// Removes the key at index from this non-leaf node.
/// </summary>
// If the child that precedes our key has atleast this._degree keys, 
// find the predecessor of our key in the subtree rooted at the child 
// at index. Replace our key by it's pred. Recursively delete pred in
// the list of children.
// If the child has less than this._degree keys, examine the child on 
// the other side. If it has atleast this._degree keys, find the successor
// of the key in the subtree rooted at our next child. Replace the key with
// the successor. Recursively delete the successor in the next child.
// If both the previous child and the next child has less than this._degree 
// keys, merge our key and all of the next child into the previous child.
// Now the previous child contains 2 * this._degree - 1 keys. Recursively 
// delete our key from the previous child. 
/// <summary>
/// Fills the Child at index, which has fewer than this._degree-1 keys.
/// </summary>
// If the previous child has keys to spare, take them.
// If the next child has keys to spare, take them.
// Merge this sibling with the next, or previous in the event that this
// is the last child.
/// <summary>
/// Gets the highest value in the tree rooted at the child at index.
/// </summary>
/// <summary>
/// Gets the lowest value in the tree rooted at the child at index+1.
/// </summary>
/// <summary>
/// Merges the child at index with the child at index+1.
/// </summary>
// Add our key and the siblings keys to the child.
// Now move the children.
/// <summary>
/// Pulls a key from the previous sibling and inserts it in the child
/// at index.
/// </summary>
// Rotate keys: sibling > parent > child
// Rotate children, if its not a leaf node
/// <summary>
/// Pulls a key from the next sibling and inserts it in the child
/// at index.
/// </summary>
// Rotate keys sibling > parent > child
// Rotate children if it's not a leaf node
/// <summary>
/// Finds the Node that holds the given value.
/// </summary>
// Find the child 
/// <summary>
/// Assumes value can be inserted. Callers should verify this.Keys has
/// enough space.
/// </summary>
// Find where the new key should be inserted.
// Find which child to explore
// One of the new nodes will need to have our value.
/// <summary>
/// Splits the given child in 2
/// </summary>
// Create a new Node which will store this._degree - 1 keys.
// Copy the keys over, leaving out the middle key
// Copy the children over
// Insert the new node in this list of children.
// Keep in mind the index i is for the keys, not children.
// One of the keys of child will move up to this node.
/// <summary>
/// Compares to.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Trees\IBinarySearchTree.cs
// Returns a copy of the tree root
// Returns the number of elements in the Tree
// Checks if the tree is empty.
// Returns the height of the tree.
// Returns true if tree allows inserting duplicates; otherwise, false
// Inserts an element to the tree
// Inserts an array of elements to the tree.
// Inserts a list of items to the tree.
// Removes the min value from tree
// Removes the max value from tree
// Remove an element from tree
// Check for the existence of an item
// Finds the minimum element.
// Finds the maximum element.
// Find the element in the tree, returns null if not found.
// Finds all the elements in the tree that match the predicate.
// Return an array of the tree elements
// Return an array of the tree elements
// Returns an enumerator that visits node in the order: parent, left child, right child
// Returns an enumerator that visits node in the order: left child, parent, right child
// Returns an enumerator that visits node in the order: left child, right child, parent
// Clear this tree.
/// <summary>
/// The itemed version of the Binary Search Tree.
/// </summary>
/// <typeparam name="TKey">Type of items.</typeparam>
/// <typeparam name="TValue">Type of records per node.</typeparam>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Trees\RedBlackTree.cs
/// <summary>
/// THE NODE COLORS TYPE
/// </summary>
/// <summary>
/// Red-Black Tree Data Structure.
/// </summary>
/// <summary>
/// Root node accessors overriding
/// </summary>
/// <summary>
/// CONSTRUCTOR.
/// Allows duplicates by default.
/// </summary>
/// <summary>
/// CONSTRUCTOR.
/// If allowDuplictes is set to false, no duplicate items will be inserted.
/// </summary>
/*************************************************************************************************/
/***
/*************************************************************************************************/
/***
/// <summary>
/// Rotates a node to the left in the Red-Black Tree.
/// </summary>
// We check the right child because it's going to be a pivot node for the rotation
// Pivot on *right* child
// Parent of currentNode
// Check if currentNode is it's parent's left child.
// Check if currentNode is the Root
// Perform the rotation
// Update parents references
//Update the entire tree's Root if necessary
// Update the original parent's child node
/// <summary>
/// Rotates a node to the right in the Red-Black Tree.
/// </summary>
// We check the right child because it's going to be a pivot node for the rotation
// Pivot on *left* child
// Parent of currentNode
// Check if currentNode is it's parent's left child.
// Check if currentNode is the Root
// Perform the rotation
// Update parents references
// Update the entire tree's Root if necessary
// Update the original parent's child node
/// <summary>
/// After insertion tree-adjustement helper.
/// </summary>
//
// STEP 1:
// Color the currentNode as red
//
// STEP 2:
// Fix the double red-consecutive-nodes problems, if there exists any.
//
// STEP 2.A:
// This is the simplest step: Basically recolor, and bubble up to see if more work is needed.
// If it has a sibling and it is black, then then it has a parent
// Color sibling of parent as black
// Color grandparent as red
// Adjust on the grandparent of currentNode
//
// STEP 2.B:
// Restructure the tree if the parent of currentNode is a left child to the grandparent of currentNode
// (parent is a left child to its own parent).
// If currentNode is also a left child, then do a single right rotation; otherwise, a left-right rotation.
//
// using the safe methods to check: currentNode.Parent.IsLeftChild == true
// Color parent as black
// Color grandparent as red
// Right Rotate tree around the currentNode's grand parent
//
// STEP 2.C: 
// Restructure the tree if the parent of currentNode is a right child to the grandparent of currentNode
// (parent is a right child to its own parent).
// If currentNode is a right-child in it's parent, then do a single left rotation; otherwise a right-left rotation.
//
// using the safe methods to check: currentNode.Parent.IsRightChild == true
// Color parent as black
// Color grandparent as red
// Left Rotate tree around the currentNode's grand parent
// STEP 3:
// Color the root node as black
/// <summary>
/// After removal tree-adjustement helper.
/// </summary>
// Get sibling of currentNode
// Safe equivalent of currentNode.Sibling or currentNode.Parent.RightChild
// Safely check sibling.IsRed property
// Color currentNode.Sibling as black
// Color currentNode.Parent as red
// Left Rotate on currentNode's parent
// Update sibling reference
// Might end be being set to null
// Check if the left and right children of the sibling node are black
// Use the safe methods to check for: (sibling.LeftChild.IsBlack && sibling.RightChild.IsBlack)
// Color currentNode.Sibling as red
// Assign currentNode.Parent to currentNode 
// Color currentNode.Sibling.LeftChild as black
// Color currentNode.Sibling as red
// Right Rotate on sibling
// Update sibling reference
// Might end be being set to null
// Color the Sibling node as currentNode.Parent.Color
// Color currentNode.Parent as black
// Color Sibling.RightChild as black
// Rotate on currentNode's parent
// Get sibling of currentNode
// Safe equivalent of currentNode.Sibling or currentNode.Parent.LeftChild
// Color currentNode.Sibling as black
// Color currentNode.Parent as red
// Right Rotate tree around the parent of currentNode
// Update sibling reference
// Might end be being set to null
// Check if the left and right children of the sibling node are black
// Use the safe methods to check for: (sibling.LeftChild.IsBlack && sibling.RightChild.IsBlack)
// Assign currentNode.Parent to currentNode 
// Check if sibling.LeftChild.IsBlack == true
// Color currentNode.Sibling.RightChild as black
// Color currentNode.Sibling as red
// Left rotate on sibling
// Update sibling reference
// Might end be being set to null
// Color the Sibling node as currentNode.Parent.Color
// Color currentNode.Parent as black
// Color Sibling.RightChild as black
// Right rotate on the parent of currentNode
// Color currentNode as black
/// <summary>
/// Remove node helpers.
/// </summary>
/// <summary>
///     The internal remove helper.
///     Separated from the overriden version to avoid casting the objects from BSTNode to RedBlackTreeNode.
///     This is called from the overriden _remove(BSTNode nodeToDelete) helper.
/// </summary>
// X is the node we will replace with the nodeToDelete in the tree once we remove it.
// Y is the node we will replace with the X in the tree once we move it to the nodeToDelete position.
/// <summary>
///     Insert one subtree in the place of the other in his parent.
/// </summary>
/// <param name="replaced">Subtree of node will be replaced by <param name="replacement">.</param></param>
/// <param name="replacement">Subtree replaces <param name="replaced">.</param></param>
/*************************************************************************************************/
/// <summary>
/// Insert data item to tree
/// </summary>
// Invoke the super BST insert node method.
// This insert node recursively starting from the root and checks for success status (related to allowDuplicates flag).
// The functions increments count on its own.
// Adjust Red-Black Tree rules
// Case 0: Parent is not black and we have to restructure tree
// Always color root as black
/// <summary>
/// Inserts an array of elements to the tree.
/// </summary>
/// <summary>
/// Inserts a list of elements to the tree.
/// </summary>
/// <summary>
/// Removes an item from the tree.
/// </summary>
// Get the node from the tree
// Invoke the internal remove node method.
/// <summary>
/// Removes the min value from tree.
/// </summary>
// Get the node from the tree
// Invoke the internal remove node method.
/// <summary>
/// Removes the max value from tree.
/// </summary>
// Get the node from the tree
// Invoke the internal remove node method.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Trees\RedBlackTreeMap.cs
/// <summary>
/// Red-Black Tree Data Structure.
/// </summary>
/// <summary>
/// Root node accessors overriding
/// </summary>
/// <summary>
/// CONSTRUCTOR.
/// Allows duplicates by default.
/// </summary>
/// <summary>
/// CONSTRUCTOR.
/// If allowDuplictes is set to false, no duplicate items will be inserted.
/// </summary>
/*************************************************************************************************/
/***
/*************************************************************************************************/
/***
/// <summary>
/// Rotates a node to the left in the Red-Black Tree.
/// </summary>
// We check the right child because it's going to be a pivot node for the rotation
// Pivot on *right* child
// Parent of currentNode
// Check if currentNode is it's parent's left child.
// Check if currentNode is the Root
// Perform the rotation
// Update parents references
//Update the entire tree's Root if necessary
// Update the original parent's child node
/// <summary>
/// Rotates a node to the right in the Red-Black Tree.
/// </summary>
// We check the right child because it's going to be a pivot node for the rotation
// Pivot on *left* child
// Parent of currentNode
// Check if currentNode is it's parent's left child.
// Check if currentNode is the Root
// Perform the rotation
// Update parents references
// Update the entire tree's Root if necessary
// Update the original parent's child node
/// <summary>
/// After insertion tree-adjustement helper.
/// </summary>
//
// STEP 1:
// Color the currentNode as red
//
// STEP 2:
// Fix the double red-consecutive-nodes problems, if there exists any.
//
// STEP 2.A:
// This is the simplest step: Basically recolor, and bubble up to see if more work is needed.
// If it has a sibling and it is red, then then it has a parent
// Color sibling of parent as black
// Color grandparent as red
// Adjust on the grandparent of currentNode
//
// STEP 2.B:
// Restructure the tree if the parent of currentNode is a left child to the grandparent of currentNode
// (parent is a left child to its own parent).
// If currentNode is also a left child, then do a single right rotation; otherwise, a left-right rotation.
//
// using the safe methods to check: currentNode.Parent.IsLeftChild == true
// Color parent as black
// Color grandparent as red
// Right Rotate tree around the currentNode's grand parent
//
// STEP 2.C: 
// Restructure the tree if the parent of currentNode is a right child to the grandparent of currentNode
// (parent is a right child to its own parent).
// If currentNode is a right-child in it's parent, then do a single left rotation; otherwise a right-left rotation.
//
// using the safe methods to check: currentNode.Parent.IsRightChild == true
// Color parent as black
// Color grandparent as red
// Left Rotate tree around the currentNode's grand parent
// STEP 3:
// Color the root node as black
/// <summary>
/// After removal tree-adjustement helper.
/// </summary>
// Get sibling of currentNode
// Safe equivalent of currentNode.Sibling or currentNode.Parent.RightChild
// Safely check sibling.IsRed property
// Color currentNode.Sibling as black
// Color currentNode.Parent as red
// Left Rotate on currentNode's parent
// Update sibling reference
// Might end be being set to null
// Check if the left and right children of the sibling node are black
// Use the safe methods to check for: (sibling.LeftChild.IsBlack && sibling.RightChild.IsBlack)
// Color currentNode.Sibling as red
// Assign currentNode.Parent to currentNode 
// Color currentNode.Sibling.LeftChild as black
// Color currentNode.Sibling as red
// Right Rotate on sibling
// Update sibling reference
// Might end be being set to null
// Color the Sibling node as currentNode.Parent.Color
// Color currentNode.Parent as black
// Color Sibling.RightChild as black
// Rotate on currentNode's parent
// Get sibling of currentNode
// Safe equivalent of currentNode.Sibling or currentNode.Parent.LeftChild
// Color currentNode.Sibling as black
// Color currentNode.Parent as red
// Right Rotate tree around the parent of currentNode
// Update sibling reference
// Might end be being set to null
// Check if the left and right children of the sibling node are black
// Use the safe methods to check for: (sibling.LeftChild.IsBlack && sibling.RightChild.IsBlack)
// Assign currentNode.Parent to currentNode 
// Check if sibling.LeftChild.IsBlack == true
// Color currentNode.Sibling.RightChild as black
// Color currentNode.Sibling as red
// Left rotate on sibling
// Update sibling reference
// Might end be being set to null
// Color the Sibling node as currentNode.Parent.Color
// Color currentNode.Parent as black
// Color Sibling.RightChild as black
// Right rotate on the parent of currentNode
// Color currentNode as black
/// <summary>
/// Remove node helpers.
/// </summary>
/// <summary>
/// The internal remove helper.
/// Separated from the overriden version to avoid casting the objects from BSTMapNode to RedBlackTreeMapNode.
/// This is called from the overriden _remove(BSTMapNode nodeToDelete) helper.
/// </summary>
// Temporary nodes
// If nodeToDelete has either one child or no children at all
// nodeToDelete has two children
// Left child case
// If node2 is not null, copy parent references
// Swap values
// Adjust the Red-Black Tree rules
// Decrement the count
/*************************************************************************************************/
/// <summary>
/// Insert data item to tree
/// </summary>
// Invoke the super BST insert node method.
// This insert node recursively starting from the root and checks for success status (related to allowDuplicates flag).
// The functions increments count on its own.
// Adjust Red-Black Tree rules
// Case 0: Parent is not black and we have to restructure tree
// Always color root as black
/// <summary>
/// Inserts an array of elements to the tree.
/// </summary>
/// <summary>
/// Inserts an array of key-value pairs to the tree.
/// </summary>
/// <summary>
/// Inserts a list of elements to the tree.
/// </summary>
/// <summary>
/// Inserts a list of key-value pairs to the tree.
/// </summary>
/// <summary>
/// Removes an item from the tree.
/// </summary>
// Get the node from the tree
// Invoke the internal remove node method.
/// <summary>
/// Removes the min value from tree.
/// </summary>
// Get the node from the tree
// Invoke the internal remove node method.
/// <summary>
/// Removes the max value from tree.
/// </summary>
// Get the node from the tree
// Invoke the internal remove node method.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Trees\RedBlackTreeMapNode.cs
/// <summary>
/// Red-Black Tree Map Node.
/// </summary>
/// <summary>
/// CONSTRUCTORS
/// </summary>
/******************************************************************************/
/// <summary>
/// Returns if this node is colored red.
/// </summary>
/// <summary>
/// Checks whether this node is colored black.
/// </summary>
/// <summary>
/// Returns the sibling of this node.
/// </summary>
/// <summary>
/// Returns the grandparent of this node.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Trees\RedBlackTreeNode.cs
/// <summary>
/// Red-Black Tree Node.
/// </summary>
/// <summary>
/// CONSTRUCTORS
/// </summary>
/******************************************************************************/
/// <summary>
/// Returns if this node is colored red.
/// </summary>
/// <summary>
/// Checks whether this node is colored black.
/// </summary>
/// <summary>
/// Returns the sibling of this node.
/// </summary>
/// <summary>
/// Returns the grandparent of this node.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Trees\TernarySearchTree.cs
//Center Branch
//Right Branch
//Left Branch
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Trees\TernaryTreeNode.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Trees\TreeDrawer.cs
/// <summary>
/// Public API.
/// Extension method for BinarySearchTree<T>.
/// Returns a visualized binary search tree text.
/// </summary>
/// <summary>
/// /// Recusively draws the tree starting from node.
/// To construct a full tree representation concatenate the returned list of strings by '\n'.
///
/// Example:
/// int position, width;
/// var fullTree = String.Join("\n", _recursivelyDrawTree(this.Root, out position, out width));
///
/// Algorithm developed by MIT OCW.
/// http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/readings/binary-search-trees/bstsize_r.py
/// </summary>
/// <param name="node"></param>
/// <param name="positionOutput"></param>
/// <param name="widthOutput"></param>
/// <returns>List of tree levels as strings.</returns>
//
// Variables
//
// Start drawing
// Visit the left child
// Visit the right child
// Calculate pads
// Format the node's label
//
// Construct the list of lines.
// 0
// 1
//
// Add the right lines and left lines to the final list of lines.
//
// Return
//
// Variables
//
// Start drawing
// Visit the left child
// Visit the right child
// Calculate pads
// Format the node's label
//
// Construct the list of lines.
// 0
// 1
//
// Add the right lines and left lines to the final list of lines.
//
// Return
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Trees\Trie.cs
/***
/// <summary>
/// The vanila Trie implementation.
/// </summary>
/// <summary>
/// CONSTRUCTOR
/// </summary>
/// <summary>
/// Return count of words.
/// </summary>
/// <summary>
/// Checks if element is empty.
/// </summary>
/// <summary>
/// Add word to trie
/// </summary>
/// <summary>
/// Removes a word from the trie.
/// </summary>
/// <summary>
/// Checks whether the trie has a specific word.
/// </summary>
/// <summary>
/// Checks whether the trie has a specific prefix.
/// </summary>
/// <summary>
/// Searches the entire trie for words that has a specific prefix.
/// </summary>
/// <summary>
/// Clears this insance.
/// </summary>
/// <summary>
/// IEnumerable\<String\>.IEnumerator implementation.
/// </summary>
/// <summary>
/// IEnumerable\<String\>.IEnumerator implementation.
/// </summary>
/// <returns></returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Trees\TrieMap.cs
/***
/// <summary>
/// The Trie Map Data Structure (a.k.a Prefix Tree).
/// </summary>
/// <typeparam name="TRecord">The type of records attached to words</typeparam>
/// <summary>
/// CONSTRUCTOR
/// </summary>
/// <summary>
/// Return count of words.
/// </summary>
/// <summary>
/// Checks if element is empty.
/// </summary>
/// <summary>
/// Add word to trie
/// </summary>
/// <summary>
/// Updates a terminal word with a new record. Throws an exception if word was not found or if it is not a terminal word.
/// </summary>
/// <summary>
/// Removes a word from the trie.
/// </summary>
/// <summary>
/// Checks whether the trie has a specific word.
/// </summary>
/// <summary>
/// Checks whether the trie has a specific prefix.
/// </summary>
/// <summary>
/// Searchs the trie for a word and returns the associated record, if found; otherwise returns false.
/// </summary>
/// <summary>
/// Searches the entire trie for words that has a specific prefix.
/// </summary>
/// <summary>
/// Clears this insance.
/// </summary>
/// <summary>
/// Checks whether a specific key exists in trie as a word (terminal word).
/// </summary>
/// <summary>
/// Return all terminal words in trie.
/// </summary>
/// <summary>
/// Return all the associated records to terminal words.
/// </summary>
/// <summary>
/// Tries to get the associated record of a terminal word from trie. Returns false if key was not found.
/// </summary>
/// <summary>
/// Checks whether a specific word-record pair exists in trie. The key of item must be a terminal word not a prefix.
/// </summary>
/// <summary>
/// Get/Set the associated record of a terminal word in trie.
/// </summary>
/// <summary>
/// Remove a word from trie.
/// </summary>
/// <summary>
/// Removes a word from trie.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Trees\TrieMapNode.cs
// Node key
// Associated record with this node
// Is Terminal node flag
// Parent pointer
// Dictionary of child-nodes
/// <summary>
/// CONSTRUCTORS
/// </summary>
/// <summary>
/// Return the word at this node if the node is terminal; otherwise, return null
/// </summary>
/// <summary>
/// Returns an enumerable list of key-value pairs of all the words that start 
/// with the prefix that maps from the root node until this node.
/// </summary>
/// <summary>
/// Returns an enumerable collection of terminal child nodes.
/// </summary>
/// <summary>
/// Remove this element upto its parent.
/// </summary>
/// <summary>
/// IComparer interface implementation
/// </summary>
/// <summary>
/// Clears this node instance
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\DataStructures\Trees\TrieNode.cs
/// <summary>
/// The Trie Node.
/// </summary>
/// <summary>
/// Instance variables.
/// </summary>
/// <summary>
/// CONSTRUCTORS
/// </summary>
/// <summary>
/// Return the word at this node if the node is terminal; otherwise, return null
/// </summary>
/// <summary>
/// Returns an enumerable list of key-value pairs of all the words that start 
/// with the prefix that maps from the root node until this node.
/// </summary>
/// <summary>
/// Returns an enumerable collection of terminal child nodes.
/// </summary>
/// <summary>
/// Remove this element upto its parent.
/// </summary>
/// <summary>
/// IComparer interface implementation
/// </summary>
/// <summary>
/// Clears this node instance
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\AlgorithmsTests\BinarySearcherTest.cs
//list of ints
//list of strings
//reset indices to test MoveNext()
//reset indices to test MoveNext()
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\AlgorithmsTests\BinarySearchTreeSorterTest.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\AlgorithmsTests\BinaryTreeRecursiveWalkerTests.cs
// Construct a Simple Binary Search Tree
// List to contain items
// ForEach Action
// Assert the fact that adding items PRE-ORDER will result in [3, 5, 7, 10, 13, 15, 17]
// List to contain items
// ForEach Action
// Assert the fact that adding items IN-ORDER will result in [10, 5, 3, 7, 15, 13, 17]
// List to contain items
// ForEach Action
// Assert the fact that adding items POST-ORDER will result in [3, 7, 5, 13, 17, 15, 10]
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\AlgorithmsTests\CatalanNumbersTest.cs
// TRY CALCULATING FROM Bin.Coeff.
// Values retrieved from https://oeis.org/A000108/list.
// This conversion seems to be necessary because as of this
// writing xunit doesn't behave well with BigInteger inline
// data values.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\AlgorithmsTests\CountingSortTest.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\AlgorithmsTests\GraphsBipartiteColoringTest.cs
// The graph
// The bipartite wrapper
// The status for checking bipartiteness
// Prepare the graph for the first case of testing
// Test initializing the bipartite
// This initialization must fail. The graph contains an odd cycle
/************************************************************/
//
// Prepare the graph for the second case of testing
//
// Test initializing the bipartite
// This initialization must fail. The graph contains an odd cycle
//
// Remove Odd Cycle and try to initialize again.
//
// This initialization must pass. The graph doesn't contain any odd cycle
//
// Second Case Initialization
// Clear the graph
//
// Add vertices
// 
// Add Edges
//
// Second Case Initialization
// Clear the graph
//
// Add vertices
//
// Add edges
// Connected Component #1
// the vertex "e" won't be connected to any other vertex
// Connected Component #2
// Connected Component #3
// Connected Component #4
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\AlgorithmsTests\GraphsBreadthFirstPathsTest.cs
// Add vertices
// Add edges
// TODO: 
// - Assert distances
// - Assert ShortestPathTo a node
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\AlgorithmsTests\GraphsBreadthFirstSearchTest.cs
// Add vertices
// Add edges
// Print the nodes in graph
//  [*] BFS PrintAll:
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\AlgorithmsTests\GraphsConnectedComponents.cs
// Add vertices
// Add edges
// Connected Component #1
// the vertex "e" won't be connected to any other vertex
// Connected Component #2
// Connected Component #3
// Connected Component #4
// Get connected components
// the case of the (e) vertex
// the case of (y) and (z) vertices
// the case of the rest
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\AlgorithmsTests\GraphsCyclesDetectorTests.cs
// Init graph object
// Init V
// Insert V
// Insert E
// Insert new values of V
// Insert new value for edges
// Insert new values of V
// Insert new value for edges
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\AlgorithmsTests\GraphsDepthFirstSearchTest.cs
// Add vertices
// Add edges
// Print the nodes in graph
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\AlgorithmsTests\GraphsDijkstraShortestPathsTest.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\AlgorithmsTests\GraphsTopologicalSorterTest.cs
// Insert new values of V
// Insert new value for edges
// PRINT THE GRAPH
// [*] DAG (Directed Asyclic Graph):
// CALCULATE THE TOPOLOGICAL SORT
// Insert new values of V
// Insert new value for edges
// PRINT THE GRAPH
// [*] DAG (Directed Asyclic Graph):
// CALCULATE THE TOPOLOGICAL SORT
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\AlgorithmsTests\GreatestCommonDivisorTests.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\AlgorithmsTests\HeapSorterTest.cs
// Sort Ascending (same as the method above);
// Sort Descending
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\AlgorithmsTests\InsertionSortTest.cs
// sort both lists 
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\AlgorithmsTests\LSDRadixSorterTest.cs
//
// Sort strings
//
// Sort a list of strings of the same length
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\AlgorithmsTests\MergeSorterTest.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\AlgorithmsTests\QuickSortTest.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\AlgorithmsTests\SieveOfAtkinTest.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\AlgorithmsTests\SieveOfEratosthenesTests.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\AlgorithmsTests\StringEditDistanceTest.cs
// Initialize the costs map
// Assert min cost is zero
// Assert min cost is 5
// Assert min cost is the length of string one (17 characters)
// Assert min cost is 11
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\AlgorithmsTests\StringPermutationTests.cs
// L is small
// L is capital
// L is small
// L is small
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\ArrayListTest.cs
//arrayList.Reverse ();
// Console.WriteLine(arrayList2.ToHumanReadable(addHeader: true));
//var arrayList3 = arrayList.GetRange(0, 100);
//Console.WriteLine(arrayList3.ToHumanReadable(addHeader: true));
/****************************************************************/
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\AVLTreeTest.cs
//
// CASE #1
// Insert: 4, 5, 7
// SIMPLE *left* rotation for node 4.
//
/***************************************
// insert
// insert
// insert
// ASSERT CAST 1;
//
// CASE #2
// Insert to the previous tree: 2 and then 1.
// SIMPLE *right* rotation for node 4.
//
/*********************************************
// insert
// insert
// ASSERT CASE 2
//
// CASE #3
// Insert to the previous tree: 3.
// DOUBLE *right* rotation for node 5.
//
// The double rotation is achieved by:
// 1> Simple *left* rotation for node 2, and then
// 2> Simple *right* rotation for node 5
//
/*************************************
// insert
// ASSERT CASE 3
//
// CASE #4
// Insert to the previous tree: 6.
// DOUBLE *right* rotation for node 5.
//
// The double rotation is achieved by:
// 1> Simple *right* rotation for node 7, and then
// 2> Simple *left* rotation for node 5
//
/**************************************************************************
// insert
// ASSERT CASE 4
//
// CASE #5
// REMOVE the tree's root: 4.
//
/**************************************************************************
// REMOVE 4
// ASSERT CASE 5
//
// CLEAR THE TREE AND START OVER
// Compare two binary trees with each other (height-wise) using bulk-inserts
//
// OUTPUT OF AVL TREE DRAWER
/**
//end-do-test
//
// DEBUG.ASSERT <- CASE 1
// DEBUG.ASSERT <- CASE 2
// DEBUG.ASSERT <- CASE 3
// DEBUG.ASSERT <- CASE 4
// DEBUG.ASSERT <- CASE 5
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\BinaryHeapsTest.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\BinarySearchTreeMapTests.cs
// Binary Search Tree Map collection
// Testing data
// Prepare the values array
// Test singular insert
// Test collection insert
// Test enumeration of key-value pairs is still in oreder
// Test against re-shuffled insertions (not like above order)
// ASSERT INSERTING DUPLICATES WOULD BREAK
// 2 already exists in tree
// Test find
// Assert find raises exception on non-existing elements
// Assert count
// Assert existence and nonexistence of some items
// Do some deletions
// Assert count
// Assert nonexistence of previously existing items
// Remove root key
// Assert count
// Assert nonexistence of old root's key
//end-do-test
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\BinarySearchTreeTest.cs
/// <summary>
/// FIRST TEST TREE WITH DUPLICATES ELEMENTS
/// </summary>
/// <param name="binarySearchTree"></param>
// New tree which doesn't allow duplicates
// Insert values with duplicates
// ASSERT COUNT = 21 (allows duplicates)
// Test contains/find
// Test find all
// test sort
// ASSERT MIN ITEM
// ASSERT MAX ITEM
// Remove min & max
// ASSERT MIN AFTER REMOVE-MIN
// ASSERT MAX AFTER REMOVE MAX
// Remove min twice
// ASSERT MIN
// 7 STILL EXISTS BECAUSE IT WAS DUPLICATED
// Remove max thrice
// ASSERT MAX AFTER REMOVE-MAX 3 TIMES
// Test removing an element with subtrees
// doesn't exist!
// does exist!
/// <summary>
/// NEXT TEST TREE THAT DOES NOT ALLOW DUPLICATES
/// </summary>
/// <param name="binarySearchTree"></param>
// New tree which doesn't allow duplicates
// Insert values with duplicates
//
// Reduce values array to an array of distinct values
// Insert unique values
// ASSERT COUNT
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\BinomialHeapsTest.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\BTreeTest.cs
//
// CASE #1
// Insert: 10, 30, 20, 50, 40, 60, 70
// ROOT contains all values; no split.
//
/***************************************
//
// CASE #2
// Insert to the previous tree: 35.
// Split into multiple.
//
/***************************************
//
// CASE #3
// Insert to the previous tree: 5, 15, 25, 39.
// Split leftmost child.
//
/***************************************
// Build a base tree
// The tree now looks like this:
/***************************************
// Build a base tree
// The tree now looks like this:
/***************************************
// First. assert the shape.
// Now, remove a key from the left-most child.
// The tree now looks like this:
/***************************************
// The tree should now be rooted around 40, with the left child full.
// left-most
// right-most
// Remove 50 - it needs to be rebalanced now.
// The tree now looks like this:
/***************************************
// Remove everything
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\CircularBufferTest.cs
// if it doesn't override, then it will throw CircularBufferFullException
// Ensuring that it reads the appropriate values in the buffer.
//Testing contains
//Testing CopyTo
//Testing Count
//Testing clear
//Removing default(T) from the buffer. buffer should not be affected since default is not contained
//Filling the buffer again with some duplicate entries
//Removing elements one by one from the end
//Adding elements back
//buffer would yield these results if it was poped initially
//Test for removing duplicate values of default(T)
//Test for removing duplicate values of default(T) for strings
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\CliqueGraphTest.cs
// ICollection<ComparableTuple> component = testGraph.GetConnectedComponent(new ComparableTuple(0, 0));
// DataStructures.Lists.DLinkedList<ComparableTuple> neighbor = testGraph.Neighbours(new ComparableTuple(0, 0));
// CliqueGraph.Edges test
//System.Diagnostics.Debug.WriteLine(string.Format("{0} -> {1}\t", edge.Source, edge.Destination));
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\CuckooHashTableTest.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\DLinkedListTest.cs
// Remove 1st
// Remove 4th
// Remove 5th and 6th
// Note that after removing 5th, the old element at index 6 becomes at index 5.
// Remove 3rd
// Remove 1st
// Test the remove item method
/****************************************************************************************/
/****************************************************************************************/
/// <summary>
///Check SelectionSort method
///</summary>
///<returns></returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\GraphsDirectedDenseGraphTest.cs
// BFS from A
// Walk the graph using BFS from A:
// DFS from A
// Walk the graph using DFS from A:
// BFS from F
// Walk the graph using BFS from F:
// DFS from F
// Walk the graph using DFS from F:
// Cleared the graph from all vertices and edges
// Walk the graph using DFS:
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\GraphsDirectedSparseGraphTest.cs
// BFS from A
// Walk the graph using BFS from A:
// output: (s) (a) (x) (z) (d) (c) (f) (v)
// DFS from A
// Walk the graph using DFS from A:
// output: (s) (a) (x) (z) (d) (c) (f) (v)
// BFS from F
// output: (s) (a) (x) (z) (d) (c) (f) (v)
// DFS from F
// Walk the graph using DFS from F:
// output: (s) (a) (x) (z) (d) (c) (f) (v)
/********************************************************************/
// Cleared the graph from all vertices and edges
// Walk the graph using DFS:
// output: (a) (b) (e) (d) (c) (f) 
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\GraphsDirectedWeightedDenseGraphTest.cs
// BFS from A
// output: (s) (a) (x) (z) (d) (c) (f) (v)
// DFS from A
// output: (s) (a) (x) (z) (d) (c) (f) (v)
// BFS from F
// output: (s) (a) (x) (z) (d) (c) (f) (v)
// DFS from F
// output: (s) (a) (x) (z) (d) (c) (f) (v)
/********************************************************************/
// output: (a) (b) (e) (d) (c) (f) 
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\GraphsDirectedWeightedSparseGraphTest.cs
// ASSERT RANDOMLY SELECTED EDGES
// ASSERT RANDOMLY SELECTED EDGES
// TRY ADDING DUPLICATE EDGES BUT WITH DIFFERENT WEIGHTS
// TEST DELETING EDGES
// ASSERT VERTICES AND EDGES COUNT
// TEST DELETING VERTICES
// ASSERT VERTICES AND EDGES COUNT
// BFS from A
// Walk the graph using BFS from A:
// output: (s) (a) (x) (z) (d) (c) (f) (v)
// DFS from A
// Walk the graph using DFS from A:
// output: (s) (a) (x) (z) (d) (c) (f) (v)
// BFS from F
// Walk the graph using BFS from F:
// output: (s) (a) (x) (z) (d) (c) (f) (v)
// DFS from F
// output: (s) (a) (x) (z) (d) (c) (f) (v)
/********************************************************************/
// Walk the graph using DFS:
// output: (a) (b) (e) (d) (c) (f) 
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\GraphsUndirectedDenseGraphTest.cs
// TEST REMOVE nodes v and f
// TEST RE-ADD REMOVED NODES AND EDGES
// RE-TEST REMOVE AND ADD NODES AND EDGES
// output: (s) (a) (x) (z) (d) (c) (f) (v)
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\GraphsUndirectedSparseGraphTest.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\GraphsUndirectedWeightedSparseGraphTest.cs
// ASSERT RANDOMLY SELECTED EDGES
// ASSERT RANDOMLY SELECTED EDGES
// TRY ADDING DUPLICATE EDGES BUT WITH DIFFERENT WEIGHTS
// TEST DELETING EDGES
// ASSERT VERTICES AND EDGES COUNT
// TEST DELETING VERTICES
// ASSERT VERTICES AND EDGES COUNT
// BFS from A
// Walk the graph using BFS from A:
// output: (s) (a) (x) (z) (d) (c) (f) (v)
// DFS from A
// Walk the graph using DFS from A:
// output: (s) (a) (x) (z) (d) (c) (f) (v)
// BFS from F
// Walk the graph using BFS from F:
// output: (s) (a) (x) (z) (d) (c) (f) (v)
// DFS from F
// Walk the graph using DFS from F:
// output: (s) (a) (x) (z) (d) (c) (f) (v)
/********************************************************************/
// "Cleared the graph from all vertices and edges.\r\n"
// Walk the graph using DFS:
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\HashTableSeparateChainingTest.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\PrimeListTest.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\PriorityQueuesTest.cs
//
// KEYED PRIORITY QUEUE
//
// Integer-index priority-queue
//
// Processes with priorities
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\QueueTest.cs
// fails if wrong size
// fails if wrong size
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\RedBlackTreeMapTests.cs
// Red-Black Tree Map collection
// Testing data
// Prepare the values array
// Test singular insert
// Test collection insert
// Test enumeration of key-value pairs is still in oreder
// Test against re-shuffled insertions (not like above order)
//redBlackTree.Insert(0, "int0");
// ASSERT INSERTING DUPLICATES WOULD BREAK
// 2 already exists in tree
// Test find
// Assert find raises exception on non-existing elements
// PRINT TREE
//Console.WriteLine("********************");
//Console.WriteLine(" [*] RED-BLACK TREE:\r\n");
//Console.WriteLine("********************");
//Console.WriteLine(redBlackTree.DrawTree());
//Console.WriteLine("\r\n");
// Assert count
// Assert existence and nonexistence of some items
// ASSERT THAT EACH LEVEL HAS A DIFFERENT COLOR
// TODO: Wrong color element "int4"
// AssetLevelsDifferentColors(redBlackTree);
// Do some deletions
// Assert count
// Assert nonexistence of previously existing items
// Remove root value
// Assert count
// Assert nonexistence of old root's key
// PRINT TREE
//Console.WriteLine("********************");
//Console.WriteLine(" [*] RED-BLACK TREE:\r\n");
//Console.WriteLine("********************");
//Console.WriteLine(redBlackTree.DrawTree(includeValues: true));
//Console.WriteLine("\r\n");
//Console.ReadLine();
//end-do-test
/// <summary>
/// Testing helper to assert that all items at every level of the tree has the same color and each level has different color than the other levels
/// </summary>
// Initialize the list
// [*] Assert that levels have different alternating colors:
//if (levels[i][j].Color != color)
//Console.WriteLine(" [-] Level: {0}. Node Value: {1}. Node color: {2}. Expected color: {3}.", i, levels[i][j].Value, levels[i][j].Color, color.ToString());
//end-test-case
/// <summary>
/// Helper function to calculate the Maximum Height
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\RedBlackTreeTest.cs
/** Input tree for test cases, (r -> red, b -> black):
/** Insert 4, (r -> red, b -> black):
/** Insert 14, (r -> red, b -> black):
/** Insert 16, (r -> red, b -> black):
//TODO Create more specyfic exception type for this kind of errors, with inheritance from InvalidOperationException.
/** Remove 13, (r -> red, b -> black):
/** Remove 3, (r -> red, b -> black):
/** Remove 7, (r -> red, b -> black):
/** Remove 11, (r -> red, b -> black):
//TODO Create more specyfic exception type for this kind of errors, with inheritance from ArgumentException.
/** Remove 8, (r -> red, b -> black):
/// <summary>
///     Contains set of method that facilitate work. Only for unit tests.
/// </summary>
/// <summary>
///     Contains method to check asked red black tree fulfills red black tree rules. Only for unit tests.
/// </summary>
/// <summary>
///     Exception class throw when any of red black tree rule is violation. Only for unit tests.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\SkipListTest.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\SLinkedListTest.cs
// Print List and Count
/************************************************************************************/
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\SortedDictionaryTests.cs
//
// Test Add
// insert
//
// Assert correct number of elements
//
// Test get via index-access notation
//
// Test update
// Restore
//
// Test TryGetValue for existing items
//
// Test TryGetValue for non-existing items
//
// Test Remove
//
// Test CopyTo returns a sorted array of key-value pairs (sorted by key).
// Prepare the sort testing data
// deleted previously from sortedDictionary
// Sort dictionary
// begin sorting test
// Keys
// Values
//
// Test Clear
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\SortedListTests.cs
// New empty sorted list
// Expeted outcome
// Insert items in arbitrary-order
//
// Helper variables
//
// Begin comparison
// Compare length and count
//
// Compare sort order
//
// Assert index access
//
// Assert removal of items correctly
//
// Assert non-removal of non-existing items
//
// Assert throws exception
// illegal index
//
// Assert indexOf returns correct information
//
// Assert correct sort after updating on index
// Add back 10
// Modify elements in increasing order
// Compare length and count
// Compare sort order
// TODO: Verify
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\StackTest.cs
// Wrong top value.
// Wrong size!
// Wrong top value.
// Wrong top value.
// Wrong size!
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\TernarySearchTreeTest.cs
//         c
//       / | \
//      a  u  h
//      |  |  | \
//      t  t  e u
//     /  / |  / |
//    s  p  e i  s
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\TrieMapTest.cs
// Insert some how to words
// Count of words = 4
// Insert some dictionary words
// Count of words = 9
// ASSERT THE WORDS IN TRIE.
// Search for a word that doesn't exist
// Search for prefix
// Search for a prefix using a word
// Get all words that start with the how-to prefix
// Assert there are only two words under the prefix "acti" -> active, & acting
// Assert that "acto" is not a word
//
// TEST GETTING VALUES ASSOCIATED TO WORDS
//
// TEST DELETING SOMETHINGS
// Removing a prefix should fail
// try removing a non-terminal word
// if exception occured then code works, word doesn't exist.
// Removing a word should work
// try removing a non-terminal word
// if exception occured then code DOESN'T work, word does exist.
//
// TEST ENUMERATOR
// Assert size
// Assert each element
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\TrieTest.cs
// Insert some how to words
// Count of words = 4
// Insert some dictionary words
// Count of words = 9
//
// ASSERT THE WORDS IN TRIE.
// Search for a word that doesn't exist
// Search for prefix
// Search for a prefix using a word
// Get all words that start with the how-to prefix
// Assert there are only two words under the prefix "acti" -> active, & acting
// Assert that "acto" is not a word
// Check the existance of other words
//
// TEST DELETING SOMETHINGS
// Removing a prefix should fail
// try removing a non-terminal word
// if exception occured then code works, word doesn't exist.
// Removing a word should work
// try removing a non-terminal word
// if exception occured then code DOESN'T work, word does exist.
//
// TEST ENUMERATOR
// Assert size
// Assert each element
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/C-Sharp-Algorithms-master\C-Sharp-Algorithms-master\UnitTest\DataStructuresTests\UndirectedWeightedDenseGraphTests.cs
