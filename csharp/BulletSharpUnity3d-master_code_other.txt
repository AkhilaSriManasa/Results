________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\SceneMenu\BackButton.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\SceneMenu\SceneMenu.cs
// Create a button for each scene.
//GUI.BeginGroup(new Rect(Screen.width/2 - 150, Screen.height/2, 300, 500));
//GUI.EndGroup();
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\SceneMenu\ScenesList.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\SceneMenu\Editor\UpdateScenesListMenu.cs
// Create list.
// Fill list.
// Write asset to disk.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\BulletExampleRunner.cs
/*
//singleton not sure if it needs to be
//rope
//rigid body
//BulletSharp.Math.Matrix transform = co.WorldTransform;
/*
//InitRigidBodyInstance(colObj, child.ChildShape, ref childTransform);
//Debug.Log("Creating " + cs.ShapeType + " for " + co.ToString());
//Debug.Log("Created Unity Shape for shapeType=" + co.CollisionShape.ShapeType + " collisionShape=" + co.ToString());
//demo.Input.ClearKeyCache();
//determine what kind of soft body it is
//rope
//build nodes 2 verts map
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\BulletMultiBodyLinkColliderProxy.cs
// Update is called once per frame
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\BulletRigidBodyProxy.cs
// Update is called once per frame
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\BulletRopeProxy.cs
//public BulletSharp.Math.Vector3[] linkVerts = new BulletSharp.Math.Vector3[0];
//link verts are in pairs marking the ends of the links.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\BulletSoftBodyProxy.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\DemoFramework2UnityInterface.cs
/*
/*
/*
//TODO set formtext and setInfotext should write text to the GUI 
//public MouseButtons MousePressed;
//public MouseButtons MouseReleased;
//public MouseButtons MouseDown;
//TODO this should position the camera
//TODO this should be a wrapper for the Input class
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\MeshFactory.cs
//using BulletSharp.SoftBody;
// Creates platform-agnostic vertex buffers of physical shapes
// (boxes, cones, cylinders, spheres) for drawing. Includes normals.
// Vertices
// Top and bottom
// Stacks
// Indices
// Top cap
// Stacks
// Bottom cap
// Draw the base
// Draw two sides
// Adjust sphere position
// Adjust indices
// Vertices
// Top and bottom
// Stacks
// Indices
// Top cap
// Stacks
//for (j = 0; j < 1; j++)
// Bottom cap
// choose p in y-z plane
// set q = n x p
// choose p in x-y plane
// set q = n x p
// StridingMeshInterface can only be TriangleIndexVertexArray
/*
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\MeshFactory2.cs
//Debug.Log("Creating Shape " + shape);
//int vertexCount = hull.NumVertices;
// choose p in y-z plane
// set q = n x p
// choose p in x-y plane
// set q = n x p
// StridingMeshInterface can only be TriangleIndexVertexArray
//float r = cs.Radius;
//todo this is a cube
// Bottom
// Left
// Front
// Back
// Right
// Top
// Bottom
// Left
// Front
// Back
// Right
// Top
// Bottom
// Left
// Front
// Back
// Right
// Top
// Bottom
// Left
// Front
// Back
// Right
// Top
// Bottom
// Left
// Front
// Back
// Right
// Top
// Bottom
// Left
// Front
// Back
// Right
// Top
// Bottom
// Left
// Front
// Back
// Right
// Top
// Bottom
// Left
// Front
// Back
// Right
// Top
// Longitude |||
// Latitude ---
//Top Cap
//Middle
//Bottom Cap
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\BasicDemo\BasicDemo.cs
// create 125 (5x5x5) dynamic objects
// scaling of the objects (0.1 = 20 centimeter boxes )
// collision configuration contains default setup for memory, collision setup
// create the ground
//groundShape.InitializePolyhedralFeatures();
//CollisionShape groundShape = new StaticPlaneShape(new Vector3(0,1,0), 50);
// create a few dynamic rigidbodies
// using motionstate is recommended, it provides interpolation capabilities
// and only synchronizes 'active' objects
// make it drop from a height
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\BenchmarkDemo\BenchmarkDemo.cs
//"F11 - Toggle fullscreen\n" +
// collision configuration contains default setup for memory, collision setup
// the maximum size of the collision world. Make sure objects stay within these boundaries
// Don't make the world AABB size too large, it will harm simulation quality and performance
//Broadphase = new DbvtBroadphase();
// create the ground
// 3000
/*RigidBody cmbody =*/ LocalCreateRigidBody(mass, Matrix.Translation(pos), blockShape);
// spacing *= 1.01f;
// TODO: Ragdolls
//this will enable polyhedral contact clipping, better quality, slightly slower
//CreateLargeMeshBody();
//CreateLargeMeshBody();
// TODO
//CreateTest6();
//InitRays();
/*RigidBody body =*/ LocalCreateRigidBody(mass, Matrix.Translation(offsetPosition + pos), blockShape);
//	float diffX = boxSize[0] * 1.0f;
// create active boxes
//rigidbody is dynamic if and only if mass is non zero, otherwise static
//using motionstate is recommended, it provides interpolation capabilities, and only synchronizes 'active' objects
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\BenchmarkDemo\Taru.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\Box2DDemo\Box2DDemo.cs
///create 25 (5x5) dynamic objects
// collision configuration contains default setup for memory, collision setup
// Use the default collision dispatcher. For parallel processing you can use a diffent dispatcher.
// the default constraint solver.
// create a few basic rigid bodies
// create a few dynamic rigidbodies
// Re-using the same collision is better for memory usage and performance
//using motionstate is recommended, it provides interpolation capabilities, and only synchronizes 'active' objects
//body.ActivationState = ActivationState.IslandSleeping;
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\BspDemo\BspConverter.cs
//start a bit higher
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\BspDemo\BspDemo.cs
// perhaps we can do something special with entities (isEntity)
// like adding a collision Triggering (as example)
//can use a shift
// collision configuration contains default setup for memory, collision setup
//string[] args = Environment.GetCommandLineArgs();
//if (args.Length == 1)
//{
//}
//else
//{
//    bspLoader.LoadBspFile(args[1]);
//}
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\BspDemo\BspLoader.cs
// read header
// if (id == "VBSP")
// lump format version
// lump ident code
// read brushes
// read brush sides
// texinfo
// bevel
// read entities
// read leaves
// contents
//Swap Y and Z; invert Z
//Swap Y and Z; invert Z
// leafWaterDataID
//reader.ReadInt16(); // ambientLighting
//reader.ReadSByte(); // ambientLighting
// padding
//Swap Y and Z; invert Z
//Swap Y and Z; invert Z
// read leaf brushes
// read planes
// type
// read shaders
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\CcdPhysicsDemo\CcdPhysicsDemo.cs
// collision configuration contains default setup for memory, collision setup
//Dispatcher.RegisterCollisionCreateFunc(BroadphaseNativeType.BoxShape, BroadphaseNativeType.BoxShape,
//    CollisionConf.GetCollisionAlgorithmCreateFunc(BroadphaseNativeType.ConvexShape, BroadphaseNativeType.ConvexShape));
// the default constraint solver.
//World.SolverInfo.SplitImpulse = 0;
//body.RollingFriction = 0.3f;
//CollisionShape shape = new CylinderShape(CubeHalfExtents, CubeHalfExtents, CubeHalfExtents);
//stack them
//body.RollingFriction = 0.3f;
//body.Restitution = 1;
// when using ccdMode, disable regular CCD
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\CharacterDemo\BspConverter.cs
//start a bit higher
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\CharacterDemo\BspLoader.cs
// read header
// if (id == "VBSP")
// lump format version
// lump ident code
// read brushes
// read brush sides
// texinfo
// bevel
// read entities
// read leaves
// contents
//Swap Y and Z; invert Z
//Swap Y and Z; invert Z
// leafWaterDataID
//reader.ReadInt16(); // ambientLighting
//reader.ReadSByte(); // ambientLighting
// padding
//Swap Y and Z; invert Z
//Swap Y and Z; invert Z
// read leaf brushes
// read planes
// type
// read shaders
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\CharacterDemo\CharacterDemo.cs
// perhaps we can do something special with entities (isEntity)
// like adding a collision Triggering (as example)
//can use a shift
//this create an internal copy of the vertices
// collision configuration contains default setup for memory, collision setup
//World.Gravity = Freelook.Up * -10.0f;
//string filename = UnityEngine.Application.dataPath + "/BulletUnity/Examples/Scripts/BulletSharpDemos/CharacterDemo/data/BspDemo.bsp";
//Console.Write("forwardDir={0},{1},{2}\n", forwardDir[0], forwardDir[1], forwardDir[2]);
// * 0.0001f;
//use the convex sweep test to find a safe position for the camera (not blocked by static geometry)
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\CollisionInterfaceDemo\CollisionInterfaceDemo.cs
//world.DebugDrawer.DrawLine(ref ptA, ref ptB, ref ptA);
//Vector3 boxMin = new Vector3(-1, -1, -1);
//Vector3 boxMax = new Vector3(1, 1, 1);
//Vector3 white = new Vector3(1, 1, 1);
//"F11 - Toggle fullscreen\n" +
// collision configuration contains default setup for memory, collision setup
//World.DebugDrawer.DrawBox(ref boxMin, ref boxMax, ref t, ref white);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\ConcaveConvexCastDemo\ConcaveConvexCastDemo.cs
// Scrolls back and forth over terrain
//const float dalpha = 4 * (float)Math.PI / NUMRAYS_IN_BAR;
// rotate around by alpha degrees y
// easier to see if this is big
//"F11 - Toggle fullscreen\n" +
//convexcastBatch = new ConvexcastBatch(true, 40.0f, -50.0f, 50.0f);
// collision configuration contains default setup for memory, collision setup
//CollisionShape colShape = new CapsuleShape(0.5f,2.0f);//boxShape = new SphereShape(1.0f);
//Graphics.MeshFactory.RemoveShape(groundShape);
//clear all contact points involving mesh proxy. Note: this is a slow/unoptimized operation.
//convexcastBatch.Draw(World.DebugDrawer);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\ConcaveRaycastDemo\ConcaveRaycastDemo.cs
// Scrolls back and forth over terrain
// rotate around by alpha degrees y
//static Vector3 cyan = new Vector3(0.0f, 1.0f, 1.0f);
//"F11 - Toggle fullscreen\n" +
// collision configuration contains default setup for memory, collision setup
//raycastBar = new RaycastBar(true, 40.0f, -50.0f, 50.0f);
//CollisionShape colShape = new CapsuleShape(0.5f,2.0f);//boxShape = new SphereShape(1.0f);
//Graphics.MeshFactory.RemoveShape(groundShape);
//clear all contact points involving mesh proxy. Note: this is a slow/unoptimized operation.
//raycastBar.Draw(World.DebugDrawer);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\ConstraintDemo\ConstraintDemo.cs
//"F11 - Toggle fullscreen\n" +
//CollisionShape groundShape = new StaticPlaneShape(Vector3.UnitY, 40);
//1,0,cyl0,localInertia);
//1,0,cyl0,localInertia);
//RigidBody body1 = null;//LocalCreateRigidBody(mass, Matrix.Translation(2*CUBE_HALF_EXTENTS,20,0), shape);
//RigidBody body1 = LocalCreateRigidBody(0, Matrix.Translation(2*CUBE_HALF_EXTENTS,20,0), null);
//body1.ActivationState = ActivationState.DisableDeactivation;
//body1.SetDamping(0.3f, 0.3f);
/*
/*
//TypedConstraint p2p = new Point2PointConstraint(body0, body1, pivotInA, pivotInB);
//TypedConstraint hinge = new HingeConstraint(body0, body1, pivotInA, pivotInB, axisInA, axisInB);
//use zero targetVelocity and a small maxMotorImpulse to simulate joint friction
//float	targetVelocity = 0.f;
//float	maxMotorImpulse = 0.01;
//RigidBody pRbA1 = LocalCreateRigidBody(0.0f, Matrix.Translation(-20, 0, 30), shape);
// add dynamic rigid body B1
//RigidBody pRbB1 = LocalCreateRigidBody(0.0f, Matrix.Translation(-20, 0, 30), shape);
// create slider constraint between A1 and B1 and add it to world
//spSlider1 = new SliderConstraint(pRbA1, pRbB1, Matrix.Identity, Matrix.Identity, false);
//create a slider, using the generic D6 constraint
//SIMD_RADS_PER_DEG * 10.f;
//bool useLinearReferenceFrameA = false;//use fixed frame B for linear llimits
//use fixed frame A for linear llimits
//range should be small, otherwise singularities will 'explode' the constraint
//AngularLowerLimit = new Vector3(-1.5f,0,0),
//AngularUpperLimit = new Vector3(1.5f,0,0),
//AngularLowerLimit = new Vector3(0,0,0),
//AngularUpperLimit = new Vector3(0,0,0),
//spSlider6Dof.TranslationalLimitMotor.EnableMotor[0] = true;
// create a door using hinge constraint attached to the world
// right next to the door slightly outside
// pointing upwards, aka Y-axis
//spDoorHinge.SetLimit(0.0f, (float)Math.PI / 2);
// test problem values
//spDoorHinge.SetLimit(-(float)Math.PI, (float)Math.PI * 0.8f);
//spDoorHinge.SetLimit(1, -1);
//spDoorHinge.SetLimit(-(float)Math.PI * 0.8f, (float)Math.PI);
//spDoorHinge.SetLimit(-(float)Math.PI * 0.8f, (float)Math.PI, 0.9f, 0.3f, 0.0f);
//spDoorHinge.SetLimit(-(float)Math.PI * 0.8f, (float)Math.PI, 0.9f, 0.01f, 0.0f); // "sticky limits"
//spDoorHinge.SetLimit(0, 0);
/*RigidBody pDropBody =*/ LocalCreateRigidBody(10.0f, Matrix.Translation(-5.0f, 2.0f, 0.0f), shape);
// create a generic 6DOF constraint
//RigidBody pBodyA = LocalCreateRigidBody(mass, Matrix.Translation(10.0f, 6.0f, 0), shape);
//RigidBody pBodyA = LocalCreateRigidBody(0, Matrix.Translation(10, 6, 0), null);
//RigidBody pBodyB = LocalCreateRigidBody(0, Matrix.Translation(0, 6, 0), shape);
//Generic6DofConstraint pGen6DOF = new Generic6DofConstraint(pBodyA, pBodyB, frameInA, frameInB, false);
//pGen6DOF.LinearLowerLimit = new Vector3(-10, 0, 0);
//pGen6DOF.LinearUpperLimit = new Vector3(10, 0, 0);
//pGen6DOF.LinearLowerLimit = new Vector3(0, 0, 0);
//pGen6DOF.LinearUpperLimit = new Vector3(0, 0, 0);
//pGen6DOF.TranslationalLimitMotor.EnableMotor[0] = true;
//pGen6DOF.TranslationalLimitMotor.TargetVelocity = new Vector3(5, 0, 0);
//pGen6DOF.TranslationalLimitMotor.MaxMotorForce = new Vector3(0.1f, 0, 0);
//pGen6DOF.AngularLowerLimit = new Vector3(0, (float)Math.PI * 0.9f, 0);
//pGen6DOF.AngularUpperLimit = new Vector3(0, -(float)Math.PI * 0.9f, 0);
//pGen6DOF.AngularLowerLimit = new Vector3(0, 0, -(float)Math.PI);
//pGen6DOF.AngularUpperLimit = new Vector3(0, 0, (float)Math.PI);
//pGen6DOF.AngularLowerLimit = new Vector3(0, -0.75f, (float)Math.PI * 0.8f);
//pGen6DOF.AngularUpperLimit = new Vector3(0, 0.75f, -(float)Math.PI * 0.8f);
//pGen6DOF.AngularLowerLimit = new Vector3(0, -(float)Math.PI * 0.8f, (float)Math.PI * 1.98f);
//pGen6DOF.AngularUpperLimit = new Vector3(0, (float)Math.PI * 0.8f, -(float)Math.PI * 1.98f);
//pGen6DOF.AngularLowerLimit = new Vector3(-0.75f, -0.5f, -0.5f);
//pGen6DOF.AngularUpperLimit = new Vector3(0.75f, 0.5f, 0.5f);
//pGen6DOF.AngularLowerLimit = new Vector3(-0.75f, 0, 0);
//pGen6DOF.AngularUpperLimit = new Vector3(0.75f, 0, 0);
//pGen6DOF.AngularLowerLimit = new Vector3(0, -0.7f, 0);
//pGen6DOF.AngularUpperLimit = new Vector3(0, 0.7f, 0);
//pGen6DOF.AngularLowerLimit = new Vector3(-1, 0, 0);
//pGen6DOF.AngularUpperLimit = new Vector3(1, 0, 0);
// create a ConeTwist constraint
//pBodyA = LocalCreateRigidBody(0, Matrix.Translation(-10, 5, 0), shape);
//pBodyB = LocalCreateRigidBody(1.0f, Matrix.Translation(-10, -5, 0), shape);
//coneTwist.SetLimit((float)Math.PI / 4, (float)Math.PI / 4, (float)Math.PI * 0.8f);
//coneTwist.SetLimit((((float)Math.PI / 4) * 0.6f), (float)Math.PI / 4, (float)Math.PI * 0.8f, 1.0f); // soft limit == hard limit
// Hinge connected to the world, with motor (to hinge motor with new and old constraint solver)
//pHinge.EnableAngularMotor(true, -1.0f, 0.165f); // use for the old solver
// use for the new SIMD solver
// create a universal joint using generic 6DOF constraint
// create two rigid bodies
// static bodyA (parent) on top:
// dynamic bodyB (child) below it :
// add some (arbitrary) data to build constraint frames
// add constraint to world
// draw constraint frames and limits for debugging
// create a generic 6DOF constraint with springs 
// create a Hinge2 joint
// create two rigid bodies
// static bodyA (parent) on top:
// dynamic bodyB (child) below it :
// add some data to build constraint frames
// add constraint to world
// draw constraint frames and limits for debugging
// create a Hinge joint between two dynamic bodies
// create two rigid bodies
// static bodyA (parent) on top:
// dynamic bodyB:
// add some data to build constraint frames
// add constraint to world
// draw constraint frames and limits for debugging
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\ConvexDecompositionDemo\ConvexDecomposition.cs
//ConvexDecompositionDemo demo;
//this.demo = demo;
// Calc centroid, to shift vertices around center of mass
// Create TriangleMesh
//var trimesh = new TriangleMesh();
//Vector3 vertex0 = hullVertices[index0] * LocalScaling - centroid;
//Vector3 vertex1 = hullVertices[index1] * LocalScaling - centroid;
//Vector3 vertex2 = hullVertices[index2] * LocalScaling - centroid;
//this is a tools issue: due to collision margin, convex objects overlap, compensate for it here:
//#define SHRINK_OBJECT_INWARDS 1
//SHRINK_OBJECT_INWARDS
// advance the 'base index' counter.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\ConvexDecompositionDemo\ConvexDecompositionDemo.cs
//"F11 - Toggle fullscreen\n" +
// MyContactCallback is just an example to show how to get access to the child shape that collided
//UnityEngine.Debug.LogFormat(childShape.ToString());
//UnityEngine.Debug.LogFormat(childShape.ToString());
/*
// collision configuration contains default setup for memory, collision setup
// create the ground
//CompoundCollisionAlgorithm.CompoundChildShapePairCallback = MyCompoundChildShapeCallback;
// Load wavefront file
//string filename = UnityEngine.Application.dataPath + "/BulletUnity/Examples/Scripts/BulletSharpDemos/ConvexDecompositionDemo/data/file.obj";
// Convert file data to TriangleMesh
// Create a hull approximation
// Add non-moving body to world
// HACD
// Recommended HACD parameters: 2 100 false false false
// minimum number of clusters
// maximum concavity
// max of 100 vertices per convex-hull
// Generate convex result
// Combine convex shapes into a compound shape
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\ConvexDecompositionDemo\Wavefront.cs
//Vector2 ToVector2(string f0, string f1)
//{
//    return new Vector2(
//        float.Parse(f0, CultureInfo.InvariantCulture),
//        float.Parse(f1, CultureInfo.InvariantCulture));
//}
// Search for a duplicate
//texels.Add(ToVector2(parts[1], parts[2]));
//texels = new List<Vector2>();
// load a wavefront obj returns number of triangles that were loaded.  Data is persists until the class is destructed.
//texels = new List<Vector2>();
//List<Vector2> texels;
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\DemoFramework\Demo.cs
// Frame counting
// Physics
// Debug drawing
/*
//Graphics = null;
//remove/dispose constraints
//remove the rigidbodies from the dynamics world and delete them
//delete collision shapes
//shadowsEnabled = !shadowsEnabled;
//very weak constraint for picking
/*
// Mouse movement
//keep it at the same picking distance
//keep it at the same picking distance
//shootBoxShape.InitializePolyhedralFeatures();
//body.Restitution = 1;
//rigidbody is dynamic if and only if mass is non zero, otherwise static
//using motionstate is recommended, it provides interpolation capabilities, and only synchronizes 'active' objects
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\DistanceDemo\DistanceDemo.cs
//Vector3 distanceFrom, distanceTo;
//float distance;
/*, body2*/;
//"F11 - Toggle fullscreen\n" +
// ground
// Objects
//colShape = new BoxShape(1);
/*body2 =*/ LocalCreateRigidBody(0, body2Position, colShape1);
//static Vector3 red = new Vector3(1.0f, 0.0f, 0.0f);
/*
//World.DebugDrawer.DrawLine(ref distanceFrom, ref distanceTo, ref red);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\FeatherStoneDemo\FeatherStoneDemo.cs
// create 125 (5x5x5) dynamic objects
// scaling of the objects (0.1 = 20 centimeter boxes )
//"F11 - Toggle fullscreen\n" +
// collision configuration contains default setup for memory, collision setup
// create a few basic rigid bodies
//groundShape.InitializePolyhedralFeatures();
//CollisionShape groundShape = new StaticPlaneShape(new Vector3(0,1,0), 50);
//body.HasSelfCollision = false;
//body.BaseVelocity = Vector3.Zero;
//body.WorldToBaseRot = new Quaternion(0, 0, 1, -0.125f * (float)Math.PI);
//y-axis assumed up
//par body's COM to cur body's COM offset	
//cur body's COM to cur body's PIV offset
//par body's COM to cur body's PIV offset
// create a few dynamic rigidbodies
// using motionstate is recommended, it provides interpolation capabilities
// and only synchronizes 'active' objects
// Add a collider for the base
//if (true)
//rigidbody is dynamic if and only if mass is non zero, otherwise static
//using motionstate is recommended, it provides interpolation capabilities, and only synchronizes 'active' objects
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\GImpactTestDemo\BunnyMesh.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\GImpactTestDemo\GImpactTestDemo.cs
//#define BULLET_TRIANGLE_COLLISION
//#define BULLET_GIMPACT_CONVEX_DECOMPOSITION
//Vector3 kinTorusTran;
//Quaternion kinTorusRot;
//"F11 - Toggle fullscreen\n" +
// collision configuration contains default setup for memory, collision setup
//Broadphase = new SimpleBroadphase();
// create trimesh model and shape
// Create Scene
//floor
//left wall
//right wall
//front wall
//back wall
//static plane
// A plane
/*RigidBody staticBody2 =*/ LocalCreateRigidBody(mass, Matrix.Translation(0, -9, 0), staticplaneShape6);
//another static plane
//normal.Normalize();
// A plane
/*staticBody2 =*/ LocalCreateRigidBody(mass, Matrix.Translation(0, -10, 0), staticplaneShape7);
// Create Static Torus
//kinematicTorus = LocalCreateRigidBody(0, startTransform, CreateTorusShape());
//kinematicTorus.CollisionFlags = kinematicTorus.CollisionFlags | CollisionFlags.StaticObject;
//kinematicTorus.ActivationState = ActivationState.IslandSleeping;
// Kinematic
//kinTorusTran = new Vector3(-0.1f, 0, 0);
//kinTorusRot = Quaternion.RotationYawPitchRoll(0, (float)Math.PI * 0.01f, 0);
// Create dynamic Torus
/*RigidBody bodyA =*/ LocalCreateRigidBody(massT, startTransform, trimeshShape);
/*RigidBody bodyB =*/ LocalCreateRigidBody(massT, startTransform, trimeshShape);
/*
// Create Dynamic Boxes
// Create Torus Shape
//GImpactConvexDecompositionShape trimesh =
//    new GImpactConvexDecompositionShape(indexVertexArrays, new Vector3(1), 0.01f);
//trimesh.Margin = 0.07f;
//trimesh.UpdateBound();
//?????
//trimeshShape = new GImpactMeshData(indexVertexArrays);
// Create Bunny Shape
//GImpactConvexDecompositionShape trimesh2 =
//    new GImpactConvexDecompositionShape(indexVertexArrays, new Vector3(1), 0.01f);
//trimesh.Margin = 0.07f;
//trimesh.UpdateBound();
//trimeshShape = trimesh2;
//?????
//trimeshShape2 = new GImpactMeshData(indexVertexArrays2);
//register GIMPACT algorithm
//ConcaveConcaveCollisionAlgorithm.RegisterAlgorithm(Dispatcher);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\GImpactTestDemo\TorusMesh.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\MotorDemo\MotorDemo.cs
//rigidbody is dynamic if and only if mass is non zero, otherwise static
//using motionstate is recommended, it provides interpolation capabilities, and only synchronizes 'active' objects
//
// Setup geometry
//
//
// Setup rigid bodies
//
// root
// legs
// thigh
// shin
// Setup some damping on the bodies
//bodies[i].SetSleepingThresholds(1.6f, 2.5f);
//
// Setup the constraints
//
//ConeTwistConstraint coneC;
// hip joints
// OK
//hingeC.SetLimit(-0.1f, 0.1f);
// knee joints
//hingeC.SetLimit(-0.01f, 0.01f);
// Remove all constraints
// Remove all bodies and shapes
//"F11 - Toggle fullscreen\n" +
// collision configuration contains default setup for memory, collision setup
// create the ground
//
// set per-frame sinusoidal position targets using angular motor (hacky?)
//
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\PendulumDemo\PendulumDemo.cs
//"F11 - Toggle fullscreen\n" +
// collision configuration contains default setup for memory, collision setup
//Vector3 baseHalfExtents = new Vector3(0.05f, 0.5f, 0.1f);
//multiBody.UseRK4Integration = true;
//multiBody.BaseWorldTransform = Matrix.Identity;
//init the links
//y-axis assumed up
//const bool isDynamic = true;
// : CollisionFilterGroups.StaticFilter;
// : CollisionFilterGroups.AllFilter & ~CollisionFilterGroups.StaticFilter;
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\RagdollDemo\Ragdoll.cs
// Setup the geometry
// Setup some damping on the m_bodies
// Now setup the constraints
//hingeC.SetLimit(-PI_2, 0);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\RagdollDemo\RagdollDemo.cs
//"F11 - Toggle fullscreen\n" +
// collision configuration contains default setup for memory, collision setup
//World.DispatchInfo.UseConvexConservativeDistanceUtil = true;
//World.DispatchInfo.ConvexConservativeDistanceThreshold = 0.01f;
// Setup a big ground box
// Spawn one ragdoll
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\RollingFrictionDemo\RollingFrictionDemo.cs
// create 125 (5x5x5) dynamic objects
// scaling of the objects (0.1 = 20 centimeter boxes )
// collision configuration contains default setup for memory, collision setup
// create the ground
// create a few dynamic rigidbodies
// using motionstate is recommended, it provides interpolation capabilities
// and only synchronizes 'active' objects
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\SerializeDemo\SerializeDemo.cs
///create 125 (5x5x5) dynamic objects
///scaling of the objects (0.1 = 20 centimeter boxes )
//"F11 - Toggle fullscreen\n" +
// collision configuration contains default setup for memory, collision setup
// create a few dynamic rigidbodies
//CollisionShape colShape = new CapsuleShapeZ(1, 1);
//CollisionShape colShape = new CylinderShapeZ(1, 1, 1);
//CollisionShape colShape = new BoxShape(1);
//CollisionShape colShape = new SphereShape(1);
// using motionstate is recommended, it provides interpolation capabilities
// and only synchronizes 'active' objects
// make it drop from a height
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\SoftDemo\Bunny.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\SoftDemo\BunnyMesh.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\SoftDemo\SoftDemo.cs
//localTransform *= Matrix.Translation(new Vector3(1,1,1));
// fun factor...
//capsuleShape.LocalScaling = new Vector3(5, 1, 1);
//RigidBody body = LocalCreateRigidBody(20, startTransform, capsuleShape);
//4+8;
//psb.Cfg.VelocityIterations = 10;
//psb.AppendAnchor(0, body);
//psb.AppendAnchor(r-1, body);
// cutting=true;
// Aerodynamic forces, 50x1g flyers
//psb.Cfg.LF = 0.004f;
//psb.Cfg.DG = 0.0003f;
//psb.Cfg.PIterations = 1;
//psb.CollisionShape.Margin = 0.01f;
//| CollisionFlags.ClusterSelf;
///pass zero in generateClusters to create  cluster for each tetrahedron or triangle
//psb.Materials[0].Lst = 0.2f;
//(elementFilename != null) ? File.ReadAllText(elementFilename) : null;
// (faceFilename != null) ? File.ReadAllText(faceFilename) : null;
// File.ReadAllText(nodeFilename)
// fix one vertex
//psb.SetMass(0,0);
//psb.SetMass(10,0);
//psb.SetMass(20,0);
//psb.GenerateClusters(128);
//psb.CollisionShape.Margin = 0.5f;
// | Collision.ClusterSelf;
//9,9,//31,31,
// pass zero in generateClusters to create  cluster for each tetrahedron or triangle
//psb.GenerateClusters(64);
//SetAzi(180);
// Front left
// Front right
// Rear left
// Rear right
//autocam=true;
//
// collision configuration contains default setup for memory, collision setup
// the default constraint solver.
// Mouse movement
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\SoftDemo\TorusMesh.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\VehicleDemo\CustomVehicle.cs
// This class is equivalent to RaycastVehicle, but is used to test the IAction interface
/*if (RigidBody.MotionState != null)
// calculate j that moves us to zero relative velocity
//debug wheels (cylinders)
///@todo for driving on dynamic/movable objects!;
/////wheel.RaycastInfo.GroundObject = object;
//clamp on max suspension travel
//put wheel info as in rest position
//wheel.ContactFriction = 0;
//todo: move this into proper structure
//calculate the impulse, so that the wheels don't move sidewards
//collapse all those loops into one!
//switch between active rolling (throttle), braking and non-active rolling friction (no throttle/break)
//wheel.EngineForce* timeStep;
// apply the impulses
// fix. It only worked if car's up was along Y - VT.
//Vector4 vChassisWorldUp = RigidBody.CenterOfMassTransform.get_Columns(indexUpAxis);
//apply friction impulse on the ground
//	Spring
// Damper
// RESULT
// Simulate suspension
/*
//apply suspension force
//damping of rotation when not in contact
//up = Vector3.Cross(right, fwd);
//up.Normalize();
//rotate around steering over the wheelAxleWS
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\BulletSharpDemos\BulletSharpDemos\VehicleDemo\VehicleDemo.cs
//bool UseTrimeshGround = false;
//string heightfieldFile = "data/heightfield128x128.raw";
// btRaycastVehicle is the interface for the constraint that implements the raycast vehicle
// notice that for higher-quality slow-moving vehicles, another approach might be better
// implementing explicit hinged-wheel constraints with cylinder collision, rather then raycasts
//this should be engine/velocity dependent
//BT_LARGE_FLOAT;
//1.0f;
//public RaycastVehicle vehicle;
//DebugDrawMode = DebugDrawModes.DrawAabb;
//Broadphase = new DbvtBroadphase();
//if (UseTrimeshGround)
//create a triangle-mesh ground
/*
// Use HeightfieldTerrainShape
//int width = 128, length = 128; // Debugging is too slow for this
//PhyScalarType scalarType = PhyScalarType.PhyUChar;
//FileStream file = new FileStream(heightfieldFile, FileMode.Open, FileAccess.Read);
// Use float data
// Create graphics object
// heightScale isn't applied internally for float data
// Normals will be calculated later
// Using diamond subdivision
// Not using diamond subdivision
//create ground object
//localTrans effectively shifts the center of mass with respect to the chassis
//carChassis.SetDamping(0.2f, 0.2f);
//CylinderShapeX wheelShape = new CylinderShapeX(wheelWidth, wheelRadius, wheelRadius);
// clientResetScene();
// create vehicle
//vehicle = new RaycastVehicle(tuning, carChassis, vehicleRayCaster);
// choose coordinate system
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\CharacterController\MoveCharacterController.cs
// Update is called once per frame
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\CollisionCallbacks\CollisionNormalDisplayCallback.cs
/// <summary>
/// Lock object between threads
/// </summary>
/// <summary>
/// This is called in Unity's thread
/// </summary>
/// <summary>
/// This is called in bullet thread
/// </summary>
/// <param name="other"></param>
/// <param name="manifoldList"></param>
/// <summary>
/// This is called in bullet thread
/// </summary>
/// <param name="other"></param>
/// <param name="manifoldList"></param>
//it is safe to Instantiate, Destroy, Enable and Disable here
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\CollisionCallbacks\CustomCollisionCallbackScript.cs
/// <summary>
///Beware of creating, destroying, adding or removing bullet objects inside CollisionEnter, CollisionStay and CollisionExit. Doing so can alter the list of collisions and ContactManifolds 
///that are being iteratated over
///(comodification). This can result in infinite loops, null pointer exceptions, out of sequence Enter,Stay,Exit, etc... A good way to handle this sitution is 
///to collect the information in these callbacks then override "OnFinishedVisitingManifolds" like:
///
/// public override void OnFinishedVisitingManifolds(){
///     base.OnFinishedVistingManifolds(); //don't omit this it does the callbacks
///     do my Instantiation and deletion here.
/// }
/// </summary>
//it is safe to Instantiate, Destroy, Enable and Disable here
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\Racast\TestRaycast.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\RealtimeSimWithOfflinePrediction\BallThrowTest.cs
//float fixedTimeStep = 1.0F / 60F;
//int maxSubsteps = 3;
// Use this for initialization
// Update is called once per frame
//first simulation ==============================
//Second simulation =====================
//prevent this clause from executing again
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\RealtimeSimWithOfflinePrediction\OfflineBallSimulation.cs
//IMPORTANT Time.fixedTime must match the timestep being used here.
//Create a World
//This should create a copy of the BPhysicsWorld with the same settings
//Copy all existing rigidbodies in scene
// IMPORTANT rigidbodies must be added to the offline world in the same order that they are in the source world
// this is because collisions must be resolved in the same order for the sim to be deterministic
//Step the simulation numberOfSimulationSteps times
//remove/dispose constraints
//remove the rigidbodies from the dynamics world and delete them
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\SoftBody\BunnyRainTest.cs
//        const string collisionTooltip = "Collisions flags\n" +
//"SDF_RS Rigid versus soft mask.\n" +
//"CL_RS: SDF based rigid vs soft.\n" +
//"SVSmask: Cluster vs convex rigid vs soft.\n" +
//"VF_SS: Rigid versus soft mask.\n" +
//"CL_SS:Vertex vs face soft vs soft handling.\n" +
//"CL_SELF: Cluster vs cluster soft vs soft handling.\n" +
//"Default: Cluster soft body self collision.";
//        //[HideInInspector]
//        [Tooltip(collisionTooltip)]
//        public Collisions collisionMask = Collisions.Default;
//Update presets if changed
//play with settings
//bSoft.SoftBodySettings.config.Collisions = collisionMask;
//randomize color for effect
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\SoftBody\ExtendedFlycam.cs
//http://wiki.unity3d.com/index.php/FlyCam_Extended
/*
//wiki.unity3d.com/index.php/FlyThrough), 17 May 2011.
//public float lastUpdateTime = 0f;
//public float currentDeltaTime;
//Screen.lockCursor = true;
//void Update()
//timeDeltaTime = Time.time - lastUpdateTime;
//lastUpdateTime = Time.time;
//Screen.lockCursor = !Screen.lockCursor;
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\SoftBody\RBRainTest.cs
// SelectMesh ProcedurealMesh = SelectMesh.Sphere;
//randomize color for effect
//Random,
// Plane,
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\SoftBody\RopeSticksArray.cs
/// <summary>
/// Demonstrate rope "sticks" or grass similar to SoftDemo "InitSticks"
/// </summary>
//use this position
//SoftBodyEditor will display this when needed
//Vector3 centerPos = transform.position;  //place at this transform position
//create but dont build yet
//copy relavent settings
//Anchor the start node
//start node point
//bRope.SoftBodySettings.ResetToSoftBodyPresets(SBSettingsPresets.ropeStick);
//now build it
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\SoftBody\ShootBox.cs
//using BulletSharp;
//linVel.Normalize();
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\SoftBody\TestTeleportJump.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scenes\Triggers\ExampleTriggerCallback.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scripts\AddForcesAndTorques.cs
// Use this for initialization
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scripts\MoveKinematicObject.cs
//test switching between dynamic and kinematic
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scripts\SetAngularAndLinearVelocity.cs
// Use this for initialization
// Update is called once per frame
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Examples\Scripts\SimpleOfflineSimulation.cs
/* 
//Create a World
// create a few dynamic rigidbodies
//Add a single cube
//Step the simulation 300 steps
//Clean up.
//remove/dispose constraints
//remove the rigidbodies from the dynamics world and delete them
//delete collision shapes
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Axis.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\BSExtensionMethods.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\InvalidDataException.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\MathUtil.cs
///*
/*
// *
// * Bullet Continuous Collision Detection and Physics Library
// * Copyright (c) 2003-2008 Erwin Coumans  http://www.bulletphysics.com/
// *
// * This software is provided 'as-is', without any express or implied warranty.
// * In no event will the authors be held liable for any damages arising from
// * the use of this software.
// * 
// * Permission is granted to anyone to use this software for any purpose, 
// * including commercial applications, and to alter it and redistribute it
// * freely, subject to the following restrictions:
// * 
// * 1. The origin of this software must not be misrepresented; you must not
// *    claim that you wrote the original software. If you use this software
// *    in a product, an acknowledgment in the product documentation would be
// *    appreciated but is not required.
// * 2. Altered source versions must be plainly marked as such, and must not be
// *    misrepresented as being the original software.
// * 3. This notice may not be removed or altered from any source distribution.
// */
//        //public static Matrix TransposeTimesBasis(ref Matrix a, ref Matrix b)
//        public static Matrix TransposeTimesBasis(ref Matrix mA, ref Matrix mB)
//        {
//            Matrix ba = MathUtil.BasisMatrix(ref mA);
//            ba = Matrix.Transpose(ba);
//            Matrix bb = MathUtil.BasisMatrix(ref mB);
//            return BulletMatrixMultiply(ref ba, ref bb);
//        }
//        public static Matrix InverseTimes(Matrix a, Matrix b)
//        {
//            return InverseTimes(ref a, ref b);
//        }
//        public static Matrix InverseTimes(ref Matrix a, ref Matrix b)
//        {
//            Matrix m = Matrix.Invert(a);
//            return BulletMatrixMultiply(ref m, ref b);
//        }
//        public static Matrix TransposeBasis(Matrix m)
//        {
//            return TransposeBasis(ref m);
//        }
//        public static Matrix TransposeBasis(ref Matrix m)
//        {
//            return Matrix.Transpose(BasisMatrix(ref m));
//        }
//        public static Matrix InverseBasis(Matrix m)
//        {
//            return InverseBasis(ref m);
//        }
//        public static Matrix InverseBasis(ref Matrix m)
//        {
//            Matrix b = BasisMatrix(ref m);
//            b = Matrix.Invert(b);
//            return b;
//        }
//        public static float Cofac(ref Matrix m,int r1, int c1, int r2, int c2)
//        {
//            float a = MatrixComponent(ref m, r1, c1);
//            float b = MatrixComponent(ref m, r2, c2);
//            float c = MatrixComponent(ref m, r1, c2);
//            float d = MatrixComponent(ref m, r2, c1);
//            return a * b - c * d;
//        }
// dodgy but seems necessary for rounding issues.
//return a >= -0.00001 ? b : c;
//maxVal = a.W;
//        public static float VectorComponent(Vector3 v, int i)
//        {
//            return VectorComponent(ref v, i);
//        }
//        public static float VectorComponent(ref Vector3 v, int i)
//        {
//            switch (i)
//            {
//                case 0:
//                    return v.X;
//                case 1:
//                    return v.Y;
//                case 2:
//                    return v.Z;
//                default:
//                    Debug.Assert(false);
//                    return 0.0f;
//            }
//        }
//        public static void VectorComponent(ref Vector3 v, int i, float f)
//        {
//            switch (i)
//            {
//                case 0:
//                    v.X = f;
//                    return;
//                case 1:
//                    v.Y = f;
//                    return;
//                case 2:
//                    v.Z = f;
//                    return;
//            }
//            Debug.Assert(false);
//        }
//        public static void VectorComponentAddAssign(ref Vector3 v, int i, float f)
//        {
//            switch (i)
//            {
//                case 0:
//                    v.X += f;
//                    return;
//                case 1:
//                    v.Y += f;
//                    return;
//                case 2:
//                    v.Z += f;
//                    return;
//            }
//            Debug.Assert(false);
//        }
//        public static void VectorComponentMinusAssign(ref Vector3 v, int i, float f)
//        {
//            switch (i)
//            {
//                case 0:
//                    v.X -= f;
//                    return;
//                case 1:
//                    v.Y -= f;
//                    return;
//                case 2:
//                    v.Z -= f;
//                    return;
//            }
//            Debug.Assert(false);
//        }
//        public static void VectorComponentMultiplyAssign(ref Vector3 v, int i, float f)
//        {
//            switch (i)
//            {
//                case 0:
//                    v.X *= f;
//                    return;
//                case 1:
//                    v.Y *= f;
//                    return;
//                case 2:
//                    v.Z *= f;
//                    return;
//            }
//            Debug.Assert(false);
//        }
//        public static void VectorComponentDivideAssign(ref Vector3 v, int i, float f)
//        {
//            switch (i)
//            {
//                case 0:
//                    v.X /= f;
//                    return;
//                case 1:
//                    v.Y /= f;
//                    return;
//                case 2:
//                    v.Z /= f;
//                    return;
//            }
//            Debug.Assert(false);
//        }
//        public static Matrix AbsoluteMatrix(Matrix input)
//        {
//            return AbsoluteMatrix(ref input);
//        }
//        public static Matrix AbsoluteMatrix(ref Matrix input)
//        {
//            Matrix output;
//            AbsoluteMatrix(ref input, out output);
//            return output;
//        }
//        public static void AbsoluteMatrix(ref Matrix input, out Matrix output)
//        {
//            output = new Matrix(
//                System.Math.Abs(input.M11),
//                System.Math.Abs(input.M12),
//                System.Math.Abs(input.M13),
//                System.Math.Abs(input.M14),
//                System.Math.Abs(input.M21),
//                System.Math.Abs(input.M22),
//                System.Math.Abs(input.M23),
//                System.Math.Abs(input.M24),
//                System.Math.Abs(input.M31),
//                System.Math.Abs(input.M32),
//                System.Math.Abs(input.M33),
//                System.Math.Abs(input.M34),
//                System.Math.Abs(input.M41),
//                System.Math.Abs(input.M42),
//                System.Math.Abs(input.M43),
//                System.Math.Abs(input.M44));
//        }
//        public static Matrix AbsoluteBasisMatrix(ref Matrix input)
//        {
//            Matrix output;
//            AbsoluteBasisMatrix(ref input, out output);
//            return output;
//        }
//        public static void AbsoluteBasisMatrix(ref Matrix input, out Matrix output)
//        {
//            output = new Matrix(
//                System.Math.Abs(input.M11), System.Math.Abs(input.M12), System.Math.Abs(input.M13), 0.0f,
//                System.Math.Abs(input.M21), System.Math.Abs(input.M22), System.Math.Abs(input.M23), 0.0f,
//                System.Math.Abs(input.M31), System.Math.Abs(input.M32), System.Math.Abs(input.M33), 0.0f,
//                0.0f, 0.0f, 0.0f, 1.0f);
//        }
//        public static void AbsoluteVector(ref Vector3 input, out Vector3 output)
//        {
//            output = new Vector3(
//                System.Math.Abs(input.X),
//                System.Math.Abs(input.Y),
//                System.Math.Abs(input.Z));
//        }
//        public static void RotateVector(ref Vector3 vec, ref Matrix m, out Vector3 output)
//        {
//            Quaternion rotation;
//            Vector3 component;
//            m.Decompose(out component, out rotation, out component);
//            output = Vector3.Transform(vec, rotation);
//        }
//        public static void TransformAabb(Vector3 halfExtents, float margin, Matrix trans, out Vector3 aabbMinOut, out Vector3 aabbMaxOut)
//        {
//            //TransformAabb(ref halfExtents,margin,ref trans,out aabbMinOut,out aabbMaxOut);
//            Vector3 halfExtentsWithMargin = halfExtents + new Vector3(margin);
//            Vector3 center, extent;
//            AbsoluteExtents(ref trans, ref halfExtentsWithMargin, out center, out extent);
//            aabbMinOut = center - extent;
//            aabbMaxOut = center + extent;
//        }
//        public static void TransformAabb(ref Vector3 halfExtents, float margin, ref Matrix trans, out Vector3 aabbMinOut, out Vector3 aabbMaxOut)
//        {
//            Vector3 halfExtentsWithMargin = halfExtents + new Vector3(margin);
//            Vector3 center, extent;
//            AbsoluteExtents(ref trans, ref halfExtentsWithMargin, out center, out extent);
//            aabbMinOut = center - extent;
//            aabbMaxOut = center + extent;
//        }
//        public static void TransformAabb(Vector3 localAabbMin, Vector3 localAabbMax, float margin, Matrix trans, out Vector3 aabbMinOut, out Vector3 aabbMaxOut)
//        {
//            TransformAabb(ref localAabbMin, ref localAabbMax, margin, ref trans, out aabbMinOut, out aabbMaxOut);
//        }
//        public static void TransformAabb(ref Vector3 localAabbMin, ref Vector3 localAabbMax, float margin, ref Matrix trans, out Vector3 aabbMinOut, out Vector3 aabbMaxOut)
//        {
//            Debug.Assert(localAabbMin.X <= localAabbMax.X);
//            Debug.Assert(localAabbMin.Y <= localAabbMax.Y);
//            Debug.Assert(localAabbMin.Z <= localAabbMax.Z);
//            Vector3 localHalfExtents = 0.5f * (localAabbMax - localAabbMin);
//            localHalfExtents += new Vector3(margin);
//            Vector3 localCenter = 0.5f * (localAabbMax + localAabbMin);
//            Matrix abs_b = MathUtil.AbsoluteBasisMatrix(ref trans);
//            Vector3 center = Vector3.Transform(localCenter, trans);
//            Vector3 extent = new Vector3(Vector3.Dot(abs_b.Right, localHalfExtents),
//                                            Vector3.Dot(abs_b.Up, localHalfExtents),
//                                            Vector3.Dot(abs_b.Backward, localHalfExtents));
//            aabbMinOut = center - extent;
//            aabbMaxOut = center + extent;
//        }
//        public static void AbsoluteExtents(ref Matrix trans, ref Vector3 vec, out Vector3 center, out Vector3 extent)
//        {
//            Matrix abs_b;
//            AbsoluteMatrix(ref trans, out abs_b);
//            center = trans._origin;
//            extent = new Vector3(Vector3.Dot(abs_b.Right, vec),
//                                            Vector3.Dot(abs_b.Up, vec),
//                                            Vector3.Dot(abs_b.Backward, vec));
//        }
//        public static void SetMatrixVector(ref Matrix matrix, int row, Vector3 vector)
//        {
//            SetMatrixVector(ref matrix, row, ref vector);
//        }
//        public static void SetMatrixVector(ref Matrix matrix, int row, ref Vector3 vector)
//        {
//            switch (row)
//            {
//                case 0:
//                    matrix.M11 = vector.X;
//                    matrix.M12 = vector.Y;
//                    matrix.M13 = vector.Z;
//                    return;
//                case 1:
//                    matrix.M21 = vector.X;
//                    matrix.M22 = vector.Y;
//                    matrix.M23 = vector.Z;
//                    return;
//                case 2:
//                    matrix.M31 = vector.X;
//                    matrix.M32 = vector.Y;
//                    matrix.M33 = vector.Z;
//                    return;
//                case 3:
//                    matrix.M41 = vector.X;
//                    matrix.M42 = vector.Y;
//                    matrix.M43 = vector.Z;
//                    return;
//            }
//            Debug.Assert(false);
//        }
//        public static void AddMatrixVector(ref Matrix matrix, int row, ref Vector3 vector)
//        {
//            switch (row)
//            {
//                case 0:
//                    matrix.M11 += vector.X;
//                    matrix.M12 += vector.Y;
//                    matrix.M13 += vector.Z;
//                    return;
//                case 1:
//                    matrix.M21 += vector.X;
//                    matrix.M22 += vector.Y;
//                    matrix.M23 += vector.Z;
//                    return;
//                case 2:
//                    matrix.M31 += vector.X;
//                    matrix.M32 += vector.Y;
//                    matrix.M33 += vector.Z;
//                    return;
//                case 3:
//                    matrix.M41 += vector.X;
//                    matrix.M42 += vector.Y;
//                    matrix.M43 += vector.Z;
//                    return;
//            }
//            Debug.Assert(false);
//        }
//        // FIXME - MAN - make sure this is being called how we'd expect , may need to
//        // swap i,j for row/column differences
//        public static float MatrixComponent(ref Matrix m, int index)
//        {
//            //int i = index % 4;
//            //int j = index / 4;
//            int j = index % 4;
//            int i = index / 4;
//            return MatrixComponent(ref m,i,j);
//        }
//        public static float MatrixComponent(ref Matrix m, int row, int column)
//        {
//            switch (row)
//            {
//                case 0:
//                    if (column == 0) return m.M11;
//                    if (column == 1) return m.M12;
//                    if (column == 2) return m.M13;
//                    if (column == 3) return m.M14;
//                    break;
//                case 1:
//                    if (column == 0) return m.M21;
//                    if (column == 1) return m.M22;
//                    if (column == 2) return m.M23;
//                    if (column == 3) return m.M24;
//                    break;
//                case 2:
//                    if (column == 0) return m.M31;
//                    if (column == 1) return m.M32;
//                    if (column == 2) return m.M33;
//                    if (column == 3) return m.M34;
//                    break;
//                case 3:
//                    if (column == 0) return m.M41;
//                    if (column == 1) return m.M42;
//                    if (column == 2) return m.M43;
//                    if (column == 3) return m.M44;
//                    break;
//            }
//            return 0;
//        }
//        public static void MatrixComponent(ref Matrix m, int row, int column, float val)
//        {
//            switch (row)
//            {
//                case 0:
//                    if (column == 0) m.M11 = val;
//                    if (column == 1) m.M12 = val;
//                    if (column == 2) m.M13 = val;
//                    if (column == 3) m.M14 = val;
//                    break;
//                case 1:
//                    if (column == 0) m.M21 = val;
//                    if (column == 1) m.M22 = val;
//                    if (column == 2) m.M23 = val;
//                    if (column == 3) m.M24 = val;
//                    break;
//                case 2:
//                    if (column == 0) m.M31 = val;
//                    if (column == 1) m.M32 = val;
//                    if (column == 2) m.M33 = val;
//                    if (column == 3) m.M34 = val;
//                    break;
//                case 3:
//                    if (column == 0) m.M41 = val;
//                    if (column == 1) m.M42 = val;
//                    if (column == 2) m.M43 = val;
//                    if (column == 3) m.M44 = val;
//                    break;
//            }
//        }
//        public static Vector3 MatrixColumn(Matrix matrix, int row)
//        {
//            return MatrixColumn(ref matrix, row);
//        }
//        public static Vector3 MatrixColumn(ref Matrix matrix, int row)
//        {
//            Vector3 vectorRow;
//            MatrixColumn(ref matrix, row, out vectorRow);
//            return vectorRow;
//        }
//        public static void MatrixColumn(Matrix matrix, int row, out Vector3 vectorRow)
//        {
//            MatrixColumn(ref matrix,row, out vectorRow);
//        }
//        public static void MatrixColumn(ref Matrix matrix, int row, out Vector3 vectorRow)
//        {
//            switch (row)
//            {
//                case 0:
//                    vectorRow = new Vector3(matrix.M11, matrix.M12, matrix.M13);
//                    break;
//                case 1:
//                    vectorRow = new Vector3(matrix.M21, matrix.M22, matrix.M23);
//                    break;
//                case 2:
//                    vectorRow = new Vector3(matrix.M31, matrix.M32, matrix.M33);
//                    break;
//                case 3:
//                    vectorRow = new Vector3(matrix.M41, matrix.M42, matrix.M43);
//                    break;
//                default:
//                    vectorRow = Vector3.Zero;
//                    break;
//            }
//        }
//        public static Vector3 MatrixRow(Matrix matrix, int row)
//        {
//            switch (row)
//            {
//                case 0:
//                    return new Vector3(matrix.M11, matrix.M21, matrix.M31);
//                case 1:
//                    return new Vector3(matrix.M12, matrix.M22, matrix.M32);
//                case 2:
//                    return new Vector3(matrix.M13, matrix.M23, matrix.M33);
//                case 3:
//                    return new Vector3(matrix.M14, matrix.M24, matrix.M34);
//                default:
//                    return Vector3.Zero;
//            }
//        }
//        public static Vector3 MatrixRow(ref Matrix matrix, int row)
//        {
//            switch (row)
//            {
//                case 0:
//                    return new Vector3(matrix.M11, matrix.M21, matrix.M31);
//                case 1:
//                    return new Vector3(matrix.M12, matrix.M22, matrix.M32);
//                case 2:
//                    return new Vector3(matrix.M13, matrix.M23, matrix.M33);
//                case 3:
//                    return new Vector3(matrix.M14, matrix.M24, matrix.M34);
//                default:
//                    return Vector3.Zero;
//            }
//        }
//        public static void MatrixRow(ref Matrix matrix, int row, out Vector3 vectorRow)
//        {
//            switch (row)
//            {
//                case 0:
//                    vectorRow = new Vector3(matrix.M11, matrix.M21, matrix.M31);
//                    break;
//                case 1:
//                    vectorRow = new Vector3(matrix.M12, matrix.M22, matrix.M32);
//                    break;
//                case 2:
//                    vectorRow = new Vector3(matrix.M13, matrix.M23, matrix.M33);
//                    break;
//                case 3:
//                    vectorRow = new Vector3(matrix.M14, matrix.M24, matrix.M34);
//                    break;
//                default:
//                    vectorRow = Vector3.Zero;
//                    break;
//            }
//        }
// Set testNz to 0xFFFFFFFF if condition is nonzero, 0x00000000 if condition is zero
// Rely on positive value or'ed with its negative having sign bit on
// and zero value or'ed with its negative (which is still zero) having sign bit off 
// Use arithmetic shift right, shifting the sign bit through all 32 bits
//        public static void BasisMatrix(Matrix matrixIn, out Matrix matrixOut)
//        {
//            BasisMatrix(ref matrixIn, out matrixOut);
//        }
//        public static void BasisMatrix(ref Matrix matrixIn, out Matrix matrixOut)
//        {
//            matrixOut = matrixIn;
//            matrixOut.M41 = 0.0f;
//            matrixOut.M42 = 0.0f;
//            matrixOut.M43 = 0.0f;
//            matrixOut.M44 = 1.0f;
//        }
//        public static Matrix BasisMatrix(Matrix matrixIn)
//        {
//            return BasisMatrix(ref matrixIn);
//        }
//        public static Matrix BasisMatrix(ref Matrix matrixIn)
//        {
//            Matrix matrixOut = matrixIn;
//            matrixOut.M41 = 0.0f;
//            matrixOut.M42 = 0.0f;
//            matrixOut.M43 = 0.0f;
//            matrixOut.M44 = 1.0f;
//            return matrixOut;
//        }
// just pick any vector
//      /**@brief diagonalizes this matrix by the Jacobi method.
/**@brief diagonalizes this matrix by the Jacobi method.
//       * coordinate system, i.e., old_this = rot * new_this * rot^T. 
//       * @param threshold See iteration
//       * @param iteration The iteration stops when all off-diagonal elements are less than the threshold multiplied 
//       * by the sum of the absolute values of the diagonal, or when maxSteps have been executed. 
//       * 
//       * Note that this matrix is assumed to be symmetric. 
//       */
//        public static void Diagonalize(ref Matrix inMatrix,ref Matrix rot, float threshold, int maxSteps)
//        {
//            Debug.Assert(false);
//            rot = Matrix.Identity;
//            for (int step = maxSteps; step > 0; step--)
//            {
//                // find off-diagonal element [p][q] with largest magnitude
//                int p = 0;
//                int q = 1;
//                int r = 2;
//                float max = System.Math.Abs(inMatrix.M12);
//                float v = System.Math.Abs(inMatrix.M13);
//                if (v > max)
//                {
//                   q = 2;
//                   r = 1;
//                   max = v;
//                }
//                v = System.Math.Abs(inMatrix.M23);
//                if (v > max)
//                {
//                   p = 1;
//                   q = 2;
//                   r = 0;
//                   max = v;
//                }
//                float t = threshold * (System.Math.Abs(inMatrix.M11) + System.Math.Abs(inMatrix.M22) + System.Math.Abs(inMatrix.M33));
//                if (max <= t)
//                {
//                   if (max <= SIMD_EPSILON * t)
//                   {
//                      return;
//                   }
//                   step = 1;
//                }
//                // compute Jacobi rotation J which leads to a zero for element [p][q] 
//                float mpq = MathUtil.MatrixComponent(ref inMatrix,p,q);
//                float theta = (MathUtil.MatrixComponent(ref inMatrix,q,q)-MathUtil.MatrixComponent(ref inMatrix,p,p)) / (2 * mpq);
//                float theta2 = theta * theta;
//                float cos;
//                float sin;
//                if (theta2 * theta2 < 10f / SIMD_EPSILON)
//                {
//                   t = (theta >= 0f) ? (float)(1f / (theta + System.Math.Sqrt(1 + theta2)))
//                                            : (float)(1f / (theta - System.Math.Sqrt(1 + theta2)));
//                   cos = (float)(1f / System.Math.Sqrt(1 + t * t));
//                   sin = cos * t;
//                }
//                else
//                {
//                   // approximation for large theta-value, i.e., a nearly diagonal matrix
//                   t = 1 / (theta * (2 + 0.5f / theta2));
//                   cos = 1 - 0.5f * t * t;
//                   sin = cos * t;
//                }
//                // apply rotation to matrix (this = J^T * this * J)
//                MathUtil.MatrixComponent(ref inMatrix,p,q,0f);
//                MathUtil.MatrixComponent(ref inMatrix,q,p,0f);
//                MathUtil.MatrixComponent(ref inMatrix,p,p,MathUtil.MatrixComponent(ref inMatrix,p,p)-t*mpq);
//                MathUtil.MatrixComponent(ref inMatrix,q,q,MathUtil.MatrixComponent(ref inMatrix,q,q)+t*mpq);
//                float  mrp = MathUtil.MatrixComponent(ref inMatrix,r,p);
//                float  mrq = MathUtil.MatrixComponent(ref inMatrix,r,q);
//                MathUtil.MatrixComponent(ref inMatrix,r,p,cos * mrp - sin * mrq);
//                MathUtil.MatrixComponent(ref inMatrix,p,r,cos * mrp - sin * mrq);
//                MathUtil.MatrixComponent(ref inMatrix,r,q,cos * mrp + sin * mrq);
//                MathUtil.MatrixComponent(ref inMatrix,q,r,cos * mrp + sin * mrq);
//                // apply rotation to rot (rot = rot * J)
//                for (int i = 0; i < 3; i++)
//                {
//                    float  mrp2 = MathUtil.MatrixComponent(ref rot,i,p);
//                    float  mrq2 = MathUtil.MatrixComponent(ref rot,i,q);
//                    MathUtil.MatrixComponent(ref rot, i, p, cos * mrp - sin * mrq);
//                    MathUtil.MatrixComponent(ref rot, i, q, cos * mrp + sin * mrq);
//                }
//            }
//        }
//Debug.Assert(false);
//        public static void Vector3FromFloat(out Vector3 v, float[] fa)
//        {
//            v = new Vector3(fa[0], fa[1], fa[2]);
//        }
//        //public static void FloatFromVector3(Vector3 v, float[] fa)
//        //{
//        //    FloatFromVector3(ref v, fa);
//        //}
//        //public static void FloatFromVector3(ref Vector3 v, float[] fa)
//        //{
//        //    fa[0] = v.X;
//        //    fa[1] = v.Y;
//        //    fa[2] = v.Z;
//        //}
//        //public static float[] FloatFromVector3(Vector3 v)
//        //{
//        //    return FloatFromVector3(ref v);
//        //}
//        //public static float[] FloatFromVector3(ref Vector3 v)
//        //{
//        //    return new float[] { v.X, v.Y, v.Z };
//        //}
/*
//	// rot =  cy*cz          -cy*sz           sy
//	//        cz*sx*sy+cx*sz  cx*cz-sx*sy*sz -cy*sx
//	//       -cx*cz*sy+sx*sz  cz*sx+cx*sy*sz  cx*cy
//
// WARNING.  Not unique.  XA - ZA = -atan2(r10,r11)
// WARNING.  Not unique.  XAngle + ZAngle = atan2(r10,r11)
//        public static Vector3 MatrixToEuler(ref Matrix m)
//        {
//            Vector3 translate;
//            Vector3 scale;
//            Quaternion rotate;
//            m.Decompose(out scale, out rotate, out translate);
//            return quaternionToEuler(ref rotate);
//        }
//        // Taken from Fabian Vikings post at : http://forums.xna.com/forums/p/4574/23763.aspx  
//        public static Vector3 quaternionToEuler(ref Quaternion q)
//        {
//            Vector3 v = Vector3.Zero;
//            v.X = (float)Math.Atan2
//            (
//                2 * q.Y * q.W - 2 * q.X * q.Z,
//                   1 - 2 * Math.Pow(q.Y, 2) - 2 * Math.Pow(q.Z, 2)
//            );
//            v.Z = (float)Math.Asin
//            (
//                2 * q.X * q.Y + 2 * q.Z * q.W
//            );
//            v.Y = (float)Math.Atan2
//            (
//                2 * q.X * q.W - 2 * q.Y * q.Z,
//                1 - 2 * Math.Pow(q.X, 2) - 2 * Math.Pow(q.Z, 2)
//            );
//            if (q.X * q.Y + q.Z * q.W == 0.5)
//            {
//                v.X = (float)(2 * Math.Atan2(q.X, q.W));
//                v.Y = 0;
//            }
//            else if (q.X * q.Y + q.Z * q.W == -0.5)
//            {
//                v.X = (float)(-2 * Math.Atan2(q.X, q.W));
//                v.Y = 0;
//            }
//            return v;
//        }
//return b * a;
//public static Matrix BulletMatrixMultiply(Matrix m1, Matrix m2)
//{
//    return m1 * m2;
//}
//public static Matrix BulletMatrixMultiply(ref Matrix m1, ref Matrix m2)
//{
//    return m1 * m2;
//}
//        public static Matrix BulletMatrixMultiplyBasis(Matrix m1, Matrix m2)
//        {
//            return BulletMatrixMultiplyBasis(ref m1, ref m2);
//        }
//        public static Matrix BulletMatrixMultiplyBasis(ref Matrix m1, ref Matrix m2)
//        {
//            Matrix mb1;
//            BasisMatrix(ref m1, out mb1);
//            Matrix mb2;
//            BasisMatrix(ref m2, out mb2);
//            return BulletMatrixMultiply(ref mb1, ref mb2);
//        }
// Need to check this mod operator works with floats...
/*
//return Matrix.CreateFromYawPitchRoll(y, x,z);
// This version tested and compared to c++ version. don't break it.
// note that the row/column settings are switched from c++
//        public static Vector3 MatrixToVector(Matrix m, Vector3 v)
//        {
//            return new Vector3(
//                Vector3.Dot(new Vector3(m.M11, m.M12, m.M13), v) + m._origin.X,
//                Vector3.Dot(new Vector3(m.M21, m.M22, m.M23), v) + m._origin.Y,
//                Vector3.Dot(new Vector3(m.M31, m.M32, m.M33), v) + m._origin.Z
//                );
//        }
//        public static Vector3 TransposeTransformNormal(Vector3 v,Matrix m)
//        {
//            return TransposeTransformNormal(ref v, ref m);
//        }
//        public static Vector3 TransposeTransformNormal(ref Vector3 v,ref Matrix m)
//        {
//            Matrix mt = TransposeBasis(ref m);
//            return Vector3.TransformNormal(v, mt);
//        }
//        //public static Vector3 TransposeTransformNormal(ref Vector3 v, ref Matrix m)
//        //{
//        //    Matrix mt = TransposeBasis(ref m);
//        //    return Vector3.TransformNormal(ref v, ref mt);
//        //}
//public const float SIMD_EPSILON = 0.0000001f;
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Native.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Utilities.cs
/*
/// <summary>
/// The value for which all absolute numbers smaller than are considered equal to zero.
/// </summary>
/// <summary>
/// Compares two floating point numbers based on an epsilon zero tolerance.
/// </summary>
/// <param name="left">The first number to compare.</param>
/// <param name="right">The second number to compare.</param>
/// <returns><c>true</c> if <paramref name="left"/> is within epsilon of <paramref name="right"/>; otherwise, <c>false</c>.</returns>
/// <summary>
/// Compares two floating point numbers based on an epsilon zero tolerance.
/// </summary>
/// <param name="left">The first number to compare.</param>
/// <param name="right">The second number to compare.</param>
/// <param name="epsilon">The epsilon value to use for zero tolerance.</param>
/// <returns><c>true</c> if <paramref name="left"/> is within epsilon of <paramref name="right"/>; otherwise, <c>false</c>.</returns>
/// <summary>
/// Swaps two items.
/// </summary>
/// <typeparam name="T">The type of the items to swap.</typeparam>
/// <param name="left">The first item to swap.</param>
/// <param name="right">The second item to swap.</param>
/// <summary>
/// Does something with arrays.
/// </summary>
/// <typeparam name="T">Most likely the type of elements in the array.</typeparam>
/// <param name="value">Who knows what this is for.</param>
/// <param name="count">Probably the length of the array.</param>
/// <returns>An array of who knows what.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\ActivatingCollisionAlgorithm.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\AxisSweep3.cs
//throw new NotImplementedException();
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btAxisSweep3_getHandle(IntPtr obj, ushort index);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btAxisSweep3_processAllOverlappingPairs(IntPtr obj, IntPtr callback);
//throw new NotImplementedException();
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr bt32BitAxisSweep3_getHandle(IntPtr obj, uint index);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void bt32BitAxisSweep3_processAllOverlappingPairs(IntPtr obj, IntPtr callback);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\Box2DBox2DCollisionAlgorithm.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\Box2DShape.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\BoxBoxCollisionAlgorithm.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\BoxBoxDetector.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\BoxShape.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\BroadphaseInterface.cs
// Can't delete broadphase, because it is referenced by a world,
// tell the world to clean up the broadphase later.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\BroadphaseProxy.cs
//return new BroadphaseProxy(native);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\BvhTriangleMeshShape.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\CapsuleShape.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\CollisionAlgorithm.cs
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btCollisionAlgorithmConstructionInfo_getDispatcher1(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btCollisionAlgorithmConstructionInfo_getManifold(IntPtr obj);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\CollisionConfiguration.cs
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\CollisionCreateFunc.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\CollisionDispatcher.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\CollisionObject.cs
// Is the object added to a world?
//System.Diagnostics.Debugger.Break();
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btCollisionObject_getCollisionShape(IntPtr obj);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\CollisionObjectWrapper.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\CollisionShape.cs
/*
//Marshal.WriteInt32(dataBuffer, IntPtr.Size + sizeof(int), 0); //padding
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\CollisionWorld.cs
// need to transform normal into worldspace
//caller already does the filter on the m_closestHitFraction
// need to transform normal into worldspace
//caller already does the filter on the m_closestHitFraction
// need to transform normal into worldspace
//used to calculate hitPointWorld from hitFraction
// keep track of shapes already serialized
// serialize all collision objects
// Clear IDebugDraw wrapper
//btIDebugDrawer_delete(btCollisionWorld_getDebugDrawer(_native));
// Create IDebugDraw wrapper, remember to delete it
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\CompoundCollisionAlgorithm.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\CompoundCompoundCollisionAlgorithm.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\CompoundShape.cs
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btCompoundShapeChild_getChildShape(IntPtr obj);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\ConcaveShape.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\ConeShape.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\ContinuousConvexCollision.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\Convex2DConvex2DAlgorithm.cs
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btConvex2dConvex2dAlgorithm_CreateFunc_getPdSolver(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btConvex2dConvex2dAlgorithm_CreateFunc_getSimplexSolver(IntPtr obj);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\Convex2DShape.cs
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btConvex2dShape_getChildShape(IntPtr obj);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\ConvexCast.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\ConvexConcaveCollisionAlgorithm.cs
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\ConvexConvexAlgorithm.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\ConvexHullShape.cs
/* public void OptimizeConvexHull()
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btConvexHullShape_new2(Vector3[] points);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btConvexHullShape_new3(Vector3[] points, int numPoints);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btConvexHullShape_new4(Vector3[] points, int numPoints, int stride);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btConvexHullShape_optimizeConvexHull(IntPtr obj);
//	[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//    static extern void btConvexHullShape_project(IntPtr obj, [In] ref Matrix trans, [In] ref Vector3 dir, [Out] out float minProj, [Out] out float maxProj, [Out] out Vector3 witnesPtMin, [Out] out Vector3 witnesPtMax);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\ConvexInternalShape.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\ConvexPenetrationDepthSolver.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\ConvexPlaneCollisionAlgorithm.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\ConvexPointCloudShape.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\ConvexPolyhedron.cs
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btFace_getIndices(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btFace_getPlane(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btFace_setIndices(IntPtr obj, AlignedObjectArray value);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btFace_setPlane(IntPtr obj, IntPtr value);
//AlignedFaceArray _faces;
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\ConvexShape.cs
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btConvexShape_batchedUnitVectorGetSupportingVertexWithoutMargin(IntPtr obj, IntPtr vectors, IntPtr supportVerticesOut, int numVectors);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\ConvexTriangleMeshShape.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\CylinderShape.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\Dbvt.cs
/*
/*
/*
/*
/*
/*
/*
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btDbvt_collideKDOP(IntPtr root, [In] ref Vector3 normals, IntPtr offsets, int count, IntPtr policy);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btDbvt_collideOCL(IntPtr root, [In] ref Vector3 normals, IntPtr offsets, [In] ref Vector3 sortaxis, int count, IntPtr policy);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btDbvt_collideOCL2(IntPtr root, [In] ref Vector3 normals, IntPtr offsets, [In] ref Vector3 sortaxis, int count, IntPtr policy, bool fullsort);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btDbvt_collideTT(IntPtr obj, IntPtr root0, IntPtr root1, IntPtr policy);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btDbvt_collideTTpersistentStack(IntPtr obj, IntPtr root0, IntPtr root1, IntPtr policy);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btDbvt_collideTU(IntPtr root, IntPtr policy);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btDbvt_collideTV(IntPtr obj, IntPtr root, IntPtr volume, IntPtr policy);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btDbvt_enumLeaves(IntPtr root, IntPtr policy);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btDbvt_enumNodes(IntPtr root, IntPtr policy);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btDbvt_rayTest(IntPtr root, [In] ref Vector3 rayFrom, [In] ref Vector3 rayTo, IntPtr policy);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btDbvt_rayTestInternal(IntPtr obj, IntPtr root, [In] ref Vector3 rayFrom, [In] ref Vector3 rayTo, [In] ref Vector3 rayDirectionInverse, uint[] signs, float lambda_max, [In] ref Vector3 aabbMin, [In] ref Vector3 aabbMax, IntPtr policy);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\DbvtBroadphase.cs
/*
/*
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btDbvtBroadphase_getPaircache(IntPtr obj);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\DefaultCollisionConfiguration.cs
/*
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\DiscreteCollisionDetectorInterface.cs
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btStorageResultWrapper_new();
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\Dispatcher.cs
/*
// Can't delete dispatcher, because it is referenced by a world,
// tell the world to clean up the broadphase later.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\EmptyCollisionAlgorithm.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\EmptyShape.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\GhostObject.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\GjkConvexCast.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\GjkEpaPenetrationDepthSolver.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\GjkPairDetector.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\HeightfieldTerrainShape.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\ManifoldPoint.cs
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr getGContactAddedCallback();
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\ManifoldResult.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\MinkowskiPenetrationDepthSolver.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\MinkowskiSumShape.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\MultimaterialTriangleMeshShape.cs
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btMultimaterialTriangleMeshShape_getMaterialProperties(IntPtr obj, int partID, int triIndex);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\MultiSphereShape.cs
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\OptimizedBvh.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\OverlappingPairCache.cs
// abstract
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\OverlappingPairCallback.cs
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\PersistentManifold.cs
//: TypedObject
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr getGContactDestroyedCallback();
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr getGContactProcessedCallback();
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\PointCollector.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\PolyhedralConvexShape.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\QuantizedBvh.cs
/*
/*
/*
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btQuantizedBvh_quantize(IntPtr obj, IntPtr out, [In] ref Vector3 point, int isMax);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btQuantizedBvh_quantizeWithClamp(IntPtr obj, IntPtr out, [In] ref Vector3 point2, int isMax);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\RaycastCallback.cs
// same sign
// Backface, skip check
// Now we have the intersection point on the plane, we'll see if it's inside the triangle
// Add an epsilon as a tolerance for the raycast,
// in case the ray hits exacly on the edge of the triangle.
// It must be scaled for the triangle size.
//@BP Mod
// Triangle normal isn't normalized
//@BP Mod - Allow for unflipped normal when raycasting against backfaces
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\ScaledBvhTriangleMeshShape.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\ShapeHull.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\SimpleBroadphase.cs
/*
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//[return: MarshalAs(UnmanagedType.I1)]
//static extern bool btSimpleBroadphase_aabbOverlap(IntPtr proxy0, IntPtr proxy1);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\SimulationIslandManager.cs
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btSimulationIslandManager_IslandCallback_processIsland(IntPtr obj, IntPtr bodies, int numBodies, IntPtr manifolds, int numManifolds, int islandId);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\SoftBodyConcaveCollisionAlgorithm.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\SoftRigidCollisionAlgorithm.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\SoftSoftCollisionAlgorithm.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\SphereBoxCollisionAlgorithm.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\SphereShape.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\SphereSphereCollisionAlgorithm.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\SphereTriangleCollisionAlgorithm.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\SphereTriangleDetector.cs
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\StaticPlaneShape.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\StridingMeshInterface.cs
// abstract
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\TetrahedronShape.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\TriangleBuffer.cs
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\TriangleCallback.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\TriangleIndexVertexArray.cs
// TODO: link _indexedMeshArray to _meshes
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\TriangleIndexVertexMaterialArray.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\TriangleInfoMap.cs
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btTriangleInfoMap_deSerialize(IntPtr obj, IntPtr data);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\TriangleMesh.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\TriangleMeshShape.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\TriangleShape.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\UniformScalingShape.cs
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btUniformScalingShape_getChildShape(IntPtr obj);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\UnionFind.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\VoronoiSimplexSolver.cs
/*
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\GImpact\BoxCollision.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\GImpact\CompoundFromGImpact.cs
//rayTo = cb.From;
//gDebugDraw.drawLine(tr(centroid),tr(centroid+normal),btVector3(1,0,0));
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\GImpact\GImpactBvh.cs
/*
/*
/*
/*
/*
/*
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\GImpact\GImpactCollisionAlgorithm.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\GImpact\GImpactQuantizedBvh.cs
/*
/*
/*
/*
/*
/*
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\GImpact\GImpactShape.cs
/*
/*
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btGImpactShapeInterface_getChildShape(IntPtr obj, int index);
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Collision\GImpact\TriangleShapeEx.cs
/*
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern int btPrimitiveTriangle_clip_triangle(IntPtr obj, IntPtr other, [Out] out Vector3 clipped_points);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btTriangleShapeEx_new3(IntPtr other);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btTriangleShapeEx_applyTransform(IntPtr obj, [In] ref Matrix t);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btTriangleShapeEx_buildTriPlane(IntPtr obj, [Out] out Vector4 plane);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//[return: MarshalAs(UnmanagedType.I1)]
//static extern bool btTriangleShapeEx_overlap_test_conservative(IntPtr obj, IntPtr other);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\ConeTwistConstraint.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\ConstraintSolver.cs
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\ContactConstraint.cs
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\ContactSolverInfo.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\DantzigSolver.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\DiscreteDynamicsWorld.cs
// padding
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\DynamicsWorld.cs
// No actions have been added
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\FixedConstraint.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\GearConstraint.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\Generic6DofConstraint.cs
/*
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\Generic6DofSpring2Constraint.cs
/*
/*
/*
/*
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\Generic6DofSpringConstraint.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\Hinge2Constraint.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\HingeConstraint.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\IAction.cs
//UnityEngine.Debug.Log("Created " + GCHandle.ToIntPtr(handle).ToInt64());
//UnityEngine.Debug.Log("Intptr" + bgActionInterface_getManagedWrapperPntr(_native));
//changed these so they are static fuctions and have MonoPInvokeCallback decorator so they work from iOS (uses AOT)
//UnityEngine.Debug.Log("callback dd yes!");
//changed these so they are static fuctions and have MonoPInvokeCallback decorator so they work from iOS (uses AOT)
//UnityEngine.Debug.Log("Callback yes!! " + iaPtrThis.ToInt64());
//UnityEngine.Debug.Log("Dispose 1");
//UnityEngine.Debug.Log("Dispose 2");
//UnityEngine.Debug.Log("Dispose 3");
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\ICharacterController.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\KinematicCharacterController.cs
//??
//printf("touching %f\n", dist);
//manifold.ClearManifold();
//	printf("m_touchingNormal = %f,%f,%f\n",m_touchingNormal[0],m_touchingNormal[1],m_touchingNormal[2]);
// phase 1: up
/* FIXME: Handle penetration properly */
// Only modify the position if the hit was a slope and not a wall or ceiling.
// we moved up only a fraction of the step height
/*
//			printf("parComponent=%f,%f,%f\n",parComponent[0],parComponent[1],parComponent[2]);
//			printf("perpComponent=%f,%f,%f\n",perpComponent[0],perpComponent[1],perpComponent[2]);
//		printf("movementLength don't normalize a zero vector\n");
//	printf("originalDir=%f,%f,%f\n",originalDir[0],originalDir[1],originalDir[2]);
// phase 2: forward and strafe
//	printf("distance2=%f\n",distance2);
//interferes with step movement
//UpdateTargetPositionBasedOnCollision(ref m_touchingNormal, 0.0f, 1.0f);
// we moved only a fraction
/* See Quake2: "If velocity is against original velocity, stop ead to avoid tiny oscilations in sloping corners." */
//				printf("currentDir: don't normalize a zero vector\n");
// we moved whole way
//	if (callback.m_closestHitFraction == 0.f)
//		break;
// phase 3: down
/*float additionalDownStep = (m_wasOnGround && !onGround()) ? m_stepHeight : 0.0;
//set double test for 2x the step drop, to check for a large drop vs small drop
//test a double fall height, to see if the character should interpolate it's fall (full) or not (partial)
// this works....
//test a double fall height, to see if the character should interpolate it's fall (large) or not (small)
//redo the velocity calculation when falling a small amount, for fast stairs motion
//for larger falls, use the smoother/slower interpolated movement by not touching the target position
//re-run previous tests
// we dropped a fraction of the height -> hit floor
//printf("hitpoint: %g - pos %g\n", callback.m_hitPointWorld.getY(), m_currentPosition.getY());
//due to errors in the closestHitFraction variable when used with large polygons, calculate the hit fraction manually
// we dropped the full height
//undo previous target change
//printf("full drop - %g, %g\n", m_currentPosition.getY(), m_targetPosition.getY());
// use walk direction by default, legacy behavior
// 3G acceleration.
// Terminal velocity of a sky diver in m/s.
// ?
///btActionInterface interface
///btActionInterface interface
//	printf("setVelocity!\n");
//	printf("  interval: %f\n", timeInterval);
//	printf("  velocity: (%f, %f, %f)\n",
//	    velocity.x(), velocity.y(), velocity.z());
//clear pair cache
//			printf("character could not recover from penetration = %d\n", numPenetrationLoops);
// quick check...
//		printf("\n");
// no motion
// Update fall velocity.
//	printf("walkDirection(%f,%f,%f)\n",walkDirection[0],walkDirection[1],walkDirection[2]);
//	printf("walkSpeed=%f\n",walkSpeed);
//printf("  time: %f", m_velocityTimeInterval);
// still have some time left for moving!
// how far will we move while we are moving?
// printf("  dtMoving: %f", dtMoving);
// okay, step
//currently no jumping.
//Matrix xform;
//m_rigidBody.getMotionState().getWorldTransform (out xform);
//Vector3 up = xform.Up;
//up.Normalize ();
//float magnitude = (1.0f/m_rigidBody.getInvMass()) * 8.0f;
//m_rigidBody.applyCentralImpulse (up * magnitude);
/// The max slope determines the maximum angle that the controller can walk up.
/// The slope angle is measured in radians.
//is also in m_ghostObject, but it needs to be convex, so we store it here to avoid upcast
// Slope angle that is set (used for returning the exact value)
// Cosine equivalent of m_maxSlopeRadians (calculated once when set, for optimization)
//@todo: remove this and fix the code
///this is the desired walk direction, set by the user
//some internal variables
///keep track of the contact manifolds
///@todo Interact with dynamic objects,
///Ride kinematicly animated platforms properly
///More realistic (or maybe just a config option) falling
/// -> Should integrate falling velocity manually and use that in stepDown()
///Support jumping
///Support ducking
// need to transform normal into worldspace
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\MlcpSolver.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\MlcpSolverInterface.cs
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//[return: MarshalAs(UnmanagedType.I1)]
//static extern bool btMLCPSolverInterface_solveMLCP(IntPtr obj, IntPtr A, IntPtr b, IntPtr x, IntPtr lo, IntPtr hi, IntPtr limitDependency, int numIterations);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//[return: MarshalAs(UnmanagedType.I1)]
//static extern bool btMLCPSolverInterface_solveMLCP2(IntPtr obj, IntPtr A, IntPtr b, IntPtr x, IntPtr lo, IntPtr hi, IntPtr limitDependency, int numIterations, bool useSparsity);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\NncgConstraintSolver.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\Point2PointConstraint.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\RaycastVehicle.cs
/*if (RigidBody.MotionState != null)
// calculate j that moves us to zero relative velocity
//debug wheels (cylinders)
///@todo for driving on dynamic/movable objects!;
/////wheel.RaycastInfo.GroundObject = object;
//clamp on max suspension travel
//put wheel info as in rest position
//wheel.ContactFriction = 0;
//todo: move this into proper structure
//calculate the impulse, so that the wheels don't move sidewards
//collapse all those loops into one!
//switch between active rolling (throttle), braking and non-active rolling friction (no throttle/break)
//wheel.EngineForce* timeStep;
// apply the impulses
// fix. It only worked if car's up was along Y - VT.
//Vector4 vChassisWorldUp = RigidBody.CenterOfMassTransform.get_Columns(indexUpAxis);
//apply friction impulse on the ground
//	Spring
// Damper
// RESULT
// Simulate suspension
//float depth = 
//apply suspension force
//damping of rotation when not in contact
//up = Vector3.Cross(right, fwd);
//up.Normalize();
//rotate around steering over the wheelAxleWS
//	RayResultCallback& resultCallback;
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\RigidBody.cs
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btRigidBody_getConstraintRef(IntPtr obj, int index);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern int btRigidBody_getNumConstraintRefs(IntPtr obj);
//public int Padding;
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\RigidBodyConstructionInfo.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\SequentialImpulseConstraintSolver.cs
/*
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btSequentialImpulseConstraintSolver_getActiveConstraintRowSolverGeneric(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btSequentialImpulseConstraintSolver_getActiveConstraintRowSolverLowerLimit(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btSequentialImpulseConstraintSolver_getScalarConstraintRowSolverGeneric(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btSequentialImpulseConstraintSolver_getScalarConstraintRowSolverLowerLimit(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btSequentialImpulseConstraintSolver_getSSE2ConstraintRowSolverGeneric(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btSequentialImpulseConstraintSolver_getSSE2ConstraintRowSolverLowerLimit(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btSequentialImpulseConstraintSolver_getSSE4_1ConstraintRowSolverGeneric(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btSequentialImpulseConstraintSolver_getSSE4_1ConstraintRowSolverLowerLimit(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btSequentialImpulseConstraintSolver_setConstraintRowSolverGeneric(IntPtr obj, IntPtr rowSolver);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btSequentialImpulseConstraintSolver_setConstraintRowSolverLowerLimit(IntPtr obj, IntPtr rowSolver);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\SliderConstraint.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\TypedConstraint.cs
/*
/*
/*
/*
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btTypedConstraint_getFixedBody();
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btTypedConstraint_getRigidBodyA(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btTypedConstraint_getRigidBodyB(IntPtr obj);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\UniversalConstraint.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\VehicleRaycaster.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\WheelInfo.cs
//ClientInfo = IntPtr.Zero;
//ClippedInvContactDotSuspension = 0;
//WheelsSuspensionForce = 0;
//SuspensionRelativeVelocity = 0;
//SkidInfo = 0;
// Not in contact : position wheel in a nice (rest length) position
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\Featherstone\MultiBody.cs
/*
/*
/*
/*
/*
/*
/*
/*
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\Featherstone\MultiBodyConstraint.cs
/*
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btMultiBodyConstraint_getMultiBodyA(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btMultiBodyConstraint_getMultiBodyB(IntPtr obj);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\Featherstone\MultiBodyConstraintSolver.cs
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\Featherstone\MultiBodyDynamicsWorld.cs
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btMultiBodyDynamicsWorld_addMultiBody2(IntPtr obj, IntPtr body, short group);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btMultiBodyDynamicsWorld_getMultiBody(IntPtr obj, int mbIndex);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btMultiBodyDynamicsWorld_getMultiBodyConstraint(IntPtr obj, int constraintIndex);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern int btMultiBodyDynamicsWorld_getNumMultibodies(IntPtr obj);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\Featherstone\MultiBodyJointLimitConstraint.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\Featherstone\MultiBodyJointMotor.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\Featherstone\MultiBodyLink.cs
/*
/*
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern eFeatherstoneJointType btMultibodyLink_getJointType(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btMultibodyLink_setAbsFrameLocVelocity(IntPtr obj, SpatialMotionVector value);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btMultibodyLink_setAbsFrameTotVelocity(IntPtr obj, SpatialMotionVector value);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btMultibodyLink_setJointType(IntPtr obj, eFeatherstoneJointType value);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\Featherstone\MultiBodyLinkCollider.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\Featherstone\MultiBodyMLCPConstraintSolver.cs
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\Featherstone\MultiBodyPoint2Point.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Dynamics\Featherstone\MultiBodySolverConstraint.cs
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Extras\bFile.cs
/*
// find the matching memory dna data
// to the file being loaded. Fill the
// memory with the file data...
//_chunkPointerFixupArray.Add(strcData.BaseStream.Position);
//Console.WriteLine("skipped {0} {1} : {2:X}", element.Type.Name, element.Name.Name, strcData.BaseStream.Position);
//GetElement(arrayLen, lookupType, type, data, strcData);
// buffer offset util
// swap ptr sizes...
// swap endian...
// looking for the data's starting position
// and the start of SDNA decls
// read the DNA1 block and extract SDNA
// Some Bullet files are missing the DNA1 block
// In Blender it's DNA1 + ChunkUtils::getOffset() + SDNA + NAME
// In Bullet tests its SDNA + NAME
// Also no REND block, so exit now.
//Console.WriteLine("Failed to find DNA1+SDNA pair");
// _fileDna.Init will convert part of DNA file endianness to current CPU endianness if necessary
//Console.WriteLine("warning: fixing some broken DNA version");
//if ((verboseMode & FileVerboseMode.DumpDnaTypeDefinitions) == FileVerboseMode.DumpDnaTypeDefinitions)
//    _fileDna.DumpTypeDefinitions();
//Console.WriteLine ("Warning, file DNA is different than built in, performance is reduced. Best to re-export file with a matching version/platform");
//Console.WriteLine ("Warning, file DNA is newer than built in.");
//bool ignoreEndianFlag = false;
//swap(head, dataChunk, ignoreEndianFlag);
// Ouch! need to rebuild the struct
// Don't try to convert Link block data, just memcpy it. Other data can be converted.
//Console.WriteLine("Link found");
//_libPointers.Add(old, cur);
// && ((_flags & FileFlags.BitsVaries | FileFlags.VersionVaries) != 0))
//ResolvePointersMismatch();
//Console.WriteLine("skipping struct");
//throw new NotImplementedException();
//Console.WriteLine("Cannot fixup pointer at {0} from {1} to {2}!", ptrptr, *ptrptr, ptr);
//throw new NotImplementedException();
// export a simple type
/*
//_chunks[i].OldPtr
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Extras\BulletFile.cs
/*
//_dataBlocks.push_back(dataBlock);
/*
//the parsing will convert to cpu endian
//Console.WriteLine("Building datablocks");
//Console.WriteLine("Chunk size = {0}", CHUNK_HEADER_LEN);
//Console.WriteLine("File chunk size = {0}", ChunkUtils.GetOffset(_flags));
//swapLen(dataPtr);
// One behind
// same as (BHEAD+DATA dependency)
//m_chunkPtrPtrMap.insert(dataChunk.oldPtr, dataChunk);
//swapLen(dataPtr);
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Extras\BulletReader.cs
// float w = ReadSingle();
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Extras\BulletWorldImporter.cs
// QuantizedBvhData is parsed in C++, so we need to actually fix pointers
//throw new NotImplementedException();
//throw new NotImplementedException();
//now you could save the file in 'native' format using
//bulletFile.WriteFile("native.bullet");
//bulletFile.WriteFile(preSwapFilenameOut);
//bulletFile.DumpChunks(bulletFile->FileDna);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Extras\BulletWriter.cs
// Write(value.W);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Extras\BulletXmlWorldImporter.cs
//throw new NotImplementedException();
//ConvertConstraint(constraintData);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Extras\Chunk.cs
// if the file is saved in a
// different format, get the
// file's chunk size
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Extras\Dna.cs
// find second dim, if any
// SDNA
// NAME
// TYPE
// TLEN
// STRC
// build reverse lookups
// compare the file to memory
// this ptr should be the file data
// SDNA empty!
// Recurse in
// Structs containing non-equal structs are also non-equal
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Extras\Hacd.cs
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Extras\WorldImporter.cs
//StridingMeshInterfaceData* interfaceData = CreateStridingMeshInterfaceData(&gimpactData->m_meshInterface)
//float collisionMargin = reader.ReadInt32();
// m_padding
//box.InitializePolyhedralFeatures();
// + new Vector3(collisionMargin);
//hullShape.InitializePolyhedralFeatures();
//bvh.DeserializeFloat(bvhPtr);
// those fields didn't exist and set to zero for pre-280 versions, so do a check here
/*
//long indices16 = meshReader.ReadPtr(meshOffset + MeshPartData.Offset("Indices16"));
//meshPart.Dispose();
//TODO: _allocatedbtStridingMeshInterfaceDatas
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\LinearMath\AlignedBroadphasePairArray.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\LinearMath\AlignedCollisionObjectArray.cs
//return btAlignedCollisionObjectArray_findLinearSearch(_native, item._native) != Count;
//btAlignedCollisionObjectArray_remove(itemPtr);
// Swap the last item with the item to be removed like Bullet does.
// TODO: implement AxisSweep3::Handle
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btCollisionWorld_addCollisionObject2(IntPtr obj, IntPtr collisionObject, short collisionFilterGroup);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btSoftRigidDynamicsWorld_addSoftBody2(IntPtr obj, IntPtr body, short collisionFilterGroup);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\LinearMath\AlignedIndexedMeshArray.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\LinearMath\AlignedManifoldArray.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\LinearMath\AlignedVector3Array.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\LinearMath\Collections.cs
// Adjust the native pointer of existing children if the array was reallocated.
// Add the child to the backing store.
// Swap the last item with the item to be removed like Bullet does.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\LinearMath\CpuFeatureUtility.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\LinearMath\DebugDraw.cs
/*
//www.bulletphysics.com/
//, IDisposable
/*
//if (ObjectTable.Contains(debugDraw))
//    return ObjectTable.GetUnmanagedObject(debugDraw);
//GCHandle handle = GCHandle.Alloc(debugDrawer);
//IntPtr wrapper = btIDebugDrawWrapper_new(GCHandle.ToIntPtr(handle), IntPtr.Zero);
//ObjectTable.Add(debugDraw, wrapper);
//return wrapper;
//if (ObjectTable.Contains(debugDrawer)
//    return ObjectTable.GetObject<IDebugDraw^>(debugDrawer);
// Draw the ends
// Draw some additional lines
// distance
// XY 
// XZ
// YZ
// choose p in y-z plane
// set q = n x p
// choose p in x-y plane
// set q = n x p
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\LinearMath\DefaultMotionState.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\LinearMath\GeometryUtil.cs
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//[return: MarshalAs(UnmanagedType.I1)]
//static extern bool btGeometryUtil_isInside(IntPtr vertices, IntPtr planeNormal, float margin);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\LinearMath\IDebugDraw.cs
/*
//www.bulletphysics.com/
/*-------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------*/
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\LinearMath\MotionState.cs
//UnityEngine.Debug.Log("Created MoState" + GCHandle.ToIntPtr(handle).ToInt64());
//UnityEngine.Debug.Log("Get" + msPtr.ToInt64());
//UnityEngine.Debug.Log("Set" + msPtr.ToInt64());
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\LinearMath\PolarDecomposition.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\LinearMath\Serializer.cs
//chunk->m_oldPtr);
//oldPtr;
//if we didn't pre-allocate a buffer, we need to create a contiguous buffer now
// header
// SDNA
// NAME
// TYPE
// TLEN
// STRC
// build reverse lookups
//don't serialize name twice
//serialize name string now
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\LinearMath\TransformUtil.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Math\Matrix.cs
/*
/// <summary>
/// Represents a 4x4 mathematical matrix.
/// </summary>
//[TypeConverter(typeof(SlimMath.Design.MatrixConverter))]
/// <summary>
/// The size of the <see cref="SlimMath.Matrix"/> type, in bytes.
/// </summary>
/// <summary>
/// A <see cref="SlimMath.Matrix"/> with all of its components set to zero.
/// </summary>
/// <summary>
/// The identity <see cref="SlimMath.Matrix"/>.
/// </summary>
/// <summary>
/// Value at row 1 column 1 of the matrix.
/// </summary>
/// <summary>
/// Value at row 1 column 2 of the matrix.
/// </summary>
/// <summary>
/// Value at row 1 column 3 of the matrix.
/// </summary>
/// <summary>
/// Value at row 1 column 4 of the matrix.
/// </summary>
/// <summary>
/// Value at row 2 column 1 of the matrix.
/// </summary>
/// <summary>
/// Value at row 2 column 2 of the matrix.
/// </summary>
/// <summary>
/// Value at row 2 column 3 of the matrix.
/// </summary>
/// <summary>
/// Value at row 2 column 4 of the matrix.
/// </summary>
/// <summary>
/// Value at row 3 column 1 of the matrix.
/// </summary>
/// <summary>
/// Value at row 3 column 2 of the matrix.
/// </summary>
/// <summary>
/// Value at row 3 column 3 of the matrix.
/// </summary>
/// <summary>
/// Value at row 3 column 4 of the matrix.
/// </summary>
/// <summary>
/// Value at row 4 column 1 of the matrix.
/// </summary>
/// <summary>
/// Value at row 4 column 2 of the matrix.
/// </summary>
/// <summary>
/// Value at row 4 column 3 of the matrix.
/// </summary>
/// <summary>
/// Value at row 4 column 4 of the matrix.
/// </summary>
/// <summary>
/// Initializes a new instance of the <see cref="SlimMath.Matrix"/> struct.
/// </summary>
/// <param name="value">The value that will be assigned to all components.</param>
/// <summary>
/// Initializes a new instance of the <see cref="SlimMath.Matrix"/> struct.
/// </summary>
/// <param name="M11">The value to assign at row 1 column 1 of the matrix.</param>
/// <param name="M12">The value to assign at row 1 column 2 of the matrix.</param>
/// <param name="M13">The value to assign at row 1 column 3 of the matrix.</param>
/// <param name="M14">The value to assign at row 1 column 4 of the matrix.</param>
/// <param name="M21">The value to assign at row 2 column 1 of the matrix.</param>
/// <param name="M22">The value to assign at row 2 column 2 of the matrix.</param>
/// <param name="M23">The value to assign at row 2 column 3 of the matrix.</param>
/// <param name="M24">The value to assign at row 2 column 4 of the matrix.</param>
/// <param name="M31">The value to assign at row 3 column 1 of the matrix.</param>
/// <param name="M32">The value to assign at row 3 column 2 of the matrix.</param>
/// <param name="M33">The value to assign at row 3 column 3 of the matrix.</param>
/// <param name="M34">The value to assign at row 3 column 4 of the matrix.</param>
/// <param name="M41">The value to assign at row 4 column 1 of the matrix.</param>
/// <param name="M42">The value to assign at row 4 column 2 of the matrix.</param>
/// <param name="M43">The value to assign at row 4 column 3 of the matrix.</param>
/// <param name="M44">The value to assign at row 4 column 4 of the matrix.</param>
/// <summary>
/// Initializes a new instance of the <see cref="SlimMath.Matrix"/> struct.
/// </summary>
/// <param name="values">The values to assign to the components of the matrix. This must be an array with sixteen elements.</param>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="values"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="values"/> contains more or less than sixteen elements.</exception>
/// <summary>
/// Gets or sets the basis matrix for the rotation.
/// </summary>
/// <summary>
/// Gets or sets the first row in the matrix; that is M11, M12, M13, and M14.
/// </summary>
/// <summary>
/// Gets or sets the second row in the matrix; that is M21, M22, M23, and M24.
/// </summary>
/// <summary>
/// Gets or sets the third row in the matrix; that is M31, M32, M33, and M34.
/// </summary>
/// <summary>
/// Gets or sets the fourth row in the matrix; that is M41, M42, M43, and M44.
/// </summary>
/// <summary>
/// Gets or sets the first column in the matrix; that is M11, M21, M31, and M41.
/// </summary>
/// <summary>
/// Gets or sets the second column in the matrix; that is M12, M22, M32, and M42.
/// </summary>
/// <summary>
/// Gets or sets the third column in the matrix; that is M13, M23, M33, and M43.
/// </summary>
/// <summary>
/// Gets or sets the fourth column in the matrix; that is M14, M24, M34, and M44.
/// </summary>
/// <summary>
/// Gets or sets the translation of the matrix; that is M41, M42, and M43.
/// </summary>
/// <summary>
/// Gets or sets the scale of the matrix; that is M11, M22, and M33.
/// </summary>
/// <summary>
/// Gets a value indicating whether this instance is an identity matrix.
/// </summary>
/// <value>
/// <c>true</c> if this instance is an identity matrix; otherwise, <c>false</c>.
/// </value>
/// <summary>
/// Calculates the determinant of the matrix.
/// </summary>
/// <returns>The determinant of the matrix.</returns>
/// <summary>
/// Gets or sets the component at the specified index.
/// </summary>
/// <value>The value of the matrix component, depending on the index.</value>
/// <param name="index">The zero-based index of the component to access.</param>
/// <returns>The value of the component at the specified index.</returns>
/// <exception cref="System.ArgumentOutOfRangeException">Thrown when the <paramref name="index"/> is out of the range [0, 15].</exception>
/// <summary>
/// Gets or sets the component at the specified index.
/// </summary>
/// <value>The value of the matrix component, depending on the index.</value>
/// <param name="row">The row of the matrix to access.</param>
/// <param name="column">The column of the matrix to access.</param>
/// <returns>The value of the component at the specified index.</returns>
/// <exception cref="System.ArgumentOutOfRangeException">Thrown when the <paramref name="row"/> or <paramref name="column"/>is out of the range [0, 3].</exception>
/// <summary>
/// Negates a matrix.
/// </summary>
/// <summary>
/// Inverts the matrix.
/// </summary>
/// <summary>
/// Transposes the matrix.
/// </summary>
/// <summary>
/// Performs the exponential operation on a matrix.
/// </summary>
/// <param name="exponent">The exponent to raise the matrix to.</param>
/// <exception cref="System.ArgumentOutOfRangeException">Thrown when the <paramref name="exponent"/> is negative.</exception>
/// <summary>
/// Orthogonalizes the specified matrix.
/// </summary>
/// <remarks>
/// <para>Orthogonalization is the process of making all rows orthogonal to each other. This
/// means that any given row in the matrix will be orthogonal to any other given row in the
/// matrix.</para>
/// <para>Because this method uses the modified Gram-Schmidt process, the resulting matrix
/// tends to be numerically unstable. The numeric stability decreases according to the rows
/// so that the first row is the most stable and the last row is the least stable.</para>
/// <para>This operation is performed on the rows of the matrix rather than the columns.
/// If you wish for this operation to be performed on the columns, first transpose the
/// input and than transpose the output.</para>
/// </remarks>
/// <summary>
/// Orthonormalizes the specified matrix.
/// </summary>
/// <remarks>
/// <para>Orthonormalization is the process of making all rows and columns orthogonal to each
/// other and making all rows and columns of unit length. This means that any given row will
/// be orthogonal to any other given row and any given column will be orthogonal to any other
/// given column. Any given row will not be orthogonal to any given column. Every row and every
/// column will be of unit length.</para>
/// <para>Because this method uses the modified Gram-Schmidt process, the resulting matrix
/// tends to be numerically unstable. The numeric stability decreases according to the rows
/// so that the first row is the most stable and the last row is the least stable.</para>
/// <para>This operation is performed on the rows of the matrix rather than the columns.
/// If you wish for this operation to be performed on the columns, first transpose the
/// input and than transpose the output.</para>
/// </remarks>
/// <summary>
/// Decomposes a matrix into an orthonormalized matrix Q and a right traingular matrix R.
/// </summary>
/// <param name="Q">When the method completes, contains the orthonormalized matrix of the decomposition.</param>
/// <param name="R">When the method completes, contains the right triangular matrix of the decomposition.</param>
/// <summary>
/// Decomposes a matrix into a lower triangular matrix L and an orthonormalized matrix Q.
/// </summary>
/// <param name="L">When the method completes, contains the lower triangular matrix of the decomposition.</param>
/// <param name="Q">When the method completes, contains the orthonormalized matrix of the decomposition.</param>
/// <summary>
/// Decomposes a matrix into a scale, rotation, and translation.
/// </summary>
/// <param name="scale">When the method completes, contains the scaling component of the decomposed matrix.</param>
/// <param name="rotation">When the method completes, contains the rtoation component of the decomposed matrix.</param>
/// <param name="translation">When the method completes, contains the translation component of the decomposed matrix.</param>
/// <remarks>
/// This method is designed to decompose an SRT transformation matrix only.
/// </remarks>
//Source: Unknown
//References: http://www.gamedev.net/community/forums/topic.asp?topic_id=441695
//Get the translation.
//Scaling is the length of the rows.
//If any of the scaling factors are zero, than the rotation matrix can not exist.
//The rotation is the left over matrix after dividing out the scaling.
/// <summary>
/// Exchanges two rows in the matrix.
/// </summary>
/// <param name="firstRow">The first row to exchange. This is an index of the row starting at zero.</param>
/// <param name="secondRow">The second row to exchange. This is an index of the row starting at zero.</param>
/// <summary>
/// 
/// </summary>
/// <param name="firstColumn"></param>
/// <param name="secondColumn"></param>
/// <summary>
/// Creates an array containing the elements of the matrix.
/// </summary>
/// <returns>A sixteen-element array containing the components of the matrix.</returns>
/// <summary>
/// Determines the sum of two matrices.
/// </summary>
/// <param name="left">The first matrix to add.</param>
/// <param name="right">The second matrix to add.</param>
/// <param name="result">When the method completes, contains the sum of the two matrices.</param>
/// <summary>
/// Determines the sum of two matrices.
/// </summary>
/// <param name="left">The first matrix to add.</param>
/// <param name="right">The second matrix to add.</param>
/// <returns>The sum of the two matrices.</returns>
/// <summary>
/// Determines the difference between two matrices.
/// </summary>
/// <param name="left">The first matrix to subtract.</param>
/// <param name="right">The second matrix to subtract.</param>
/// <param name="result">When the method completes, contains the difference between the two matrices.</param>
/// <summary>
/// Determines the difference between two matrices.
/// </summary>
/// <param name="left">The first matrix to subtract.</param>
/// <param name="right">The second matrix to subtract.</param>
/// <returns>The difference between the two matrices.</returns>
/// <summary>
/// Scales a matrix by the given value.
/// </summary>
/// <param name="left">The matrix to scale.</param>
/// <param name="scalar">The amount by which to scale.</param>
/// <param name="result">When the method completes, contains the scaled matrix.</param>
/// <summary>
/// Scales a matrix by the given value.
/// </summary>
/// <param name="left">The matrix to scale.</param>
/// <param name="scalar">The amount by which to scale.</param>
/// <returns>The scaled matrix.</returns>
/// <summary>
/// Determines the product of two matrices.
/// </summary>
/// <param name="left">The first matrix to multiply.</param>
/// <param name="right">The second matrix to multiply.</param>
/// <param name="result">The product of the two matrices.</param>
/// <summary>
/// Determines the product of two matrices.
/// </summary>
/// <param name="left">The first matrix to multiply.</param>
/// <param name="right">The second matrix to multiply.</param>
/// <returns>The product of the two matrices.</returns>
/// <summary>
/// Scales a matrix by the given value.
/// </summary>
/// <param name="left">The matrix to scale.</param>
/// <param name="scalar">The amount by which to scale.</param>
/// <param name="result">When the method completes, contains the scaled matrix.</param>
/// <summary>
/// Scales a matrix by the given value.
/// </summary>
/// <param name="left">The matrix to scale.</param>
/// <param name="scalar">The amount by which to scale.</param>
/// <returns>The scaled matrix.</returns>
/// <summary>
/// Determines the quotient of two matrices.
/// </summary>
/// <param name="left">The first matrix to divide.</param>
/// <param name="right">The second matrix to divide.</param>
/// <param name="result">When the method completes, contains the quotient of the two matrices.</param>
/// <summary>
/// Determines the quotient of two matrices.
/// </summary>
/// <param name="left">The first matrix to divide.</param>
/// <param name="right">The second matrix to divide.</param>
/// <returns>The quotient of the two matrices.</returns>
/// <summary>
/// Performs the exponential operation on a matrix.
/// </summary>
/// <param name="value">The matrix to perform the operation on.</param>
/// <param name="exponent">The exponent to raise the matrix to.</param>
/// <param name="result">When the method completes, contains the exponential matrix.</param>
/// <exception cref="System.ArgumentOutOfRangeException">Thrown when the <paramref name="exponent"/> is negative.</exception>
//Source: http://rosettacode.org
//Refrence: http://rosettacode.org/wiki/Matrix-exponentiation_operator
/// <summary>
/// Performs the exponential operation on a matrix.
/// </summary>
/// <param name="value">The matrix to perform the operation on.</param>
/// <param name="exponent">The exponent to raise the matrix to.</param>
/// <returns>The exponential matrix.</returns>
/// <exception cref="System.ArgumentOutOfRangeException">Thrown when the <paramref name="exponent"/> is negative.</exception>
/// <summary>
/// Negates a matrix.
/// </summary>
/// <param name="value">The matrix to be negated.</param>
/// <param name="result">When the method completes, contains the negated matrix.</param>
/// <summary>
/// Negates a matrix.
/// </summary>
/// <param name="value">The matrix to be negated.</param>
/// <returns>The negated matrix.</returns>
/// <summary>
/// Performs a linear interpolation between two matricies.
/// </summary>
/// <param name="start">Start matrix.</param>
/// <param name="end">End matrix.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <param name="result">When the method completes, contains the linear interpolation of the two matricies.</param>
/// <remarks>
/// This method performs the linear interpolation based on the following formula.
/// <code>start + (end - start) * amount</code>
/// Passing <paramref name="amount"/> a value of 0 will cause <paramref name="start"/> to be returned; a value of 1 will cause <paramref name="end"/> to be returned. 
/// </remarks>
/// <summary>
/// Performs a linear interpolation between two matricies.
/// </summary>
/// <param name="start">Start matrix.</param>
/// <param name="end">End matrix.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <returns>The linear interpolation of the two matrices.</returns>
/// <remarks>
/// This method performs the linear interpolation based on the following formula.
/// <code>start + (end - start) * amount</code>
/// Passing <paramref name="amount"/> a value of 0 will cause <paramref name="start"/> to be returned; a value of 1 will cause <paramref name="end"/> to be returned. 
/// </remarks>
/// <summary>
/// Performs a cubic interpolation between two matricies.
/// </summary>
/// <param name="start">Start matrix.</param>
/// <param name="end">End matrix.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <param name="result">When the method completes, contains the cubic interpolation of the two matrices.</param>
/// <summary>
/// Performs a cubic interpolation between two matrices.
/// </summary>
/// <param name="start">Start matrix.</param>
/// <param name="end">End matrix.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <returns>The cubic interpolation of the two matrices.</returns>
/// <summary>
/// Calculates the transpose of the specified matrix.
/// </summary>
/// <param name="value">The matrix whose transpose is to be calculated.</param>
/// <param name="result">When the method completes, contains the transpose of the specified matrix.</param>
/// <summary>
/// Calculates the transpose of the specified matrix.
/// </summary>
/// <param name="value">The matrix whose transpose is to be calculated.</param>
/// <returns>The transpose of the specified matrix.</returns>
/// <summary>
/// Calculates the inverse of the specified matrix.
/// </summary>
/// <param name="value">The matrix whose inverse is to be calculated.</param>
/// <param name="result">When the method completes, contains the inverse of the specified matrix.</param>
/// <summary>
/// Calculates the inverse of the specified matrix.
/// </summary>
/// <param name="value">The matrix whose inverse is to be calculated.</param>
/// <returns>The inverse of the specified matrix.</returns>
/// <summary>
/// Orthogonalizes the specified matrix.
/// </summary>
/// <param name="value">The matrix to orthogonalize.</param>
/// <param name="result">When the method completes, contains the orthogonalized matrix.</param>
/// <remarks>
/// <para>Orthogonalization is the process of making all rows orthogonal to each other. This
/// means that any given row in the matrix will be orthogonal to any other given row in the
/// matrix.</para>
/// <para>Because this method uses the modified Gram-Schmidt process, the resulting matrix
/// tends to be numerically unstable. The numeric stability decreases according to the rows
/// so that the first row is the most stable and the last row is the least stable.</para>
/// <para>This operation is performed on the rows of the matrix rather than the columns.
/// If you wish for this operation to be performed on the columns, first transpose the
/// input and than transpose the output.</para>
/// </remarks>
//Uses the modified Gram-Schmidt process.
//q1 = m1
//q2 = m2 - ((q1 ⋅ m2) / (q1 ⋅ q1)) * q1
//q3 = m3 - ((q1 ⋅ m3) / (q1 ⋅ q1)) * q1 - ((q2 ⋅ m3) / (q2 ⋅ q2)) * q2
//q4 = m4 - ((q1 ⋅ m4) / (q1 ⋅ q1)) * q1 - ((q2 ⋅ m4) / (q2 ⋅ q2)) * q2 - ((q3 ⋅ m4) / (q3 ⋅ q3)) * q3
//By separating the above algorithm into multiple lines, we actually increase accuracy.
/// <summary>
/// Orthogonalizes the specified matrix.
/// </summary>
/// <param name="value">The matrix to orthogonalize.</param>
/// <returns>The orthogonalized matrix.</returns>
/// <remarks>
/// <para>Orthogonalization is the process of making all rows orthogonal to each other. This
/// means that any given row in the matrix will be orthogonal to any other given row in the
/// matrix.</para>
/// <para>Because this method uses the modified Gram-Schmidt process, the resulting matrix
/// tends to be numerically unstable. The numeric stability decreases according to the rows
/// so that the first row is the most stable and the last row is the least stable.</para>
/// <para>This operation is performed on the rows of the matrix rather than the columns.
/// If you wish for this operation to be performed on the columns, first transpose the
/// input and than transpose the output.</para>
/// </remarks>
/// <summary>
/// Orthonormalizes the specified matrix.
/// </summary>
/// <param name="value">The matrix to orthonormalize.</param>
/// <param name="result">When the method completes, contains the orthonormalized matrix.</param>
/// <remarks>
/// <para>Orthonormalization is the process of making all rows and columns orthogonal to each
/// other and making all rows and columns of unit length. This means that any given row will
/// be orthogonal to any other given row and any given column will be orthogonal to any other
/// given column. Any given row will not be orthogonal to any given column. Every row and every
/// column will be of unit length.</para>
/// <para>Because this method uses the modified Gram-Schmidt process, the resulting matrix
/// tends to be numerically unstable. The numeric stability decreases according to the rows
/// so that the first row is the most stable and the last row is the least stable.</para>
/// <para>This operation is performed on the rows of the matrix rather than the columns.
/// If you wish for this operation to be performed on the columns, first transpose the
/// input and than transpose the output.</para>
/// </remarks>
//Uses the modified Gram-Schmidt process.
//Because we are making unit vectors, we can optimize the math for orthogonalization
//and simplify the projection operation to remove the division.
//q1 = m1 / |m1|
//q2 = (m2 - (q1 ⋅ m2) * q1) / |m2 - (q1 ⋅ m2) * q1|
//q3 = (m3 - (q1 ⋅ m3) * q1 - (q2 ⋅ m3) * q2) / |m3 - (q1 ⋅ m3) * q1 - (q2 ⋅ m3) * q2|
//q4 = (m4 - (q1 ⋅ m4) * q1 - (q2 ⋅ m4) * q2 - (q3 ⋅ m4) * q3) / |m4 - (q1 ⋅ m4) * q1 - (q2 ⋅ m4) * q2 - (q3 ⋅ m4) * q3|
//By separating the above algorithm into multiple lines, we actually increase accuracy.
/// <summary>
/// Orthonormalizes the specified matrix.
/// </summary>
/// <param name="value">The matrix to orthonormalize.</param>
/// <returns>The orthonormalized matrix.</returns>
/// <remarks>
/// <para>Orthonormalization is the process of making all rows and columns orthogonal to each
/// other and making all rows and columns of unit length. This means that any given row will
/// be orthogonal to any other given row and any given column will be orthogonal to any other
/// given column. Any given row will not be orthogonal to any given column. Every row and every
/// column will be of unit length.</para>
/// <para>Because this method uses the modified Gram-Schmidt process, the resulting matrix
/// tends to be numerically unstable. The numeric stability decreases according to the rows
/// so that the first row is the most stable and the last row is the least stable.</para>
/// <para>This operation is performed on the rows of the matrix rather than the columns.
/// If you wish for this operation to be performed on the columns, first transpose the
/// input and than transpose the output.</para>
/// </remarks>
/// <summary>
/// Brings the matrix into upper triangular form using elementry row operations.
/// </summary>
/// <param name="value">The matrix to put into upper triangular form.</param>
/// <param name="result">When the method completes, contains the upper triangular matrix.</param>
/// <remarks>
/// If the matrix is not invertable (i.e. its determinant is zero) than the result of this
/// method may produce Single.Nan and Single.Inf values. When the matrix represents a system
/// of linear equations, than this often means that either no solution exists or an infinite
/// number of solutions exist.
/// </remarks>
//Adapted from the row echelon code
/// <summary>
/// Brings the matrix into upper triangular form using elementry row operations.
/// </summary>
/// <param name="value">The matrix to put into upper triangular form.</param>
/// <returns>The upper triangular matrix.</returns>
/// <remarks>
/// If the matrix is not invertable (i.e. its determinant is zero) than the result of this
/// method may produce Single.Nan and Single.Inf values. When the matrix represents a system
/// of linear equations, than this often means that either no solution exists or an infinite
/// number of solutions exist.
/// </remarks>
/// <summary>
/// Brings the matrix into lower triangular form using elementry row operations.
/// </summary>
/// <param name="value">The matrix to put into lower triangular form.</param>
/// <param name="result">When the method completes, contains the lower triangular matrix.</param>
/// <remarks>
/// If the matrix is not invertable (i.e. its determinant is zero) than the result of this
/// method may produce Single.Nan and Single.Inf values. When the matrix represents a system
/// of linear equations, than this often means that either no solution exists or an infinite
/// number of solutions exist.
/// </remarks>
//Adapted from the row echelon code
/// <summary>
/// Brings the matrix into lower triangular form using elementry row operations.
/// </summary>
/// <param name="value">The matrix to put into lower triangular form.</param>
/// <returns>The lower triangular matrix.</returns>
/// <remarks>
/// If the matrix is not invertable (i.e. its determinant is zero) than the result of this
/// method may produce Single.Nan and Single.Inf values. When the matrix represents a system
/// of linear equations, than this often means that either no solution exists or an infinite
/// number of solutions exist.
/// </remarks>
/// <summary>
/// Brings the matrix into row echelon form using elementry row operations;
/// </summary>
/// <param name="value">The matrix to put into row echelon form.</param>
/// <param name="result">When the method completes, contains the row echelon form of the matrix.</param>
//Source: Wikipedia psuedo code
//Reference: http://en.wikipedia.org/wiki/Row_echelon_form#Pseudocode
/// <summary>
/// Brings the matrix into row echelon form using elementry row operations;
/// </summary>
/// <param name="value">The matrix to put into row echelon form.</param>
/// <returns>When the method completes, contains the row echelon form of the matrix.</returns>
/// <summary>
/// Brings the matrix into reduced row echelon form using elementry row operations.
/// </summary>
/// <param name="value">The matrix to put into reduced row echelon form.</param>
/// <param name="augment">The fifth column of the matrix.</param>
/// <param name="result">When the method completes, contains the resultant matrix after the operation.</param>
/// <param name="augmentResult">When the method completes, contains the resultant fifth column of the matrix.</param>
/// <remarks>
/// <para>The fifth column is often called the agumented part of the matrix. This is because the fifth
/// column is really just an extension of the matrix so that there is a place to put all of the
/// non-zero components after the operation is complete.</para>
/// <para>Often times the resultant matrix will the identity matrix or a matrix similar to the identity
/// matrix. Sometimes, however, that is not possible and numbers other than zero and one may appear.</para>
/// <para>This method can be used to solve systems of linear equations. Upon completion of this method,
/// the <paramref name="augmentResult"/> will contain the solution for the system. It is up to the user
/// to analyze both the input and the result to determine if a solution really exists.</para>
/// </remarks>
//Source: http://rosettacode.org
//Reference: http://rosettacode.org/wiki/Reduced_row_echelon_form
/// <summary>
/// Creates a spherical billboard that rotates around a specified object position.
/// </summary>
/// <param name="objectPosition">The position of the object around which the billboard will rotate.</param>
/// <param name="cameraPosition">The position of the camera.</param>
/// <param name="cameraUpVector">The up vector of the camera.</param>
/// <param name="cameraForwardVector">The forward vector of the camera.</param>
/// <param name="result">When the method completes, contains the created billboard matrix.</param>
/// <summary>
/// Creates a spherical billboard that rotates around a specified object position.
/// </summary>
/// <param name="objectPosition">The position of the object around which the billboard will rotate.</param>
/// <param name="cameraPosition">The position of the camera.</param>
/// <param name="cameraUpVector">The up vector of the camera.</param>
/// <param name="cameraForwardVector">The forward vector of the camera.</param>
/// <returns>The created billboard matrix.</returns>
/// <summary>
/// Creates a left-handed, look-at matrix.
/// </summary>
/// <param name="eye">The position of the viewer's eye.</param>
/// <param name="target">The camera look-at target.</param>
/// <param name="up">The camera's up vector.</param>
/// <param name="result">When the method completes, contains the created look-at matrix.</param>
/// <summary>
/// Creates a left-handed, look-at matrix.
/// </summary>
/// <param name="eye">The position of the viewer's eye.</param>
/// <param name="target">The camera look-at target.</param>
/// <param name="up">The camera's up vector.</param>
/// <returns>The created look-at matrix.</returns>
/// <summary>
/// Creates a right-handed, look-at matrix.
/// </summary>
/// <param name="eye">The position of the viewer's eye.</param>
/// <param name="target">The camera look-at target.</param>
/// <param name="up">The camera's up vector.</param>
/// <param name="result">When the method completes, contains the created look-at matrix.</param>
/// <summary>
/// Creates a right-handed, look-at matrix.
/// </summary>
/// <param name="eye">The position of the viewer's eye.</param>
/// <param name="target">The camera look-at target.</param>
/// <param name="up">The camera's up vector.</param>
/// <returns>The created look-at matrix.</returns>
/// <summary>
/// Creates a left-handed, orthographic projection matrix.
/// </summary>
/// <param name="width">Width of the viewing volume.</param>
/// <param name="height">Height of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <param name="result">When the method completes, contains the created projection matrix.</param>
/// <summary>
/// Creates a left-handed, orthographic projection matrix.
/// </summary>
/// <param name="width">Width of the viewing volume.</param>
/// <param name="height">Height of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <returns>The created projection matrix.</returns>
/// <summary>
/// Creates a right-handed, orthographic projection matrix.
/// </summary>
/// <param name="width">Width of the viewing volume.</param>
/// <param name="height">Height of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <param name="result">When the method completes, contains the created projection matrix.</param>
/// <summary>
/// Creates a right-handed, orthographic projection matrix.
/// </summary>
/// <param name="width">Width of the viewing volume.</param>
/// <param name="height">Height of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <returns>The created projection matrix.</returns>
/// <summary>
/// Creates a left-handed, customized orthographic projection matrix.
/// </summary>
/// <param name="left">Minimum x-value of the viewing volume.</param>
/// <param name="right">Maximum x-value of the viewing volume.</param>
/// <param name="bottom">Minimum y-value of the viewing volume.</param>
/// <param name="top">Maximum y-value of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <param name="result">When the method completes, contains the created projection matrix.</param>
/// <summary>
/// Creates a left-handed, customized orthographic projection matrix.
/// </summary>
/// <param name="left">Minimum x-value of the viewing volume.</param>
/// <param name="right">Maximum x-value of the viewing volume.</param>
/// <param name="bottom">Minimum y-value of the viewing volume.</param>
/// <param name="top">Maximum y-value of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <returns>The created projection matrix.</returns>
/// <summary>
/// Creates a right-handed, customized orthographic projection matrix.
/// </summary>
/// <param name="left">Minimum x-value of the viewing volume.</param>
/// <param name="right">Maximum x-value of the viewing volume.</param>
/// <param name="bottom">Minimum y-value of the viewing volume.</param>
/// <param name="top">Maximum y-value of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <param name="result">When the method completes, contains the created projection matrix.</param>
/// <summary>
/// Creates a right-handed, customized orthographic projection matrix.
/// </summary>
/// <param name="left">Minimum x-value of the viewing volume.</param>
/// <param name="right">Maximum x-value of the viewing volume.</param>
/// <param name="bottom">Minimum y-value of the viewing volume.</param>
/// <param name="top">Maximum y-value of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <returns>The created projection matrix.</returns>
/// <summary>
/// Creates a left-handed, perspective projection matrix.
/// </summary>
/// <param name="width">Width of the viewing volume.</param>
/// <param name="height">Height of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <param name="result">When the method completes, contains the created projection matrix.</param>
/// <summary>
/// Creates a left-handed, perspective projection matrix.
/// </summary>
/// <param name="width">Width of the viewing volume.</param>
/// <param name="height">Height of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <returns>The created projection matrix.</returns>
/// <summary>
/// Creates a right-handed, perspective projection matrix.
/// </summary>
/// <param name="width">Width of the viewing volume.</param>
/// <param name="height">Height of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <param name="result">When the method completes, contains the created projection matrix.</param>
/// <summary>
/// Creates a right-handed, perspective projection matrix.
/// </summary>
/// <param name="width">Width of the viewing volume.</param>
/// <param name="height">Height of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <returns>The created projection matrix.</returns>
/// <summary>
/// Creates a left-handed, perspective projection matrix based on a field of view.
/// </summary>
/// <param name="fov">Field of view in the y direction, in radians.</param>
/// <param name="aspect">Aspect ratio, defined as view space width divided by height.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <param name="result">When the method completes, contains the created projection matrix.</param>
/// <summary>
/// Creates a left-handed, perspective projection matrix based on a field of view.
/// </summary>
/// <param name="fov">Field of view in the y direction, in radians.</param>
/// <param name="aspect">Aspect ratio, defined as view space width divided by height.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <returns>The created projection matrix.</returns>
/// <summary>
/// Creates a right-handed, perspective projection matrix based on a field of view.
/// </summary>
/// <param name="fov">Field of view in the y direction, in radians.</param>
/// <param name="aspect">Aspect ratio, defined as view space width divided by height.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <param name="result">When the method completes, contains the created projection matrix.</param>
/// <summary>
/// Creates a right-handed, perspective projection matrix based on a field of view.
/// </summary>
/// <param name="fov">Field of view in the y direction, in radians.</param>
/// <param name="aspect">Aspect ratio, defined as view space width divided by height.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <returns>The created projection matrix.</returns>
/// <summary>
/// Creates a left-handed, customized perspective projection matrix.
/// </summary>
/// <param name="left">Minimum x-value of the viewing volume.</param>
/// <param name="right">Maximum x-value of the viewing volume.</param>
/// <param name="bottom">Minimum y-value of the viewing volume.</param>
/// <param name="top">Maximum y-value of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <param name="result">When the method completes, contains the created projection matrix.</param>
/// <summary>
/// Creates a left-handed, customized perspective projection matrix.
/// </summary>
/// <param name="left">Minimum x-value of the viewing volume.</param>
/// <param name="right">Maximum x-value of the viewing volume.</param>
/// <param name="bottom">Minimum y-value of the viewing volume.</param>
/// <param name="top">Maximum y-value of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <returns>The created projection matrix.</returns>
/// <summary>
/// Creates a right-handed, customized perspective projection matrix.
/// </summary>
/// <param name="left">Minimum x-value of the viewing volume.</param>
/// <param name="right">Maximum x-value of the viewing volume.</param>
/// <param name="bottom">Minimum y-value of the viewing volume.</param>
/// <param name="top">Maximum y-value of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <param name="result">When the method completes, contains the created projection matrix.</param>
/// <summary>
/// Creates a right-handed, customized perspective projection matrix.
/// </summary>
/// <param name="left">Minimum x-value of the viewing volume.</param>
/// <param name="right">Maximum x-value of the viewing volume.</param>
/// <param name="bottom">Minimum y-value of the viewing volume.</param>
/// <param name="top">Maximum y-value of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <returns>The created projection matrix.</returns>
/// <summary>
/// Creates a matrix that scales along the x-axis, y-axis, and y-axis.
/// </summary>
/// <param name="scale">Scaling factor for all three axes.</param>
/// <param name="result">When the method completes, contains the created scaling matrix.</param>
/// <summary>
/// Creates a matrix that scales along the x-axis, y-axis, and y-axis.
/// </summary>
/// <param name="scale">Scaling factor for all three axes.</param>
/// <returns>The created scaling matrix.</returns>
/// <summary>
/// Creates a matrix that uniformally scales along all three axis.
/// </summary>
/// <param name="scale">The uniform scale that is applied along all axis.</param>
/// <param name="result">When the method completes, contains the created scaling matrix.</param>
/// <summary>
/// Creates a matrix that uniformally scales along all three axis.
/// </summary>
/// <param name="scale">The uniform scale that is applied along all axis.</param>
/// <returns>The created scaling matrix.</returns>
/// <summary>
/// Creates a matrix that scales along the x-axis, y-axis, and y-axis.
/// </summary>
/// <param name="x">Scaling factor that is applied along the x-axis.</param>
/// <param name="y">Scaling factor that is applied along the y-axis.</param>
/// <param name="z">Scaling factor that is applied along the z-axis.</param>
/// <param name="result">When the method completes, contains the created scaling matrix.</param>
/// <summary>
/// Creates a matrix that scales along the x-axis, y-axis, and y-axis.
/// </summary>
/// <param name="x">Scaling factor that is applied along the x-axis.</param>
/// <param name="y">Scaling factor that is applied along the y-axis.</param>
/// <param name="z">Scaling factor that is applied along the z-axis.</param>
/// <returns>The created scaling matrix.</returns>
/// <summary>
/// Creates a matrix that rotates around the x-axis.
/// </summary>
/// <param name="angle">Angle of rotation in radians. Angles are measured clockwise when looking along the rotation axis toward the origin.</param>
/// <param name="result">When the method completes, contains the created rotation matrix.</param>
/// <summary>
/// Creates a matrix that rotates around the x-axis.
/// </summary>
/// <param name="angle">Angle of rotation in radians. Angles are measured clockwise when looking along the rotation axis toward the origin.</param>
/// <returns>The created rotation matrix.</returns>
/// <summary>
/// Creates a matrix that rotates around the y-axis.
/// </summary>
/// <param name="angle">Angle of rotation in radians. Angles are measured clockwise when looking along the rotation axis toward the origin.</param>
/// <param name="result">When the method completes, contains the created rotation matrix.</param>
/// <summary>
/// Creates a matrix that rotates around the y-axis.
/// </summary>
/// <param name="angle">Angle of rotation in radians. Angles are measured clockwise when looking along the rotation axis toward the origin.</param>
/// <returns>The created rotation matrix.</returns>
/// <summary>
/// Creates a matrix that rotates around the z-axis.
/// </summary>
/// <param name="angle">Angle of rotation in radians. Angles are measured clockwise when looking along the rotation axis toward the origin.</param>
/// <param name="result">When the method completes, contains the created rotation matrix.</param>
/// <summary>
/// Creates a matrix that rotates around the z-axis.
/// </summary>
/// <param name="angle">Angle of rotation in radians. Angles are measured clockwise when looking along the rotation axis toward the origin.</param>
/// <returns>The created rotation matrix.</returns>
/// <summary>
/// Creates a matrix that rotates around an arbitary axis.
/// </summary>
/// <param name="axis">The axis around which to rotate. This parameter is assumed to be normalized.</param>
/// <param name="angle">Angle of rotation in radians. Angles are measured clockwise when looking along the rotation axis toward the origin.</param>
/// <param name="result">When the method completes, contains the created rotation matrix.</param>
/// <summary>
/// Creates a matrix that rotates around an arbitary axis.
/// </summary>
/// <param name="axis">The axis around which to rotate. This parameter is assumed to be normalized.</param>
/// <param name="angle">Angle of rotation in radians. Angles are measured clockwise when looking along the rotation axis toward the origin.</param>
/// <returns>The created rotation matrix.</returns>
/// <summary>
/// Creates a rotation matrix from a quaternion.
/// </summary>
/// <param name="rotation">The quaternion to use to build the matrix.</param>
/// <param name="result">The created rotation matrix.</param>
/// <summary>
/// Creates a rotation matrix from a quaternion.
/// </summary>
/// <param name="rotation">The quaternion to use to build the matrix.</param>
/// <returns>The created rotation matrix.</returns>
/// <summary>
/// Creates a rotation matrix with a specified yaw, pitch, and roll.
/// </summary>
/// <param name="yaw">Yaw around the y-axis, in radians.</param>
/// <param name="pitch">Pitch around the x-axis, in radians.</param>
/// <param name="roll">Roll around the z-axis, in radians.</param>
/// <param name="result">When the method completes, contains the created rotation matrix.</param>
/// <summary>
/// Creates a rotation matrix with a specified yaw, pitch, and roll.
/// </summary>
/// <param name="yaw">Yaw around the y-axis, in radians.</param>
/// <param name="pitch">Pitch around the x-axis, in radians.</param>
/// <param name="roll">Roll around the z-axis, in radians.</param>
/// <returns>The created rotation matrix.</returns>
/// <summary>
/// Creates a translation matrix using the specified offsets.
/// </summary>
/// <param name="value">The offset for all three coordinate planes.</param>
/// <param name="result">When the method completes, contains the created translation matrix.</param>
/// <summary>
/// Creates a translation matrix using the specified offsets.
/// </summary>
/// <param name="value">The offset for all three coordinate planes.</param>
/// <returns>The created translation matrix.</returns>
/// <summary>
/// Creates a translation matrix using the specified offsets.
/// </summary>
/// <param name="x">X-coordinate offset.</param>
/// <param name="y">Y-coordinate offset.</param>
/// <param name="z">Z-coordinate offset.</param>
/// <param name="result">When the method completes, contains the created translation matrix.</param>
/// <summary>
/// Creates a translation matrix using the specified offsets.
/// </summary>
/// <param name="x">X-coordinate offset.</param>
/// <param name="y">Y-coordinate offset.</param>
/// <param name="z">Z-coordinate offset.</param>
/// <returns>The created translation matrix.</returns>
/// <summary>
/// Creates a 3D affine transformation matrix.
/// </summary>
/// <param name="scaling">Scaling factor.</param>
/// <param name="rotation">The rotation of the transformation.</param>
/// <param name="translation">The translation factor of the transformation.</param>
/// <param name="result">When the method completes, contains the created affine transformation matrix.</param>
/// <summary>
/// Creates a 3D affine transformation matrix.
/// </summary>
/// <param name="scaling">Scaling factor.</param>
/// <param name="rotation">The rotation of the transformation.</param>
/// <param name="translation">The translation factor of the transformation.</param>
/// <returns>The created affine transformation matrix.</returns>
/// <summary>
/// Creates a 3D affine transformation matrix.
/// </summary>
/// <param name="scaling">Scaling factor.</param>
/// <param name="rotationCenter">The center of the rotation.</param>
/// <param name="rotation">The rotation of the transformation.</param>
/// <param name="translation">The translation factor of the transformation.</param>
/// <param name="result">When the method completes, contains the created affine transformation matrix.</param>
/// <summary>
/// Creates a 3D affine transformation matrix.
/// </summary>
/// <param name="scaling">Scaling factor.</param>
/// <param name="rotationCenter">The center of the rotation.</param>
/// <param name="rotation">The rotation of the transformation.</param>
/// <param name="translation">The translation factor of the transformation.</param>
/// <returns>The created affine transformation matrix.</returns>
/// <summary>
/// Creates a transformation matrix.
/// </summary>
/// <param name="scalingCenter">Center point of the scaling operation.</param>
/// <param name="scalingRotation">Scaling rotation amount.</param>
/// <param name="scaling">Scaling factor.</param>
/// <param name="rotationCenter">The center of the rotation.</param>
/// <param name="rotation">The rotation of the transformation.</param>
/// <param name="translation">The translation factor of the transformation.</param>
/// <param name="result">When the method completes, contains the created transformation matrix.</param>
/// <summary>
/// Creates a transformation matrix.
/// </summary>
/// <param name="scalingCenter">Center point of the scaling operation.</param>
/// <param name="scalingRotation">Scaling rotation amount.</param>
/// <param name="scaling">Scaling factor.</param>
/// <param name="rotationCenter">The center of the rotation.</param>
/// <param name="rotation">The rotation of the transformation.</param>
/// <param name="translation">The translation factor of the transformation.</param>
/// <returns>The created transformation matrix.</returns>
/// <summary>
/// Adds two matricies.
/// </summary>
/// <param name="left">The first matrix to add.</param>
/// <param name="right">The second matrix to add.</param>
/// <returns>The sum of the two matricies.</returns>
/// <summary>
/// Assert a matrix (return it unchanged).
/// </summary>
/// <param name="value">The matrix to assert (unchange).</param>
/// <returns>The asserted (unchanged) matrix.</returns>
/// <summary>
/// Subtracts two matricies.
/// </summary>
/// <param name="left">The first matrix to subtract.</param>
/// <param name="right">The second matrix to subtract.</param>
/// <returns>The difference between the two matricies.</returns>
/// <summary>
/// Negates a matrix.
/// </summary>
/// <param name="value">The matrix to negate.</param>
/// <returns>The negated matrix.</returns>
/// <summary>
/// Scales a matrix by a given value.
/// </summary>
/// <param name="right">The matrix to scale.</param>
/// <param name="scalar">The amount by which to scale.</param>
/// <returns>The scaled matrix.</returns>
/// <summary>
/// Scales a matrix by a given value.
/// </summary>
/// <param name="left">The matrix to scale.</param>
/// <param name="scalar">The amount by which to scale.</param>
/// <returns>The scaled matrix.</returns>
/// <summary>
/// Multiplies two matricies.
/// </summary>
/// <param name="left">The first matrix to multiply.</param>
/// <param name="right">The second matrix to multiply.</param>
/// <returns>The product of the two matricies.</returns>
/// <summary>
/// Scales a matrix by a given value.
/// </summary>
/// <param name="left">The matrix to scale.</param>
/// <param name="scalar">The amount by which to scale.</param>
/// <returns>The scaled matrix.</returns>
/// <summary>
/// Divides two matricies.
/// </summary>
/// <param name="left">The first matrix to divide.</param>
/// <param name="right">The second matrix to divide.</param>
/// <returns>The quotient of the two matricies.</returns>
/// <summary>
/// Tests for equality between two objects.
/// </summary>
/// <param name="left">The first value to compare.</param>
/// <param name="right">The second value to compare.</param>
/// <returns><c>true</c> if <paramref name="left"/> has the same value as <paramref name="right"/>; otherwise, <c>false</c>.</returns>
/// <summary>
/// Tests for inequality between two objects.
/// </summary>
/// <param name="left">The first value to compare.</param>
/// <param name="right">The second value to compare.</param>
/// <returns><c>true</c> if <paramref name="left"/> has a different value than <paramref name="right"/>; otherwise, <c>false</c>.</returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <param name="format">The format.</param>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <param name="formatProvider">The format provider.</param>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <param name="format">The format.</param>
/// <param name="formatProvider">The format provider.</param>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a hash code for this instance.
/// </summary>
/// <returns>
/// A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
/// </returns>
/// <summary>
/// Determines whether the specified <see cref="SlimMath.Matrix"/> is equal to this instance.
/// </summary>
/// <param name="other">The <see cref="SlimMath.Matrix"/> to compare with this instance.</param>
/// <returns>
/// <c>true</c> if the specified <see cref="SlimMath.Matrix"/> is equal to this instance; otherwise, <c>false</c>.
/// </returns>
/// <summary>
/// Determines whether the specified <see cref="SlimMath.Matrix"/> is equal to this instance.
/// </summary>
/// <param name="other">The <see cref="SlimMath.Matrix"/> to compare with this instance.</param>
/// <param name="epsilon">The amount of error allowed.</param>
/// <returns>
/// <c>true</c> if the specified <see cref="SlimMath.Matrix"/> is equal to this instance; otherwise, <c>false</c>.
/// </returns>
/// <summary>
/// Determines whether the specified <see cref="System.Object"/> is equal to this instance.
/// </summary>
/// <param name="obj">The <see cref="System.Object"/> to compare with this instance.</param>
/// <returns>
/// <c>true</c> if the specified <see cref="System.Object"/> is equal to this instance; otherwise, <c>false</c>.
/// </returns>
/// <summary>
/// Performs an implicit conversion from <see cref="SlimMath.Matrix"/> to <see cref="SlimDX.Matrix"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="SlimDX.Matrix"/> to <see cref="SlimMath.Matrix"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="SlimMath.Matrix"/> to <see cref="System.Windows.Media.Media3D.Matrix3D"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an explicit conversion from <see cref="System.Windows.Media.Media3D.Matrix3D"/> to <see cref="SlimMath.Matrix"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="SlimMath.Matrix"/> to <see cref="Microsoft.Xna.Framework.Matrix"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="Microsoft.Xna.Framework.Matrix"/> to <see cref="SlimMath.Matrix"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Math\Quaternion.cs
/*
/// <summary>
/// Represents a four dimensional mathematical quaternion.
/// </summary>
//[TypeConverter(typeof(SlimMath.Design.QuaternionConverter))]
/// <summary>
/// The size of the <see cref="SlimMath.Quaternion"/> type, in bytes.
/// </summary>
/// <summary>
/// A <see cref="SlimMath.Quaternion"/> with all of its components set to zero.
/// </summary>
/// <summary>
/// A <see cref="SlimMath.Quaternion"/> with all of its components set to one.
/// </summary>
/// <summary>
/// The identity <see cref="SlimMath.Quaternion"/> (0, 0, 0, 1).
/// </summary>
/// <summary>
/// The X component of the quaternion.
/// </summary>
/// <summary>
/// The Y component of the quaternion.
/// </summary>
/// <summary>
/// The Z component of the quaternion.
/// </summary>
/// <summary>
/// The W component of the quaternion.
/// </summary>
/// <summary>
/// Initializes a new instance of the <see cref="SlimMath.Quaternion"/> struct.
/// </summary>
/// <param name="value">The value that will be assigned to all components.</param>
/// <summary>
/// Initializes a new instance of the <see cref="SlimMath.Quaternion"/> struct.
/// </summary>
/// <param name="value">A vector containing the values with which to initialize the components.</param>
/// <summary>
/// Initializes a new instance of the <see cref="SlimMath.Quaternion"/> struct.
/// </summary>
/// <param name="value">A vector containing the values with which to initialize the X, Y, and Z components.</param>
/// <param name="angle">Initial value for the angle of the quaternion.</param>
/// <summary>
/// Initializes a new instance of the <see cref="SlimMath.Quaternion"/> struct.
/// </summary>
/// <param name="x">Initial value for the X component of the quaternion.</param>
/// <param name="y">Initial value for the Y component of the quaternion.</param>
/// <param name="z">Initial value for the Z component of the quaternion.</param>
/// <param name="w">Initial value for the W component of the quaternion.</param>
/// <summary>
/// Initializes a new instance of the <see cref="SlimMath.Quaternion"/> struct.
/// </summary>
/// <param name="values">The values to assign to the X, Y, Z, and W components of the quaternion. This must be an array with four elements.</param>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="values"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="values"/> contains more or less than four elements.</exception>
/// <summary>
/// Gets a value indicating whether this instance is equivalent to the identity quaternion.
/// </summary>
/// <value>
/// <c>true</c> if this instance is an identity quaternion; otherwise, <c>false</c>.
/// </value>
/// <summary>
/// Gets a value indicting whether this instance is normalized.
/// </summary>
/// <summary>
/// Gets the angle of the quaternion.
/// </summary>
/// <value>The quaternion's angle.</value>
/// <summary>
/// Gets the axis components of the quaternion.
/// </summary>
/// <value>The axis components of the quaternion.</value>
/// <summary>
/// Calculates the length of the quaternion.
/// </summary>
/// <remarks>
/// <see cref="SlimMath.Quaternion.LengthSquared"/> may be preferred when only the relative length is needed
/// and speed is of the essence.
/// </remarks>
/// <summary>
/// Calculates the squared length of the quaternion.
/// </summary>
/// <remarks>
/// This property may be preferred to <see cref="SlimMath.Quaternion.Length"/> when only a relative length is needed
/// and speed is of the essence.
/// </remarks>
/// <summary>
/// Gets or sets the component at the specified index.
/// </summary>
/// <value>The value of the X, Y, Z, or W component, depending on the index.</value>
/// <param name="index">The index of the component to access. Use 0 for the X component, 1 for the Y component, 2 for the Z component, and 3 for the W component.</param>
/// <returns>The value of the component at the specified index.</returns>
/// <exception cref="System.ArgumentOutOfRangeException">Thrown when the <paramref name="index"/> is out of the range [0, 3].</exception>
/// <summary>
/// Conjugates the quaternion.
/// </summary>
/// <summary>
/// Reverses the direction of a given quaternion.
/// </summary>
/// <summary>
/// Return the inverse of this quaternion.
/// </summary>
/// <summary>
/// Conjugates and renormalizes the quaternion.
/// </summary>
/// <summary>
/// Converts the quaternion into a unit quaternion.
/// </summary>
/// <summary>
/// Exponentiates a quaternion.
/// </summary>
/// <summary>
/// Calculates the natural logarithm of the specified quaternion.
/// </summary>
/// <summary>
/// Creates an array containing the elements of the quaternion.
/// </summary>
/// <returns>A four-element array containing the components of the quaternion.</returns>
/// <summary>
/// Adds two quaternions.
/// </summary>
/// <param name="left">The first quaternion to add.</param>
/// <param name="right">The second quaternion to add.</param>
/// <param name="result">When the method completes, contains the sum of the two quaternions.</param>
/// <summary>
/// Adds two quaternions.
/// </summary>
/// <param name="left">The first quaternion to add.</param>
/// <param name="right">The second quaternion to add.</param>
/// <returns>The sum of the two quaternions.</returns>
/// <summary>
/// Subtracts two quaternions.
/// </summary>
/// <param name="left">The first quaternion to subtract.</param>
/// <param name="right">The second quaternion to subtract.</param>
/// <param name="result">When the method completes, contains the difference of the two quaternions.</param>
/// <summary>
/// Subtracts two quaternions.
/// </summary>
/// <param name="left">The first quaternion to subtract.</param>
/// <param name="right">The second quaternion to subtract.</param>
/// <returns>The difference of the two quaternions.</returns>
/// <summary>
/// Scales a quaternion by the given value.
/// </summary>
/// <param name="value">The quaternion to scale.</param>
/// <param name="scalar">The amount by which to scale the quaternion.</param>
/// <param name="result">When the method completes, contains the scaled quaternion.</param>
/// <summary>
/// Scales a quaternion by the given value.
/// </summary>
/// <param name="value">The quaternion to scale.</param>
/// <param name="scalar">The amount by which to scale the quaternion.</param>
/// <returns>The scaled quaternion.</returns>
/// <summary>
/// Modulates a quaternion by another.
/// </summary>
/// <param name="left">The first quaternion to modulate.</param>
/// <param name="right">The second quaternion to modulate.</param>
/// <param name="result">When the moethod completes, contains the modulated quaternion.</param>
/// <summary>
/// Modulates a quaternion by another.
/// </summary>
/// <param name="left">The first quaternion to modulate.</param>
/// <param name="right">The second quaternion to modulate.</param>
/// <returns>The modulated quaternion.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <param name="result">When the method completes, contains the scaled vector.</param>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Reverses the direction of a given quaternion.
/// </summary>
/// <param name="value">The quaternion to negate.</param>
/// <param name="result">When the method completes, contains a quaternion facing in the opposite direction.</param>
/// <summary>
/// Reverses the direction of a given quaternion.
/// </summary>
/// <param name="value">The quaternion to negate.</param>
/// <returns>A quaternion facing in the opposite direction.</returns>
/// <summary>
/// Returns a <see cref="SlimMath.Quaternion"/> containing the 4D Cartesian coordinates of a point specified in Barycentric coordinates relative to a 2D triangle.
/// </summary>
/// <param name="value1">A <see cref="SlimMath.Quaternion"/> containing the 4D Cartesian coordinates of vertex 1 of the triangle.</param>
/// <param name="value2">A <see cref="SlimMath.Quaternion"/> containing the 4D Cartesian coordinates of vertex 2 of the triangle.</param>
/// <param name="value3">A <see cref="SlimMath.Quaternion"/> containing the 4D Cartesian coordinates of vertex 3 of the triangle.</param>
/// <param name="amount1">Barycentric coordinate b2, which expresses the weighting factor toward vertex 2 (specified in <paramref name="value2"/>).</param>
/// <param name="amount2">Barycentric coordinate b3, which expresses the weighting factor toward vertex 3 (specified in <paramref name="value3"/>).</param>
/// <param name="result">When the method completes, contains a new <see cref="SlimMath.Quaternion"/> containing the 4D Cartesian coordinates of the specified point.</param>
/// <summary>
/// Returns a <see cref="SlimMath.Quaternion"/> containing the 4D Cartesian coordinates of a point specified in Barycentric coordinates relative to a 2D triangle.
/// </summary>
/// <param name="value1">A <see cref="SlimMath.Quaternion"/> containing the 4D Cartesian coordinates of vertex 1 of the triangle.</param>
/// <param name="value2">A <see cref="SlimMath.Quaternion"/> containing the 4D Cartesian coordinates of vertex 2 of the triangle.</param>
/// <param name="value3">A <see cref="SlimMath.Quaternion"/> containing the 4D Cartesian coordinates of vertex 3 of the triangle.</param>
/// <param name="amount1">Barycentric coordinate b2, which expresses the weighting factor toward vertex 2 (specified in <paramref name="value2"/>).</param>
/// <param name="amount2">Barycentric coordinate b3, which expresses the weighting factor toward vertex 3 (specified in <paramref name="value3"/>).</param>
/// <returns>A new <see cref="SlimMath.Quaternion"/> containing the 4D Cartesian coordinates of the specified point.</returns>
/// <summary>
/// Conjugates a quaternion.
/// </summary>
/// <param name="value">The quaternion to conjugate.</param>
/// <param name="result">When the method completes, contains the conjugated quaternion.</param>
/// <summary>
/// Conjugates a quaternion.
/// </summary>
/// <param name="value">The quaternion to conjugate.</param>
/// <returns>The conjugated quaternion.</returns>
/// <summary>
/// Calculates the dot product of two quaternions.
/// </summary>
/// <param name="left">First source quaternion.</param>
/// <param name="right">Second source quaternion.</param>
/// <param name="result">When the method completes, contains the dot product of the two quaternions.</param>
/// <summary>
/// Calculates the dot product of two quaternions.
/// </summary>
/// <param name="left">First source quaternion.</param>
/// <param name="right">Second source quaternion.</param>
/// <returns>The dot product of the two quaternions.</returns>
/// <summary>
/// Exponentiates a quaternion.
/// </summary>
/// <param name="value">The quaternion to exponentiate.</param>
/// <param name="result">When the method completes, contains the exponentiated quaternion.</param>
/// <summary>
/// Exponentiates a quaternion.
/// </summary>
/// <param name="value">The quaternion to exponentiate.</param>
/// <returns>The exponentiated quaternion.</returns>
/// <summary>
/// Conjugates and renormalizes the quaternion.
/// </summary>
/// <param name="value">The quaternion to conjugate and renormalize.</param>
/// <param name="result">When the method completes, contains the conjugated and renormalized quaternion.</param>
/// <summary>
/// Conjugates and renormalizes the quaternion.
/// </summary>
/// <param name="value">The quaternion to conjugate and renormalize.</param>
/// <returns>The conjugated and renormalized quaternion.</returns>
/// <summary>
/// Performs a linear interpolation between two quaternions.
/// </summary>
/// <param name="start">Start quaternion.</param>
/// <param name="end">End quaternion.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <param name="result">When the method completes, contains the linear interpolation of the two quaternions.</param>
/// <remarks>
/// This method performs the linear interpolation based on the following formula.
/// <code>start + (end - start) * amount</code>
/// Passing <paramref name="amount"/> a value of 0 will cause <paramref name="start"/> to be returned; a value of 1 will cause <paramref name="end"/> to be returned. 
/// </remarks>
/// <summary>
/// Performs a linear interpolation between two quaternion.
/// </summary>
/// <param name="start">Start quaternion.</param>
/// <param name="end">End quaternion.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <returns>The linear interpolation of the two quaternions.</returns>
/// <remarks>
/// This method performs the linear interpolation based on the following formula.
/// <code>start + (end - start) * amount</code>
/// Passing <paramref name="amount"/> a value of 0 will cause <paramref name="start"/> to be returned; a value of 1 will cause <paramref name="end"/> to be returned. 
/// </remarks>
/// <summary>
/// Calculates the natural logarithm of the specified quaternion.
/// </summary>
/// <param name="value">The quaternion whose logarithm will be calculated.</param>
/// <param name="result">When the method completes, contains the natural logarithm of the quaternion.</param>
/// <summary>
/// Calculates the natural logarithm of the specified quaternion.
/// </summary>
/// <param name="value">The quaternion whose logarithm will be calculated.</param>
/// <returns>The natural logarithm of the quaternion.</returns>
/// <summary>
/// Converts the quaternion into a unit quaternion.
/// </summary>
/// <param name="value">The quaternion to normalize.</param>
/// <param name="result">When the method completes, contains the normalized quaternion.</param>
/// <summary>
/// Converts the quaternion into a unit quaternion.
/// </summary>
/// <param name="value">The quaternion to normalize.</param>
/// <returns>The normalized quaternion.</returns>
/// <summary>
/// Creates a quaternion given a rotation and an axis.
/// </summary>
/// <param name="axis">The axis of rotation.</param>
/// <param name="angle">The angle of rotation.</param>
/// <param name="result">When the method completes, contains the newly created quaternion.</param>
/// <summary>
/// Creates a quaternion given a rotation and an axis.
/// </summary>
/// <param name="axis">The axis of rotation.</param>
/// <param name="angle">The angle of rotation.</param>
/// <returns>The newly created quaternion.</returns>
/// <summary>
/// Creates a quaternion given a rotation matrix.
/// </summary>
/// <param name="matrix">The rotation matrix.</param>
/// <param name="result">When the method completes, contains the newly created quaternion.</param>
/// <summary>
/// Creates a quaternion given a rotation matrix.
/// </summary>
/// <param name="matrix">The rotation matrix.</param>
/// <returns>The newly created quaternion.</returns>
/// <summary>
/// Creates a quaternion given a yaw, pitch, and roll value.
/// </summary>
/// <param name="yaw">The yaw of rotation.</param>
/// <param name="pitch">The pitch of rotation.</param>
/// <param name="roll">The roll of rotation.</param>
/// <param name="result">When the method completes, contains the newly created quaternion.</param>
/// <summary>
/// Creates a quaternion given a yaw, pitch, and roll value.
/// </summary>
/// <param name="yaw">The yaw of rotation.</param>
/// <param name="pitch">The pitch of rotation.</param>
/// <param name="roll">The roll of rotation.</param>
/// <returns>The newly created quaternion.</returns>
/// <summary>
/// Interpolates between two quaternions, using spherical linear interpolation.
/// </summary>
/// <param name="start">Start quaternion.</param>
/// <param name="end">End quaternion.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <param name="result">When the method completes, contains the spherical linear interpolation of the two quaternions.</param>
/// <summary>
/// Interpolates between two quaternions, using spherical linear interpolation.
/// </summary>
/// <param name="start">Start quaternion.</param>
/// <param name="end">End quaternion.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <returns>The spherical linear interpolation of the two quaternions.</returns>
/// <summary>
/// Interpolates between quaternions, using spherical quadrangle interpolation.
/// </summary>
/// <param name="value1">First source quaternion.</param>
/// <param name="value2">Second source quaternion.</param>
/// <param name="value3">Thrid source quaternion.</param>
/// <param name="value4">Fourth source quaternion.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of interpolation.</param>
/// <param name="result">When the method completes, contains the spherical quadrangle interpolation of the quaternions.</param>
/// <summary>
/// Interpolates between quaternions, using spherical quadrangle interpolation.
/// </summary>
/// <param name="value1">First source quaternion.</param>
/// <param name="value2">Second source quaternion.</param>
/// <param name="value3">Thrid source quaternion.</param>
/// <param name="value4">Fourth source quaternion.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of interpolation.</param>
/// <returns>The spherical quadrangle interpolation of the quaternions.</returns>
/// <summary>
/// Sets up control points for spherical quadrangle interpolation.
/// </summary>
/// <param name="value1">First source quaternion.</param>
/// <param name="value2">Second source quaternion.</param>
/// <param name="value3">Third source quaternion.</param>
/// <param name="value4">Fourth source quaternion.</param>
/// <param name="result1">When the method completes, contains the first control point for spherical quadrangle interpolation.</param>
/// <param name="result2">When the method completes, contains the second control point for spherical quadrangle interpolation.</param>
/// <param name="result3">When the method completes, contains the third control point for spherical quadrangle interpolation.</param>
/// <summary>
/// Sets up control points for spherical quadrangle interpolation.
/// </summary>
/// <param name="value1">First source quaternion.</param>
/// <param name="value2">Second source quaternion.</param>
/// <param name="value3">Third source quaternion.</param>
/// <param name="value4">Fourth source quaternion.</param>
/// <returns>An array of three quaternions that represent control points for spherical quadrangle interpolation.</returns>
/// <summary>
/// Adds two quaternions.
/// </summary>
/// <param name="left">The first quaternion to add.</param>
/// <param name="right">The second quaternion to add.</param>
/// <returns>The sum of the two quaternions.</returns>
/// <summary>
/// Subtracts two quaternions.
/// </summary>
/// <param name="left">The first quaternion to subtract.</param>
/// <param name="right">The second quaternion to subtract.</param>
/// <returns>The difference of the two quaternions.</returns>
/// <summary>
/// Reverses the direction of a given quaternion.
/// </summary>
/// <param name="value">The quaternion to negate.</param>
/// <returns>A quaternion facing in the opposite direction.</returns>
/// <summary>
/// Scales a quaternion by the given value.
/// </summary>
/// <param name="value">The quaternion to scale.</param>
/// <param name="scalar">The amount by which to scale the quaternion.</param>
/// <returns>The scaled quaternion.</returns>
/// <summary>
/// Scales a quaternion by the given value.
/// </summary>
/// <param name="value">The quaternion to scale.</param>
/// <param name="scalar">The amount by which to scale the quaternion.</param>
/// <returns>The scaled quaternion.</returns>
/// <summary>
/// Multiplies a quaternion by another.
/// </summary>
/// <param name="left">The first quaternion to multiply.</param>
/// <param name="right">The second quaternion to multiply.</param>
/// <returns>The multiplied quaternion.</returns>
/// <summary>
/// Multiplies a quaternion by a vector.
/// </summary>
/// <param name="left">The quaternion to multiply.</param>
/// <param name="right">The vector to multiply.</param>
/// <returns>The multiplied quaternion.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Tests for equality between two objects.
/// </summary>
/// <param name="left">The first value to compare.</param>
/// <param name="right">The second value to compare.</param>
/// <returns><c>true</c> if <paramref name="left"/> has the same value as <paramref name="right"/>; otherwise, <c>false</c>.</returns>
/// <summary>
/// Tests for inequality between two objects.
/// </summary>
/// <param name="left">The first value to compare.</param>
/// <param name="right">The second value to compare.</param>
/// <returns><c>true</c> if <paramref name="left"/> has a different value than <paramref name="right"/>; otherwise, <c>false</c>.</returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <param name="format">The format.</param>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <param name="formatProvider">The format provider.</param>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <param name="format">The format.</param>
/// <param name="formatProvider">The format provider.</param>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a hash code for this instance.
/// </summary>
/// <returns>
/// A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
/// </returns>
/// <summary>
/// Determines whether the specified <see cref="SlimMath.Quaternion"/> is equal to this instance.
/// </summary>
/// <param name="other">The <see cref="SlimMath.Quaternion"/> to compare with this instance.</param>
/// <returns>
/// <c>true</c> if the specified <see cref="SlimMath.Quaternion"/> is equal to this instance; otherwise, <c>false</c>.
/// </returns>
/// <summary>
/// Determines whether the specified <see cref="SlimMath.Quaternion"/> is equal to this instance.
/// </summary>
/// <param name="other">The <see cref="SlimMath.Quaternion"/> to compare with this instance.</param>
/// <param name="epsilon">The amount of error allowed.</param>
/// <returns>
/// <c>true</c> if the specified <see cref="SlimMath.Quaternion"/> is equal to this instance; otherwise, <c>false</c>.
/// </returns>
/// <summary>
/// Determines whether the specified <see cref="System.Object"/> is equal to this instance.
/// </summary>
/// <param name="obj">The <see cref="System.Object"/> to compare with this instance.</param>
/// <returns>
/// <c>true</c> if the specified <see cref="System.Object"/> is equal to this instance; otherwise, <c>false</c>.
/// </returns>
/// <summary>
/// Performs an implicit conversion from <see cref="SlimMath.Quaternion"/> to <see cref="SlimDX.Quaternion"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="SlimDX.Quaternion"/> to <see cref="SlimMath.Quaternion"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="SlimMath.Quaternion"/> to <see cref="System.Windows.Media.Media3D.Quaternion"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an explicit conversion from <see cref="System.Windows.Media.Media3D.Quaternion"/> to <see cref="SlimMath.Quaternion"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="SlimMath.Quaternion"/> to <see cref="Microsoft.Xna.Framework.Quaternion"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="Microsoft.Xna.Framework.Quaternion"/> to <see cref="SlimMath.Quaternion"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Math\Vector3.cs
/*
/// <summary>
/// Represents a three dimensional mathematical vector.
/// </summary>
//[TypeConverter(typeof(SlimMath.Design.Vector3Converter))]
/// <summary>
/// The size of the <see cref="Vector3"/> type, in bytes.
/// </summary>
/// <summary>
/// A <see cref="Vector3"/> with all of its components set to zero.
/// </summary>
/// <summary>
/// The X unit <see cref="Vector3"/> (1, 0, 0).
/// </summary>
/// <summary>
/// The Y unit <see cref="Vector3"/> (0, 1, 0).
/// </summary>
/// <summary>
/// The Z unit <see cref="Vector3"/> (0, 0, 1).
/// </summary>
/// <summary>
/// A <see cref="Vector3"/> with all of its components set to one.
/// </summary>
/// <summary>
/// The X component of the vector.
/// </summary>
/// <summary>
/// The Y component of the vector.
/// </summary>
/// <summary>
/// The Z component of the vector.
/// </summary>
/// <summary>
/// Initializes a new instance of the <see cref="Vector3"/> struct.
/// </summary>
/// <param name="value">The value that will be assigned to all components.</param>
/// <summary>
/// Initializes a new instance of the <see cref="Vector3"/> struct.
/// </summary>
/// <param name="x">Initial value for the X component of the vector.</param>
/// <param name="y">Initial value for the Y component of the vector.</param>
/// <param name="z">Initial value for the Z component of the vector.</param>
/// <summary>
/// Initializes a new instance of the <see cref="Vector3"/> struct.
/// </summary>
/// <param name="values">The values to assign to the X, Y, and Z components of the vector. This must be an array with three elements.</param>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="values"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="values"/> contains more or less than three elements.</exception>
/// <summary>
/// Gets a value indicting whether this instance is normalized.
/// </summary>
/// <summary>
/// Calculates the length of the vector.
/// </summary>
/// <remarks>
/// <see cref="Vector3.LengthSquared"/> may be preferred when only the relative length is needed
/// and speed is of the essence.
/// </remarks>
/// <summary>
/// Calculates the squared length of the vector.
/// </summary>
/// <remarks>
/// This property may be preferred to <see cref="Vector3.Length"/> when only a relative length is needed
/// and speed is of the essence.
/// </remarks>
/// <summary>
/// Gets or sets the component at the specified index.
/// </summary>
/// <value>The value of the X, Y, or Z component, depending on the index.</value>
/// <param name="index">The index of the component to access. Use 0 for the X component, 1 for the Y component, and 2 for the Z component.</param>
/// <returns>The value of the component at the specified index.</returns>
/// <exception cref="System.ArgumentOutOfRangeException">Thrown when the <paramref name="index"/> is out of the range [0, 2].</exception>
/// <summary>
/// Converts the vector into a unit vector.
/// </summary>
/// <summary>
/// Reverses the direction of a given vector.
/// </summary>
/// <summary>
/// Takes the absolute value of each component.
/// </summary>
/// <summary>
/// Creates an array containing the elements of the vector.
/// </summary>
/// <returns>A three-element array containing the components of the vector.</returns>
/// <summary>
/// Takes the square root of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the square root of.</param>
/// <param name="result">When the method completes, contains a vector that is the square root of the input vector.</param>
/// <summary>
/// Takes the square root of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the square root of.</param>
/// <returns>A vector that is the square root of the input vector.</returns>
/// <summary>
/// Takes the reciprocal of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the reciprocal of.</param>
/// <param name="result">When the method completes, contains a vector that is the reciprocal of the input vector.</param>
/// <summary>
/// Takes the reciprocal of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the reciprocal of.</param>
/// <returns>A vector that is the reciprocal of the input vector.</returns>
/// <summary>
/// Takes the square root of each component in the vector and than takes the reciprocal of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the square root and recpirocal of.</param>
/// <param name="result">When the method completes, contains a vector that is the square root and reciprocal of the input vector.</param>
/// <summary>
/// Takes the square root of each component in the vector and than takes the reciprocal of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the square root and recpirocal of.</param>
/// <returns>A vector that is the square root and reciprocal of the input vector.</returns>
/// <summary>
/// Takes e raised to the component in the vector.
/// </summary>
/// <param name="value">The value to take e raised to each component of.</param>
/// <param name="result">When the method completes, contains a vector that has e raised to each of the components in the input vector.</param>
/// <summary>
/// Takes e raised to the component in the vector.
/// </summary>
/// <param name="value">The value to take e raised to each component of.</param>
/// <returns>A vector that has e raised to each of the components in the input vector.</returns>
/// <summary>
/// Takes the sine and than the cosine of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the sine and cosine of.</param>
/// <param name="sinResult">When the method completes, contains the sine of each component in the input vector.</param>
/// <param name="cosResult">When the method completes, contains the cpsome pf each component in the input vector.</param>
/// <summary>
/// Takes the sine of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the sine of.</param>
/// <param name="result">When the method completes, a vector that contains the sine of each component in the input vector.</param>
/// <summary>
/// Takes the sine of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the sine of.</param>
/// <returns>A vector that contains the sine of each component in the input vector.</returns>
/// <summary>
/// Takes the cosine of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the cosine of.</param>
/// <param name="result">When the method completes, contains a vector that contains the cosine of each component in the input vector.</param>
/// <summary>
/// Takes the cosine of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the cosine of.</param>
/// <returns>A vector that contains the cosine of each component in the input vector.</returns>
/// <summary>
/// Takes the tangent of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the tangent of.</param>
/// <param name="result">When the method completes, contains a vector that contains the tangent of each component in the input vector.</param>
/// <summary>
/// Takes the tangent of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the tangent of.</param>
/// <returns>A vector that contains the tangent of each component in the input vector.</returns>
/// <summary>
/// Adds two vectors.
/// </summary>
/// <param name="left">The first vector to add.</param>
/// <param name="right">The second vector to add.</param>
/// <param name="result">When the method completes, contains the sum of the two vectors.</param>
/// <summary>
/// Adds two vectors.
/// </summary>
/// <param name="left">The first vector to add.</param>
/// <param name="right">The second vector to add.</param>
/// <returns>The sum of the two vectors.</returns>
/// <summary>
/// Subtracts two vectors.
/// </summary>
/// <param name="left">The first vector to subtract.</param>
/// <param name="right">The second vector to subtract.</param>
/// <param name="result">When the method completes, contains the difference of the two vectors.</param>
/// <summary>
/// Subtracts two vectors.
/// </summary>
/// <param name="left">The first vector to subtract.</param>
/// <param name="right">The second vector to subtract.</param>
/// <returns>The difference of the two vectors.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <param name="result">When the method completes, contains the scaled vector.</param>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Modulates a vector with another by performing component-wise multiplication.
/// </summary>
/// <param name="left">The first vector to modulate.</param>
/// <param name="right">The second vector to modulate.</param>
/// <param name="result">When the method completes, contains the modulated vector.</param>
/// <summary>
/// Modulates a vector with another by performing component-wise multiplication.
/// </summary>
/// <param name="left">The first vector to modulate.</param>
/// <param name="right">The second vector to modulate.</param>
/// <returns>The modulated vector.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <param name="result">When the method completes, contains the scaled vector.</param>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Reverses the direction of a given vector.
/// </summary>
/// <param name="value">The vector to negate.</param>
/// <param name="result">When the method completes, contains a vector facing in the opposite direction.</param>
/// <summary>
/// Reverses the direction of a given vector.
/// </summary>
/// <param name="value">The vector to negate.</param>
/// <returns>A vector facing in the opposite direction.</returns>
/// <summary>
/// Takes the absolute value of each component.
/// </summary>
/// <param name="value">The vector to take the absolute value of.</param>
/// <param name="result">When the method completes, contains a vector that has all positive components.</param>
/// <summary>
/// Takes the absolute value of each component.
/// </summary>
/// <param name="value">The vector to take the absolute value of.</param>
/// <returns>A vector that has all positive components.</returns>
/// <summary>
/// Returns a <see cref="Vector3"/> containing the 3D Cartesian coordinates of a point specified in Barycentric coordinates relative to a 3D triangle.
/// </summary>
/// <param name="value1">A <see cref="Vector3"/> containing the 3D Cartesian coordinates of vertex 1 of the triangle.</param>
/// <param name="value2">A <see cref="Vector3"/> containing the 3D Cartesian coordinates of vertex 2 of the triangle.</param>
/// <param name="value3">A <see cref="Vector3"/> containing the 3D Cartesian coordinates of vertex 3 of the triangle.</param>
/// <param name="amount1">Barycentric coordinate b2, which expresses the weighting factor toward vertex 2 (specified in <paramref name="value2"/>).</param>
/// <param name="amount2">Barycentric coordinate b3, which expresses the weighting factor toward vertex 3 (specified in <paramref name="value3"/>).</param>
/// <param name="result">When the method completes, contains the 3D Cartesian coordinates of the specified point.</param>
/// <summary>
/// Returns a <see cref="Vector3"/> containing the 3D Cartesian coordinates of a point specified in Barycentric coordinates relative to a 3D triangle.
/// </summary>
/// <param name="value1">A <see cref="Vector3"/> containing the 3D Cartesian coordinates of vertex 1 of the triangle.</param>
/// <param name="value2">A <see cref="Vector3"/> containing the 3D Cartesian coordinates of vertex 2 of the triangle.</param>
/// <param name="value3">A <see cref="Vector3"/> containing the 3D Cartesian coordinates of vertex 3 of the triangle.</param>
/// <param name="amount1">Barycentric coordinate b2, which expresses the weighting factor toward vertex 2 (specified in <paramref name="value2"/>).</param>
/// <param name="amount2">Barycentric coordinate b3, which expresses the weighting factor toward vertex 3 (specified in <paramref name="value3"/>).</param>
/// <returns>A new <see cref="Vector3"/> containing the 3D Cartesian coordinates of the specified point.</returns>
/// <summary>
/// Restricts a value to be within a specified range.
/// </summary>
/// <param name="value">The value to clamp.</param>
/// <param name="min">The minimum value.</param>
/// <param name="max">The maximum value.</param>
/// <param name="result">When the method completes, contains the clamped value.</param>
/// <summary>
/// Restricts a value to be within a specified range.
/// </summary>
/// <param name="value">The value to clamp.</param>
/// <param name="min">The minimum value.</param>
/// <param name="max">The maximum value.</param>
/// <returns>The clamped value.</returns>
/// <summary>
/// Calculates the cross product of two vectors.
/// </summary>
/// <param name="left">First source vector.</param>
/// <param name="right">Second source vector.</param>
/// <param name="result">When the method completes, contains the cross product of the two vectors.</param>
/// <summary>
/// Calculates the cross product of two vectors.
/// </summary>
/// <param name="left">First source vector.</param>
/// <param name="right">Second source vector.</param>
/// <returns>The cross product of the two vectors.</returns>
/// <summary>
/// Calculates the cross product of two vectors.
/// </summary>
/// <param name="v">Second source vector.</param>
/// <returns>The cross product of the two vectors.</returns>
/// <summary>
/// Calculates the tripple cross product of three vectors.
/// </summary>
/// <param name="value1">First source vector.</param>
/// <param name="value2">Second source vector.</param>
/// <param name="value3">Third source vector.</param>
/// <param name="result">When the method completes, contains the triple cross product of the three vectors.</param>
/// <summary>
/// Calculates the tripple cross product of three vectors.
/// </summary>
/// <param name="value1">First source vector.</param>
/// <param name="value2">Second source vector.</param>
/// <param name="value3">Third source vector.</param>
/// <returns>The tripple cross product of the three vectors.</returns>
/// <summary>
/// Calculates the distance between two vectors.
/// </summary>
/// <param name="value1">The first vector.</param>
/// <param name="value2">The second vector.</param>
/// <param name="result">When the method completes, contains the distance between the two vectors.</param>
/// <remarks>
/// <see cref="Vector3.DistanceSquared(ref Vector3, ref Vector3, out float)"/> may be preferred when only the relative distance is needed
/// and speed is of the essence.
/// </remarks>
/// <summary>
/// Calculates the distance between two vectors.
/// </summary>
/// <param name="value1">The first vector.</param>
/// <param name="value2">The second vector.</param>
/// <returns>The distance between the two vectors.</returns>
/// <remarks>
/// <see cref="Vector3.DistanceSquared(Vector3, Vector3)"/> may be preferred when only the relative distance is needed
/// and speed is of the essence.
/// </remarks>
/// <summary>
/// Calculates the squared distance between two vectors.
/// </summary>
/// <param name="value1">The first vector.</param>
/// <param name="value2">The second vector.</param>
/// <param name="result">When the method completes, contains the squared distance between the two vectors.</param>
/// <remarks>Distance squared is the value before taking the square root. 
/// Distance squared can often be used in place of distance if relative comparisons are being made. 
/// For example, consider three points A, B, and C. To determine whether B or C is further from A, 
/// compare the distance between A and B to the distance between A and C. Calculating the two distances 
/// involves two square roots, which are computationally expensive. However, using distance squared 
/// provides the same information and avoids calculating two square roots.
/// </remarks>
/// <summary>
/// Calculates the squared distance between two vectors.
/// </summary>
/// <param name="value1">The first vector.</param>
/// <param name="value2">The second vector.</param>
/// <returns>The squared distance between the two vectors.</returns>
/// <remarks>Distance squared is the value before taking the square root. 
/// Distance squared can often be used in place of distance if relative comparisons are being made. 
/// For example, consider three points A, B, and C. To determine whether B or C is further from A, 
/// compare the distance between A and B to the distance between A and C. Calculating the two distances 
/// involves two square roots, which are computationally expensive. However, using distance squared 
/// provides the same information and avoids calculating two square roots.
/// </remarks>
/// <summary>
/// Calculates the dot product of two vectors.
/// </summary>
/// <param name="left">First source vector.</param>
/// <param name="right">Second source vector.</param>
/// <param name="result">When the method completes, contains the dot product of the two vectors.</param>
/// <summary>
/// Calculates the dot product of two vectors.
/// </summary>
/// <param name="left">First source vector.</param>
/// <param name="right">Second source vector.</param>
/// <returns>The dot product of the two vectors.</returns>
/// <summary>
/// Calculates the dot product of two vectors.
/// </summary>
/// <param name="v">Second source vector.</param>
/// <param name="result">When the method completes, contains the dot product of the two vectors.</param>
/// <summary>
/// Calculates the dot product of two vectors.
/// </summary>
/// <param name="v">Second source vector.</param>
/// <returns>The dot product of the two vectors.</returns>
/// <summary>
/// Converts the vector into a unit vector.
/// </summary>
/// <param name="value">The vector to normalize.</param>
/// <param name="result">When the method completes, contains the normalized vector.</param>
/// <summary>
/// Converts the vector into a unit vector.
/// </summary>
/// <param name="value">The vector to normalize.</param>
/// <returns>The normalized vector.</returns>
/// <summary>
/// Performs a linear interpolation between two vectors.
/// </summary>
/// <param name="start">Start vector.</param>
/// <param name="end">End vector.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <param name="result">When the method completes, contains the linear interpolation of the two vectors.</param>
/// <remarks>
/// This method performs the linear interpolation based on the following formula.
/// <code>start + (end - start) * amount</code>
/// Passing <paramref name="amount"/> a value of 0 will cause <paramref name="start"/> to be returned; a value of 1 will cause <paramref name="end"/> to be returned. 
/// </remarks>
/// <summary>
/// Performs a linear interpolation between two vectors.
/// </summary>
/// <param name="start">Start vector.</param>
/// <param name="end">End vector.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <returns>The linear interpolation of the two vectors.</returns>
/// <remarks>
/// This method performs the linear interpolation based on the following formula.
/// <code>start + (end - start) * amount</code>
/// Passing <paramref name="amount"/> a value of 0 will cause <paramref name="start"/> to be returned; a value of 1 will cause <paramref name="end"/> to be returned. 
/// </remarks>
/// <summary>
/// Performs a cubic interpolation between two vectors.
/// </summary>
/// <param name="start">Start vector.</param>
/// <param name="end">End vector.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <param name="result">When the method completes, contains the cubic interpolation of the two vectors.</param>
/// <summary>
/// Performs a cubic interpolation between two vectors.
/// </summary>
/// <param name="start">Start vector.</param>
/// <param name="end">End vector.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <returns>The cubic interpolation of the two vectors.</returns>
/// <summary>
/// Performs a Hermite spline interpolation.
/// </summary>
/// <param name="value1">First source position vector.</param>
/// <param name="tangent1">First source tangent vector.</param>
/// <param name="value2">Second source position vector.</param>
/// <param name="tangent2">Second source tangent vector.</param>
/// <param name="amount">Weighting factor.</param>
/// <param name="result">When the method completes, contains the result of the Hermite spline interpolation.</param>
/// <summary>
/// Performs a Hermite spline interpolation.
/// </summary>
/// <param name="value1">First source position vector.</param>
/// <param name="tangent1">First source tangent vector.</param>
/// <param name="value2">Second source position vector.</param>
/// <param name="tangent2">Second source tangent vector.</param>
/// <param name="amount">Weighting factor.</param>
/// <returns>The result of the Hermite spline interpolation.</returns>
/// <summary>
/// Performs a Catmull-Rom interpolation using the specified positions.
/// </summary>
/// <param name="value1">The first position in the interpolation.</param>
/// <param name="value2">The second position in the interpolation.</param>
/// <param name="value3">The third position in the interpolation.</param>
/// <param name="value4">The fourth position in the interpolation.</param>
/// <param name="amount">Weighting factor.</param>
/// <param name="result">When the method completes, contains the result of the Catmull-Rom interpolation.</param>
/// <summary>
/// Performs a Catmull-Rom interpolation using the specified positions.
/// </summary>
/// <param name="value1">The first position in the interpolation.</param>
/// <param name="value2">The second position in the interpolation.</param>
/// <param name="value3">The third position in the interpolation.</param>
/// <param name="value4">The fourth position in the interpolation.</param>
/// <param name="amount">Weighting factor.</param>
/// <returns>A vector that is the result of the Catmull-Rom interpolation.</returns>
/// <summary>
/// Returns a vector containing the largest components of the specified vectors.
/// </summary>
/// <param name="value1">The first source vector.</param>
/// <param name="value2">The second source vector.</param>
/// <param name="result">When the method completes, contains an new vector composed of the largest components of the source vectors.</param>
/// <summary>
/// Returns a vector containing the largest components of the specified vectors.
/// </summary>
/// <param name="value1">The first source vector.</param>
/// <param name="value2">The second source vector.</param>
/// <returns>A vector containing the largest components of the source vectors.</returns>
/// <summary>
/// Returns a vector containing the smallest components of the specified vectors.
/// </summary>
/// <param name="value1">The first source vector.</param>
/// <param name="value2">The second source vector.</param>
/// <param name="result">When the method completes, contains an new vector composed of the smallest components of the source vectors.</param>
/// <summary>
/// Returns a vector containing the smallest components of the specified vectors.
/// </summary>
/// <param name="value1">The first source vector.</param>
/// <param name="value2">The second source vector.</param>
/// <returns>A vector containing the smallest components of the source vectors.</returns>
/// <summary>
/// Projects a 3D vector from object space into screen space. 
/// </summary>
/// <param name="vector">The vector to project.</param>
/// <param name="x">The X position of the viewport.</param>
/// <param name="y">The Y position of the viewport.</param>
/// <param name="width">The width of the viewport.</param>
/// <param name="height">The height of the viewport.</param>
/// <param name="minZ">The minimum depth of the viewport.</param>
/// <param name="maxZ">The maximum depth of the viewport.</param>
/// <param name="worldViewProjection">The combined world-view-projection matrix.</param>
/// <param name="result">When the method completes, contains the vector in screen space.</param>
/// <summary>
/// Projects a 3D vector from object space into screen space. 
/// </summary>
/// <param name="vector">The vector to project.</param>
/// <param name="x">The X position of the viewport.</param>
/// <param name="y">The Y position of the viewport.</param>
/// <param name="width">The width of the viewport.</param>
/// <param name="height">The height of the viewport.</param>
/// <param name="minZ">The minimum depth of the viewport.</param>
/// <param name="maxZ">The maximum depth of the viewport.</param>
/// <param name="worldViewProjection">The combined world-view-projection matrix.</param>
/// <returns>The vector in screen space.</returns>
/// <summary>
/// Projects a 3D vector from screen space into object space. 
/// </summary>
/// <param name="vector">The vector to project.</param>
/// <param name="x">The X position of the viewport.</param>
/// <param name="y">The Y position of the viewport.</param>
/// <param name="width">The width of the viewport.</param>
/// <param name="height">The height of the viewport.</param>
/// <param name="minZ">The minimum depth of the viewport.</param>
/// <param name="maxZ">The maximum depth of the viewport.</param>
/// <param name="worldViewProjection">The combined world-view-projection matrix.</param>
/// <param name="result">When the method completes, contains the vector in object space.</param>
/// <summary>
/// Projects a 3D vector from screen space into object space. 
/// </summary>
/// <param name="vector">The vector to project.</param>
/// <param name="x">The X position of the viewport.</param>
/// <param name="y">The Y position of the viewport.</param>
/// <param name="width">The width of the viewport.</param>
/// <param name="height">The height of the viewport.</param>
/// <param name="minZ">The minimum depth of the viewport.</param>
/// <param name="maxZ">The maximum depth of the viewport.</param>
/// <param name="worldViewProjection">The combined world-view-projection matrix.</param>
/// <returns>The vector in object space.</returns>
/// <summary>
/// Returns the reflection of a vector off a surface that has the specified normal. 
/// </summary>
/// <param name="vector">The source vector.</param>
/// <param name="normal">Normal of the surface.</param>
/// <param name="result">When the method completes, contains the reflected vector.</param>
/// <remarks>Reflect only gives the direction of a reflection off a surface, it does not determine 
/// whether the original vector was close enough to the surface to hit it.</remarks>
/// <summary>
/// Returns the reflection of a vector off a surface that has the specified normal. 
/// </summary>
/// <param name="vector">The source vector.</param>
/// <param name="normal">Normal of the surface.</param>
/// <returns>The reflected vector.</returns>
/// <remarks>Reflect only gives the direction of a reflection off a surface, it does not determine 
/// whether the original vector was close enough to the surface to hit it.</remarks>
/// <summary>
/// Returns the fraction of a vector off a surface that has the specified normal and index.
/// </summary>
/// <param name="vector">The source vector.</param>
/// <param name="normal">Normal of the surface.</param>
/// <param name="index">Index of refraction.</param>
/// <param name="result">When the method completes, contains the refracted vector.</param>
/// <summary>
/// Returns the fraction of a vector off a surface that has the specified normal and index.
/// </summary>
/// <param name="vector">The source vector.</param>
/// <param name="normal">Normal of the surface.</param>
/// <param name="index">Index of refraction.</param>
/// <returns>The refracted vector.</returns>
/// <summary>
/// Orthogonalizes a list of vectors.
/// </summary>
/// <param name="destination">The list of orthogonalized vectors.</param>
/// <param name="source">The list of vectors to orthogonalize.</param>
/// <remarks>
/// <para>Orthogonalization is the process of making all vectors orthogonal to each other. This
/// means that any given vector in the list will be orthogonal to any other given vector in the
/// list.</para>
/// <para>Because this method uses the modified Gram-Schmidt process, the resulting vectors
/// tend to be numerically unstable. The numeric stability decreases according to the vectors
/// position in the list so that the first vector is the most stable and the last vector is the
/// least stable.</para>
/// </remarks>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="source"/> or <paramref name="destination"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="destination"/> is shorter in length than <paramref name="source"/>.</exception>
//Uses the modified Gram-Schmidt process.
//q1 = m1
//q2 = m2 - ((q1 ⋅ m2) / (q1 ⋅ q1)) * q1
//q3 = m3 - ((q1 ⋅ m3) / (q1 ⋅ q1)) * q1 - ((q2 ⋅ m3) / (q2 ⋅ q2)) * q2
//q4 = m4 - ((q1 ⋅ m4) / (q1 ⋅ q1)) * q1 - ((q2 ⋅ m4) / (q2 ⋅ q2)) * q2 - ((q3 ⋅ m4) / (q3 ⋅ q3)) * q3
//q5 = ...
/// <summary>
/// Orthonormalizes a list of vectors.
/// </summary>
/// <param name="destination">The list of orthonormalized vectors.</param>
/// <param name="source">The list of vectors to orthonormalize.</param>
/// <remarks>
/// <para>Orthonormalization is the process of making all vectors orthogonal to each
/// other and making all vectors of unit length. This means that any given vector will
/// be orthogonal to any other given vector in the list.</para>
/// <para>Because this method uses the modified Gram-Schmidt process, the resulting vectors
/// tend to be numerically unstable. The numeric stability decreases according to the vectors
/// position in the list so that the first vector is the most stable and the last vector is the
/// least stable.</para>
/// </remarks>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="source"/> or <paramref name="destination"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="destination"/> is shorter in length than <paramref name="source"/>.</exception>
//Uses the modified Gram-Schmidt process.
//Because we are making unit vectors, we can optimize the math for orthogonalization
//and simplify the projection operation to remove the division.
//q1 = m1 / |m1|
//q2 = (m2 - (q1 ⋅ m2) * q1) / |m2 - (q1 ⋅ m2) * q1|
//q3 = (m3 - (q1 ⋅ m3) * q1 - (q2 ⋅ m3) * q2) / |m3 - (q1 ⋅ m3) * q1 - (q2 ⋅ m3) * q2|
//q4 = (m4 - (q1 ⋅ m4) * q1 - (q2 ⋅ m4) * q2 - (q3 ⋅ m4) * q3) / |m4 - (q1 ⋅ m4) * q1 - (q2 ⋅ m4) * q2 - (q3 ⋅ m4) * q3|
//q5 = ...
/// <summary>
/// Transforms a 3D vector by the given <see cref="Quaternion"/> rotation.
/// </summary>
/// <param name="vector">The vector to rotate.</param>
/// <param name="rotation">The <see cref="Quaternion"/> rotation to apply.</param>
/// <param name="result">When the method completes, contains the transformed <see cref="Vector4"/>.</param>
/// <summary>
/// Transforms a 3D vector by the given <see cref="Quaternion"/> rotation.
/// </summary>
/// <param name="vector">The vector to rotate.</param>
/// <param name="rotation">The <see cref="Quaternion"/> rotation to apply.</param>
/// <returns>The transformed <see cref="Vector4"/>.</returns>
/// <summary>
/// Transforms an array of vectors by the given <see cref="Quaternion"/> rotation.
/// </summary>
/// <param name="source">The array of vectors to transform.</param>
/// <param name="rotation">The <see cref="Quaternion"/> rotation to apply.</param>
/// <param name="destination">The array for which the transformed vectors are stored.
/// This array may be the same array as <paramref name="source"/>.</param>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="source"/> or <paramref name="destination"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="destination"/> is shorter in length than <paramref name="source"/>.</exception>
/// <summary>
/// Transforms a 3D vector by the given <see cref="Matrix"/>.
/// </summary>
/// <param name="vector">The source vector.</param>
/// <param name="transform">The transformation <see cref="Matrix"/>.</param>
/// <param name="result">When the method completes, contains the transformed <see cref="Vector4"/>.</param>
/// <summary>
/// Transforms a 3D vector by the given <see cref="Matrix"/>.
/// </summary>
/// <param name="vector">The source vector.</param>
/// <param name="transform">The transformation <see cref="Matrix"/>.</param>
/// <returns>The transformed <see cref="Vector4"/>.</returns>
/// <summary>
/// Transforms an array of 3D vectors by the given <see cref="Matrix"/>.
/// </summary>
/// <param name="source">The array of vectors to transform.</param>
/// <param name="transform">The transformation <see cref="Matrix"/>.</param>
/// <param name="destination">The array for which the transformed vectors are stored.</param>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="source"/> or <paramref name="destination"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="destination"/> is shorter in length than <paramref name="source"/>.</exception>
/// <summary>
/// Performs a coordinate transformation using the given <see cref="Matrix"/>.
/// </summary>
/// <param name="coordinate">The coordinate vector to transform.</param>
/// <param name="transform">The transformation <see cref="Matrix"/>.</param>
/// <param name="result">When the method completes, contains the transformed coordinates.</param>
/// <remarks>
/// A coordinate transform performs the transformation with the assumption that the w component
/// is one. The four dimensional vector obtained from the transformation operation has each
/// component in the vector divided by the w component. This forces the wcomponent to be one and
/// therefore makes the vector homogeneous. The homogeneous vector is often prefered when working
/// with coordinates as the w component can safely be ignored.
/// </remarks>
/// <summary>
/// Performs a coordinate transformation using the given <see cref="Matrix"/>.
/// </summary>
/// <param name="coordinate">The coordinate vector to transform.</param>
/// <param name="transform">The transformation <see cref="Matrix"/>.</param>
/// <returns>The transformed coordinates.</returns>
/// <remarks>
/// A coordinate transform performs the transformation with the assumption that the w component
/// is one. The four dimensional vector obtained from the transformation operation has each
/// component in the vector divided by the w component. This forces the wcomponent to be one and
/// therefore makes the vector homogeneous. The homogeneous vector is often prefered when working
/// with coordinates as the w component can safely be ignored.
/// </remarks>
/// <summary>
/// Performs a coordinate transformation on an array of vectors using the given <see cref="Matrix"/>.
/// </summary>
/// <param name="source">The array of coordinate vectors to trasnform.</param>
/// <param name="transform">The transformation <see cref="Matrix"/>.</param>
/// <param name="destination">The array for which the transformed vectors are stored.
/// This array may be the same array as <paramref name="source"/>.</param>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="source"/> or <paramref name="destination"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="destination"/> is shorter in length than <paramref name="source"/>.</exception>
/// <remarks>
/// A coordinate transform performs the transformation with the assumption that the w component
/// is one. The four dimensional vector obtained from the transformation operation has each
/// component in the vector divided by the w component. This forces the wcomponent to be one and
/// therefore makes the vector homogeneous. The homogeneous vector is often prefered when working
/// with coordinates as the w component can safely be ignored.
/// </remarks>
/// <summary>
/// Performs a normal transformation using the given <see cref="Matrix"/>.
/// </summary>
/// <param name="normal">The normal vector to transform.</param>
/// <param name="transform">The transformation <see cref="Matrix"/>.</param>
/// <param name="result">When the method completes, contains the transformed normal.</param>
/// <remarks>
/// A normal transform performs the transformation with the assumption that the w component
/// is zero. This causes the fourth row and fourth collumn of the matrix to be unused. The
/// end result is a vector that is not translated, but all other transformation properties
/// apply. This is often prefered for normal vectors as normals purely represent direction
/// rather than location because normal vectors should not be translated.
/// </remarks>
/// <summary>
/// Performs a normal transformation using the given <see cref="Matrix"/>.
/// </summary>
/// <param name="normal">The normal vector to transform.</param>
/// <param name="transform">The transformation <see cref="Matrix"/>.</param>
/// <returns>The transformed normal.</returns>
/// <remarks>
/// A normal transform performs the transformation with the assumption that the w component
/// is zero. This causes the fourth row and fourth collumn of the matrix to be unused. The
/// end result is a vector that is not translated, but all other transformation properties
/// apply. This is often prefered for normal vectors as normals purely represent direction
/// rather than location because normal vectors should not be translated.
/// </remarks>
/// <summary>
/// Performs a normal transformation on an array of vectors using the given <see cref="Matrix"/>.
/// </summary>
/// <param name="source">The array of normal vectors to transform.</param>
/// <param name="transform">The transformation <see cref="Matrix"/>.</param>
/// <param name="destination">The array for which the transformed vectors are stored.
/// This array may be the same array as <paramref name="source"/>.</param>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="source"/> or <paramref name="destination"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="destination"/> is shorter in length than <paramref name="source"/>.</exception>
/// <remarks>
/// A normal transform performs the transformation with the assumption that the w component
/// is zero. This causes the fourth row and fourth collumn of the matrix to be unused. The
/// end result is a vector that is not translated, but all other transformation properties
/// apply. This is often prefered for normal vectors as normals purely represent direction
/// rather than location because normal vectors should not be translated.
/// </remarks>
/// <summary>
/// Adds two vectors.
/// </summary>
/// <param name="left">The first vector to add.</param>
/// <param name="right">The second vector to add.</param>
/// <returns>The sum of the two vectors.</returns>
/// <summary>
/// Assert a vector (return it unchanged).
/// </summary>
/// <param name="value">The vector to assert (unchange).</param>
/// <returns>The asserted (unchanged) vector.</returns>
/// <summary>
/// Subtracts two vectors.
/// </summary>
/// <param name="left">The first vector to subtract.</param>
/// <param name="right">The second vector to subtract.</param>
/// <returns>The difference of the two vectors.</returns>
/// <summary>
/// Reverses the direction of a given vector.
/// </summary>
/// <param name="value">The vector to negate.</param>
/// <returns>A vector facing in the opposite direction.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="left">The vector to scale.</param>
/// <param name="right">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="left">The vector to scale.</param>
/// <param name="right">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Tests for equality between two objects.
/// </summary>
/// <param name="left">The first value to compare.</param>
/// <param name="right">The second value to compare.</param>
/// <returns><c>true</c> if <paramref name="left"/> has the same value as <paramref name="right"/>; otherwise, <c>false</c>.</returns>
/// <summary>
/// Tests for inequality between two objects.
/// </summary>
/// <param name="left">The first value to compare.</param>
/// <param name="right">The second value to compare.</param>
/// <returns><c>true</c> if <paramref name="left"/> has a different value than <paramref name="right"/>; otherwise, <c>false</c>.</returns>
/// <summary>
/// Performs an explicit conversion from <see cref="Vector3"/> to <see cref="Vector4"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <param name="format">The format.</param>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <param name="formatProvider">The format provider.</param>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <param name="format">The format.</param>
/// <param name="formatProvider">The format provider.</param>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a hash code for this instance.
/// </summary>
/// <returns>
/// A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
/// </returns>
/// <summary>
/// Determines whether the specified <see cref="Vector3"/> is equal to this instance.
/// </summary>
/// <param name="other">The <see cref="Vector3"/> to compare with this instance.</param>
/// <returns>
/// <c>true</c> if the specified <see cref="Vector3"/> is equal to this instance; otherwise, <c>false</c>.
/// </returns>
/// <summary>
/// Determines whether the specified <see cref="Vector3"/> is equal to this instance.
/// </summary>
/// <param name="other">The <see cref="Vector3"/> to compare with this instance.</param>
/// <param name="epsilon">The amount of error allowed.</param>
/// <returns>
/// <c>true</c> if the specified <see cref="Vector3"/> is equal to this instance; otherwise, <c>false</c>.
/// </returns>
/// <summary>
/// Determines whether the specified <see cref="System.Object"/> is equal to this instance.
/// </summary>
/// <param name="obj">The <see cref="System.Object"/> to compare with this instance.</param>
/// <returns>
/// <c>true</c> if the specified <see cref="System.Object"/> is equal to this instance; otherwise, <c>false</c>.
/// </returns>
/// <summary>
/// Performs an implicit conversion from <see cref="Vector3"/> to <see cref="SlimDX.Vector3"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="SlimDX.Vector3"/> to <see cref="Vector3"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="Vector3"/> to <see cref="System.Windows.Media.Media3D.Vector3D"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an explicit conversion from <see cref="System.Windows.Media.Media3D.Vector3D"/> to <see cref="Vector3"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="Vector3"/> to <see cref="Microsoft.Xna.Framework.Vector3"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="Microsoft.Xna.Framework.Vector3"/> to <see cref="Vector3"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\Math\Vector4.cs
/*
/// <summary>
/// Represents a four dimensional mathematical vector.
/// </summary>
//[TypeConverter(typeof(SlimMath.Design.Vector4Converter))]
/// <summary>
/// The size of the <see cref="SlimMath.Vector4"/> type, in bytes.
/// </summary>
/// <summary>
/// A <see cref="SlimMath.Vector4"/> with all of its components set to zero.
/// </summary>
/// <summary>
/// The X unit <see cref="SlimMath.Vector4"/> (1, 0, 0, 0).
/// </summary>
/// <summary>
/// The Y unit <see cref="SlimMath.Vector4"/> (0, 1, 0, 0).
/// </summary>
/// <summary>
/// The Z unit <see cref="SlimMath.Vector4"/> (0, 0, 1, 0).
/// </summary>
/// <summary>
/// The W unit <see cref="SlimMath.Vector4"/> (0, 0, 0, 1).
/// </summary>
/// <summary>
/// A <see cref="SlimMath.Vector4"/> with all of its components set to one.
/// </summary>
/// <summary>
/// The X component of the vector.
/// </summary>
/// <summary>
/// The Y component of the vector.
/// </summary>
/// <summary>
/// The Z component of the vector.
/// </summary>
/// <summary>
/// The W component of the vector.
/// </summary>
/// <summary>
/// Initializes a new instance of the <see cref="SlimMath.Vector4"/> struct.
/// </summary>
/// <param name="value">The value that will be assigned to all components.</param>
/// <summary>
/// Initializes a new instance of the <see cref="SlimMath.Vector4"/> struct.
/// </summary>
/// <param name="x">Initial value for the X component of the vector.</param>
/// <param name="y">Initial value for the Y component of the vector.</param>
/// <param name="z">Initial value for the Z component of the vector.</param>
/// <param name="w">Initial value for the W component of the vector.</param>
/// <summary>
/// Initializes a new instance of the <see cref="SlimMath.Vector4"/> struct.
/// </summary>
/// <param name="value">A vector containing the values with which to initialize the X, Y, and Z components.</param>
/// <param name="w">Initial value for the W component of the vector.</param>
/// <summary>
/// Initializes a new instance of the <see cref="SlimMath.Vector4"/> struct.
/// </summary>
/// <param name="values">The values to assign to the X, Y, Z, and W components of the vector. This must be an array with four elements.</param>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="values"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="values"/> contains more or less than four elements.</exception>
/// <summary>
/// Gets a value indicting whether this instance is normalized.
/// </summary>
/// <summary>
/// Calculates the length of the vector.
/// </summary>
/// <remarks>
/// <see cref="SlimMath.Vector4.LengthSquared"/> may be preferred when only the relative length is needed
/// and speed is of the essence.
/// </remarks>
/// <summary>
/// Calculates the squared length of the vector.
/// </summary>
/// <remarks>
/// This property may be preferred to <see cref="SlimMath.Vector4.Length"/> when only a relative length is needed
/// and speed is of the essence.
/// </remarks>
/// <summary>
/// Gets or sets the component at the specified index.
/// </summary>
/// <value>The value of the X, Y, Z, or W component, depending on the index.</value>
/// <param name="index">The index of the component to access. Use 0 for the X component, 1 for the Y component, 2 for the Z component, and 3 for the W component.</param>
/// <returns>The value of the component at the specified index.</returns>
/// <exception cref="System.ArgumentOutOfRangeException">Thrown when the <paramref name="index"/> is out of the range [0, 3].</exception>
/// <summary>
/// Converts the vector into a unit vector.
/// </summary>
/// <summary>
/// Reverses the direction of a given vector.
/// </summary>
/// <summary>
/// Takes the absolute value of each component.
/// </summary>
/// <summary>
/// Creates an array containing the elements of the vector.
/// </summary>
/// <returns>A four-element array containing the components of the vector.</returns>
/// <summary>
/// Takes the square root of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the square root of.</param>
/// <param name="result">When the method completes, contains a vector that is the square root of the input vector.</param>
/// <summary>
/// Takes the square root of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the square root of.</param>
/// <returns>A vector that is the square root of the input vector.</returns>
/// <summary>
/// Takes the reciprocal of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the reciprocal of.</param>
/// <param name="result">When the method completes, contains a vector that is the reciprocal of the input vector.</param>
/// <summary>
/// Takes the reciprocal of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the reciprocal of.</param>
/// <returns>A vector that is the reciprocal of the input vector.</returns>
/// <summary>
/// Takes the square root of each component in the vector and than takes the reciprocal of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the square root and recpirocal of.</param>
/// <param name="result">When the method completes, contains a vector that is the square root and reciprocal of the input vector.</param>
/// <summary>
/// Takes the square root of each component in the vector and than takes the reciprocal of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the square root and recpirocal of.</param>
/// <returns>A vector that is the square root and reciprocal of the input vector.</returns>
/// <summary>
/// Takes e raised to the component in the vector.
/// </summary>
/// <param name="value">The value to take e raised to each component of.</param>
/// <param name="result">When the method completes, contains a vector that has e raised to each of the components in the input vector.</param>
/// <summary>
/// Takes e raised to the component in the vector.
/// </summary>
/// <param name="value">The value to take e raised to each component of.</param>
/// <returns>A vector that has e raised to each of the components in the input vector.</returns>
/// <summary>
/// Takes the sine and than the cosine of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the sine and cosine of.</param>
/// <param name="sinResult">When the method completes, contains the sine of each component in the input vector.</param>
/// <param name="cosResult">When the method completes, contains the cpsome pf each component in the input vector.</param>
/// <summary>
/// Takes the sine of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the sine of.</param>
/// <param name="result">When the method completes, a vector that contains the sine of each component in the input vector.</param>
/// <summary>
/// Takes the sine of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the sine of.</param>
/// <returns>A vector that contains the sine of each component in the input vector.</returns>
/// <summary>
/// Takes the cosine of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the cosine of.</param>
/// <param name="result">When the method completes, contains a vector that contains the cosine of each component in the input vector.</param>
/// <summary>
/// Takes the cosine of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the cosine of.</param>
/// <returns>A vector that contains the cosine of each component in the input vector.</returns>
/// <summary>
/// Takes the tangent of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the tangent of.</param>
/// <param name="result">When the method completes, contains a vector that contains the tangent of each component in the input vector.</param>
/// <summary>
/// Takes the tangent of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the tangent of.</param>
/// <returns>A vector that contains the tangent of each component in the input vector.</returns>
/// <summary>
/// Adds two vectors.
/// </summary>
/// <param name="left">The first vector to add.</param>
/// <param name="right">The second vector to add.</param>
/// <param name="result">When the method completes, contains the sum of the two vectors.</param>
/// <summary>
/// Adds two vectors.
/// </summary>
/// <param name="left">The first vector to add.</param>
/// <param name="right">The second vector to add.</param>
/// <returns>The sum of the two vectors.</returns>
/// <summary>
/// Subtracts two vectors.
/// </summary>
/// <param name="left">The first vector to subtract.</param>
/// <param name="right">The second vector to subtract.</param>
/// <param name="result">When the method completes, contains the difference of the two vectors.</param>
/// <summary>
/// Subtracts two vectors.
/// </summary>
/// <param name="left">The first vector to subtract.</param>
/// <param name="right">The second vector to subtract.</param>
/// <returns>The difference of the two vectors.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <param name="result">When the method completes, contains the scaled vector.</param>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Modulates a vector with another by performing component-wise multiplication.
/// </summary>
/// <param name="left">The first vector to modulate.</param>
/// <param name="right">The second vector to modulate.</param>
/// <param name="result">When the method completes, contains the modulated vector.</param>
/// <summary>
/// Modulates a vector with another by performing component-wise multiplication.
/// </summary>
/// <param name="left">The first vector to modulate.</param>
/// <param name="right">The second vector to modulate.</param>
/// <returns>The modulated vector.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <param name="result">When the method completes, contains the scaled vector.</param>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Reverses the direction of a given vector.
/// </summary>
/// <param name="value">The vector to negate.</param>
/// <param name="result">When the method completes, contains a vector facing in the opposite direction.</param>
/// <summary>
/// Reverses the direction of a given vector.
/// </summary>
/// <param name="value">The vector to negate.</param>
/// <returns>A vector facing in the opposite direction.</returns>
/// <summary>
/// Takes the absolute value of each component.
/// </summary>
/// <param name="value">The vector to take the absolute value of.</param>
/// <param name="result">When the method completes, contains a vector that has all positive components.</param>
/// <summary>
/// Takes the absolute value of each component.
/// </summary>
/// <param name="value">The vector to take the absolute value of.</param>
/// <returns>A vector that has all positive components.</returns>
/// <summary>
/// Returns a <see cref="SlimMath.Vector4"/> containing the 4D Cartesian coordinates of a point specified in Barycentric coordinates relative to a 4D triangle.
/// </summary>
/// <param name="value1">A <see cref="SlimMath.Vector4"/> containing the 4D Cartesian coordinates of vertex 1 of the triangle.</param>
/// <param name="value2">A <see cref="SlimMath.Vector4"/> containing the 4D Cartesian coordinates of vertex 2 of the triangle.</param>
/// <param name="value3">A <see cref="SlimMath.Vector4"/> containing the 4D Cartesian coordinates of vertex 3 of the triangle.</param>
/// <param name="amount1">Barycentric coordinate b2, which expresses the weighting factor toward vertex 2 (specified in <paramref name="value2"/>).</param>
/// <param name="amount2">Barycentric coordinate b3, which expresses the weighting factor toward vertex 3 (specified in <paramref name="value3"/>).</param>
/// <param name="result">When the method completes, contains the 4D Cartesian coordinates of the specified point.</param>
/// <summary>
/// Returns a <see cref="SlimMath.Vector4"/> containing the 4D Cartesian coordinates of a point specified in Barycentric coordinates relative to a 4D triangle.
/// </summary>
/// <param name="value1">A <see cref="SlimMath.Vector4"/> containing the 4D Cartesian coordinates of vertex 1 of the triangle.</param>
/// <param name="value2">A <see cref="SlimMath.Vector4"/> containing the 4D Cartesian coordinates of vertex 2 of the triangle.</param>
/// <param name="value3">A <see cref="SlimMath.Vector4"/> containing the 4D Cartesian coordinates of vertex 3 of the triangle.</param>
/// <param name="amount1">Barycentric coordinate b2, which expresses the weighting factor toward vertex 2 (specified in <paramref name="value2"/>).</param>
/// <param name="amount2">Barycentric coordinate b3, which expresses the weighting factor toward vertex 3 (specified in <paramref name="value3"/>).</param>
/// <returns>A new <see cref="SlimMath.Vector4"/> containing the 4D Cartesian coordinates of the specified point.</returns>
/// <summary>
/// Restricts a value to be within a specified range.
/// </summary>
/// <param name="value">The value to clamp.</param>
/// <param name="min">The minimum value.</param>
/// <param name="max">The maximum value.</param>
/// <param name="result">When the method completes, contains the clamped value.</param>
/// <summary>
/// Restricts a value to be within a specified range.
/// </summary>
/// <param name="value">The value to clamp.</param>
/// <param name="min">The minimum value.</param>
/// <param name="max">The maximum value.</param>
/// <returns>The clamped value.</returns>
/// <summary>
/// Calculates the distance between two vectors.
/// </summary>
/// <param name="value1">The first vector.</param>
/// <param name="value2">The second vector.</param>
/// <param name="result">When the method completes, contains the distance between the two vectors.</param>
/// <remarks>
/// <see cref="SlimMath.Vector4.DistanceSquared(ref Vector4, ref Vector4, out float)"/> may be preferred when only the relative distance is needed
/// and speed is of the essence.
/// </remarks>
/// <summary>
/// Calculates the distance between two vectors.
/// </summary>
/// <param name="value1">The first vector.</param>
/// <param name="value2">The second vector.</param>
/// <returns>The distance between the two vectors.</returns>
/// <remarks>
/// <see cref="SlimMath.Vector4.DistanceSquared(Vector4, Vector4)"/> may be preferred when only the relative distance is needed
/// and speed is of the essence.
/// </remarks>
/// <summary>
/// Calculates the squared distance between two vectors.
/// </summary>
/// <param name="value1">The first vector.</param>
/// <param name="value2">The second vector.</param>
/// <param name="result">When the method completes, contains the squared distance between the two vectors.</param>
/// <remarks>Distance squared is the value before taking the square root. 
/// Distance squared can often be used in place of distance if relative comparisons are being made. 
/// For example, consider three points A, B, and C. To determine whether B or C is further from A, 
/// compare the distance between A and B to the distance between A and C. Calculating the two distances 
/// involves two square roots, which are computationally expensive. However, using distance squared 
/// provides the same information and avoids calculating two square roots.
/// </remarks>
/// <summary>
/// Calculates the squared distance between two vectors.
/// </summary>
/// <param name="value1">The first vector.</param>
/// <param name="value2">The second vector.</param>
/// <returns>The squared distance between the two vectors.</returns>
/// <remarks>Distance squared is the value before taking the square root. 
/// Distance squared can often be used in place of distance if relative comparisons are being made. 
/// For example, consider three points A, B, and C. To determine whether B or C is further from A, 
/// compare the distance between A and B to the distance between A and C. Calculating the two distances 
/// involves two square roots, which are computationally expensive. However, using distance squared 
/// provides the same information and avoids calculating two square roots.
/// </remarks>
/// <summary>
/// Calculates the dot product of two vectors.
/// </summary>
/// <param name="left">First source vector</param>
/// <param name="right">Second source vector.</param>
/// <param name="result">When the method completes, contains the dot product of the two vectors.</param>
/// <summary>
/// Calculates the dot product of two vectors.
/// </summary>
/// <param name="left">First source vector.</param>
/// <param name="right">Second source vector.</param>
/// <returns>The dot product of the two vectors.</returns>
/// <summary>
/// Converts the vector into a unit vector.
/// </summary>
/// <param name="value">The vector to normalize.</param>
/// <param name="result">When the method completes, contains the normalized vector.</param>
/// <summary>
/// Converts the vector into a unit vector.
/// </summary>
/// <param name="value">The vector to normalize.</param>
/// <returns>The normalized vector.</returns>
/// <summary>
/// Performs a linear interpolation between two vectors.
/// </summary>
/// <param name="start">Start vector.</param>
/// <param name="end">End vector.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <param name="result">When the method completes, contains the linear interpolation of the two vectors.</param>
/// <remarks>
/// This method performs the linear interpolation based on the following formula.
/// <code>start + (end - start) * amount</code>
/// Passing <paramref name="amount"/> a value of 0 will cause <paramref name="start"/> to be returned; a value of 1 will cause <paramref name="end"/> to be returned. 
/// </remarks>
/// <summary>
/// Performs a linear interpolation between two vectors.
/// </summary>
/// <param name="start">Start vector.</param>
/// <param name="end">End vector.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <returns>The linear interpolation of the two vectors.</returns>
/// <remarks>
/// This method performs the linear interpolation based on the following formula.
/// <code>start + (end - start) * amount</code>
/// Passing <paramref name="amount"/> a value of 0 will cause <paramref name="start"/> to be returned; a value of 1 will cause <paramref name="end"/> to be returned. 
/// </remarks>
/// <summary>
/// Performs a cubic interpolation between two vectors.
/// </summary>
/// <param name="start">Start vector.</param>
/// <param name="end">End vector.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <param name="result">When the method completes, contains the cubic interpolation of the two vectors.</param>
/// <summary>
/// Performs a cubic interpolation between two vectors.
/// </summary>
/// <param name="start">Start vector.</param>
/// <param name="end">End vector.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <returns>The cubic interpolation of the two vectors.</returns>
/// <summary>
/// Performs a Hermite spline interpolation.
/// </summary>
/// <param name="value1">First source position vector.</param>
/// <param name="tangent1">First source tangent vector.</param>
/// <param name="value2">Second source position vector.</param>
/// <param name="tangent2">Second source tangent vector.</param>
/// <param name="amount">Weighting factor.</param>
/// <param name="result">When the method completes, contains the result of the Hermite spline interpolation.</param>
/// <summary>
/// Performs a Hermite spline interpolation.
/// </summary>
/// <param name="value1">First source position vector.</param>
/// <param name="tangent1">First source tangent vector.</param>
/// <param name="value2">Second source position vector.</param>
/// <param name="tangent2">Second source tangent vector.</param>
/// <param name="amount">Weighting factor.</param>
/// <returns>The result of the Hermite spline interpolation.</returns>
/// <summary>
/// Performs a Catmull-Rom interpolation using the specified positions.
/// </summary>
/// <param name="value1">The first position in the interpolation.</param>
/// <param name="value2">The second position in the interpolation.</param>
/// <param name="value3">The third position in the interpolation.</param>
/// <param name="value4">The fourth position in the interpolation.</param>
/// <param name="amount">Weighting factor.</param>
/// <param name="result">When the method completes, contains the result of the Catmull-Rom interpolation.</param>
/// <summary>
/// Performs a Catmull-Rom interpolation using the specified positions.
/// </summary>
/// <param name="value1">The first position in the interpolation.</param>
/// <param name="value2">The second position in the interpolation.</param>
/// <param name="value3">The third position in the interpolation.</param>
/// <param name="value4">The fourth position in the interpolation.</param>
/// <param name="amount">Weighting factor.</param>
/// <returns>A vector that is the result of the Catmull-Rom interpolation.</returns>
/// <summary>
/// Returns a vector containing the largest components of the specified vectors.
/// </summary>
/// <param name="value1">The first source vector.</param>
/// <param name="value2">The second source vector.</param>
/// <param name="result">When the method completes, contains an new vector composed of the largest components of the source vectors.</param>
/// <summary>
/// Returns a vector containing the largest components of the specified vectors.
/// </summary>
/// <param name="value1">The first source vector.</param>
/// <param name="value2">The second source vector.</param>
/// <returns>A vector containing the largest components of the source vectors.</returns>
/// <summary>
/// Returns a vector containing the smallest components of the specified vectors.
/// </summary>
/// <param name="value1">The first source vector.</param>
/// <param name="value2">The second source vector.</param>
/// <param name="result">When the method completes, contains an new vector composed of the smallest components of the source vectors.</param>
/// <summary>
/// Returns a vector containing the smallest components of the specified vectors.
/// </summary>
/// <param name="value1">The first source vector.</param>
/// <param name="value2">The second source vector.</param>
/// <returns>A vector containing the smallest components of the source vectors.</returns>
/// <summary>
/// Orthogonalizes a list of vectors.
/// </summary>
/// <param name="destination">The list of orthogonalized vectors.</param>
/// <param name="source">The list of vectors to orthogonalize.</param>
/// <remarks>
/// <para>Orthogonalization is the process of making all vectors orthogonal to each other. This
/// means that any given vector in the list will be orthogonal to any other given vector in the
/// list.</para>
/// <para>Because this method uses the modified Gram-Schmidt process, the resulting vectors
/// tend to be numerically unstable. The numeric stability decreases according to the vectors
/// position in the list so that the first vector is the most stable and the last vector is the
/// least stable.</para>
/// </remarks>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="source"/> or <paramref name="destination"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="destination"/> is shorter in length than <paramref name="source"/>.</exception>
//Uses the modified Gram-Schmidt process.
//q1 = m1
//q2 = m2 - ((q1 ⋅ m2) / (q1 ⋅ q1)) * q1
//q3 = m3 - ((q1 ⋅ m3) / (q1 ⋅ q1)) * q1 - ((q2 ⋅ m3) / (q2 ⋅ q2)) * q2
//q4 = m4 - ((q1 ⋅ m4) / (q1 ⋅ q1)) * q1 - ((q2 ⋅ m4) / (q2 ⋅ q2)) * q2 - ((q3 ⋅ m4) / (q3 ⋅ q3)) * q3
//q5 = ...
/// <summary>
/// Orthonormalizes a list of vectors.
/// </summary>
/// <param name="destination">The list of orthonormalized vectors.</param>
/// <param name="source">The list of vectors to orthonormalize.</param>
/// <remarks>
/// <para>Orthonormalization is the process of making all vectors orthogonal to each
/// other and making all vectors of unit length. This means that any given vector will
/// be orthogonal to any other given vector in the list.</para>
/// <para>Because this method uses the modified Gram-Schmidt process, the resulting vectors
/// tend to be numerically unstable. The numeric stability decreases according to the vectors
/// position in the list so that the first vector is the most stable and the last vector is the
/// least stable.</para>
/// </remarks>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="source"/> or <paramref name="destination"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="destination"/> is shorter in length than <paramref name="source"/>.</exception>
//Uses the modified Gram-Schmidt process.
//Because we are making unit vectors, we can optimize the math for orthogonalization
//and simplify the projection operation to remove the division.
//q1 = m1 / |m1|
//q2 = (m2 - (q1 ⋅ m2) * q1) / |m2 - (q1 ⋅ m2) * q1|
//q3 = (m3 - (q1 ⋅ m3) * q1 - (q2 ⋅ m3) * q2) / |m3 - (q1 ⋅ m3) * q1 - (q2 ⋅ m3) * q2|
//q4 = (m4 - (q1 ⋅ m4) * q1 - (q2 ⋅ m4) * q2 - (q3 ⋅ m4) * q3) / |m4 - (q1 ⋅ m4) * q1 - (q2 ⋅ m4) * q2 - (q3 ⋅ m4) * q3|
//q5 = ...
/// <summary>
/// Transforms a 4D vector by the given <see cref="SlimMath.Quaternion"/> rotation.
/// </summary>
/// <param name="vector">The vector to rotate.</param>
/// <param name="rotation">The <see cref="SlimMath.Quaternion"/> rotation to apply.</param>
/// <param name="result">When the method completes, contains the transformed <see cref="SlimMath.Vector4"/>.</param>
/// <summary>
/// Transforms a 4D vector by the given <see cref="SlimMath.Quaternion"/> rotation.
/// </summary>
/// <param name="vector">The vector to rotate.</param>
/// <param name="rotation">The <see cref="SlimMath.Quaternion"/> rotation to apply.</param>
/// <returns>The transformed <see cref="SlimMath.Vector4"/>.</returns>
/// <summary>
/// Transforms an array of vectors by the given <see cref="SlimMath.Quaternion"/> rotation.
/// </summary>
/// <param name="source">The array of vectors to transform.</param>
/// <param name="rotation">The <see cref="SlimMath.Quaternion"/> rotation to apply.</param>
/// <param name="destination">The array for which the transformed vectors are stored.
/// This array may be the same array as <paramref name="source"/>.</param>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="source"/> or <paramref name="destination"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="destination"/> is shorter in length than <paramref name="source"/>.</exception>
/// <summary>
/// Transforms a 4D vector by the given <see cref="SlimMath.Matrix"/>.
/// </summary>
/// <param name="vector">The source vector.</param>
/// <param name="transform">The transformation <see cref="SlimMath.Matrix"/>.</param>
/// <param name="result">When the method completes, contains the transformed <see cref="SlimMath.Vector4"/>.</param>
/// <summary>
/// Transforms a 4D vector by the given <see cref="SlimMath.Matrix"/>.
/// </summary>
/// <param name="vector">The source vector.</param>
/// <param name="transform">The transformation <see cref="SlimMath.Matrix"/>.</param>
/// <returns>The transformed <see cref="SlimMath.Vector4"/>.</returns>
/// <summary>
/// Transforms an array of 4D vectors by the given <see cref="SlimMath.Matrix"/>.
/// </summary>
/// <param name="source">The array of vectors to transform.</param>
/// <param name="transform">The transformation <see cref="SlimMath.Matrix"/>.</param>
/// <param name="destination">The array for which the transformed vectors are stored.
/// This array may be the same array as <paramref name="source"/>.</param>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="source"/> or <paramref name="destination"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="destination"/> is shorter in length than <paramref name="source"/>.</exception>
/// <summary>
/// Adds two vectors.
/// </summary>
/// <param name="left">The first vector to add.</param>
/// <param name="right">The second vector to add.</param>
/// <returns>The sum of the two vectors.</returns>
/// <summary>
/// Assert a vector (return it unchanged).
/// </summary>
/// <param name="value">The vector to assert (unchange).</param>
/// <returns>The asserted (unchanged) vector.</returns>
/// <summary>
/// Subtracts two vectors.
/// </summary>
/// <param name="left">The first vector to subtract.</param>
/// <param name="right">The second vector to subtract.</param>
/// <returns>The difference of the two vectors.</returns>
/// <summary>
/// Reverses the direction of a given vector.
/// </summary>
/// <param name="value">The vector to negate.</param>
/// <returns>A vector facing in the opposite direction.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Tests for equality between two objects.
/// </summary>
/// <param name="left">The first value to compare.</param>
/// <param name="right">The second value to compare.</param>
/// <returns><c>true</c> if <paramref name="left"/> has the same value as <paramref name="right"/>; otherwise, <c>false</c>.</returns>
/// <summary>
/// Tests for inequality between two objects.
/// </summary>
/// <param name="left">The first value to compare.</param>
/// <param name="right">The second value to compare.</param>
/// <returns><c>true</c> if <paramref name="left"/> has a different value than <paramref name="right"/>; otherwise, <c>false</c>.</returns>
/// <summary>
/// Performs an explicit conversion from <see cref="SlimMath.Vector4"/> to <see cref="SlimMath.Vector3"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <param name="format">The format.</param>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <param name="formatProvider">The format provider.</param>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <param name="format">The format.</param>
/// <param name="formatProvider">The format provider.</param>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a hash code for this instance.
/// </summary>
/// <returns>
/// A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
/// </returns>
/// <summary>
/// Determines whether the specified <see cref="SlimMath.Vector4"/> is equal to this instance.
/// </summary>
/// <param name="other">The <see cref="SlimMath.Vector4"/> to compare with this instance.</param>
/// <returns>
/// <c>true</c> if the specified <see cref="SlimMath.Vector4"/> is equal to this instance; otherwise, <c>false</c>.
/// </returns>
/// <summary>
/// Determines whether the specified <see cref="SlimMath.Vector4"/> is equal to this instance.
/// </summary>
/// <param name="other">The <see cref="SlimMath.Vector4"/> to compare with this instance.</param>
/// <param name="epsilon">The amount of error allowed.</param>
/// <returns>
/// <c>true</c> if the specified <see cref="SlimMath.Vector4"/> is equal to this instance; otherwise, <c>false</c>.
/// </returns>
/// <summary>
/// Determines whether the specified <see cref="System.Object"/> is equal to this instance.
/// </summary>
/// <param name="obj">The <see cref="System.Object"/> to compare with this instance.</param>
/// <returns>
/// <c>true</c> if the specified <see cref="System.Object"/> is equal to this instance; otherwise, <c>false</c>.
/// </returns>
/// <summary>
/// Performs an implicit conversion from <see cref="SlimMath.Vector4"/> to <see cref="SlimDX.Vector4"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="SlimDX.Vector4"/> to <see cref="SlimMath.Vector4"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="SlimMath.Vector4"/> to <see cref="System.Windows.Media.Media3D.Point4D"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an explicit conversion from <see cref="System.Windows.Media.Media3D.Point4D"/> to <see cref="SlimMath.Vector4"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="SlimMath.Vector4"/> to <see cref="Microsoft.Xna.Framework.Vector4"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="Microsoft.Xna.Framework.Vector4"/> to <see cref="SlimMath.Vector4"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\SoftBody\AlignedAnchorArray.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\SoftBody\AlignedClusterArray.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\SoftBody\AlignedFaceArray.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\SoftBody\AlignedJointArray.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\SoftBody\AlignedLinkArray.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\SoftBody\AlignedMaterialArray.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\SoftBody\AlignedNodeArray.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\SoftBody\AlignedSoftBodyArray.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\SoftBody\AlignedTetraArray.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\SoftBody\Collections.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\SoftBody\DefaultSoftBodySolver.cs
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\SoftBody\SoftBody.cs
//private AlignedScalarArray _masses;
/*
//private AlignedPSolverArray _dSequence;
//private AlignedPSolverArray _pSequence;
//private AlignedVSolverArray _vSequence;
/*
/*
/*
/*
/*
/*
//private AlignedScalarArray _wgh;
/*
//private ScalarArray _cfm;
/*
//private AlignedBoolArray _clusterConnectivity;
//private AlignedCollisionObjectArray _collisionDisabledObjects;
//private AlignedNoteArray _notes;
//private AlignedRigidContactArray _rigidContacts;
//private AlignedSoftContactArray _softContacts;
//private AlignedIntArray _userIndexMapping;
/*
/*
/*
/*
/*
// Do not use Array.Resize, because it copies the old data
/*
/*
/*
/*
/*
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btSoftBody_getSolver(_ solver);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btSoftBody_getSolver2(_ solver);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btSoftBody_setSolver(IntPtr obj, btSoftBody::eSolverPresets::_ preset);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\SoftBody\SoftBodyHelpers.cs
//int numDims = int.Parse(nodeHeader[1]);
//int numAttrs = int.Parse(nodeHeader[2]);
//bool hasBounds = !nodeHeader[3].Equals("0");
/*
//int numCorners = int.Parse(eleHeader[1]);
//int numAttrs = int.Parse(eleHeader[2]);
//int index = int.Parse(eleLine[0], culture);
//Console.WriteLine("Nodes: {0}", psb.Nodes.Count);
//Console.WriteLine("Links: {0}", psb.Links.Count);
//Console.WriteLine("Faces: {0}", psb.Faces.Count);
//Console.WriteLine("Tetras: {0}", psb.Tetras.Count);
// triangles.Max() + 1;
// Create nodes
// Create links and faces
// Create nodes
// Create links
// ReoptimizeLinkOrder minimizes the cases where links L and L+1 share a common node.
// Link calculation input is dependent upon prior calculation #N
// Update the nodes to mark which ones are calculated by this link
// Add this dependent link calculation to the ready list if *both* inputs are clear
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\SoftBody\SoftBodyRigidBodyCollisionConfiguration.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\SoftBody\SoftBodySolver.cs
/*
/*
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern SolverTypes btSoftBodySolver_getSolverType(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btSoftBodySolver_optimize(IntPtr obj, IntPtr softBodies);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btSoftBodySolver_optimize2(IntPtr obj, IntPtr softBodies, bool forceUpdate);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btSoftBodySolver_processCollision(IntPtr obj, IntPtr __unnamed0, IntPtr __unnamed1);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btSoftBodySolver_processCollision2(IntPtr obj, IntPtr __unnamed0, IntPtr __unnamed1);
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\SoftBody\SoftRigidDynamicsWorld.cs
// private ref passed to bodies during AddSoftBody
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btSoftRigidDynamicsWorld_new(IntPtr dispatcher, IntPtr pairCache, IntPtr constraintSolver, IntPtr collisionConfiguration);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Plugins\BulletUnity\BulletSharp\SoftBody\SparseSdf.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\BasePhysicsWorldHelper.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\BCamera.cs
/* Returns the first CollisionObject the ray hits.
//BulletSharp.AllHitsRayResultCallback rayCallBack = new BulletSharp.AllHitsRayResultCallback(rayFrom, rayTo);
//Debug.Log("Casting ray from: " + rayFrom + " to: " + rayTo);
//Debug.Log("rayCallBack " + rayCallBack.GetType() + " had a hit: " + rayCallBack.CollisionObject.UserObject + " / of type: " + rayCallBack.CollisionObject.UserObject.GetType());
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\BCharacterController.cs
//0=x, 1=y, 2=z
//world.world.AddCollisionObject(m_collisionObject, CollisionFilterGroups.CharacterFilter, CollisionFilterGroups.StaticFilter | CollisionFilterGroups.DefaultFilter);
//((DynamicsWorld)world.world).AddAction(m_characterController);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\BCollisionCallbacks.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\BCollisionCallbacksDefault.cs
//todo get PersistentManifoldList from object pool
//this is first contact with this other object
//might have multiple new contacts with same object stored in separate persistent manifolds
//don't add two different lists to new contacts
//don't add to otherObjs2ManifoldMap here. It messes up onStay do it after all pm's have been visited.
/// <summary>
///Beware of creating, destroying, adding or removing bullet objects inside these functions. Doing so can alter the list of collisions and ContactManifolds 
///that are being iteratated over
///(comodification). This can result in infinite loops, null pointer exceptions, out of sequence Enter,Stay,Exit, etc... A good way to handle this sitution is 
///to collect the information in these callbacks then override "OnFinishedVisitingManifolds" like:
///
/// public override void OnFinishedVisitingManifolds(){
///     base.OnFinishedVistingManifolds(); //don't omit this it does the callbacks
///     do my Instantiation and deletion here.
/// }
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\BCollisionObject.cs
//This is used to handle a design problem. 
//We want OnEnable to add physics object to world and OnDisable to remove.
//We also want user to be able to in script: AddComponent<CollisionObject>, configure it, add it to world, potentialy disable to delay it being added to world
//Problem is OnEnable gets called before Start so that developer has no chance to configure object before it is added to world or prevent
//It from being added.
//Solution is not to add object to the world until after Start has been called. Start will do the first add to world. 
// A bitmask
// A colliding object must match this mask in order to collide with me.
//called by Physics World just before rigid body is added to world.
//the current rigid body properties are used to rebuild the rigid body.
//rigidbody is dynamic if and only if mass is non zero, otherwise static
//Don't try to call functions on other objects such as the Physics world since they may not exit.
// Add this object to the world on Start. We are doing this so that scripts which add this componnet to 
// game objects have a chance to configure them before the object is added to the bullet world.
// Be aware that Start is not affected by script execution order so objects such as constraints should
// make sure that objects they depend on have been added to the world before they add themselves.
// This can be called more than once
//OnEnable and OnDisable are called when a game object is Activated and Deactivated. 
//Unfortunately the first call comes before Awake and Start. We suppress this call so that the component
//has a chance to initialize itself. Objects that depend on other objects such as constraints should make
//sure those objects have been added to the world first.
//don't try to call functions on world before Start is called. It may not exist.
// when scene is closed objects, including the physics world, are destroyed in random order. 
// There is no way to distinquish between scene close destruction and normal gameplay destruction.
// Objects cannot depend on world existing when they Dispose of themselves. World may have been destroyed first.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\BGameObjectMotionState.cs
//Bullet wants me to fill in worldTrans
//This is called by bullet once when rigid body is added to the the world
//For kinematic rigid bodies it is called every simulation step
//[MonoPInvokeCallback(typeof(GetTransformDelegate))]
//Bullet calls this so I can copy bullet data to unity
// Update is called once per frame
// Interpolation is needed in threaded mode
// Maybe we can have a call to the physics engine in an update method instead ?
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\BGhostObject.cs
//rigidbody is dynamic if and only if mass is non zero, otherwise static
//TODO should do two passes like with collisions
//swap the hashsets so objsIWasInContactWithLastFrame now contains the list of objs.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\BPairCachingGhostObject.cs
//rigidbody is dynamic if and only if mass is non zero, otherwise static
//m_currentPosition = m_ghostObject.WorldTransform.Origin;
//float maxPen = 0f;
//swap the hashsets so objsIWasInContactWithLastFrame now contains the list of objs.
//============
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\BPhysicsWorld.cs
//for FeatherStone forward dynamics I think
//if (singleton.m_world == null && !singleton.isDisposed) singleton._InitializePhysicsWorld();
/*
// convenience variable so we arn't typecasting all the time.
//It is critical that Awake be called before any other scripts call BPhysicsWorld.Get()
//Set this script and any derived classes very early in script execution order.
// if (debugType >= BDebug.DebugType.Debug) Debug.LogFormat(c, "Adding multibody constraint {0} to world", c);
//if (c._BuildConstraint())
//  c.m_isInWorld = true;
//if (debugType >= BDebug.DebugType.Debug) Debug.LogFormat("Removing constraint {0} from world", c.Userobject);
//if (c.Userobject is BTypedConstraint) ((BTypedConstraint)c.Userobject).m_isInWorld = false;
//Add a BPhysicsWorldLateHelper component to call FixedUpdate
/*
/* case SolverType.MLCP:
//remove/dispose constraints
//remove the rigidbodies from the dynamics world and delete them
/* if (constraint.Userobject is BTypedConstraint) ((BTypedConstraint)constraint.Userobject).m_isInWorld = false;
//remove the rigidbodies from the dynamics world and delete them
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\BPhysicsWorldLateHelper.cs
/**
/*  stepSimulation proceeds the simulation over 'timeStep', units in preferably in seconds.
//collisions
//This is needed for rigidBody interpolation. The motion states will update the positions of the rigidbodies
// We want to ensure that each bullet sim step corresponds to exactly one Unity FixedUpdate timestep
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\BRigidBody.cs
/*
//need to set mass to zero for kinematic and static
//need to set mass to mass
/* can lock axis with this */
/*
/**
//rigidbody is dynamic if and only if mass is non zero, otherwise static
//if kinematic then disable deactivation
//called by Physics World just before rigid body is added to world.
//the current rigid body properties are used to rebuild the rigid body.
//all constraints using RB must be disabled before rigid body is disabled
//should remove it from the scene
//constraints must be removed before rigid body is removed
//constraints must be removed before rigid body is removed
/**
/**
/**
// Update is called once per frame
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\BSExtensionMethods2.cs
/*
//Scaling is the length of the rows.
//The rotation is the left over matrix after dividing out the scaling.
//------------------------
//------------------------
/*
//creates new Unity Matrix4x4
/// <summary>
/// Extract translation from transform matrix.
/// </summary>
/// <param name="matrix">Transform matrix. This parameter is passed by reference
/// to improve performance; no changes will be made to it.</param>
/// <returns>
/// Translation offset.
/// </returns>
/// <summary>
/// Extract rotation quaternion from transform matrix.
/// </summary>
/// <param name="matrix">Transform matrix. This parameter is passed by reference
/// to improve performance; no changes will be made to it.</param>
/// <returns>
/// Quaternion representation of rotation transform.
/// </returns>
/// <summary>
/// Extract scale from transform matrix.
/// </summary>
/// <param name="matrix">Transform matrix. This parameter is passed by reference
/// to improve performance; no changes will be made to it.</param>
/// <returns>
/// Scale vector.
/// </returns>
/// <summary>
/// Extract position, rotation and scale from TRS matrix.
/// </summary>
/// <param name="matrix">Transform matrix. This parameter is passed by reference
/// to improve performance; no changes will be made to it.</param>
/// <param name="localPosition">Output position.</param>
/// <param name="localRotation">Output rotation.</param>
/// <param name="localScale">Output scale.</param>
/// <summary>
/// Set transform component from TRS matrix.
/// </summary>
/// <param name="transform">Transform component.</param>
/// <param name="matrix">Transform matrix. This parameter is passed by reference
/// to improve performance; no changes will be made to it.</param>
// EXTRAS!
/// <summary>
/// Identity quaternion.
/// </summary>
/// <remarks>
/// <para>It is faster to access this variation than <c>Quaternion.identity</c>.</para>
/// </remarks>
/// <summary>
/// Identity matrix.
/// </summary>
/// <remarks>
/// <para>It is faster to access this variation than <c>Matrix4x4.identity</c>.</para>
/// </remarks>
/// <summary>
/// Get translation matrix.
/// </summary>
/// <param name="offset">Translation offset.</param>
/// <returns>
/// The translation transform matrix.
/// </returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\BTerrainCollisionObject.cs
/* 
//called by Physics World just before rigid body is added to world.
//the current rigid body properties are used to rebuild the rigid body.
//rigidbody is dynamic if and only if mass is non zero, otherwise static
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\BThreadedWorldHelper.cs
/// <summary>
/// Threading bullet allows to run bullet simulation steps at a higher frequency than Unity.
/// When not threaded, bullet will interpolate automatically the transforms but the action callbacks won't be called regularly
/// </summary>
/// <summary>
/// Total simulation time [in s]
/// </summary>
// wait 1 sec before starting
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\BUtility.cs
// line
// point 00
// point 01
//point 10
//point 11
/*	
//normal draw
//            {
//                Vector3 normalColor = new Vector3(1,1,0);
//				 
//                BulletSharp.Math.Vector3 faceNormal(face.m_plane[0],poly->m_faces[i].m_plane[1],poly->m_faces[i].m_plane[2]);
//                getDebugDrawer()->drawLine(worldTransform*centroid,worldTransform*(centroid+faceNormal),normalColor);
//            }
// Draw some additional lines
// Drawing top and bottom caps of the cylinder
// Drawing the base of the cone
// choose p in y-z plane
// set q = n x p
// choose p in x-y plane
// set q = n x p
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\DebugDrawUnity.cs
//todo normals and alpha
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\GetSetAttribute.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\MicroTimer.cs
/// <summary>
/// MicroStopwatch class
/// </summary>
/// <summary>
/// MicroTimer class
/// </summary>
/// <summary>
/// MicroTimer Event Argument class
/// </summary>
// Simple counter, number times timed event (callback function) executed
// Time when timed event was called since timer started
// Time when timed event was called since last timed event (dt)
// How late the timer was compared to when it should have been called
// Time it took to execute previous call to callback function (OnTimedEvent)
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\CollisionShapes\BBoxShape.cs
//public Vector3 extents = Vector3.one;
//BUtility.DebugDrawBox(position, rotation, scale, extents, Color.yellow);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\CollisionShapes\BBvhTriangleMeshShape.cs
//todo draw the hull when not in the world
//todo can this be used with Dynamic objects? The manual hints that it is for static only.
//BUtility.DebugDrawCapsule(position, rotation, scale, radius, height / 2f, 1, Gizmos.color);  
//todo test for convex. Make convex if not.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\CollisionShapes\BCapsuleShape.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\CollisionShapes\BCollisionShape.cs
// dynamic
// static
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\CollisionShapes\BCollisionShapeFromCollider.cs
//TODO
// cs.OptimizeConvexHull();
//BulletSharp.Math.Matrix childShapeTransform = this.transform;
//childShapeTransform.Invert();
//BulletSharp.Math.Matrix shapeTransform = childShapeTransform * this.transform.localToWorldMatrix.ToBullet();
/*   public override void InternalProcessTriangleIndex(ref BulletSharp.Math.Vector3 point0, ref BulletSharp.Math.Vector3 point1, ref BulletSharp.Math.Vector3 point2, int partId, int triangleIndex)
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\CollisionShapes\BCollisionShapeFromColliders.cs
//childShapeTransform.Invert();
/*   public override void InternalProcessTriangleIndex(ref BulletSharp.Math.Vector3 point0, ref BulletSharp.Math.Vector3 point1, ref BulletSharp.Math.Vector3 point2, int partId, int triangleIndex)
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\CollisionShapes\BCompoundShape.cs
/*
// TODO We should store the transform matrix to apply between the subshape and the mainshape
// because there are different cases.
// With shapes from unity colliders, we need to invert the local scale of the object as the collider takes it into account already
// With shapes from bullet, we must not invert the local scale
//TODO the gizmos do not draw correctly when collision shape is scaled
//TODO
// some of the collider types (non-finite and other compound colliders) are probably not
// can only be added to game object with rigid body attached.
// allowed should check for these.
// what about scaling not sure if it is handled correctly
// we need to invert the scale
//skip
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\CollisionShapes\BConeShape.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\CollisionShapes\BConvexHullShape.cs
//todo draw the hull when not in the world
//            Gizmos.matrix = 
//Gizmos.DrawWireMesh(hullMesh, transform.position, transform.rotation, transform.lossyScale);
//todo remove duplicate verts
//todo use vertex reduction utility
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\CollisionShapes\BConvexTriangleMeshShape.cs
//todo draw the hull when not in the world
//todo can this be used with Dynamic objects? The manual hints that it is for static only.
//BUtility.DebugDrawCapsule(position, rotation, scale, radius, height / 2f, 1, Gizmos.color);  
//todo test for convex. Make convex if not.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\CollisionShapes\BCylinderShape.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\CollisionShapes\BHeightfieldTerrainShape.cs
//generate procedural data
//just allocated several hundred float arrays. Garbage collect now since 99% likely we just loaded the scene
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\CollisionShapes\BMultiSphereShape.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\CollisionShapes\BSphereShape.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Constraints\B6DOFConstraint.cs
//Todo not sure if this is working
//todo should be properties so can capture changes and propagate to scene
//called by Physics World just before constraint is added to world.
//the current constraint properties are used to rebuild the constraint.
//TODO think about this
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Constraints\B6DOFSpring2Constraint.cs
// TODO
//   m_constraintPtr = new Generic6DofSpringConstraint(rba, m_localConstraintPoint.ToBullet(), m_localConstraintAxisX.ToBullet(), false);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Constraints\B6DOFSpringConstraint.cs
// TODO
//   m_constraintPtr = new Generic6DofSpringConstraint(rba, m_localConstraintPoint.ToBullet(), m_localConstraintAxisX.ToBullet(), false);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Constraints\BBallSocketConstraint.cs
//todo should be properties so can capture changes and propagate to scene
//called by Physics World just before constraint is added to world.
//the current constraint properties are used to rebuild the constraint.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Constraints\BConeTwistConstraint.cs
//called by Physics World just before constraint is added to world.
//the current constraint properties are used to rebuild the constraint.
//TODO this is broken
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Constraints\BFixedConstraint.cs
//called by Physics World just before constraint is added to world.
//the current constraint properties are used to rebuild the constraint.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Constraints\BHingedConstraint.cs
//todo should be properties so can capture changes and propagate to scene
//called by Physics World just before constraint is added to world.
//the current constraint properties are used to rebuild the constraint.
//warning the frameInA, frameInB version of the constructor is broken
//BM.Matrix frameInA = BM.Matrix.Identity;
//CreateFrame(m_localConstraintForwardDir, m_localConstraintUpDir, m_localConstraintPoint, ref frameInA);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Constraints\BSliderConstraint.cs
//called by Physics World just before constraint is added to world.
//the current constraint properties are used to rebuild the constraint.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Constraints\BTypedConstraint.cs
// Object A has the constraint compontent and is constrainted to object B
// The constraint frame is defined relative to A by three vectors.
// This method calculates the frames A and B that need to be passed to bullet
//do not override this
//override this one
//called by Physics World just before constraint is added to world.
//the current constraint properties are used to rebuild the constraint.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Constraints\Editor\B6DOFConstraintEditor.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Constraints\Editor\BBallSocketConstraintEditor.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Constraints\Editor\BConeTwistConstraintEditor.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Constraints\Editor\BFixedConstraintEditor.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Constraints\Editor\BHingedConstraintEditor.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Constraints\Editor\BSliderConstraintEditor.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Constraints\Editor\BTypedConstraintEditor.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Debug\BDebug.cs
/*
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Editor\BBoxShapeEditor.cs
//SerializedProperty extents;
//SerializedProperty localScaling;
//GetSerializedProperties();
//void GetSerializedProperties() {
//	extents = serializedObject.FindProperty("extents");
//    localScaling = serializedObject.FindProperty("m_localScaling");
//}
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Editor\BBvhTriangleMeshShapeEditor.cs
//SerializedProperty hullMesh;
//GetSerializedProperties();
/*
//EditorGUILayout.PropertyField(hullMesh);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Editor\BCapsuleShapeEditor.cs
//GetSerializedProperties();
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Editor\BCompoundShapeEditor.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Editor\BConeShapeEditor.cs
//GetSerializedProperties();
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Editor\BConvexHullShapeEditor.cs
//SerializedProperty hullMesh;
//GetSerializedProperties();
/*
//EditorGUILayout.PropertyField(hullMesh);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Editor\BConvexTriangleMeshShapeEditor.cs
//SerializedProperty hullMesh;
//GetSerializedProperties();
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Editor\BCylinderShapeEditor.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Editor\BMultiSphereShapeEditor.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Editor\BPhysicsWorldEditor.cs
//[CustomEditor(typeof(BPhysicsWorld),true)]
//right click menu
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Editor\BPrimitiveComponentOrderSorter.cs
//http://answers.unity3d.com/questions/31784/changing-the-order-of-components.html?page=2&pageSize=5&sort=votes
// Transform is always first (though that doesn't really matter, as we can't  move it anyway).
// Add your types here in the order you want them to be in the inspector.
// If we found the exact type in the list, then this is the right index.
// If we found a parent, then we switch to its place if it is more
// "recent" (in the inheritance tree) than previously found parents.
// [MenuItem("Edit/Sort Components %&a")]
//var GameObject = Selection.activeGameObject;
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Editor\BRigidBodyEditor.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Editor\BSoftBodyComponentOrderSorter.cs
//http://answers.unity3d.com/questions/31784/changing-the-order-of-components.html?page=2&pageSize=5&sort=votes
// Transform is always first (though that doesn't really matter, as we can't  move it anyway).
// Add your types here in the order you want them to be in the inspector.
//if present
// If we found the exact type in the list, then this is the right index.
// If we found a parent, then we switch to its place if it is more
// "recent" (in the inheritance tree) than previously found parents.
// [MenuItem("Edit/Sort Components %&a")]
//var GameObject = Selection.activeGameObject;
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Editor\BSoftBodyEditor.cs
//BulletSharp.SoftBody.Collisions collisions;  //bitmask field for collisions
//GUIContent gcSoftBodyMeshSettings = new GUIContent("SoftBodyMeshSettings");
//used to hide specific serialized properties in the editor
//Hide softBody Settings until we want to display it, also script name
//Draw settings after the default inspector
//SBSettingsPresets saveMe = bSoftBodyTarget.SoftBodySettings.sBpresetSelect;
//bSoftBodyTarget.SoftBodySettings.sBpresetSelect = saveMe;
//bitmask field for collisions
//Can apply settings on editor change
//Menu items here
//right click menu
//right click menu
/// <summary>
/// Stuff to do after creation like sort script order
/// </summary>
//order the scripts, looks nicer
//Hackish method to get past Unity serialization
//Get Instance
//BAnyMeshSettingsForEditor.Instance;
//Build it!
//Select a mesh type
//limit the fields [Range()] doesnt work
//AutoMagickally change settings is edited
//Can apply settings on editor change
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Editor\BSphereShapeEditor.cs
//SerializedProperty radius;
//GetSerializedProperties();
/*
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Editor\BThreadedWorldHelperEditor.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Editor\EditorHelpers.cs
//BulletUnity version
//Draw the UnityBullet Logo and version on scripts that need it
//EditorGUILayout.LabelField(string.Format("Bullet Version: {0}", version));
//ray-plane intersection
//raycast on existing geometry
//place it x units from the camera
//Get a ray in the world from editor camera to middle of the screen
//EditorGUILayout.BeginHorizontal();
//EditorGUILayout.HelpBox(text, MessageType.None, true);
//EditorGUILayout.EndHorizontal();
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Editor\EditorInterface.cs
/// <summary>
/// Draw a box for select the debug mode of this object.
/// </summary>
/// <param name="debug">DebugType</param>
//Check if the interface changed for perform an undo record.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Editor\PrimitiveEditor.cs
//Custom inspector
//EditorGUILayout.BeginHorizontal();
//Logo
//GUILayout.Box(EditorLogo, GUILayout.Height(64), GUILayout.ExpandWidth(true));
//Title/Version
/*
//EditorGUILayout.EndHorizontal();
//build mesh and resize
//draw default view
//DrawDefaultInspector();
//right click menu
//right click menu
//right click menu
//right click menu
//right click menu
//right click menu
//right click menu
//order the scripts, looks nicer
//ray-plane intersection
//raycast on existing geometry
//place it x units from the camera
//Get a ray in the world from editor camera to middle of the screen
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Editor\Utils\EnumFlagAttributePropertyDrawer.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Editor\Utils\GetSetDrawer.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Editor\Utils\GraphDisplay.cs
// Begin to draw a horizontal layout, using the helpBox EditorStyle
// Reserve GUI space with a width from 10 to 10000, and a fixed height of 100, and 
// cache it as a rectangle.
// step time
// first line of X
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\EditorHelpers\EnumFlagAttribute.cs
/// <summary>
/// Display multi-select popup for Flags enum correctly.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Extensions\EnumsExtension.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\MultiBody\BMultiBody.cs
/*   public override CollisionObject GetCollisionObject()
/**
// if an error occurs, don't add the object, otherwise unity will crash
//called by Physics World just before multi body is added to world.
//the current multi body properties are used to rebuild the multi body.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\MultiBody\BMultiBodyConstraint.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\MultiBody\BMultiBodyFixedLink.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\MultiBody\BMultiBodyJointLimitConstraint.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\MultiBody\BMultiBodyJointMotor.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\MultiBody\BMultiBodyLink.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\MultiBody\BMultiBodyPlanarLink.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\MultiBody\BMultiBodyPrismaticLink.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\MultiBody\BMultiBodyRevoluteLink.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\MultiBody\BMultiBodySphericalLink.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Primitives\BBox.cs
//using BulletSharp;
//using BulletSharp.Math;
/// <summary>
/// Basic BBox
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Primitives\BCapsule.cs
//using BulletSharp;
//using BulletSharp.Math;
/// <summary>
/// BCylinder
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Primitives\BCone.cs
//using BulletSharp;
//using BulletSharp.Math;
/// <summary>
/// BCylinder
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Primitives\BConvexHull.cs
//using BulletSharp;
//using BulletSharp.Math;
/// <summary>
/// Basic BBox
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Primitives\BConvexTriMesh.cs
/// <summary>
/// Basic BBox
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Primitives\BCylinder.cs
//using BulletSharp;
//using BulletSharp.Math;
/// <summary>
/// BCylinder
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Primitives\BPrimitive.cs
//using BulletSharp.Math;
/// <summary>
/// Base class for UnityBullet primatives
/// </summary>
//display in inspector
//Destroy(this);  //Probably don't need this class during runtime?
/// <summary>
/// Build object mesh and collider
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Primitives\BSphere.cs
//using BulletSharp;
//using BulletSharp.Math;
/// <summary>
/// Basic BSphere
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\Primitives\EnumerationExtensions.cs
//namespace RatherGood
//{
/// <summary>
/// Compares if the flags enum is contained in enum
/// </summary>
/// <param name="type"></param>
/// <param name="flage"></param>
/// <returns></returns>
/// <summary>
/// checks if the value contains the provided type
/// </summary>
/// <typeparam name="T"></typeparam>
/// <param name="type"></param>
/// <param name="value"></param>
/// <returns></returns>
/// <summary>
/// checks if the value is only the provided type
/// </summary>
/// <typeparam name="T"></typeparam>
/// <param name="type"></param>
/// <param name="value"></param>
/// <returns></returns>
/// <summary>
/// appends a value
/// </summary>
/// <typeparam name="T"></typeparam>
/// <param name="type"></param>
/// <param name="value"></param>
/// <returns></returns>
//completely removes the value
/// <summary>
/// Gets Description attribute from enum type
/// </summary>
/// <param name="en"></param>
/// <returns></returns>
//}________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\ProceduralMeshes\PPMeshFactory.cs
//TODO
//fill in something
//create a copy of UserMesh, dont overwrite prefabs
//Bullet dimensions
//Bullet dimensions
/// <summary>
/// Useful for creating something random for examples in the editor
/// Instance remebers last settings
/// </summary>
//[SerializeField]
//Unity wont allow switching classes in editor, so this class has all parameters in one pile, ick!
//cube
//sphere, cone, cylinder
//cone, cylinder
//Plane
//sphere
//sphere
//cone/cylinder sides
//Unity cant display this due to serialization, figure it out later
//public BPrimitiveMeshSettings meshSettings = new BPrimitiveMeshSettings();
//TODO
//Need to copy mesh from sharedMesh or we cant modify the mesh!
//fill in something
/// <summary>
/// For editor configurations
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\ProceduralMeshes\ProceduralPrimitives.cs
//using System.IO;
//using System.Runtime.InteropServices;
//using BulletSharp;
//using BulletSharp.Math;
//http://wiki.unity3d.com/index.php/ProceduralPrimitives
/// <summary>
/// Class to generate procedural Unity Meshes 
/// </summary>
// [ -length / 2, length / 2 ]
// [ -width / 2, width / 2 ]
// Retrieve lower left corner from face ind
// Bottom
// Left
// Front
// Back
// Right
// Top
// Bottom
// Left
// Front
// Back
// Right
// Top
// Bottom
// Left
// Front
// Back
// Right
// Top
// Bottom
// Left
// Front
// Back
// Right
// Top
//Note that cylinders(bottomRadius == topRadius) and pyramids(4 sides, topRadius == 0) are types of cones, and can be created with this script.
// Not implemented yet
// bottom + top + sides
// Bottom cap
// Top cap
// Sides
//Apply offset to vertices to shift pivot to center (Bullet default)
//TODO: User settable offset
//offset
// bottom + top + sides
// Bottom cap
// Top cap
// Sides
// Bottom cap
// Top cap
// Sides
// Bottom cap
// Top cap
//tri++;
// Sides
// Not implemented yet
// bottom + top + sides
// Bottom cap
// Top cap
// Sides
//Apply offset to vertices to shift pivot to center (Bullet default)
//TODO: User settable offset
//offset
// bottom + top + sides
// Bottom cap
// Top cap
// Sides
// Bottom cap
// Top cap
// Sides
// Bottom cap
// Top cap
//tri++;
// Sides
// bottom + top + sides
// Bottom cap
// Top cap
// Sides (out)
// Sides (in)
// bottom + top + sides
// Bottom cap
// Top cap
// Sides (out)
// Sides (in)
// Bottom cap
// Top cap
// Sides (out)
// Sides (in)
// Bottom cap
// Top cap
// Sides (out)
// Sides (in)
//Vector3 normale = Vector3.Cross(r1, Vector3.up);
/// <summary>
/// 
/// </summary>
/// <param name="radius"></param>
/// <param name="nbLong">number of longitude lines</param>
/// <param name="nbLat">number of latitude lines</param>
/// <returns></returns>
//Top Cap
//Middle
//Bottom Cap
/*
//Note: Don't forget to include System.Collections.Generic. And there is no UV yet, not sure how to go about it actually.
// return index of point in the middle of p1 and p2
// first check if we have it already
// not in cache, calculate it
// add vertex makes sure point is on unit sphere
// store it, return index
//MeshFilter filter = gameObject.AddComponent<MeshFilter>();
//Mesh mesh = filter.mesh;
// create 12 vertices of a icosahedron
// create 20 triangles of the icosahedron
// 5 faces around point 0
// 5 adjacent faces 
// 5 faces around point 3
// 5 adjacent faces 
// refine triangles
// replace triangle by 4 triangles
//http://answers.unity3d.com/questions/228841/dynamically-combine-verticies-that-share-the-same.html
/// <summary>
/// Weld close vertices together to create a closed hull.
/// </summary>
/// <param name="mesh"></param>
/// <param name="threshold"></param>
/// <returns></returns>
// Build new vertex buffer and remove "duplicate" verticies
// that are within the given threshold.
// Has vertex already been added to newVerts list?
// Accept new vertex!
//some meshes dont have 
// Rebuild triangles using new verticies
// Find new vertex point from buffer
/// <summary>
/// Add back face triangles to this mesh. Test me
/// </summary>
/// <param name="mesh"></param>
// duplicate vertices and uvs:
// copy the original normals...
// and revert the new ones
// double the triangles
// copy the original triangle
// save the new reversed triangle
// assign triangles last!
/// <summary>
/// After mesh is created, process it based on selected options
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\SoftBody\BSoftBody.cs
//using BulletSharp.Math;
//common Soft body settings class used for all softbodies, parameters set based on type of soft body
//SoftBodyEditor will display this when needed
//protected SoftBody m_BSoftBody;
//for converting to/from unity mesh
//disable warning
//Get Bullet data
//Update mesh based on bullet data
//Make coffee
/// <summary>
/// Update Mesh (or line renderer) at runtime, call from Update 
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\SoftBody\BSoftBodyPartOnSkinnedMesh.cs
//TODO preset must be shapeMatching
//vertex bind normal
//we need to track the edges leaving this node so we can fully orient the bone
//normalized cross product of edge with normal
//in world space,
//want to choose edges that are closest to 90 degrees with Normal first
//used for debugging if I want to display the the mesh distortions
//can't use verts and norms because
// Use this for initialization
//good
//good
//get bones and mesh verts
//compare these in world space to see which ones line up
//TODO why does other mesh shape work better than this one.
//check for duplicate verts
//Debug.Log("found a bone that is aligned with a vertex " + bones[j]);
// clear old values
/*
/*
/*
//convert the mesh data to Bullet data and create DoftBody
//todo should these be in world coordinates
//Set SB settings
//Set SB position to GO position
/**
//verts[i].ToBullet();
//sb.Nodes[i].Normal = norms[i].ToBullet();
//TODO deal with rotation
//sb.Rotate(physicsSimMesh.transform.rotation.ToBullet());
//sb.Translate(physicsSimMesh.transform.position.ToBullet());
// read the positions of the bones from the physics simulation
//Update bone positions and orientaion based on bullet data
// to update the orientation we need to see how the normal and one vertex moved
//todo check magnitude and loop over edges if first doesn't work
//do nothing since we arn't updating the mesh, we are updating the bones
//don't do anything here overriding to disable the default behavior
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\SoftBody\BSoftBodyRope.cs
//using BulletSharp;
//Set SB settings
//anchorNode point 0 to 1, rounds to node # 
//setting node mass to 0 fixes it in space apparently
//TODO: lr, Doesnt always work in editor
//Set SB position to GO position
//m_BSoftBody.Rotate(transform.rotation.ToBullet());
//m_BSoftBody.Translate(transform.position.ToBullet());
//m_BSoftBody.Scale(transform.localScale.ToBullet());
/// <summary>
/// Create new SoftBody object
/// </summary>
/// <param name="position"></param>
/// <param name="rotation"></param>
/// <param name="buildNow">Build now or configure properties and call BuildSoftBody() after</param>
/// <returns></returns>
/// <summary>
/// Update Rope line renderer at runtime, called from Update 
/// </summary>
//transform.SetTransformationFromBulletMatrix(m_BSoftBody.WorldTransform);  //Set SoftBody position, No motionstate
//public bool anchorSameAsNode = true;
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\SoftBody\BSoftBodyWMesh.cs
//using BulletSharp.SoftBody;
/// <summary>
/// Used base for any(most) softbodies needing a mesh and meshrenderer.
/// </summary>
//[RequireComponent(typeof(MeshFilter))]
//[RequireComponent(typeof(MeshRenderer))]
//convert the mesh data to Bullet data and create SoftBody
//Set SB settings
//Set SB position to GO position
/// <summary>
/// Create new SoftBody object using a Mesh
/// </summary>
/// <param name="position">World position</param>
/// <param name="rotation">rotation</param>
/// <param name="mesh">Need to provide a mesh</param>
/// <param name="buildNow">Build now or configure properties and call BuildSoftBody() after</param>
/// <param name="sBpresetSelect">Use a particular softBody configuration pre select values</param>
/// <returns></returns>
//Apply SoftBody settings presets
//Build the SoftBody
/// <summary>
/// Update Mesh (or line renderer) at runtime, call from Update 
/// </summary>
//Set SoftBody position, No motionstate    
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/BulletSharpUnity3d-master\BulletSharpUnity3d-master\Scripts\SoftBody\SBSettings.cs
//using BulletSharp.Math;
/// <summary>
/// Settings for configuring a Bullet SoftBody in Unity Editor
/// </summary>
/// <summary>
/// Apply these SoftBody settings to this SoftBody
/// </summary>
/// <param name="softBody"></param>
//TODO: lots! These presets need work.
/// <summary>
/// Reset and Configure SoftBody settings for some general preset values.  Can use as a starting point before optimization.
/// </summary>
/// <param name="preset"></param>
//save last applied preset
//reset itself
// fun factor...
/// <summary>
/// Provides convienent presets for SBSettings
/// Warning; Will overwrite settings with preset defaults!
/// </summary>
//TODO: apply reasonable min/max values
/// <summary>
/// SoftBody Config wrapper
/// </summary>
//[Range(float.NegativeInfinity, float.PositiveInfinity)]
//int.MaxValue)]
// V_Point,			///Vertex normals are oriented toward velocity
//V_TwoSided,			///Vertex normals are flipped to match velocity	
//V_TwoSidedLiftDrag, ///Vertex normals are flipped to match velocity and lift and drag forces are applied
//V_OneSided,			///Vertex normals are taken as it is	
//F_TwoSided,			///Face normals are flipped to match velocity
//F_TwoSidedLiftDrag,	///Face normals are flipped to match velocity and lift and drag forces are applied 
//F_OneSided,			///Face normals are taken as it is	
/// <summary>
/// SoftBody Material wrapper
/// </summary>
/// <summary>
/// Set SoftBody material properties
/// </summary>
/// <param name="softBody"></param>
/// <returns></returns>
//Notes:
//http://bulletphysics.org/Bullet/phpBB3/viewtopic.php?p=24280
/*setPose(bvolume,bframe):
