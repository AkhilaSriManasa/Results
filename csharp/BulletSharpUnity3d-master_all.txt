The files in Assets/Plugins/BulletUnity/BulletSharp and Assets/BulletUnity/Examples/Scenes/BulletSharpDemos are Copyright (c) 2013-2016 Andres Traks. 

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.fileFormatVersion: 2
guid: 8c71fd47d8aa69e4e9303425eb398679
timeCreated: 1464398824
licenseType: Free
TextScriptImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 
# BulletSharpUnity3d
A fork of the BulletSharp project to make the Bullet Physics Engine usable from C# code in Unity3d
fileFormatVersion: 2
guid: dd5de70bc01bc5d429b234e29899b686
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant: 
GETTING STARTED WITH BULLET PHYSICS
===================================
INSTALLATION

Bullet Physics For Unity uses unsafe code. There must be a file "smcs.rsp" in the root asset folder that contains:

-unsafe

Sometimes this file is not included

===================================

BULLET UNITY CONTAINS TWO API'S

1) BulletSharp - Located in Plugins/BulletSharp is a low level set of C# wrappers for the native bullet libraries. These wrappers are not integrated with Unity in
any way. Simulations can be run that are not synchronized with Unity's game loop. The demos in BulletUnity/Examples/Scenes/BulletSharpDemos use this API.

2) BulletUnity - Located in BulletUnity/Scripts is a set of Unity Components similar to the PhysX components. These components use the lower level BulletSharp API.

======================
SOURCES OF INFORMATION

The BULLET PHYSICS MANUAL. Download it from the Bullet Physics project on github. It is short (can be read in 1 hour) and will set you up well for working with 
Bullet Physics.

The Bullet Physics Wiki has a lot of good information http://bulletphysics.org/mediawiki-1.5.8/index.php/Main_Page.

The Bullet Physics Forums http://www.bulletphysics.org/Bullet/phpBB3/

The Bullet Physics Examples (ported to C#, then ported to Unity) located in the BulletUnity/Examples/Scenes/BulletSharpDemos folder. More are available in the https://github.com/Phong13/BulletSharpPInvoke project.

DON'T BE AFRAID TO LOOK AT THE BULLET PHYSICS SOURCE CODE. I know it sounds intimidating, but it is much easier than you think. If you are not sure what an API
 call or class does or what a member variable is for, then search for it in the bullet sourcecode. Even if you are not a C++ programmer you can probably deduce
 what it does. I recently spent a few hours on google trying to find good information explaining the difference between btGhostObject and btPairCachingGhostObject.
Eventually I opened the btGhostObject.cpp source file and had a look. The entire sourcecode for both classes is only 170 lines. In about 10 minutes I had a complete
understanding how both classes worked. Much better than an online tutorial.

It is possible to debug from Unity into the Bullet Physics library native code with Visual Studio (probably possible with other IDEs but I havn't tried). To do this you need
to clone the https://github.com/Phong13/BulletSharpPInvoke project. Build a debug, x64 version of libbulletc for windows. Copy the .dll and .pdb file to Unity project (Plugins/Native/x64. 
Then launch Unity from the Visual Studio as described here https://msdn.microsoft.com/en-us/library/605a12zt.aspx.

================================================
IMPORTANT DIFFERENCES WITH UNITY'S PHYSX PHYSICS

Don't try to move the rigid bodies by writing to myRigidBody.transform.position or .rotation. Bullet Physics is not as tightly integrated with Unity as PhysX.
Consider the transform to be completely under the control of Bullet Physics (for non-kinematic RigidBodies) and translate/rotate your rigidBodies using the Bullet Physics API calls.

Be careful of localScale. It is almost completely ignored by Bullet Physics. There are only a few CollisionShapes that can be scaled in the Bullet API (at the time
of writing these have not been implemented in Unity). Modify the shape of the CollisionShape and leave localScale at 1,1,1. You can add your MeshRender as a child of
the CollisionShape and scale that.

Don't try to nest Rigid Bodies. Bullet Unity has no control over the order that bullet updates the transforms of objects each simulation step. If the child RigidBodies get
updated before the parent RigidBodies then the child will jitter terribly.

	WRONG
		RigidBodyGameObjectA
			-RigidBodyGameObjectB
				-RigidBodyGameObjectC

	CORRECT
		RigidBodyGameObjectA
		RigidBodyGameObjectB
		RigidBodyGameObjectC

======================================
FEEL FREE TO CONTRIBUTE TO THE PROJECT

Bullet Unity is an open source project in GitHub. Please feel free to clone the github repository and contribute:

	https://github.com/Phong13/BulletUnity
	https://github.com/Phong13/BulletSharpPInvoke



  fileFormatVersion: 2
guid: 30388b92f282cc34994eaa5be83b8cb5
timeCreated: 1456287928
licenseType: Free
TextScriptImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 
This version of the libbulletc library requires Unity 5.3.4 or higher.

Building for Universal Windows Platform generates errors about unsafe code. The presence of -unsafe in the SMCP.rsp file is supposed to allow unsafe code
but does not seem to work on Universal Windows Platform.

A workaround is to compile the code in: /Plugins/BulletUnity/BulletSharp into a .dll and include that in the project instead of the C# files.fileFormatVersion: 2
guid: 508b42418ba4d944ab90c02ebf069371
timeCreated: 1475198292
licenseType: Free
TextScriptImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 
INCLUDE_DIRECTORIES(
	${BULLET_PHYSICS_SOURCE_DIR}/src
	${BULLET_PHYSICS_SOURCE_DIR}/Extras/Serialize/BulletFileLoader
)

ADD_LIBRARY(
BulletWorldImporter
btBulletWorldImporter.cpp
btBulletWorldImporter.h
btWorldImporter.cpp
btWorldImporter.h
)

SET_TARGET_PROPERTIES(BulletWorldImporter PROPERTIES VERSION ${BULLET_VERSION})
SET_TARGET_PROPERTIES(BulletWorldImporter PROPERTIES SOVERSION ${BULLET_VERSION})

IF (BUILD_SHARED_LIBS)
	TARGET_LINK_LIBRARIES(BulletWorldImporter BulletDynamics BulletCollision BulletFileLoader LinearMath)
ENDIF (BUILD_SHARED_LIBS)

IF (INSTALL_EXTRA_LIBS)
	IF (NOT INTERNAL_CREATE_DISTRIBUTABLE_MSVC_PROJECTFILES)
		#FILES_MATCHING requires CMake 2.6
		IF (${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION} GREATER 2.5)
			IF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
				INSTALL(TARGETS BulletWorldImporter DESTINATION .)
			ELSE (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
				INSTALL(TARGETS BulletWorldImporter DESTINATION lib${LIB_SUFFIX})
				INSTALL(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
DESTINATION ${INCLUDE_INSTALL_DIR} FILES_MATCHING PATTERN "*.h"  PATTERN
".svn" EXCLUDE PATTERN "CMakeFiles" EXCLUDE)
			ENDIF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
		ENDIF (${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION} GREATER 2.5)

		IF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
			SET_TARGET_PROPERTIES(BulletWorldImporter PROPERTIES FRAMEWORK true)
			SET_TARGET_PROPERTIES(BulletWorldImporter PROPERTIES PUBLIC_HEADER "btBulletWorldImporter.h")
		ENDIF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
	ENDIF (NOT INTERNAL_CREATE_DISTRIBUTABLE_MSVC_PROJECTFILES)
ENDIF (INSTALL_EXTRA_LIBS)
nDispatch/btSphereSphereCollisionAlgorithm.cpp
	CollisionDispatch/btSphereTriangleCollisionAlgorithm.cpp
	CollisionDispatch/btUnionFind.cpp
	CollisionDispatch/SphereTriangleDetector.cpp
	CollisionShapes/btBoxShape.cpp
	CollisionShapes/btBox2dShape.cpp
	CollisionShapes/btBvhTriangleMeshShape.cpp
	CollisionShapes/btCapsuleShape.cpp
	CollisionShapes/btCollisionShape.cpp
	CollisionShapes/btCompoundShape.cpp
	CollisionShapes/btConcaveShape.cpp
	CollisionShapes/btConeShape.cpp
	CollisionShapes/btConvexHullShape.cpp
	CollisionShapes/btConvexInternalShape.cpp
	CollisionShapes/btConvexPointCloudShape.cpp
	CollisionShapes/btConvexPolyhedron.cpp
	CollisionShapes/btConvexShape.cpp
	CollisionShapes/btConvex2dShape.cpp
	CollisionShapes/btConvexTriangleMeshShape.cpp
	CollisionShapes/btCylinderShape.cpp
	CollisionShapes/btEmptyShape.cpp
	CollisionShapes/btHeightfieldTerrainShape.cpp
	CollisionShapes/btMinkowskiSumShape.cpp
	CollisionShapes/btMultimaterialTriangleMeshShape.cpp
	CollisionShapes/btMultiSphereShape.cpp
	CollisionShapes/btOptimizedBvh.cpp
	CollisionShapes/btPolyhedralConvexShape.cpp
	CollisionShapes/btScaledBvhTriangleMeshShape.cpp
	CollisionShapes/btShapeHull.cpp
	CollisionShapes/btSphereShape.cpp
	CollisionShapes/btStaticPlaneShape.cpp
	CollisionShapes/btStridingMeshInterface.cpp
	CollisionShapes/btTetrahedronShape.cpp
	CollisionShapes/btTriangleBuffer.cpp
	CollisionShapes/btTriangleCallback.cpp
	CollisionShapes/btTriangleIndexVertexArray.cpp
	CollisionShapes/btTriangleIndexVertexMaterialArray.cpp
	CollisionShapes/btTriangleMesh.cpp
	CollisionShapes/btTriangleMeshShape.cpp
	CollisionShapes/btUniformScalingShape.cpp
	Gimpact/btContactProcessing.cpp
	Gimpact/btGenericPoolAllocator.cpp
	Gimpact/btGImpactBvh.cpp
	Gimpact/btGImpactCollisionAlgorithm.cpp
	Gimpact/btGImpactQuantizedBvh.cpp
	Gimpact/btGImpactShape.cpp
	Gimpact/btTriangleShapeEx.cpp
	Gimpact/gim_box_set.cpp
	Gimpact/gim_contact.cpp
	Gimpact/gim_memory.cpp
	Gimpact/gim_tri_collision.cpp
	NarrowPhaseCollision/btContinuousConvexCollision.cpp
	NarrowPhaseCollision/btConvexCast.cpp
	NarrowPhaseCollision/btGjkConvexCast.cpp
	NarrowPhaseCollision/btGjkEpa2.cpp
	NarrowPhaseCollision/btGjkEpaPenetrationDepthSolver.cpp
	NarrowPhaseCollision/btGjkPairDetector.cpp
	NarrowPhaseCollision/btMinkowskiPenetrationDepthSolver.cpp
	NarrowPhaseCollision/btPersistentManifold.cpp
	NarrowPhaseCollision/btRaycastCallback.cpp
	NarrowPhaseCollision/btSubSimplexConvexCast.cpp
	NarrowPhaseCollision/btVoronoiSimplexSolver.cpp
	NarrowPhaseCollision/btPolyhedralContactClipping.cpp
)

SET(Root_HDRS
	../btBulletCollisionCommon.h
)
SET(BroadphaseCollision_HDRS
	BroadphaseCollision/btAxisSweep3.h
	BroadphaseCollision/btBroadphaseInterface.h
	BroadphaseCollision/btBroadphaseProxy.h
	BroadphaseCollision/btCollisionAlgorithm.h
	BroadphaseCollision/btDbvt.h
	BroadphaseCollision/btDbvtBroadphase.h
	BroadphaseCollision/btDispatcher.h
	BroadphaseCollision/btMultiSapBroadphase.h
	BroadphaseCollision/btOverlappingPairCache.h
	BroadphaseCollision/btOverlappingPairCallback.h
	BroadphaseCollision/btQuantizedBvh.h
	BroadphaseCollision/btSimpleBroadphase.h
)
SET(CollisionDispatch_HDRS
	CollisionDispatch/btActivatingCollisionAlgorithm.h
	CollisionDispatch/btBoxBoxCollisionAlgorithm.h
	CollisionDispatch/btBox2dBox2dCollisionAlgorithm.h
	CollisionDispatch/btBoxBoxDetector.h
	CollisionDispatch/btCollisionConfiguration.h
	CollisionDispatch/btCollisionCreateFunc.h
	CollisionDispatch/btCollisionDispatcher.h
	CollisionDispatch/btCollisionObject.h
	CollisionDispatch/btCollisionObjectWrapper.h
	CollisionDispatch/btCollisionWorld.h
	CollisionDispatch/btCollisionWorldImporter.h
	CollisionDispatch/btCompoundCollisionAlgorithm.h
	CollisionDispatch/btCompoundCompoundCollisionAlgorithm.h
	CollisionDispatch/btConvexConcaveCollisionAlgorithm.h
	CollisionDispatch/btConvexConvexAlgorithm.h
	CollisionDispatch/btConvex2dConvex2dAlgorithm.h
	CollisionDispatch/btConvexPlaneCollisionAlgorithm.h
	CollisionDispatch/btDefaultCollisionConfiguration.h
	CollisionDispatch/btEmptyCollisionAlgorithm.h
	CollisionDispatch/btGhostObject.h
	CollisionDispatch/btHashedSimplePairCache.h
	CollisionDispatch/btManifoldResult.h
	CollisionDispatch/btSimulationIslandManager.h
	CollisionDispatch/btSphereBoxCollisionAlgorithm.h
	CollisionDispatch/btSphereSphereCollisionAlgorithm.h
	CollisionDispatch/btSphereTriangleCollisionAlgorithm.h
	CollisionDispatch/btUnionFind.h
	CollisionDispatch/SphereTriangleDetector.h
)
SET(CollisionShapes_HDRS
	CollisionShapes/btBoxShape.h
	CollisionShapes/btBox2dShape.h
	CollisionShapes/btBvhTriangleMeshShape.h
	CollisionShapes/btCapsuleShape.h
	CollisionShapes/btCollisionMargin.h
	CollisionShapes/btCollisionShape.h
	CollisionShapes/btCompoundShape.h
	CollisionShapes/btConcaveShape.h
	CollisionShapes/btConeShape.h
	CollisionShapes/btConvexHullShape.h
	CollisionShapes/btConvexInternalShape.h
	CollisionShapes/btConvexPointCloudShape.h
	CollisionShapes/btConvexPolyhedron.h
	CollisionShapes/btConvexShape.h
	CollisionShapes/btConvex2dShape.h
	CollisionShapes/btConvexTriangleMeshShape.h
	CollisionShapes/btCylinderShape.h
	CollisionShapes/btEmptyShape.h
	CollisionShapes/btHeightfieldTerrainShape.h
	CollisionShapes/btMaterial.h
	CollisionShapes/btMinkowskiSumShape.h
	CollisionShapes/btMultimaterialTriangleMeshShape.h
	CollisionShapes/btMultiSphereShape.h
	CollisionShapes/btOptimizedBvh.h
	CollisionShapes/btPolyhedralConvexShape.h
	CollisionShapes/btScaledBvhTriangleMeshShape.h
	CollisionShapes/btShapeHull.h
	CollisionShapes/btSphereShape.h
	CollisionShapes/btStaticPlaneShape.h
	CollisionShapes/btStridingMeshInterface.h
	CollisionShapes/btTetrahedronShape.h
	CollisionShapes/btTriangleBuffer.h
	CollisionShapes/btTriangleCallback.h
	CollisionShapes/btTriangleIndexVertexArray.h
	CollisionShapes/btTriangleIndexVertexMaterialArray.h
	CollisionShapes/btTriangleInfoMap.h
	CollisionShapes/btTriangleMesh.h
	CollisionShapes/btTriangleMeshShape.h
	CollisionShapes/btTriangleShape.h
	CollisionShapes/btUniformScalingShape.h
)
SET(Gimpact_HDRS
	Gimpact/btBoxCollision.h
	Gimpact/btClipPolygon.h
	Gimpact/btContactProcessing.h
	Gimpact/btGenericPoolAllocator.h
	Gimpact/btGeometryOperations.h
	Gimpact/btGImpactBvh.h
	Gimpact/btGImpactCollisionAlgorithm.h
	Gimpact/btGImpactMassUtil.h
	Gimpact/btGImpactQuantizedBvh.h
	Gimpact/btGImpactShape.h
	Gimpact/btQuantization.h
	Gimpact/btTriangleShapeEx.h
	Gimpact/gim_array.h
	Gimpact/gim_basic_geometry_operations.h
	Gimpact/gim_bitset.h
	Gimpact/gim_box_collision.h
	Gimpact/gim_box_set.h
	Gimpact/gim_clip_polygon.h
	Gimpact/gim_contact.h
	Gimpact/gim_geom_types.h
	Gimpact/gim_geometry.h
	Gimpact/gim_hash_table.h
	Gimpact/gim_linear_math.h
	Gimpact/gim_math.h
	Gimpact/gim_memory.h
	Gimpact/gim_radixsort.h
	Gimpact/gim_tri_collision.h
)
SET(NarrowPhaseCollision_HDRS
	NarrowPhaseCollision/btContinuousConvexCollision.h
	NarrowPhaseCollision/btConvexCast.h
	NarrowPhaseCollision/btConvexPenetrationDepthSolver.h
	NarrowPhaseCollision/btDiscreteCollisionDetectorInterface.h
	NarrowPhaseCollision/btGjkConvexCast.h
	NarrowPhaseCollision/btGjkEpa2.h
	NarrowPhaseCollision/btGjkEpaPenetrationDepthSolver.h
	NarrowPhaseCollision/btGjkPairDetector.h
	NarrowPhaseCollision/btManifoldPoint.h
	NarrowPhaseCollision/btMinkowskiPenetrationDepthSolver.h
	NarrowPhaseCollision/btPersistentManifold.h
	NarrowPhaseCollision/btPointCollector.h
	NarrowPhaseCollision/btRaycastCallback.h
	NarrowPhaseCollision/btSimplexSolverInterface.h
	NarrowPhaseCollision/btSubSimplexConvexCast.h
	NarrowPhaseCollision/btVoronoiSimplexSolver.h
	NarrowPhaseCollision/btPolyhedralContactClipping.h
)

SET(BulletCollision_HDRS
	${Root_HDRS}
	${BroadphaseCollision_HDRS}
	${CollisionDispatch_HDRS}
	${CollisionShapes_HDRS}
	${Gimpact_HDRS}
	${NarrowPhaseCollision_HDRS}
)


ADD_LIBRARY(BulletCollision ${BulletCollision_SRCS} ${BulletCollision_HDRS})
SET_TARGET_PROPERTIES(BulletCollision PROPERTIES VERSION ${BULLET_VERSION})
SET_TARGET_PROPERTIES(BulletCollision PROPERTIES SOVERSION ${BULLET_VERSION})
IF (BUILD_SHARED_LIBS)
  TARGET_LINK_LIBRARIES(BulletCollision LinearMath)
ENDIF (BUILD_SHARED_LIBS)


IF (INSTALL_LIBS)
	IF (NOT INTERNAL_CREATE_DISTRIBUTABLE_MSVC_PROJECTFILES)
		#INSTALL of other files requires CMake 2.6
		IF (${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION} GREATER 2.5)
			IF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
				INSTALL(TARGETS BulletCollision DESTINATION .)
			ELSE (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
				INSTALL(TARGETS BulletCollision RUNTIME DESTINATION bin
								LIBRARY DESTINATION lib${LIB_SUFFIX}
								ARCHIVE DESTINATION lib${LIB_SUFFIX})
				INSTALL(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
DESTINATION ${INCLUDE_INSTALL_DIR} FILES_MATCHING PATTERN "*.h" PATTERN ".svn" EXCLUDE PATTERN "CMakeFiles" EXCLUDE)
				INSTALL(FILES ../btBulletCollisionCommon.h
DESTINATION ${INCLUDE_INSTALL_DIR}/BulletCollision)
			ENDIF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
		ENDIF (${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION} GREATER 2.5)

		IF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
			SET_TARGET_PROPERTIES(BulletCollision PROPERTIES FRAMEWORK true)

			SET_TARGET_PROPERTIES(BulletCollision PROPERTIES PUBLIC_HEADER "${Root_HDRS}")
			# Have to list out sub-directories manually:
			SET_PROPERTY(SOURCE ${BroadphaseCollision_HDRS} PROPERTY MACOSX_PACKAGE_LOCATION Headers/BroadphaseCollision)
			SET_PROPERTY(SOURCE ${CollisionDispatch_HDRS} PROPERTY MACOSX_PACKAGE_LOCATION Headers/CollisionDispatch)
			SET_PROPERTY(SOURCE ${CollisionShapes_HDRS} PROPERTY MACOSX_PACKAGE_LOCATION Headers/CollisionShapes)
			SET_PROPERTY(SOURCE ${Gimpact_HDRS} PROPERTY MACOSX_PACKAGE_LOCATION Headers/Gimpact)
			SET_PROPERTY(SOURCE ${NarrowPhaseCollision_HDRS} PROPERTY MACOSX_PACKAGE_LOCATION Headers/NarrowPhaseCollision)

		ENDIF (APPLE AND BUILD_SHARED_LIBS AND FRAMEWORK)
	ENDIF (NOT INTERNAL_CREATE_DISTRIBUTABLE_MSVC_PROJECTFILES)
ENDIF (INSTALL_LIBS)
// Create a button for each scene.
//GUI.BeginGroup(new Rect(Screen.width/2 - 150, Screen.height/2, 300, 500));
//GUI.EndGroup();
// Create list.
// Fill list.
// Write asset to disk.
/*
//singleton not sure if it needs to be
//rope
//rigid body
//BulletSharp.Math.Matrix transform = co.WorldTransform;
/*
//InitRigidBodyInstance(colObj, child.ChildShape, ref childTransform);
//Debug.Log("Creating " + cs.ShapeType + " for " + co.ToString());
//Debug.Log("Created Unity Shape for shapeType=" + co.CollisionShape.ShapeType + " collisionShape=" + co.ToString());
//demo.Input.ClearKeyCache();
//determine what kind of soft body it is
//rope
//build nodes 2 verts map
// Update is called once per frame
// Update is called once per frame
//public BulletSharp.Math.Vector3[] linkVerts = new BulletSharp.Math.Vector3[0];
//link verts are in pairs marking the ends of the links.
/*
/*
/*
//TODO set formtext and setInfotext should write text to the GUI 
//public MouseButtons MousePressed;
//public MouseButtons MouseReleased;
//public MouseButtons MouseDown;
//TODO this should position the camera
//TODO this should be a wrapper for the Input class
//using BulletSharp.SoftBody;
// Creates platform-agnostic vertex buffers of physical shapes
// (boxes, cones, cylinders, spheres) for drawing. Includes normals.
// Vertices
// Top and bottom
// Stacks
// Indices
// Top cap
// Stacks
// Bottom cap
// Draw the base
// Draw two sides
// Adjust sphere position
// Adjust indices
// Vertices
// Top and bottom
// Stacks
// Indices
// Top cap
// Stacks
//for (j = 0; j < 1; j++)
// Bottom cap
// choose p in y-z plane
// set q = n x p
// choose p in x-y plane
// set q = n x p
// StridingMeshInterface can only be TriangleIndexVertexArray
/*
/*
//Debug.Log("Creating Shape " + shape);
//int vertexCount = hull.NumVertices;
// choose p in y-z plane
// set q = n x p
// choose p in x-y plane
// set q = n x p
// StridingMeshInterface can only be TriangleIndexVertexArray
//float r = cs.Radius;
//todo this is a cube
// Bottom
// Left
// Front
// Back
// Right
// Top
// Bottom
// Left
// Front
// Back
// Right
// Top
// Bottom
// Left
// Front
// Back
// Right
// Top
// Bottom
// Left
// Front
// Back
// Right
// Top
// Bottom
// Left
// Front
// Back
// Right
// Top
// Bottom
// Left
// Front
// Back
// Right
// Top
// Bottom
// Left
// Front
// Back
// Right
// Top
// Bottom
// Left
// Front
// Back
// Right
// Top
// Longitude |||
// Latitude ---
//Top Cap
//Middle
//Bottom Cap
// create 125 (5x5x5) dynamic objects
// scaling of the objects (0.1 = 20 centimeter boxes )
// collision configuration contains default setup for memory, collision setup
// create the ground
//groundShape.InitializePolyhedralFeatures();
//CollisionShape groundShape = new StaticPlaneShape(new Vector3(0,1,0), 50);
// create a few dynamic rigidbodies
// using motionstate is recommended, it provides interpolation capabilities
// and only synchronizes 'active' objects
// make it drop from a height
//"F11 - Toggle fullscreen\n" +
// collision configuration contains default setup for memory, collision setup
// the maximum size of the collision world. Make sure objects stay within these boundaries
// Don't make the world AABB size too large, it will harm simulation quality and performance
//Broadphase = new DbvtBroadphase();
// create the ground
// 3000
/*RigidBody cmbody =*/ LocalCreateRigidBody(mass, Matrix.Translation(pos), blockShape);
// spacing *= 1.01f;
// TODO: Ragdolls
//this will enable polyhedral contact clipping, better quality, slightly slower
//CreateLargeMeshBody();
//CreateLargeMeshBody();
// TODO
//CreateTest6();
//InitRays();
/*RigidBody body =*/ LocalCreateRigidBody(mass, Matrix.Translation(offsetPosition + pos), blockShape);
//	float diffX = boxSize[0] * 1.0f;
// create active boxes
//rigidbody is dynamic if and only if mass is non zero, otherwise static
//using motionstate is recommended, it provides interpolation capabilities, and only synchronizes 'active' objects
///create 25 (5x5) dynamic objects
// collision configuration contains default setup for memory, collision setup
// Use the default collision dispatcher. For parallel processing you can use a diffent dispatcher.
// the default constraint solver.
// create a few basic rigid bodies
// create a few dynamic rigidbodies
// Re-using the same collision is better for memory usage and performance
//using motionstate is recommended, it provides interpolation capabilities, and only synchronizes 'active' objects
//body.ActivationState = ActivationState.IslandSleeping;
//start a bit higher
/*
// perhaps we can do something special with entities (isEntity)
// like adding a collision Triggering (as example)
//can use a shift
// collision configuration contains default setup for memory, collision setup
//string[] args = Environment.GetCommandLineArgs();
//if (args.Length == 1)
//{
//}
//else
//{
//    bspLoader.LoadBspFile(args[1]);
//}
// read header
// if (id == "VBSP")
// lump format version
// lump ident code
// read brushes
// read brush sides
// texinfo
// bevel
// read entities
// read leaves
// contents
//Swap Y and Z; invert Z
//Swap Y and Z; invert Z
// leafWaterDataID
//reader.ReadInt16(); // ambientLighting
//reader.ReadSByte(); // ambientLighting
// padding
//Swap Y and Z; invert Z
//Swap Y and Z; invert Z
// read leaf brushes
// read planes
// type
// read shaders
// collision configuration contains default setup for memory, collision setup
//Dispatcher.RegisterCollisionCreateFunc(BroadphaseNativeType.BoxShape, BroadphaseNativeType.BoxShape,
//    CollisionConf.GetCollisionAlgorithmCreateFunc(BroadphaseNativeType.ConvexShape, BroadphaseNativeType.ConvexShape));
// the default constraint solver.
//World.SolverInfo.SplitImpulse = 0;
//body.RollingFriction = 0.3f;
//CollisionShape shape = new CylinderShape(CubeHalfExtents, CubeHalfExtents, CubeHalfExtents);
//stack them
//body.RollingFriction = 0.3f;
//body.Restitution = 1;
// when using ccdMode, disable regular CCD
//start a bit higher
/*
// read header
// if (id == "VBSP")
// lump format version
// lump ident code
// read brushes
// read brush sides
// texinfo
// bevel
// read entities
// read leaves
// contents
//Swap Y and Z; invert Z
//Swap Y and Z; invert Z
// leafWaterDataID
//reader.ReadInt16(); // ambientLighting
//reader.ReadSByte(); // ambientLighting
// padding
//Swap Y and Z; invert Z
//Swap Y and Z; invert Z
// read leaf brushes
// read planes
// type
// read shaders
// perhaps we can do something special with entities (isEntity)
// like adding a collision Triggering (as example)
//can use a shift
//this create an internal copy of the vertices
// collision configuration contains default setup for memory, collision setup
//World.Gravity = Freelook.Up * -10.0f;
//string filename = UnityEngine.Application.dataPath + "/BulletUnity/Examples/Scripts/BulletSharpDemos/CharacterDemo/data/BspDemo.bsp";
//Console.Write("forwardDir={0},{1},{2}\n", forwardDir[0], forwardDir[1], forwardDir[2]);
// * 0.0001f;
//use the convex sweep test to find a safe position for the camera (not blocked by static geometry)
//world.DebugDrawer.DrawLine(ref ptA, ref ptB, ref ptA);
//Vector3 boxMin = new Vector3(-1, -1, -1);
//Vector3 boxMax = new Vector3(1, 1, 1);
//Vector3 white = new Vector3(1, 1, 1);
//"F11 - Toggle fullscreen\n" +
// collision configuration contains default setup for memory, collision setup
//World.DebugDrawer.DrawBox(ref boxMin, ref boxMax, ref t, ref white);
// Scrolls back and forth over terrain
//const float dalpha = 4 * (float)Math.PI / NUMRAYS_IN_BAR;
// rotate around by alpha degrees y
// easier to see if this is big
//"F11 - Toggle fullscreen\n" +
//convexcastBatch = new ConvexcastBatch(true, 40.0f, -50.0f, 50.0f);
// collision configuration contains default setup for memory, collision setup
//CollisionShape colShape = new CapsuleShape(0.5f,2.0f);//boxShape = new SphereShape(1.0f);
//Graphics.MeshFactory.RemoveShape(groundShape);
//clear all contact points involving mesh proxy. Note: this is a slow/unoptimized operation.
//convexcastBatch.Draw(World.DebugDrawer);
// Scrolls back and forth over terrain
// rotate around by alpha degrees y
//static Vector3 cyan = new Vector3(0.0f, 1.0f, 1.0f);
//"F11 - Toggle fullscreen\n" +
// collision configuration contains default setup for memory, collision setup
//raycastBar = new RaycastBar(true, 40.0f, -50.0f, 50.0f);
//CollisionShape colShape = new CapsuleShape(0.5f,2.0f);//boxShape = new SphereShape(1.0f);
//Graphics.MeshFactory.RemoveShape(groundShape);
//clear all contact points involving mesh proxy. Note: this is a slow/unoptimized operation.
//raycastBar.Draw(World.DebugDrawer);
//"F11 - Toggle fullscreen\n" +
//CollisionShape groundShape = new StaticPlaneShape(Vector3.UnitY, 40);
//1,0,cyl0,localInertia);
//1,0,cyl0,localInertia);
//RigidBody body1 = null;//LocalCreateRigidBody(mass, Matrix.Translation(2*CUBE_HALF_EXTENTS,20,0), shape);
//RigidBody body1 = LocalCreateRigidBody(0, Matrix.Translation(2*CUBE_HALF_EXTENTS,20,0), null);
//body1.ActivationState = ActivationState.DisableDeactivation;
//body1.SetDamping(0.3f, 0.3f);
/*
/*
//TypedConstraint p2p = new Point2PointConstraint(body0, body1, pivotInA, pivotInB);
//TypedConstraint hinge = new HingeConstraint(body0, body1, pivotInA, pivotInB, axisInA, axisInB);
//use zero targetVelocity and a small maxMotorImpulse to simulate joint friction
//float	targetVelocity = 0.f;
//float	maxMotorImpulse = 0.01;
//RigidBody pRbA1 = LocalCreateRigidBody(0.0f, Matrix.Translation(-20, 0, 30), shape);
// add dynamic rigid body B1
//RigidBody pRbB1 = LocalCreateRigidBody(0.0f, Matrix.Translation(-20, 0, 30), shape);
// create slider constraint between A1 and B1 and add it to world
//spSlider1 = new SliderConstraint(pRbA1, pRbB1, Matrix.Identity, Matrix.Identity, false);
//create a slider, using the generic D6 constraint
//SIMD_RADS_PER_DEG * 10.f;
//bool useLinearReferenceFrameA = false;//use fixed frame B for linear llimits
//use fixed frame A for linear llimits
//range should be small, otherwise singularities will 'explode' the constraint
//AngularLowerLimit = new Vector3(-1.5f,0,0),
//AngularUpperLimit = new Vector3(1.5f,0,0),
//AngularLowerLimit = new Vector3(0,0,0),
//AngularUpperLimit = new Vector3(0,0,0),
//spSlider6Dof.TranslationalLimitMotor.EnableMotor[0] = true;
// create a door using hinge constraint attached to the world
// right next to the door slightly outside
// pointing upwards, aka Y-axis
//spDoorHinge.SetLimit(0.0f, (float)Math.PI / 2);
// test problem values
//spDoorHinge.SetLimit(-(float)Math.PI, (float)Math.PI * 0.8f);
//spDoorHinge.SetLimit(1, -1);
//spDoorHinge.SetLimit(-(float)Math.PI * 0.8f, (float)Math.PI);
//spDoorHinge.SetLimit(-(float)Math.PI * 0.8f, (float)Math.PI, 0.9f, 0.3f, 0.0f);
//spDoorHinge.SetLimit(-(float)Math.PI * 0.8f, (float)Math.PI, 0.9f, 0.01f, 0.0f); // "sticky limits"
//spDoorHinge.SetLimit(0, 0);
/*RigidBody pDropBody =*/ LocalCreateRigidBody(10.0f, Matrix.Translation(-5.0f, 2.0f, 0.0f), shape);
// create a generic 6DOF constraint
//RigidBody pBodyA = LocalCreateRigidBody(mass, Matrix.Translation(10.0f, 6.0f, 0), shape);
//RigidBody pBodyA = LocalCreateRigidBody(0, Matrix.Translation(10, 6, 0), null);
//RigidBody pBodyB = LocalCreateRigidBody(0, Matrix.Translation(0, 6, 0), shape);
//Generic6DofConstraint pGen6DOF = new Generic6DofConstraint(pBodyA, pBodyB, frameInA, frameInB, false);
//pGen6DOF.LinearLowerLimit = new Vector3(-10, 0, 0);
//pGen6DOF.LinearUpperLimit = new Vector3(10, 0, 0);
//pGen6DOF.LinearLowerLimit = new Vector3(0, 0, 0);
//pGen6DOF.LinearUpperLimit = new Vector3(0, 0, 0);
//pGen6DOF.TranslationalLimitMotor.EnableMotor[0] = true;
//pGen6DOF.TranslationalLimitMotor.TargetVelocity = new Vector3(5, 0, 0);
//pGen6DOF.TranslationalLimitMotor.MaxMotorForce = new Vector3(0.1f, 0, 0);
//pGen6DOF.AngularLowerLimit = new Vector3(0, (float)Math.PI * 0.9f, 0);
//pGen6DOF.AngularUpperLimit = new Vector3(0, -(float)Math.PI * 0.9f, 0);
//pGen6DOF.AngularLowerLimit = new Vector3(0, 0, -(float)Math.PI);
//pGen6DOF.AngularUpperLimit = new Vector3(0, 0, (float)Math.PI);
//pGen6DOF.AngularLowerLimit = new Vector3(0, -0.75f, (float)Math.PI * 0.8f);
//pGen6DOF.AngularUpperLimit = new Vector3(0, 0.75f, -(float)Math.PI * 0.8f);
//pGen6DOF.AngularLowerLimit = new Vector3(0, -(float)Math.PI * 0.8f, (float)Math.PI * 1.98f);
//pGen6DOF.AngularUpperLimit = new Vector3(0, (float)Math.PI * 0.8f, -(float)Math.PI * 1.98f);
//pGen6DOF.AngularLowerLimit = new Vector3(-0.75f, -0.5f, -0.5f);
//pGen6DOF.AngularUpperLimit = new Vector3(0.75f, 0.5f, 0.5f);
//pGen6DOF.AngularLowerLimit = new Vector3(-0.75f, 0, 0);
//pGen6DOF.AngularUpperLimit = new Vector3(0.75f, 0, 0);
//pGen6DOF.AngularLowerLimit = new Vector3(0, -0.7f, 0);
//pGen6DOF.AngularUpperLimit = new Vector3(0, 0.7f, 0);
//pGen6DOF.AngularLowerLimit = new Vector3(-1, 0, 0);
//pGen6DOF.AngularUpperLimit = new Vector3(1, 0, 0);
// create a ConeTwist constraint
//pBodyA = LocalCreateRigidBody(0, Matrix.Translation(-10, 5, 0), shape);
//pBodyB = LocalCreateRigidBody(1.0f, Matrix.Translation(-10, -5, 0), shape);
//coneTwist.SetLimit((float)Math.PI / 4, (float)Math.PI / 4, (float)Math.PI * 0.8f);
//coneTwist.SetLimit((((float)Math.PI / 4) * 0.6f), (float)Math.PI / 4, (float)Math.PI * 0.8f, 1.0f); // soft limit == hard limit
// Hinge connected to the world, with motor (to hinge motor with new and old constraint solver)
//pHinge.EnableAngularMotor(true, -1.0f, 0.165f); // use for the old solver
// use for the new SIMD solver
// create a universal joint using generic 6DOF constraint
// create two rigid bodies
// static bodyA (parent) on top:
// dynamic bodyB (child) below it :
// add some (arbitrary) data to build constraint frames
// add constraint to world
// draw constraint frames and limits for debugging
// create a generic 6DOF constraint with springs 
// create a Hinge2 joint
// create two rigid bodies
// static bodyA (parent) on top:
// dynamic bodyB (child) below it :
// add some data to build constraint frames
// add constraint to world
// draw constraint frames and limits for debugging
// create a Hinge joint between two dynamic bodies
// create two rigid bodies
// static bodyA (parent) on top:
// dynamic bodyB:
// add some data to build constraint frames
// add constraint to world
// draw constraint frames and limits for debugging
//ConvexDecompositionDemo demo;
//this.demo = demo;
// Calc centroid, to shift vertices around center of mass
// Create TriangleMesh
//var trimesh = new TriangleMesh();
//Vector3 vertex0 = hullVertices[index0] * LocalScaling - centroid;
//Vector3 vertex1 = hullVertices[index1] * LocalScaling - centroid;
//Vector3 vertex2 = hullVertices[index2] * LocalScaling - centroid;
//this is a tools issue: due to collision margin, convex objects overlap, compensate for it here:
//#define SHRINK_OBJECT_INWARDS 1
//SHRINK_OBJECT_INWARDS
// advance the 'base index' counter.
//"F11 - Toggle fullscreen\n" +
// MyContactCallback is just an example to show how to get access to the child shape that collided
//UnityEngine.Debug.LogFormat(childShape.ToString());
//UnityEngine.Debug.LogFormat(childShape.ToString());
/*
// collision configuration contains default setup for memory, collision setup
// create the ground
//CompoundCollisionAlgorithm.CompoundChildShapePairCallback = MyCompoundChildShapeCallback;
// Load wavefront file
//string filename = UnityEngine.Application.dataPath + "/BulletUnity/Examples/Scripts/BulletSharpDemos/ConvexDecompositionDemo/data/file.obj";
// Convert file data to TriangleMesh
// Create a hull approximation
// Add non-moving body to world
// HACD
// Recommended HACD parameters: 2 100 false false false
// minimum number of clusters
// maximum concavity
// max of 100 vertices per convex-hull
// Generate convex result
// Combine convex shapes into a compound shape
//Vector2 ToVector2(string f0, string f1)
//{
//    return new Vector2(
//        float.Parse(f0, CultureInfo.InvariantCulture),
//        float.Parse(f1, CultureInfo.InvariantCulture));
//}
// Search for a duplicate
//texels.Add(ToVector2(parts[1], parts[2]));
//texels = new List<Vector2>();
// load a wavefront obj returns number of triangles that were loaded.  Data is persists until the class is destructed.
//texels = new List<Vector2>();
//List<Vector2> texels;
// Frame counting
// Physics
// Debug drawing
/*
//Graphics = null;
//remove/dispose constraints
//remove the rigidbodies from the dynamics world and delete them
//delete collision shapes
//shadowsEnabled = !shadowsEnabled;
//very weak constraint for picking
/*
// Mouse movement
//keep it at the same picking distance
//keep it at the same picking distance
//shootBoxShape.InitializePolyhedralFeatures();
//body.Restitution = 1;
//rigidbody is dynamic if and only if mass is non zero, otherwise static
//using motionstate is recommended, it provides interpolation capabilities, and only synchronizes 'active' objects
//Vector3 distanceFrom, distanceTo;
//float distance;
/*, body2*/;
//"F11 - Toggle fullscreen\n" +
// ground
// Objects
//colShape = new BoxShape(1);
/*body2 =*/ LocalCreateRigidBody(0, body2Position, colShape1);
//static Vector3 red = new Vector3(1.0f, 0.0f, 0.0f);
/*
//World.DebugDrawer.DrawLine(ref distanceFrom, ref distanceTo, ref red);
// create 125 (5x5x5) dynamic objects
// scaling of the objects (0.1 = 20 centimeter boxes )
//"F11 - Toggle fullscreen\n" +
// collision configuration contains default setup for memory, collision setup
// create a few basic rigid bodies
//groundShape.InitializePolyhedralFeatures();
//CollisionShape groundShape = new StaticPlaneShape(new Vector3(0,1,0), 50);
//body.HasSelfCollision = false;
//body.BaseVelocity = Vector3.Zero;
//body.WorldToBaseRot = new Quaternion(0, 0, 1, -0.125f * (float)Math.PI);
//y-axis assumed up
//par body's COM to cur body's COM offset	
//cur body's COM to cur body's PIV offset
//par body's COM to cur body's PIV offset
// create a few dynamic rigidbodies
// using motionstate is recommended, it provides interpolation capabilities
// and only synchronizes 'active' objects
// Add a collider for the base
//if (true)
//rigidbody is dynamic if and only if mass is non zero, otherwise static
//using motionstate is recommended, it provides interpolation capabilities, and only synchronizes 'active' objects
//#define BULLET_TRIANGLE_COLLISION
//#define BULLET_GIMPACT_CONVEX_DECOMPOSITION
//Vector3 kinTorusTran;
//Quaternion kinTorusRot;
//"F11 - Toggle fullscreen\n" +
// collision configuration contains default setup for memory, collision setup
//Broadphase = new SimpleBroadphase();
// create trimesh model and shape
// Create Scene
//floor
//left wall
//right wall
//front wall
//back wall
//static plane
// A plane
/*RigidBody staticBody2 =*/ LocalCreateRigidBody(mass, Matrix.Translation(0, -9, 0), staticplaneShape6);
//another static plane
//normal.Normalize();
// A plane
/*staticBody2 =*/ LocalCreateRigidBody(mass, Matrix.Translation(0, -10, 0), staticplaneShape7);
// Create Static Torus
//kinematicTorus = LocalCreateRigidBody(0, startTransform, CreateTorusShape());
//kinematicTorus.CollisionFlags = kinematicTorus.CollisionFlags | CollisionFlags.StaticObject;
//kinematicTorus.ActivationState = ActivationState.IslandSleeping;
// Kinematic
//kinTorusTran = new Vector3(-0.1f, 0, 0);
//kinTorusRot = Quaternion.RotationYawPitchRoll(0, (float)Math.PI * 0.01f, 0);
// Create dynamic Torus
/*RigidBody bodyA =*/ LocalCreateRigidBody(massT, startTransform, trimeshShape);
/*RigidBody bodyB =*/ LocalCreateRigidBody(massT, startTransform, trimeshShape);
/*
// Create Dynamic Boxes
// Create Torus Shape
//GImpactConvexDecompositionShape trimesh =
//    new GImpactConvexDecompositionShape(indexVertexArrays, new Vector3(1), 0.01f);
//trimesh.Margin = 0.07f;
//trimesh.UpdateBound();
//?????
//trimeshShape = new GImpactMeshData(indexVertexArrays);
// Create Bunny Shape
//GImpactConvexDecompositionShape trimesh2 =
//    new GImpactConvexDecompositionShape(indexVertexArrays, new Vector3(1), 0.01f);
//trimesh.Margin = 0.07f;
//trimesh.UpdateBound();
//trimeshShape = trimesh2;
//?????
//trimeshShape2 = new GImpactMeshData(indexVertexArrays2);
//register GIMPACT algorithm
//ConcaveConcaveCollisionAlgorithm.RegisterAlgorithm(Dispatcher);
//rigidbody is dynamic if and only if mass is non zero, otherwise static
//using motionstate is recommended, it provides interpolation capabilities, and only synchronizes 'active' objects
//
// Setup geometry
//
//
// Setup rigid bodies
//
// root
// legs
// thigh
// shin
// Setup some damping on the bodies
//bodies[i].SetSleepingThresholds(1.6f, 2.5f);
//
// Setup the constraints
//
//ConeTwistConstraint coneC;
// hip joints
// OK
//hingeC.SetLimit(-0.1f, 0.1f);
// knee joints
//hingeC.SetLimit(-0.01f, 0.01f);
// Remove all constraints
// Remove all bodies and shapes
//"F11 - Toggle fullscreen\n" +
// collision configuration contains default setup for memory, collision setup
// create the ground
//
// set per-frame sinusoidal position targets using angular motor (hacky?)
//
//"F11 - Toggle fullscreen\n" +
// collision configuration contains default setup for memory, collision setup
//Vector3 baseHalfExtents = new Vector3(0.05f, 0.5f, 0.1f);
//multiBody.UseRK4Integration = true;
//multiBody.BaseWorldTransform = Matrix.Identity;
//init the links
//y-axis assumed up
//const bool isDynamic = true;
// : CollisionFilterGroups.StaticFilter;
// : CollisionFilterGroups.AllFilter & ~CollisionFilterGroups.StaticFilter;
/*
// Setup the geometry
// Setup some damping on the m_bodies
// Now setup the constraints
//hingeC.SetLimit(-PI_2, 0);
//"F11 - Toggle fullscreen\n" +
// collision configuration contains default setup for memory, collision setup
//World.DispatchInfo.UseConvexConservativeDistanceUtil = true;
//World.DispatchInfo.ConvexConservativeDistanceThreshold = 0.01f;
// Setup a big ground box
// Spawn one ragdoll
// create 125 (5x5x5) dynamic objects
// scaling of the objects (0.1 = 20 centimeter boxes )
// collision configuration contains default setup for memory, collision setup
// create the ground
// create a few dynamic rigidbodies
// using motionstate is recommended, it provides interpolation capabilities
// and only synchronizes 'active' objects
///create 125 (5x5x5) dynamic objects
///scaling of the objects (0.1 = 20 centimeter boxes )
//"F11 - Toggle fullscreen\n" +
// collision configuration contains default setup for memory, collision setup
// create a few dynamic rigidbodies
//CollisionShape colShape = new CapsuleShapeZ(1, 1);
//CollisionShape colShape = new CylinderShapeZ(1, 1, 1);
//CollisionShape colShape = new BoxShape(1);
//CollisionShape colShape = new SphereShape(1);
// using motionstate is recommended, it provides interpolation capabilities
// and only synchronizes 'active' objects
// make it drop from a height
//localTransform *= Matrix.Translation(new Vector3(1,1,1));
// fun factor...
//capsuleShape.LocalScaling = new Vector3(5, 1, 1);
//RigidBody body = LocalCreateRigidBody(20, startTransform, capsuleShape);
//4+8;
//psb.Cfg.VelocityIterations = 10;
//psb.AppendAnchor(0, body);
//psb.AppendAnchor(r-1, body);
// cutting=true;
// Aerodynamic forces, 50x1g flyers
//psb.Cfg.LF = 0.004f;
//psb.Cfg.DG = 0.0003f;
//psb.Cfg.PIterations = 1;
//psb.CollisionShape.Margin = 0.01f;
//| CollisionFlags.ClusterSelf;
///pass zero in generateClusters to create  cluster for each tetrahedron or triangle
//psb.Materials[0].Lst = 0.2f;
//(elementFilename != null) ? File.ReadAllText(elementFilename) : null;
// (faceFilename != null) ? File.ReadAllText(faceFilename) : null;
// File.ReadAllText(nodeFilename)
// fix one vertex
//psb.SetMass(0,0);
//psb.SetMass(10,0);
//psb.SetMass(20,0);
//psb.GenerateClusters(128);
//psb.CollisionShape.Margin = 0.5f;
// | Collision.ClusterSelf;
//9,9,//31,31,
// pass zero in generateClusters to create  cluster for each tetrahedron or triangle
//psb.GenerateClusters(64);
//SetAzi(180);
// Front left
// Front right
// Rear left
// Rear right
//autocam=true;
//
// collision configuration contains default setup for memory, collision setup
// the default constraint solver.
// Mouse movement
// This class is equivalent to RaycastVehicle, but is used to test the IAction interface
/*if (RigidBody.MotionState != null)
// calculate j that moves us to zero relative velocity
//debug wheels (cylinders)
///@todo for driving on dynamic/movable objects!;
/////wheel.RaycastInfo.GroundObject = object;
//clamp on max suspension travel
//put wheel info as in rest position
//wheel.ContactFriction = 0;
//todo: move this into proper structure
//calculate the impulse, so that the wheels don't move sidewards
//collapse all those loops into one!
//switch between active rolling (throttle), braking and non-active rolling friction (no throttle/break)
//wheel.EngineForce* timeStep;
// apply the impulses
// fix. It only worked if car's up was along Y - VT.
//Vector4 vChassisWorldUp = RigidBody.CenterOfMassTransform.get_Columns(indexUpAxis);
//apply friction impulse on the ground
//	Spring
// Damper
// RESULT
// Simulate suspension
/*
//apply suspension force
//damping of rotation when not in contact
//up = Vector3.Cross(right, fwd);
//up.Normalize();
//rotate around steering over the wheelAxleWS
//bool UseTrimeshGround = false;
//string heightfieldFile = "data/heightfield128x128.raw";
// btRaycastVehicle is the interface for the constraint that implements the raycast vehicle
// notice that for higher-quality slow-moving vehicles, another approach might be better
// implementing explicit hinged-wheel constraints with cylinder collision, rather then raycasts
//this should be engine/velocity dependent
//BT_LARGE_FLOAT;
//1.0f;
//public RaycastVehicle vehicle;
//DebugDrawMode = DebugDrawModes.DrawAabb;
//Broadphase = new DbvtBroadphase();
//if (UseTrimeshGround)
//create a triangle-mesh ground
/*
// Use HeightfieldTerrainShape
//int width = 128, length = 128; // Debugging is too slow for this
//PhyScalarType scalarType = PhyScalarType.PhyUChar;
//FileStream file = new FileStream(heightfieldFile, FileMode.Open, FileAccess.Read);
// Use float data
// Create graphics object
// heightScale isn't applied internally for float data
// Normals will be calculated later
// Using diamond subdivision
// Not using diamond subdivision
//create ground object
//localTrans effectively shifts the center of mass with respect to the chassis
//carChassis.SetDamping(0.2f, 0.2f);
//CylinderShapeX wheelShape = new CylinderShapeX(wheelWidth, wheelRadius, wheelRadius);
// clientResetScene();
// create vehicle
//vehicle = new RaycastVehicle(tuning, carChassis, vehicleRayCaster);
// choose coordinate system
// Update is called once per frame
/// <summary>
/// Lock object between threads
/// </summary>
/// <summary>
/// This is called in Unity's thread
/// </summary>
/// <summary>
/// This is called in bullet thread
/// </summary>
/// <param name="other"></param>
/// <param name="manifoldList"></param>
/// <summary>
/// This is called in bullet thread
/// </summary>
/// <param name="other"></param>
/// <param name="manifoldList"></param>
//it is safe to Instantiate, Destroy, Enable and Disable here
/// <summary>
///Beware of creating, destroying, adding or removing bullet objects inside CollisionEnter, CollisionStay and CollisionExit. Doing so can alter the list of collisions and ContactManifolds 
///that are being iteratated over
///(comodification). This can result in infinite loops, null pointer exceptions, out of sequence Enter,Stay,Exit, etc... A good way to handle this sitution is 
///to collect the information in these callbacks then override "OnFinishedVisitingManifolds" like:
///
/// public override void OnFinishedVisitingManifolds(){
///     base.OnFinishedVistingManifolds(); //don't omit this it does the callbacks
///     do my Instantiation and deletion here.
/// }
/// </summary>
//it is safe to Instantiate, Destroy, Enable and Disable here
//float fixedTimeStep = 1.0F / 60F;
//int maxSubsteps = 3;
// Use this for initialization
// Update is called once per frame
//first simulation ==============================
//Second simulation =====================
//prevent this clause from executing again
//IMPORTANT Time.fixedTime must match the timestep being used here.
//Create a World
//This should create a copy of the BPhysicsWorld with the same settings
//Copy all existing rigidbodies in scene
// IMPORTANT rigidbodies must be added to the offline world in the same order that they are in the source world
// this is because collisions must be resolved in the same order for the sim to be deterministic
//Step the simulation numberOfSimulationSteps times
//remove/dispose constraints
//remove the rigidbodies from the dynamics world and delete them
//        const string collisionTooltip = "Collisions flags\n" +
//"SDF_RS Rigid versus soft mask.\n" +
//"CL_RS: SDF based rigid vs soft.\n" +
//"SVSmask: Cluster vs convex rigid vs soft.\n" +
//"VF_SS: Rigid versus soft mask.\n" +
//"CL_SS:Vertex vs face soft vs soft handling.\n" +
//"CL_SELF: Cluster vs cluster soft vs soft handling.\n" +
//"Default: Cluster soft body self collision.";
//        //[HideInInspector]
//        [Tooltip(collisionTooltip)]
//        public Collisions collisionMask = Collisions.Default;
//Update presets if changed
//play with settings
//bSoft.SoftBodySettings.config.Collisions = collisionMask;
//randomize color for effect
//http://wiki.unity3d.com/index.php/FlyCam_Extended
/*
//wiki.unity3d.com/index.php/FlyThrough), 17 May 2011.
//public float lastUpdateTime = 0f;
//public float currentDeltaTime;
//Screen.lockCursor = true;
//void Update()
//timeDeltaTime = Time.time - lastUpdateTime;
//lastUpdateTime = Time.time;
//Screen.lockCursor = !Screen.lockCursor;
// SelectMesh ProcedurealMesh = SelectMesh.Sphere;
//randomize color for effect
//Random,
// Plane,
/// <summary>
/// Demonstrate rope "sticks" or grass similar to SoftDemo "InitSticks"
/// </summary>
//use this position
//SoftBodyEditor will display this when needed
//Vector3 centerPos = transform.position;  //place at this transform position
//create but dont build yet
//copy relavent settings
//Anchor the start node
//start node point
//bRope.SoftBodySettings.ResetToSoftBodyPresets(SBSettingsPresets.ropeStick);
//now build it
//using BulletSharp;
//linVel.Normalize();
// Use this for initialization
//test switching between dynamic and kinematic
// Use this for initialization
// Update is called once per frame
/* 
//Create a World
// create a few dynamic rigidbodies
//Add a single cube
//Step the simulation 300 steps
//Clean up.
//remove/dispose constraints
//remove the rigidbodies from the dynamics world and delete them
//delete collision shapes
///*
/*
// *
// * Bullet Continuous Collision Detection and Physics Library
// * Copyright (c) 2003-2008 Erwin Coumans  http://www.bulletphysics.com/
// *
// * This software is provided 'as-is', without any express or implied warranty.
// * In no event will the authors be held liable for any damages arising from
// * the use of this software.
// * 
// * Permission is granted to anyone to use this software for any purpose, 
// * including commercial applications, and to alter it and redistribute it
// * freely, subject to the following restrictions:
// * 
// * 1. The origin of this software must not be misrepresented; you must not
// *    claim that you wrote the original software. If you use this software
// *    in a product, an acknowledgment in the product documentation would be
// *    appreciated but is not required.
// * 2. Altered source versions must be plainly marked as such, and must not be
// *    misrepresented as being the original software.
// * 3. This notice may not be removed or altered from any source distribution.
// */
//        //public static Matrix TransposeTimesBasis(ref Matrix a, ref Matrix b)
//        public static Matrix TransposeTimesBasis(ref Matrix mA, ref Matrix mB)
//        {
//            Matrix ba = MathUtil.BasisMatrix(ref mA);
//            ba = Matrix.Transpose(ba);
//            Matrix bb = MathUtil.BasisMatrix(ref mB);
//            return BulletMatrixMultiply(ref ba, ref bb);
//        }
//        public static Matrix InverseTimes(Matrix a, Matrix b)
//        {
//            return InverseTimes(ref a, ref b);
//        }
//        public static Matrix InverseTimes(ref Matrix a, ref Matrix b)
//        {
//            Matrix m = Matrix.Invert(a);
//            return BulletMatrixMultiply(ref m, ref b);
//        }
//        public static Matrix TransposeBasis(Matrix m)
//        {
//            return TransposeBasis(ref m);
//        }
//        public static Matrix TransposeBasis(ref Matrix m)
//        {
//            return Matrix.Transpose(BasisMatrix(ref m));
//        }
//        public static Matrix InverseBasis(Matrix m)
//        {
//            return InverseBasis(ref m);
//        }
//        public static Matrix InverseBasis(ref Matrix m)
//        {
//            Matrix b = BasisMatrix(ref m);
//            b = Matrix.Invert(b);
//            return b;
//        }
//        public static float Cofac(ref Matrix m,int r1, int c1, int r2, int c2)
//        {
//            float a = MatrixComponent(ref m, r1, c1);
//            float b = MatrixComponent(ref m, r2, c2);
//            float c = MatrixComponent(ref m, r1, c2);
//            float d = MatrixComponent(ref m, r2, c1);
//            return a * b - c * d;
//        }
// dodgy but seems necessary for rounding issues.
//return a >= -0.00001 ? b : c;
//maxVal = a.W;
//        public static float VectorComponent(Vector3 v, int i)
//        {
//            return VectorComponent(ref v, i);
//        }
//        public static float VectorComponent(ref Vector3 v, int i)
//        {
//            switch (i)
//            {
//                case 0:
//                    return v.X;
//                case 1:
//                    return v.Y;
//                case 2:
//                    return v.Z;
//                default:
//                    Debug.Assert(false);
//                    return 0.0f;
//            }
//        }
//        public static void VectorComponent(ref Vector3 v, int i, float f)
//        {
//            switch (i)
//            {
//                case 0:
//                    v.X = f;
//                    return;
//                case 1:
//                    v.Y = f;
//                    return;
//                case 2:
//                    v.Z = f;
//                    return;
//            }
//            Debug.Assert(false);
//        }
//        public static void VectorComponentAddAssign(ref Vector3 v, int i, float f)
//        {
//            switch (i)
//            {
//                case 0:
//                    v.X += f;
//                    return;
//                case 1:
//                    v.Y += f;
//                    return;
//                case 2:
//                    v.Z += f;
//                    return;
//            }
//            Debug.Assert(false);
//        }
//        public static void VectorComponentMinusAssign(ref Vector3 v, int i, float f)
//        {
//            switch (i)
//            {
//                case 0:
//                    v.X -= f;
//                    return;
//                case 1:
//                    v.Y -= f;
//                    return;
//                case 2:
//                    v.Z -= f;
//                    return;
//            }
//            Debug.Assert(false);
//        }
//        public static void VectorComponentMultiplyAssign(ref Vector3 v, int i, float f)
//        {
//            switch (i)
//            {
//                case 0:
//                    v.X *= f;
//                    return;
//                case 1:
//                    v.Y *= f;
//                    return;
//                case 2:
//                    v.Z *= f;
//                    return;
//            }
//            Debug.Assert(false);
//        }
//        public static void VectorComponentDivideAssign(ref Vector3 v, int i, float f)
//        {
//            switch (i)
//            {
//                case 0:
//                    v.X /= f;
//                    return;
//                case 1:
//                    v.Y /= f;
//                    return;
//                case 2:
//                    v.Z /= f;
//                    return;
//            }
//            Debug.Assert(false);
//        }
//        public static Matrix AbsoluteMatrix(Matrix input)
//        {
//            return AbsoluteMatrix(ref input);
//        }
//        public static Matrix AbsoluteMatrix(ref Matrix input)
//        {
//            Matrix output;
//            AbsoluteMatrix(ref input, out output);
//            return output;
//        }
//        public static void AbsoluteMatrix(ref Matrix input, out Matrix output)
//        {
//            output = new Matrix(
//                System.Math.Abs(input.M11),
//                System.Math.Abs(input.M12),
//                System.Math.Abs(input.M13),
//                System.Math.Abs(input.M14),
//                System.Math.Abs(input.M21),
//                System.Math.Abs(input.M22),
//                System.Math.Abs(input.M23),
//                System.Math.Abs(input.M24),
//                System.Math.Abs(input.M31),
//                System.Math.Abs(input.M32),
//                System.Math.Abs(input.M33),
//                System.Math.Abs(input.M34),
//                System.Math.Abs(input.M41),
//                System.Math.Abs(input.M42),
//                System.Math.Abs(input.M43),
//                System.Math.Abs(input.M44));
//        }
//        public static Matrix AbsoluteBasisMatrix(ref Matrix input)
//        {
//            Matrix output;
//            AbsoluteBasisMatrix(ref input, out output);
//            return output;
//        }
//        public static void AbsoluteBasisMatrix(ref Matrix input, out Matrix output)
//        {
//            output = new Matrix(
//                System.Math.Abs(input.M11), System.Math.Abs(input.M12), System.Math.Abs(input.M13), 0.0f,
//                System.Math.Abs(input.M21), System.Math.Abs(input.M22), System.Math.Abs(input.M23), 0.0f,
//                System.Math.Abs(input.M31), System.Math.Abs(input.M32), System.Math.Abs(input.M33), 0.0f,
//                0.0f, 0.0f, 0.0f, 1.0f);
//        }
//        public static void AbsoluteVector(ref Vector3 input, out Vector3 output)
//        {
//            output = new Vector3(
//                System.Math.Abs(input.X),
//                System.Math.Abs(input.Y),
//                System.Math.Abs(input.Z));
//        }
//        public static void RotateVector(ref Vector3 vec, ref Matrix m, out Vector3 output)
//        {
//            Quaternion rotation;
//            Vector3 component;
//            m.Decompose(out component, out rotation, out component);
//            output = Vector3.Transform(vec, rotation);
//        }
//        public static void TransformAabb(Vector3 halfExtents, float margin, Matrix trans, out Vector3 aabbMinOut, out Vector3 aabbMaxOut)
//        {
//            //TransformAabb(ref halfExtents,margin,ref trans,out aabbMinOut,out aabbMaxOut);
//            Vector3 halfExtentsWithMargin = halfExtents + new Vector3(margin);
//            Vector3 center, extent;
//            AbsoluteExtents(ref trans, ref halfExtentsWithMargin, out center, out extent);
//            aabbMinOut = center - extent;
//            aabbMaxOut = center + extent;
//        }
//        public static void TransformAabb(ref Vector3 halfExtents, float margin, ref Matrix trans, out Vector3 aabbMinOut, out Vector3 aabbMaxOut)
//        {
//            Vector3 halfExtentsWithMargin = halfExtents + new Vector3(margin);
//            Vector3 center, extent;
//            AbsoluteExtents(ref trans, ref halfExtentsWithMargin, out center, out extent);
//            aabbMinOut = center - extent;
//            aabbMaxOut = center + extent;
//        }
//        public static void TransformAabb(Vector3 localAabbMin, Vector3 localAabbMax, float margin, Matrix trans, out Vector3 aabbMinOut, out Vector3 aabbMaxOut)
//        {
//            TransformAabb(ref localAabbMin, ref localAabbMax, margin, ref trans, out aabbMinOut, out aabbMaxOut);
//        }
//        public static void TransformAabb(ref Vector3 localAabbMin, ref Vector3 localAabbMax, float margin, ref Matrix trans, out Vector3 aabbMinOut, out Vector3 aabbMaxOut)
//        {
//            Debug.Assert(localAabbMin.X <= localAabbMax.X);
//            Debug.Assert(localAabbMin.Y <= localAabbMax.Y);
//            Debug.Assert(localAabbMin.Z <= localAabbMax.Z);
//            Vector3 localHalfExtents = 0.5f * (localAabbMax - localAabbMin);
//            localHalfExtents += new Vector3(margin);
//            Vector3 localCenter = 0.5f * (localAabbMax + localAabbMin);
//            Matrix abs_b = MathUtil.AbsoluteBasisMatrix(ref trans);
//            Vector3 center = Vector3.Transform(localCenter, trans);
//            Vector3 extent = new Vector3(Vector3.Dot(abs_b.Right, localHalfExtents),
//                                            Vector3.Dot(abs_b.Up, localHalfExtents),
//                                            Vector3.Dot(abs_b.Backward, localHalfExtents));
//            aabbMinOut = center - extent;
//            aabbMaxOut = center + extent;
//        }
//        public static void AbsoluteExtents(ref Matrix trans, ref Vector3 vec, out Vector3 center, out Vector3 extent)
//        {
//            Matrix abs_b;
//            AbsoluteMatrix(ref trans, out abs_b);
//            center = trans._origin;
//            extent = new Vector3(Vector3.Dot(abs_b.Right, vec),
//                                            Vector3.Dot(abs_b.Up, vec),
//                                            Vector3.Dot(abs_b.Backward, vec));
//        }
//        public static void SetMatrixVector(ref Matrix matrix, int row, Vector3 vector)
//        {
//            SetMatrixVector(ref matrix, row, ref vector);
//        }
//        public static void SetMatrixVector(ref Matrix matrix, int row, ref Vector3 vector)
//        {
//            switch (row)
//            {
//                case 0:
//                    matrix.M11 = vector.X;
//                    matrix.M12 = vector.Y;
//                    matrix.M13 = vector.Z;
//                    return;
//                case 1:
//                    matrix.M21 = vector.X;
//                    matrix.M22 = vector.Y;
//                    matrix.M23 = vector.Z;
//                    return;
//                case 2:
//                    matrix.M31 = vector.X;
//                    matrix.M32 = vector.Y;
//                    matrix.M33 = vector.Z;
//                    return;
//                case 3:
//                    matrix.M41 = vector.X;
//                    matrix.M42 = vector.Y;
//                    matrix.M43 = vector.Z;
//                    return;
//            }
//            Debug.Assert(false);
//        }
//        public static void AddMatrixVector(ref Matrix matrix, int row, ref Vector3 vector)
//        {
//            switch (row)
//            {
//                case 0:
//                    matrix.M11 += vector.X;
//                    matrix.M12 += vector.Y;
//                    matrix.M13 += vector.Z;
//                    return;
//                case 1:
//                    matrix.M21 += vector.X;
//                    matrix.M22 += vector.Y;
//                    matrix.M23 += vector.Z;
//                    return;
//                case 2:
//                    matrix.M31 += vector.X;
//                    matrix.M32 += vector.Y;
//                    matrix.M33 += vector.Z;
//                    return;
//                case 3:
//                    matrix.M41 += vector.X;
//                    matrix.M42 += vector.Y;
//                    matrix.M43 += vector.Z;
//                    return;
//            }
//            Debug.Assert(false);
//        }
//        // FIXME - MAN - make sure this is being called how we'd expect , may need to
//        // swap i,j for row/column differences
//        public static float MatrixComponent(ref Matrix m, int index)
//        {
//            //int i = index % 4;
//            //int j = index / 4;
//            int j = index % 4;
//            int i = index / 4;
//            return MatrixComponent(ref m,i,j);
//        }
//        public static float MatrixComponent(ref Matrix m, int row, int column)
//        {
//            switch (row)
//            {
//                case 0:
//                    if (column == 0) return m.M11;
//                    if (column == 1) return m.M12;
//                    if (column == 2) return m.M13;
//                    if (column == 3) return m.M14;
//                    break;
//                case 1:
//                    if (column == 0) return m.M21;
//                    if (column == 1) return m.M22;
//                    if (column == 2) return m.M23;
//                    if (column == 3) return m.M24;
//                    break;
//                case 2:
//                    if (column == 0) return m.M31;
//                    if (column == 1) return m.M32;
//                    if (column == 2) return m.M33;
//                    if (column == 3) return m.M34;
//                    break;
//                case 3:
//                    if (column == 0) return m.M41;
//                    if (column == 1) return m.M42;
//                    if (column == 2) return m.M43;
//                    if (column == 3) return m.M44;
//                    break;
//            }
//            return 0;
//        }
//        public static void MatrixComponent(ref Matrix m, int row, int column, float val)
//        {
//            switch (row)
//            {
//                case 0:
//                    if (column == 0) m.M11 = val;
//                    if (column == 1) m.M12 = val;
//                    if (column == 2) m.M13 = val;
//                    if (column == 3) m.M14 = val;
//                    break;
//                case 1:
//                    if (column == 0) m.M21 = val;
//                    if (column == 1) m.M22 = val;
//                    if (column == 2) m.M23 = val;
//                    if (column == 3) m.M24 = val;
//                    break;
//                case 2:
//                    if (column == 0) m.M31 = val;
//                    if (column == 1) m.M32 = val;
//                    if (column == 2) m.M33 = val;
//                    if (column == 3) m.M34 = val;
//                    break;
//                case 3:
//                    if (column == 0) m.M41 = val;
//                    if (column == 1) m.M42 = val;
//                    if (column == 2) m.M43 = val;
//                    if (column == 3) m.M44 = val;
//                    break;
//            }
//        }
//        public static Vector3 MatrixColumn(Matrix matrix, int row)
//        {
//            return MatrixColumn(ref matrix, row);
//        }
//        public static Vector3 MatrixColumn(ref Matrix matrix, int row)
//        {
//            Vector3 vectorRow;
//            MatrixColumn(ref matrix, row, out vectorRow);
//            return vectorRow;
//        }
//        public static void MatrixColumn(Matrix matrix, int row, out Vector3 vectorRow)
//        {
//            MatrixColumn(ref matrix,row, out vectorRow);
//        }
//        public static void MatrixColumn(ref Matrix matrix, int row, out Vector3 vectorRow)
//        {
//            switch (row)
//            {
//                case 0:
//                    vectorRow = new Vector3(matrix.M11, matrix.M12, matrix.M13);
//                    break;
//                case 1:
//                    vectorRow = new Vector3(matrix.M21, matrix.M22, matrix.M23);
//                    break;
//                case 2:
//                    vectorRow = new Vector3(matrix.M31, matrix.M32, matrix.M33);
//                    break;
//                case 3:
//                    vectorRow = new Vector3(matrix.M41, matrix.M42, matrix.M43);
//                    break;
//                default:
//                    vectorRow = Vector3.Zero;
//                    break;
//            }
//        }
//        public static Vector3 MatrixRow(Matrix matrix, int row)
//        {
//            switch (row)
//            {
//                case 0:
//                    return new Vector3(matrix.M11, matrix.M21, matrix.M31);
//                case 1:
//                    return new Vector3(matrix.M12, matrix.M22, matrix.M32);
//                case 2:
//                    return new Vector3(matrix.M13, matrix.M23, matrix.M33);
//                case 3:
//                    return new Vector3(matrix.M14, matrix.M24, matrix.M34);
//                default:
//                    return Vector3.Zero;
//            }
//        }
//        public static Vector3 MatrixRow(ref Matrix matrix, int row)
//        {
//            switch (row)
//            {
//                case 0:
//                    return new Vector3(matrix.M11, matrix.M21, matrix.M31);
//                case 1:
//                    return new Vector3(matrix.M12, matrix.M22, matrix.M32);
//                case 2:
//                    return new Vector3(matrix.M13, matrix.M23, matrix.M33);
//                case 3:
//                    return new Vector3(matrix.M14, matrix.M24, matrix.M34);
//                default:
//                    return Vector3.Zero;
//            }
//        }
//        public static void MatrixRow(ref Matrix matrix, int row, out Vector3 vectorRow)
//        {
//            switch (row)
//            {
//                case 0:
//                    vectorRow = new Vector3(matrix.M11, matrix.M21, matrix.M31);
//                    break;
//                case 1:
//                    vectorRow = new Vector3(matrix.M12, matrix.M22, matrix.M32);
//                    break;
//                case 2:
//                    vectorRow = new Vector3(matrix.M13, matrix.M23, matrix.M33);
//                    break;
//                case 3:
//                    vectorRow = new Vector3(matrix.M14, matrix.M24, matrix.M34);
//                    break;
//                default:
//                    vectorRow = Vector3.Zero;
//                    break;
//            }
//        }
// Set testNz to 0xFFFFFFFF if condition is nonzero, 0x00000000 if condition is zero
// Rely on positive value or'ed with its negative having sign bit on
// and zero value or'ed with its negative (which is still zero) having sign bit off 
// Use arithmetic shift right, shifting the sign bit through all 32 bits
//        public static void BasisMatrix(Matrix matrixIn, out Matrix matrixOut)
//        {
//            BasisMatrix(ref matrixIn, out matrixOut);
//        }
//        public static void BasisMatrix(ref Matrix matrixIn, out Matrix matrixOut)
//        {
//            matrixOut = matrixIn;
//            matrixOut.M41 = 0.0f;
//            matrixOut.M42 = 0.0f;
//            matrixOut.M43 = 0.0f;
//            matrixOut.M44 = 1.0f;
//        }
//        public static Matrix BasisMatrix(Matrix matrixIn)
//        {
//            return BasisMatrix(ref matrixIn);
//        }
//        public static Matrix BasisMatrix(ref Matrix matrixIn)
//        {
//            Matrix matrixOut = matrixIn;
//            matrixOut.M41 = 0.0f;
//            matrixOut.M42 = 0.0f;
//            matrixOut.M43 = 0.0f;
//            matrixOut.M44 = 1.0f;
//            return matrixOut;
//        }
// just pick any vector
//      /**@brief diagonalizes this matrix by the Jacobi method.
/**@brief diagonalizes this matrix by the Jacobi method.
//       * coordinate system, i.e., old_this = rot * new_this * rot^T. 
//       * @param threshold See iteration
//       * @param iteration The iteration stops when all off-diagonal elements are less than the threshold multiplied 
//       * by the sum of the absolute values of the diagonal, or when maxSteps have been executed. 
//       * 
//       * Note that this matrix is assumed to be symmetric. 
//       */
//        public static void Diagonalize(ref Matrix inMatrix,ref Matrix rot, float threshold, int maxSteps)
//        {
//            Debug.Assert(false);
//            rot = Matrix.Identity;
//            for (int step = maxSteps; step > 0; step--)
//            {
//                // find off-diagonal element [p][q] with largest magnitude
//                int p = 0;
//                int q = 1;
//                int r = 2;
//                float max = System.Math.Abs(inMatrix.M12);
//                float v = System.Math.Abs(inMatrix.M13);
//                if (v > max)
//                {
//                   q = 2;
//                   r = 1;
//                   max = v;
//                }
//                v = System.Math.Abs(inMatrix.M23);
//                if (v > max)
//                {
//                   p = 1;
//                   q = 2;
//                   r = 0;
//                   max = v;
//                }
//                float t = threshold * (System.Math.Abs(inMatrix.M11) + System.Math.Abs(inMatrix.M22) + System.Math.Abs(inMatrix.M33));
//                if (max <= t)
//                {
//                   if (max <= SIMD_EPSILON * t)
//                   {
//                      return;
//                   }
//                   step = 1;
//                }
//                // compute Jacobi rotation J which leads to a zero for element [p][q] 
//                float mpq = MathUtil.MatrixComponent(ref inMatrix,p,q);
//                float theta = (MathUtil.MatrixComponent(ref inMatrix,q,q)-MathUtil.MatrixComponent(ref inMatrix,p,p)) / (2 * mpq);
//                float theta2 = theta * theta;
//                float cos;
//                float sin;
//                if (theta2 * theta2 < 10f / SIMD_EPSILON)
//                {
//                   t = (theta >= 0f) ? (float)(1f / (theta + System.Math.Sqrt(1 + theta2)))
//                                            : (float)(1f / (theta - System.Math.Sqrt(1 + theta2)));
//                   cos = (float)(1f / System.Math.Sqrt(1 + t * t));
//                   sin = cos * t;
//                }
//                else
//                {
//                   // approximation for large theta-value, i.e., a nearly diagonal matrix
//                   t = 1 / (theta * (2 + 0.5f / theta2));
//                   cos = 1 - 0.5f * t * t;
//                   sin = cos * t;
//                }
//                // apply rotation to matrix (this = J^T * this * J)
//                MathUtil.MatrixComponent(ref inMatrix,p,q,0f);
//                MathUtil.MatrixComponent(ref inMatrix,q,p,0f);
//                MathUtil.MatrixComponent(ref inMatrix,p,p,MathUtil.MatrixComponent(ref inMatrix,p,p)-t*mpq);
//                MathUtil.MatrixComponent(ref inMatrix,q,q,MathUtil.MatrixComponent(ref inMatrix,q,q)+t*mpq);
//                float  mrp = MathUtil.MatrixComponent(ref inMatrix,r,p);
//                float  mrq = MathUtil.MatrixComponent(ref inMatrix,r,q);
//                MathUtil.MatrixComponent(ref inMatrix,r,p,cos * mrp - sin * mrq);
//                MathUtil.MatrixComponent(ref inMatrix,p,r,cos * mrp - sin * mrq);
//                MathUtil.MatrixComponent(ref inMatrix,r,q,cos * mrp + sin * mrq);
//                MathUtil.MatrixComponent(ref inMatrix,q,r,cos * mrp + sin * mrq);
//                // apply rotation to rot (rot = rot * J)
//                for (int i = 0; i < 3; i++)
//                {
//                    float  mrp2 = MathUtil.MatrixComponent(ref rot,i,p);
//                    float  mrq2 = MathUtil.MatrixComponent(ref rot,i,q);
//                    MathUtil.MatrixComponent(ref rot, i, p, cos * mrp - sin * mrq);
//                    MathUtil.MatrixComponent(ref rot, i, q, cos * mrp + sin * mrq);
//                }
//            }
//        }
//Debug.Assert(false);
//        public static void Vector3FromFloat(out Vector3 v, float[] fa)
//        {
//            v = new Vector3(fa[0], fa[1], fa[2]);
//        }
//        //public static void FloatFromVector3(Vector3 v, float[] fa)
//        //{
//        //    FloatFromVector3(ref v, fa);
//        //}
//        //public static void FloatFromVector3(ref Vector3 v, float[] fa)
//        //{
//        //    fa[0] = v.X;
//        //    fa[1] = v.Y;
//        //    fa[2] = v.Z;
//        //}
//        //public static float[] FloatFromVector3(Vector3 v)
//        //{
//        //    return FloatFromVector3(ref v);
//        //}
//        //public static float[] FloatFromVector3(ref Vector3 v)
//        //{
//        //    return new float[] { v.X, v.Y, v.Z };
//        //}
/*
//	// rot =  cy*cz          -cy*sz           sy
//	//        cz*sx*sy+cx*sz  cx*cz-sx*sy*sz -cy*sx
//	//       -cx*cz*sy+sx*sz  cz*sx+cx*sy*sz  cx*cy
//
// WARNING.  Not unique.  XA - ZA = -atan2(r10,r11)
// WARNING.  Not unique.  XAngle + ZAngle = atan2(r10,r11)
//        public static Vector3 MatrixToEuler(ref Matrix m)
//        {
//            Vector3 translate;
//            Vector3 scale;
//            Quaternion rotate;
//            m.Decompose(out scale, out rotate, out translate);
//            return quaternionToEuler(ref rotate);
//        }
//        // Taken from Fabian Vikings post at : http://forums.xna.com/forums/p/4574/23763.aspx  
//        public static Vector3 quaternionToEuler(ref Quaternion q)
//        {
//            Vector3 v = Vector3.Zero;
//            v.X = (float)Math.Atan2
//            (
//                2 * q.Y * q.W - 2 * q.X * q.Z,
//                   1 - 2 * Math.Pow(q.Y, 2) - 2 * Math.Pow(q.Z, 2)
//            );
//            v.Z = (float)Math.Asin
//            (
//                2 * q.X * q.Y + 2 * q.Z * q.W
//            );
//            v.Y = (float)Math.Atan2
//            (
//                2 * q.X * q.W - 2 * q.Y * q.Z,
//                1 - 2 * Math.Pow(q.X, 2) - 2 * Math.Pow(q.Z, 2)
//            );
//            if (q.X * q.Y + q.Z * q.W == 0.5)
//            {
//                v.X = (float)(2 * Math.Atan2(q.X, q.W));
//                v.Y = 0;
//            }
//            else if (q.X * q.Y + q.Z * q.W == -0.5)
//            {
//                v.X = (float)(-2 * Math.Atan2(q.X, q.W));
//                v.Y = 0;
//            }
//            return v;
//        }
//return b * a;
//public static Matrix BulletMatrixMultiply(Matrix m1, Matrix m2)
//{
//    return m1 * m2;
//}
//public static Matrix BulletMatrixMultiply(ref Matrix m1, ref Matrix m2)
//{
//    return m1 * m2;
//}
//        public static Matrix BulletMatrixMultiplyBasis(Matrix m1, Matrix m2)
//        {
//            return BulletMatrixMultiplyBasis(ref m1, ref m2);
//        }
//        public static Matrix BulletMatrixMultiplyBasis(ref Matrix m1, ref Matrix m2)
//        {
//            Matrix mb1;
//            BasisMatrix(ref m1, out mb1);
//            Matrix mb2;
//            BasisMatrix(ref m2, out mb2);
//            return BulletMatrixMultiply(ref mb1, ref mb2);
//        }
// Need to check this mod operator works with floats...
/*
//return Matrix.CreateFromYawPitchRoll(y, x,z);
// This version tested and compared to c++ version. don't break it.
// note that the row/column settings are switched from c++
//        public static Vector3 MatrixToVector(Matrix m, Vector3 v)
//        {
//            return new Vector3(
//                Vector3.Dot(new Vector3(m.M11, m.M12, m.M13), v) + m._origin.X,
//                Vector3.Dot(new Vector3(m.M21, m.M22, m.M23), v) + m._origin.Y,
//                Vector3.Dot(new Vector3(m.M31, m.M32, m.M33), v) + m._origin.Z
//                );
//        }
//        public static Vector3 TransposeTransformNormal(Vector3 v,Matrix m)
//        {
//            return TransposeTransformNormal(ref v, ref m);
//        }
//        public static Vector3 TransposeTransformNormal(ref Vector3 v,ref Matrix m)
//        {
//            Matrix mt = TransposeBasis(ref m);
//            return Vector3.TransformNormal(v, mt);
//        }
//        //public static Vector3 TransposeTransformNormal(ref Vector3 v, ref Matrix m)
//        //{
//        //    Matrix mt = TransposeBasis(ref m);
//        //    return Vector3.TransformNormal(ref v, ref mt);
//        //}
//public const float SIMD_EPSILON = 0.0000001f;
/*
/// <summary>
/// The value for which all absolute numbers smaller than are considered equal to zero.
/// </summary>
/// <summary>
/// Compares two floating point numbers based on an epsilon zero tolerance.
/// </summary>
/// <param name="left">The first number to compare.</param>
/// <param name="right">The second number to compare.</param>
/// <returns><c>true</c> if <paramref name="left"/> is within epsilon of <paramref name="right"/>; otherwise, <c>false</c>.</returns>
/// <summary>
/// Compares two floating point numbers based on an epsilon zero tolerance.
/// </summary>
/// <param name="left">The first number to compare.</param>
/// <param name="right">The second number to compare.</param>
/// <param name="epsilon">The epsilon value to use for zero tolerance.</param>
/// <returns><c>true</c> if <paramref name="left"/> is within epsilon of <paramref name="right"/>; otherwise, <c>false</c>.</returns>
/// <summary>
/// Swaps two items.
/// </summary>
/// <typeparam name="T">The type of the items to swap.</typeparam>
/// <param name="left">The first item to swap.</param>
/// <param name="right">The second item to swap.</param>
/// <summary>
/// Does something with arrays.
/// </summary>
/// <typeparam name="T">Most likely the type of elements in the array.</typeparam>
/// <param name="value">Who knows what this is for.</param>
/// <param name="count">Probably the length of the array.</param>
/// <returns>An array of who knows what.</returns>
//throw new NotImplementedException();
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btAxisSweep3_getHandle(IntPtr obj, ushort index);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btAxisSweep3_processAllOverlappingPairs(IntPtr obj, IntPtr callback);
//throw new NotImplementedException();
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr bt32BitAxisSweep3_getHandle(IntPtr obj, uint index);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void bt32BitAxisSweep3_processAllOverlappingPairs(IntPtr obj, IntPtr callback);
// Can't delete broadphase, because it is referenced by a world,
// tell the world to clean up the broadphase later.
//return new BroadphaseProxy(native);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btCollisionAlgorithmConstructionInfo_getDispatcher1(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btCollisionAlgorithmConstructionInfo_getManifold(IntPtr obj);
/*
// Is the object added to a world?
//System.Diagnostics.Debugger.Break();
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btCollisionObject_getCollisionShape(IntPtr obj);
/*
//Marshal.WriteInt32(dataBuffer, IntPtr.Size + sizeof(int), 0); //padding
// need to transform normal into worldspace
//caller already does the filter on the m_closestHitFraction
// need to transform normal into worldspace
//caller already does the filter on the m_closestHitFraction
// need to transform normal into worldspace
//used to calculate hitPointWorld from hitFraction
// keep track of shapes already serialized
// serialize all collision objects
// Clear IDebugDraw wrapper
//btIDebugDrawer_delete(btCollisionWorld_getDebugDrawer(_native));
// Create IDebugDraw wrapper, remember to delete it
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btCompoundShapeChild_getChildShape(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btConvex2dConvex2dAlgorithm_CreateFunc_getPdSolver(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btConvex2dConvex2dAlgorithm_CreateFunc_getSimplexSolver(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btConvex2dShape_getChildShape(IntPtr obj);
/*
/* public void OptimizeConvexHull()
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btConvexHullShape_new2(Vector3[] points);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btConvexHullShape_new3(Vector3[] points, int numPoints);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btConvexHullShape_new4(Vector3[] points, int numPoints, int stride);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btConvexHullShape_optimizeConvexHull(IntPtr obj);
//	[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//    static extern void btConvexHullShape_project(IntPtr obj, [In] ref Matrix trans, [In] ref Vector3 dir, [Out] out float minProj, [Out] out float maxProj, [Out] out Vector3 witnesPtMin, [Out] out Vector3 witnesPtMax);
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btFace_getIndices(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btFace_getPlane(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btFace_setIndices(IntPtr obj, AlignedObjectArray value);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btFace_setPlane(IntPtr obj, IntPtr value);
//AlignedFaceArray _faces;
/*
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btConvexShape_batchedUnitVectorGetSupportingVertexWithoutMargin(IntPtr obj, IntPtr vectors, IntPtr supportVerticesOut, int numVectors);
/*
/*
/*
/*
/*
/*
/*
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btDbvt_collideKDOP(IntPtr root, [In] ref Vector3 normals, IntPtr offsets, int count, IntPtr policy);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btDbvt_collideOCL(IntPtr root, [In] ref Vector3 normals, IntPtr offsets, [In] ref Vector3 sortaxis, int count, IntPtr policy);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btDbvt_collideOCL2(IntPtr root, [In] ref Vector3 normals, IntPtr offsets, [In] ref Vector3 sortaxis, int count, IntPtr policy, bool fullsort);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btDbvt_collideTT(IntPtr obj, IntPtr root0, IntPtr root1, IntPtr policy);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btDbvt_collideTTpersistentStack(IntPtr obj, IntPtr root0, IntPtr root1, IntPtr policy);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btDbvt_collideTU(IntPtr root, IntPtr policy);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btDbvt_collideTV(IntPtr obj, IntPtr root, IntPtr volume, IntPtr policy);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btDbvt_enumLeaves(IntPtr root, IntPtr policy);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btDbvt_enumNodes(IntPtr root, IntPtr policy);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btDbvt_rayTest(IntPtr root, [In] ref Vector3 rayFrom, [In] ref Vector3 rayTo, IntPtr policy);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btDbvt_rayTestInternal(IntPtr obj, IntPtr root, [In] ref Vector3 rayFrom, [In] ref Vector3 rayTo, [In] ref Vector3 rayDirectionInverse, uint[] signs, float lambda_max, [In] ref Vector3 aabbMin, [In] ref Vector3 aabbMax, IntPtr policy);
/*
/*
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btDbvtBroadphase_getPaircache(IntPtr obj);
/*
/*
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btStorageResultWrapper_new();
/*
// Can't delete dispatcher, because it is referenced by a world,
// tell the world to clean up the broadphase later.
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr getGContactAddedCallback();
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btMultimaterialTriangleMeshShape_getMaterialProperties(IntPtr obj, int partID, int triIndex);
/*
// abstract
/*
/*
//: TypedObject
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr getGContactDestroyedCallback();
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr getGContactProcessedCallback();
/*
/*
/*
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btQuantizedBvh_quantize(IntPtr obj, IntPtr out, [In] ref Vector3 point, int isMax);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btQuantizedBvh_quantizeWithClamp(IntPtr obj, IntPtr out, [In] ref Vector3 point2, int isMax);
// same sign
// Backface, skip check
// Now we have the intersection point on the plane, we'll see if it's inside the triangle
// Add an epsilon as a tolerance for the raycast,
// in case the ray hits exacly on the edge of the triangle.
// It must be scaled for the triangle size.
//@BP Mod
// Triangle normal isn't normalized
//@BP Mod - Allow for unflipped normal when raycasting against backfaces
/*
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//[return: MarshalAs(UnmanagedType.I1)]
//static extern bool btSimpleBroadphase_aabbOverlap(IntPtr proxy0, IntPtr proxy1);
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btSimulationIslandManager_IslandCallback_processIsland(IntPtr obj, IntPtr bodies, int numBodies, IntPtr manifolds, int numManifolds, int islandId);
/*
// abstract
/*
// TODO: link _indexedMeshArray to _meshes
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btTriangleInfoMap_deSerialize(IntPtr obj, IntPtr data);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btUniformScalingShape_getChildShape(IntPtr obj);
/*
/*
//rayTo = cb.From;
//gDebugDraw.drawLine(tr(centroid),tr(centroid+normal),btVector3(1,0,0));
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btGImpactShapeInterface_getChildShape(IntPtr obj, int index);
/*
/*
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern int btPrimitiveTriangle_clip_triangle(IntPtr obj, IntPtr other, [Out] out Vector3 clipped_points);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btTriangleShapeEx_new3(IntPtr other);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btTriangleShapeEx_applyTransform(IntPtr obj, [In] ref Matrix t);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btTriangleShapeEx_buildTriPlane(IntPtr obj, [Out] out Vector4 plane);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//[return: MarshalAs(UnmanagedType.I1)]
//static extern bool btTriangleShapeEx_overlap_test_conservative(IntPtr obj, IntPtr other);
/*
/*
// padding
/*
// No actions have been added
/*
/*
/*
/*
/*
/*
/*
/*
//UnityEngine.Debug.Log("Created " + GCHandle.ToIntPtr(handle).ToInt64());
//UnityEngine.Debug.Log("Intptr" + bgActionInterface_getManagedWrapperPntr(_native));
//changed these so they are static fuctions and have MonoPInvokeCallback decorator so they work from iOS (uses AOT)
//UnityEngine.Debug.Log("callback dd yes!");
//changed these so they are static fuctions and have MonoPInvokeCallback decorator so they work from iOS (uses AOT)
//UnityEngine.Debug.Log("Callback yes!! " + iaPtrThis.ToInt64());
//UnityEngine.Debug.Log("Dispose 1");
//UnityEngine.Debug.Log("Dispose 2");
//UnityEngine.Debug.Log("Dispose 3");
//??
//printf("touching %f\n", dist);
//manifold.ClearManifold();
//	printf("m_touchingNormal = %f,%f,%f\n",m_touchingNormal[0],m_touchingNormal[1],m_touchingNormal[2]);
// phase 1: up
/* FIXME: Handle penetration properly */
// Only modify the position if the hit was a slope and not a wall or ceiling.
// we moved up only a fraction of the step height
/*
//			printf("parComponent=%f,%f,%f\n",parComponent[0],parComponent[1],parComponent[2]);
//			printf("perpComponent=%f,%f,%f\n",perpComponent[0],perpComponent[1],perpComponent[2]);
//		printf("movementLength don't normalize a zero vector\n");
//	printf("originalDir=%f,%f,%f\n",originalDir[0],originalDir[1],originalDir[2]);
// phase 2: forward and strafe
//	printf("distance2=%f\n",distance2);
//interferes with step movement
//UpdateTargetPositionBasedOnCollision(ref m_touchingNormal, 0.0f, 1.0f);
// we moved only a fraction
/* See Quake2: "If velocity is against original velocity, stop ead to avoid tiny oscilations in sloping corners." */
//				printf("currentDir: don't normalize a zero vector\n");
// we moved whole way
//	if (callback.m_closestHitFraction == 0.f)
//		break;
// phase 3: down
/*float additionalDownStep = (m_wasOnGround && !onGround()) ? m_stepHeight : 0.0;
//set double test for 2x the step drop, to check for a large drop vs small drop
//test a double fall height, to see if the character should interpolate it's fall (full) or not (partial)
// this works....
//test a double fall height, to see if the character should interpolate it's fall (large) or not (small)
//redo the velocity calculation when falling a small amount, for fast stairs motion
//for larger falls, use the smoother/slower interpolated movement by not touching the target position
//re-run previous tests
// we dropped a fraction of the height -> hit floor
//printf("hitpoint: %g - pos %g\n", callback.m_hitPointWorld.getY(), m_currentPosition.getY());
//due to errors in the closestHitFraction variable when used with large polygons, calculate the hit fraction manually
// we dropped the full height
//undo previous target change
//printf("full drop - %g, %g\n", m_currentPosition.getY(), m_targetPosition.getY());
// use walk direction by default, legacy behavior
// 3G acceleration.
// Terminal velocity of a sky diver in m/s.
// ?
///btActionInterface interface
///btActionInterface interface
//	printf("setVelocity!\n");
//	printf("  interval: %f\n", timeInterval);
//	printf("  velocity: (%f, %f, %f)\n",
//	    velocity.x(), velocity.y(), velocity.z());
//clear pair cache
//			printf("character could not recover from penetration = %d\n", numPenetrationLoops);
// quick check...
//		printf("\n");
// no motion
// Update fall velocity.
//	printf("walkDirection(%f,%f,%f)\n",walkDirection[0],walkDirection[1],walkDirection[2]);
//	printf("walkSpeed=%f\n",walkSpeed);
//printf("  time: %f", m_velocityTimeInterval);
// still have some time left for moving!
// how far will we move while we are moving?
// printf("  dtMoving: %f", dtMoving);
// okay, step
//currently no jumping.
//Matrix xform;
//m_rigidBody.getMotionState().getWorldTransform (out xform);
//Vector3 up = xform.Up;
//up.Normalize ();
//float magnitude = (1.0f/m_rigidBody.getInvMass()) * 8.0f;
//m_rigidBody.applyCentralImpulse (up * magnitude);
/// The max slope determines the maximum angle that the controller can walk up.
/// The slope angle is measured in radians.
//is also in m_ghostObject, but it needs to be convex, so we store it here to avoid upcast
// Slope angle that is set (used for returning the exact value)
// Cosine equivalent of m_maxSlopeRadians (calculated once when set, for optimization)
//@todo: remove this and fix the code
///this is the desired walk direction, set by the user
//some internal variables
///keep track of the contact manifolds
///@todo Interact with dynamic objects,
///Ride kinematicly animated platforms properly
///More realistic (or maybe just a config option) falling
/// -> Should integrate falling velocity manually and use that in stepDown()
///Support jumping
///Support ducking
// need to transform normal into worldspace
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//[return: MarshalAs(UnmanagedType.I1)]
//static extern bool btMLCPSolverInterface_solveMLCP(IntPtr obj, IntPtr A, IntPtr b, IntPtr x, IntPtr lo, IntPtr hi, IntPtr limitDependency, int numIterations);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//[return: MarshalAs(UnmanagedType.I1)]
//static extern bool btMLCPSolverInterface_solveMLCP2(IntPtr obj, IntPtr A, IntPtr b, IntPtr x, IntPtr lo, IntPtr hi, IntPtr limitDependency, int numIterations, bool useSparsity);
/*if (RigidBody.MotionState != null)
// calculate j that moves us to zero relative velocity
//debug wheels (cylinders)
///@todo for driving on dynamic/movable objects!;
/////wheel.RaycastInfo.GroundObject = object;
//clamp on max suspension travel
//put wheel info as in rest position
//wheel.ContactFriction = 0;
//todo: move this into proper structure
//calculate the impulse, so that the wheels don't move sidewards
//collapse all those loops into one!
//switch between active rolling (throttle), braking and non-active rolling friction (no throttle/break)
//wheel.EngineForce* timeStep;
// apply the impulses
// fix. It only worked if car's up was along Y - VT.
//Vector4 vChassisWorldUp = RigidBody.CenterOfMassTransform.get_Columns(indexUpAxis);
//apply friction impulse on the ground
//	Spring
// Damper
// RESULT
// Simulate suspension
//float depth = 
//apply suspension force
//damping of rotation when not in contact
//up = Vector3.Cross(right, fwd);
//up.Normalize();
//rotate around steering over the wheelAxleWS
//	RayResultCallback& resultCallback;
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btRigidBody_getConstraintRef(IntPtr obj, int index);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern int btRigidBody_getNumConstraintRefs(IntPtr obj);
//public int Padding;
/*
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btSequentialImpulseConstraintSolver_getActiveConstraintRowSolverGeneric(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btSequentialImpulseConstraintSolver_getActiveConstraintRowSolverLowerLimit(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btSequentialImpulseConstraintSolver_getScalarConstraintRowSolverGeneric(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btSequentialImpulseConstraintSolver_getScalarConstraintRowSolverLowerLimit(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btSequentialImpulseConstraintSolver_getSSE2ConstraintRowSolverGeneric(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btSequentialImpulseConstraintSolver_getSSE2ConstraintRowSolverLowerLimit(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btSequentialImpulseConstraintSolver_getSSE4_1ConstraintRowSolverGeneric(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btSequentialImpulseConstraintSolver_getSSE4_1ConstraintRowSolverLowerLimit(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btSequentialImpulseConstraintSolver_setConstraintRowSolverGeneric(IntPtr obj, IntPtr rowSolver);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btSequentialImpulseConstraintSolver_setConstraintRowSolverLowerLimit(IntPtr obj, IntPtr rowSolver);
/*
/*
/*
/*
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btTypedConstraint_getFixedBody();
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btTypedConstraint_getRigidBodyA(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btTypedConstraint_getRigidBodyB(IntPtr obj);
//ClientInfo = IntPtr.Zero;
//ClippedInvContactDotSuspension = 0;
//WheelsSuspensionForce = 0;
//SuspensionRelativeVelocity = 0;
//SkidInfo = 0;
// Not in contact : position wheel in a nice (rest length) position
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btMultiBodyConstraint_getMultiBodyA(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btMultiBodyConstraint_getMultiBodyB(IntPtr obj);
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btMultiBodyDynamicsWorld_addMultiBody2(IntPtr obj, IntPtr body, short group);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btMultiBodyDynamicsWorld_getMultiBody(IntPtr obj, int mbIndex);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btMultiBodyDynamicsWorld_getMultiBodyConstraint(IntPtr obj, int constraintIndex);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern int btMultiBodyDynamicsWorld_getNumMultibodies(IntPtr obj);
/*
/*
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern eFeatherstoneJointType btMultibodyLink_getJointType(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btMultibodyLink_setAbsFrameLocVelocity(IntPtr obj, SpatialMotionVector value);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btMultibodyLink_setAbsFrameTotVelocity(IntPtr obj, SpatialMotionVector value);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btMultibodyLink_setJointType(IntPtr obj, eFeatherstoneJointType value);
/*
/*
/*
// find the matching memory dna data
// to the file being loaded. Fill the
// memory with the file data...
//_chunkPointerFixupArray.Add(strcData.BaseStream.Position);
//Console.WriteLine("skipped {0} {1} : {2:X}", element.Type.Name, element.Name.Name, strcData.BaseStream.Position);
//GetElement(arrayLen, lookupType, type, data, strcData);
// buffer offset util
// swap ptr sizes...
// swap endian...
// looking for the data's starting position
// and the start of SDNA decls
// read the DNA1 block and extract SDNA
// Some Bullet files are missing the DNA1 block
// In Blender it's DNA1 + ChunkUtils::getOffset() + SDNA + NAME
// In Bullet tests its SDNA + NAME
// Also no REND block, so exit now.
//Console.WriteLine("Failed to find DNA1+SDNA pair");
// _fileDna.Init will convert part of DNA file endianness to current CPU endianness if necessary
//Console.WriteLine("warning: fixing some broken DNA version");
//if ((verboseMode & FileVerboseMode.DumpDnaTypeDefinitions) == FileVerboseMode.DumpDnaTypeDefinitions)
//    _fileDna.DumpTypeDefinitions();
//Console.WriteLine ("Warning, file DNA is different than built in, performance is reduced. Best to re-export file with a matching version/platform");
//Console.WriteLine ("Warning, file DNA is newer than built in.");
//bool ignoreEndianFlag = false;
//swap(head, dataChunk, ignoreEndianFlag);
// Ouch! need to rebuild the struct
// Don't try to convert Link block data, just memcpy it. Other data can be converted.
//Console.WriteLine("Link found");
//_libPointers.Add(old, cur);
// && ((_flags & FileFlags.BitsVaries | FileFlags.VersionVaries) != 0))
//ResolvePointersMismatch();
//Console.WriteLine("skipping struct");
//throw new NotImplementedException();
//Console.WriteLine("Cannot fixup pointer at {0} from {1} to {2}!", ptrptr, *ptrptr, ptr);
//throw new NotImplementedException();
// export a simple type
/*
//_chunks[i].OldPtr
/*
/*
//_dataBlocks.push_back(dataBlock);
/*
//the parsing will convert to cpu endian
//Console.WriteLine("Building datablocks");
//Console.WriteLine("Chunk size = {0}", CHUNK_HEADER_LEN);
//Console.WriteLine("File chunk size = {0}", ChunkUtils.GetOffset(_flags));
//swapLen(dataPtr);
// One behind
// same as (BHEAD+DATA dependency)
//m_chunkPtrPtrMap.insert(dataChunk.oldPtr, dataChunk);
//swapLen(dataPtr);
/*
// float w = ReadSingle();
// QuantizedBvhData is parsed in C++, so we need to actually fix pointers
//throw new NotImplementedException();
//throw new NotImplementedException();
//now you could save the file in 'native' format using
//bulletFile.WriteFile("native.bullet");
//bulletFile.WriteFile(preSwapFilenameOut);
//bulletFile.DumpChunks(bulletFile->FileDna);
// Write(value.W);
//throw new NotImplementedException();
//ConvertConstraint(constraintData);
// if the file is saved in a
// different format, get the
// file's chunk size
// find second dim, if any
// SDNA
// NAME
// TYPE
// TLEN
// STRC
// build reverse lookups
// compare the file to memory
// this ptr should be the file data
// SDNA empty!
// Recurse in
// Structs containing non-equal structs are also non-equal
/*
//StridingMeshInterfaceData* interfaceData = CreateStridingMeshInterfaceData(&gimpactData->m_meshInterface)
//float collisionMargin = reader.ReadInt32();
// m_padding
//box.InitializePolyhedralFeatures();
// + new Vector3(collisionMargin);
//hullShape.InitializePolyhedralFeatures();
//bvh.DeserializeFloat(bvhPtr);
// those fields didn't exist and set to zero for pre-280 versions, so do a check here
/*
//long indices16 = meshReader.ReadPtr(meshOffset + MeshPartData.Offset("Indices16"));
//meshPart.Dispose();
//TODO: _allocatedbtStridingMeshInterfaceDatas
//return btAlignedCollisionObjectArray_findLinearSearch(_native, item._native) != Count;
//btAlignedCollisionObjectArray_remove(itemPtr);
// Swap the last item with the item to be removed like Bullet does.
// TODO: implement AxisSweep3::Handle
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btCollisionWorld_addCollisionObject2(IntPtr obj, IntPtr collisionObject, short collisionFilterGroup);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btSoftRigidDynamicsWorld_addSoftBody2(IntPtr obj, IntPtr body, short collisionFilterGroup);
// Adjust the native pointer of existing children if the array was reallocated.
// Add the child to the backing store.
// Swap the last item with the item to be removed like Bullet does.
/*
//www.bulletphysics.com/
//, IDisposable
/*
//if (ObjectTable.Contains(debugDraw))
//    return ObjectTable.GetUnmanagedObject(debugDraw);
//GCHandle handle = GCHandle.Alloc(debugDrawer);
//IntPtr wrapper = btIDebugDrawWrapper_new(GCHandle.ToIntPtr(handle), IntPtr.Zero);
//ObjectTable.Add(debugDraw, wrapper);
//return wrapper;
//if (ObjectTable.Contains(debugDrawer)
//    return ObjectTable.GetObject<IDebugDraw^>(debugDrawer);
// Draw the ends
// Draw some additional lines
// distance
// XY 
// XZ
// YZ
// choose p in y-z plane
// set q = n x p
// choose p in x-y plane
// set q = n x p
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//[return: MarshalAs(UnmanagedType.I1)]
//static extern bool btGeometryUtil_isInside(IntPtr vertices, IntPtr planeNormal, float margin);
/*
//www.bulletphysics.com/
/*-------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------*/
//UnityEngine.Debug.Log("Created MoState" + GCHandle.ToIntPtr(handle).ToInt64());
//UnityEngine.Debug.Log("Get" + msPtr.ToInt64());
//UnityEngine.Debug.Log("Set" + msPtr.ToInt64());
//chunk->m_oldPtr);
//oldPtr;
//if we didn't pre-allocate a buffer, we need to create a contiguous buffer now
// header
// SDNA
// NAME
// TYPE
// TLEN
// STRC
// build reverse lookups
//don't serialize name twice
//serialize name string now
/*
/// <summary>
/// Represents a 4x4 mathematical matrix.
/// </summary>
//[TypeConverter(typeof(SlimMath.Design.MatrixConverter))]
/// <summary>
/// The size of the <see cref="SlimMath.Matrix"/> type, in bytes.
/// </summary>
/// <summary>
/// A <see cref="SlimMath.Matrix"/> with all of its components set to zero.
/// </summary>
/// <summary>
/// The identity <see cref="SlimMath.Matrix"/>.
/// </summary>
/// <summary>
/// Value at row 1 column 1 of the matrix.
/// </summary>
/// <summary>
/// Value at row 1 column 2 of the matrix.
/// </summary>
/// <summary>
/// Value at row 1 column 3 of the matrix.
/// </summary>
/// <summary>
/// Value at row 1 column 4 of the matrix.
/// </summary>
/// <summary>
/// Value at row 2 column 1 of the matrix.
/// </summary>
/// <summary>
/// Value at row 2 column 2 of the matrix.
/// </summary>
/// <summary>
/// Value at row 2 column 3 of the matrix.
/// </summary>
/// <summary>
/// Value at row 2 column 4 of the matrix.
/// </summary>
/// <summary>
/// Value at row 3 column 1 of the matrix.
/// </summary>
/// <summary>
/// Value at row 3 column 2 of the matrix.
/// </summary>
/// <summary>
/// Value at row 3 column 3 of the matrix.
/// </summary>
/// <summary>
/// Value at row 3 column 4 of the matrix.
/// </summary>
/// <summary>
/// Value at row 4 column 1 of the matrix.
/// </summary>
/// <summary>
/// Value at row 4 column 2 of the matrix.
/// </summary>
/// <summary>
/// Value at row 4 column 3 of the matrix.
/// </summary>
/// <summary>
/// Value at row 4 column 4 of the matrix.
/// </summary>
/// <summary>
/// Initializes a new instance of the <see cref="SlimMath.Matrix"/> struct.
/// </summary>
/// <param name="value">The value that will be assigned to all components.</param>
/// <summary>
/// Initializes a new instance of the <see cref="SlimMath.Matrix"/> struct.
/// </summary>
/// <param name="M11">The value to assign at row 1 column 1 of the matrix.</param>
/// <param name="M12">The value to assign at row 1 column 2 of the matrix.</param>
/// <param name="M13">The value to assign at row 1 column 3 of the matrix.</param>
/// <param name="M14">The value to assign at row 1 column 4 of the matrix.</param>
/// <param name="M21">The value to assign at row 2 column 1 of the matrix.</param>
/// <param name="M22">The value to assign at row 2 column 2 of the matrix.</param>
/// <param name="M23">The value to assign at row 2 column 3 of the matrix.</param>
/// <param name="M24">The value to assign at row 2 column 4 of the matrix.</param>
/// <param name="M31">The value to assign at row 3 column 1 of the matrix.</param>
/// <param name="M32">The value to assign at row 3 column 2 of the matrix.</param>
/// <param name="M33">The value to assign at row 3 column 3 of the matrix.</param>
/// <param name="M34">The value to assign at row 3 column 4 of the matrix.</param>
/// <param name="M41">The value to assign at row 4 column 1 of the matrix.</param>
/// <param name="M42">The value to assign at row 4 column 2 of the matrix.</param>
/// <param name="M43">The value to assign at row 4 column 3 of the matrix.</param>
/// <param name="M44">The value to assign at row 4 column 4 of the matrix.</param>
/// <summary>
/// Initializes a new instance of the <see cref="SlimMath.Matrix"/> struct.
/// </summary>
/// <param name="values">The values to assign to the components of the matrix. This must be an array with sixteen elements.</param>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="values"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="values"/> contains more or less than sixteen elements.</exception>
/// <summary>
/// Gets or sets the basis matrix for the rotation.
/// </summary>
/// <summary>
/// Gets or sets the first row in the matrix; that is M11, M12, M13, and M14.
/// </summary>
/// <summary>
/// Gets or sets the second row in the matrix; that is M21, M22, M23, and M24.
/// </summary>
/// <summary>
/// Gets or sets the third row in the matrix; that is M31, M32, M33, and M34.
/// </summary>
/// <summary>
/// Gets or sets the fourth row in the matrix; that is M41, M42, M43, and M44.
/// </summary>
/// <summary>
/// Gets or sets the first column in the matrix; that is M11, M21, M31, and M41.
/// </summary>
/// <summary>
/// Gets or sets the second column in the matrix; that is M12, M22, M32, and M42.
/// </summary>
/// <summary>
/// Gets or sets the third column in the matrix; that is M13, M23, M33, and M43.
/// </summary>
/// <summary>
/// Gets or sets the fourth column in the matrix; that is M14, M24, M34, and M44.
/// </summary>
/// <summary>
/// Gets or sets the translation of the matrix; that is M41, M42, and M43.
/// </summary>
/// <summary>
/// Gets or sets the scale of the matrix; that is M11, M22, and M33.
/// </summary>
/// <summary>
/// Gets a value indicating whether this instance is an identity matrix.
/// </summary>
/// <value>
/// <c>true</c> if this instance is an identity matrix; otherwise, <c>false</c>.
/// </value>
/// <summary>
/// Calculates the determinant of the matrix.
/// </summary>
/// <returns>The determinant of the matrix.</returns>
/// <summary>
/// Gets or sets the component at the specified index.
/// </summary>
/// <value>The value of the matrix component, depending on the index.</value>
/// <param name="index">The zero-based index of the component to access.</param>
/// <returns>The value of the component at the specified index.</returns>
/// <exception cref="System.ArgumentOutOfRangeException">Thrown when the <paramref name="index"/> is out of the range [0, 15].</exception>
/// <summary>
/// Gets or sets the component at the specified index.
/// </summary>
/// <value>The value of the matrix component, depending on the index.</value>
/// <param name="row">The row of the matrix to access.</param>
/// <param name="column">The column of the matrix to access.</param>
/// <returns>The value of the component at the specified index.</returns>
/// <exception cref="System.ArgumentOutOfRangeException">Thrown when the <paramref name="row"/> or <paramref name="column"/>is out of the range [0, 3].</exception>
/// <summary>
/// Negates a matrix.
/// </summary>
/// <summary>
/// Inverts the matrix.
/// </summary>
/// <summary>
/// Transposes the matrix.
/// </summary>
/// <summary>
/// Performs the exponential operation on a matrix.
/// </summary>
/// <param name="exponent">The exponent to raise the matrix to.</param>
/// <exception cref="System.ArgumentOutOfRangeException">Thrown when the <paramref name="exponent"/> is negative.</exception>
/// <summary>
/// Orthogonalizes the specified matrix.
/// </summary>
/// <remarks>
/// <para>Orthogonalization is the process of making all rows orthogonal to each other. This
/// means that any given row in the matrix will be orthogonal to any other given row in the
/// matrix.</para>
/// <para>Because this method uses the modified Gram-Schmidt process, the resulting matrix
/// tends to be numerically unstable. The numeric stability decreases according to the rows
/// so that the first row is the most stable and the last row is the least stable.</para>
/// <para>This operation is performed on the rows of the matrix rather than the columns.
/// If you wish for this operation to be performed on the columns, first transpose the
/// input and than transpose the output.</para>
/// </remarks>
/// <summary>
/// Orthonormalizes the specified matrix.
/// </summary>
/// <remarks>
/// <para>Orthonormalization is the process of making all rows and columns orthogonal to each
/// other and making all rows and columns of unit length. This means that any given row will
/// be orthogonal to any other given row and any given column will be orthogonal to any other
/// given column. Any given row will not be orthogonal to any given column. Every row and every
/// column will be of unit length.</para>
/// <para>Because this method uses the modified Gram-Schmidt process, the resulting matrix
/// tends to be numerically unstable. The numeric stability decreases according to the rows
/// so that the first row is the most stable and the last row is the least stable.</para>
/// <para>This operation is performed on the rows of the matrix rather than the columns.
/// If you wish for this operation to be performed on the columns, first transpose the
/// input and than transpose the output.</para>
/// </remarks>
/// <summary>
/// Decomposes a matrix into an orthonormalized matrix Q and a right traingular matrix R.
/// </summary>
/// <param name="Q">When the method completes, contains the orthonormalized matrix of the decomposition.</param>
/// <param name="R">When the method completes, contains the right triangular matrix of the decomposition.</param>
/// <summary>
/// Decomposes a matrix into a lower triangular matrix L and an orthonormalized matrix Q.
/// </summary>
/// <param name="L">When the method completes, contains the lower triangular matrix of the decomposition.</param>
/// <param name="Q">When the method completes, contains the orthonormalized matrix of the decomposition.</param>
/// <summary>
/// Decomposes a matrix into a scale, rotation, and translation.
/// </summary>
/// <param name="scale">When the method completes, contains the scaling component of the decomposed matrix.</param>
/// <param name="rotation">When the method completes, contains the rtoation component of the decomposed matrix.</param>
/// <param name="translation">When the method completes, contains the translation component of the decomposed matrix.</param>
/// <remarks>
/// This method is designed to decompose an SRT transformation matrix only.
/// </remarks>
//Source: Unknown
//References: http://www.gamedev.net/community/forums/topic.asp?topic_id=441695
//Get the translation.
//Scaling is the length of the rows.
//If any of the scaling factors are zero, than the rotation matrix can not exist.
//The rotation is the left over matrix after dividing out the scaling.
/// <summary>
/// Exchanges two rows in the matrix.
/// </summary>
/// <param name="firstRow">The first row to exchange. This is an index of the row starting at zero.</param>
/// <param name="secondRow">The second row to exchange. This is an index of the row starting at zero.</param>
/// <summary>
/// 
/// </summary>
/// <param name="firstColumn"></param>
/// <param name="secondColumn"></param>
/// <summary>
/// Creates an array containing the elements of the matrix.
/// </summary>
/// <returns>A sixteen-element array containing the components of the matrix.</returns>
/// <summary>
/// Determines the sum of two matrices.
/// </summary>
/// <param name="left">The first matrix to add.</param>
/// <param name="right">The second matrix to add.</param>
/// <param name="result">When the method completes, contains the sum of the two matrices.</param>
/// <summary>
/// Determines the sum of two matrices.
/// </summary>
/// <param name="left">The first matrix to add.</param>
/// <param name="right">The second matrix to add.</param>
/// <returns>The sum of the two matrices.</returns>
/// <summary>
/// Determines the difference between two matrices.
/// </summary>
/// <param name="left">The first matrix to subtract.</param>
/// <param name="right">The second matrix to subtract.</param>
/// <param name="result">When the method completes, contains the difference between the two matrices.</param>
/// <summary>
/// Determines the difference between two matrices.
/// </summary>
/// <param name="left">The first matrix to subtract.</param>
/// <param name="right">The second matrix to subtract.</param>
/// <returns>The difference between the two matrices.</returns>
/// <summary>
/// Scales a matrix by the given value.
/// </summary>
/// <param name="left">The matrix to scale.</param>
/// <param name="scalar">The amount by which to scale.</param>
/// <param name="result">When the method completes, contains the scaled matrix.</param>
/// <summary>
/// Scales a matrix by the given value.
/// </summary>
/// <param name="left">The matrix to scale.</param>
/// <param name="scalar">The amount by which to scale.</param>
/// <returns>The scaled matrix.</returns>
/// <summary>
/// Determines the product of two matrices.
/// </summary>
/// <param name="left">The first matrix to multiply.</param>
/// <param name="right">The second matrix to multiply.</param>
/// <param name="result">The product of the two matrices.</param>
/// <summary>
/// Determines the product of two matrices.
/// </summary>
/// <param name="left">The first matrix to multiply.</param>
/// <param name="right">The second matrix to multiply.</param>
/// <returns>The product of the two matrices.</returns>
/// <summary>
/// Scales a matrix by the given value.
/// </summary>
/// <param name="left">The matrix to scale.</param>
/// <param name="scalar">The amount by which to scale.</param>
/// <param name="result">When the method completes, contains the scaled matrix.</param>
/// <summary>
/// Scales a matrix by the given value.
/// </summary>
/// <param name="left">The matrix to scale.</param>
/// <param name="scalar">The amount by which to scale.</param>
/// <returns>The scaled matrix.</returns>
/// <summary>
/// Determines the quotient of two matrices.
/// </summary>
/// <param name="left">The first matrix to divide.</param>
/// <param name="right">The second matrix to divide.</param>
/// <param name="result">When the method completes, contains the quotient of the two matrices.</param>
/// <summary>
/// Determines the quotient of two matrices.
/// </summary>
/// <param name="left">The first matrix to divide.</param>
/// <param name="right">The second matrix to divide.</param>
/// <returns>The quotient of the two matrices.</returns>
/// <summary>
/// Performs the exponential operation on a matrix.
/// </summary>
/// <param name="value">The matrix to perform the operation on.</param>
/// <param name="exponent">The exponent to raise the matrix to.</param>
/// <param name="result">When the method completes, contains the exponential matrix.</param>
/// <exception cref="System.ArgumentOutOfRangeException">Thrown when the <paramref name="exponent"/> is negative.</exception>
//Source: http://rosettacode.org
//Refrence: http://rosettacode.org/wiki/Matrix-exponentiation_operator
/// <summary>
/// Performs the exponential operation on a matrix.
/// </summary>
/// <param name="value">The matrix to perform the operation on.</param>
/// <param name="exponent">The exponent to raise the matrix to.</param>
/// <returns>The exponential matrix.</returns>
/// <exception cref="System.ArgumentOutOfRangeException">Thrown when the <paramref name="exponent"/> is negative.</exception>
/// <summary>
/// Negates a matrix.
/// </summary>
/// <param name="value">The matrix to be negated.</param>
/// <param name="result">When the method completes, contains the negated matrix.</param>
/// <summary>
/// Negates a matrix.
/// </summary>
/// <param name="value">The matrix to be negated.</param>
/// <returns>The negated matrix.</returns>
/// <summary>
/// Performs a linear interpolation between two matricies.
/// </summary>
/// <param name="start">Start matrix.</param>
/// <param name="end">End matrix.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <param name="result">When the method completes, contains the linear interpolation of the two matricies.</param>
/// <remarks>
/// This method performs the linear interpolation based on the following formula.
/// <code>start + (end - start) * amount</code>
/// Passing <paramref name="amount"/> a value of 0 will cause <paramref name="start"/> to be returned; a value of 1 will cause <paramref name="end"/> to be returned. 
/// </remarks>
/// <summary>
/// Performs a linear interpolation between two matricies.
/// </summary>
/// <param name="start">Start matrix.</param>
/// <param name="end">End matrix.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <returns>The linear interpolation of the two matrices.</returns>
/// <remarks>
/// This method performs the linear interpolation based on the following formula.
/// <code>start + (end - start) * amount</code>
/// Passing <paramref name="amount"/> a value of 0 will cause <paramref name="start"/> to be returned; a value of 1 will cause <paramref name="end"/> to be returned. 
/// </remarks>
/// <summary>
/// Performs a cubic interpolation between two matricies.
/// </summary>
/// <param name="start">Start matrix.</param>
/// <param name="end">End matrix.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <param name="result">When the method completes, contains the cubic interpolation of the two matrices.</param>
/// <summary>
/// Performs a cubic interpolation between two matrices.
/// </summary>
/// <param name="start">Start matrix.</param>
/// <param name="end">End matrix.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <returns>The cubic interpolation of the two matrices.</returns>
/// <summary>
/// Calculates the transpose of the specified matrix.
/// </summary>
/// <param name="value">The matrix whose transpose is to be calculated.</param>
/// <param name="result">When the method completes, contains the transpose of the specified matrix.</param>
/// <summary>
/// Calculates the transpose of the specified matrix.
/// </summary>
/// <param name="value">The matrix whose transpose is to be calculated.</param>
/// <returns>The transpose of the specified matrix.</returns>
/// <summary>
/// Calculates the inverse of the specified matrix.
/// </summary>
/// <param name="value">The matrix whose inverse is to be calculated.</param>
/// <param name="result">When the method completes, contains the inverse of the specified matrix.</param>
/// <summary>
/// Calculates the inverse of the specified matrix.
/// </summary>
/// <param name="value">The matrix whose inverse is to be calculated.</param>
/// <returns>The inverse of the specified matrix.</returns>
/// <summary>
/// Orthogonalizes the specified matrix.
/// </summary>
/// <param name="value">The matrix to orthogonalize.</param>
/// <param name="result">When the method completes, contains the orthogonalized matrix.</param>
/// <remarks>
/// <para>Orthogonalization is the process of making all rows orthogonal to each other. This
/// means that any given row in the matrix will be orthogonal to any other given row in the
/// matrix.</para>
/// <para>Because this method uses the modified Gram-Schmidt process, the resulting matrix
/// tends to be numerically unstable. The numeric stability decreases according to the rows
/// so that the first row is the most stable and the last row is the least stable.</para>
/// <para>This operation is performed on the rows of the matrix rather than the columns.
/// If you wish for this operation to be performed on the columns, first transpose the
/// input and than transpose the output.</para>
/// </remarks>
//Uses the modified Gram-Schmidt process.
//q1 = m1
//q2 = m2 - ((q1 ⋅ m2) / (q1 ⋅ q1)) * q1
//q3 = m3 - ((q1 ⋅ m3) / (q1 ⋅ q1)) * q1 - ((q2 ⋅ m3) / (q2 ⋅ q2)) * q2
//q4 = m4 - ((q1 ⋅ m4) / (q1 ⋅ q1)) * q1 - ((q2 ⋅ m4) / (q2 ⋅ q2)) * q2 - ((q3 ⋅ m4) / (q3 ⋅ q3)) * q3
//By separating the above algorithm into multiple lines, we actually increase accuracy.
/// <summary>
/// Orthogonalizes the specified matrix.
/// </summary>
/// <param name="value">The matrix to orthogonalize.</param>
/// <returns>The orthogonalized matrix.</returns>
/// <remarks>
/// <para>Orthogonalization is the process of making all rows orthogonal to each other. This
/// means that any given row in the matrix will be orthogonal to any other given row in the
/// matrix.</para>
/// <para>Because this method uses the modified Gram-Schmidt process, the resulting matrix
/// tends to be numerically unstable. The numeric stability decreases according to the rows
/// so that the first row is the most stable and the last row is the least stable.</para>
/// <para>This operation is performed on the rows of the matrix rather than the columns.
/// If you wish for this operation to be performed on the columns, first transpose the
/// input and than transpose the output.</para>
/// </remarks>
/// <summary>
/// Orthonormalizes the specified matrix.
/// </summary>
/// <param name="value">The matrix to orthonormalize.</param>
/// <param name="result">When the method completes, contains the orthonormalized matrix.</param>
/// <remarks>
/// <para>Orthonormalization is the process of making all rows and columns orthogonal to each
/// other and making all rows and columns of unit length. This means that any given row will
/// be orthogonal to any other given row and any given column will be orthogonal to any other
/// given column. Any given row will not be orthogonal to any given column. Every row and every
/// column will be of unit length.</para>
/// <para>Because this method uses the modified Gram-Schmidt process, the resulting matrix
/// tends to be numerically unstable. The numeric stability decreases according to the rows
/// so that the first row is the most stable and the last row is the least stable.</para>
/// <para>This operation is performed on the rows of the matrix rather than the columns.
/// If you wish for this operation to be performed on the columns, first transpose the
/// input and than transpose the output.</para>
/// </remarks>
//Uses the modified Gram-Schmidt process.
//Because we are making unit vectors, we can optimize the math for orthogonalization
//and simplify the projection operation to remove the division.
//q1 = m1 / |m1|
//q2 = (m2 - (q1 ⋅ m2) * q1) / |m2 - (q1 ⋅ m2) * q1|
//q3 = (m3 - (q1 ⋅ m3) * q1 - (q2 ⋅ m3) * q2) / |m3 - (q1 ⋅ m3) * q1 - (q2 ⋅ m3) * q2|
//q4 = (m4 - (q1 ⋅ m4) * q1 - (q2 ⋅ m4) * q2 - (q3 ⋅ m4) * q3) / |m4 - (q1 ⋅ m4) * q1 - (q2 ⋅ m4) * q2 - (q3 ⋅ m4) * q3|
//By separating the above algorithm into multiple lines, we actually increase accuracy.
/// <summary>
/// Orthonormalizes the specified matrix.
/// </summary>
/// <param name="value">The matrix to orthonormalize.</param>
/// <returns>The orthonormalized matrix.</returns>
/// <remarks>
/// <para>Orthonormalization is the process of making all rows and columns orthogonal to each
/// other and making all rows and columns of unit length. This means that any given row will
/// be orthogonal to any other given row and any given column will be orthogonal to any other
/// given column. Any given row will not be orthogonal to any given column. Every row and every
/// column will be of unit length.</para>
/// <para>Because this method uses the modified Gram-Schmidt process, the resulting matrix
/// tends to be numerically unstable. The numeric stability decreases according to the rows
/// so that the first row is the most stable and the last row is the least stable.</para>
/// <para>This operation is performed on the rows of the matrix rather than the columns.
/// If you wish for this operation to be performed on the columns, first transpose the
/// input and than transpose the output.</para>
/// </remarks>
/// <summary>
/// Brings the matrix into upper triangular form using elementry row operations.
/// </summary>
/// <param name="value">The matrix to put into upper triangular form.</param>
/// <param name="result">When the method completes, contains the upper triangular matrix.</param>
/// <remarks>
/// If the matrix is not invertable (i.e. its determinant is zero) than the result of this
/// method may produce Single.Nan and Single.Inf values. When the matrix represents a system
/// of linear equations, than this often means that either no solution exists or an infinite
/// number of solutions exist.
/// </remarks>
//Adapted from the row echelon code
/// <summary>
/// Brings the matrix into upper triangular form using elementry row operations.
/// </summary>
/// <param name="value">The matrix to put into upper triangular form.</param>
/// <returns>The upper triangular matrix.</returns>
/// <remarks>
/// If the matrix is not invertable (i.e. its determinant is zero) than the result of this
/// method may produce Single.Nan and Single.Inf values. When the matrix represents a system
/// of linear equations, than this often means that either no solution exists or an infinite
/// number of solutions exist.
/// </remarks>
/// <summary>
/// Brings the matrix into lower triangular form using elementry row operations.
/// </summary>
/// <param name="value">The matrix to put into lower triangular form.</param>
/// <param name="result">When the method completes, contains the lower triangular matrix.</param>
/// <remarks>
/// If the matrix is not invertable (i.e. its determinant is zero) than the result of this
/// method may produce Single.Nan and Single.Inf values. When the matrix represents a system
/// of linear equations, than this often means that either no solution exists or an infinite
/// number of solutions exist.
/// </remarks>
//Adapted from the row echelon code
/// <summary>
/// Brings the matrix into lower triangular form using elementry row operations.
/// </summary>
/// <param name="value">The matrix to put into lower triangular form.</param>
/// <returns>The lower triangular matrix.</returns>
/// <remarks>
/// If the matrix is not invertable (i.e. its determinant is zero) than the result of this
/// method may produce Single.Nan and Single.Inf values. When the matrix represents a system
/// of linear equations, than this often means that either no solution exists or an infinite
/// number of solutions exist.
/// </remarks>
/// <summary>
/// Brings the matrix into row echelon form using elementry row operations;
/// </summary>
/// <param name="value">The matrix to put into row echelon form.</param>
/// <param name="result">When the method completes, contains the row echelon form of the matrix.</param>
//Source: Wikipedia psuedo code
//Reference: http://en.wikipedia.org/wiki/Row_echelon_form#Pseudocode
/// <summary>
/// Brings the matrix into row echelon form using elementry row operations;
/// </summary>
/// <param name="value">The matrix to put into row echelon form.</param>
/// <returns>When the method completes, contains the row echelon form of the matrix.</returns>
/// <summary>
/// Brings the matrix into reduced row echelon form using elementry row operations.
/// </summary>
/// <param name="value">The matrix to put into reduced row echelon form.</param>
/// <param name="augment">The fifth column of the matrix.</param>
/// <param name="result">When the method completes, contains the resultant matrix after the operation.</param>
/// <param name="augmentResult">When the method completes, contains the resultant fifth column of the matrix.</param>
/// <remarks>
/// <para>The fifth column is often called the agumented part of the matrix. This is because the fifth
/// column is really just an extension of the matrix so that there is a place to put all of the
/// non-zero components after the operation is complete.</para>
/// <para>Often times the resultant matrix will the identity matrix or a matrix similar to the identity
/// matrix. Sometimes, however, that is not possible and numbers other than zero and one may appear.</para>
/// <para>This method can be used to solve systems of linear equations. Upon completion of this method,
/// the <paramref name="augmentResult"/> will contain the solution for the system. It is up to the user
/// to analyze both the input and the result to determine if a solution really exists.</para>
/// </remarks>
//Source: http://rosettacode.org
//Reference: http://rosettacode.org/wiki/Reduced_row_echelon_form
/// <summary>
/// Creates a spherical billboard that rotates around a specified object position.
/// </summary>
/// <param name="objectPosition">The position of the object around which the billboard will rotate.</param>
/// <param name="cameraPosition">The position of the camera.</param>
/// <param name="cameraUpVector">The up vector of the camera.</param>
/// <param name="cameraForwardVector">The forward vector of the camera.</param>
/// <param name="result">When the method completes, contains the created billboard matrix.</param>
/// <summary>
/// Creates a spherical billboard that rotates around a specified object position.
/// </summary>
/// <param name="objectPosition">The position of the object around which the billboard will rotate.</param>
/// <param name="cameraPosition">The position of the camera.</param>
/// <param name="cameraUpVector">The up vector of the camera.</param>
/// <param name="cameraForwardVector">The forward vector of the camera.</param>
/// <returns>The created billboard matrix.</returns>
/// <summary>
/// Creates a left-handed, look-at matrix.
/// </summary>
/// <param name="eye">The position of the viewer's eye.</param>
/// <param name="target">The camera look-at target.</param>
/// <param name="up">The camera's up vector.</param>
/// <param name="result">When the method completes, contains the created look-at matrix.</param>
/// <summary>
/// Creates a left-handed, look-at matrix.
/// </summary>
/// <param name="eye">The position of the viewer's eye.</param>
/// <param name="target">The camera look-at target.</param>
/// <param name="up">The camera's up vector.</param>
/// <returns>The created look-at matrix.</returns>
/// <summary>
/// Creates a right-handed, look-at matrix.
/// </summary>
/// <param name="eye">The position of the viewer's eye.</param>
/// <param name="target">The camera look-at target.</param>
/// <param name="up">The camera's up vector.</param>
/// <param name="result">When the method completes, contains the created look-at matrix.</param>
/// <summary>
/// Creates a right-handed, look-at matrix.
/// </summary>
/// <param name="eye">The position of the viewer's eye.</param>
/// <param name="target">The camera look-at target.</param>
/// <param name="up">The camera's up vector.</param>
/// <returns>The created look-at matrix.</returns>
/// <summary>
/// Creates a left-handed, orthographic projection matrix.
/// </summary>
/// <param name="width">Width of the viewing volume.</param>
/// <param name="height">Height of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <param name="result">When the method completes, contains the created projection matrix.</param>
/// <summary>
/// Creates a left-handed, orthographic projection matrix.
/// </summary>
/// <param name="width">Width of the viewing volume.</param>
/// <param name="height">Height of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <returns>The created projection matrix.</returns>
/// <summary>
/// Creates a right-handed, orthographic projection matrix.
/// </summary>
/// <param name="width">Width of the viewing volume.</param>
/// <param name="height">Height of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <param name="result">When the method completes, contains the created projection matrix.</param>
/// <summary>
/// Creates a right-handed, orthographic projection matrix.
/// </summary>
/// <param name="width">Width of the viewing volume.</param>
/// <param name="height">Height of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <returns>The created projection matrix.</returns>
/// <summary>
/// Creates a left-handed, customized orthographic projection matrix.
/// </summary>
/// <param name="left">Minimum x-value of the viewing volume.</param>
/// <param name="right">Maximum x-value of the viewing volume.</param>
/// <param name="bottom">Minimum y-value of the viewing volume.</param>
/// <param name="top">Maximum y-value of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <param name="result">When the method completes, contains the created projection matrix.</param>
/// <summary>
/// Creates a left-handed, customized orthographic projection matrix.
/// </summary>
/// <param name="left">Minimum x-value of the viewing volume.</param>
/// <param name="right">Maximum x-value of the viewing volume.</param>
/// <param name="bottom">Minimum y-value of the viewing volume.</param>
/// <param name="top">Maximum y-value of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <returns>The created projection matrix.</returns>
/// <summary>
/// Creates a right-handed, customized orthographic projection matrix.
/// </summary>
/// <param name="left">Minimum x-value of the viewing volume.</param>
/// <param name="right">Maximum x-value of the viewing volume.</param>
/// <param name="bottom">Minimum y-value of the viewing volume.</param>
/// <param name="top">Maximum y-value of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <param name="result">When the method completes, contains the created projection matrix.</param>
/// <summary>
/// Creates a right-handed, customized orthographic projection matrix.
/// </summary>
/// <param name="left">Minimum x-value of the viewing volume.</param>
/// <param name="right">Maximum x-value of the viewing volume.</param>
/// <param name="bottom">Minimum y-value of the viewing volume.</param>
/// <param name="top">Maximum y-value of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <returns>The created projection matrix.</returns>
/// <summary>
/// Creates a left-handed, perspective projection matrix.
/// </summary>
/// <param name="width">Width of the viewing volume.</param>
/// <param name="height">Height of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <param name="result">When the method completes, contains the created projection matrix.</param>
/// <summary>
/// Creates a left-handed, perspective projection matrix.
/// </summary>
/// <param name="width">Width of the viewing volume.</param>
/// <param name="height">Height of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <returns>The created projection matrix.</returns>
/// <summary>
/// Creates a right-handed, perspective projection matrix.
/// </summary>
/// <param name="width">Width of the viewing volume.</param>
/// <param name="height">Height of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <param name="result">When the method completes, contains the created projection matrix.</param>
/// <summary>
/// Creates a right-handed, perspective projection matrix.
/// </summary>
/// <param name="width">Width of the viewing volume.</param>
/// <param name="height">Height of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <returns>The created projection matrix.</returns>
/// <summary>
/// Creates a left-handed, perspective projection matrix based on a field of view.
/// </summary>
/// <param name="fov">Field of view in the y direction, in radians.</param>
/// <param name="aspect">Aspect ratio, defined as view space width divided by height.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <param name="result">When the method completes, contains the created projection matrix.</param>
/// <summary>
/// Creates a left-handed, perspective projection matrix based on a field of view.
/// </summary>
/// <param name="fov">Field of view in the y direction, in radians.</param>
/// <param name="aspect">Aspect ratio, defined as view space width divided by height.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <returns>The created projection matrix.</returns>
/// <summary>
/// Creates a right-handed, perspective projection matrix based on a field of view.
/// </summary>
/// <param name="fov">Field of view in the y direction, in radians.</param>
/// <param name="aspect">Aspect ratio, defined as view space width divided by height.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <param name="result">When the method completes, contains the created projection matrix.</param>
/// <summary>
/// Creates a right-handed, perspective projection matrix based on a field of view.
/// </summary>
/// <param name="fov">Field of view in the y direction, in radians.</param>
/// <param name="aspect">Aspect ratio, defined as view space width divided by height.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <returns>The created projection matrix.</returns>
/// <summary>
/// Creates a left-handed, customized perspective projection matrix.
/// </summary>
/// <param name="left">Minimum x-value of the viewing volume.</param>
/// <param name="right">Maximum x-value of the viewing volume.</param>
/// <param name="bottom">Minimum y-value of the viewing volume.</param>
/// <param name="top">Maximum y-value of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <param name="result">When the method completes, contains the created projection matrix.</param>
/// <summary>
/// Creates a left-handed, customized perspective projection matrix.
/// </summary>
/// <param name="left">Minimum x-value of the viewing volume.</param>
/// <param name="right">Maximum x-value of the viewing volume.</param>
/// <param name="bottom">Minimum y-value of the viewing volume.</param>
/// <param name="top">Maximum y-value of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <returns>The created projection matrix.</returns>
/// <summary>
/// Creates a right-handed, customized perspective projection matrix.
/// </summary>
/// <param name="left">Minimum x-value of the viewing volume.</param>
/// <param name="right">Maximum x-value of the viewing volume.</param>
/// <param name="bottom">Minimum y-value of the viewing volume.</param>
/// <param name="top">Maximum y-value of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <param name="result">When the method completes, contains the created projection matrix.</param>
/// <summary>
/// Creates a right-handed, customized perspective projection matrix.
/// </summary>
/// <param name="left">Minimum x-value of the viewing volume.</param>
/// <param name="right">Maximum x-value of the viewing volume.</param>
/// <param name="bottom">Minimum y-value of the viewing volume.</param>
/// <param name="top">Maximum y-value of the viewing volume.</param>
/// <param name="znear">Minimum z-value of the viewing volume.</param>
/// <param name="zfar">Maximum z-value of the viewing volume.</param>
/// <returns>The created projection matrix.</returns>
/// <summary>
/// Creates a matrix that scales along the x-axis, y-axis, and y-axis.
/// </summary>
/// <param name="scale">Scaling factor for all three axes.</param>
/// <param name="result">When the method completes, contains the created scaling matrix.</param>
/// <summary>
/// Creates a matrix that scales along the x-axis, y-axis, and y-axis.
/// </summary>
/// <param name="scale">Scaling factor for all three axes.</param>
/// <returns>The created scaling matrix.</returns>
/// <summary>
/// Creates a matrix that uniformally scales along all three axis.
/// </summary>
/// <param name="scale">The uniform scale that is applied along all axis.</param>
/// <param name="result">When the method completes, contains the created scaling matrix.</param>
/// <summary>
/// Creates a matrix that uniformally scales along all three axis.
/// </summary>
/// <param name="scale">The uniform scale that is applied along all axis.</param>
/// <returns>The created scaling matrix.</returns>
/// <summary>
/// Creates a matrix that scales along the x-axis, y-axis, and y-axis.
/// </summary>
/// <param name="x">Scaling factor that is applied along the x-axis.</param>
/// <param name="y">Scaling factor that is applied along the y-axis.</param>
/// <param name="z">Scaling factor that is applied along the z-axis.</param>
/// <param name="result">When the method completes, contains the created scaling matrix.</param>
/// <summary>
/// Creates a matrix that scales along the x-axis, y-axis, and y-axis.
/// </summary>
/// <param name="x">Scaling factor that is applied along the x-axis.</param>
/// <param name="y">Scaling factor that is applied along the y-axis.</param>
/// <param name="z">Scaling factor that is applied along the z-axis.</param>
/// <returns>The created scaling matrix.</returns>
/// <summary>
/// Creates a matrix that rotates around the x-axis.
/// </summary>
/// <param name="angle">Angle of rotation in radians. Angles are measured clockwise when looking along the rotation axis toward the origin.</param>
/// <param name="result">When the method completes, contains the created rotation matrix.</param>
/// <summary>
/// Creates a matrix that rotates around the x-axis.
/// </summary>
/// <param name="angle">Angle of rotation in radians. Angles are measured clockwise when looking along the rotation axis toward the origin.</param>
/// <returns>The created rotation matrix.</returns>
/// <summary>
/// Creates a matrix that rotates around the y-axis.
/// </summary>
/// <param name="angle">Angle of rotation in radians. Angles are measured clockwise when looking along the rotation axis toward the origin.</param>
/// <param name="result">When the method completes, contains the created rotation matrix.</param>
/// <summary>
/// Creates a matrix that rotates around the y-axis.
/// </summary>
/// <param name="angle">Angle of rotation in radians. Angles are measured clockwise when looking along the rotation axis toward the origin.</param>
/// <returns>The created rotation matrix.</returns>
/// <summary>
/// Creates a matrix that rotates around the z-axis.
/// </summary>
/// <param name="angle">Angle of rotation in radians. Angles are measured clockwise when looking along the rotation axis toward the origin.</param>
/// <param name="result">When the method completes, contains the created rotation matrix.</param>
/// <summary>
/// Creates a matrix that rotates around the z-axis.
/// </summary>
/// <param name="angle">Angle of rotation in radians. Angles are measured clockwise when looking along the rotation axis toward the origin.</param>
/// <returns>The created rotation matrix.</returns>
/// <summary>
/// Creates a matrix that rotates around an arbitary axis.
/// </summary>
/// <param name="axis">The axis around which to rotate. This parameter is assumed to be normalized.</param>
/// <param name="angle">Angle of rotation in radians. Angles are measured clockwise when looking along the rotation axis toward the origin.</param>
/// <param name="result">When the method completes, contains the created rotation matrix.</param>
/// <summary>
/// Creates a matrix that rotates around an arbitary axis.
/// </summary>
/// <param name="axis">The axis around which to rotate. This parameter is assumed to be normalized.</param>
/// <param name="angle">Angle of rotation in radians. Angles are measured clockwise when looking along the rotation axis toward the origin.</param>
/// <returns>The created rotation matrix.</returns>
/// <summary>
/// Creates a rotation matrix from a quaternion.
/// </summary>
/// <param name="rotation">The quaternion to use to build the matrix.</param>
/// <param name="result">The created rotation matrix.</param>
/// <summary>
/// Creates a rotation matrix from a quaternion.
/// </summary>
/// <param name="rotation">The quaternion to use to build the matrix.</param>
/// <returns>The created rotation matrix.</returns>
/// <summary>
/// Creates a rotation matrix with a specified yaw, pitch, and roll.
/// </summary>
/// <param name="yaw">Yaw around the y-axis, in radians.</param>
/// <param name="pitch">Pitch around the x-axis, in radians.</param>
/// <param name="roll">Roll around the z-axis, in radians.</param>
/// <param name="result">When the method completes, contains the created rotation matrix.</param>
/// <summary>
/// Creates a rotation matrix with a specified yaw, pitch, and roll.
/// </summary>
/// <param name="yaw">Yaw around the y-axis, in radians.</param>
/// <param name="pitch">Pitch around the x-axis, in radians.</param>
/// <param name="roll">Roll around the z-axis, in radians.</param>
/// <returns>The created rotation matrix.</returns>
/// <summary>
/// Creates a translation matrix using the specified offsets.
/// </summary>
/// <param name="value">The offset for all three coordinate planes.</param>
/// <param name="result">When the method completes, contains the created translation matrix.</param>
/// <summary>
/// Creates a translation matrix using the specified offsets.
/// </summary>
/// <param name="value">The offset for all three coordinate planes.</param>
/// <returns>The created translation matrix.</returns>
/// <summary>
/// Creates a translation matrix using the specified offsets.
/// </summary>
/// <param name="x">X-coordinate offset.</param>
/// <param name="y">Y-coordinate offset.</param>
/// <param name="z">Z-coordinate offset.</param>
/// <param name="result">When the method completes, contains the created translation matrix.</param>
/// <summary>
/// Creates a translation matrix using the specified offsets.
/// </summary>
/// <param name="x">X-coordinate offset.</param>
/// <param name="y">Y-coordinate offset.</param>
/// <param name="z">Z-coordinate offset.</param>
/// <returns>The created translation matrix.</returns>
/// <summary>
/// Creates a 3D affine transformation matrix.
/// </summary>
/// <param name="scaling">Scaling factor.</param>
/// <param name="rotation">The rotation of the transformation.</param>
/// <param name="translation">The translation factor of the transformation.</param>
/// <param name="result">When the method completes, contains the created affine transformation matrix.</param>
/// <summary>
/// Creates a 3D affine transformation matrix.
/// </summary>
/// <param name="scaling">Scaling factor.</param>
/// <param name="rotation">The rotation of the transformation.</param>
/// <param name="translation">The translation factor of the transformation.</param>
/// <returns>The created affine transformation matrix.</returns>
/// <summary>
/// Creates a 3D affine transformation matrix.
/// </summary>
/// <param name="scaling">Scaling factor.</param>
/// <param name="rotationCenter">The center of the rotation.</param>
/// <param name="rotation">The rotation of the transformation.</param>
/// <param name="translation">The translation factor of the transformation.</param>
/// <param name="result">When the method completes, contains the created affine transformation matrix.</param>
/// <summary>
/// Creates a 3D affine transformation matrix.
/// </summary>
/// <param name="scaling">Scaling factor.</param>
/// <param name="rotationCenter">The center of the rotation.</param>
/// <param name="rotation">The rotation of the transformation.</param>
/// <param name="translation">The translation factor of the transformation.</param>
/// <returns>The created affine transformation matrix.</returns>
/// <summary>
/// Creates a transformation matrix.
/// </summary>
/// <param name="scalingCenter">Center point of the scaling operation.</param>
/// <param name="scalingRotation">Scaling rotation amount.</param>
/// <param name="scaling">Scaling factor.</param>
/// <param name="rotationCenter">The center of the rotation.</param>
/// <param name="rotation">The rotation of the transformation.</param>
/// <param name="translation">The translation factor of the transformation.</param>
/// <param name="result">When the method completes, contains the created transformation matrix.</param>
/// <summary>
/// Creates a transformation matrix.
/// </summary>
/// <param name="scalingCenter">Center point of the scaling operation.</param>
/// <param name="scalingRotation">Scaling rotation amount.</param>
/// <param name="scaling">Scaling factor.</param>
/// <param name="rotationCenter">The center of the rotation.</param>
/// <param name="rotation">The rotation of the transformation.</param>
/// <param name="translation">The translation factor of the transformation.</param>
/// <returns>The created transformation matrix.</returns>
/// <summary>
/// Adds two matricies.
/// </summary>
/// <param name="left">The first matrix to add.</param>
/// <param name="right">The second matrix to add.</param>
/// <returns>The sum of the two matricies.</returns>
/// <summary>
/// Assert a matrix (return it unchanged).
/// </summary>
/// <param name="value">The matrix to assert (unchange).</param>
/// <returns>The asserted (unchanged) matrix.</returns>
/// <summary>
/// Subtracts two matricies.
/// </summary>
/// <param name="left">The first matrix to subtract.</param>
/// <param name="right">The second matrix to subtract.</param>
/// <returns>The difference between the two matricies.</returns>
/// <summary>
/// Negates a matrix.
/// </summary>
/// <param name="value">The matrix to negate.</param>
/// <returns>The negated matrix.</returns>
/// <summary>
/// Scales a matrix by a given value.
/// </summary>
/// <param name="right">The matrix to scale.</param>
/// <param name="scalar">The amount by which to scale.</param>
/// <returns>The scaled matrix.</returns>
/// <summary>
/// Scales a matrix by a given value.
/// </summary>
/// <param name="left">The matrix to scale.</param>
/// <param name="scalar">The amount by which to scale.</param>
/// <returns>The scaled matrix.</returns>
/// <summary>
/// Multiplies two matricies.
/// </summary>
/// <param name="left">The first matrix to multiply.</param>
/// <param name="right">The second matrix to multiply.</param>
/// <returns>The product of the two matricies.</returns>
/// <summary>
/// Scales a matrix by a given value.
/// </summary>
/// <param name="left">The matrix to scale.</param>
/// <param name="scalar">The amount by which to scale.</param>
/// <returns>The scaled matrix.</returns>
/// <summary>
/// Divides two matricies.
/// </summary>
/// <param name="left">The first matrix to divide.</param>
/// <param name="right">The second matrix to divide.</param>
/// <returns>The quotient of the two matricies.</returns>
/// <summary>
/// Tests for equality between two objects.
/// </summary>
/// <param name="left">The first value to compare.</param>
/// <param name="right">The second value to compare.</param>
/// <returns><c>true</c> if <paramref name="left"/> has the same value as <paramref name="right"/>; otherwise, <c>false</c>.</returns>
/// <summary>
/// Tests for inequality between two objects.
/// </summary>
/// <param name="left">The first value to compare.</param>
/// <param name="right">The second value to compare.</param>
/// <returns><c>true</c> if <paramref name="left"/> has a different value than <paramref name="right"/>; otherwise, <c>false</c>.</returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <param name="format">The format.</param>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <param name="formatProvider">The format provider.</param>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <param name="format">The format.</param>
/// <param name="formatProvider">The format provider.</param>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a hash code for this instance.
/// </summary>
/// <returns>
/// A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
/// </returns>
/// <summary>
/// Determines whether the specified <see cref="SlimMath.Matrix"/> is equal to this instance.
/// </summary>
/// <param name="other">The <see cref="SlimMath.Matrix"/> to compare with this instance.</param>
/// <returns>
/// <c>true</c> if the specified <see cref="SlimMath.Matrix"/> is equal to this instance; otherwise, <c>false</c>.
/// </returns>
/// <summary>
/// Determines whether the specified <see cref="SlimMath.Matrix"/> is equal to this instance.
/// </summary>
/// <param name="other">The <see cref="SlimMath.Matrix"/> to compare with this instance.</param>
/// <param name="epsilon">The amount of error allowed.</param>
/// <returns>
/// <c>true</c> if the specified <see cref="SlimMath.Matrix"/> is equal to this instance; otherwise, <c>false</c>.
/// </returns>
/// <summary>
/// Determines whether the specified <see cref="System.Object"/> is equal to this instance.
/// </summary>
/// <param name="obj">The <see cref="System.Object"/> to compare with this instance.</param>
/// <returns>
/// <c>true</c> if the specified <see cref="System.Object"/> is equal to this instance; otherwise, <c>false</c>.
/// </returns>
/// <summary>
/// Performs an implicit conversion from <see cref="SlimMath.Matrix"/> to <see cref="SlimDX.Matrix"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="SlimDX.Matrix"/> to <see cref="SlimMath.Matrix"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="SlimMath.Matrix"/> to <see cref="System.Windows.Media.Media3D.Matrix3D"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an explicit conversion from <see cref="System.Windows.Media.Media3D.Matrix3D"/> to <see cref="SlimMath.Matrix"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="SlimMath.Matrix"/> to <see cref="Microsoft.Xna.Framework.Matrix"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="Microsoft.Xna.Framework.Matrix"/> to <see cref="SlimMath.Matrix"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/*
/// <summary>
/// Represents a four dimensional mathematical quaternion.
/// </summary>
//[TypeConverter(typeof(SlimMath.Design.QuaternionConverter))]
/// <summary>
/// The size of the <see cref="SlimMath.Quaternion"/> type, in bytes.
/// </summary>
/// <summary>
/// A <see cref="SlimMath.Quaternion"/> with all of its components set to zero.
/// </summary>
/// <summary>
/// A <see cref="SlimMath.Quaternion"/> with all of its components set to one.
/// </summary>
/// <summary>
/// The identity <see cref="SlimMath.Quaternion"/> (0, 0, 0, 1).
/// </summary>
/// <summary>
/// The X component of the quaternion.
/// </summary>
/// <summary>
/// The Y component of the quaternion.
/// </summary>
/// <summary>
/// The Z component of the quaternion.
/// </summary>
/// <summary>
/// The W component of the quaternion.
/// </summary>
/// <summary>
/// Initializes a new instance of the <see cref="SlimMath.Quaternion"/> struct.
/// </summary>
/// <param name="value">The value that will be assigned to all components.</param>
/// <summary>
/// Initializes a new instance of the <see cref="SlimMath.Quaternion"/> struct.
/// </summary>
/// <param name="value">A vector containing the values with which to initialize the components.</param>
/// <summary>
/// Initializes a new instance of the <see cref="SlimMath.Quaternion"/> struct.
/// </summary>
/// <param name="value">A vector containing the values with which to initialize the X, Y, and Z components.</param>
/// <param name="angle">Initial value for the angle of the quaternion.</param>
/// <summary>
/// Initializes a new instance of the <see cref="SlimMath.Quaternion"/> struct.
/// </summary>
/// <param name="x">Initial value for the X component of the quaternion.</param>
/// <param name="y">Initial value for the Y component of the quaternion.</param>
/// <param name="z">Initial value for the Z component of the quaternion.</param>
/// <param name="w">Initial value for the W component of the quaternion.</param>
/// <summary>
/// Initializes a new instance of the <see cref="SlimMath.Quaternion"/> struct.
/// </summary>
/// <param name="values">The values to assign to the X, Y, Z, and W components of the quaternion. This must be an array with four elements.</param>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="values"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="values"/> contains more or less than four elements.</exception>
/// <summary>
/// Gets a value indicating whether this instance is equivalent to the identity quaternion.
/// </summary>
/// <value>
/// <c>true</c> if this instance is an identity quaternion; otherwise, <c>false</c>.
/// </value>
/// <summary>
/// Gets a value indicting whether this instance is normalized.
/// </summary>
/// <summary>
/// Gets the angle of the quaternion.
/// </summary>
/// <value>The quaternion's angle.</value>
/// <summary>
/// Gets the axis components of the quaternion.
/// </summary>
/// <value>The axis components of the quaternion.</value>
/// <summary>
/// Calculates the length of the quaternion.
/// </summary>
/// <remarks>
/// <see cref="SlimMath.Quaternion.LengthSquared"/> may be preferred when only the relative length is needed
/// and speed is of the essence.
/// </remarks>
/// <summary>
/// Calculates the squared length of the quaternion.
/// </summary>
/// <remarks>
/// This property may be preferred to <see cref="SlimMath.Quaternion.Length"/> when only a relative length is needed
/// and speed is of the essence.
/// </remarks>
/// <summary>
/// Gets or sets the component at the specified index.
/// </summary>
/// <value>The value of the X, Y, Z, or W component, depending on the index.</value>
/// <param name="index">The index of the component to access. Use 0 for the X component, 1 for the Y component, 2 for the Z component, and 3 for the W component.</param>
/// <returns>The value of the component at the specified index.</returns>
/// <exception cref="System.ArgumentOutOfRangeException">Thrown when the <paramref name="index"/> is out of the range [0, 3].</exception>
/// <summary>
/// Conjugates the quaternion.
/// </summary>
/// <summary>
/// Reverses the direction of a given quaternion.
/// </summary>
/// <summary>
/// Return the inverse of this quaternion.
/// </summary>
/// <summary>
/// Conjugates and renormalizes the quaternion.
/// </summary>
/// <summary>
/// Converts the quaternion into a unit quaternion.
/// </summary>
/// <summary>
/// Exponentiates a quaternion.
/// </summary>
/// <summary>
/// Calculates the natural logarithm of the specified quaternion.
/// </summary>
/// <summary>
/// Creates an array containing the elements of the quaternion.
/// </summary>
/// <returns>A four-element array containing the components of the quaternion.</returns>
/// <summary>
/// Adds two quaternions.
/// </summary>
/// <param name="left">The first quaternion to add.</param>
/// <param name="right">The second quaternion to add.</param>
/// <param name="result">When the method completes, contains the sum of the two quaternions.</param>
/// <summary>
/// Adds two quaternions.
/// </summary>
/// <param name="left">The first quaternion to add.</param>
/// <param name="right">The second quaternion to add.</param>
/// <returns>The sum of the two quaternions.</returns>
/// <summary>
/// Subtracts two quaternions.
/// </summary>
/// <param name="left">The first quaternion to subtract.</param>
/// <param name="right">The second quaternion to subtract.</param>
/// <param name="result">When the method completes, contains the difference of the two quaternions.</param>
/// <summary>
/// Subtracts two quaternions.
/// </summary>
/// <param name="left">The first quaternion to subtract.</param>
/// <param name="right">The second quaternion to subtract.</param>
/// <returns>The difference of the two quaternions.</returns>
/// <summary>
/// Scales a quaternion by the given value.
/// </summary>
/// <param name="value">The quaternion to scale.</param>
/// <param name="scalar">The amount by which to scale the quaternion.</param>
/// <param name="result">When the method completes, contains the scaled quaternion.</param>
/// <summary>
/// Scales a quaternion by the given value.
/// </summary>
/// <param name="value">The quaternion to scale.</param>
/// <param name="scalar">The amount by which to scale the quaternion.</param>
/// <returns>The scaled quaternion.</returns>
/// <summary>
/// Modulates a quaternion by another.
/// </summary>
/// <param name="left">The first quaternion to modulate.</param>
/// <param name="right">The second quaternion to modulate.</param>
/// <param name="result">When the moethod completes, contains the modulated quaternion.</param>
/// <summary>
/// Modulates a quaternion by another.
/// </summary>
/// <param name="left">The first quaternion to modulate.</param>
/// <param name="right">The second quaternion to modulate.</param>
/// <returns>The modulated quaternion.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <param name="result">When the method completes, contains the scaled vector.</param>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Reverses the direction of a given quaternion.
/// </summary>
/// <param name="value">The quaternion to negate.</param>
/// <param name="result">When the method completes, contains a quaternion facing in the opposite direction.</param>
/// <summary>
/// Reverses the direction of a given quaternion.
/// </summary>
/// <param name="value">The quaternion to negate.</param>
/// <returns>A quaternion facing in the opposite direction.</returns>
/// <summary>
/// Returns a <see cref="SlimMath.Quaternion"/> containing the 4D Cartesian coordinates of a point specified in Barycentric coordinates relative to a 2D triangle.
/// </summary>
/// <param name="value1">A <see cref="SlimMath.Quaternion"/> containing the 4D Cartesian coordinates of vertex 1 of the triangle.</param>
/// <param name="value2">A <see cref="SlimMath.Quaternion"/> containing the 4D Cartesian coordinates of vertex 2 of the triangle.</param>
/// <param name="value3">A <see cref="SlimMath.Quaternion"/> containing the 4D Cartesian coordinates of vertex 3 of the triangle.</param>
/// <param name="amount1">Barycentric coordinate b2, which expresses the weighting factor toward vertex 2 (specified in <paramref name="value2"/>).</param>
/// <param name="amount2">Barycentric coordinate b3, which expresses the weighting factor toward vertex 3 (specified in <paramref name="value3"/>).</param>
/// <param name="result">When the method completes, contains a new <see cref="SlimMath.Quaternion"/> containing the 4D Cartesian coordinates of the specified point.</param>
/// <summary>
/// Returns a <see cref="SlimMath.Quaternion"/> containing the 4D Cartesian coordinates of a point specified in Barycentric coordinates relative to a 2D triangle.
/// </summary>
/// <param name="value1">A <see cref="SlimMath.Quaternion"/> containing the 4D Cartesian coordinates of vertex 1 of the triangle.</param>
/// <param name="value2">A <see cref="SlimMath.Quaternion"/> containing the 4D Cartesian coordinates of vertex 2 of the triangle.</param>
/// <param name="value3">A <see cref="SlimMath.Quaternion"/> containing the 4D Cartesian coordinates of vertex 3 of the triangle.</param>
/// <param name="amount1">Barycentric coordinate b2, which expresses the weighting factor toward vertex 2 (specified in <paramref name="value2"/>).</param>
/// <param name="amount2">Barycentric coordinate b3, which expresses the weighting factor toward vertex 3 (specified in <paramref name="value3"/>).</param>
/// <returns>A new <see cref="SlimMath.Quaternion"/> containing the 4D Cartesian coordinates of the specified point.</returns>
/// <summary>
/// Conjugates a quaternion.
/// </summary>
/// <param name="value">The quaternion to conjugate.</param>
/// <param name="result">When the method completes, contains the conjugated quaternion.</param>
/// <summary>
/// Conjugates a quaternion.
/// </summary>
/// <param name="value">The quaternion to conjugate.</param>
/// <returns>The conjugated quaternion.</returns>
/// <summary>
/// Calculates the dot product of two quaternions.
/// </summary>
/// <param name="left">First source quaternion.</param>
/// <param name="right">Second source quaternion.</param>
/// <param name="result">When the method completes, contains the dot product of the two quaternions.</param>
/// <summary>
/// Calculates the dot product of two quaternions.
/// </summary>
/// <param name="left">First source quaternion.</param>
/// <param name="right">Second source quaternion.</param>
/// <returns>The dot product of the two quaternions.</returns>
/// <summary>
/// Exponentiates a quaternion.
/// </summary>
/// <param name="value">The quaternion to exponentiate.</param>
/// <param name="result">When the method completes, contains the exponentiated quaternion.</param>
/// <summary>
/// Exponentiates a quaternion.
/// </summary>
/// <param name="value">The quaternion to exponentiate.</param>
/// <returns>The exponentiated quaternion.</returns>
/// <summary>
/// Conjugates and renormalizes the quaternion.
/// </summary>
/// <param name="value">The quaternion to conjugate and renormalize.</param>
/// <param name="result">When the method completes, contains the conjugated and renormalized quaternion.</param>
/// <summary>
/// Conjugates and renormalizes the quaternion.
/// </summary>
/// <param name="value">The quaternion to conjugate and renormalize.</param>
/// <returns>The conjugated and renormalized quaternion.</returns>
/// <summary>
/// Performs a linear interpolation between two quaternions.
/// </summary>
/// <param name="start">Start quaternion.</param>
/// <param name="end">End quaternion.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <param name="result">When the method completes, contains the linear interpolation of the two quaternions.</param>
/// <remarks>
/// This method performs the linear interpolation based on the following formula.
/// <code>start + (end - start) * amount</code>
/// Passing <paramref name="amount"/> a value of 0 will cause <paramref name="start"/> to be returned; a value of 1 will cause <paramref name="end"/> to be returned. 
/// </remarks>
/// <summary>
/// Performs a linear interpolation between two quaternion.
/// </summary>
/// <param name="start">Start quaternion.</param>
/// <param name="end">End quaternion.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <returns>The linear interpolation of the two quaternions.</returns>
/// <remarks>
/// This method performs the linear interpolation based on the following formula.
/// <code>start + (end - start) * amount</code>
/// Passing <paramref name="amount"/> a value of 0 will cause <paramref name="start"/> to be returned; a value of 1 will cause <paramref name="end"/> to be returned. 
/// </remarks>
/// <summary>
/// Calculates the natural logarithm of the specified quaternion.
/// </summary>
/// <param name="value">The quaternion whose logarithm will be calculated.</param>
/// <param name="result">When the method completes, contains the natural logarithm of the quaternion.</param>
/// <summary>
/// Calculates the natural logarithm of the specified quaternion.
/// </summary>
/// <param name="value">The quaternion whose logarithm will be calculated.</param>
/// <returns>The natural logarithm of the quaternion.</returns>
/// <summary>
/// Converts the quaternion into a unit quaternion.
/// </summary>
/// <param name="value">The quaternion to normalize.</param>
/// <param name="result">When the method completes, contains the normalized quaternion.</param>
/// <summary>
/// Converts the quaternion into a unit quaternion.
/// </summary>
/// <param name="value">The quaternion to normalize.</param>
/// <returns>The normalized quaternion.</returns>
/// <summary>
/// Creates a quaternion given a rotation and an axis.
/// </summary>
/// <param name="axis">The axis of rotation.</param>
/// <param name="angle">The angle of rotation.</param>
/// <param name="result">When the method completes, contains the newly created quaternion.</param>
/// <summary>
/// Creates a quaternion given a rotation and an axis.
/// </summary>
/// <param name="axis">The axis of rotation.</param>
/// <param name="angle">The angle of rotation.</param>
/// <returns>The newly created quaternion.</returns>
/// <summary>
/// Creates a quaternion given a rotation matrix.
/// </summary>
/// <param name="matrix">The rotation matrix.</param>
/// <param name="result">When the method completes, contains the newly created quaternion.</param>
/// <summary>
/// Creates a quaternion given a rotation matrix.
/// </summary>
/// <param name="matrix">The rotation matrix.</param>
/// <returns>The newly created quaternion.</returns>
/// <summary>
/// Creates a quaternion given a yaw, pitch, and roll value.
/// </summary>
/// <param name="yaw">The yaw of rotation.</param>
/// <param name="pitch">The pitch of rotation.</param>
/// <param name="roll">The roll of rotation.</param>
/// <param name="result">When the method completes, contains the newly created quaternion.</param>
/// <summary>
/// Creates a quaternion given a yaw, pitch, and roll value.
/// </summary>
/// <param name="yaw">The yaw of rotation.</param>
/// <param name="pitch">The pitch of rotation.</param>
/// <param name="roll">The roll of rotation.</param>
/// <returns>The newly created quaternion.</returns>
/// <summary>
/// Interpolates between two quaternions, using spherical linear interpolation.
/// </summary>
/// <param name="start">Start quaternion.</param>
/// <param name="end">End quaternion.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <param name="result">When the method completes, contains the spherical linear interpolation of the two quaternions.</param>
/// <summary>
/// Interpolates between two quaternions, using spherical linear interpolation.
/// </summary>
/// <param name="start">Start quaternion.</param>
/// <param name="end">End quaternion.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <returns>The spherical linear interpolation of the two quaternions.</returns>
/// <summary>
/// Interpolates between quaternions, using spherical quadrangle interpolation.
/// </summary>
/// <param name="value1">First source quaternion.</param>
/// <param name="value2">Second source quaternion.</param>
/// <param name="value3">Thrid source quaternion.</param>
/// <param name="value4">Fourth source quaternion.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of interpolation.</param>
/// <param name="result">When the method completes, contains the spherical quadrangle interpolation of the quaternions.</param>
/// <summary>
/// Interpolates between quaternions, using spherical quadrangle interpolation.
/// </summary>
/// <param name="value1">First source quaternion.</param>
/// <param name="value2">Second source quaternion.</param>
/// <param name="value3">Thrid source quaternion.</param>
/// <param name="value4">Fourth source quaternion.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of interpolation.</param>
/// <returns>The spherical quadrangle interpolation of the quaternions.</returns>
/// <summary>
/// Sets up control points for spherical quadrangle interpolation.
/// </summary>
/// <param name="value1">First source quaternion.</param>
/// <param name="value2">Second source quaternion.</param>
/// <param name="value3">Third source quaternion.</param>
/// <param name="value4">Fourth source quaternion.</param>
/// <param name="result1">When the method completes, contains the first control point for spherical quadrangle interpolation.</param>
/// <param name="result2">When the method completes, contains the second control point for spherical quadrangle interpolation.</param>
/// <param name="result3">When the method completes, contains the third control point for spherical quadrangle interpolation.</param>
/// <summary>
/// Sets up control points for spherical quadrangle interpolation.
/// </summary>
/// <param name="value1">First source quaternion.</param>
/// <param name="value2">Second source quaternion.</param>
/// <param name="value3">Third source quaternion.</param>
/// <param name="value4">Fourth source quaternion.</param>
/// <returns>An array of three quaternions that represent control points for spherical quadrangle interpolation.</returns>
/// <summary>
/// Adds two quaternions.
/// </summary>
/// <param name="left">The first quaternion to add.</param>
/// <param name="right">The second quaternion to add.</param>
/// <returns>The sum of the two quaternions.</returns>
/// <summary>
/// Subtracts two quaternions.
/// </summary>
/// <param name="left">The first quaternion to subtract.</param>
/// <param name="right">The second quaternion to subtract.</param>
/// <returns>The difference of the two quaternions.</returns>
/// <summary>
/// Reverses the direction of a given quaternion.
/// </summary>
/// <param name="value">The quaternion to negate.</param>
/// <returns>A quaternion facing in the opposite direction.</returns>
/// <summary>
/// Scales a quaternion by the given value.
/// </summary>
/// <param name="value">The quaternion to scale.</param>
/// <param name="scalar">The amount by which to scale the quaternion.</param>
/// <returns>The scaled quaternion.</returns>
/// <summary>
/// Scales a quaternion by the given value.
/// </summary>
/// <param name="value">The quaternion to scale.</param>
/// <param name="scalar">The amount by which to scale the quaternion.</param>
/// <returns>The scaled quaternion.</returns>
/// <summary>
/// Multiplies a quaternion by another.
/// </summary>
/// <param name="left">The first quaternion to multiply.</param>
/// <param name="right">The second quaternion to multiply.</param>
/// <returns>The multiplied quaternion.</returns>
/// <summary>
/// Multiplies a quaternion by a vector.
/// </summary>
/// <param name="left">The quaternion to multiply.</param>
/// <param name="right">The vector to multiply.</param>
/// <returns>The multiplied quaternion.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Tests for equality between two objects.
/// </summary>
/// <param name="left">The first value to compare.</param>
/// <param name="right">The second value to compare.</param>
/// <returns><c>true</c> if <paramref name="left"/> has the same value as <paramref name="right"/>; otherwise, <c>false</c>.</returns>
/// <summary>
/// Tests for inequality between two objects.
/// </summary>
/// <param name="left">The first value to compare.</param>
/// <param name="right">The second value to compare.</param>
/// <returns><c>true</c> if <paramref name="left"/> has a different value than <paramref name="right"/>; otherwise, <c>false</c>.</returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <param name="format">The format.</param>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <param name="formatProvider">The format provider.</param>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <param name="format">The format.</param>
/// <param name="formatProvider">The format provider.</param>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a hash code for this instance.
/// </summary>
/// <returns>
/// A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
/// </returns>
/// <summary>
/// Determines whether the specified <see cref="SlimMath.Quaternion"/> is equal to this instance.
/// </summary>
/// <param name="other">The <see cref="SlimMath.Quaternion"/> to compare with this instance.</param>
/// <returns>
/// <c>true</c> if the specified <see cref="SlimMath.Quaternion"/> is equal to this instance; otherwise, <c>false</c>.
/// </returns>
/// <summary>
/// Determines whether the specified <see cref="SlimMath.Quaternion"/> is equal to this instance.
/// </summary>
/// <param name="other">The <see cref="SlimMath.Quaternion"/> to compare with this instance.</param>
/// <param name="epsilon">The amount of error allowed.</param>
/// <returns>
/// <c>true</c> if the specified <see cref="SlimMath.Quaternion"/> is equal to this instance; otherwise, <c>false</c>.
/// </returns>
/// <summary>
/// Determines whether the specified <see cref="System.Object"/> is equal to this instance.
/// </summary>
/// <param name="obj">The <see cref="System.Object"/> to compare with this instance.</param>
/// <returns>
/// <c>true</c> if the specified <see cref="System.Object"/> is equal to this instance; otherwise, <c>false</c>.
/// </returns>
/// <summary>
/// Performs an implicit conversion from <see cref="SlimMath.Quaternion"/> to <see cref="SlimDX.Quaternion"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="SlimDX.Quaternion"/> to <see cref="SlimMath.Quaternion"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="SlimMath.Quaternion"/> to <see cref="System.Windows.Media.Media3D.Quaternion"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an explicit conversion from <see cref="System.Windows.Media.Media3D.Quaternion"/> to <see cref="SlimMath.Quaternion"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="SlimMath.Quaternion"/> to <see cref="Microsoft.Xna.Framework.Quaternion"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="Microsoft.Xna.Framework.Quaternion"/> to <see cref="SlimMath.Quaternion"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/*
/// <summary>
/// Represents a three dimensional mathematical vector.
/// </summary>
//[TypeConverter(typeof(SlimMath.Design.Vector3Converter))]
/// <summary>
/// The size of the <see cref="Vector3"/> type, in bytes.
/// </summary>
/// <summary>
/// A <see cref="Vector3"/> with all of its components set to zero.
/// </summary>
/// <summary>
/// The X unit <see cref="Vector3"/> (1, 0, 0).
/// </summary>
/// <summary>
/// The Y unit <see cref="Vector3"/> (0, 1, 0).
/// </summary>
/// <summary>
/// The Z unit <see cref="Vector3"/> (0, 0, 1).
/// </summary>
/// <summary>
/// A <see cref="Vector3"/> with all of its components set to one.
/// </summary>
/// <summary>
/// The X component of the vector.
/// </summary>
/// <summary>
/// The Y component of the vector.
/// </summary>
/// <summary>
/// The Z component of the vector.
/// </summary>
/// <summary>
/// Initializes a new instance of the <see cref="Vector3"/> struct.
/// </summary>
/// <param name="value">The value that will be assigned to all components.</param>
/// <summary>
/// Initializes a new instance of the <see cref="Vector3"/> struct.
/// </summary>
/// <param name="x">Initial value for the X component of the vector.</param>
/// <param name="y">Initial value for the Y component of the vector.</param>
/// <param name="z">Initial value for the Z component of the vector.</param>
/// <summary>
/// Initializes a new instance of the <see cref="Vector3"/> struct.
/// </summary>
/// <param name="values">The values to assign to the X, Y, and Z components of the vector. This must be an array with three elements.</param>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="values"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="values"/> contains more or less than three elements.</exception>
/// <summary>
/// Gets a value indicting whether this instance is normalized.
/// </summary>
/// <summary>
/// Calculates the length of the vector.
/// </summary>
/// <remarks>
/// <see cref="Vector3.LengthSquared"/> may be preferred when only the relative length is needed
/// and speed is of the essence.
/// </remarks>
/// <summary>
/// Calculates the squared length of the vector.
/// </summary>
/// <remarks>
/// This property may be preferred to <see cref="Vector3.Length"/> when only a relative length is needed
/// and speed is of the essence.
/// </remarks>
/// <summary>
/// Gets or sets the component at the specified index.
/// </summary>
/// <value>The value of the X, Y, or Z component, depending on the index.</value>
/// <param name="index">The index of the component to access. Use 0 for the X component, 1 for the Y component, and 2 for the Z component.</param>
/// <returns>The value of the component at the specified index.</returns>
/// <exception cref="System.ArgumentOutOfRangeException">Thrown when the <paramref name="index"/> is out of the range [0, 2].</exception>
/// <summary>
/// Converts the vector into a unit vector.
/// </summary>
/// <summary>
/// Reverses the direction of a given vector.
/// </summary>
/// <summary>
/// Takes the absolute value of each component.
/// </summary>
/// <summary>
/// Creates an array containing the elements of the vector.
/// </summary>
/// <returns>A three-element array containing the components of the vector.</returns>
/// <summary>
/// Takes the square root of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the square root of.</param>
/// <param name="result">When the method completes, contains a vector that is the square root of the input vector.</param>
/// <summary>
/// Takes the square root of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the square root of.</param>
/// <returns>A vector that is the square root of the input vector.</returns>
/// <summary>
/// Takes the reciprocal of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the reciprocal of.</param>
/// <param name="result">When the method completes, contains a vector that is the reciprocal of the input vector.</param>
/// <summary>
/// Takes the reciprocal of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the reciprocal of.</param>
/// <returns>A vector that is the reciprocal of the input vector.</returns>
/// <summary>
/// Takes the square root of each component in the vector and than takes the reciprocal of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the square root and recpirocal of.</param>
/// <param name="result">When the method completes, contains a vector that is the square root and reciprocal of the input vector.</param>
/// <summary>
/// Takes the square root of each component in the vector and than takes the reciprocal of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the square root and recpirocal of.</param>
/// <returns>A vector that is the square root and reciprocal of the input vector.</returns>
/// <summary>
/// Takes e raised to the component in the vector.
/// </summary>
/// <param name="value">The value to take e raised to each component of.</param>
/// <param name="result">When the method completes, contains a vector that has e raised to each of the components in the input vector.</param>
/// <summary>
/// Takes e raised to the component in the vector.
/// </summary>
/// <param name="value">The value to take e raised to each component of.</param>
/// <returns>A vector that has e raised to each of the components in the input vector.</returns>
/// <summary>
/// Takes the sine and than the cosine of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the sine and cosine of.</param>
/// <param name="sinResult">When the method completes, contains the sine of each component in the input vector.</param>
/// <param name="cosResult">When the method completes, contains the cpsome pf each component in the input vector.</param>
/// <summary>
/// Takes the sine of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the sine of.</param>
/// <param name="result">When the method completes, a vector that contains the sine of each component in the input vector.</param>
/// <summary>
/// Takes the sine of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the sine of.</param>
/// <returns>A vector that contains the sine of each component in the input vector.</returns>
/// <summary>
/// Takes the cosine of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the cosine of.</param>
/// <param name="result">When the method completes, contains a vector that contains the cosine of each component in the input vector.</param>
/// <summary>
/// Takes the cosine of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the cosine of.</param>
/// <returns>A vector that contains the cosine of each component in the input vector.</returns>
/// <summary>
/// Takes the tangent of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the tangent of.</param>
/// <param name="result">When the method completes, contains a vector that contains the tangent of each component in the input vector.</param>
/// <summary>
/// Takes the tangent of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the tangent of.</param>
/// <returns>A vector that contains the tangent of each component in the input vector.</returns>
/// <summary>
/// Adds two vectors.
/// </summary>
/// <param name="left">The first vector to add.</param>
/// <param name="right">The second vector to add.</param>
/// <param name="result">When the method completes, contains the sum of the two vectors.</param>
/// <summary>
/// Adds two vectors.
/// </summary>
/// <param name="left">The first vector to add.</param>
/// <param name="right">The second vector to add.</param>
/// <returns>The sum of the two vectors.</returns>
/// <summary>
/// Subtracts two vectors.
/// </summary>
/// <param name="left">The first vector to subtract.</param>
/// <param name="right">The second vector to subtract.</param>
/// <param name="result">When the method completes, contains the difference of the two vectors.</param>
/// <summary>
/// Subtracts two vectors.
/// </summary>
/// <param name="left">The first vector to subtract.</param>
/// <param name="right">The second vector to subtract.</param>
/// <returns>The difference of the two vectors.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <param name="result">When the method completes, contains the scaled vector.</param>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Modulates a vector with another by performing component-wise multiplication.
/// </summary>
/// <param name="left">The first vector to modulate.</param>
/// <param name="right">The second vector to modulate.</param>
/// <param name="result">When the method completes, contains the modulated vector.</param>
/// <summary>
/// Modulates a vector with another by performing component-wise multiplication.
/// </summary>
/// <param name="left">The first vector to modulate.</param>
/// <param name="right">The second vector to modulate.</param>
/// <returns>The modulated vector.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <param name="result">When the method completes, contains the scaled vector.</param>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Reverses the direction of a given vector.
/// </summary>
/// <param name="value">The vector to negate.</param>
/// <param name="result">When the method completes, contains a vector facing in the opposite direction.</param>
/// <summary>
/// Reverses the direction of a given vector.
/// </summary>
/// <param name="value">The vector to negate.</param>
/// <returns>A vector facing in the opposite direction.</returns>
/// <summary>
/// Takes the absolute value of each component.
/// </summary>
/// <param name="value">The vector to take the absolute value of.</param>
/// <param name="result">When the method completes, contains a vector that has all positive components.</param>
/// <summary>
/// Takes the absolute value of each component.
/// </summary>
/// <param name="value">The vector to take the absolute value of.</param>
/// <returns>A vector that has all positive components.</returns>
/// <summary>
/// Returns a <see cref="Vector3"/> containing the 3D Cartesian coordinates of a point specified in Barycentric coordinates relative to a 3D triangle.
/// </summary>
/// <param name="value1">A <see cref="Vector3"/> containing the 3D Cartesian coordinates of vertex 1 of the triangle.</param>
/// <param name="value2">A <see cref="Vector3"/> containing the 3D Cartesian coordinates of vertex 2 of the triangle.</param>
/// <param name="value3">A <see cref="Vector3"/> containing the 3D Cartesian coordinates of vertex 3 of the triangle.</param>
/// <param name="amount1">Barycentric coordinate b2, which expresses the weighting factor toward vertex 2 (specified in <paramref name="value2"/>).</param>
/// <param name="amount2">Barycentric coordinate b3, which expresses the weighting factor toward vertex 3 (specified in <paramref name="value3"/>).</param>
/// <param name="result">When the method completes, contains the 3D Cartesian coordinates of the specified point.</param>
/// <summary>
/// Returns a <see cref="Vector3"/> containing the 3D Cartesian coordinates of a point specified in Barycentric coordinates relative to a 3D triangle.
/// </summary>
/// <param name="value1">A <see cref="Vector3"/> containing the 3D Cartesian coordinates of vertex 1 of the triangle.</param>
/// <param name="value2">A <see cref="Vector3"/> containing the 3D Cartesian coordinates of vertex 2 of the triangle.</param>
/// <param name="value3">A <see cref="Vector3"/> containing the 3D Cartesian coordinates of vertex 3 of the triangle.</param>
/// <param name="amount1">Barycentric coordinate b2, which expresses the weighting factor toward vertex 2 (specified in <paramref name="value2"/>).</param>
/// <param name="amount2">Barycentric coordinate b3, which expresses the weighting factor toward vertex 3 (specified in <paramref name="value3"/>).</param>
/// <returns>A new <see cref="Vector3"/> containing the 3D Cartesian coordinates of the specified point.</returns>
/// <summary>
/// Restricts a value to be within a specified range.
/// </summary>
/// <param name="value">The value to clamp.</param>
/// <param name="min">The minimum value.</param>
/// <param name="max">The maximum value.</param>
/// <param name="result">When the method completes, contains the clamped value.</param>
/// <summary>
/// Restricts a value to be within a specified range.
/// </summary>
/// <param name="value">The value to clamp.</param>
/// <param name="min">The minimum value.</param>
/// <param name="max">The maximum value.</param>
/// <returns>The clamped value.</returns>
/// <summary>
/// Calculates the cross product of two vectors.
/// </summary>
/// <param name="left">First source vector.</param>
/// <param name="right">Second source vector.</param>
/// <param name="result">When the method completes, contains the cross product of the two vectors.</param>
/// <summary>
/// Calculates the cross product of two vectors.
/// </summary>
/// <param name="left">First source vector.</param>
/// <param name="right">Second source vector.</param>
/// <returns>The cross product of the two vectors.</returns>
/// <summary>
/// Calculates the cross product of two vectors.
/// </summary>
/// <param name="v">Second source vector.</param>
/// <returns>The cross product of the two vectors.</returns>
/// <summary>
/// Calculates the tripple cross product of three vectors.
/// </summary>
/// <param name="value1">First source vector.</param>
/// <param name="value2">Second source vector.</param>
/// <param name="value3">Third source vector.</param>
/// <param name="result">When the method completes, contains the triple cross product of the three vectors.</param>
/// <summary>
/// Calculates the tripple cross product of three vectors.
/// </summary>
/// <param name="value1">First source vector.</param>
/// <param name="value2">Second source vector.</param>
/// <param name="value3">Third source vector.</param>
/// <returns>The tripple cross product of the three vectors.</returns>
/// <summary>
/// Calculates the distance between two vectors.
/// </summary>
/// <param name="value1">The first vector.</param>
/// <param name="value2">The second vector.</param>
/// <param name="result">When the method completes, contains the distance between the two vectors.</param>
/// <remarks>
/// <see cref="Vector3.DistanceSquared(ref Vector3, ref Vector3, out float)"/> may be preferred when only the relative distance is needed
/// and speed is of the essence.
/// </remarks>
/// <summary>
/// Calculates the distance between two vectors.
/// </summary>
/// <param name="value1">The first vector.</param>
/// <param name="value2">The second vector.</param>
/// <returns>The distance between the two vectors.</returns>
/// <remarks>
/// <see cref="Vector3.DistanceSquared(Vector3, Vector3)"/> may be preferred when only the relative distance is needed
/// and speed is of the essence.
/// </remarks>
/// <summary>
/// Calculates the squared distance between two vectors.
/// </summary>
/// <param name="value1">The first vector.</param>
/// <param name="value2">The second vector.</param>
/// <param name="result">When the method completes, contains the squared distance between the two vectors.</param>
/// <remarks>Distance squared is the value before taking the square root. 
/// Distance squared can often be used in place of distance if relative comparisons are being made. 
/// For example, consider three points A, B, and C. To determine whether B or C is further from A, 
/// compare the distance between A and B to the distance between A and C. Calculating the two distances 
/// involves two square roots, which are computationally expensive. However, using distance squared 
/// provides the same information and avoids calculating two square roots.
/// </remarks>
/// <summary>
/// Calculates the squared distance between two vectors.
/// </summary>
/// <param name="value1">The first vector.</param>
/// <param name="value2">The second vector.</param>
/// <returns>The squared distance between the two vectors.</returns>
/// <remarks>Distance squared is the value before taking the square root. 
/// Distance squared can often be used in place of distance if relative comparisons are being made. 
/// For example, consider three points A, B, and C. To determine whether B or C is further from A, 
/// compare the distance between A and B to the distance between A and C. Calculating the two distances 
/// involves two square roots, which are computationally expensive. However, using distance squared 
/// provides the same information and avoids calculating two square roots.
/// </remarks>
/// <summary>
/// Calculates the dot product of two vectors.
/// </summary>
/// <param name="left">First source vector.</param>
/// <param name="right">Second source vector.</param>
/// <param name="result">When the method completes, contains the dot product of the two vectors.</param>
/// <summary>
/// Calculates the dot product of two vectors.
/// </summary>
/// <param name="left">First source vector.</param>
/// <param name="right">Second source vector.</param>
/// <returns>The dot product of the two vectors.</returns>
/// <summary>
/// Calculates the dot product of two vectors.
/// </summary>
/// <param name="v">Second source vector.</param>
/// <param name="result">When the method completes, contains the dot product of the two vectors.</param>
/// <summary>
/// Calculates the dot product of two vectors.
/// </summary>
/// <param name="v">Second source vector.</param>
/// <returns>The dot product of the two vectors.</returns>
/// <summary>
/// Converts the vector into a unit vector.
/// </summary>
/// <param name="value">The vector to normalize.</param>
/// <param name="result">When the method completes, contains the normalized vector.</param>
/// <summary>
/// Converts the vector into a unit vector.
/// </summary>
/// <param name="value">The vector to normalize.</param>
/// <returns>The normalized vector.</returns>
/// <summary>
/// Performs a linear interpolation between two vectors.
/// </summary>
/// <param name="start">Start vector.</param>
/// <param name="end">End vector.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <param name="result">When the method completes, contains the linear interpolation of the two vectors.</param>
/// <remarks>
/// This method performs the linear interpolation based on the following formula.
/// <code>start + (end - start) * amount</code>
/// Passing <paramref name="amount"/> a value of 0 will cause <paramref name="start"/> to be returned; a value of 1 will cause <paramref name="end"/> to be returned. 
/// </remarks>
/// <summary>
/// Performs a linear interpolation between two vectors.
/// </summary>
/// <param name="start">Start vector.</param>
/// <param name="end">End vector.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <returns>The linear interpolation of the two vectors.</returns>
/// <remarks>
/// This method performs the linear interpolation based on the following formula.
/// <code>start + (end - start) * amount</code>
/// Passing <paramref name="amount"/> a value of 0 will cause <paramref name="start"/> to be returned; a value of 1 will cause <paramref name="end"/> to be returned. 
/// </remarks>
/// <summary>
/// Performs a cubic interpolation between two vectors.
/// </summary>
/// <param name="start">Start vector.</param>
/// <param name="end">End vector.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <param name="result">When the method completes, contains the cubic interpolation of the two vectors.</param>
/// <summary>
/// Performs a cubic interpolation between two vectors.
/// </summary>
/// <param name="start">Start vector.</param>
/// <param name="end">End vector.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <returns>The cubic interpolation of the two vectors.</returns>
/// <summary>
/// Performs a Hermite spline interpolation.
/// </summary>
/// <param name="value1">First source position vector.</param>
/// <param name="tangent1">First source tangent vector.</param>
/// <param name="value2">Second source position vector.</param>
/// <param name="tangent2">Second source tangent vector.</param>
/// <param name="amount">Weighting factor.</param>
/// <param name="result">When the method completes, contains the result of the Hermite spline interpolation.</param>
/// <summary>
/// Performs a Hermite spline interpolation.
/// </summary>
/// <param name="value1">First source position vector.</param>
/// <param name="tangent1">First source tangent vector.</param>
/// <param name="value2">Second source position vector.</param>
/// <param name="tangent2">Second source tangent vector.</param>
/// <param name="amount">Weighting factor.</param>
/// <returns>The result of the Hermite spline interpolation.</returns>
/// <summary>
/// Performs a Catmull-Rom interpolation using the specified positions.
/// </summary>
/// <param name="value1">The first position in the interpolation.</param>
/// <param name="value2">The second position in the interpolation.</param>
/// <param name="value3">The third position in the interpolation.</param>
/// <param name="value4">The fourth position in the interpolation.</param>
/// <param name="amount">Weighting factor.</param>
/// <param name="result">When the method completes, contains the result of the Catmull-Rom interpolation.</param>
/// <summary>
/// Performs a Catmull-Rom interpolation using the specified positions.
/// </summary>
/// <param name="value1">The first position in the interpolation.</param>
/// <param name="value2">The second position in the interpolation.</param>
/// <param name="value3">The third position in the interpolation.</param>
/// <param name="value4">The fourth position in the interpolation.</param>
/// <param name="amount">Weighting factor.</param>
/// <returns>A vector that is the result of the Catmull-Rom interpolation.</returns>
/// <summary>
/// Returns a vector containing the largest components of the specified vectors.
/// </summary>
/// <param name="value1">The first source vector.</param>
/// <param name="value2">The second source vector.</param>
/// <param name="result">When the method completes, contains an new vector composed of the largest components of the source vectors.</param>
/// <summary>
/// Returns a vector containing the largest components of the specified vectors.
/// </summary>
/// <param name="value1">The first source vector.</param>
/// <param name="value2">The second source vector.</param>
/// <returns>A vector containing the largest components of the source vectors.</returns>
/// <summary>
/// Returns a vector containing the smallest components of the specified vectors.
/// </summary>
/// <param name="value1">The first source vector.</param>
/// <param name="value2">The second source vector.</param>
/// <param name="result">When the method completes, contains an new vector composed of the smallest components of the source vectors.</param>
/// <summary>
/// Returns a vector containing the smallest components of the specified vectors.
/// </summary>
/// <param name="value1">The first source vector.</param>
/// <param name="value2">The second source vector.</param>
/// <returns>A vector containing the smallest components of the source vectors.</returns>
/// <summary>
/// Projects a 3D vector from object space into screen space. 
/// </summary>
/// <param name="vector">The vector to project.</param>
/// <param name="x">The X position of the viewport.</param>
/// <param name="y">The Y position of the viewport.</param>
/// <param name="width">The width of the viewport.</param>
/// <param name="height">The height of the viewport.</param>
/// <param name="minZ">The minimum depth of the viewport.</param>
/// <param name="maxZ">The maximum depth of the viewport.</param>
/// <param name="worldViewProjection">The combined world-view-projection matrix.</param>
/// <param name="result">When the method completes, contains the vector in screen space.</param>
/// <summary>
/// Projects a 3D vector from object space into screen space. 
/// </summary>
/// <param name="vector">The vector to project.</param>
/// <param name="x">The X position of the viewport.</param>
/// <param name="y">The Y position of the viewport.</param>
/// <param name="width">The width of the viewport.</param>
/// <param name="height">The height of the viewport.</param>
/// <param name="minZ">The minimum depth of the viewport.</param>
/// <param name="maxZ">The maximum depth of the viewport.</param>
/// <param name="worldViewProjection">The combined world-view-projection matrix.</param>
/// <returns>The vector in screen space.</returns>
/// <summary>
/// Projects a 3D vector from screen space into object space. 
/// </summary>
/// <param name="vector">The vector to project.</param>
/// <param name="x">The X position of the viewport.</param>
/// <param name="y">The Y position of the viewport.</param>
/// <param name="width">The width of the viewport.</param>
/// <param name="height">The height of the viewport.</param>
/// <param name="minZ">The minimum depth of the viewport.</param>
/// <param name="maxZ">The maximum depth of the viewport.</param>
/// <param name="worldViewProjection">The combined world-view-projection matrix.</param>
/// <param name="result">When the method completes, contains the vector in object space.</param>
/// <summary>
/// Projects a 3D vector from screen space into object space. 
/// </summary>
/// <param name="vector">The vector to project.</param>
/// <param name="x">The X position of the viewport.</param>
/// <param name="y">The Y position of the viewport.</param>
/// <param name="width">The width of the viewport.</param>
/// <param name="height">The height of the viewport.</param>
/// <param name="minZ">The minimum depth of the viewport.</param>
/// <param name="maxZ">The maximum depth of the viewport.</param>
/// <param name="worldViewProjection">The combined world-view-projection matrix.</param>
/// <returns>The vector in object space.</returns>
/// <summary>
/// Returns the reflection of a vector off a surface that has the specified normal. 
/// </summary>
/// <param name="vector">The source vector.</param>
/// <param name="normal">Normal of the surface.</param>
/// <param name="result">When the method completes, contains the reflected vector.</param>
/// <remarks>Reflect only gives the direction of a reflection off a surface, it does not determine 
/// whether the original vector was close enough to the surface to hit it.</remarks>
/// <summary>
/// Returns the reflection of a vector off a surface that has the specified normal. 
/// </summary>
/// <param name="vector">The source vector.</param>
/// <param name="normal">Normal of the surface.</param>
/// <returns>The reflected vector.</returns>
/// <remarks>Reflect only gives the direction of a reflection off a surface, it does not determine 
/// whether the original vector was close enough to the surface to hit it.</remarks>
/// <summary>
/// Returns the fraction of a vector off a surface that has the specified normal and index.
/// </summary>
/// <param name="vector">The source vector.</param>
/// <param name="normal">Normal of the surface.</param>
/// <param name="index">Index of refraction.</param>
/// <param name="result">When the method completes, contains the refracted vector.</param>
/// <summary>
/// Returns the fraction of a vector off a surface that has the specified normal and index.
/// </summary>
/// <param name="vector">The source vector.</param>
/// <param name="normal">Normal of the surface.</param>
/// <param name="index">Index of refraction.</param>
/// <returns>The refracted vector.</returns>
/// <summary>
/// Orthogonalizes a list of vectors.
/// </summary>
/// <param name="destination">The list of orthogonalized vectors.</param>
/// <param name="source">The list of vectors to orthogonalize.</param>
/// <remarks>
/// <para>Orthogonalization is the process of making all vectors orthogonal to each other. This
/// means that any given vector in the list will be orthogonal to any other given vector in the
/// list.</para>
/// <para>Because this method uses the modified Gram-Schmidt process, the resulting vectors
/// tend to be numerically unstable. The numeric stability decreases according to the vectors
/// position in the list so that the first vector is the most stable and the last vector is the
/// least stable.</para>
/// </remarks>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="source"/> or <paramref name="destination"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="destination"/> is shorter in length than <paramref name="source"/>.</exception>
//Uses the modified Gram-Schmidt process.
//q1 = m1
//q2 = m2 - ((q1 ⋅ m2) / (q1 ⋅ q1)) * q1
//q3 = m3 - ((q1 ⋅ m3) / (q1 ⋅ q1)) * q1 - ((q2 ⋅ m3) / (q2 ⋅ q2)) * q2
//q4 = m4 - ((q1 ⋅ m4) / (q1 ⋅ q1)) * q1 - ((q2 ⋅ m4) / (q2 ⋅ q2)) * q2 - ((q3 ⋅ m4) / (q3 ⋅ q3)) * q3
//q5 = ...
/// <summary>
/// Orthonormalizes a list of vectors.
/// </summary>
/// <param name="destination">The list of orthonormalized vectors.</param>
/// <param name="source">The list of vectors to orthonormalize.</param>
/// <remarks>
/// <para>Orthonormalization is the process of making all vectors orthogonal to each
/// other and making all vectors of unit length. This means that any given vector will
/// be orthogonal to any other given vector in the list.</para>
/// <para>Because this method uses the modified Gram-Schmidt process, the resulting vectors
/// tend to be numerically unstable. The numeric stability decreases according to the vectors
/// position in the list so that the first vector is the most stable and the last vector is the
/// least stable.</para>
/// </remarks>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="source"/> or <paramref name="destination"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="destination"/> is shorter in length than <paramref name="source"/>.</exception>
//Uses the modified Gram-Schmidt process.
//Because we are making unit vectors, we can optimize the math for orthogonalization
//and simplify the projection operation to remove the division.
//q1 = m1 / |m1|
//q2 = (m2 - (q1 ⋅ m2) * q1) / |m2 - (q1 ⋅ m2) * q1|
//q3 = (m3 - (q1 ⋅ m3) * q1 - (q2 ⋅ m3) * q2) / |m3 - (q1 ⋅ m3) * q1 - (q2 ⋅ m3) * q2|
//q4 = (m4 - (q1 ⋅ m4) * q1 - (q2 ⋅ m4) * q2 - (q3 ⋅ m4) * q3) / |m4 - (q1 ⋅ m4) * q1 - (q2 ⋅ m4) * q2 - (q3 ⋅ m4) * q3|
//q5 = ...
/// <summary>
/// Transforms a 3D vector by the given <see cref="Quaternion"/> rotation.
/// </summary>
/// <param name="vector">The vector to rotate.</param>
/// <param name="rotation">The <see cref="Quaternion"/> rotation to apply.</param>
/// <param name="result">When the method completes, contains the transformed <see cref="Vector4"/>.</param>
/// <summary>
/// Transforms a 3D vector by the given <see cref="Quaternion"/> rotation.
/// </summary>
/// <param name="vector">The vector to rotate.</param>
/// <param name="rotation">The <see cref="Quaternion"/> rotation to apply.</param>
/// <returns>The transformed <see cref="Vector4"/>.</returns>
/// <summary>
/// Transforms an array of vectors by the given <see cref="Quaternion"/> rotation.
/// </summary>
/// <param name="source">The array of vectors to transform.</param>
/// <param name="rotation">The <see cref="Quaternion"/> rotation to apply.</param>
/// <param name="destination">The array for which the transformed vectors are stored.
/// This array may be the same array as <paramref name="source"/>.</param>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="source"/> or <paramref name="destination"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="destination"/> is shorter in length than <paramref name="source"/>.</exception>
/// <summary>
/// Transforms a 3D vector by the given <see cref="Matrix"/>.
/// </summary>
/// <param name="vector">The source vector.</param>
/// <param name="transform">The transformation <see cref="Matrix"/>.</param>
/// <param name="result">When the method completes, contains the transformed <see cref="Vector4"/>.</param>
/// <summary>
/// Transforms a 3D vector by the given <see cref="Matrix"/>.
/// </summary>
/// <param name="vector">The source vector.</param>
/// <param name="transform">The transformation <see cref="Matrix"/>.</param>
/// <returns>The transformed <see cref="Vector4"/>.</returns>
/// <summary>
/// Transforms an array of 3D vectors by the given <see cref="Matrix"/>.
/// </summary>
/// <param name="source">The array of vectors to transform.</param>
/// <param name="transform">The transformation <see cref="Matrix"/>.</param>
/// <param name="destination">The array for which the transformed vectors are stored.</param>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="source"/> or <paramref name="destination"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="destination"/> is shorter in length than <paramref name="source"/>.</exception>
/// <summary>
/// Performs a coordinate transformation using the given <see cref="Matrix"/>.
/// </summary>
/// <param name="coordinate">The coordinate vector to transform.</param>
/// <param name="transform">The transformation <see cref="Matrix"/>.</param>
/// <param name="result">When the method completes, contains the transformed coordinates.</param>
/// <remarks>
/// A coordinate transform performs the transformation with the assumption that the w component
/// is one. The four dimensional vector obtained from the transformation operation has each
/// component in the vector divided by the w component. This forces the wcomponent to be one and
/// therefore makes the vector homogeneous. The homogeneous vector is often prefered when working
/// with coordinates as the w component can safely be ignored.
/// </remarks>
/// <summary>
/// Performs a coordinate transformation using the given <see cref="Matrix"/>.
/// </summary>
/// <param name="coordinate">The coordinate vector to transform.</param>
/// <param name="transform">The transformation <see cref="Matrix"/>.</param>
/// <returns>The transformed coordinates.</returns>
/// <remarks>
/// A coordinate transform performs the transformation with the assumption that the w component
/// is one. The four dimensional vector obtained from the transformation operation has each
/// component in the vector divided by the w component. This forces the wcomponent to be one and
/// therefore makes the vector homogeneous. The homogeneous vector is often prefered when working
/// with coordinates as the w component can safely be ignored.
/// </remarks>
/// <summary>
/// Performs a coordinate transformation on an array of vectors using the given <see cref="Matrix"/>.
/// </summary>
/// <param name="source">The array of coordinate vectors to trasnform.</param>
/// <param name="transform">The transformation <see cref="Matrix"/>.</param>
/// <param name="destination">The array for which the transformed vectors are stored.
/// This array may be the same array as <paramref name="source"/>.</param>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="source"/> or <paramref name="destination"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="destination"/> is shorter in length than <paramref name="source"/>.</exception>
/// <remarks>
/// A coordinate transform performs the transformation with the assumption that the w component
/// is one. The four dimensional vector obtained from the transformation operation has each
/// component in the vector divided by the w component. This forces the wcomponent to be one and
/// therefore makes the vector homogeneous. The homogeneous vector is often prefered when working
/// with coordinates as the w component can safely be ignored.
/// </remarks>
/// <summary>
/// Performs a normal transformation using the given <see cref="Matrix"/>.
/// </summary>
/// <param name="normal">The normal vector to transform.</param>
/// <param name="transform">The transformation <see cref="Matrix"/>.</param>
/// <param name="result">When the method completes, contains the transformed normal.</param>
/// <remarks>
/// A normal transform performs the transformation with the assumption that the w component
/// is zero. This causes the fourth row and fourth collumn of the matrix to be unused. The
/// end result is a vector that is not translated, but all other transformation properties
/// apply. This is often prefered for normal vectors as normals purely represent direction
/// rather than location because normal vectors should not be translated.
/// </remarks>
/// <summary>
/// Performs a normal transformation using the given <see cref="Matrix"/>.
/// </summary>
/// <param name="normal">The normal vector to transform.</param>
/// <param name="transform">The transformation <see cref="Matrix"/>.</param>
/// <returns>The transformed normal.</returns>
/// <remarks>
/// A normal transform performs the transformation with the assumption that the w component
/// is zero. This causes the fourth row and fourth collumn of the matrix to be unused. The
/// end result is a vector that is not translated, but all other transformation properties
/// apply. This is often prefered for normal vectors as normals purely represent direction
/// rather than location because normal vectors should not be translated.
/// </remarks>
/// <summary>
/// Performs a normal transformation on an array of vectors using the given <see cref="Matrix"/>.
/// </summary>
/// <param name="source">The array of normal vectors to transform.</param>
/// <param name="transform">The transformation <see cref="Matrix"/>.</param>
/// <param name="destination">The array for which the transformed vectors are stored.
/// This array may be the same array as <paramref name="source"/>.</param>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="source"/> or <paramref name="destination"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="destination"/> is shorter in length than <paramref name="source"/>.</exception>
/// <remarks>
/// A normal transform performs the transformation with the assumption that the w component
/// is zero. This causes the fourth row and fourth collumn of the matrix to be unused. The
/// end result is a vector that is not translated, but all other transformation properties
/// apply. This is often prefered for normal vectors as normals purely represent direction
/// rather than location because normal vectors should not be translated.
/// </remarks>
/// <summary>
/// Adds two vectors.
/// </summary>
/// <param name="left">The first vector to add.</param>
/// <param name="right">The second vector to add.</param>
/// <returns>The sum of the two vectors.</returns>
/// <summary>
/// Assert a vector (return it unchanged).
/// </summary>
/// <param name="value">The vector to assert (unchange).</param>
/// <returns>The asserted (unchanged) vector.</returns>
/// <summary>
/// Subtracts two vectors.
/// </summary>
/// <param name="left">The first vector to subtract.</param>
/// <param name="right">The second vector to subtract.</param>
/// <returns>The difference of the two vectors.</returns>
/// <summary>
/// Reverses the direction of a given vector.
/// </summary>
/// <param name="value">The vector to negate.</param>
/// <returns>A vector facing in the opposite direction.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="left">The vector to scale.</param>
/// <param name="right">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="left">The vector to scale.</param>
/// <param name="right">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Tests for equality between two objects.
/// </summary>
/// <param name="left">The first value to compare.</param>
/// <param name="right">The second value to compare.</param>
/// <returns><c>true</c> if <paramref name="left"/> has the same value as <paramref name="right"/>; otherwise, <c>false</c>.</returns>
/// <summary>
/// Tests for inequality between two objects.
/// </summary>
/// <param name="left">The first value to compare.</param>
/// <param name="right">The second value to compare.</param>
/// <returns><c>true</c> if <paramref name="left"/> has a different value than <paramref name="right"/>; otherwise, <c>false</c>.</returns>
/// <summary>
/// Performs an explicit conversion from <see cref="Vector3"/> to <see cref="Vector4"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <param name="format">The format.</param>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <param name="formatProvider">The format provider.</param>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <param name="format">The format.</param>
/// <param name="formatProvider">The format provider.</param>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a hash code for this instance.
/// </summary>
/// <returns>
/// A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
/// </returns>
/// <summary>
/// Determines whether the specified <see cref="Vector3"/> is equal to this instance.
/// </summary>
/// <param name="other">The <see cref="Vector3"/> to compare with this instance.</param>
/// <returns>
/// <c>true</c> if the specified <see cref="Vector3"/> is equal to this instance; otherwise, <c>false</c>.
/// </returns>
/// <summary>
/// Determines whether the specified <see cref="Vector3"/> is equal to this instance.
/// </summary>
/// <param name="other">The <see cref="Vector3"/> to compare with this instance.</param>
/// <param name="epsilon">The amount of error allowed.</param>
/// <returns>
/// <c>true</c> if the specified <see cref="Vector3"/> is equal to this instance; otherwise, <c>false</c>.
/// </returns>
/// <summary>
/// Determines whether the specified <see cref="System.Object"/> is equal to this instance.
/// </summary>
/// <param name="obj">The <see cref="System.Object"/> to compare with this instance.</param>
/// <returns>
/// <c>true</c> if the specified <see cref="System.Object"/> is equal to this instance; otherwise, <c>false</c>.
/// </returns>
/// <summary>
/// Performs an implicit conversion from <see cref="Vector3"/> to <see cref="SlimDX.Vector3"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="SlimDX.Vector3"/> to <see cref="Vector3"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="Vector3"/> to <see cref="System.Windows.Media.Media3D.Vector3D"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an explicit conversion from <see cref="System.Windows.Media.Media3D.Vector3D"/> to <see cref="Vector3"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="Vector3"/> to <see cref="Microsoft.Xna.Framework.Vector3"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="Microsoft.Xna.Framework.Vector3"/> to <see cref="Vector3"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/*
/// <summary>
/// Represents a four dimensional mathematical vector.
/// </summary>
//[TypeConverter(typeof(SlimMath.Design.Vector4Converter))]
/// <summary>
/// The size of the <see cref="SlimMath.Vector4"/> type, in bytes.
/// </summary>
/// <summary>
/// A <see cref="SlimMath.Vector4"/> with all of its components set to zero.
/// </summary>
/// <summary>
/// The X unit <see cref="SlimMath.Vector4"/> (1, 0, 0, 0).
/// </summary>
/// <summary>
/// The Y unit <see cref="SlimMath.Vector4"/> (0, 1, 0, 0).
/// </summary>
/// <summary>
/// The Z unit <see cref="SlimMath.Vector4"/> (0, 0, 1, 0).
/// </summary>
/// <summary>
/// The W unit <see cref="SlimMath.Vector4"/> (0, 0, 0, 1).
/// </summary>
/// <summary>
/// A <see cref="SlimMath.Vector4"/> with all of its components set to one.
/// </summary>
/// <summary>
/// The X component of the vector.
/// </summary>
/// <summary>
/// The Y component of the vector.
/// </summary>
/// <summary>
/// The Z component of the vector.
/// </summary>
/// <summary>
/// The W component of the vector.
/// </summary>
/// <summary>
/// Initializes a new instance of the <see cref="SlimMath.Vector4"/> struct.
/// </summary>
/// <param name="value">The value that will be assigned to all components.</param>
/// <summary>
/// Initializes a new instance of the <see cref="SlimMath.Vector4"/> struct.
/// </summary>
/// <param name="x">Initial value for the X component of the vector.</param>
/// <param name="y">Initial value for the Y component of the vector.</param>
/// <param name="z">Initial value for the Z component of the vector.</param>
/// <param name="w">Initial value for the W component of the vector.</param>
/// <summary>
/// Initializes a new instance of the <see cref="SlimMath.Vector4"/> struct.
/// </summary>
/// <param name="value">A vector containing the values with which to initialize the X, Y, and Z components.</param>
/// <param name="w">Initial value for the W component of the vector.</param>
/// <summary>
/// Initializes a new instance of the <see cref="SlimMath.Vector4"/> struct.
/// </summary>
/// <param name="values">The values to assign to the X, Y, Z, and W components of the vector. This must be an array with four elements.</param>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="values"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="values"/> contains more or less than four elements.</exception>
/// <summary>
/// Gets a value indicting whether this instance is normalized.
/// </summary>
/// <summary>
/// Calculates the length of the vector.
/// </summary>
/// <remarks>
/// <see cref="SlimMath.Vector4.LengthSquared"/> may be preferred when only the relative length is needed
/// and speed is of the essence.
/// </remarks>
/// <summary>
/// Calculates the squared length of the vector.
/// </summary>
/// <remarks>
/// This property may be preferred to <see cref="SlimMath.Vector4.Length"/> when only a relative length is needed
/// and speed is of the essence.
/// </remarks>
/// <summary>
/// Gets or sets the component at the specified index.
/// </summary>
/// <value>The value of the X, Y, Z, or W component, depending on the index.</value>
/// <param name="index">The index of the component to access. Use 0 for the X component, 1 for the Y component, 2 for the Z component, and 3 for the W component.</param>
/// <returns>The value of the component at the specified index.</returns>
/// <exception cref="System.ArgumentOutOfRangeException">Thrown when the <paramref name="index"/> is out of the range [0, 3].</exception>
/// <summary>
/// Converts the vector into a unit vector.
/// </summary>
/// <summary>
/// Reverses the direction of a given vector.
/// </summary>
/// <summary>
/// Takes the absolute value of each component.
/// </summary>
/// <summary>
/// Creates an array containing the elements of the vector.
/// </summary>
/// <returns>A four-element array containing the components of the vector.</returns>
/// <summary>
/// Takes the square root of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the square root of.</param>
/// <param name="result">When the method completes, contains a vector that is the square root of the input vector.</param>
/// <summary>
/// Takes the square root of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the square root of.</param>
/// <returns>A vector that is the square root of the input vector.</returns>
/// <summary>
/// Takes the reciprocal of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the reciprocal of.</param>
/// <param name="result">When the method completes, contains a vector that is the reciprocal of the input vector.</param>
/// <summary>
/// Takes the reciprocal of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the reciprocal of.</param>
/// <returns>A vector that is the reciprocal of the input vector.</returns>
/// <summary>
/// Takes the square root of each component in the vector and than takes the reciprocal of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the square root and recpirocal of.</param>
/// <param name="result">When the method completes, contains a vector that is the square root and reciprocal of the input vector.</param>
/// <summary>
/// Takes the square root of each component in the vector and than takes the reciprocal of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the square root and recpirocal of.</param>
/// <returns>A vector that is the square root and reciprocal of the input vector.</returns>
/// <summary>
/// Takes e raised to the component in the vector.
/// </summary>
/// <param name="value">The value to take e raised to each component of.</param>
/// <param name="result">When the method completes, contains a vector that has e raised to each of the components in the input vector.</param>
/// <summary>
/// Takes e raised to the component in the vector.
/// </summary>
/// <param name="value">The value to take e raised to each component of.</param>
/// <returns>A vector that has e raised to each of the components in the input vector.</returns>
/// <summary>
/// Takes the sine and than the cosine of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the sine and cosine of.</param>
/// <param name="sinResult">When the method completes, contains the sine of each component in the input vector.</param>
/// <param name="cosResult">When the method completes, contains the cpsome pf each component in the input vector.</param>
/// <summary>
/// Takes the sine of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the sine of.</param>
/// <param name="result">When the method completes, a vector that contains the sine of each component in the input vector.</param>
/// <summary>
/// Takes the sine of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the sine of.</param>
/// <returns>A vector that contains the sine of each component in the input vector.</returns>
/// <summary>
/// Takes the cosine of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the cosine of.</param>
/// <param name="result">When the method completes, contains a vector that contains the cosine of each component in the input vector.</param>
/// <summary>
/// Takes the cosine of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the cosine of.</param>
/// <returns>A vector that contains the cosine of each component in the input vector.</returns>
/// <summary>
/// Takes the tangent of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the tangent of.</param>
/// <param name="result">When the method completes, contains a vector that contains the tangent of each component in the input vector.</param>
/// <summary>
/// Takes the tangent of each component in the vector.
/// </summary>
/// <param name="value">The vector to take the tangent of.</param>
/// <returns>A vector that contains the tangent of each component in the input vector.</returns>
/// <summary>
/// Adds two vectors.
/// </summary>
/// <param name="left">The first vector to add.</param>
/// <param name="right">The second vector to add.</param>
/// <param name="result">When the method completes, contains the sum of the two vectors.</param>
/// <summary>
/// Adds two vectors.
/// </summary>
/// <param name="left">The first vector to add.</param>
/// <param name="right">The second vector to add.</param>
/// <returns>The sum of the two vectors.</returns>
/// <summary>
/// Subtracts two vectors.
/// </summary>
/// <param name="left">The first vector to subtract.</param>
/// <param name="right">The second vector to subtract.</param>
/// <param name="result">When the method completes, contains the difference of the two vectors.</param>
/// <summary>
/// Subtracts two vectors.
/// </summary>
/// <param name="left">The first vector to subtract.</param>
/// <param name="right">The second vector to subtract.</param>
/// <returns>The difference of the two vectors.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <param name="result">When the method completes, contains the scaled vector.</param>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Modulates a vector with another by performing component-wise multiplication.
/// </summary>
/// <param name="left">The first vector to modulate.</param>
/// <param name="right">The second vector to modulate.</param>
/// <param name="result">When the method completes, contains the modulated vector.</param>
/// <summary>
/// Modulates a vector with another by performing component-wise multiplication.
/// </summary>
/// <param name="left">The first vector to modulate.</param>
/// <param name="right">The second vector to modulate.</param>
/// <returns>The modulated vector.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <param name="result">When the method completes, contains the scaled vector.</param>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Reverses the direction of a given vector.
/// </summary>
/// <param name="value">The vector to negate.</param>
/// <param name="result">When the method completes, contains a vector facing in the opposite direction.</param>
/// <summary>
/// Reverses the direction of a given vector.
/// </summary>
/// <param name="value">The vector to negate.</param>
/// <returns>A vector facing in the opposite direction.</returns>
/// <summary>
/// Takes the absolute value of each component.
/// </summary>
/// <param name="value">The vector to take the absolute value of.</param>
/// <param name="result">When the method completes, contains a vector that has all positive components.</param>
/// <summary>
/// Takes the absolute value of each component.
/// </summary>
/// <param name="value">The vector to take the absolute value of.</param>
/// <returns>A vector that has all positive components.</returns>
/// <summary>
/// Returns a <see cref="SlimMath.Vector4"/> containing the 4D Cartesian coordinates of a point specified in Barycentric coordinates relative to a 4D triangle.
/// </summary>
/// <param name="value1">A <see cref="SlimMath.Vector4"/> containing the 4D Cartesian coordinates of vertex 1 of the triangle.</param>
/// <param name="value2">A <see cref="SlimMath.Vector4"/> containing the 4D Cartesian coordinates of vertex 2 of the triangle.</param>
/// <param name="value3">A <see cref="SlimMath.Vector4"/> containing the 4D Cartesian coordinates of vertex 3 of the triangle.</param>
/// <param name="amount1">Barycentric coordinate b2, which expresses the weighting factor toward vertex 2 (specified in <paramref name="value2"/>).</param>
/// <param name="amount2">Barycentric coordinate b3, which expresses the weighting factor toward vertex 3 (specified in <paramref name="value3"/>).</param>
/// <param name="result">When the method completes, contains the 4D Cartesian coordinates of the specified point.</param>
/// <summary>
/// Returns a <see cref="SlimMath.Vector4"/> containing the 4D Cartesian coordinates of a point specified in Barycentric coordinates relative to a 4D triangle.
/// </summary>
/// <param name="value1">A <see cref="SlimMath.Vector4"/> containing the 4D Cartesian coordinates of vertex 1 of the triangle.</param>
/// <param name="value2">A <see cref="SlimMath.Vector4"/> containing the 4D Cartesian coordinates of vertex 2 of the triangle.</param>
/// <param name="value3">A <see cref="SlimMath.Vector4"/> containing the 4D Cartesian coordinates of vertex 3 of the triangle.</param>
/// <param name="amount1">Barycentric coordinate b2, which expresses the weighting factor toward vertex 2 (specified in <paramref name="value2"/>).</param>
/// <param name="amount2">Barycentric coordinate b3, which expresses the weighting factor toward vertex 3 (specified in <paramref name="value3"/>).</param>
/// <returns>A new <see cref="SlimMath.Vector4"/> containing the 4D Cartesian coordinates of the specified point.</returns>
/// <summary>
/// Restricts a value to be within a specified range.
/// </summary>
/// <param name="value">The value to clamp.</param>
/// <param name="min">The minimum value.</param>
/// <param name="max">The maximum value.</param>
/// <param name="result">When the method completes, contains the clamped value.</param>
/// <summary>
/// Restricts a value to be within a specified range.
/// </summary>
/// <param name="value">The value to clamp.</param>
/// <param name="min">The minimum value.</param>
/// <param name="max">The maximum value.</param>
/// <returns>The clamped value.</returns>
/// <summary>
/// Calculates the distance between two vectors.
/// </summary>
/// <param name="value1">The first vector.</param>
/// <param name="value2">The second vector.</param>
/// <param name="result">When the method completes, contains the distance between the two vectors.</param>
/// <remarks>
/// <see cref="SlimMath.Vector4.DistanceSquared(ref Vector4, ref Vector4, out float)"/> may be preferred when only the relative distance is needed
/// and speed is of the essence.
/// </remarks>
/// <summary>
/// Calculates the distance between two vectors.
/// </summary>
/// <param name="value1">The first vector.</param>
/// <param name="value2">The second vector.</param>
/// <returns>The distance between the two vectors.</returns>
/// <remarks>
/// <see cref="SlimMath.Vector4.DistanceSquared(Vector4, Vector4)"/> may be preferred when only the relative distance is needed
/// and speed is of the essence.
/// </remarks>
/// <summary>
/// Calculates the squared distance between two vectors.
/// </summary>
/// <param name="value1">The first vector.</param>
/// <param name="value2">The second vector.</param>
/// <param name="result">When the method completes, contains the squared distance between the two vectors.</param>
/// <remarks>Distance squared is the value before taking the square root. 
/// Distance squared can often be used in place of distance if relative comparisons are being made. 
/// For example, consider three points A, B, and C. To determine whether B or C is further from A, 
/// compare the distance between A and B to the distance between A and C. Calculating the two distances 
/// involves two square roots, which are computationally expensive. However, using distance squared 
/// provides the same information and avoids calculating two square roots.
/// </remarks>
/// <summary>
/// Calculates the squared distance between two vectors.
/// </summary>
/// <param name="value1">The first vector.</param>
/// <param name="value2">The second vector.</param>
/// <returns>The squared distance between the two vectors.</returns>
/// <remarks>Distance squared is the value before taking the square root. 
/// Distance squared can often be used in place of distance if relative comparisons are being made. 
/// For example, consider three points A, B, and C. To determine whether B or C is further from A, 
/// compare the distance between A and B to the distance between A and C. Calculating the two distances 
/// involves two square roots, which are computationally expensive. However, using distance squared 
/// provides the same information and avoids calculating two square roots.
/// </remarks>
/// <summary>
/// Calculates the dot product of two vectors.
/// </summary>
/// <param name="left">First source vector</param>
/// <param name="right">Second source vector.</param>
/// <param name="result">When the method completes, contains the dot product of the two vectors.</param>
/// <summary>
/// Calculates the dot product of two vectors.
/// </summary>
/// <param name="left">First source vector.</param>
/// <param name="right">Second source vector.</param>
/// <returns>The dot product of the two vectors.</returns>
/// <summary>
/// Converts the vector into a unit vector.
/// </summary>
/// <param name="value">The vector to normalize.</param>
/// <param name="result">When the method completes, contains the normalized vector.</param>
/// <summary>
/// Converts the vector into a unit vector.
/// </summary>
/// <param name="value">The vector to normalize.</param>
/// <returns>The normalized vector.</returns>
/// <summary>
/// Performs a linear interpolation between two vectors.
/// </summary>
/// <param name="start">Start vector.</param>
/// <param name="end">End vector.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <param name="result">When the method completes, contains the linear interpolation of the two vectors.</param>
/// <remarks>
/// This method performs the linear interpolation based on the following formula.
/// <code>start + (end - start) * amount</code>
/// Passing <paramref name="amount"/> a value of 0 will cause <paramref name="start"/> to be returned; a value of 1 will cause <paramref name="end"/> to be returned. 
/// </remarks>
/// <summary>
/// Performs a linear interpolation between two vectors.
/// </summary>
/// <param name="start">Start vector.</param>
/// <param name="end">End vector.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <returns>The linear interpolation of the two vectors.</returns>
/// <remarks>
/// This method performs the linear interpolation based on the following formula.
/// <code>start + (end - start) * amount</code>
/// Passing <paramref name="amount"/> a value of 0 will cause <paramref name="start"/> to be returned; a value of 1 will cause <paramref name="end"/> to be returned. 
/// </remarks>
/// <summary>
/// Performs a cubic interpolation between two vectors.
/// </summary>
/// <param name="start">Start vector.</param>
/// <param name="end">End vector.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <param name="result">When the method completes, contains the cubic interpolation of the two vectors.</param>
/// <summary>
/// Performs a cubic interpolation between two vectors.
/// </summary>
/// <param name="start">Start vector.</param>
/// <param name="end">End vector.</param>
/// <param name="amount">Value between 0 and 1 indicating the weight of <paramref name="end"/>.</param>
/// <returns>The cubic interpolation of the two vectors.</returns>
/// <summary>
/// Performs a Hermite spline interpolation.
/// </summary>
/// <param name="value1">First source position vector.</param>
/// <param name="tangent1">First source tangent vector.</param>
/// <param name="value2">Second source position vector.</param>
/// <param name="tangent2">Second source tangent vector.</param>
/// <param name="amount">Weighting factor.</param>
/// <param name="result">When the method completes, contains the result of the Hermite spline interpolation.</param>
/// <summary>
/// Performs a Hermite spline interpolation.
/// </summary>
/// <param name="value1">First source position vector.</param>
/// <param name="tangent1">First source tangent vector.</param>
/// <param name="value2">Second source position vector.</param>
/// <param name="tangent2">Second source tangent vector.</param>
/// <param name="amount">Weighting factor.</param>
/// <returns>The result of the Hermite spline interpolation.</returns>
/// <summary>
/// Performs a Catmull-Rom interpolation using the specified positions.
/// </summary>
/// <param name="value1">The first position in the interpolation.</param>
/// <param name="value2">The second position in the interpolation.</param>
/// <param name="value3">The third position in the interpolation.</param>
/// <param name="value4">The fourth position in the interpolation.</param>
/// <param name="amount">Weighting factor.</param>
/// <param name="result">When the method completes, contains the result of the Catmull-Rom interpolation.</param>
/// <summary>
/// Performs a Catmull-Rom interpolation using the specified positions.
/// </summary>
/// <param name="value1">The first position in the interpolation.</param>
/// <param name="value2">The second position in the interpolation.</param>
/// <param name="value3">The third position in the interpolation.</param>
/// <param name="value4">The fourth position in the interpolation.</param>
/// <param name="amount">Weighting factor.</param>
/// <returns>A vector that is the result of the Catmull-Rom interpolation.</returns>
/// <summary>
/// Returns a vector containing the largest components of the specified vectors.
/// </summary>
/// <param name="value1">The first source vector.</param>
/// <param name="value2">The second source vector.</param>
/// <param name="result">When the method completes, contains an new vector composed of the largest components of the source vectors.</param>
/// <summary>
/// Returns a vector containing the largest components of the specified vectors.
/// </summary>
/// <param name="value1">The first source vector.</param>
/// <param name="value2">The second source vector.</param>
/// <returns>A vector containing the largest components of the source vectors.</returns>
/// <summary>
/// Returns a vector containing the smallest components of the specified vectors.
/// </summary>
/// <param name="value1">The first source vector.</param>
/// <param name="value2">The second source vector.</param>
/// <param name="result">When the method completes, contains an new vector composed of the smallest components of the source vectors.</param>
/// <summary>
/// Returns a vector containing the smallest components of the specified vectors.
/// </summary>
/// <param name="value1">The first source vector.</param>
/// <param name="value2">The second source vector.</param>
/// <returns>A vector containing the smallest components of the source vectors.</returns>
/// <summary>
/// Orthogonalizes a list of vectors.
/// </summary>
/// <param name="destination">The list of orthogonalized vectors.</param>
/// <param name="source">The list of vectors to orthogonalize.</param>
/// <remarks>
/// <para>Orthogonalization is the process of making all vectors orthogonal to each other. This
/// means that any given vector in the list will be orthogonal to any other given vector in the
/// list.</para>
/// <para>Because this method uses the modified Gram-Schmidt process, the resulting vectors
/// tend to be numerically unstable. The numeric stability decreases according to the vectors
/// position in the list so that the first vector is the most stable and the last vector is the
/// least stable.</para>
/// </remarks>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="source"/> or <paramref name="destination"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="destination"/> is shorter in length than <paramref name="source"/>.</exception>
//Uses the modified Gram-Schmidt process.
//q1 = m1
//q2 = m2 - ((q1 ⋅ m2) / (q1 ⋅ q1)) * q1
//q3 = m3 - ((q1 ⋅ m3) / (q1 ⋅ q1)) * q1 - ((q2 ⋅ m3) / (q2 ⋅ q2)) * q2
//q4 = m4 - ((q1 ⋅ m4) / (q1 ⋅ q1)) * q1 - ((q2 ⋅ m4) / (q2 ⋅ q2)) * q2 - ((q3 ⋅ m4) / (q3 ⋅ q3)) * q3
//q5 = ...
/// <summary>
/// Orthonormalizes a list of vectors.
/// </summary>
/// <param name="destination">The list of orthonormalized vectors.</param>
/// <param name="source">The list of vectors to orthonormalize.</param>
/// <remarks>
/// <para>Orthonormalization is the process of making all vectors orthogonal to each
/// other and making all vectors of unit length. This means that any given vector will
/// be orthogonal to any other given vector in the list.</para>
/// <para>Because this method uses the modified Gram-Schmidt process, the resulting vectors
/// tend to be numerically unstable. The numeric stability decreases according to the vectors
/// position in the list so that the first vector is the most stable and the last vector is the
/// least stable.</para>
/// </remarks>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="source"/> or <paramref name="destination"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="destination"/> is shorter in length than <paramref name="source"/>.</exception>
//Uses the modified Gram-Schmidt process.
//Because we are making unit vectors, we can optimize the math for orthogonalization
//and simplify the projection operation to remove the division.
//q1 = m1 / |m1|
//q2 = (m2 - (q1 ⋅ m2) * q1) / |m2 - (q1 ⋅ m2) * q1|
//q3 = (m3 - (q1 ⋅ m3) * q1 - (q2 ⋅ m3) * q2) / |m3 - (q1 ⋅ m3) * q1 - (q2 ⋅ m3) * q2|
//q4 = (m4 - (q1 ⋅ m4) * q1 - (q2 ⋅ m4) * q2 - (q3 ⋅ m4) * q3) / |m4 - (q1 ⋅ m4) * q1 - (q2 ⋅ m4) * q2 - (q3 ⋅ m4) * q3|
//q5 = ...
/// <summary>
/// Transforms a 4D vector by the given <see cref="SlimMath.Quaternion"/> rotation.
/// </summary>
/// <param name="vector">The vector to rotate.</param>
/// <param name="rotation">The <see cref="SlimMath.Quaternion"/> rotation to apply.</param>
/// <param name="result">When the method completes, contains the transformed <see cref="SlimMath.Vector4"/>.</param>
/// <summary>
/// Transforms a 4D vector by the given <see cref="SlimMath.Quaternion"/> rotation.
/// </summary>
/// <param name="vector">The vector to rotate.</param>
/// <param name="rotation">The <see cref="SlimMath.Quaternion"/> rotation to apply.</param>
/// <returns>The transformed <see cref="SlimMath.Vector4"/>.</returns>
/// <summary>
/// Transforms an array of vectors by the given <see cref="SlimMath.Quaternion"/> rotation.
/// </summary>
/// <param name="source">The array of vectors to transform.</param>
/// <param name="rotation">The <see cref="SlimMath.Quaternion"/> rotation to apply.</param>
/// <param name="destination">The array for which the transformed vectors are stored.
/// This array may be the same array as <paramref name="source"/>.</param>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="source"/> or <paramref name="destination"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="destination"/> is shorter in length than <paramref name="source"/>.</exception>
/// <summary>
/// Transforms a 4D vector by the given <see cref="SlimMath.Matrix"/>.
/// </summary>
/// <param name="vector">The source vector.</param>
/// <param name="transform">The transformation <see cref="SlimMath.Matrix"/>.</param>
/// <param name="result">When the method completes, contains the transformed <see cref="SlimMath.Vector4"/>.</param>
/// <summary>
/// Transforms a 4D vector by the given <see cref="SlimMath.Matrix"/>.
/// </summary>
/// <param name="vector">The source vector.</param>
/// <param name="transform">The transformation <see cref="SlimMath.Matrix"/>.</param>
/// <returns>The transformed <see cref="SlimMath.Vector4"/>.</returns>
/// <summary>
/// Transforms an array of 4D vectors by the given <see cref="SlimMath.Matrix"/>.
/// </summary>
/// <param name="source">The array of vectors to transform.</param>
/// <param name="transform">The transformation <see cref="SlimMath.Matrix"/>.</param>
/// <param name="destination">The array for which the transformed vectors are stored.
/// This array may be the same array as <paramref name="source"/>.</param>
/// <exception cref="ArgumentNullException">Thrown when <paramref name="source"/> or <paramref name="destination"/> is <c>null</c>.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown when <paramref name="destination"/> is shorter in length than <paramref name="source"/>.</exception>
/// <summary>
/// Adds two vectors.
/// </summary>
/// <param name="left">The first vector to add.</param>
/// <param name="right">The second vector to add.</param>
/// <returns>The sum of the two vectors.</returns>
/// <summary>
/// Assert a vector (return it unchanged).
/// </summary>
/// <param name="value">The vector to assert (unchange).</param>
/// <returns>The asserted (unchanged) vector.</returns>
/// <summary>
/// Subtracts two vectors.
/// </summary>
/// <param name="left">The first vector to subtract.</param>
/// <param name="right">The second vector to subtract.</param>
/// <returns>The difference of the two vectors.</returns>
/// <summary>
/// Reverses the direction of a given vector.
/// </summary>
/// <param name="value">The vector to negate.</param>
/// <returns>A vector facing in the opposite direction.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Scales a vector by the given value.
/// </summary>
/// <param name="value">The vector to scale.</param>
/// <param name="scalar">The amount by which to scale the vector.</param>
/// <returns>The scaled vector.</returns>
/// <summary>
/// Tests for equality between two objects.
/// </summary>
/// <param name="left">The first value to compare.</param>
/// <param name="right">The second value to compare.</param>
/// <returns><c>true</c> if <paramref name="left"/> has the same value as <paramref name="right"/>; otherwise, <c>false</c>.</returns>
/// <summary>
/// Tests for inequality between two objects.
/// </summary>
/// <param name="left">The first value to compare.</param>
/// <param name="right">The second value to compare.</param>
/// <returns><c>true</c> if <paramref name="left"/> has a different value than <paramref name="right"/>; otherwise, <c>false</c>.</returns>
/// <summary>
/// Performs an explicit conversion from <see cref="SlimMath.Vector4"/> to <see cref="SlimMath.Vector3"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <param name="format">The format.</param>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <param name="formatProvider">The format provider.</param>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a <see cref="System.String"/> that represents this instance.
/// </summary>
/// <param name="format">The format.</param>
/// <param name="formatProvider">The format provider.</param>
/// <returns>
/// A <see cref="System.String"/> that represents this instance.
/// </returns>
/// <summary>
/// Returns a hash code for this instance.
/// </summary>
/// <returns>
/// A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
/// </returns>
/// <summary>
/// Determines whether the specified <see cref="SlimMath.Vector4"/> is equal to this instance.
/// </summary>
/// <param name="other">The <see cref="SlimMath.Vector4"/> to compare with this instance.</param>
/// <returns>
/// <c>true</c> if the specified <see cref="SlimMath.Vector4"/> is equal to this instance; otherwise, <c>false</c>.
/// </returns>
/// <summary>
/// Determines whether the specified <see cref="SlimMath.Vector4"/> is equal to this instance.
/// </summary>
/// <param name="other">The <see cref="SlimMath.Vector4"/> to compare with this instance.</param>
/// <param name="epsilon">The amount of error allowed.</param>
/// <returns>
/// <c>true</c> if the specified <see cref="SlimMath.Vector4"/> is equal to this instance; otherwise, <c>false</c>.
/// </returns>
/// <summary>
/// Determines whether the specified <see cref="System.Object"/> is equal to this instance.
/// </summary>
/// <param name="obj">The <see cref="System.Object"/> to compare with this instance.</param>
/// <returns>
/// <c>true</c> if the specified <see cref="System.Object"/> is equal to this instance; otherwise, <c>false</c>.
/// </returns>
/// <summary>
/// Performs an implicit conversion from <see cref="SlimMath.Vector4"/> to <see cref="SlimDX.Vector4"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="SlimDX.Vector4"/> to <see cref="SlimMath.Vector4"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="SlimMath.Vector4"/> to <see cref="System.Windows.Media.Media3D.Point4D"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an explicit conversion from <see cref="System.Windows.Media.Media3D.Point4D"/> to <see cref="SlimMath.Vector4"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="SlimMath.Vector4"/> to <see cref="Microsoft.Xna.Framework.Vector4"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/// <summary>
/// Performs an implicit conversion from <see cref="Microsoft.Xna.Framework.Vector4"/> to <see cref="SlimMath.Vector4"/>.
/// </summary>
/// <param name="value">The value.</param>
/// <returns>The result of the conversion.</returns>
/*
//private AlignedScalarArray _masses;
/*
//private AlignedPSolverArray _dSequence;
//private AlignedPSolverArray _pSequence;
//private AlignedVSolverArray _vSequence;
/*
/*
/*
/*
/*
/*
//private AlignedScalarArray _wgh;
/*
//private ScalarArray _cfm;
/*
//private AlignedBoolArray _clusterConnectivity;
//private AlignedCollisionObjectArray _collisionDisabledObjects;
//private AlignedNoteArray _notes;
//private AlignedRigidContactArray _rigidContacts;
//private AlignedSoftContactArray _softContacts;
//private AlignedIntArray _userIndexMapping;
/*
/*
/*
/*
/*
// Do not use Array.Resize, because it copies the old data
/*
/*
/*
/*
/*
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btSoftBody_getSolver(_ solver);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btSoftBody_getSolver2(_ solver);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btSoftBody_setSolver(IntPtr obj, btSoftBody::eSolverPresets::_ preset);
//int numDims = int.Parse(nodeHeader[1]);
//int numAttrs = int.Parse(nodeHeader[2]);
//bool hasBounds = !nodeHeader[3].Equals("0");
/*
//int numCorners = int.Parse(eleHeader[1]);
//int numAttrs = int.Parse(eleHeader[2]);
//int index = int.Parse(eleLine[0], culture);
//Console.WriteLine("Nodes: {0}", psb.Nodes.Count);
//Console.WriteLine("Links: {0}", psb.Links.Count);
//Console.WriteLine("Faces: {0}", psb.Faces.Count);
//Console.WriteLine("Tetras: {0}", psb.Tetras.Count);
// triangles.Max() + 1;
// Create nodes
// Create links and faces
// Create nodes
// Create links
// ReoptimizeLinkOrder minimizes the cases where links L and L+1 share a common node.
// Link calculation input is dependent upon prior calculation #N
// Update the nodes to mark which ones are calculated by this link
// Add this dependent link calculation to the ready list if *both* inputs are clear
/*
/*
/*
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern SolverTypes btSoftBodySolver_getSolverType(IntPtr obj);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btSoftBodySolver_optimize(IntPtr obj, IntPtr softBodies);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btSoftBodySolver_optimize2(IntPtr obj, IntPtr softBodies, bool forceUpdate);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btSoftBodySolver_processCollision(IntPtr obj, IntPtr __unnamed0, IntPtr __unnamed1);
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern void btSoftBodySolver_processCollision2(IntPtr obj, IntPtr __unnamed0, IntPtr __unnamed1);
/*
// private ref passed to bodies during AddSoftBody
//[DllImport(Native.Dll, CallingConvention = Native.Conv), SuppressUnmanagedCodeSecurity]
//static extern IntPtr btSoftRigidDynamicsWorld_new(IntPtr dispatcher, IntPtr pairCache, IntPtr constraintSolver, IntPtr collisionConfiguration);
/* Returns the first CollisionObject the ray hits.
//BulletSharp.AllHitsRayResultCallback rayCallBack = new BulletSharp.AllHitsRayResultCallback(rayFrom, rayTo);
//Debug.Log("Casting ray from: " + rayFrom + " to: " + rayTo);
//Debug.Log("rayCallBack " + rayCallBack.GetType() + " had a hit: " + rayCallBack.CollisionObject.UserObject + " / of type: " + rayCallBack.CollisionObject.UserObject.GetType());
//0=x, 1=y, 2=z
//world.world.AddCollisionObject(m_collisionObject, CollisionFilterGroups.CharacterFilter, CollisionFilterGroups.StaticFilter | CollisionFilterGroups.DefaultFilter);
//((DynamicsWorld)world.world).AddAction(m_characterController);
//todo get PersistentManifoldList from object pool
//this is first contact with this other object
//might have multiple new contacts with same object stored in separate persistent manifolds
//don't add two different lists to new contacts
//don't add to otherObjs2ManifoldMap here. It messes up onStay do it after all pm's have been visited.
/// <summary>
///Beware of creating, destroying, adding or removing bullet objects inside these functions. Doing so can alter the list of collisions and ContactManifolds 
///that are being iteratated over
///(comodification). This can result in infinite loops, null pointer exceptions, out of sequence Enter,Stay,Exit, etc... A good way to handle this sitution is 
///to collect the information in these callbacks then override "OnFinishedVisitingManifolds" like:
///
/// public override void OnFinishedVisitingManifolds(){
///     base.OnFinishedVistingManifolds(); //don't omit this it does the callbacks
///     do my Instantiation and deletion here.
/// }
/// </summary>
//This is used to handle a design problem. 
//We want OnEnable to add physics object to world and OnDisable to remove.
//We also want user to be able to in script: AddComponent<CollisionObject>, configure it, add it to world, potentialy disable to delay it being added to world
//Problem is OnEnable gets called before Start so that developer has no chance to configure object before it is added to world or prevent
//It from being added.
//Solution is not to add object to the world until after Start has been called. Start will do the first add to world. 
// A bitmask
// A colliding object must match this mask in order to collide with me.
//called by Physics World just before rigid body is added to world.
//the current rigid body properties are used to rebuild the rigid body.
//rigidbody is dynamic if and only if mass is non zero, otherwise static
//Don't try to call functions on other objects such as the Physics world since they may not exit.
// Add this object to the world on Start. We are doing this so that scripts which add this componnet to 
// game objects have a chance to configure them before the object is added to the bullet world.
// Be aware that Start is not affected by script execution order so objects such as constraints should
// make sure that objects they depend on have been added to the world before they add themselves.
// This can be called more than once
//OnEnable and OnDisable are called when a game object is Activated and Deactivated. 
//Unfortunately the first call comes before Awake and Start. We suppress this call so that the component
//has a chance to initialize itself. Objects that depend on other objects such as constraints should make
//sure those objects have been added to the world first.
//don't try to call functions on world before Start is called. It may not exist.
// when scene is closed objects, including the physics world, are destroyed in random order. 
// There is no way to distinquish between scene close destruction and normal gameplay destruction.
// Objects cannot depend on world existing when they Dispose of themselves. World may have been destroyed first.
//Bullet wants me to fill in worldTrans
//This is called by bullet once when rigid body is added to the the world
//For kinematic rigid bodies it is called every simulation step
//[MonoPInvokeCallback(typeof(GetTransformDelegate))]
//Bullet calls this so I can copy bullet data to unity
// Update is called once per frame
// Interpolation is needed in threaded mode
// Maybe we can have a call to the physics engine in an update method instead ?
//rigidbody is dynamic if and only if mass is non zero, otherwise static
//TODO should do two passes like with collisions
//swap the hashsets so objsIWasInContactWithLastFrame now contains the list of objs.
//rigidbody is dynamic if and only if mass is non zero, otherwise static
//m_currentPosition = m_ghostObject.WorldTransform.Origin;
//float maxPen = 0f;
//swap the hashsets so objsIWasInContactWithLastFrame now contains the list of objs.
//============
//for FeatherStone forward dynamics I think
//if (singleton.m_world == null && !singleton.isDisposed) singleton._InitializePhysicsWorld();
/*
// convenience variable so we arn't typecasting all the time.
//It is critical that Awake be called before any other scripts call BPhysicsWorld.Get()
//Set this script and any derived classes very early in script execution order.
// if (debugType >= BDebug.DebugType.Debug) Debug.LogFormat(c, "Adding multibody constraint {0} to world", c);
//if (c._BuildConstraint())
//  c.m_isInWorld = true;
//if (debugType >= BDebug.DebugType.Debug) Debug.LogFormat("Removing constraint {0} from world", c.Userobject);
//if (c.Userobject is BTypedConstraint) ((BTypedConstraint)c.Userobject).m_isInWorld = false;
//Add a BPhysicsWorldLateHelper component to call FixedUpdate
/*
/* case SolverType.MLCP:
//remove/dispose constraints
//remove the rigidbodies from the dynamics world and delete them
/* if (constraint.Userobject is BTypedConstraint) ((BTypedConstraint)constraint.Userobject).m_isInWorld = false;
//remove the rigidbodies from the dynamics world and delete them
/**
/*  stepSimulation proceeds the simulation over 'timeStep', units in preferably in seconds.
//collisions
//This is needed for rigidBody interpolation. The motion states will update the positions of the rigidbodies
// We want to ensure that each bullet sim step corresponds to exactly one Unity FixedUpdate timestep
/*
//need to set mass to zero for kinematic and static
//need to set mass to mass
/* can lock axis with this */
/*
/**
//rigidbody is dynamic if and only if mass is non zero, otherwise static
//if kinematic then disable deactivation
//called by Physics World just before rigid body is added to world.
//the current rigid body properties are used to rebuild the rigid body.
//all constraints using RB must be disabled before rigid body is disabled
//should remove it from the scene
//constraints must be removed before rigid body is removed
//constraints must be removed before rigid body is removed
/**
/**
/**
// Update is called once per frame
/*
//Scaling is the length of the rows.
//The rotation is the left over matrix after dividing out the scaling.
//------------------------
//------------------------
/*
//creates new Unity Matrix4x4
/// <summary>
/// Extract translation from transform matrix.
/// </summary>
/// <param name="matrix">Transform matrix. This parameter is passed by reference
/// to improve performance; no changes will be made to it.</param>
/// <returns>
/// Translation offset.
/// </returns>
/// <summary>
/// Extract rotation quaternion from transform matrix.
/// </summary>
/// <param name="matrix">Transform matrix. This parameter is passed by reference
/// to improve performance; no changes will be made to it.</param>
/// <returns>
/// Quaternion representation of rotation transform.
/// </returns>
/// <summary>
/// Extract scale from transform matrix.
/// </summary>
/// <param name="matrix">Transform matrix. This parameter is passed by reference
/// to improve performance; no changes will be made to it.</param>
/// <returns>
/// Scale vector.
/// </returns>
/// <summary>
/// Extract position, rotation and scale from TRS matrix.
/// </summary>
/// <param name="matrix">Transform matrix. This parameter is passed by reference
/// to improve performance; no changes will be made to it.</param>
/// <param name="localPosition">Output position.</param>
/// <param name="localRotation">Output rotation.</param>
/// <param name="localScale">Output scale.</param>
/// <summary>
/// Set transform component from TRS matrix.
/// </summary>
/// <param name="transform">Transform component.</param>
/// <param name="matrix">Transform matrix. This parameter is passed by reference
/// to improve performance; no changes will be made to it.</param>
// EXTRAS!
/// <summary>
/// Identity quaternion.
/// </summary>
/// <remarks>
/// <para>It is faster to access this variation than <c>Quaternion.identity</c>.</para>
/// </remarks>
/// <summary>
/// Identity matrix.
/// </summary>
/// <remarks>
/// <para>It is faster to access this variation than <c>Matrix4x4.identity</c>.</para>
/// </remarks>
/// <summary>
/// Get translation matrix.
/// </summary>
/// <param name="offset">Translation offset.</param>
/// <returns>
/// The translation transform matrix.
/// </returns>
/* 
//called by Physics World just before rigid body is added to world.
//the current rigid body properties are used to rebuild the rigid body.
//rigidbody is dynamic if and only if mass is non zero, otherwise static
/// <summary>
/// Threading bullet allows to run bullet simulation steps at a higher frequency than Unity.
/// When not threaded, bullet will interpolate automatically the transforms but the action callbacks won't be called regularly
/// </summary>
/// <summary>
/// Total simulation time [in s]
/// </summary>
// wait 1 sec before starting
// line
// point 00
// point 01
//point 10
//point 11
/*	
//normal draw
//            {
//                Vector3 normalColor = new Vector3(1,1,0);
//				 
//                BulletSharp.Math.Vector3 faceNormal(face.m_plane[0],poly->m_faces[i].m_plane[1],poly->m_faces[i].m_plane[2]);
//                getDebugDrawer()->drawLine(worldTransform*centroid,worldTransform*(centroid+faceNormal),normalColor);
//            }
// Draw some additional lines
// Drawing top and bottom caps of the cylinder
// Drawing the base of the cone
// choose p in y-z plane
// set q = n x p
// choose p in x-y plane
// set q = n x p
//todo normals and alpha
/// <summary>
/// MicroStopwatch class
/// </summary>
/// <summary>
/// MicroTimer class
/// </summary>
/// <summary>
/// MicroTimer Event Argument class
/// </summary>
// Simple counter, number times timed event (callback function) executed
// Time when timed event was called since timer started
// Time when timed event was called since last timed event (dt)
// How late the timer was compared to when it should have been called
// Time it took to execute previous call to callback function (OnTimedEvent)
//public Vector3 extents = Vector3.one;
//BUtility.DebugDrawBox(position, rotation, scale, extents, Color.yellow);
//todo draw the hull when not in the world
//todo can this be used with Dynamic objects? The manual hints that it is for static only.
//BUtility.DebugDrawCapsule(position, rotation, scale, radius, height / 2f, 1, Gizmos.color);  
//todo test for convex. Make convex if not.
// dynamic
// static
//TODO
// cs.OptimizeConvexHull();
//BulletSharp.Math.Matrix childShapeTransform = this.transform;
//childShapeTransform.Invert();
//BulletSharp.Math.Matrix shapeTransform = childShapeTransform * this.transform.localToWorldMatrix.ToBullet();
/*   public override void InternalProcessTriangleIndex(ref BulletSharp.Math.Vector3 point0, ref BulletSharp.Math.Vector3 point1, ref BulletSharp.Math.Vector3 point2, int partId, int triangleIndex)
//childShapeTransform.Invert();
/*   public override void InternalProcessTriangleIndex(ref BulletSharp.Math.Vector3 point0, ref BulletSharp.Math.Vector3 point1, ref BulletSharp.Math.Vector3 point2, int partId, int triangleIndex)
/*
// TODO We should store the transform matrix to apply between the subshape and the mainshape
// because there are different cases.
// With shapes from unity colliders, we need to invert the local scale of the object as the collider takes it into account already
// With shapes from bullet, we must not invert the local scale
//TODO the gizmos do not draw correctly when collision shape is scaled
//TODO
// some of the collider types (non-finite and other compound colliders) are probably not
// can only be added to game object with rigid body attached.
// allowed should check for these.
// what about scaling not sure if it is handled correctly
// we need to invert the scale
//skip
//todo draw the hull when not in the world
//            Gizmos.matrix = 
//Gizmos.DrawWireMesh(hullMesh, transform.position, transform.rotation, transform.lossyScale);
//todo remove duplicate verts
//todo use vertex reduction utility
//todo draw the hull when not in the world
//todo can this be used with Dynamic objects? The manual hints that it is for static only.
//BUtility.DebugDrawCapsule(position, rotation, scale, radius, height / 2f, 1, Gizmos.color);  
//todo test for convex. Make convex if not.
//generate procedural data
//just allocated several hundred float arrays. Garbage collect now since 99% likely we just loaded the scene
//Todo not sure if this is working
//todo should be properties so can capture changes and propagate to scene
//called by Physics World just before constraint is added to world.
//the current constraint properties are used to rebuild the constraint.
//TODO think about this
// TODO
//   m_constraintPtr = new Generic6DofSpringConstraint(rba, m_localConstraintPoint.ToBullet(), m_localConstraintAxisX.ToBullet(), false);
// TODO
//   m_constraintPtr = new Generic6DofSpringConstraint(rba, m_localConstraintPoint.ToBullet(), m_localConstraintAxisX.ToBullet(), false);
//todo should be properties so can capture changes and propagate to scene
//called by Physics World just before constraint is added to world.
//the current constraint properties are used to rebuild the constraint.
//called by Physics World just before constraint is added to world.
//the current constraint properties are used to rebuild the constraint.
//TODO this is broken
//called by Physics World just before constraint is added to world.
//the current constraint properties are used to rebuild the constraint.
//todo should be properties so can capture changes and propagate to scene
//called by Physics World just before constraint is added to world.
//the current constraint properties are used to rebuild the constraint.
//warning the frameInA, frameInB version of the constructor is broken
//BM.Matrix frameInA = BM.Matrix.Identity;
//CreateFrame(m_localConstraintForwardDir, m_localConstraintUpDir, m_localConstraintPoint, ref frameInA);
//called by Physics World just before constraint is added to world.
//the current constraint properties are used to rebuild the constraint.
// Object A has the constraint compontent and is constrainted to object B
// The constraint frame is defined relative to A by three vectors.
// This method calculates the frames A and B that need to be passed to bullet
//do not override this
//override this one
//called by Physics World just before constraint is added to world.
//the current constraint properties are used to rebuild the constraint.
/*
/*
//SerializedProperty extents;
//SerializedProperty localScaling;
//GetSerializedProperties();
//void GetSerializedProperties() {
//	extents = serializedObject.FindProperty("extents");
//    localScaling = serializedObject.FindProperty("m_localScaling");
//}
//SerializedProperty hullMesh;
//GetSerializedProperties();
/*
//EditorGUILayout.PropertyField(hullMesh);
//GetSerializedProperties();
/*
//GetSerializedProperties();
/*
//SerializedProperty hullMesh;
//GetSerializedProperties();
/*
//EditorGUILayout.PropertyField(hullMesh);
//SerializedProperty hullMesh;
//GetSerializedProperties();
/*
//[CustomEditor(typeof(BPhysicsWorld),true)]
//right click menu
//http://answers.unity3d.com/questions/31784/changing-the-order-of-components.html?page=2&pageSize=5&sort=votes
// Transform is always first (though that doesn't really matter, as we can't  move it anyway).
// Add your types here in the order you want them to be in the inspector.
// If we found the exact type in the list, then this is the right index.
// If we found a parent, then we switch to its place if it is more
// "recent" (in the inheritance tree) than previously found parents.
// [MenuItem("Edit/Sort Components %&a")]
//var GameObject = Selection.activeGameObject;
//http://answers.unity3d.com/questions/31784/changing-the-order-of-components.html?page=2&pageSize=5&sort=votes
// Transform is always first (though that doesn't really matter, as we can't  move it anyway).
// Add your types here in the order you want them to be in the inspector.
//if present
// If we found the exact type in the list, then this is the right index.
// If we found a parent, then we switch to its place if it is more
// "recent" (in the inheritance tree) than previously found parents.
// [MenuItem("Edit/Sort Components %&a")]
//var GameObject = Selection.activeGameObject;
//BulletSharp.SoftBody.Collisions collisions;  //bitmask field for collisions
//GUIContent gcSoftBodyMeshSettings = new GUIContent("SoftBodyMeshSettings");
//used to hide specific serialized properties in the editor
//Hide softBody Settings until we want to display it, also script name
//Draw settings after the default inspector
//SBSettingsPresets saveMe = bSoftBodyTarget.SoftBodySettings.sBpresetSelect;
//bSoftBodyTarget.SoftBodySettings.sBpresetSelect = saveMe;
//bitmask field for collisions
//Can apply settings on editor change
//Menu items here
//right click menu
//right click menu
/// <summary>
/// Stuff to do after creation like sort script order
/// </summary>
//order the scripts, looks nicer
//Hackish method to get past Unity serialization
//Get Instance
//BAnyMeshSettingsForEditor.Instance;
//Build it!
//Select a mesh type
//limit the fields [Range()] doesnt work
//AutoMagickally change settings is edited
//Can apply settings on editor change
//SerializedProperty radius;
//GetSerializedProperties();
/*
//BulletUnity version
//Draw the UnityBullet Logo and version on scripts that need it
//EditorGUILayout.LabelField(string.Format("Bullet Version: {0}", version));
//ray-plane intersection
//raycast on existing geometry
//place it x units from the camera
//Get a ray in the world from editor camera to middle of the screen
//EditorGUILayout.BeginHorizontal();
//EditorGUILayout.HelpBox(text, MessageType.None, true);
//EditorGUILayout.EndHorizontal();
/// <summary>
/// Draw a box for select the debug mode of this object.
/// </summary>
/// <param name="debug">DebugType</param>
//Check if the interface changed for perform an undo record.
//Custom inspector
//EditorGUILayout.BeginHorizontal();
//Logo
//GUILayout.Box(EditorLogo, GUILayout.Height(64), GUILayout.ExpandWidth(true));
//Title/Version
/*
//EditorGUILayout.EndHorizontal();
//build mesh and resize
//draw default view
//DrawDefaultInspector();
//right click menu
//right click menu
//right click menu
//right click menu
//right click menu
//right click menu
//right click menu
//order the scripts, looks nicer
//ray-plane intersection
//raycast on existing geometry
//place it x units from the camera
//Get a ray in the world from editor camera to middle of the screen
// Begin to draw a horizontal layout, using the helpBox EditorStyle
// Reserve GUI space with a width from 10 to 10000, and a fixed height of 100, and 
// cache it as a rectangle.
// step time
// first line of X
/// <summary>
/// Display multi-select popup for Flags enum correctly.
/// </summary>
/*   public override CollisionObject GetCollisionObject()
/**
// if an error occurs, don't add the object, otherwise unity will crash
//called by Physics World just before multi body is added to world.
//the current multi body properties are used to rebuild the multi body.
//using BulletSharp;
//using BulletSharp.Math;
/// <summary>
/// Basic BBox
/// </summary>
//using BulletSharp;
//using BulletSharp.Math;
/// <summary>
/// BCylinder
/// </summary>
//using BulletSharp;
//using BulletSharp.Math;
/// <summary>
/// BCylinder
/// </summary>
//using BulletSharp;
//using BulletSharp.Math;
/// <summary>
/// Basic BBox
/// </summary>
/// <summary>
/// Basic BBox
/// </summary>
//using BulletSharp;
//using BulletSharp.Math;
/// <summary>
/// BCylinder
/// </summary>
//using BulletSharp.Math;
/// <summary>
/// Base class for UnityBullet primatives
/// </summary>
//display in inspector
//Destroy(this);  //Probably don't need this class during runtime?
/// <summary>
/// Build object mesh and collider
/// </summary>
//using BulletSharp;
//using BulletSharp.Math;
/// <summary>
/// Basic BSphere
/// </summary>
//namespace RatherGood
//{
/// <summary>
/// Compares if the flags enum is contained in enum
/// </summary>
/// <param name="type"></param>
/// <param name="flage"></param>
/// <returns></returns>
/// <summary>
/// checks if the value contains the provided type
/// </summary>
/// <typeparam name="T"></typeparam>
/// <param name="type"></param>
/// <param name="value"></param>
/// <returns></returns>
/// <summary>
/// checks if the value is only the provided type
/// </summary>
/// <typeparam name="T"></typeparam>
/// <param name="type"></param>
/// <param name="value"></param>
/// <returns></returns>
/// <summary>
/// appends a value
/// </summary>
/// <typeparam name="T"></typeparam>
/// <param name="type"></param>
/// <param name="value"></param>
/// <returns></returns>
//completely removes the value
/// <summary>
/// Gets Description attribute from enum type
/// </summary>
/// <param name="en"></param>
/// <returns></returns>
//}//TODO
//fill in something
//create a copy of UserMesh, dont overwrite prefabs
//Bullet dimensions
//Bullet dimensions
/// <summary>
/// Useful for creating something random for examples in the editor
/// Instance remebers last settings
/// </summary>
//[SerializeField]
//Unity wont allow switching classes in editor, so this class has all parameters in one pile, ick!
//cube
//sphere, cone, cylinder
//cone, cylinder
//Plane
//sphere
//sphere
//cone/cylinder sides
//Unity cant display this due to serialization, figure it out later
//public BPrimitiveMeshSettings meshSettings = new BPrimitiveMeshSettings();
//TODO
//Need to copy mesh from sharedMesh or we cant modify the mesh!
//fill in something
/// <summary>
/// For editor configurations
/// </summary>
//using System.IO;
//using System.Runtime.InteropServices;
//using BulletSharp;
//using BulletSharp.Math;
//http://wiki.unity3d.com/index.php/ProceduralPrimitives
/// <summary>
/// Class to generate procedural Unity Meshes 
/// </summary>
// [ -length / 2, length / 2 ]
// [ -width / 2, width / 2 ]
// Retrieve lower left corner from face ind
// Bottom
// Left
// Front
// Back
// Right
// Top
// Bottom
// Left
// Front
// Back
// Right
// Top
// Bottom
// Left
// Front
// Back
// Right
// Top
// Bottom
// Left
// Front
// Back
// Right
// Top
//Note that cylinders(bottomRadius == topRadius) and pyramids(4 sides, topRadius == 0) are types of cones, and can be created with this script.
// Not implemented yet
// bottom + top + sides
// Bottom cap
// Top cap
// Sides
//Apply offset to vertices to shift pivot to center (Bullet default)
//TODO: User settable offset
//offset
// bottom + top + sides
// Bottom cap
// Top cap
// Sides
// Bottom cap
// Top cap
// Sides
// Bottom cap
// Top cap
//tri++;
// Sides
// Not implemented yet
// bottom + top + sides
// Bottom cap
// Top cap
// Sides
//Apply offset to vertices to shift pivot to center (Bullet default)
//TODO: User settable offset
//offset
// bottom + top + sides
// Bottom cap
// Top cap
// Sides
// Bottom cap
// Top cap
// Sides
// Bottom cap
// Top cap
//tri++;
// Sides
// bottom + top + sides
// Bottom cap
// Top cap
// Sides (out)
// Sides (in)
// bottom + top + sides
// Bottom cap
// Top cap
// Sides (out)
// Sides (in)
// Bottom cap
// Top cap
// Sides (out)
// Sides (in)
// Bottom cap
// Top cap
// Sides (out)
// Sides (in)
//Vector3 normale = Vector3.Cross(r1, Vector3.up);
/// <summary>
/// 
/// </summary>
/// <param name="radius"></param>
/// <param name="nbLong">number of longitude lines</param>
/// <param name="nbLat">number of latitude lines</param>
/// <returns></returns>
//Top Cap
//Middle
//Bottom Cap
/*
//Note: Don't forget to include System.Collections.Generic. And there is no UV yet, not sure how to go about it actually.
// return index of point in the middle of p1 and p2
// first check if we have it already
// not in cache, calculate it
// add vertex makes sure point is on unit sphere
// store it, return index
//MeshFilter filter = gameObject.AddComponent<MeshFilter>();
//Mesh mesh = filter.mesh;
// create 12 vertices of a icosahedron
// create 20 triangles of the icosahedron
// 5 faces around point 0
// 5 adjacent faces 
// 5 faces around point 3
// 5 adjacent faces 
// refine triangles
// replace triangle by 4 triangles
//http://answers.unity3d.com/questions/228841/dynamically-combine-verticies-that-share-the-same.html
/// <summary>
/// Weld close vertices together to create a closed hull.
/// </summary>
/// <param name="mesh"></param>
/// <param name="threshold"></param>
/// <returns></returns>
// Build new vertex buffer and remove "duplicate" verticies
// that are within the given threshold.
// Has vertex already been added to newVerts list?
// Accept new vertex!
//some meshes dont have 
// Rebuild triangles using new verticies
// Find new vertex point from buffer
/// <summary>
/// Add back face triangles to this mesh. Test me
/// </summary>
/// <param name="mesh"></param>
// duplicate vertices and uvs:
// copy the original normals...
// and revert the new ones
// double the triangles
// copy the original triangle
// save the new reversed triangle
// assign triangles last!
/// <summary>
/// After mesh is created, process it based on selected options
/// </summary>
//using BulletSharp.Math;
//common Soft body settings class used for all softbodies, parameters set based on type of soft body
//SoftBodyEditor will display this when needed
//protected SoftBody m_BSoftBody;
//for converting to/from unity mesh
//disable warning
//Get Bullet data
//Update mesh based on bullet data
//Make coffee
/// <summary>
/// Update Mesh (or line renderer) at runtime, call from Update 
/// </summary>
//TODO preset must be shapeMatching
//vertex bind normal
//we need to track the edges leaving this node so we can fully orient the bone
//normalized cross product of edge with normal
//in world space,
//want to choose edges that are closest to 90 degrees with Normal first
//used for debugging if I want to display the the mesh distortions
//can't use verts and norms because
// Use this for initialization
//good
//good
//get bones and mesh verts
//compare these in world space to see which ones line up
//TODO why does other mesh shape work better than this one.
//check for duplicate verts
//Debug.Log("found a bone that is aligned with a vertex " + bones[j]);
// clear old values
/*
/*
/*
//convert the mesh data to Bullet data and create DoftBody
//todo should these be in world coordinates
//Set SB settings
//Set SB position to GO position
/**
//verts[i].ToBullet();
//sb.Nodes[i].Normal = norms[i].ToBullet();
//TODO deal with rotation
//sb.Rotate(physicsSimMesh.transform.rotation.ToBullet());
//sb.Translate(physicsSimMesh.transform.position.ToBullet());
// read the positions of the bones from the physics simulation
//Update bone positions and orientaion based on bullet data
// to update the orientation we need to see how the normal and one vertex moved
//todo check magnitude and loop over edges if first doesn't work
//do nothing since we arn't updating the mesh, we are updating the bones
//don't do anything here overriding to disable the default behavior
//using BulletSharp;
//Set SB settings
//anchorNode point 0 to 1, rounds to node # 
//setting node mass to 0 fixes it in space apparently
//TODO: lr, Doesnt always work in editor
//Set SB position to GO position
//m_BSoftBody.Rotate(transform.rotation.ToBullet());
//m_BSoftBody.Translate(transform.position.ToBullet());
//m_BSoftBody.Scale(transform.localScale.ToBullet());
/// <summary>
/// Create new SoftBody object
/// </summary>
/// <param name="position"></param>
/// <param name="rotation"></param>
/// <param name="buildNow">Build now or configure properties and call BuildSoftBody() after</param>
/// <returns></returns>
/// <summary>
/// Update Rope line renderer at runtime, called from Update 
/// </summary>
//transform.SetTransformationFromBulletMatrix(m_BSoftBody.WorldTransform);  //Set SoftBody position, No motionstate
//public bool anchorSameAsNode = true;
//using BulletSharp.SoftBody;
/// <summary>
/// Used base for any(most) softbodies needing a mesh and meshrenderer.
/// </summary>
//[RequireComponent(typeof(MeshFilter))]
//[RequireComponent(typeof(MeshRenderer))]
//convert the mesh data to Bullet data and create SoftBody
//Set SB settings
//Set SB position to GO position
/// <summary>
/// Create new SoftBody object using a Mesh
/// </summary>
/// <param name="position">World position</param>
/// <param name="rotation">rotation</param>
/// <param name="mesh">Need to provide a mesh</param>
/// <param name="buildNow">Build now or configure properties and call BuildSoftBody() after</param>
/// <param name="sBpresetSelect">Use a particular softBody configuration pre select values</param>
/// <returns></returns>
//Apply SoftBody settings presets
//Build the SoftBody
/// <summary>
/// Update Mesh (or line renderer) at runtime, call from Update 
/// </summary>
//Set SoftBody position, No motionstate    
//using BulletSharp.Math;
/// <summary>
/// Settings for configuring a Bullet SoftBody in Unity Editor
/// </summary>
/// <summary>
/// Apply these SoftBody settings to this SoftBody
/// </summary>
/// <param name="softBody"></param>
//TODO: lots! These presets need work.
/// <summary>
/// Reset and Configure SoftBody settings for some general preset values.  Can use as a starting point before optimization.
/// </summary>
/// <param name="preset"></param>
//save last applied preset
//reset itself
// fun factor...
/// <summary>
/// Provides convienent presets for SBSettings
/// Warning; Will overwrite settings with preset defaults!
/// </summary>
//TODO: apply reasonable min/max values
/// <summary>
/// SoftBody Config wrapper
/// </summary>
//[Range(float.NegativeInfinity, float.PositiveInfinity)]
//int.MaxValue)]
// V_Point,			///Vertex normals are oriented toward velocity
//V_TwoSided,			///Vertex normals are flipped to match velocity	
//V_TwoSidedLiftDrag, ///Vertex normals are flipped to match velocity and lift and drag forces are applied
//V_OneSided,			///Vertex normals are taken as it is	
//F_TwoSided,			///Face normals are flipped to match velocity
//F_TwoSidedLiftDrag,	///Face normals are flipped to match velocity and lift and drag forces are applied 
//F_OneSided,			///Face normals are taken as it is	
/// <summary>
/// SoftBody Material wrapper
/// </summary>
/// <summary>
/// Set SoftBody material properties
/// </summary>
/// <param name="softBody"></param>
/// <returns></returns>
//Notes:
//http://bulletphysics.org/Bullet/phpBB3/viewtopic.php?p=24280
/*setPose(bvolume,bframe):
