________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\BuildTasks\SetEnvVar.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\BuildTasks\Properties\AssemblyInfo.cs
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
// The following GUID is for the ID of the typelib if this project is exposed to COM
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\GlobalSuppressions.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: Determine if we want to make Clojure.dll CLSCompliant
// TODO: Consider implications of strong-signing (has been requested by people who want to install in the GAC)
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\api\Clojure.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Provides a minimal interface to bootstrap Clojure access from other CLR languages.
/// </summary>
/// <remarks>
/// <para>The Clojure class provides a minimal interface to bootstrap Clojure access 
/// from other JVM languages. It provides:</para>
/// <list type=">">
/// <item>The ability to use Clojure's namespaces to locate an arbitrary
/// <a href="http://clojure.org/vars">var</a>, returning the
/// var's clojure.lang.IFn interface.</item>
/// <item>A convenience method <c>read</c> for reading data using
/// Clojure's edn reader</item>
/// </list>
/// <para>To lookup and call a Clojure function:</para>
/// <code>
/// IFn plus = Clojure.var("clojure.core", "+");
/// plus.invoke(1, 2);
/// </code>
/// <para>Functions in <c>clojure.core</c> are automatically loaded. Other
/// namespaces can be loaded via <c>require</c>:</para>
/// <code>
/// IFn require = Clojure.var("clojure.core", "require");
/// require.invoke(Clojure.read("clojure.set"));
/// </code>
/// <para><c>IFn</c>s can be passed to higher order functions, e.g. the
/// example below passes <c>plus</c> to <c>read</c>:</para>
/// <code>
/// IFn map = Clojure.var("clojure.core", "map");
/// IFn inc = Clojure.var("clojure.core", "inc");
/// map.invoke(inc, Clojure.read("[1 2 3]"));
/// </code>
/// </remarks>
/// <summary>
/// Returns the var associated with qualifiedName.
/// </summary>
/// <param name="qualifiedName">a String or clojure.lang.Symbol</param>
/// <returns>a clojure.lang.IFn</returns>
/// <summary>
/// Returns an IFn associated with the namespace and nanme
/// </summary>
/// <param name="ns">a String or clojure.lang.Symbol</param>
/// <param name="name">a String or clojure.lang.Symbol</param>
/// <returns>a clojure.lang.IFn</returns>
/// <summary>
/// Read one object from the string s. Reads data in the edn format (http://edn-format.org).
/// </summary>
/// <param name="s">a string</param>
/// <returns>an Object or nil</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\ArrayIter.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Compiler.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//internal const string CompileStubPrefix = "compile__stub";
//internal static readonly Symbol InvokeStaticSym = Symbol.intern("invokeStatic");
//internal static readonly Keyword StaticKeyword = Keyword.intern(null, "static");
//static readonly Keyword VolatileKeyword = Keyword.intern(null,"volatile");
//static readonly Keyword OnKeyword = Keyword.intern(null, "on");
//boolean
//String
// String
// String
//Integer
// From the JVM version
// From the JVM version
//internal static readonly Var LINE_BEFORE = Var.create(0).setDynamic();   // From the JVM version
//internal static readonly Var COLUMN_BEFORE = Var.create(0).setDynamic();   // From the JVM version
//internal static readonly Var LINE_AFTER = Var.create(0).setDynamic();    // From the JVM version
//internal static readonly Var COLUMN_AFTER = Var.create(0).setDynamic();    // From the JVM version
// Mine
//Integer
// Label
//null or not
//null or not
//internal static readonly Var MethodReturnContextVar = Var.create(null).setDynamic();    // null or not
//var->constid
//vector<object>
// IdentityHashMap
//keyword->constid
// vector<keyword>
// vector<var>
// set<var>
// compiler options on *nix need to be of the form
// CLOJURE_COMPILER_DIRECT_LINKING because most shells do not
// support hyphens in variable names
// TODO: we have duplicate code below.
//already qualified or classname?
//note, presumes non-nil sym.ns
// first check against currentNS' aliases...
// ...otherwise check the Namespaces map.
// note: ns-qualified vars must already exist
// note: ns-qualified vars must already exist
/// JAVA: symbol.Name[0] == '[')
// Note: ns-qualified vars in other namespaces must exist already
// is it mapped?
// introduce a new var in the current ns
//return varCallsites.count() - 1;
// not sure abou this one.
//		                         '.', "_DOT_",
// DEMUNGE_MAP maps strings to characters in the opposite
// direction that CHAR_MAP does, plus it maps "$" to '/'
// DEMUNGE_PATTERN searches for the first of any occurrence of
// the strings that are keys of DEMUNGE_MAP.
// Note: Regex matching rules mean that #"_|_COLON_" "_COLON_"
// returns "_", but #"_COLON_|_" "_COLON_" returns "_COLON_"
// as desired.  Sorting string keys of DEMUNGE_MAP from longest to
// shortest ensures correct matching behavior, even if some strings are
// prefixes of others.
// Keep everything before the match
// Replace the match with DEMUNGE_MAP result
// Keep everything after the last match
/// <summary>
///  
/// </summary>
/// <param name="form"></param>
/// <returns></returns>
/// <remarks>Initial lowercase for core.clj compatibility</remarks>
/// <summary>
/// 
/// </summary>
/// <param name="form"></param>
/// <returns></returns>
/// <remarks>Initial lowercase for core.clj compatibility</remarks>
//public static Regex UnpackFnNameRE = new Regex("^(.+)/$([^_]+)(__[0-9]+)*$");
// macro expansion
// hide the 2 extra params for a macro
// This simple test is used in the JVM:   if (e.Name.Equals(munge(v.ns.Name.Name) + "$" + munge(v.sym.Name)))
// Does not work for us because have to append a __1234 to the type name for functions in order to avoid name collisiions in the eval assembly.
// So we have to see if the name is of the form   namespace$name__xxxx  where the __xxxx can be repeated.
// in C# 6, could use ...  catch ( Exception ex )   when (e is ArgumentException || e is InvalidOperationException || e is ExceptionInfo e)
// (.substring s 2 5) => (. x substring 2 5)
// We need to make sure source information gets transferred
// We need to make sure source information gets transferred
// (x.substring 2 5) =>  (. x substring 2 5)
// also (package.class.name ... ) (. package.class name ... )
// We need to make sure source information gets transferred
// Java:  	//no local inlines for now
//GenContext c = GenContext.CreateWithExternalAssembly("eval", ".dll", true);  // for debugging use with SaveEvalContext
/* RT.T */));
// generate loader class
// static load method
/* RT.T */,
// static fields for constants
// Static init for constants, keywords, vars
// I have no idea why Mono can't find our initializer types using Assembly.GetType(string).
// This is roll-your-own.
// old init class name
// ?
// ?
//LOADER, RT.makeClassLoader(),
/* RT.T */,
//LINE_BEFORE, lntr.LineNumber,
//LINE_AFTER, lntr.LineNumber,
//COLUMN_BEFORE, lntr.ColumnNumber,
//COLUMN_AFTER, lntr.ColumnNumber
//int lineAfter = lntr.LineNumber;
//int columnAfter = lntr.ColumnNumber;
//LINE_AFTER.set(lntr.LineNumber);
//COLUMN_AFTER.set(lntr.ColumnNumber);
//lineAfter = lntr.LineNumber;
//columnAfter = lntr.ColumnNumber;
//LINE_BEFORE.set(lntr.LineNumber);
//COLUMN_BEFORE.set(lntr.ColumnNumber);
// ns-qualified syms are always Vars
/* (MethodReturnContextVar.deref() != null) && */ (InTryBlockVar.deref() == null);
// Error keys
// Compile error phases
// JVM has this deprecated
//static string ErrorMsg(string source, int line, int column, string s)
//{
//    return string.Format("{0}, compiling: ({1}:{2}:{3})", s, source, line,column);
//}
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\GenClass.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// For debugging purposes only: testing with no compile in process
//static int _saveId = 0;
// of Types 
// define the class
/// <summary>
///  Set up Var fields and (maybe) load assembly for the namespace.
/// </summary>
/// <param name="proxyTB"></param>
/// <param name="varMap"></param>
/// <param name="loadImplNameSpace"></param>
/// <param name="implNamespace"></param>
// gen.Emit(OpCodes.Ldstr, implNamespace);
// gen.Emit(OpCodes.Ldstr, prefix + pair.Key);
// gen.Emit(OpCodes.Call, Method_Var_internPrivate);
// gen.Emit(OpCodes.Ldstr, "clojure.core");
// gen.Emit(OpCodes.Ldstr, "load");
// gen.Emit(OpCodes.Call, Method_RT_var2);
// gen.Emit(OpCodes.Ldstr, "/" + implCname);
// gen.Emit(OpCodes.Call, Compiler.Methods_IFn_invoke[1]);
// TODO: Get rid of this mess by making sure the metadata on the keys of the constructors map gets copied to the constructor-types map.  Sigh.
// init supplied
// box init args
// gen.Emit(OpCodes.Ldarg, i + 1);
// gen.Emit(OpCodes.Call, Compiler.Methods_IFn_invoke[thisParamTypes.Length]);
// Expecting:  [[super-ctor-args...] state]
// store the init return in a local
// store the first element in a local
// gen.Emit(OpCodes.Ldc_I4_0);
// gen.Emit(OpCodes.Call, Method_RT_nth);
// Stack this + super-ctor-args + call base-class ctor.
// gen.Emit(OpCodes.Ldarg_0);
// gen.Emit(OpCodes.Ldc_I4, i);
// gen.Emit(OpCodes.Call, Method_RT_nth);
// gen.Emit(OpCodes.Ldarg_0);
// gen.Emit(OpCodes.Ldc_I4_1);
// gen.Emit(OpCodes.Call, Method_RT_nth);
// gen.Emit(OpCodes.Stfld, stateFB);
// No init found
// no InitFB supplied.
// gen.Emit(OpCodes.Ldarg_0);
// gen.Emit(OpCodes.Ldarg, i + 1); 
// post-init supplied
// box init args
// gen.Emit(OpCodes.Ldarg_0);
// gen.Emit(OpCodes.Ldarg, i + 1);
// gen.Emit(OpCodes.Call, Compiler.Methods_IFn_invoke[thisParamTypes.Length + 1]);
// no post-init found
// genf.Emit(OpCodes.Ldarg, i);
// genf.Emit(OpCodes.Ldarg, i);
// genf.Emit(OpCodes.Newobj, cb);
// gen.Emit(OpCodes.Ldarg_0);
// gen.Emit(OpCodes.Call, Method_RT_seq);
// gen.Emit(OpCodes.Call, Method_IFn_applyTo_Object_ISeq);
// no main found
//context.AssyBldr.SetEntryPoint(cb);
// gen.Emit(OpCodes.Ldarg_0);
// gen.Emit(OpCodes.Ldarg, (i + 1));
// not gen.EmitCall(sig.Method) -- we need call versus callvirt
// gen.Emit(OpCodes.Ldarg_0);
// gen.Emit(OpCodes.Ldarg, i + 1);
//gen.Emit(OpCodes.Call, Compiler.Methods_IFn_invoke[sig.ParamTypes.Length + (isStatic ? 0 : 1)]);
// gen.Emit(OpCodes.Ldarg_0);
// gen.Emit(OpCodes.Ldarg, i + 1);
// not gen.EmitCall(mi); -- we need call versus callvirt
//if (fld.IsStatic)
//    gen.Emit(OpCodes.Ldsfld, fld);
//else
//{
//    gen.Emit(OpCodes.Ldarg_0);
//    gen.Emit(OpCodes.Ldfld, fld);
//}
//gen.Emit(OpCodes.Stsfld, fld);
//gen.Emit(OpCodes.Stfld, fld);
// gen.Emit(OpCodes.Ldsfld,fb);
// gen.Emit(OpCodes.Call, Method_Var_IsBound);
// gen.Emit(OpCodes.Ldnull);
// gen.Emit(OpCodes.Ldstr, name);
// gen.Emit(OpCodes.Newobj, CtorInfo_NotImplementedException_1);
//private static void GetMethodFields(string name, IPersistentMap overloads, Dictionary<string, FieldBuilder> varMap, out FieldBuilder overloadFB, out FieldBuilder regularFB)
//{
//    if ( overloads.containsKey(name) )
//}
// v == [name [paramTypes...] returnType]
//HashSet<String> overloadNames = new HashSet<string>();
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\GenDelegate.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//static int _saveId = 0;
// I guess we'll pass a void.  This happens when we have a throw, for example.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\GenInterface.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//string path = (string)Compiler.COMPILE_PATH.deref();
//if (path == null)
//    throw new Exception("*compile-path* not set");
//context = new GenContext(iName, ".dll", path, CompilerMode.File);
// TODO: In CLR4, should create a collectible type?
// Should we associate source file info?
// See Java committ 8d6fdb, 2015.07.17, related to CLJ-1645
// TODO: part of check on debug info
//if ( Compiler.IsCompiling )
//    context.SaveAssembly();
// attributes = ( [ type inits]... }
// inits = #{ init1 init2 ... }
// init =  { :key value ... }
// Special key :__args indicates positional arguments
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\GenProxy.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//static GenContext _staticContext = new GenContext("proxy", CompilerMode.Immediate);
//if ( _context == _staticContext) 
//    _staticContext = new GenContext("proxy"+(++_saveId).ToString(), CompilerMode.Immediate);
//string path = (string)Compiler.COMPILE_PATH.deref();
//if (path == null)
//    throw new Exception("*compile-path* not set");
////string dir = (string)Compiler.SOURCE_PATH.deref();
//_context = new GenContext(className, ".dll", path, CompilerMode.File);
// define the class
// Must follow AddInterfaceMethods
//if (Compiler.IsCompiling)
//    SaveProxyContext();
// define a constructor with the same signature as each public superclass ctor
// Call base class ctor on all the args
// gen.Emit(OpCodes.Ldarg_0);
// gen.Emit(OpCodes.Ldarg, i + 1);
// Create failing implementation of GetObjectData
// gen.Emit(OpCodes.Ldarg_0);
// gen.Emit(OpCodes.Ldarg_1);
// gen.Emit(OpCodes.Stfld, fb);
// gen.Emit(OpCodes.Ldarg_0);
// gen.Emit(OpCodes.Ldfld, fb);
// gen.Emit(OpCodes.Ldarg_1);
//gen.Emit(OpCodes.Call, Method_IPersistentCollection_Cons);
// gen.Emit(OpCodes.Stfld, fb);
// gen.Emit(OpCodes.Ldarg_0);
// gen.Emit(OpCodes.Ldfld, fb);
// TODO: ARe we handling generic methods properly?
// TODO: Are we handling explicit-implementation interface methods properly?
//Console.Write("Generating proxy method {0}(", m.Name);
//foreach (ParameterInfo p in m.GetParameters())
//    Console.Write("{0}, ", p.ParameterType.FullName);
//Console.Write(") ");
//Console.WriteLine(attribs.ToString());
//// Print a little message, for debugging purposes
//gen.Emit(OpCodes.Ldstr, String.Format("Calling {0} / {1}", proxyTB.FullName, m.ToString()));
//gen.Emit(OpCodes.Call, typeof(Console).GetMethod("WriteLine",
//    new Type[] { typeof(string) }));
//gen.Emit(OpCodes.Call, typeof(Console).GetMethod("get_Out"));
//gen.Emit(OpCodes.Call, typeof(System.IO.TextWriter).GetMethod("Flush"));
// Lookup method name in map
// gen.Emit(OpCodes.Ldarg_0);
// gen.Emit(OpCodes.Ldfld, mapField);
// gen.Emit(OpCodes.Ldstr, m.Name);
// gen.Emit(OpCodes.Call, Method_RT_get);
// gen.Emit(OpCodes.Ldnull);
// map entry found
// gen.Emit(OpCodes.Ldarg_0);  // push implicit 'this' arg.
// gen.Emit(OpCodes.Ldarg, i + 1);
// gen.Emit(OpCodes.Call, GetIFnInvokeMethodInfo(parmCount + 1));
// map entry not found
// get rid of null leftover from the 'get'
// gen.Emit(OpCodes.Ldarg_0);
// gen.Emit(OpCodes.Ldarg, i + 1);
// gen.EmitCall(m) improperly emits a callvirt in some cases
// gen.Emit(OpCodes.Ldstr, m.Name);
// gen.Emit(OpCodes.Newobj, CtorInfo_NotImplementedException_1);
// TODO: Define an extension to proxy that allows overriding getters/setters on properties.
//Console.Write("Generating proxy property {0} ({1})", pi.Name, pi.PropertyType);
//if (getter != null)
//    Console.Write(", get = {0}", getter.Name);
//if (setter != null)
//    Console.Write(", set = {0}", setter.Name);
//Console.WriteLine();
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\MethodSignature.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// names are same, do lexicographic ordering on the types.
// equal through length of smallest. smallest wins
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\AssignableExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\AssignExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\BindingInit.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\BodyExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\BooleanExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// , MaybePrimitiveExpr  TODO: No reason this shouldn't be, but it messes up the RecurExpr emit code.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\CaseExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//(case* expr shift mask  default map<minhash, [test then]> table-type test-type skip-check?)
//prepared by case macro and presumed correct
//case macro binds actual expr in let so expr is always a local,
//no need to worry about multiple evaluation
// [test-val then-expr]
// Equivalent to :
//    switch (hashed _expr)
//    
//      case i:  if _expr == _test_i
//                 goto end with _then_i
//               else goto default
//               
//      ...
//      default:
//            (default_label)
//             goto end with _default
//      end
//    end_label:
// else direct match
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\ConstantExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\DefExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// (def x) or (def x initexpr) or (def x "docstring" initexpr)
//Console.WriteLine("Def {0}", sym.Name);
//throw new Exception(string.Format("Name conflict, can't def {0} because namespace: {1} refers to: {2}",
//            sym, Compiler.CurrentNamespace.Name, v));
//vm = (IPersistentMap)RT.assoc(vm, Compiler.STATIC_KEY, true);
// drop quote
//.assoc(RT.SOURCE_SPAN_KEY,Compiler.SOURCE_SPAN.deref());
//  Following comment in JVM version
//mm = mm.without(RT.DOC_KEY)
//            .without(Keyword.intern(null, "arglists"))
//            .without(RT.FILE_KEY)
//            .without(RT.LINE_KEY)
//            .without(RT.COLUMN_KEY)
//            .without(Keyword.intern(null, "ns"))
//            .without(Keyword.intern(null, "name"))
//            .without(Keyword.intern(null, "added"))
//            .without(Keyword.intern(null, "static"));
// includesExplicitMetadata((MapExpr)_meta))
//IncludesExplicitMetadata((MapExpr)_meta))
//private static bool IncludesExplicitMetadata(MapExpr expr)
//{
//    for (int i = 0; i < expr.KeyVals.count(); i += 2)
//    {
//        Keyword k = ((KeywordExpr)expr.KeyVals.nth(i)).Kw;
//        if ((k != RT.FileKey) &&
//            (k != RT.DeclaredKey) &&
//            (k != RT.SourceSpanKey) &&
//            (k != RT.LineKey) &&
//            (k != RT.ColumnKey))
//            return true;
//    }
//    return false;
//}
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\DynInitHelper.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Reduces the provided DynamicExpression into site.Target(site, *args).
/// </summary>
// ($site = siteExpr).Target.Invoke($site, *args)
// rewrite the node...
// The following code is lifted from DLR because of protection levels on various pieces.
// From Microsoft.Scripting.Generation.ToDiskRewriter
// TODO: should caching move to AssemblyGen?
/* _typeGen.AssemblyGen. */MakeDelegateType(
// From Microsoft.Scripting.Generation.ToDiskRewriter
// We need to replace a transient delegateType with one stored in
// the assembly we're saving to disk.
//
// One complication:
// SaveAssemblies mode prevents us from detecting the module as
// transient. If that option is turned on, always replace delegates
// that live in another AssemblyBuilder
// DM: Added this test to detect the Snippets assembly/module
// From Microsoft.Scripting.Generation.AssemblyGen
// Adapted to not being a method of AssemblyGen, which causes me to copy a WHOLE BUNCH of stuff.
/* _assemblyGen. */DefineType(name, typeof(MulticastDelegate), DelegateAttributes, false);
// From Microsoft.Scripting.Generation.AssemblyGen
//private int _index;
//Interlocked.Increment(ref _index);
// There is a bug in Reflection.Emit that leads to 
// Unhandled Exception: System.Runtime.InteropServices.COMException (0x80131130): Record not found on lookup.
// if there is any of the characters []*&+,\ in the type name and a method defined on the type is called.
/* _myModule */ _assemblyGen.ModuleBuilder.DefineType(name, attr, parent);
// From Microsoft.Scripting.Utils.CollectionExtensions
// Name needs to be different so it doesn't conflict with Enumerable.Select
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\EmptyExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// JVM does not include LazySeq test.  I'm getting it in some places.  LazySeq of 0 size got us here, we'll treat as an empty list
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\Expr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\FieldExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\FnExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// This naming convention drawn from the Java code.
//  Name.Replace('.', '/');
// TODO: make static
//arglist might be preceded by symbol naming this fn
// Normalize body
//now (fn [args] body...) or (fn ([args] body...) ([args2] body2...) ...)
//turn former into latter
//Console.WriteLine("{0} uses this",fn.Name);
//    Dictionary<int, WeakReference > dict = DynMethodMap[key];
//    WeakReference wr = dict[arity];
//    return (DynamicMethod)wr.Target;
//WeakReference wr = ConstantsMap[key];
//return (object[])wr.Target;
// to avoid the non-variadics, the last of which may have NumParams == this method RequireArity
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\FnMethod.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// localbinding => localbinding
// Accessor for _argTypes: see below.
// accessor for _retType: see below.
// For top-level compilation only
// TODO: Can we get rid of this when the DLR-based compile goes away?
//_thisBinding = Compiler.RegisterLocal(Symbol.intern(fn.ThisName ?? "fn__" + RT.nextID()), null, null, false);
// Objx.IsStatic)
// ([args] body ... )
//if (method._prim != null)
//    method._prim = method._prim.Replace('.', '/');
// register 'this' as local 0  
//Type t = null;
//if (x is Type)
//    t = (Type)x;
//else if (x is Symbol)
//    t = Compiler.PrimType((Symbol)x);
//Console.WriteLine("emit static: {0}", fn.Name);
//Console.WriteLine("emit prim: {0}", fn.Name);
//Console.WriteLine("emit normal: {0}", fn.Name);
// Generate the regular invoke, calling the static method
// Generate primInvoke if prim
//HostExpr.EmitUnboxArg(fn, primIlg, _argTypes[i]);
// Generate the regular invoke, calling the prim method
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\GenContext.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// Massive kludge for .net 3.5 -- the RuntimeAssemblyBuilder yielded by reflection is not the same as AssemblyBuilder.
//&& directory != ".")
// TODO: Make this settable from a *debug* flag
// DO not call context.AssmeblyGen.SaveAssembly() directly.
// probably a dynamic ilgen
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\HostArg.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\HostExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// form is one of:
//  (. x fieldname-sym)
//  (. x 0-ary-method)
//  (. x propertyname-sym)
//  (. x methodname-sym args)+
//  (. x (methodname-sym args?))
//  (. x (generic-m 
// Compiler.GetSourceSpanMap(form);
// determine static or instance
// static target must be symbol, either fully.qualified.Typename or Typename that has been imported
// at this point, t will be non-null if static
// TODO: Figure out if we want to handle the -propname otherwise.
// The JVM version does not have to worry about Properties.  It captures 0-arity methods under fields.
// We have to put in special checks here for this.
// Also, when reflection is required, we have to capture 0-arity methods under the calls that
//   are generated by StaticFieldExpr and InstanceFieldExpr.
// same as InstancePropertyExpr when last arg is null
//  t is null, so we know this is not a static call
//  If instance is null, we are screwed anyway.
//  If instance is not null, then we don't have a type.
//  So we must be in an instance call to a property, field, or 0-arity method.
//  The code generated by InstanceFieldExpr/InstancePropertyExpr with a null FieldInfo/PropertyInfo
//     will generate code to do a runtime call to a Reflector method that will check all three.
//return new InstanceFieldExpr(source, spanMap, tag, instance, fieldName, null); // same as InstancePropertyExpr when last arg is null
//return new InstanceZeroArityCallExpr(source, spanMap, tag, instance, fieldName); 
// same as InstancePropertyExpr when last arg is null
//ISeq call = RT.third(form) is ISeq ? (ISeq)RT.third(form) : RT.next(RT.next(form));
// We have a type args supplied for a generic method call
// (. thing methodname (type-args type1 ... ) args ...)
// if ns-qualified, can't be classname
// Array.  JVM version detects [whatever  notation.
// JVM casts to java.util.Map
// aargh
// leave t set to null -> return null
// if ns-qualified, can't be classname
// TODO: Properly handle value types here.  Really, we need to know the incoming type.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\IdentityHashMap.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\IfExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// (if test then) or (if test then else)
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\IlGen.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// Cannot work with signatures on uncreated types
// Required modifier : followed by a TypeDef or TypeRef token
// Optional modifier : followed by a TypeDef or TypeRef token
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\ImportExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\InstanceFieldExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// Java version does not include check on _targetType
// However, this seems consistent with the checks in the generation code.
// We could convert this to a dynamic call-site
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\InstanceMethodExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\InstanceOfExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\InstanceZeroArityCallExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: Handle by-ref
// See MethodExpr.EmitComplexCall to see why this is so complicated
//  Build the parameter list
// Build dynamic call and lambda
// Not covariant. Sigh.
//  Emit target + args (no args, actually)
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\Intrinsics.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// bitwise
// TODO: add ulong overloads in Numbers.
//AddOp(nt, "and", uuta, OpCodes.And);
//AddOp(nt, "or", uuta, OpCodes.Or);
//AddOp(nt, "xor", uuta, OpCodes.Xor);
//AddOp(nt, "shiftLeft", uuta, OpCodes.Shl);
//AddOp(nt, "shiftRight", uuta, OpCodes.Shr);
//AddOp(nt, "unsignedShiftRight", uuta, OpCodes.Shr_Un);
// arithmetic on doubles
// integer ops
// unchecked int ops
// long/ulong/double unchecked ops
// Array ops
//AddOp(rtt, "aget", new Type[] { typeof(char[]), typeof(int) }, OpCodes.lde );
//AddOp(rtt, "aget", new Type[] { typeof(ulong[]), typeof(int) }, OpCodes.lde );
//AddOp(rtt, "aget", new Type[] { typeof(bool[]), typeof(int) }, OpCodes.lde );
// We need to write a special prefer method to distinguish these.
//AddOp(rtt, "alength", new Type[] { typeof(float[]) }, OpCodes.Ldlen );
//AddOp(rtt, "alength", new Type[] { typeof(double[]) }, OpCodes.Ldlen);
//AddOp(rtt, "alength", new Type[] { typeof(decimal[]) }, OpCodes.Ldlen);
//AddOp(rtt, "alength", new Type[] { typeof(bool[]) }, OpCodes.Ldlen );
//AddOp(rtt, "alength", new Type[] { typeof(byte[]) }, OpCodes.Ldlen );
//AddOp(rtt, "alength", new Type[] { typeof(sbyte[]) }, OpCodes.Ldlen );
//AddOp(rtt, "alength", new Type[] { typeof(short[]) }, OpCodes.Ldlen );
//AddOp(rtt, "alength", new Type[] { typeof(ushort[]) }, OpCodes.Ldlen );
//AddOp(rtt, "alength", new Type[] { typeof(int[]) }, OpCodes.Ldlen );
//AddOp(rtt, "alength", new Type[] { typeof(uint[]) }, OpCodes.Ldlen );
//AddOp(rtt, "alength", new Type[] { typeof(long[]) }, OpCodes.Ldlen );
//AddOp(rtt, "alength", new Type[] { typeof(ulong[]) }, OpCodes.Ldlen );
//AddOp(rtt, "alength", new Type[] { typeof(char[]) }, OpCodes.Ldlen );
//AddOp(rtt, "alength", new Type[] { typeof(object[]) }, OpCodes.Ldlen );
// Todo:  reimplement RT.ulongCast and implement these intrinsics
// Predicates
// special case the shift methods because we didn't create a way to embed arguments to the opcodes.
// the long second-arg bit-shifts need to mask to a value <= 63
// the int second-arg bit-shifts need to maks to a value <= 31
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\InvokeExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//object arglists = RT.get(RT.meta(v), Compiler.ArglistsKeyword);
//Console.WriteLine("invoke direct: {0}", v);
//Console.WriteLine("NOT direct: {0}", v);
//if (args.count() > Compiler.MAX_POSITIONAL_ARITY)
//    throw new ArgumentException(String.Format("No more than {0} args supported", Compiler.MAX_POSITIONAL_ARITY));
//Compiler.GetSourceSpanMap(form),
// target
// target, target
// target
// class
// class, cached-class
// 
// target
// null or target
// (null or target), null
// (0 or 1)
// target
// class
//    (typeType <= class)
// this, class
// 
// var
// proto-fn
// proto-fn, target
// target
// In JVM.  No necessary here.
//if (_tailPosition)
//{
//    ObjMethod method = (ObjMethod)Compiler.MethodVar.deref();
//    method.EmitClearThis(ilg);
//}
// In JVM.  No necessary here.
//if (_tailPosition)
//{
//    ObjMethod method = (ObjMethod)Compiler.MethodVar.deref();
//    method.EmitClearThis(ilg);
//}
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\IParser.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\KeywordExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\KeywordInvokeExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: Debug info
// pseudo-code:
//  ILookupThunk thunk = objclass.ThunkField(i)
//  object target = ...code...
//  object val = thunk.get(target)
//  if ( val != thunk )
//     return val
//  else
//     KeywordLookupSite site = objclass.SiteField(i)
//     thunk = site.fault(target)
//     objclass.ThunkField(i) = thunk
//     val = thunk.get(target)
//     return val
// thunk
//  (thunkLoc <= thunk)
// target
//   (targetLoc <= target)
// result
//    (resultLoc <= result)
// result
// site
// site, target
// new-thunk
// new-thunk, new-thunk
// new-thunk
// new-thunk, target
// result
// result
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\LetExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// form => (let  [var1 val1 var2 val2 ... ] body ... )
//      or (loop [var1 val1 var2 val2 ... ] body ... )
// may repeat once for each binding with a mismatch, return breaks
// Sequential enhancement of env (like Lisp let*)
// stuff with clear paths,
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\LetFnExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// form => (letfn*  [var1 (fn [args] body) ... ] body ... )
// pre-seed env (like Lisp labels)
// b.CanBeCleared = false;
// Define our locals
// Then initialize
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\LiteralExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\LocalBinding.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\LocalBindingExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\MapExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//else if (constant)
//{
// This 'optimzation' works, mostly, unless you have nested map values.
// The nested map values do not participate in the constants map, so you end up with the code to create the keys.
// Result: huge duplication of keyword creation.  3X increase in init time to the REPL.
//    //IPersistentMap m = PersistentHashMap.EMPTY;
//    //for (int i = 0; i < keyvals.length(); i += 2)
//    //    m = m.assoc(((LiteralExpr)keyvals.nth(i)).Val, ((LiteralExpr)keyvals.nth(i + 1)).Val);
//    //return new ConstantExpr(m);
//    return ret;
//}
// TBD: Add more detail to exception thrown below.
// This 'optimzation' works, mostly, unless you have nested map values.
// The nested map values do not participate in the constants map, so you end up with the code to create the keys.
// Result: huge duplication of keyword creation.  3X increase in init time to the REPL.
//IPersistentMap m = PersistentArrayMap.EMPTY;
//for (int i = 0; i < keyvals.length(); i += 2)
//    m = m.assoc(((LiteralExpr)keyvals.nth(i)).Val, ((LiteralExpr)keyvals.nth(i + 1)).Val);
//return new ConstantExpr(m);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\MaybePrimitiveExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\MetaExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\MethodExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// IN JVM:
//if (_tailPosition)
//    _method.EmitClearThis(ilg);
// TOD: We have gotten rid of light-compile. Simplify this.
// This is made more complex than I'd like by light-compiling.
// Without light-compile, we could just:
//   Emit the target expression
//   Emit the arguments (and build up the parameter list for the lambda)
//   Create the lambda, compile to a methodbuilder, and call it.
// Light-compile forces us to 
//     create a lambda at the beginning because we must 
//     compile it to a delegate, to get the type
//     write code to grab the delegate from a cache
//     Then emit the target expression
//          emit the arguments (but note we need already to have built the parameter list)
//          Call the delegate
//  Combined, this becomes
//      Build the parameter list
//      Build the dynamic call and lambda  (slightly different for light-compile vs full)
//      if light-compile
//          build the delegate
//          cache it
//          emit code to retrieve and cast it
//       emit the target expression
//       emit the args
//       emit the call (slightly different for light compile vs full)
//
//  Build the parameter list
// Build dynamic call and lambda
// This is what I want to do.
//DynamicExpression dyn = Expression.Dynamic(binder, typeof(object), paramExprs);
// Unfortunately, the Expression.Dynamic method does not respect byRef parameters.
// The workaround appears to be to roll your delegate type and then use Expression.MakeDynamic, as below.
// Not covariant. Sigh.
//  Emit target + args
// light compile
// light compile
// paramIsByRef
//  If the DLR folks had made this method public (instead of internal), I could call it directly.
//  Didn't feel like copying their code due to license/copyright.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\MethodParamExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\MonitorEnterExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\MonitorExitExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\NewExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// Value types have a default no-arg c-tor that is not picked up in the regular c-tors.
//int line = (int)Compiler.LINE.deref();
// form => (new Typename args ... )
// TODO: Deal with ByRef parameters
// See the notes on MethodExpr.EmitComplexCall on why this is so complicated
// Build dynamic call and lambda
// Not covariant. Sigh.
//  Emit target + args
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\NewInstanceExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// frm is: (deftype* tagname classname [fields] :implements [interfaces] :tag tagname methods*)
// frm is:  (reify this-name? [interfaces] (method-name [args] body)* )
// ret.Name.Replace('.', '/');
// Java: ret.objtype = Type.getObjectType(ret.internalName);
// Java TODO: inject __meta et al into closes - when?
// use array map to preserve ctor order
// Java TODO: set up volatiles
//ret._volatiles = PersistentHashSet.create(RT.seq(RT.get(ret._optionsMap, volatileKey)));
// now (methodname [args] body)*
// TOD:  Really, the first baseclass here should be 'superclass' but can't handle hostexprs nested in method bodies -- reify method compilation takes place before this sucker is compiled, so can't replace the call.
// Might be able to flag baseclass classes and not try to convert, leading to a dynsite.
/***
/*
//TypeBuilder tb = context.ModuleBuilder.DefineType(Compiler.CompileStubPrefix + "." + InternalName + RT.nextID(), TypeAttributes.Public | TypeAttributes.Abstract, super, interfaces);
// ctor that takes closed-overs and does nothing
// store closed-overs in their fields
// gen.Emit(OpCodes.Ldarg_0);
// gen.Emit(OpCodes.Ldarg, a + 1);
//for (int i = 0; i < AltCtorDrops; i++)
//    ilg2.EmitNull();
// __meta
// __extmap
// __hash
// __hasheq
//for (int i = 0; i < AltCtorDrops; i++)
//    ilg2.EmitNull();
// __hash
// __hasheq
//static string[] InterfaceNames(IPersistentVector interfaces)
//{
//    int icnt = interfaces.count();
//    string[] inames = icnt > 0 ? new string[icnt] : null;
//    for (int i = 0; i < icnt; i++)
//        inames[i] = SlashName((Type)interfaces.nth(i));
//    return inames;
//}
//static string SlashName(Type t)
//{
//    return t.FullName.Replace(',', '/');
//}
// getBasis()
// create(IPersistentMap)
// local_kw = Keyword.intern(bname)
// local_i = arg_0.valAt(kw,null)
// arg_0 = arg_0.without(local_kw);
// __meta
// __extmap
// __hash
// __hasheq
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\NewInstanceMethod.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// Public access -- see below
// Public access -- see below
// Public access -- see below
// (methodname [this-name args*] body...)
// this-name might be nil
// we have an explicit interface implementation
// register as the current method and set up a new env frame
// PathNode pnade = new PathNode(PATHTYPE.PATH, (PathNode) CLEAR_PATH.get());
// CLEAR_PATH, pnode,
// CLEAR_ROOT, pnode,
// CLEAR_SITES, PersistentHashMap.EMPTY
// register 'this' as local 0
//method._thisBinding = Compiler.RegisterLocalThis(((thisName == null) ? dummyThis : thisName), thisTag, null);
// Param should be symbol or (by-ref symbol)
// multiple matches
// must be hinted and match one method
// one match
// if hinted, validate match,
//if (m.ReturnType != method._retType)
//    throw new ArgumentException(String.Format("Mismatched return type: {0}, expected {1}, had: {2}",
//        name.Name, m.ReturnType.Name, method._retType.Name));
// adopt found method sig
// validate unique name + arity among additional methods
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\NilExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\Node.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: Remove Node class
/*
/// Base class for AST expressions in the compiler.
/// </summary>
/// <remarks>Stolen from IronPython.</remarks>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\NumberExpr.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\ObjExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// If we were to get rid of setting these in Compiler.Compile1, we could change to protected.
// Perhaps part of passing context instead of using dynamic vars.
// symbol -> lb
// needed by NewInstanceExpr
// needed by NewInstanceExpr
// needed by NewInstanceExpr
// needed by NewInstanceExpr
// Java: can't emit derived fn types due to visibility
//emitting a Fn means constructing an instance, feeding closed-overs from enclosing scope, if any
//objx arg is enclosing objx, not this
/* || (CanBeDirect && Compiler.IsCompiling) */ ? InternalName : InternalName + "__" + RT.nextID();
//,
//Compiler.COMPILE_STUB_CLASS, _baseType));
// If this IsDefType, then it has already emitted the closed-over fields on the base class.
//Keyword k = (Keyword)_keywordCallsites.nth(i);
// closed-overs map to instance fields.
// Pass closed-overs to base class ctor
// gen.Emit(OpCodes.Ldarg_0);
//LocalBinding lb = (LocalBinding)s.first();
//FieldBuilder fb = _closedOverFields[a];
//bool isVolatile = IsVolatile(_closedOverFieldsToBindingsMap[fb]);
// gen.Emit(OpCodes.Ldarg, a + 1);
//Call base constructor
// Store Meta
// store closed-overs in their fields
//LocalBinding lb = (LocalBinding)s.first();
// gen.Emit(OpCodes.Ldarg_0);
// gen.Emit(OpCodes.Ldarg, a + 1);
//Call full constructor
// gen.Emit(OpCodes.Ldarg_0);
//for (int i = 0; i < AltCtorDrops; i++)
//    gen.EmitNull();
// __meta
// __extmap
// __hash
// __hasheq
//Call full constructor
// gen.Emit(OpCodes.Ldarg_0);
// __hash
// __hasheq
// null meta
// IPersistentMap meta()
// IObj withMeta(IPersistentMap)
// meta arg
//this
// We have to do this different than the JVM version.
// The JVM does all these at the end.
// That works for the usual ObjExpr, but not for the top-level one that becomes __Init__.Initialize in the assembly.
// That one need the constants defined incrementally.
// This version accommodates the all-at-end approach for general ObjExprs and the incremental approach in Compiler.Compile1.
//  If we don't pick up the ctor after we finalize the type, 
//    we sometimes get a ctor which is not a RuntimeConstructorInfo
//  This causes System.DynamicILGenerator.Emit(opcode,ContructorInfo) to blow up.
//    The error says the ConstructorInfo is null, but there is a second case in the code.
//  Thank heavens one can run Reflector on mscorlib.
//
// We will take the first ctor with indicated number of args.
// In our use case, it should be unique.
//ilg.EmitString(Compiler.DestubClassName(((Type)value).FullName));
//MethodInfo[] minfos = value.GetType().GetMethods(BindingFlags.Static | BindingFlags.Public);
//HostExpr.EmitBoxReturn(this, ilg, item.GetType());
//static void EmitPrimitive(CljILGen ilg, object val)
//{
//    switch (Type.GetTypeCode(val.GetType()) )
//    {
//        case TypeCode.Boolean:
//            ilg.EmitBoolean((bool)val); break;
//        case TypeCode.Byte:
//            ilg.EmitByte((byte)val); break;
//        case TypeCode.Char:
//            ilg.EmitChar((char)val); break;
//        case TypeCode.Decimal:
//            ilg.EmitDecimal((decimal)val); break;
//        case TypeCode.Double:
//            ilg.EmitDouble((double)val); break;
//        case TypeCode.Int16:
//            ilg.EmitShort((short)val); break;
//        case TypeCode.Int32:
//            ilg.EmitInt((int)val); break;
//        case TypeCode.Int64:
//            ilg.EmitLong((long)val); break;
//        case TypeCode.SByte:
//            ilg.EmitSByte((sbyte)val); break;
//        case TypeCode.Single:
//            ilg.EmitSingle((float)val); break;
//        case TypeCode.UInt16:
//            ilg.EmitUShort((ushort)val); break;
//        case TypeCode.UInt32:
//            ilg.EmitUInt((uint)val); break;
//        case TypeCode.UInt64:
//            ilg.EmitULong((ulong)val); break;
//        default:
//            throw new InvalidOperationException("Unknown constant type in EmitPrimitive");
//    }
//}
// or just Method_Var_get??
// this
// TODO: ONCEONLY?    
//int argOffset = IsStatic ? 1 : 0;
//ilg.Emit(OpCodes.Ldarg, lb.Index - argOffset);
// this
//int argOffset = IsStatic ? 0 : 1;
//ilg.Emit(OpCodes.Ldarg, lb.Index + argOffset);
// this
// Full compile
// this
// TODO: Convert to a Switch instruction
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\ObjMethod.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// Java: when closures are defined inside other closures,
// the closed over locals need to be propagated to the enclosing objx
// localbinding => localbinding
// num -> localbinding
//static void EmitClearThis(CljILGen ilg) 
//{
//    ilg.EmitNull();
//    ilg.EmitStoreArg(0);
//}
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\ParseException.cs
/// <summary>
/// Exception thrown during parsing
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\ParserContext.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// RHC = Rich Hickey Context -- same enum as Compiler.C in the Java version
// value ignored
// value required
// tail position relative to enclosing recur frame
// value semantics
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\RecurExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// Compiler.GetSourceSpanMap(form);
//ilg.EmitCall(Compiler.Method_RT_intCast_long);
//Type primt = lb.PrimitiveType;
//ilg.Emit(OpCodes.Starg, lb.Index - (objx.IsStatic ? 0 : 1));
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\SetExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\StaticFieldExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// literal fields need to be inlined directly in here... We use GetRawConstant
// which will work even in partial trust if the constant is protected.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\StaticInvokeExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//readonly Type _target;
//_target = target;
//Console.WriteLine("Not bound: {0}", v);
//Console.WriteLine("Method {0}", m.Name);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\StaticMethodExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// JVM: clear locals
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\StringExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\TheVarExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\ThrowExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\TryExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//_retLocal = retLocal;
//_finallyLocal = finallyLocal;
// (try try-expr* catch-expr* finally-expr?)
// catch-expr: (catch class sym expr*)
// finally-expr: (finally expr*)
// finally
//Var.pushThreadBindings(RT.map(Compiler.IN_CATCH_FINALLY, RT.T));
// this codepath is hit when there is neither catch nor finally, e.g., (try (expr))
// return a body expr directly
// degenerate case
// Exception should be on the stack.  Put in clause local
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\UnresolvedVarExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// do nothing
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\UntypedExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\VarExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\CljCompiler\Ast\VectorExpr.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\AFn.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Provides a basic implementation of <see cref="IFn">IFn</see> interface methods.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\AFnImpl.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// An implementation of AFn. Instances of this class are created by the compiler.
/// </summary>
/// <remarks>
/// <para>We need this at the moment as a workaround to DLR not being able to generate instance methods from lambdas.</para>
/// </remarks>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\AFunction.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Base class providing IComparer implementation on top of <see cref="AFn">AFn</see>.  Internal use by compiler.
/// </summary>
/// <summary>
/// Compares two objects and returns a value indicating whether one is less than, equal to, or greater than the other.
/// </summary>
/// <param name="x">The first object to compare.</param>
/// <param name="y">The second object to compare.</param>
/// <returns>x?y:-1 if less than, 0 if equal, 1 if greater</returns>
/// <remarks>Uses the two-parameter invoke.  
/// Return type can be <code>bool</code> with <value>true</value> meaning less-than, or an int.</remarks>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Agent.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents an Agent.
/// </summary>
/// <remarks>
/// <para>See the Clojure documentation for more information.</para>
/// <para>The Java implementation plays many more games with thread pools.  The CLR does not provide such support. We need to revisit this in CLR 4.  
/// Until then: TODO: Implement our own thread pooling?</para>
/// </remarks>
// non-null indicates fail state
//static readonly Keyword FailKeyword = Keyword.intern(null, "fail");
/// <summary>
/// The current state of the agent.
/// </summary>
/// <summary>
/// The current state of the agent.
/// </summary>
/// <summary>
/// A queue of pending actions.
/// </summary>
/// <summary>
/// Number of items in the queue.
/// </summary>
/// <summary>
/// Number of items in the queue.  For core.clj compatibility.
/// </summary>
/// <returns></returns>
///// <summary>
///// Agent errors, a sequence of Exceptions.
///// </summary>
//private volatile ISeq _errors = null;
///// <summary>
///// Agent errors, a sequence of Exceptions.
///// </summary>
//public ISeq Errors
//{
//    get { return _errors; }
//}
///// <summary>
///// Add an error.
///// </summary>
///// <param name="e">The exception to add.</param>
//public void AddError(Exception e)
//{
//    _errors = RT.cons(e, _errors);
//}
/// <summary>
/// A collection of agent actions enqueued during the current transaction.  Per thread.
/// </summary>
/// <summary>
/// A collection of agent actions enqueued during the current transaction.  Per thread.
/// </summary>
/// <summary>
/// Construct an agent with given state and null metadata.
/// </summary>
/// <param name="state">The initial state.</param>
/// <summary>
/// Construct an agent with given state and metadata.
/// </summary>
/// <param name="state">The initial state.</param>
/// <param name="meta">The metadata to attach.</param>
/// <summary>
/// Set the state.
/// </summary>
/// <param name="newState">The new state.</param>
/// <returns><value>true</value> if the state changed; <value>false</value> otherwise.</returns>
///// <summary>
///// Clear the agent's errors.
///// </summary>
///// <remarks>Lowercase-name and  for core.clj compatibility.</remarks>
//public void clearErrors()
//{
//    _errors = null;
//}
/// <summary>
/// Send a message to the agent.
/// </summary>
/// <param name="fn">The function to be called on the current state and the supplied arguments.</param>
/// <param name="args">The extra arguments to the function.</param>
/// <param name="solo"><value>true</value> means execute on its own thread (send-off); 
/// <value>false</value> means use a thread pool thread (send).</param>
/// <returns>This agent.</returns>
/// <summary>
/// Send an action (encapsulated message).
/// </summary>
/// <param name="action">The action to execute.</param>
/// <remarks>
/// <para>If there is a transaction running on this thread, 
/// defer execution until the transaction ends 
/// (enqueue the action on the transaction).</para>
/// <para>If there is already an action running, enqueue it (nested).</para>
/// <para>Otherwise, queue it for execution.</para>
/// </remarks>
/// <summary>
/// Enqueue an action in the pending queue.
/// </summary>
/// <param name="action">The action to enqueue.</param>
/// <remarks>Spin-locks to update the queue.</remarks>
/// <summary>
/// Gets the (immutable) value the reference is holding.
/// </summary>
/// <returns>The value</returns>
/// <summary>
/// Shutdown all threads executing.
/// </summary>
/// <remarks>We need to work on this.</remarks>
// JAVA: soloExecutor.shutdown();
// JAVA: pooledExecutor.shutdown();
// TODO: record active jobs and shut them down?
/// <summary>
/// An encapsulated message.
/// </summary>
/// <summary>
/// The agent this message is for.
/// </summary>
/// <summary>
/// The agent this message is for.
/// </summary>
/// <summary>
/// The function to call to create the new state.
/// </summary>
/// <summary>
/// The arguments to call (in addition to the current state).
/// </summary>
/// <summary>
/// Should execute on its own thread (not a thread-pool thread).
/// </summary>
/// <summary>
/// Create an encapsulated message to an agent.
/// </summary>
/// <param name="agent">The agent the message is for.</param>
/// <param name="fn">The function to compute the new value.</param>
/// <param name="args">Additional arguments (in addition to the current state).</param>
/// <param name="solo">Execute on its own thread?</param>
/// <summary>
/// Send the message.
/// </summary>
// TODO:  Reuse/cleanup these threads
//thread.Priority = ThreadPriority.Lowest;
// ignore _errorHandler errors
/// <summary>
/// Worker method to execute the action on a thread.
/// </summary>
/// <param name="state">(not used)</param>
/// <remarks>corresponds to doRun in Java version</remarks>
// allow errorHandler to send
// ignore error handler errors
/// <summary>
/// Enqueue nested actions.
/// </summary>
/// <returns></returns>
/// <remarks>lowercase for core.clj compatibility</remarks>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\AMapEntry.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Provides a basic implementation of <see cref="IMapEntry">IMapEntry</see>.
/// </summary>
/// <summary>
/// Initialize an <see cref="AMapEntry">AMapEntry</see> with null metadata.
/// </summary>
/// <summary>
/// Convert to an actual <see cref="IPersistentVector">IPersistentVector</see> with two elements.
/// </summary>
/// <returns>An <see cref="IPersistentVector">IPersistentVector</see> with two elements.</returns>
// they changed from implementing IPersistentVector to deriving from APersistentVector.
///// <summary>
///// Determines whether the specified Object is equal to the current one.
///// </summary>
///// <param name="obj">The Object to compare with the current one.</param>
///// <returns><value>true</value> if the specified Object is equal to the current one; 
///// otherwise <value>false</value>.</returns>
///// <remarks>Acts like a value type.</remarks>
//public override bool Equals(object obj)
//{
//    return APersistentVector.doEquals(this, obj);
//}
///// <summary>
///// Computes the hash code for the object.
///// </summary>
///// <returns>A hash code for the current object.</returns>
//public override int GetHashCode()
//{
//    // must match logic in APersistentVector
//    return Util.HashCombine(Util.HashCombine(0, Util.Hash(key())), Util.Hash(val()));
//}
///// <summary>
///// Returns a string that represents the current object.
///// </summary>
///// <returns></returns>
//public override string ToString()
//{
//    StringBuilder sb = new StringBuilder();
//    RT.print(this, sb);
//    return sb.ToString();
//}
/// <summary>
/// Get the key in a key/value pair.
/// </summary>
/// <returns>The key.</returns>
/// <summary>
/// Get the value in a key/value pair.
/// </summary>
/// <returns>The value.</returns>
/// <summary>
/// Gets the number of items in the vector.
/// </summary>
/// <returns>The number of items.</returns>
/// <remarks>Not sure why you wouldn't use <c>count()</c> intead.</remarks>
/// <summary>
/// Get the i-th item in the vector.
/// </summary>
/// <param name="i">The index of the item to retrieve/</param>
/// <returns>The i-th item</returns>
/// <remarks>Throws an exception if the index <c>i</c> is not in the range of the vector's elements.</remarks>
/// <summary>
/// Return a new vector with the i-th value set to <c>val</c>.
/// </summary>
/// <param name="i">The index of the item to set.</param>
/// <param name="val">The new value</param>
/// <returns>A new (immutable) vector v with v[i] == val.</returns>
/// <summary>
/// Creates a new vector with a new item at the end.
/// </summary>
/// <param name="o">The item to add to the vector.</param>
/// <returns>A new (immutable) vector with the objected added at the end.</returns>
/// <summary>
/// Test if the map contains a key.
/// </summary>
/// <param name="key">The key to test for membership</param>
/// <returns>True if the key is in this map.</returns>
/// <summary>
/// Returns the key/value pair for this key.
/// </summary>
/// <param name="key">The key to retrieve</param>
/// <returns>The key/value pair for the key, or null if the key is not in the map.</returns>
/// <summary>
/// Add a new key/value pair.
/// </summary>
/// <param name="key">The key</param>
/// <param name="val">The value</param>
/// <returns>A new map with the key/value added.</returns>
/// <summary>
/// Gets the value associated with a key.
/// </summary>
/// <param name="key">The key to look up.</param>
/// <returns>The associated value. (Throws an exception if key is not present.)</returns>
/// <summary>
/// Gets the value associated with a key.
/// </summary>
/// <param name="key">The key to look up.</param>
/// <param name="notFound">The value to return if the key is not present.</param>
/// <returns>The associated value (or <c>notFound</c> if the key is not present.</returns>
//public ISeq rseq()
//{
//    return asVector().rseq();
//}
/// <summary>
/// Gets the number of items in the collection.
/// </summary>
/// <returns>The number of items in the collection.</returns>
/// <summary>
/// Gets an ISeq to allow first/rest iteration through the collection.
/// </summary>
/// <returns>An ISeq for iteration.</returns>
/// <summary>
/// Returns a new collection that has the given element cons'd on front of the eixsting collection.
/// </summary>
/// <param name="o">An item to put at the front of the collection.</param>
/// <returns>A new immutable collection with the item added.</returns>
//IPersistentCollection IPersistentCollection.cons(object o)
//{
//    return cons(o);
//}
/// <summary>
/// Peek at the top (first) element in the stack.
/// </summary>
/// <returns>The top (first) element.</returns>
/// <summary>
/// Returns a new stack with the top element popped.
/// </summary>
/// <returns>The new stack</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\APersistentMap.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Provides a basic impelmentation of <see cref="IPersistentMap">IPersistentMap</see> functionality.
/// </summary>
/// <summary>
/// Caches the hash code, when computed.
/// </summary>
/// <remarks>The default value indicates that the hash code has not been computed yet.</remarks>
/// <summary>
/// Caches the hashseq code, when computed.
/// </summary>
/// <remarks>The default value indicates that the hasheq code has not been computed yet.</remarks>
/// <summary>
/// Returns a string that represents the current object.
/// </summary>
/// <returns>A string that represents the current object.</returns>
/// <summary>
/// Determines whether the specified Object is equal to the current Object.
/// </summary>
/// <param name="obj">The Object to compare with the current Object. </param>
/// <returns>true if the specified Object is equal to the current Object; 
/// otherwise, false.</returns>
//if(!(obj instanceof Map))
//    return false;
//Map m = (Map) obj;
// Java had the following.
// This works on other APersistentMap implementations, but not on
//  arbitrary dictionaries.
//if (d.Count != m1.Count || d.GetHashCode() != m1.GetHashCode())
//    return false;
/// <summary>
/// Gets a hash code for the current object.
/// </summary>
/// <returns>A hash code for the current object.</returns>
/// <remarks>Valud-based = relies on all entries.  Once computed, it is cached.</remarks>
/// <summary>
/// Returns a new collection that has the given element cons'd on front of the eixsting collection.
/// </summary>
/// <param name="o">An item to put at the front of the collection.</param>
/// <returns>A new immutable collection with the item added.</returns>
/// <summary>
/// Determine if an object is equivalent to this (handles all collections).
/// </summary>
/// <param name="o">The object to compare.</param>
/// <returns><c>true</c> if the object is equivalent; <c>false</c> otherwise.</returns>
/// <remarks>
/// In Java Rev 1215, Added equiv.  Same as the definition in Equals, as in they took out the hashcode comparison.
/// Different, as in Util.Equal above became Util.equals. and below it is Util.equiv.
/// </remarks> 
//if(!(obj instanceof Map))
//    return false;
//Map m = (Map) obj;
// Java had the following.
// This works on other APersistentMap implementations, but not on
//  arbitrary dictionaries.
//if (d.Count != this.Count || d.GetHashCode() != this.GetHashCode())
//    return false;
/// <summary>
/// Add a new key/value pair.
/// </summary>
/// <param name="o">The key/value pair to add.</param>
/// <returns>A new map with key+value pair added.</returns>
//_hasheq = mapHasheq(this);
/// <summary>
/// Implements a sequence across the keys of map.
/// </summary>
/// <summary>
/// Returns an enumerator that iterates through a collection.
/// </summary>
/// <returns>A <see cref="SeqEnumerator">SeqEnumerator</see> that iterates through the sequence.</returns>
/// <summary>
/// Implements a sequence across the values of a map.
/// </summary>
/// <summary>
/// Returns an enumerator that iterates through a collection.
/// </summary>
/// <returns>A <see cref="SeqEnumerator">SeqEnumerator</see> that iterates through the sequence.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\APersistentSet.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// , Set -- no equivalent,  Should we do ISet<Object>?
/// <summary>
/// Caches the hash code, when computed.
/// </summary>
/// <summary>
/// Caches the hashseq code, when computed.
/// </summary>
/// <remarks>The default value indicates that the hasheq code has not been computed yet.</remarks>
/// <summary>
/// The underlying map that contains the set's elements.
/// </summary>
/// <summary>
/// Initialize an <cref see="APersistentSet">APersistentSet</cref> from the metadata map and the data map.
/// </summary>
/// <param name="impl">The underlying implementation map</param>
/// <summary>
/// Returns a string representing the current object.
/// </summary>
/// <returns>A string representing the current object.</returns>
/// <summary>
/// Computes a hash code for the current object.
/// </summary>
/// <returns>A hash code for the current object.</returns>
/// <remarks>The hash code is value-based (based on the items in the set).  
/// Once computed, the value is cached.</remarks>
/// <summary>
/// Determines whether the specified Object is equal to the current Object.
/// </summary>
/// <param name="obj">The Object to compare with the current Object.</param>
/// <returns><value>true</value> if the specified Object is equal to the current Object; 
/// otherwise, <value>false</value>.
/// </returns>
// I really can't do what the Java version does.
// It casts to a Set.  No such thing here.  We'll use IPersistentSet instead.
// No System.Collections.Generic.ISet<T>
/// <summary>
/// Get a set with the given item removed.
/// </summary>
/// <param name="key">The item to remove.</param>
/// <returns>A new set with the item removed.</returns>
/// <summary>
/// Test if the set contains the key.
/// </summary>
/// <param name="key">The value to test for membership in the set.</param>
/// <returns>True if the item is in the collection; false, otherwise.</returns>
/// <summary>
/// Get the value for the key (= the key itself, or null if not present).
/// </summary>
/// <param name="key">The value to test for membership in the set.</param>
/// <returns>the key if the key is in the set, else null.</returns>
/// <summary>
/// Gets the number of items in the collection.
/// </summary>
/// <returns>The number of items in the collection.</returns>
/// <summary>
/// Gets an ISeq to allow first/rest iteration through the collection.
/// </summary>
/// <returns>An ISeq for iteration.</returns>
/// <summary>
/// Determine if an object is equivalent to this (handles all collections).
/// </summary>
/// <param name="o">The object to compare.</param>
/// <returns><c>true</c> if the object is equivalent; <c>false</c> otherwise.</returns>
//int hash = 0;
//for (ISeq s = seq(); s != null; s = s.next())
//{
//    object e = s.first();
//    hash += Util.hasheq(e);
//}
//_hasheq = hash;
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\APersistentVector.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Provides a basic implementation of <see cref="IPersistentVector">IPersistentVector</see> functionality.
/// </summary>
/// <summary>
///  Caches the hash code, once computed.
/// </summary>
/// <summary>
/// Caches the hashseq code, when computed.
/// </summary>
/// <remarks>The default value indicates that the hasheq code has not been computed yet.</remarks>
/// <summary>
/// Returns a string representing the object.
/// </summary>
/// <returns>A string representing the object.</returns>
/// <summary>
/// Determines whether the specified Object is equal to the current Object.
/// </summary>
/// <param name="obj">The Object to compare with the current Object.</param>
/// <returns><value>true</value> if the specified Object is equal to the current Object; 
/// otherwise, <value>false</value>.
/// </returns>
/// <summary>
/// Compares an <see cref="IPersistentVector">IPersistentVector</see> to another object for equality.
/// </summary>
/// <param name="v">The <see cref="IPersistentVector">IPersistentVector</see> to compare.</param>
/// <param name="obj">The other object to compare.</param>
/// <returns><value>true</value> if the specified Object is equal to the current Object; 
/// otherwise, <value>false</value>.
/// </returns>
// THis test in the JVM code can't be right:  || ma.GetHashCode() != v.GetHashCode())
/// <summary>
/// Compute a hash code for the current object.
/// </summary>
/// <returns>A hash code for the current object.</returns>
/// <summary>
/// Gets an ISeq to allow first/rest iteration through the collection.
/// </summary>
/// <returns>An ISeq for iteration.</returns>
/// <summary>
/// Returns a new collection that has the given element cons'd on front of the eixsting collection.
/// </summary>
/// <param name="o">An item to put at the front of the collection.</param>
/// <returns>A new immutable collection with the item added.</returns>
/// <summary>
/// Determine if an object is equivalent to this (handles all collections).
/// </summary>
/// <param name="o">The object to compare.</param>
/// <returns><c>true</c> if the object is equivalent; <c>false</c> otherwise.</returns>
// THis test in the JVM code can't be right:  || ma.GetHashCode() != v.GetHashCode())
/// <summary>
/// Gets an <see cref="ISeq">ISeq</see> to travers the sequence in reverse.
/// </summary>
/// <returns>An <see cref="ISeq">ISeq</see> .</returns>
/// <summary>
/// Gets the number of items in the vector.
/// </summary>
/// <returns>The number of items.</returns>
/// <summary>
/// Test if the map contains a key.
/// </summary>
/// <param name="key">The key to test for membership</param>
/// <returns>True if the key is in this map.</returns>
/// <summary>
/// Returns the key/value pair for this key.
/// </summary>
/// <param name="key">The key to retrieve</param>
/// <returns>The key/value pair for the key, or null if the key is not in the map.</returns>
/// <summary>
/// Add a new key/value pair.
/// </summary>
/// <param name="key">The key</param>
/// <param name="val">The value</param>
/// <returns>A new map with the key/value added.</returns>
/// <summary>
/// Gets the value associated with a key.
/// </summary>
/// <param name="key">The key to look up.</param>
/// <returns>The associated value. (Throws an exception if key is not present.)</returns>
/// <summary>
/// Gets the value associated with a key.
/// </summary>
/// <param name="key">The key to look up.</param>
/// <param name="notFound">The value to return if the key is not present.</param>
/// <returns>The associated value (or <c>notFound</c> if the key is not present.</returns>
/// <summary>
/// Peek at the top (first) element in the stack.
/// </summary>
/// <returns>The top (first) element.</returns>
/// <summary>
/// Internal class providing <see cref="ISeq">ISeq</see> functionality for <see cref="APersistentVector">APersistentVector</see>.
/// </summary>
/// <remarks>This class should be private.  Public only for DLR debugging output.</remarks>
// Counted left out of Java version
// TODO: something more efficient  (todo = from Java)
/// <summary>
/// The <see cref="IPersistentVector">IPersistentVector</see> this sequence is iterating over.
/// </summary>
/// <summary>
/// The current index into the vector.
/// </summary>
/// <summary>
/// Initialize a sequence over a vector with the first element at a given index.
/// </summary>
/// <param name="v">The vector to sequence over.</param>
/// <param name="i">The index to start at.</param>
/// <summary>
/// Initialize a sequence over a vector with the first element at a given index, with the given metadata.
/// </summary>
/// <param name="meta">The metadata to attach.</param>
/// <param name="v">The vector to sequence over.</param>
/// <param name="i">The index to start at.</param>
/// <summary>
/// Gets the first item.
/// </summary>
/// <returns>The first item.</returns>
/// <summary>
/// Return a seq of the items after the first.  Calls <c>seq</c> on its argument.  If there are no more items, returns nil."
/// </summary>
/// <returns>A seq of the items after the first, or <c>nil</c> if there are no more items.</returns>
/// <summary>
/// Gets the index associated with this sequence.
/// </summary>
/// <returns>The index associated with this sequence.</returns>
/// <summary>
/// Gets the number of items in the collection.
/// </summary>
/// <returns>The number of items in the collection.</returns>
/// <summary>
/// Create a copy with new metadata.
/// </summary>
/// <param name="meta">The new metadata.</param>
/// <returns>A copy of the object with new metadata attached.</returns>
/// <summary>
/// Reduce the collection using a function.
/// </summary>
/// <param name="f">The function to apply.</param>
/// <returns>The reduced value</returns>
/// <summary>
/// Reduce the collection using a function.
/// </summary>
/// <param name="f">The function to apply.</param>
/// <param name="start">An initial value to get started.</param>
/// <returns>The reduced value</returns>
// nested class Seq
/// <summary>
/// Internal class providing reverse <see cref="ISeq">ISeq</see> functionality for <see cref="APersistentVector">APersistentVector</see>.
/// </summary>
/// <remarks>This class should be private.  Public only for DLR debugging output.</remarks>
// IReduce left out of Java version
/// <summary>
/// The <see cref="IPersistentVector">IPersistentVector</see> this sequence is iterating over.
/// </summary>
/// <summary>
/// The current index into the vector.
/// </summary>    
/// <summary>
/// Initialize a reverse sequence over a vector with the first element at a given index.
/// </summary>
/// <param name="v">The vector to sequence over.</param>
/// <param name="i">The index to start at.</param>
/// <summary>
/// Initialize a reverse sequence over a vector with the first element at a given index, with the given metadata.
/// </summary>
/// <param name="meta">The metadata to attach.</param>
/// <param name="v">The vector to sequence over.</param>
/// <param name="i">The index to start at.</param>
/// <summary>
/// Gets the first item.
/// </summary>
/// <returns>The first item.</returns>
/// <summary>
/// Return a seq of the items after the first.  Calls <c>seq</c> on its argument.  If there are no more items, returns nil."
/// </summary>
/// <returns>A seq of the items after the first, or <c>nil</c> if there are no more items.</returns>
/// <summary>
/// Gets the index associated with this sequence.
/// </summary>
/// <returns>The index associated with this sequence.</returns>
/// <summary>
/// Gets the number of items in the collection.
/// </summary>
/// <returns>The number of items in the collection.</returns>
/// <summary>
/// Create a copy with new metadata.
/// </summary>
/// <param name="meta">The new metadata.</param>
/// <returns>A copy of the object with new metadata attached.</returns>
// Not in Java original
/// <summary>
/// Reduce the collection using a function.
/// </summary>
/// <param name="f">The function to apply.</param>
/// <returns>The reduced value</returns>
/// <summary>
/// Reduce the collection using a function.
/// </summary>
/// <param name="f">The function to apply.</param>
/// <param name="start">An initial value to get started.</param>
/// <returns>The reduced value</returns>
// nested class RSeq
/// <summary>
/// Internal class providing subvector functionality for <see cref="APersistentVector">APersistentVector</see>.
/// </summary>
/// <summary>
/// The vector being subvectored.
/// </summary>
/// <summary>
/// The vector being subvectored.
/// </summary>
/// <summary>
/// The start index of the subvector.
/// </summary>
/// <summary>
/// The start index of the subvector.
/// </summary>
/// public int Start { get { return _start; } }
/// <summary>
/// The end index of the subvector.
/// </summary>
/// <summary>
/// The end index of the subvector.
/// </summary>
/// <summary>
/// Initialize a subvector, with the given metadata and start/end indices.
/// </summary>
/// <param name="meta">The metatdata to attach.</param>
/// <param name="v">The vector to subvector.</param>
/// <param name="start">The start index of the subvector.</param>
/// <param name="end">The end index of the subvector.</param>
/// <summary>
/// Create a copy with new metadata.
/// </summary>
/// <param name="meta">The new metadata.</param>
/// <returns>A copy of the object with new metadata attached.</returns>
/// <summary>
/// Gets the number of items in the collection.
/// </summary>
/// <returns>The number of items in the collection.</returns>
/// <summary>
/// Gets an empty collection of the same type.
/// </summary>
/// <returns>An emtpy collection.</returns>
/// <summary>
/// Returns a new collection that has the given element cons'd on front of the eixsting collection.
/// </summary>
/// <param name="o">An item to put at the front of the collection.</param>
/// <returns>A new immutable collection with the item added.</returns>
/// <summary>
/// Gets the number of items in the vector.
/// </summary>
/// <returns>The number of items.</returns>
/// <remarks>Not sure why you wouldn't use <c>count()</c> intead.</remarks>
/// <summary>
/// Get the i-th item in the vector.
/// </summary>
/// <param name="i">The index of the item to retrieve/</param>
/// <returns>The i-th item</returns>
/// <remarks>Throws an exception if the index <c>i</c> is not in the range of the vector's elements.</remarks>
/// <summary>
/// Return a new vector with the i-th value set to <c>val</c>.
/// </summary>
/// <param name="i">The index of the item to set.</param>
/// <param name="val">The new value</param>
/// <returns>A new (immutable) vector v with v[i] == val.</returns>
/// <summary>
/// Creates a new vector with a new item at the end.
/// </summary>
/// <param name="o">The item to add to the vector.</param>
/// <returns>A new (immutable) vector with the objected added at the end.</returns>
/// <summary>
/// Returns a new stack with the top element popped.
/// </summary>
/// <returns>The new stack</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\ARef.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Provides basic implementation for the <see cref="IRef">IRef</see> interface methods.
/// </summary>
/// <summary>
/// The validator for the reference.
/// </summary>
/// <summary>
/// The set of watchers for the reference.
/// </summary>
/// <summary>
/// Initializes an <see cref="ARef">ARef</see> with null metadata.
/// </summary>
/// <summary>
///  Initializes an <see cref="ARef">ARef</see> with the given metadata.
/// </summary>
/// <param name="meta">The metadata to use</param>
/// <summary>
/// Gets the (immutable) value the reference is holding.
/// </summary>
/// <returns>The value</returns>
/// <summary>
/// Invoke an <see cref="IFn">IFn</see> on a value to validate it.
/// </summary>
/// <param name="vf">The <see cref="IFn">IFn</see> to invoke.</param>
/// <param name="val">The value to validate.</param>
/// <remarks>Uneventful return marks a successful validation.  
/// To indicate a failed validation, the validation function should return <value>false</value> or throw an exception.
/// <para>This appears in multiple places.  Should find it a common home?</para></remarks>
/// <summary>
/// Call the reference's validator on the given value.
/// </summary>
/// <param name="val">The value to validate</param>
/// <summary>
/// Sets the validator.
/// </summary>
/// <param name="vf">The new validtor</param>
/// <remarks>The current value must validate in order for this validator to be accepted.  If not, an exception will be thrown.</remarks>
/// <summary>
/// Gets the validator.
/// </summary>
/// <returns>The current validator.</returns>
/// <summary>
/// Gets a map of watchers (key=Agent, value=IFn).
/// </summary>
/// <returns>An immutable map of watchers (key=Agent, value=IFn). </returns>
/// <summary>
/// Adds a new watcher.
/// </summary>
/// <param name="watcher">The <see cref="Agent">Agent</see> doing the watching.</param>
/// <param name="callback">The 'message' to send when the value changes.</param>
/// <returns></returns>
/// <summary>
/// Remove a watcher.
/// </summary>
/// <param name="watcher">The <see cref="Agent">Agent</see> to be removed.</param>
/// <returns>This IRef (for chaining).</returns>
/// <summary>
/// Notify all watchers.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\AReference.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Provides a basic implementation of IReference functionality.
/// </summary>
/// <remarks>The JVM implementation does not make this abstract, but I see no reason to every create one of these standalone.</remarks>
/// <summary>
/// The metatdata for the object.
/// </summary>
/// <summary>
/// Initializes a new instance of <see cref="AReference">AReference</see> that has null metadata.
/// </summary>
/// <summary>
/// Initializes a new instance of <see cref="AReference">AReference</see> that has 
/// the given <see cref="IPersistentMap">IPersistentMap</see> as its metadata.
/// </summary>
/// <param name="meta">The map used to initialize the metadata.</param>
/// <summary>
/// Alter the metadata on the object.
/// </summary>
/// <param name="alter">A function to apply to generate the new metadata</param>
/// <param name="args">Arguments to apply the function to.</param>
/// <returns>The new metadata map.</returns>
/// <remarks>The new value will be the result of <c>(apply alter (cons currentMeta args))</c>.</remarks>
/// <summary>
/// Set the metadata of the object.
/// </summary>
/// <param name="m">The new metadata map</param>
/// <returns>The new metadata map.</returns>
/// <summary>
/// Gets the metadata attached to the object.
/// </summary>
/// <returns>An immutable map representing the object's metadata.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\ArityException.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\ArrayChunk.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\ArrayHelper.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Adds methods that exist in Java Array class, for compatibility with core.clj.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\ArraySeq.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// Not in the Java version, but I can really use this
//protected readonly Type _ct;
//_ct = typeof(T);
// TODO: first/reduce do a Numbers.num(x) conversion  -- do we need that?
//return Reflector.prepRet(_ct,_array[_i]);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\ASeq.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Provides basic implementation of <see cref="ISeq"/> functionality.
/// </summary>
/// <summary>
/// Holds the hash code.
/// </summary>
/// <summary>
/// Caches the hashseq code, when computed.
/// </summary>
/// <remarks>The value <value>0</value> indicates that the hasheq code has not been computed yet.</remarks>        
/// <summary>
/// Initializes an <see cref="ASeq">ASeq</see> with given metadata.
/// </summary>
/// <param name="meta"></param>
/// <summary>
/// Initializes an <see cref="ASeq">ASeq</see> with null metadata.
/// </summary>
/// <summary>
/// Returns a String that represents the current object.
/// </summary>
/// <returns>A String that represents the current object.</returns>
/// <summary>
/// Determines whether the specified Object is equal to the current object.
/// </summary>
/// <param name="obj">The Object to compare to the current object.</param>
/// <returns><c>true</c> if the specified Object is equal to the current object; otherwise <c>false</c></returns>
/// <remarks>Equality is value-based, ie.e. depends on the sequence of items.</remarks>
// hit end of sequence on both sequences
/// <summary>
/// Computes a hash code for the current object.
/// </summary>
/// <returns>A hash code for the current object.</returns>
/// <remarks>The hash code is cached after it is computed the first time.  The hash code depends on the value (sequenc of items).</remarks>
/// <summary>
/// Gets the first item.
/// </summary>
/// <returns>The first item.</returns>
///// <summary>
///// Gets the rest of the sequence.
///// </summary>
///// <returns>The rest of the sequence, or <c>null</c> if no more elements.</returns>
//public abstract ISeq rest();
/// <summary>
/// Return a seq of the items after the first.  Calls <c>seq</c> on its argument.  If there are no more items, returns nil."
/// </summary>
/// <returns>A seq of the items after the first, or <c>nil</c> if there are no more items.</returns>
/// <summary>
/// Adds an item to the beginning of the sequence.
/// </summary>
/// <param name="o">The item to add.</param>
/// <returns>A new sequence containing the new item in front of the items already in the sequence.</returns>
/// <remarks>This overrides the <c>cons</c> method in <see cref="IPersistentCollection">IPersistentCollection</see>
/// by giving an <see cref="ISeq">ISeq</see> in return.</remarks>
/// <summary>
/// Adds an item to the beginning of the sequence.
/// </summary>
/// <param name="o">The item to add.</param>
/// <returns>A new sequence containing the new item in front of the items already in the sequence.</returns>
/// <remarks>This overrides the <c>cons</c> method in <see cref="IPersistentCollection">IPersistentCollection</see>
/// by giving an <see cref="ISeq">ISeq</see> in return.</remarks>
/// <remarks>Explicit implementation defers to the implicit implementation for <see cref="ISeq">ISeq</see>.</remarks>
/// <summary>
/// Gets the number of items in the collection.
/// </summary>
/// <returns>The number of items in the collection.</returns>
/// <remarks>This implementation is has time linear in the number of items.  
/// Derived classes will want to override to cache this value.  
/// (Easy because the collections are immutable.)</remarks>
// if it is here, it is non-empty.
/// <summary>
/// Gets an ISeq to allow first/rest iteration through the collection.
/// </summary>
/// <returns>This item itself.</returns>
/// <summary>
/// Gets an empty collection of the same type.
/// </summary>
/// <returns>An emtpy collection.</returns>
/// <remarks>An empty sequence must be null.</remarks>
/// <summary>
/// Determine if an object is equivalent to this (handles all collections).
/// </summary>
/// <param name="o">The object to compare.</param>
/// <returns><c>true</c> if the object is equivalent; <c>false</c> otherwise.</returns>
// hit end of sequence on both sequences
//Java has this: return RT.nth(this, index);
// THis causes an infinite loop in my code.  
// When this was introduces, a change was made in RT.nth that changed the List test in its type dispatch to RandomAccess.
// CLR does not have the equivalent notion, so I just left it at IList.  BOOM!
// So, I have to do a sequential search, duplicating some of the code in RT.nth.
/// <summary>
/// Copies the elements of the sequence to an Array, starting at a particular index.
/// </summary>
/// <param name="array">The Array that is the destination of the copy.</param>
/// <param name="index">The zero-based index in <paramref name="array"/>array</param> at which copying begins.
/// <summary>
/// Gets the number of elements in the sequence.
/// </summary>
/// <summary>
/// Gets a value indicating whether access to the collection is thread-safe.
/// </summary>
/// <summary>
/// Returns an enumerator that iterates through a collection.
/// </summary>
/// <returns>A <see cref="SeqEnumerator">SeqEnumerator</see> that iterates through the sequence.</returns>
//int hash = 1;
//for (ISeq s = seq(); s != null; s = s.next())
//    hash = 31 * hash + Util.hasheq(s.first());
//_hasheq = hash;
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Associative.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents an immutable key/value mapping.
/// </summary>
/// <summary>
/// Test if the map contains a key.
/// </summary>
/// <param name="key">The key to test for membership</param>
/// <returns>True if the key is in this map.</returns>
/// <summary>
/// Returns the key/value pair for this key.
/// </summary>
/// <param name="key">The key to retrieve</param>
/// <returns>The key/value pair for the key, or null if the key is not in the map.</returns>
/// <summary>
/// Add a new key/value pair.
/// </summary>
/// <param name="key">The key</param>
/// <param name="val">The value</param>
/// <returns>A new map with the key/value added.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Atom.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Provides spin-loop synchronized access to a value.  One of the reference types.
/// </summary>
/// <summary>
/// The atom's value.
/// </summary>
/// <summary>
/// Construct an atom with given intiial value.
/// </summary>
/// <param name="state">The initial value</param>
/// <summary>
/// Construct an atom with given initial value and metadata.
/// </summary>
/// <param name="state">The initial value.</param>
/// <param name="meta">The metadata to attach.</param>
/// <summary>
/// Gets the (immutable) value the reference is holding.
/// </summary>
/// <returns>The value</returns>
/// <summary>
/// Compute and set a new value.  Spin loop for coordination.
/// </summary>
/// <param name="f">The function to apply to the current state.</param>
/// <returns>The new value.</returns>
/// <summary>
/// Compute and set a new value.  Spin loop for coordination.
/// </summary>
/// <param name="f">The function to apply to current state and one additional argument.</param>
/// <param name="arg">Additional argument.</param>
/// <returns>The new value.</returns>
/// <summary>
/// Compute and set a new value.  Spin loop for coordination.
/// </summary>
/// <param name="f">The function to apply to current state and additional arguments.</param>
/// <param name="arg1">First additional argument.</param>
/// <param name="arg2">Second additional argument.</param>
/// <returns>The new value.</returns>
/// <summary>
/// Compute and set a new value.  Spin loop for coordination.
/// </summary>
/// <param name="f">The function to apply to current state and additional arguments.</param>
/// <param name="x">First additional argument.</param>
/// <param name="y">Second additional argument.</param>
/// <param name="args">Sequence of additional arguments.</param>
/// <returns>The new value.</returns>
/// <summary>
/// Compare/exchange the value.
/// </summary>
/// <param name="oldv">The expected value.</param>
/// <param name="newv">The new value.</param>
/// <returns><value>true</value> if the value was set; <value>false</value> otherwise.</returns>
/// <summary>
/// Set the value.
/// </summary>
/// <param name="newval">The new value.</param>
/// <returns>The new value.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\AtomicBoolean.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Implements the Java <c>java.util.concurrent.atomic.AtomicBoolean</c> class.  
/// </summary>
/// <remarks>I hope.  Someone with more knowledge of these things should check this out.
/// <para>So I could cheat and use Interlocked, I just used an int and make it 0 === false.</para></remarks>
/// <summary>
/// The current <see cref="Boolean">boolean</see> value.
/// </summary>
/// <summary>
/// Initializes an <see cref="AtomicBoolean"/> with value false.
/// </summary>
/// <summary>
/// Initializes an <see cref="AtomicBoolean"/> with a given value.
/// </summary>
/// <param name="initVal">The initial value.</param>
/// <summary>
/// Gets the current value.
/// </summary>
/// <returns>The current value.</returns>
/// <summary>
/// Sets the value if the expected value is current.
/// </summary>
/// <param name="oldVal">The expected value.</param>
/// <param name="newVal">The new value.</param>
/// <returns><value>true</value> if the value was set; <value>false</value> otherwise.</returns>
/// <summary>
/// Sets the value.
/// </summary>
/// <param name="newVal">The new value.</param>
/// <returns>The new value.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\AtomicInteger.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Implements the Java <c>java.util.concurrent.atomic.AtomicInteger</c> class.  
/// </summary>
/// <remarks>I hope.  Someone with more knowledge of these things should check this out.</remarks>
/// <summary>
/// The current <see cref="Int32">integer</see> value.
/// </summary>
/// <summary>
/// Initializes an <see cref="AtomicInteger">AtomicInteger</see> with value zero.
/// </summary>
/// <summary>
/// Initializes an <see cref="AtomicInteger">AtomicInteger</see> with a given value.
/// </summary>
/// <param name="initVal">The initial value.</param>
/// <summary>
/// Gets the current value.
/// </summary>
/// <returns>The current value.</returns>
/// <summary>
/// Increments the value and returns the new value.
/// </summary>
/// <returns>The new value.</returns>
/// <summary>
/// Increments the value and returns the original value.
/// </summary>
/// <returns>The original value.</returns>
/// <summary>
/// Decrements the value and returns the new value.
/// </summary>
/// <returns>The new value.</returns>
/// <summary>
/// Decrements the value and returns the original value.
/// </summary>
/// <returns>The original value.</returns>
/// <summary>
/// Sets the value if the expected value is current.
/// </summary>
/// <param name="oldVal">The expected value.</param>
/// <param name="newVal">The new value.</param>
/// <returns><value>true</value> if the value was set; <value>false</value> otherwise.</returns>
/// <summary>
/// Sets the value.
/// </summary>
/// <param name="newVal">The new value.</param>
/// <returns>The new value.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\AtomicLong.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Implements the Java <c>java.util.concurrent.atomic.AtomicLong</c> class.  
/// </summary>
/// <remarks>I hope.  Someone with more knowledge of these things should check this out.</remarks>
/// <summary>
/// The current <see cref="Int32">integer</see> value.
/// </summary>
/// <summary>
/// Initializes an <see cref="AtomicLong">AtomicLong</see> with value zero.
/// </summary>
/// <summary>
/// Initializes an <see cref="AtomicLong">AtomicLong</see> with a given value.
/// </summary>
/// <param name="initVal">The initial value.</param>
/// <summary>
/// Gets the current value.
/// </summary>
/// <returns>The current value.</returns>
/// <summary>
/// Increments the value and returns the new value.
/// </summary>
/// <returns>The new value.</returns>
/// <summary>
/// Increments the value and returns the original value.
/// </summary>
/// <returns>The original value.</returns>
/// <summary>
/// Sets the value if the expected value is current.
/// </summary>
/// <param name="oldVal">The expected value.</param>
/// <param name="newVal">The new value.</param>
/// <returns><value>true</value> if the value was set; <value>false</value> otherwise.</returns>
/// <summary>
/// Sets the value.
/// </summary>
/// <param name="newVal">The new value.</param>
/// <returns>The new value.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\AtomicReference.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Implements the Java java.util.concurrent.atomic.AtomicReference&lt;V&gt; class
/// </summary>
/// <remarks>I hope.  Someone with more knowledge of these things should check this out.
/// <para>Not implemented: weakCompareAndSet</para></remarks>
/// <summary>
/// The current value.
/// </summary>
/// <summary>
/// Intializes an <see cref="AtomicReference">AtomicReference</see> to null.
/// </summary>
/// <summary>
/// Intializes an <see cref="AtomicReference">AtomicReference</see> to hold a given reference.
/// </summary>
/// <param name="initVal">The initial value.</param>
/// <summary>
/// Sets the reference if the expected reference is current.
/// </summary>
/// <param name="expect">The expected value.</param>
/// <param name="update">The new value.</param>
/// <returns><value>true</value> if the value is changed; <value>false</value> otherwise.</returns>
/// <remarks>The Java version returns a boolean.  The BCL version returns the old value.  
/// We use ReferenceEquals for the change comparison because that is what CompareExchange&lt;T&gt; uses.</remarks>
/// <summary>
/// Get the current value.
/// </summary>
/// <returns>The current value.</returns>
/// <summary>
/// Sets a new value and returns the original value.
/// </summary>
/// <param name="update">The new value.</param>
/// <returns>The original value.</returns>
/// <summary>
/// Sets the value.
/// </summary>
/// <param name="update">The new value.</param>
/// <summary>
/// Returns string representing the value.
/// </summary>
/// <returns>A string representing the value.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\ATransientMap.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: also handle KeyValuePair?
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\ATransientSet.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\BigDecimal.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Immutable, arbitrary precision, signed decimal.
/// </summary>
/// <remarks>
/// <para>This class is inspired by the General Decimal Arithmetic Specification (http://speleotrove.com/decimal/decarith.html, 
/// (PDF: http://speleotrove.com/decimal/decarith.pdf).  However, at the moment, the interface and capabilities comes closer
/// to java.math.BigDecimal, primarily because I only needed to mimic j.m.BigDecimal's capabilities to provide a minimum set
/// of functionality for ClojureCLR.</para>
/// <para>Because of this, as in j.m.BigDecimal, the implementation is closest to the X3.274 subset described in Appendix A
/// of the GDAS: infinite values, NaNs, subnormal values and negative zero are not represented, and most conditions throw exceptions. 
/// Exponent limits in the context are not implemented, except a limit to the range of an Int32. 
/// However, we do not do "conversion to shorter" for arith ops.</para>
/// <para>It is our long term intention to convert this to a complete implementation of the standard.</para>
/// <para>The representation is an arbitrary precision integer (the signed coefficient, also called the unscaled value) 
/// and an exponent.  The exponent is limited to the range of an Int32. 
/// The value of a BigDecimal representation is <c>coefficient * 10^exponent</c>. </para>
/// <para> Note: the representation in the GDAS is
/// [sign,coefficient,exponent] with sign = 0/1 for (pos/neg) and an unsigned coefficient. 
/// This yields signed zero, which we do not have.  
/// We used a BigInteger for the signed coefficient.  
/// That class does not have a representation for signed zero.</para>
/// <para>Note: Compared to j.m.BigDecimal, our coefficient = their <c>unscaledValue</c> 
/// and our exponent is the negation of their <c>scale</c>.</para>
/// <para>The representation also track the number of significant digits.  This is usually the number of digits in the coefficient,
/// except when the coeffiecient is zero.  This value is computed lazily and cached.</para>
/// <para>This is not a clean-room implementation.  
/// I examined at other code, especially OpenJDK implementation of java.math.BigDecimal, 
/// to look for special cases and other gotchas.  Then I looked away.  
/// I have tried to give credit in the few places where I pretty much did unthinking translation.  
/// However, there are only so many ways to skim certain cats, so some similarities are unavoidable.</para>
/// </remarks>
/// <summary>
/// Indicates the rounding algorithm to use.
/// </summary>
/// <remarks>I have not implemented the round-05up algorithm mentioned in GDAS.</remarks>
/// <summary>
/// Round away from 0.
/// </summary>
/// <summary>
/// Truncate (round toward 0). 
/// </summary>
/// <summary>
/// Round toward positive infinity.
/// </summary>
/// <summary>
/// Round toward negative infinity.
/// </summary>
/// <summary>
/// Round to nearest neighbor, round up if equidistant.
/// </summary>
/// <summary>
/// Round to nearest neighbor, round down if equidistant.
/// </summary>
/// <summary>
/// Round to nearest neighbor, round to even neighbor if equidistant.
/// </summary>
/// <summary>
/// Do not do any rounding.
/// </summary>
/// <remarks>This value is not part of the GDAS, but is in java.math.BigDecimal.</remarks>
/// <summary>
/// The number of digits to be used.  (0 = unlimited)
/// </summary>
/// <summary>
/// The number of digits to be used.  (0 = unlimited)
/// </summary>
/// <summary>
///  The rounding algorithm to be used.
/// </summary>
/// <summary>
///  The rounding algorithm to be used.
/// </summary>
// Same as Java
// TODO: Really
/// <summary>
/// The coeffienct of this BigDecimal.
/// </summary>
/// <summary>
/// The coeffienct of this BigDecimal.
/// </summary>
/// <summary>
///  The exponent of this BigDecimal.
/// </summary>
/// <summary>
///  The exponent of this BigDecimal.
/// </summary>
/// <summary>
/// Get the precision (number of decimal digits) of this BigDecimal.
/// </summary>
/// <remarks>The value 0 indicated that the number is not known.</remarks>
/// <summary>
/// Get the (number of decimal digits) of this BigDecimal.  Will trigger computation if not already known.
/// </summary>
/// <returns>The precision.</returns>
/// <summary>
/// A BigDecimal representation of zero with precision 1.
/// </summary>
/// <summary>
/// A BigDecimal representation of one.
/// </summary>
/// <summary>
/// A BigDecimal representation of ten.
/// </summary>
// I went with factory methods rather than constructors so that I could, if I wanted,
// return cached values for things such as zero, one, etc.
/// <summary>
/// Create a BigDecimal from a double.
/// </summary>
/// <param name="v">The double value</param>
/// <returns>A BigDecimal corresponding to the double value.</returns>
/// <remarks>Watch out!  BigDecimal.Create(0.1) is not the same as BigDecimal.Parse("0.1").  
/// We create exact representations of doubles,
/// and 1/10 does not have an exact representation as a double.  So the double 1.0 is not exactly 1/10.</remarks>
// TODO: avoid extra allocation
// at this point v = coeff * 2 ** exp
// need to convert to appropriate exponent of 10.
/// <summary>
/// Create a BigDecimal from a double, rounded as specified.
/// </summary>
/// <param name="v">The double value</param>
/// <param name="c">The rounding context</param>
/// <returns>A BigDecimal corresponding to the double value, rounded as specified.</returns>
/// <remarks>Watch out!  BigDecimal.Create(0.1) is not the same as BigDecimal.Parse("0.1").  
/// We create exact representations of doubles,
/// and 1/10 does not have an exact representation as a double.  So the double 1.0 is not exactly 1/10.</remarks>
/// <summary>
/// Create a BigDecimal with the same value as the given Int32.
/// </summary>
/// <param name="v">The initial value</param>
/// <returns>A BigDecimal with the same value.</returns>
/// <summary>
/// Create a BigDecimal with the same value as the given Int32, rounded appropriately.
/// </summary>
/// <param name="v">The initial value</param>
/// <param name="c">The rounding context</param>
/// <returns>A BigDecimal with the same value, appropriately rounded</returns>
/// <summary>
/// Create a BigDecimal with the same value as the given Int64.
/// </summary>
/// <param name="v">The initial value</param>
/// <returns>A BigDecimal with the same value.</returns>
/// <summary>
/// Create a BigDecimal with the same value as the given Int64, rounded appropriately.
/// </summary>
/// <param name="v">The initial value</param>
/// <param name="c">The rounding context</param>
/// <returns>A BigDecimal with the same value, appropriately rounded</returns>
/// <summary>
/// Create a BigDecimal with the same value as the given UInt64.
/// </summary>
/// <param name="v">The initial value</param>
/// <returns>A BigDecimal with the same value.</returns>
/// <summary>
/// Create a BigDecimal with the same value as the given UInt64, rounded appropriately.
/// </summary>
/// <param name="v">The initial value</param>
/// <param name="c">The rounding context</param>
/// <returns>A BigDecimal with the same value, appropriately rounded</returns>
/// <summary>
/// Create a BigDecimal with the same value as the given Decimal.
/// </summary>
/// <param name="v">The initial value</param>
/// <returns>A BigDecimal with the same value.</returns>
/// <summary>
/// Create a BigDecimal with the same value as the given UInt64, rounded appropriately.
/// </summary>
/// <param name="v">The initial value</param>
/// <param name="c">The rounding context</param>
/// <returns>A BigDecimal with the same value, appropriately rounded</returns>
/// <summary>
/// Create a BigDecimal with the same value as the given BigInteger.
/// </summary>
/// <param name="v">The initial value</param>
/// <returns>A BigDecimal with the same value.</returns>
/// <summary>
/// Create a BigDecimal with the same value as the given BigInteger, rounded appropriately.
/// </summary>
/// <param name="v">The initial value</param>
/// <param name="c">The rounding context</param>
/// <returns>A BigDecimal with the same value, appropriately rounded</returns>
/// <summary>
/// Create a BigDecimal by parsing a string.
/// </summary>
/// <param name="v"></param>
/// <returns></returns>
/// <summary>
/// Create a BigDecimal by parsing a string.
/// </summary>
/// <param name="v"></param>
/// <returns></returns>        
/// <summary>
/// Create a BigDecimal by parsing a character array.
/// </summary>
/// <param name="v"></param>
/// <returns></returns>
/// <summary>
/// Create a BigDecimal by parsing a character array.
/// </summary>
/// <param name="v"></param>
/// <returns></returns>
/// <summary>
/// Create a BigDecimal by parsing a segment of character array.
/// </summary>
/// <param name="v"></param>
/// <returns></returns>
/// <summary>
/// Create a BigDecimal by parsing a segment of character array.
/// </summary>
/// <param name="v"></param>
/// <returns></returns>
/// <summary>
/// Creates a copy of given BigDecimal.
/// </summary>
/// <param name="copy">A copy of the given BigDecimal</param>
/// <remarks>Really only needed internally.  BigDecimals are immutable, so why copy?  
/// Internally, we sometimes need to copy and modify before releasing into the wild.</remarks>
/// <summary>
/// Create a BigDecimal with given coefficient, exponent, and precision.
/// </summary>
/// <param name="coeff">The coefficient</param>
/// <param name="exp">The exponent</param>
/// <param name="precision">The precision</param>
/// <remarks>For internal use only.  We can't trust someone outside to set the precision for us.
/// Only for use when we know the precision explicitly.</remarks>
/// <summary>
/// Create a BigDecimal with given coefficient and exponent.
/// </summary>
/// <param name="coeff">The coefficient</param>
/// <param name="exp">The exponent</param>
/// <summary>
/// Create a BigDecimal from a string representation
/// </summary>
/// <param name="s"></param>
/// <returns></returns>
/// <summary>
/// Create a BigDecimal from a string representation, rounded as indicated.
/// </summary>
/// <param name="s"></param>
/// <param name="c"></param>
/// <returns></returns>
/// <summary>
/// Try to create a BigDecimal from a string representation.
/// </summary>
/// <param name="s">The string to convert</param>
/// <param name="v">Set to the BigDecimal corresponding to the string.</param>
/// <returns>True if successful, false if there is an error parsing.</returns>
/// <summary>
/// Try to create a BigDecimal from a string representation, rounded as indicated.
/// </summary>
/// <param name="s">The string to convert</param>
/// <param name="c">The rounding context</param>
/// <param name="v">Set to the BigDecimal corresponding to the string.</param>
/// <returns></returns>
/// <summary>
/// Create a BigDecimal from an array of characters.
/// </summary>
/// <param name="buf"></param>
/// <returns></returns>
/// <summary>
/// Create a BigDecimal from an array of characters, rounded as indicated.
/// </summary>
/// <param name="buf"></param>
/// <param name="c"></param>
/// <returns></returns>
/// <summary>
/// Try to create a BigDecimal from an array of characters.
/// </summary>
/// <param name="buf"></param>
/// <param name="v"></param>
/// <returns>True if successful; false otherwise</returns>      
/// <summary>
/// Try to create a BigDecimal from an array of characters, rounded as indicated.
/// </summary>
/// <param name="buf"></param>
/// <param name="c"></param>
/// <param name="v"></param>
/// <returns>True if successful; false otherwise</returns>      
/// <summary>
/// Create a BigDecimal corresponding to a sequence of characters from an array.
/// </summary>
/// <param name="buf"></param>
/// <param name="offset"></param>
/// <param name="len"></param>
/// <returns></returns>
/// <summary>
/// Create a BigDecimal corresponding to a sequence of characters from an array, rounded as indicated.
/// </summary>
/// <param name="buf"></param>
/// <param name="offset"></param>
/// <param name="len"></param>
/// <param name="c"></param>
/// <returns></returns>
/// <summary>
/// Try to create a BigDecimal corresponding to a sequence of characters from an array.
/// </summary>
/// <param name="buf"></param>
/// <param name="offset"></param>
/// <param name="len"></param>
/// <param name="v"></param>
/// <returns></returns>
/// <summary>
/// Try to create a BigDecimal corresponding to a sequence of characters from an array.
/// </summary>
/// <param name="buf"></param>
/// <param name="offset"></param>
/// <param name="len"></param>
/// <param name="c"></param>
/// <param name="v"></param>
/// <returns></returns>
/// <summary>
/// Parse a substring of a character array as a BigDecimal.
/// </summary>
/// <param name="buf">The character array to parse</param>
/// <param name="offset">Start index for parsing</param>
/// <param name="len">Number of chars to parse.</param>
/// <param name="throwOnError">If true, an error causes an exception to be thrown. If false, false is returned.</param>
/// <param name="v">The BigDecimal corresponding to the characters.</param>
/// <returns>True if successful, false if not (or throws if throwOnError is true).</returns>
/// <remarks> Ugly. We could use a RegEx, but trying to avoid unnecessary allocation, I guess.
/// [+-]?\d*(\.\d*)?([Ee][+-]?\d+)?  with additional constraint that one of the two d* must have at least one char.
///</remarks>
// Make sure we have some characters
// Make sure we're not going past the end of the array
// optional leading sign
// parse first set of digits
// parse the optional fraction
// Parse the optional exponent.
// Parse the optional sign;
// we should be at the end
// Remove leading zeros from precision count.
/// <summary>
/// Create the canonical string representation for a BigDecimal.
/// </summary>
/// <returns></returns>
// not using exponential notation
// We do need a decimal point.
// using exponential notation
/// <summary>
/// Return a string representing the BigDecimal value.
/// </summary>
/// <returns></returns>
//public string ToEngineeringString()
//{
//}
// do it the dumb way
// As j.m.BigDecimal puts it: "Somewhat inefficient, but guaranteed to work."
// However, JVM's double parser goes to +/- Infinity when out of range,
// while CLR's throws an exception.
// Hate dealing with that.
/// <summary>
/// Compute <paramref name="x"/> + <paramref name="y"/>.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The sum</returns>
/// <summary>
/// Compute <paramref name="x"/> - <paramref name="y"/>.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The difference</returns>
/// <summary>
/// Compute the negation of <paramref name="x"/>.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The negation</returns>
/// <summary>
/// Compute <paramref name="x"/> * <paramref name="y"/>.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The product</returns>
/// <summary>
/// Compute <paramref name="x"/> / <paramref name="y"/>.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The quotient</returns>
/// <summary>
/// Compute <paramref name="x"/> % <paramref name="y"/>.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The modulus</returns>
/// <summary>
/// Compute <paramref name="x"/> + <paramref name="y"/>.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The sum</returns>
/// <summary>
/// Compute <paramref name="x"/> + <paramref name="y"/> with the result rounded per the context.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The sum</returns>
/// <summary>
/// Compute <paramref name="x"/> - <paramref name="y"/>.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The difference</returns>
/// <summary>
/// Compute <paramref name="x"/> - <paramref name="y"/> with the result rounded per the context.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <param name="mc"></param>
/// <returns></returns>
/// <summary>
/// Compute the negation of <paramref name="x"/>.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The negation</returns>
/// <summary>
/// Compute the negation of <paramref name="x"/>, with result rounded according to the context
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The negation</returns>
/// <summary>
/// Compute <paramref name="x"/> * <paramref name="y"/>.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The product</returns>
/// <summary>
/// Compute <paramref name="x"/> * <paramref name="y"/>, with result rounded according to the context.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The product</returns>
/// <summary>
/// Compute <paramref name="x"/> / <paramref name="y"/>.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The quotient</returns>
/// <summary>
/// Compute <paramref name="x"/> / <paramref name="y"/>, with result rounded according to the context.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The quotient</returns>
/// <summary>
/// Returns <paramref name="x"/> % <paramref name="y"/>.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The modulus</returns>
/// <summary>
/// Returns <paramref name="x"/> % <paramref name="y"/>, with result rounded according to the context.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The modulus</returns>
/// <summary>
/// Compute the quotient and remainder of dividing one <see cref="BigInteger"/> by another.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <param name="remainder">Set to the remainder after division</param>
/// <returns>The quotient</returns>
/// <summary>
/// Compute the quotient and remainder of dividing one <see cref="BigInteger"/> by another, with result rounded according to the context.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <param name="remainder">Set to the remainder after division</param>
/// <returns>The quotient</returns>
/// <summary>
/// Compute the absolute value.
/// </summary>
/// <param name="x"></param>
/// <returns>The absolute value</returns>
/// <summary>
/// Compute the absolute value, with result rounded according to the context.
/// </summary>
/// <param name="x"></param>
/// <returns>The absolute value</returns>
/// <summary>
/// Returns a <see cref="BigInteger"/> raised to an int power.
/// </summary>
/// <param name="x">The value to exponentiate</param>
/// <param name="exp">The exponent</param>
/// <returns>The exponent</returns>
/// <summary>
/// Returns a <see cref="BigInteger"/> raised to an int power, with result rounded according to the context.
/// </summary>
/// <param name="x">The value to exponentiate</param>
/// <param name="exp">The exponent</param>
/// <returns>The exponent</returns>
/// <summary>
/// Returns this.
/// </summary>
/// <param name="x"></param>
/// <returns></returns>
/// <summary>
/// Returns the negation of this.
/// </summary>
/// <param name="x"></param>
/// <returns></returns>
/// <summary>
/// Returns this + y.
/// </summary>
/// <param name="y">The augend.</param>
/// <returns>The sum</returns>
/// <summary>
/// Returns this + y, with the result rounded according to the context.
/// </summary>
/// <param name="y">The augend.</param>
/// <returns>The sum</returns>
/// <remarks>Translated the Sun Java code pretty directly.</remarks>
// TODO: Optimize for one arg or the other being zero.
// TODO: Optimize for differences in exponent along with the desired precision is large enough that the add is irreleveant
/// <summary>
/// Change either x or y by a power of 10 in order to align them.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <summary>
/// Modify a larger BigDecimal to have the same exponent as a smaller one by multiplying the coefficient by a power of 10.
/// </summary>
/// <param name="big"></param>
/// <param name="small"></param>
/// <returns></returns>
/// <summary>
/// Returns this - y
/// </summary>
/// <param name="y">The subtrahend</param>
/// <returns>The difference</returns>
/// <summary>
/// Returns this - y
/// </summary>
/// <param name="y">The subtrahend</param>
/// <returns>The difference</returns>
// TODO: Optimize for one arg or the other being zero.
// TODO: Optimize for differences in exponent along with the desired precision is large enough that the add is irreleveant
/// <summary>
/// Returns the negation of this value.
/// </summary>
/// <returns>The negation</returns>
/// <summary>
/// Returns the negation of this value, with result rounded according to the context.
/// </summary>
/// <param name="mc"></param>
/// <returns></returns>
/// <summary>
/// Returns this * y
/// </summary>
/// <param name="y">The multiplicand</param>
/// <returns>The product</returns>
/// <summary>
/// Returns this * y
/// </summary>
/// <param name="y">The multiplicand</param>
/// <returns>The product</returns>
/// <summary>
/// Returns this / y.
/// </summary>
/// <param name="y">The divisor</param>
/// <returns>The quotient</returns>
/// <exception cref="ArithmeticException">If rounding mode is RoundingMode.UNNECESSARY and we have a repeating fraction"</exception>
/// <remarks>I completely ripped off the OpenJDK implementation.  
/// Their analysis of the basic algorithm I could not compete with.</remarks>
// x/0
// 0/0
// NaN
// INF
// Calculate preferred exponent
// 0/y
/*  OpenJDK says:
// divide(BigDecimal, mc) tries to adjust the quotient to
// the desired one by removing trailing zeros; since the
// exact divide method does not have an explicit digit
// limit, we can add zeros too.
/// <summary>
/// Returns this / y.
/// </summary>
/// <param name="y">The divisor</param>
/// <param name="mc">The context</param>
/// <returns>The quotient</returns>
/// <remarks>
/// <para>The specification talks about the division algorithm in terms of repeated subtraction.
/// I'll try to re-analyze this in terms of divisions on integers.</para>
/// <para>Assume we want to divide one BigDecimal by another:</para>
/// <code> [x,a] / [y,b] = [(x/y), a-b]</code>
/// <para>where [x,a] signifies x is integer, a is exponent so [x,a] has value x * 10^a.
/// Here, (x/y) indicates a result rounded to the desired precision p. For the moment, assume x, y non-negative.</para>
/// <para>We want to compute (x/y) using integer-only arithmetic, yielding a quotient+remainder q+r
/// where q has up to p precision and r is used to compute the rounding.  So actually, the result will be [q, a-b+c],
/// where c is some adjustment factor to make q be in the range [0,10^0).</para>
/// <para>We will need to adjust either x or y to make sure we can compute x/y and make q be in this range.</para>
/// <para>Let px be the precision of x (number of digits), let py be the precision of y. Then </para>
/// <code>
/// x = x' * 10^px
/// y = y' * 10^py
/// </code>
/// <para>where x' and y' are in the range [.1,1).  However, we'd really like to have:</para>
/// <code>
/// (a) x' in [.1,1)
/// (b) y' in [x',10*x')
/// </code>
/// <para>So that  x'/y' is in the range (.1,1].  
/// We can use y' as defined above if y' meets (b), else multiply y' by 10 (and decrease py by 1). 
/// Having done this, we now have</para>
/// <code>
///  x/y = (x'/y') * 10^(px-py)
/// </code>
/// <para>
/// This gives us  10^(px-py-1) &lt; x/y &lt 10^(px-py).
/// We'd like q to have p digits of precision.  So,
/// <code>
/// if px-py = p, ok.
/// if px-py &lt; p, multiply x by 10^(p - (px-py)).
/// if px-py &gt; p, multiply y by 10^(px-py-p).
/// </code>
/// <para>Using these adjusted values of x and y, divide to get q and r, round using those, then adjust the exponent.</para>
/// </remarks>
// Deal with x or y being zero.
// x/0
// 0/0
// NaN
// Inf
// 0/y
// Determine if we need to make an adjustment to get x', y' into relation (b).
// Now make sure x and y themselves are in the proper range.
// Thanks to the OpenJDK implementation for pointing this out.
// TODO: Have ROundingDivide2 return a flag indicating if the remainder is 0.  Then we can lose the multiply.
// Apply preferred scale rules for exact quotients
// if (c.RoundingMode == RoundingMode.Ceiling ||
//     c.RoundingMode == RoundingMode.Floor)
// {
//     // OpenJDK code says:
//     // The floor (round toward negative infinity) and ceil
//     // (round toward positive infinity) rounding modes are not
//     // invariant under a sign flip.  If xprime/yprime has a
//     // different sign than lhs/rhs, the rounding mode must be
//     // changed.
//     if ((xprime._coeff.Signum != lhs._coeff.Signum) ^
//         (yprime._coeff.Signum != rhs._coeff.Signum))
//     {
//         c = new Context(c.Precision,
//                              (c.RoundingMode == RoundingMode.Ceiling) ?
//                              RoundingMode.Floor : RoundingMode.Ceiling);
//     }
// }
/// <summary>
/// Returns this % y
/// </summary>
/// <param name="y">The divisor</param>
/// <returns>The modulus</returns>
/// <summary>
/// Returns this % y
/// </summary>
/// <param name="y">The divisor</param>
/// <returns>The modulus</returns>
/// <summary>
/// Returns the quotient and remainder of this divided by another.
/// </summary>
/// <param name="y">The divisor</param>
/// <param name="remainder">The remainder</param>
/// <returns>The quotient</returns>
// x = q * y + r
/// <summary>
/// Returns the quotient and remainder of this divided by another.
/// </summary>
/// <param name="y">The divisor</param>
/// <param name="remainder">The remainder</param>
/// <returns>The quotient</returns>
// x = q * y + r
/// <summary>
/// 
/// </summary>
/// <param name="y"></param>
/// <param name="c"></param>
/// <returns></returns>
/// <remarks>I am indebted to the OpenJDK implementation for the algorithm.
/// <para>However, the spec I'm working from specifies an exponent of zero always!
/// The OpenJDK implementation does otherwise.  So I've modified it to yield a zero exponent.</para>
/// </remarks>
// exact result
// zero result
// Calculate preferred scale
//int preferredExp = (int)Math.Max(Math.Min((long)this._exp - y._exp,
//                                            Int32.MaxValue),Int32.MinValue);
/*  OpenJKD says:
/*
// If the quotient is the full integer value,
// |dividend-product| < |divisor|.
/*
// else resultExp == 0;
//int precisionDiff;
/*precisionDiff = */(int)(c.Precision - result.GetPrecision())) > 0)
//return Rescale(result, resultExp + Math.Max(precisionDiff, preferredExp - resultExp), RoundingMode.Unnecessary);
/// <summary>
/// Return the integer part of this / y.
/// </summary>
/// <param name="y"></param>
/// <returns></returns>
/// <remarks>I am indebted to the OpenJDK implementation for the algorithm.
/// <para>However, the spec I'm working from specifies an exponent of zero always!
/// The OpenJDK implementation does otherwise.  So I've modified it to yield a zero exponent.</para>
/// </remarks>
// Calculate preferred exponent
//int preferredExp = (int)Math.Max(Math.Min((long)this._exp - y._exp,
//                                            Int32.MaxValue), Int32.MinValue);
// Perform a divide with enough digits to round to a correct
// integer value; then remove any fractional digits
// pad with zeros if necessary
/// <summary>
/// Returns the absolute value of this instance.
/// </summary>
/// <returns>The absolute value</returns>
/// <summary>
/// Returns the absolute value of this instance.
/// </summary>
/// <returns>The absolute value</returns>
/// <summary>
/// Returns the value of this instance raised to an integral power.
/// </summary>
/// <param name="exp">The exponent</param>
/// <returns>The exponetiated value</returns>
/// <exception cref="System.ArgumentOutOfRangeException">Thrown if the exponent is negative.</exception>
/// <summary>
/// Returns the value of this instance raised to an integral power.
/// </summary>
/// <param name="exp">The exponent</param>
/// <returns>The exponetiated value</returns>
/// <exception cref="System.ArgumentOutOfRangeException">Thrown if the exponent is negative.</exception>
/// <remarks><para>Follows the OpenJKD implementation.  This is an implementation of the X3.274-1996 algorithm:</para>
/// <list>
///   <item> An ArithmeticException exception is thrown if
///     <list>
///       <item>abs(n) > 999999999</item>
///       <item>c.precision == 0 and code n &lt; 0</item>
///       <item>c.precision > 0 and n has more than c.precision decimal digits</item>
///     </list>
///   </item>
///   <item>if n is zero, ONE is returned even if this is zero, otherwise
///     <list>        
///       <item>if n is positive, the result is calculated via
///             the repeated squaring technique into a single accumulator.
///             The individual multiplications with the accumulator use the
///             same math context settings as in c except for a
///             precision increased to c.precision + elength + 1
///             where elength is the number of decimal digits in n.
///       </item>       
///       <item>if n is negative, the result is calculated as if
///             n were positive; this value is then divided into one
///             using the working precision specified above.
///       </item>
///       <item>The final value from either the positive or negative case
///              is then rounded to the destination precision.
///        </item>
///     </list>
///  </list>
/// </remarks>
// X3.274 rule
// shift left 1 bit
// top bit is set
// OK, we're off
// acc=acc*x
// that was the last bit
// acc=acc*acc [square]
// else (!seenbit) no point in squaring ONE
// if negative n, calculate the reciprocal using working precision
// [hence mc.precision>0]
// round to final precision and strip zeros
/// <summary>
/// Does this BigDecimal have a zero value?
/// </summary>
/// <summary>
/// Does this BigDecimal represent a positive value?
/// </summary>
/// <summary>
/// Does this BigDecimal represent a negative value?
/// </summary>
/// <summary>
/// Returns the sign (-1, 0, +1) of this BigDecimal.
/// </summary>
/// <summary>
/// Check to see if the result of exponent arithmetic is valid.
/// </summary>
/// <param name="candidate">The value resulting from exponent arithmetic.</param>
/// <param name="isZero">Are we computing an exponent for a zero coefficient?</param>
/// <param name="exponent">The exponent to use</param>
/// <returns>True if the candidate is valid, false otherwise.</returns>
/// <remarks>
/// <para>Exponent arithmetic during various operations may result in values
/// that are out of range of an Int32.  We can do the computation as a long,
/// then use this to make sure the result is okay to use.</para>
/// <para>If the exponent is out of range, but the coefficient is zero,
/// the exponent in some sense is not that relevant, so we just clamp to 
/// the appropriate (pos/neg) extreme value for Int32.  (This handling inspired by 
/// the OpenJKD implementation.)</para>
/// </remarks>
// We have underflow/overflow.
// If Zero, use the max value of the appropriate sign.
/// <summary>
/// Reduce exponent to Int32.  Throw error if out of range.
/// </summary>
/// <param name="candidate">The value resulting from exponent arithmetic.</param>
/// <param name="isZero">Are we computing an exponent for a zero coefficient?</param>
/// <returns>The exponent to use</returns>
// Report error condition
/// <summary>
/// Remove insignificant trailing zeros from this BigDecimal until the 
/// preferred exponent is reached or no more zeros can be removed.
/// </summary>
/// <param name="preferredExp"></param>
/// <returns></returns>
/// <remarks>
/// <para>Took this one from OpenJDK implementation, with some minor edits.</para>
/// <para>Modifies its argument.  Use only on a new BigDecimal.</para>
/// </remarks>
// odd number.  cannot end in 0
// non-0 remainder
// could overflow
// adjust precision if known
/// <summary>
/// Returns a BigDecimal numerically equal to this one, but with 
/// any trailing zeros removed.
/// </summary>
/// <returns></returns>
/// <remarks>Ended up needing this in ClojureCLR, grabbed from OpenJDK.</remarks>
/// <summary>
/// 
/// </summary>
/// <param name="v"></param>
/// <param name="c"></param>
/// <returns></returns>
/// <remarks>The OpenJDK implementation has an efficiency hack to only compute the precision 
/// (call to .GetPrecision) if the value is outside the range of the context's precision 
/// (-10^precision to 10^precision), with those bounds being cached on the Context.
/// TODO: See if it is worth implementing the hack.
/// </remarks>
//if (c.Precision == 0)
//    return v;
// we need to lose some digits on the coefficient. 
/// <summary>
/// Assuming 
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <param name="mode"></param>
/// <returns></returns>
// we need to pay attention
// no change
// Not clear on the precision
// Essentially, we have to round to a new precision.
// we need this new precision to be non-zero, else we are zero.
// happens for example with 9.9999 & 1e-2 where we have a round 10.0 
// decreasing the exponent (delta is positive)
// multiply by an appropriate power of 10
// Make sure we don't underflow
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\BigInt.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// Copying JVM's clojure.lang.BigInt class as closely as possible
/// <summary>
/// Try to convert to an Int32.
/// </summary>
/// <param name="ret">Set to the converted value</param>
/// <returns><value>true</value> if successful; <value>false</value> if the value cannot be represented.</returns>
/// <summary>
/// Try to convert to an Int64.
/// </summary>
/// <param name="ret">Set to the converted value</param>
/// <returns><value>true</value> if successful; <value>false</value> if the value cannot be represented.</returns>
/// <summary>
/// Try to convert to an UInt32.
/// </summary>
/// <param name="ret">Set to the converted value</param>
/// <returns><value>true</value> if successful; <value>false</value> if the value cannot be represented.</returns>
/// <summary>
/// Try to convert to an UInt64.
/// </summary>
/// <param name="ret">Set to the converted value</param>
/// <returns><value>true</value> if successful; <value>false</value> if the value cannot be represented.</returns>
/// <summary>
/// Try to convert to a Decimal.
/// </summary>
/// <param name="ret">Set to the converted value</param>
/// <returns><value>true</value> if successful; <value>false</value> if the value cannot be represented.</returns>
/// <summary>
/// Implicitly convert from byte to <see cref="BigInt"/>.
/// </summary>
/// <param name="v">The value to convert</param>
/// <returns>The equivalent <see cref="BigInt"/></returns>
/// <summary>
/// Implicitly convert from sbyte to <see cref="BigInt"/>.
/// </summary>
/// <param name="v">The value to convert</param>
/// <returns>The equivalent <see cref="BigInt"/></returns>
/// <summary>
/// Implicitly convert from short to <see cref="BigInt"/>.
/// </summary>
/// <param name="v">The value to convert</param>
/// <returns>The equivalent <see cref="BigInt"/></returns>
/// <summary>
/// Implicitly convert from ushort to <see cref="BigInt"/>.
/// </summary>
/// <param name="v">The value to convert</param>
/// <returns>The equivalent <see cref="BigInt"/></returns>
/// <summary>
/// Implicitly convert from uint to <see cref="BigInt"/>.
/// </summary>
/// <param name="v">The value to convert</param>
/// <returns>The equivalent <see cref="BigInt"/></returns>
/// <summary>
/// Implicitly convert from int to <see cref="BigInt"/>.
/// </summary>
/// <param name="v">The value to convert</param>
/// <returns>The equivalent <see cref="BigInt"/></returns>
/// <summary>
/// Implicitly convert from ulong to <see cref="BigInt"/>.
/// </summary>
/// <param name="v">The value to convert</param>
/// <returns>The equivalent <see cref="BigInt"/></returns>
/// <summary>
/// Implicitly convert from long to <see cref="BigInt"/>.
/// </summary>
/// <param name="v">The value to convert</param>
/// <returns>The equivalent <see cref="BigInt"/></returns>
/// <summary>
/// Implicitly convert from decimal to <see cref="BigInt"/>.
/// </summary>
/// <param name="v">The value to convert</param>
/// <returns>The equivalent <see cref="BigInt"/></returns>
/// <summary>
/// Explicitly convert from double to <see cref="BigInt"/>.
/// </summary>
/// <param name="v">The value to convert</param>
/// <returns>The equivalent <see cref="BigInt"/></returns>
/// <summary>
/// Implicitly convert from <see cref="BigInt"/> to double.
/// </summary>
/// <param name="i">The <see cref="BigInt"/> to convert</param>
/// <returns>The equivalent double</returns>
/// <summary>
/// Explicitly convert from <see cref="BigInt"/> to byte.
/// </summary>
/// <param name="i">The <see cref="BigInt"/> to convert</param>
/// <returns>The equivalent byte</returns>
/// <summary>
/// Explicitly convert from <see cref="BigInt"/> to sbyte.
/// </summary>
/// <param name="i">The <see cref="BigInt"/> to convert</param>
/// <returns>The equivalent sbyte</returns>
/// <summary>
/// Explicitly convert from <see cref="BigInt"/> to UInt16.
/// </summary>
/// <param name="i">The <see cref="BigInt"/> to convert</param>
/// <returns>The equivalent UInt16</returns>
/// <summary>
/// Explicitly convert from <see cref="BigInt"/> to Int16.
/// </summary>
/// <param name="i">The <see cref="BigInt"/> to convert</param>
/// <returns>The equivalent Int16</returns>
/// <summary>
/// Explicitly convert from <see cref="BigInt"/> to UInt32.
/// </summary>
/// <param name="i">The <see cref="BigInt"/> to convert</param>
/// <returns>The equivalent UInt32</returns>
/// <summary>
/// Explicitly convert from <see cref="BigInt"/> to Int32.
/// </summary>
/// <param name="i">The <see cref="BigInt"/> to convert</param>
/// <returns>The equivalent Int32</returns>
/// <summary>
/// Explicitly convert from <see cref="BigInt"/> to Int64.
/// </summary>
/// <param name="i">The <see cref="BigInt"/> to convert</param>
/// <returns>The equivalent Int64</returns>
/// <summary>
/// Explicitly convert from <see cref="BigInt"/> to UInt64.
/// </summary>
/// <param name="i">The <see cref="BigInt"/> to convert</param>
/// <returns>The equivalent UInt64</returns>
/// <summary>
/// Explicitly convert from <see cref="BigInt"/> to float.
/// </summary>
/// <param name="i">The <see cref="BigInt"/> to convert</param>
/// <returns>The equivalent float</returns>
/// <summary>
/// Explicitly convert from <see cref="BigInt"/> to double.
/// </summary>
/// <param name="i">The <see cref="BigInt"/> to convert</param>
/// <returns>The equivalent decimal</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\BigInteger.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Extended precision integer.
/// </summary>
/// <remarks>
/// <para>Inspired by the Microsoft.Scripting.Math.BigInteger code, 
/// the java.math.BigInteger code, but mostly by Don Knuth's Art of Computer Programming, Volume 2.</para>
/// <para>The same as most other BigInteger representations, this implementation uses a sign/magnitude representation.</para>
/// <para>The magnitude is represented by an array of uints in big-endian order.  Noted in passing: the CLR implementation is little-endian uint[].  
/// The Java implementation is int[] big-endian.</para>
/// <para>BigIntegers are immutable.</para>
/// </remarks>
/// <summary>
/// The number of bits in one 'digit' of the magnitude.
/// </summary>
// uint implementation
/// <summary>
/// The sign of the integer.  Must be -1, 0, +1.
/// </summary>
/// <summary>
/// The magnitude of the integer (big-endian).
/// </summary>
/// <remarks>
/// <para>Big-endian = _data[0] is the most significant digit.</para>
/// <para> Some invariants:</para>
/// <list>
/// <item>If the integer is zero, then _data must be length zero array and _sign must be zero.</item>
/// <item>No leading zero uints.</item>
/// <item>Must be non-null.  For zero, a zero-length array is used.</item>
/// </list>
/// These invariants imply a unique representation for every value.  
/// They also force us to get rid of leading zeros after every operation that might create some.
/// </remarks>
/// <summary>
/// Zero
/// </summary>
/// <summary>
/// One
/// </summary>
/// <summary>
/// Two
/// </summary>
/// <summary>
/// Five
/// </summary>
/// <summary>
/// Ten
/// </summary>
/// <summary>
/// -1
/// </summary>
/// <summary>
/// Create a <see cref="BigInteger"/> from an unsigned long value. 
/// </summary>
/// <param name="v">The value</param>
/// <returns>A <see cref="BigInteger"/></returns>
/// <summary>
/// Create a <see cref="BigInteger"/> from an unsigned int value.
/// </summary>
/// <param name="v">The value</param>
/// <returns>A <see cref="BigInteger"/></returns>
/// <summary>
/// Create a <see cref="BigInteger"/> from an (signed) long value.
/// </summary>
/// <param name="v">The value</param>
/// <returns>A <see cref="BigInteger"/></returns>
/// <summary>
/// Create a <see cref="BigInteger"/> from an (signed) int value.
/// </summary>
/// <param name="v">The value</param>
/// <returns>A <see cref="BigInteger"/></returns>
/// <summary>
/// Create a <see cref="BigInteger"/> from a decimal value.
/// </summary>
/// <param name="v">The value</param>
/// <returns>A <see cref="BigInteger"/></returns>
// I could avoid creating the extra array, but do I care?
/// <summary>
/// Create a <see cref="BigInteger"/> from a double value.
/// </summary>
/// <param name="v">The value</param>
/// <returns>A <see cref="BigInteger"/></returns>
// TODO: Avoid extra allocation
// TODO: Avoid extra allocation
/// <summary>
/// Create a copy of a <see cref="BigInteger"/>
/// </summary>
/// <param name="copy">The <see cref="BigInteger"/> to copy</param>
/// <summary>
/// Create a BigInteger from sign/magnitude data.
/// </summary>
/// <param name="sign">The sign (-1, 0, +1)</param>
/// <param name="data">The magnitude (big-endian)</param>
/// <exception cref="System.ArgumentException">Thrown when the sign is not one of -1, 0, +1, 
/// or if a zero sign is given on a non-empty magnitude.</exception>
/// <remarks>
/// <para>Leading zero (uint) digits will be removed.</para>
/// <para>The sign will be set to zero if a zero-length array is passed.</para>
/// </remarks>
/// <summary>
/// Create a <see cref="BigInteger"/> from a string representation (radix 10).
/// </summary>
/// <param name="x">The string to convert</param>
/// <returns>A <see cref="BigInteger"/></returns>
/// <exception cref="System.FormatException">Thrown if there is a bad minus sign (more than one or not leading)
/// or if one of the digits in the string is noat valid for the given radix.</exception>
/// <summary>
/// Create a <see cref="BigInteger"/> from a string representation in the given radix.
/// </summary>
/// <param name="s">The string to convert</param>
/// <param name="radix">The radix of the numeric representation</param>
/// <returns>A <see cref="BigInteger"/></returns>
/// <exception cref="System.FormatException">Thrown if there is a bad minus sign (more than one or not leading)
/// or if one of the digits in the string is noat valid for the given radix.</exception>
/// <summary>
/// Try to create a <see cref="BigInteger"/> from a string representation (radix 10)
/// </summary>
/// <param name="s">The string to convert</param>
/// <param name="v">Set to the  <see cref="BigInteger"/> corresponding to the string, if possible; set to null otherwise</param>
/// <returns><c>True</c> if the string is parsed successfully; <c>false</c> otherwise</returns>
/// <summary>
/// The minimum radix allowed in parsing.
/// </summary>
/// <summary>
/// The maximum radix allowed in parsing.
/// </summary>
/// <summary>
/// Try to create a <see cref="BigInteger"/> from a string representation in the given radix)
/// </summary>
/// <param name="s">The string to convert</param>
/// <param name="radix">The radix of the numeric representation</param>
/// <param name="v">Set to the  <see cref="BigInteger"/> corresponding to the string, if possible; set to null otherwise</param>
/// <returns><c>True</c> if the string is parsed successfully; <c>false</c> otherwise</returns>
/// <remarks>
/// <para>This is pretty much the same algorithm as in the Java implementation.
/// That's pretty much what is in Knuth ACPv2ed3, Sec. 4.4, Method 1b.
/// That's pretty much what you'd do by hand.</para>  
/// <para>The only enhancement is that instead of doing one digit at a time, you translate a group of contiguous
/// digits into a uint, then do a multiply by the radix and add of the uint.
/// The size of each group of digits is the maximum number of digits in the radix
/// that will fit into a uint.</para>
/// <para>Once you've decided to make that enhancement to Knuth's algoorithm, you pretty much
/// end up with the Java version's code.</para>
/// </remarks>
// zero length bad, 
// hyphen only bad, plus only bad,
// hyphen not leading bad, plus not leading bad
// (overkill) both hyphen and minus present (one would be caught by the tests above)
// skip leading zeros
// We can compute size of magnitude.  May be too large by one uint.
// the first group may be short
// the first group is the initial value for _data.
/// <summary>
/// Converts the numeric value of this <see cref="BigInteger"/> to its string representation in radix 10.
/// </summary>
/// <returns>The string representation in radix 10</returns>
/// <summary>
/// Converts the numeric value of this <see cref="BigInteger"/> to its string representation in the given radix.
/// </summary>
/// <param name="radix">The radix for the conversion</param>
/// <returns>The string representation in the given radix</returns>
/// <exception cref="System.ArgumentOutOfRangeException">Thrown if the radix is out of range [2,36].</exception>
/// <remarks>
/// <para>Compute a set of 'super digits' in a 'super radix' that is computed based on the <paramref name="radix"/>;
/// specifically, it is based on how many digits in the given radix can fit into a uint when converted.  Each 'super digit'
/// is then translated into a string of digits in the given radix and appended to the result string.
/// </para>
/// <para>The Java and the DLR code are very similar.</para>
/// </remarks>
// TODO: figure out max, pre-allocate space (in array)
/// <summary>
/// Append a sequence of digits representing <paramref name="rem"/> to the <see cref="System.StringBuilder"/>,
/// possibly adding leading null chars if specified.
/// </summary>
/// <param name="sb">The <see cref="System.StringBuilder"/> to append characters to</param>
/// <param name="rem">The 'super digit' value to be converted to its string representation</param>
/// <param name="radix">The radix for the conversion</param>
/// <param name="charBuf">A character buffer used for temporary storage, big enough to hold the string
/// representation of <paramref name="rem"/></param>
/// <param name="leadingZeros">Whether or not to pad with the leading zeros if the value is not large enough to fill the buffer</param>
/// <remarks>Pretty much identical to DLR BigInteger.AppendRadix</remarks>
/// <summary>
/// The maximum number of digits in radix [i] that will fit into a uint.
/// </summary>
/// <remarks>
/// <para>RadixDigitsPerDigit[i] = floor(log_i (2^32 - 1))</para>
/// <para>See the radix.xlsx spreadsheet.</para>
/// </remarks>
/// <summary>
/// The super radix (power of given radix) that fits into a uint.
/// </summary>
/// <remarks>
/// <para>SuperRadix[i] = 2 ^ RadixDigitsPerDigit[i]</para>
/// <para>See the radix.xlsx spreadsheet.</para>
/// </remarks>
/// <summary>
/// The number of bits in one digit of radix [i] times 1024.
/// </summary>
/// <remarks>    
/// <para>BitsPerRadixDigit[i] = ceiling(1024*log_2(i))</para>
/// <para>The value is multiplied by 1024 to avoid fractions.  Users will need to divide by 1024.</para>
/// <para>See the radix.xlsx spreadsheet.</para>
/// </remarks>
/// <summary>
/// Convert a substring in a given radix to its equivalent numeric value as a UInt32.
/// </summary>
/// <param name="val">The string containing the substring to convert</param>
/// <param name="startIndex">The start index of the substring</param>
/// <param name="len">The length of the substring</param>
/// <param name="radix">The radix</param>
/// <param name="u">Set to the converted value, or 0 if the conversion is unsuccessful</param>
/// <returns><value>true</value> if successful, <value>false</value> otherwise</returns>
/// <remarks>The length of the substring must be small enough that the converted value is guaranteed to fit
/// into a uint.</remarks>
/// <summary>
/// Convert an (extended) digit to its value in the given radix.
/// </summary>
/// <param name="c">The character to convert</param>
/// <param name="radix">The radix to interpret the character in</param>
/// <param name="v">Set to the converted value</param>
/// <returns><value>true</value> if the conversion is successful; <value>false</value> otherwise</returns>
/// <summary>
/// Implicitly convert from byte to <see cref="BigInteger"/>.
/// </summary>
/// <param name="v">The value to convert</param>
/// <returns>The equivalent <see cref="BigInteger"/></returns>
/// <summary>
/// Implicitly convert from sbyte to <see cref="BigInteger"/>.
/// </summary>
/// <param name="v">The value to convert</param>
/// <returns>The equivalent <see cref="BigInteger"/></returns>
/// <summary>
/// Implicitly convert from short to <see cref="BigInteger"/>.
/// </summary>
/// <param name="v">The value to convert</param>
/// <returns>The equivalent <see cref="BigInteger"/></returns>
/// <summary>
/// Implicitly convert from ushort to <see cref="BigInteger"/>.
/// </summary>
/// <param name="v">The value to convert</param>
/// <returns>The equivalent <see cref="BigInteger"/></returns>
/// <summary>
/// Implicitly convert from uint to <see cref="BigInteger"/>.
/// </summary>
/// <param name="v">The value to convert</param>
/// <returns>The equivalent <see cref="BigInteger"/></returns>
/// <summary>
/// Implicitly convert from int to <see cref="BigInteger"/>.
/// </summary>
/// <param name="v">The value to convert</param>
/// <returns>The equivalent <see cref="BigInteger"/></returns>
/// <summary>
/// Implicitly convert from ulong to <see cref="BigInteger"/>.
/// </summary>
/// <param name="v">The value to convert</param>
/// <returns>The equivalent <see cref="BigInteger"/></returns>
/// <summary>
/// Implicitly convert from long to <see cref="BigInteger"/>.
/// </summary>
/// <param name="v">The value to convert</param>
/// <returns>The equivalent <see cref="BigInteger"/></returns>
/// <summary>
/// Implicitly convert from decimal to <see cref="BigInteger"/>.
/// </summary>
/// <param name="v">The value to convert</param>
/// <returns>The equivalent <see cref="BigInteger"/></returns>
/// <summary>
/// Explicitly convert from double to <see cref="BigInteger"/>.
/// </summary>
/// <param name="v">The value to convert</param>
/// <returns>The equivalent <see cref="BigInteger"/></returns>
/// <summary>
/// Implicitly convert from <see cref="BigInteger"/> to double.
/// </summary>
/// <param name="i">The <see cref="BigInteger"/> to convert</param>
/// <returns>The equivalent double</returns>
/// <summary>
/// Explicitly convert from <see cref="BigInteger"/> to byte.
/// </summary>
/// <param name="i">The <see cref="BigInteger"/> to convert</param>
/// <returns>The equivalent byte</returns>
/// <summary>
/// Explicitly convert from <see cref="BigInteger"/> to sbyte.
/// </summary>
/// <param name="i">The <see cref="BigInteger"/> to convert</param>
/// <returns>The equivalent sbyte</returns>
/// <summary>
/// Explicitly convert from <see cref="BigInteger"/> to UInt16.
/// </summary>
/// <param name="i">The <see cref="BigInteger"/> to convert</param>
/// <returns>The equivalent UInt16</returns>
/// <summary>
/// Explicitly convert from <see cref="BigInteger"/> to Int16.
/// </summary>
/// <param name="i">The <see cref="BigInteger"/> to convert</param>
/// <returns>The equivalent Int16</returns>
/// <summary>
/// Explicitly convert from <see cref="BigInteger"/> to UInt32.
/// </summary>
/// <param name="i">The <see cref="BigInteger"/> to convert</param>
/// <returns>The equivalent UInt32</returns>
/// <summary>
/// Explicitly convert from <see cref="BigInteger"/> to Int32.
/// </summary>
/// <param name="i">The <see cref="BigInteger"/> to convert</param>
/// <returns>The equivalent Int32</returns>
/// <summary>
/// Explicitly convert from <see cref="BigInteger"/> to Int64.
/// </summary>
/// <param name="i">The <see cref="BigInteger"/> to convert</param>
/// <returns>The equivalent Int64</returns>
/// <summary>
/// Explicitly convert from <see cref="BigInteger"/> to UInt64.
/// </summary>
/// <param name="i">The <see cref="BigInteger"/> to convert</param>
/// <returns>The equivalent UInt64</returns>
/// <summary>
/// Explicitly convert from <see cref="BigInteger"/> to float.
/// </summary>
/// <param name="i">The <see cref="BigInteger"/> to convert</param>
/// <returns>The equivalent float</returns>
/// <summary>
/// Explicitly convert from <see cref="BigInteger"/> to double.
/// </summary>
/// <param name="i">The <see cref="BigInteger"/> to convert</param>
/// <returns>The equivalent decimal</returns>
/// <summary>
/// Compare two <see cref="BigInteger"/>s for equivalent numeric values.
/// </summary>
/// <param name="x">First value to compare</param>
/// <param name="y">Second value to compare</param>
/// <returns><value>true</value> if equivalent; <value>false</value> otherwise</returns>
/// <summary>
/// Compare two <see cref="BigInteger"/>s for non-equivalent numeric values.
/// </summary>
/// <param name="x">First value to compare</param>
/// <param name="y">Second value to compare</param>
/// <returns><value>true</value> if not equivalent; <value>false</value> otherwise</returns>
/// <summary>
/// Compare two <see cref="BigInteger"/>s for <.
/// </summary>
/// <param name="x">First value to compare</param>
/// <param name="y">Second value to compare</param>
/// <returns><value>true</value> if <; <value>false</value> otherwise</returns>
/// <summary>
/// Compare two <see cref="BigInteger"/>s for <=.
/// </summary>
/// <param name="x">First value to compare</param>
/// <param name="y">Second value to compare</param>
/// <returns><value>true</value> if <=; <value>false</value> otherwise</returns>
/// <summary>
/// Compare two <see cref="BigInteger"/>s for >.
/// </summary>
/// <param name="x">First value to compare</param>
/// <param name="y">Second value to compare</param>
/// <returns><value>true</value> if >; <value>false</value> otherwise</returns>
/// <summary>
/// Compare two <see cref="BigInteger"/>s for >=.
/// </summary>
/// <param name="x">First value to compare</param>
/// <param name="y">Second value to compare</param>
/// <returns><value>true</value> if >=; <value>false</value> otherwise</returns>
/// <summary>
/// Compute <paramref name="x"/> + <paramref name="y"/>.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The sum</returns>
/// <summary>
/// Compute <paramref name="x"/> - <paramref name="y"/>.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The difference</returns>
/// <summary>
/// Compute the negation of <paramref name="x"/>.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The negation</returns>
/// <summary>
/// Compute <paramref name="x"/> * <paramref name="y"/>.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The product</returns>
/// <summary>
/// Compute <paramref name="x"/> / <paramref name="y"/>.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The quotient</returns>
/// <summary>
/// Compute <paramref name="x"/> % <paramref name="y"/>.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The modulus</returns>
/// <summary>
/// Compute <paramref name="x"/> + <paramref name="y"/>.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The sum</returns>
/// <summary>
/// Compute <paramref name="x"/> - <paramref name="y"/>.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The difference</returns>
/// <summary>
/// Compute the negation of <paramref name="x"/>.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The negation</returns>
/// <summary>
/// Compute <paramref name="x"/> * <paramref name="y"/>.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The product</returns>
/// <summary>
/// Compute <paramref name="x"/> / <paramref name="y"/>.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The quotient</returns>
/// <summary>
/// Returns <paramref name="x"/> % <paramref name="y"/>.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The modulus</returns>
/// <summary>
/// Compute the quotient and remainder of dividing one <see cref="BigInteger"/> by another.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <param name="remainder">Set to the remainder after division</param>
/// <returns>The quotient</returns>
/// <summary>
/// Compute the absolute value.
/// </summary>
/// <param name="x"></param>
/// <returns>The absolute value</returns>
/// <summary>
/// Returns a <see cref="BigInteger"/> raised to an int power.
/// </summary>
/// <param name="x">The value to exponentiate</param>
/// <param name="exp">The exponent</param>
/// <returns>The exponent</returns>
/// <summary>
/// Returns a <see cref="BigInteger"/> raised to an <see cref="BigInteger"/> power modulo another <see cref="BigInteger"/>
/// </summary>
/// <param name="x"></param>
/// <param name="power"></param>
/// <param name="mod"></param>
/// <returns> x ^ e mod m</returns>
/// <summary>
/// Returns the greatest common divisor.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns>The greatest common divisor</returns>
/// <summary>
/// Returns the bitwise-AND.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns></returns>
/// <summary>
/// Returns the bitwise-OR.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns></returns>
/// <summary>
/// Returns the bitwise-complement.
/// </summary>
/// <param name="x"></param>
/// <returns></returns>
/// <summary>
/// Returns the bitwise-XOR.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns></returns>
/// <summary>
/// Returns the left-shift of a <see cref="BigInteger"/> by an int shift.
/// </summary>
/// <param name="x"></param>
/// <param name="shift"></param>
/// <returns></returns>
/// <summary>
/// Returns the right-shift of a <see cref="BigInteger"/> by an int shift.
/// </summary>
/// <param name="x"></param>
/// <param name="shift"></param>
/// <returns></returns>
/// <summary>
/// Returns the bitwise-AND.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns></returns>
/// <summary>
/// Returns the bitwise-OR.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns></returns>
/// <summary>
/// Returns the bitwise-XOR.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns></returns>
/// <summary>
/// Returns the bitwise complement.
/// </summary>
/// <param name="x"></param>
/// <returns></returns>
/// <summary>
/// Returns the bitwise x & ~y.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns></returns>
/// <summary>
/// Returns  x << shift.
/// </summary>
/// <param name="x"></param>
/// <param name="shift"></param>
/// <returns></returns>
/// <summary>
/// Returns x >> shift.
/// </summary>
/// <param name="x"></param>
/// <param name="shift"></param>
/// <returns></returns>
/// <summary>
/// Test if a specified bit is set.
/// </summary>
/// <param name="x"></param>
/// <param name="n"></param>
/// <returns></returns>
/// <summary>
/// Set the specified bit.
/// </summary>
/// <param name="x"></param>
/// <param name="n"></param>
/// <returns></returns>
/// <summary>
/// Set the specified bit to its negation.
/// </summary>
/// <param name="x"></param>
/// <param name="n"></param>
/// <returns></returns>
/// <summary>
///  Clear the specified bit.
/// </summary>
/// <param name="x"></param>
/// <param name="n"></param>
/// <returns></returns>
/// <summary>
/// Try to convert to an Int32.
/// </summary>
/// <param name="ret">Set to the converted value</param>
/// <returns><value>true</value> if successful; <value>false</value> if the value cannot be represented.</returns>
/// <summary>
/// Try to convert to an Int64.
/// </summary>
/// <param name="ret">Set to the converted value</param>
/// <returns><value>true</value> if successful; <value>false</value> if the value cannot be represented.</returns>
/// <summary>
/// Try to convert to an UInt32.
/// </summary>
/// <param name="ret">Set to the converted value</param>
/// <returns><value>true</value> if successful; <value>false</value> if the value cannot be represented.</returns>
/// <summary>
/// Try to convert to an UInt64.
/// </summary>
/// <param name="ret">Set to the converted value</param>
/// <returns><value>true</value> if successful; <value>false</value> if the value cannot be represented.</returns>
/// <summary>
/// Try to convert to a Decimal.
/// </summary>
/// <param name="ret">Set to the converted value</param>
/// <returns><value>true</value> if successful; <value>false</value> if the value cannot be represented.</returns>
/// <summary>
/// Convert to an equivalent UInt32
/// </summary>
/// <returns>The equivalent value</returns>
/// <exception cref="System.OverflowException">Thrown if the magnitude is too large for the conversion</exception>
/// <summary>
/// Convert to an equivalent Int32
/// </summary>
/// <returns>The equivalent value</returns>
/// <exception cref="System.OverflowException">Thrown if the magnitude is too large for the conversion</exception>
/// <summary>
/// Convert to an equivalent Decimal
/// </summary>
/// <returns>The equivalent value</returns>
/// <exception cref="System.OverflowException">Thrown if the magnitude is too large for the conversion</exception>
/// <summary>
/// Convert to an equivalent UInt64
/// </summary>
/// <returns>The equivalent value</returns>
/// <exception cref="System.OverflowException">Thrown if the magnitude is too large for the conversion</exception>
/// <summary>
/// Convert to an equivalent Int64
/// </summary>
/// <returns>The equivalent value</returns>
/// <exception cref="System.OverflowException">Thrown if the magnitude is too large for the conversion</exception>
/// <summary>
/// Convert to an equivalent Double
/// </summary>
/// <returns>The equivalent value</returns>
/// <exception cref="System.OverflowException">Thrown if the magnitude is too large for the conversion</exception>
/// <summary>
/// Compares this instance to a specified object and returns an indication of their relative values.
/// </summary>
/// <param name="obj"></param>
/// <returns></returns>
/// <exception cref="System.ArgumentException">Thrown if a comparison is made against anything other than a <see cref="BigInteger"/></exception>
/// <summary>
/// Returns the <see cref="System.TypeCode"/> for this instance.
/// </summary>
/// <returns>The <see cref="System.TypeCode"/></returns>
/// <summary>
/// Converts the value of this instance to an equivalent boolean value
/// </summary>
/// <param name="provider"></param>
/// <returns><value>true</value> if the value is not zero; <value>false</value> otherwise</returns>
/// <summary>
/// Converts the value of this instance to an equivalent byte value
/// </summary>
/// <param name="provider">(Ignored)</param>
/// <returns>The converted value</returns>
/// <exception cref="System.OverflowException">Thrown if the value cannot be represented in a byte.</exception>
/// <summary>
/// Converts the value of this instance to an equivalent Character value
/// </summary>
/// <param name="provider">(Ignored)</param>
/// <returns>The converted value</returns>
/// <exception cref="System.OverflowException">Thrown if the value cannot be represented in a char.</exception>
/// <summary>
/// Converts the value of this instance to an equivalent Decimal value
/// </summary>
/// <param name="provider">(Ignored)</param>
/// <returns>The converted value</returns>
/// <exception cref="System.OverflowException">Thrown if the value cannot be represented in a Decimal.</exception>
/// <summary>
/// Converts the value of this instance to an equivalent Double value
/// </summary>
/// <param name="provider">(Ignored)</param>
/// <returns>The converted value</returns>
/// <exception cref="System.OverflowException">Thrown if the value cannot be represented in a Double.</exception>
/// <summary>
/// Converts the value of this instance to an equivalent Int16 value
/// </summary>
/// <param name="provider">(Ignored)</param>
/// <returns>The converted value</returns>
/// <exception cref="System.OverflowException">Thrown if the value cannot be represented in a Int16.</exception>
/// <summary>
/// Converts the value of this instance to an equivalent Int32 value
/// </summary>
/// <param name="provider">(Ignored)</param>
/// <returns>The converted value</returns>
/// <exception cref="System.OverflowException">Thrown if the value cannot be represented in a Int32.</exception>
/// <summary>
/// Converts the value of this instance to an equivalent Int64 value
/// </summary>
/// <param name="provider">(Ignored)</param>
/// <returns>The converted value</returns>
/// <exception cref="System.OverflowException">Thrown if the value cannot be represented in a Int64.</exception>
/// <summary>
/// Converts the value of this instance to an equivalent sbyte value
/// </summary>
/// <param name="provider">(Ignored)</param>
/// <returns>The converted value</returns>
/// <exception cref="System.OverflowException">Thrown if the value cannot be represented in a sbyte.</exception>
/// <summary>
/// Converts the value of this instance to an equivalent float value
/// </summary>
/// <param name="provider">(Ignored)</param>
/// <returns>The converted value</returns>
/// <exception cref="System.OverflowException">Thrown if the value cannot be represented in a float.</exception>
/// <summary>
/// Converts the value of this instance to an equivalent string
/// </summary>
/// <param name="provider">(Ignored)</param>
/// <returns>The converted value</returns>
/// <summary>
/// Converts the value of this instance to the given type.  
/// </summary>
/// <param name="conversionType">Type to convert to (<see cref="BigInteger"/> only.</param>
/// <param name="provider">(Ingored)</param>
/// <returns>The converted value</returns>
/// <summary>
/// Converts the value of this instance to an equivalent UInt16 value
/// </summary>
/// <param name="provider">(Ignored)</param>
/// <returns>The converted value</returns>
/// <exception cref="System.OverflowException">Thrown if the value cannot be represented in a UInt16.</exception>
/// <summary>
/// Converts the value of this instance to an equivalent UInt132 value
/// </summary>
/// <param name="provider">(Ignored)</param>
/// <returns>The converted value</returns>
/// <exception cref="System.OverflowException">Thrown if the value cannot be represented in a UInt32.</exception>
/// <summary>
/// Converts the value of this instance to an equivalent UInt64 value
/// </summary>
/// <param name="provider">(Ignored)</param>
/// <returns>The converted value</returns>
/// <exception cref="System.OverflowException">Thrown if the value cannot be represented in a UInt64.</exception>
/// <summary>
/// Indicates whether this instance is equivalent to another object of the same type.
/// </summary>
/// <param name="other">The object to compare this instance against</param>
/// <returns><value>true</value> if equivalent; <value>false</value> otherwise</returns>
/// <summary>
/// Returns an indication of the relative values of the two <see cref="BigInteger"/>s
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns><value>-1</value> if the first is less than second; <value>0</value> if equal; <value>+1</value> if greater</returns>
/// <summary>
/// Return an indication of the relative values of two uint arrays treated as unsigned big-endian values.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns><value>-1</value> if the first is less than second; <value>0</value> if equal; <value>+1</value> if greater</returns>
/// <summary>
/// Returns this + y.
/// </summary>
/// <param name="y">The augend.</param>
/// <returns>The sum</returns>
/// <summary>
/// Returns this - y
/// </summary>
/// <param name="y">The subtrahend</param>
/// <returns>The difference</returns>
/// <summary>
/// Returns the negation of this value.
/// </summary>
/// <returns>The negation</returns>
/// <summary>
/// Returns this * y
/// </summary>
/// <param name="y">The multiplicand</param>
/// <returns>The product</returns>
/// <summary>
/// Returns this / y.
/// </summary>
/// <param name="y">The divisor</param>
/// <returns>The quotient</returns>
/// <summary>
/// Returns this % y
/// </summary>
/// <param name="y">The divisor</param>
/// <returns>The modulus</returns>
/// <summary>
/// Returns the quotient and remainder of this divided by another.
/// </summary>
/// <param name="y">The divisor</param>
/// <param name="remainder">The remainder</param>
/// <returns>The quotient</returns>
/// <summary>
/// Returns the absolute value of this instance.
/// </summary>
/// <returns>The absolute value</returns>
/// <summary>
/// Returns the value of this instance raised to an integral power.
/// </summary>
/// <param name="exp">The exponent</param>
/// <returns>The exponetiated value</returns>
/// <exception cref="System.ArgumentOutOfRangeException">Thrown if the exponent is negative.</exception>
// Exponentiation by repeated squaring
/// <summary>
/// Returns (this ^ power) % modulus
/// </summary>
/// <param name="power">The exponent</param>
/// <param name="mod"></param>
/// <returns></returns>
// TODO: Look at Java implementation for a more efficient version
// Exponentiation by repeated squaring
/// <summary>
/// Returns the greatest common divisor of this and another value.
/// </summary>
/// <param name="y">The other value</param>
/// <returns>The greatest common divisor</returns>
// We follow Java and do a hybrid/binary gcd
// TODO: get rid of unnecessary object creation?
/// <summary>
/// Compute the greatest common divisor of two <see cref="BigInteger"/> values.
/// </summary>
/// <param name="a">The first value</param>
/// <param name="b">The second value</param>
/// <returns>The greatest common divisor</returns>
/// <remarks>Does the standard Euclidean algorithm until the two values are approximately
/// the same length, then switches to a binary gcd algorithm.</remarks>
/// <summary>
/// Compute the greatest common divisor of two <see cref="BigInteger"/> values.
/// </summary>
/// <param name="a">The first value</param>
/// <param name="b">The second value</param>
/// <returns>The greatest common divisor</returns>
/// <remarks>Intended for use when the two values have approximately the same magnitude.</remarks>
// From Knuth, 4.5.5, Algorithm B
// TODO: make this create fewer values, do more in-place manipulations
// Step B1: Find power of 2
// Step B2: Initialize
// Steps B3 and B4  Halve t until not even.
//Step B5: reset max(u,v)
//  One word?
// Step B6: Subtract
// TODO: Clean up extra object creation here.
/// <summary>
/// Return the greatest common divisor of two uint values.
/// </summary>
/// <param name="a">The first value</param>
/// <param name="b">The second value</param>
/// <returns>The greatest common divisor</returns>
/// <remarks>Uses Knuth, 4.5.5, Algorithm B, highly optimized for getting rid of powers of 2.
/// </remarks>
// From Knuth, 4.5.5, Algorithm B
/// <summary>
/// Returns the number of trailing zero bits in a uint value.
/// </summary>
/// <param name="val">The value</param>
/// <returns>The number of trailing zero bits </returns>
/// <summary>
/// The value at index i is the number of trailing zero bits in the value i.
/// </summary>
/// <summary>
/// Returns the index of the lowest set bit in this instance's magnitude.
/// </summary>
/// <returns>The index of the lowest set bit</returns>
/// <summary>
/// Return the bitwise-AND of this instance and another <see cref="BigInteger"/>
/// </summary>
/// <param name="y">The value to AND to this instance.</param>
/// <returns>The bitwise-AND</returns>
// result is negative only if both this and y are negative
/// <summary>
/// Return the bitwise-OR of this instance and another <see cref="BigInteger"/>
/// </summary>
/// <param name="y">The value to OR to this instance.</param>
/// <returns>The bitwise-OR</returns>
// result is negative only if either this or y is negative
/// <summary>
/// Return the bitwise-XOR of this instance and another <see cref="BigInteger"/>
/// </summary>
/// <param name="y">The value to XOR to this instance.</param>
/// <returns>The bitwise-XOR</returns>
// result is negative only if either x and y have the same sign.
/// <summary>
/// Returns the bitwise complement of this instance.
/// </summary>
/// <returns>The bitwise complement</returns>
/// <summary>
/// Return the bitwise-AND-NOT of this instance and another <see cref="BigInteger"/>
/// </summary>
/// <param name="y">The value to OR to this instance.</param>
/// <returns>The bitwise-AND-NOT</returns>
// result is negative only if either this is negative and y is positive
/// <summary>
/// Returns the value of the given bit in this instance.
/// </summary>
/// <param name="n">Index of the bit to check</param>
/// <returns><value>true</value> if the bit is set; <value>false</value> otherwise</returns>
/// <exception cref="System.ArithmeticException">Thrown if the index is negative.</exception>
/// <remarks>The value is treated as if in twos-complement.</remarks>
/// <summary>
/// Set the n-th bit.
/// </summary>
/// <param name="n">Index of the bit to set</param>
/// <returns>An instance with the bit set</returns>
/// <exception cref="System.ArithmeticException">Thrown if the index is negative.</exception>
/// <remarks>The value is treated as if in twos-complement.</remarks>
// This will work if the bit is already set.
/// <summary>
/// Clears the n-th bit.
/// </summary>
/// <param name="n">Index of the bit to clear</param>
/// <returns>An instance with the bit cleared</returns>
/// <exception cref="System.ArithmeticException">Thrown if the index is negative.</exception>
/// <remarks>The value is treated as if in twos-complement.</remarks>
// This will work if the bit is already clear.
/// <summary>
/// Toggles the n-th bit.
/// </summary>
/// <param name="n">Index of the bit to toggle</param>
/// <returns>An instance with the bit toggled</returns>
/// <exception cref="System.ArithmeticException">Thrown if the index is negative.</exception>
/// <remarks>The value is treated as if in twos-complement.</remarks>
/// <summary>
/// Returns the value of this instance left-shifted by the given number of bits.
/// </summary>
/// <param name="shift">The number of bits to shift.</param>
/// <returns>An instance with the magnitude shifted.</returns>
/// <remarks><para>The value is treated as if in twos-complement.</para>
/// <para>A negative shift count will be treated as a positive right shift.</para></remarks>
/// <summary>
/// Returns the value of this instance right-shifted by the given number of bits.
/// </summary>
/// <param name="shift">The number of bits to shift.</param>
/// <returns>An instance with the magnitude shifted.</returns>
/// <remarks><para>The value is treated as if in twos-complement.</para>
/// <para>A negative shift count will be treated as a positive left shift.</para></remarks>
/// <summary>
/// Returns the specified uint-digit pretending the number
/// is a little-endian two's complement representation.
/// </summary>
/// <param name="n">The index of the digit to retrieve</param>
/// <returns>The uint at the given index.</returns>
/// <remarks>If iterating through the data array, better to use
/// the incremental version that keeps track of whether or not
///  the first nonzero has been seen.</remarks>
/// <summary>
/// Returns the specified uint-digit pretending the number
/// is a little-endian two's complement representation.
/// </summary>
/// <param name="n">The index of the digit to retrieve</param>
/// <param name="seenNonZero">Set to true if a nonZero byte is seen</param>
/// <returns>The uint at the given index.</returns>
/// <summary>
/// Returns a uint of all zeros or all ones depending on the sign (pos, neg).
/// </summary>
/// <returns>The uint corresponding to the sign</returns>
/// <summary>
/// Returns the index of the first nonzero digit (there must be one), pretending the value is little-endian.
/// </summary>
/// <returns></returns>
// The Java version caches this value on first computation
/// <summary>
/// Return the twos-complement of the integer represented by the byte-array.
/// </summary>
/// <param name="a"></param>
/// <returns></returns>
// to prevent exit on first test
/// <summary>
/// Returns the sign (-1, 0, +1) of this instance.
/// </summary>
/// <summary>
/// Returns true if this instance is negative.
/// </summary>
/// <summary>
/// Returns true if this instance has value 0.
/// </summary>
/// <summary>
/// Returns true if this instance is positive.
/// </summary>
/// <summary>
/// Return true if this instance has an odd value.
/// </summary>
/// <summary>
/// Return the magnitude as a big-endian array of uints.
/// </summary>
/// <returns>The magnitude</returns>
/// <remarks>The returned array can be manipulated as you like = unshared.</remarks>
/// <summary>
/// Add two uint arrays (big-endian).
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns></returns>
// make sure x is longer, y shorter, swapping if necessary
// add common parts, with carry
// copy longer part of x, while carry required
// copy remaining part, no carry required
// if carry still required, we must grow
/// <summary>
/// Add one digit.
/// </summary>
/// <param name="x"></param>
/// <param name="newDigit"></param>
/// <returns></returns>
/// <summary>
/// Subtract one instance from another (larger first).
/// </summary>
/// <param name="xs"></param>
/// <param name="ys"></param>
/// <returns></returns>
// Assume xs > ys
/// <summary>
///  Multiply to big-endian uint arrays.
/// </summary>
/// <param name="xs"></param>
/// <param name="ys"></param>
/// <returns></returns>
/// <summary>
/// Return the quotient and remainder of dividing one <see cref="BigInteger"/> by another.
/// </summary>
/// <param name="x">The dividend</param>
/// <param name="y">The divisor</param>
/// <param name="q">Set to the quotient</param>
/// <param name="r">Set to the remainder</param>
/// <remarks>Algorithm D in Knuth 4.3.1.</remarks>
// Handle some special cases first.
// Special case: divisor = 0
// Special case: dividend == 0
// Special case: dividend == divisor
// Special case: dividend < divisor
// Special case: divide by single digit (uint)
// Okay.
// Special cases out of the way, let do Knuth's algorithm.
// THis is almost exactly the same as in DLR's BigInteger.
// TODO:  Look at the optimizations inthe Colin Plumb C library
//        (used in the Java BigInteger code).
// D1. Normalize
// Using suggestion to take d = a power of 2 that makes v(n-1) >= b/2.
// Main loop: 
//  D2: Initialize j
//  D7: Loop on j
// Our loop goes the opposite way because of big-endian
// D3: Calculate qhat.
// adjust if estimate is too big
// D4: Multiply and subtract
// Read Knuth very carefully when it comes to 
//  possibly being too large, borrowing, readjusting.
// It sucks.
// D5: Test remainder
// We now know the quotient digit at this index
// D6: Add back
// If we went negative, add ynorm back into the xnorm.
/// <summary>
/// 
/// </summary>
/// <param name="xnorm"></param>
/// <param name="xnlen"></param>
/// <param name="x"></param>
/// <param name="xlen"></param>
/// <param name="shift"></param>
/// <remarks>
/// <para>Assume xnorm.Length == xlen + 1 | xlen;</para>
/// <para>Assume shift in [0,31]</para>
/// <para>This should be private, but I wanted to test it.</para></remarks>
// just copy, with the added zero at the most significant end.
/// <summary>
/// 
/// </summary>
/// <param name="xnorm"></param>
/// <param name="r"></param>
/// <param name="shift"></param>
/// <summary>
/// Do a multiplication and addition in place.
/// </summary>
/// <param name="data">The subject of the operation, receives the result</param>
/// <param name="mult">The value to multiply by</param>
/// <param name="addend">The value to add in</param>
// Multiply
// Add
/// <summary>
/// Return a (possibly new) uint array with leading zero uints removed.
/// </summary>
/// <param name="data">The uint array to prune</param>
/// <returns>A (possibly new) uint array with leading zero uints removed.</returns>
// we have leading zeros. Allocate new array.
/// <summary>
/// Do a division in place and return the remainder.
/// </summary>
/// <param name="data">The value to divide into, and where the result appears</param>
/// <param name="index">Starting index in <paramref name="data"/> for the operation</param>
/// <param name="divisor">The value to dif</param>
/// <returns>The remainder</returns>
/// <remarks>Pretty much identical to DLR BigInteger.div, except DLR's is little-endian
/// and this is big-endian.</remarks>
/// <summary>
/// Divide a big-endian uint array by a uint divisor, returning the quotient and remainder.
/// </summary>
/// <param name="data">A big-endian uint array</param>
/// <param name="divisor">The value to divide by</param>
/// <param name="quotient">Set to the quotient (newly allocated)</param>
/// <returns>The remainder</returns>
/// <summary>
/// Exponent bias in the 64-bit floating point representation.
/// </summary>
/// <summary>
/// The size in bits of the significand in the 64-bit floating point representation.
/// </summary>
/// <summary>
/// How much to shift to accommodate the exponent and the binary digits of the significand.
/// </summary>
/// <summary>
/// Extract the sign bit from a byte-array representaition of a double.
/// </summary>
/// <param name="v">A byte-array representation of a double</param>
/// <returns>The sign bit, either 0 (positive) or 1 (negative)</returns>
/// <summary>
/// Extract the significand (AKA mantissa, coefficient) from a byte-array representation of a double.
/// </summary>
/// <param name="v">A byte-array representation of a double</param>
/// <returns>The significand</returns>
/// <summary>
/// Extract the exponent from a byte-array representaition of a double.
/// </summary>
/// <param name="v">A byte-array representation of a double</param>
/// <returns>The exponent</returns>
// Support for BigDecimal, to compute precision.
// 0 is one digit
// need a working copy.
// Algorithm from Hacker's Delight, section 11-4
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Box.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: Replace Box:  mostly this is used in the Java version in lieu of ref/out parameters.
/// <summary>
/// Boxes any value or reference.
/// </summary>
/// <summary>
/// The value being boxed.
/// </summary>
/// <summary>
/// Gets the boxed value.
/// </summary>
/// <summary>
/// Initializes a <see cref="Box">Box</see> to the given value.
/// </summary>
/// <param name="val"></param>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\ChunkBuffer.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\ChunkedCons.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//public new IPersistentCollection cons(object o)
//{
//    throw new NotImplementedException();
//}
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\ClojureException.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\ClrTypeSpec.cs
// Inspired by similar code in various places
// See  https://github.com/mono/mono/blob/master/mcs/class/corlib/System/TypeSpec.cs
// and see http://www.java2s.com/Open-Source/ASP.NET/Library/sixpack-library/SixPack/Reflection/TypeName.cs.htm 
// The EBNF for fully-qualified type names is here: http://msdn.microsoft.com/en-us/library/yfsftwz6(v=VS.100).aspx
// I primarily followed the mono version. Modifications have to do with assembly and type resolver defaults and some minor details.
// Also, rather than throwing exceptions for badly formed names, we just return null.  Where this is called, generally, an error is not required.
//
// Giving credit where credit is due: please note the following attributions in the mono code:
//
//          Author:
//            Rodrigo Kumpera <kumpera@gmail.com>
//
//          Copyright (C) 2010 Novell, Inc (http://www.novell.com)
//(assy, typeName) => assy == null ? RT.classForName(typeName) : assy.GetType(typeName));  <--- this goes into an infinite loop on a non-existent typename
// bad parse
// ArgumentException ("Count not parse the whole type name", "typeName");
// ArgumentException ("Generic argument can't be byref or pointer type", "typeName");
// ArgumentException ("Can't have a byref of a byref", "typeName")
// ArgumentException ("Can't have a pointer to a byref type", "typeName");
// ArgumentException ("Unmatched ']' while parsing generic argument assembly name");
// ArgumentException ("Byref qualifier must be the last one of a type", "typeName");
// ArgumentException ("Invalid array/generic spec", "typeName");
//generic args
// ArgumentException ("generic args after array spec", "typeName");
//skip '[' to the start of the type
// bad generic arg
// ArgumentException ("Invalid generic arguments spec", "typeName");
// skip ',' to the start of the next arg
// ArgumentException ("Invalid generic arguments separator " + name [pos], "typeName")
// ArgumentException ("Error parsing generic params spec", "typeName");
//array spec
// ArgumentException ("Array spec cannot have 2 bound dimensions", "typeName");
// ArgumentException ("Invalid character in array spec " + name [pos], "typeName");
// ArgumentException ("Error parsing array spec", "typeName");
// ArgumentException ("Invalid array spec, multi-dimensional array cannot be bound", "typeName")
// ArgumentException ("Unmatched ']'", "typeName");
// ArgumentException ("Bad type def, can't handle '" + name [pos]+"'" + " at " + pos, "typeName");
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Cons.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Implements an immutable cons cell.
/// </summary>
// Any reason not to seal this class?
/// <summary>
/// Holds the first value.  (= CAR)
/// </summary>
/// <summary>
/// Holds the rest value. (= CDR)
/// </summary>
/// <summary>
/// Initializes a <see cref="Cons">Cons</see> with the given metadata and first/rest.
/// </summary>
/// <param name="meta">The metadata to attach.</param>
/// <param name="first">The first value.</param>
/// <param name="more">The rest of the sequence.</param>
/// <summary>
/// Initializes a <see cref="Cons">Cons</see> with null metadata and given first/rest.
/// </summary>
/// <param name="first">The first value.</param>
/// <param name="more">The rest of the sequence.</param>
/// <summary>
/// Create a copy with new metadata.
/// </summary>
/// <param name="meta">The new metadata.</param>
/// <returns>A copy of the object with new metadata attached.</returns>
/// <summary>
/// Gets the first item.
/// </summary>
/// <returns>The first item.</returns>
/// <summary>
/// Return a seq of the items after the first.  Calls <c>seq</c> on its argument.  If there are no more items, returns nil."
/// </summary>
/// <returns>A seq of the items after the first, or <c>nil</c> if there are no more items.</returns>
/// <summary>
/// Gets the number of items in the collection.
/// </summary>
/// <returns>The number of items in the collection.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\CountDownLatch.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Implements countdown latch.
/// </summary>
/// <remarks>The interface that is implemented matches the one for java.util.concurrent.CountDownLatch.</remarks>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Counted.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// A promise that the class is a collection that implements a constant-time <see cref="Counted.count()">count()</see>.
/// </summary>
/// <summary>
/// Gets the number of items in the collection.
/// </summary>
/// <returns>The number of items in the collection.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Cycle.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/* Alex Miller, Dec 5, 2014 */
/**
// never null
// lazily realized
// cached
// realization for use of current
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Delay.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Implements a delay of a function call.
/// </summary>
/// <summary>
/// The value, after it has been computed.
/// </summary>
/// <summary>
/// Cached exception, if encountered
/// </summary>
/// <summary>
/// The function being delayed.
/// </summary>
/// <summary>
/// Construct a delay for a function.
/// </summary>
/// <param name="fn">The function to delay.</param>
/// <summary>
/// Force a delay (or identity if not a delay).
/// </summary>
/// <param name="x">The object to force.</param>
/// <returns>The computed valued (if a delay); the object itself (if not a delay).</returns>
/// <summary>
/// Get the value.
/// </summary>
/// <returns>The value</returns>
/// <remarks>Forces the computation if it has not happened yet.</remarks>
// double check
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\EdnReader.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//_dispatchMacros['"'] = new RegexReader();
// no op macros return the reader
//string token = readToken(r, (char)ch);
//return RT.suppressRead() ? null : interpretToken(token);
// Roughly a match to Java Character.digit(char,int),
// though I don't handle all unicode digits.
//no op macros return the reader
//return RT.T;
//return RT.F;
// matched 0  or 0N only
// N suffix
// MS implementation of java.util.BigDecimal has a bug when the string has a leading+
//if ( val[0] == '+' )
//    val = val.Substring(1);
// There is a bug in the BigInteger c-tor that causes it barf on a leading +.
//return Numbers.BIDivide(new BigInteger(numerString), new BigInteger(denomString));
// surrogate code unit?
//octal377
//escape
//if (CharValueInRadix(ch, 8) != -1)  -- this is correct, but we end up with different error message for 8,9 than JVM, so do the following to match:
//octal377
// Read ns symbol
// Read map
// Construct output map
// IPersistentMap m = RT.map();
//+
//+		// Construct output map
//+		IPersistentMap m = RT.map();
//+		Iterator iter = kvs.iterator();
//+		while(iter.hasNext()) {
//+			Object key = iter.next();
//+			Object val = iter.next();
//+
//+			if(key instanceof Keyword) {
//+				Keyword kw = (Keyword) key;
//+				if (kw.getNamespace() == null) {
//+					m = m.assoc(Keyword.intern(ns, kw.getName()), val);
//+				} else if (kw.getNamespace().equals("_")) {
//+					m = m.assoc(Keyword.intern(null, kw.getName()), val);
//+				} else {
//+					m = m.assoc(kw, val);
//+				}
//+			} else if(key instanceof Symbol) {
//+				Symbol s = (Symbol) key;
//+				if (s.getNamespace() == null) {
//+					m = m.assoc(Symbol.intern(ns, s.getName()), val);
//+				} else if (s.getNamespace().equals("_")) {
//+					m = m.assoc(Symbol.intern(null, s.getName()), val);
//+				} else {
//+					m = m.assoc(s, val);
//+				}
//+			} else {
//+				m = m.assoc(key, val);
//+			}
//+		}
//+		return m;
//+	}
//+}
// try tagged reader
//int startLine = -1;
//int startCol = -1;
//LineNumberingTextReader lntr = r as LineNumberingTextReader;
//if (lntr != null)
//{
//    startLine = lntr.LineNumber;
//    startCol = lntr.ColumnNumber;
//}
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\EnumeratorSeq.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: Rethink this now that we have the lazy version of clojure.
// There's no way to do this properly.  
// If the enumerator is uninitialized, we have to do a move next to see if there is an element.
// If the enumerator is initialized, we should see if calling Current throws an exception.  Sigh.
// Okay, try this:  access Current.  If it blows, assume we are not initialized.
// Okay, that takes a _long_ time.  Lots of Exceptions thrown/caught.
// Maybe the new lazy version will solve this.
//bool hasElement = true;
//try {
//    object o = enumerator.Current;
//}
//catch ( InvalidOperationException )
//{
//    // we are before the beginning.
//    hasElement = enumerator.MoveNext();
//}
/// <summary>
/// Construct an EnumeratorSeq during deserialization.
/// </summary>
/// <param name="info"></param>
/// <param name="context"></param>
// Java: _state._rest = create(_enumerator);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\ExceptionInfo.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Exception that carries data (a map) as additional payload.
/// </summary>
/// <remarks> Clojure programs that need
/// richer semantics for exceptions should use this in lieu of defining project-specific
/// exception classes.</remarks>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Fn.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Marks an object that can be used in a functional position in a Clojure form.
/// </summary>
// marker interface
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\FuncTypes.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Future.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Implements IDeref and java.util.concurrent.Future, like the proxy in JVM clojure core.
/// </summary>
// TODO: Use a cached thread pool when agents have one.
// Worker method to execute the task.
/// <summary>
///
/// </summary>
/// <returns>True if the task completed due to normal completion, cancellation,
/// or an exception.</returns>
/// <summary>
/// Attempts to abort the future.
/// </summary>
/// <returns>True if the attempt succeeds. False if the task already completed
/// or was cancelled previously.</returns>
// Already completed or cancelled.
// Don't abort until the task thread has established its ThreadAbortException catch block.
/// <summary>
/// Attempts to abort the future.
/// </summary>
/// <returns>True if the attempt succeeds. False if the task already completed
/// or was cancelled previously.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IAtom.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IAtom2.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IBlockingDeref.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IChunk.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IChunkedSeq.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IDeref.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents something that can dereference.
/// </summary>
/// <summary>
/// Gets the (immutable) value the reference is holding.
/// </summary>
/// <returns>The value</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IEditableCollection.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IExceptionInfo.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IFn.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents an object that can be used a function.
/// </summary>
/// <remarks>
/// <para>
/// <c>IFn</c> provides complete access to invoking
/// any of Clojure's <a href="http://clojure.github.io/clojure/">API</a>s.
/// You can also access any other library written in Clojure, after adding
/// either its source or compiled form to the classpath.</para>
/// </remarks>
// Callable, Runnable -- no equivalents
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IFnArity.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Interface supporting an IFn reporting what arities is supports
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IFnClosure.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// This is essentially identical to DLR's System.Runtime.CompilerServices.Closure.
// Because it does the exact same thing.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IHashEq.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IKeywordLookup.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IKVReduce.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/* rich 7/20/15 */
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\ILookup.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents an object that supports value lookup by key.
/// </summary>
/// <summary>
/// Gets the value associated with a key.
/// </summary>
/// <param name="key">The key to look up.</param>
/// <returns>The associated value. (Throws an exception if key is not present.)</returns>
/// <summary>
/// Gets the value associated with a key.
/// </summary>
/// <param name="key">The key to look up.</param>
/// <param name="notFound">The value to return if the key is not present.</param>
/// <returns>The associated value (or <c>notFound</c> if the key is not present.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\ILookupSite.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\ILookupThunk.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IMapEntry.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Defines a key/value pair.  Immutable.
/// </summary>
/// <remarks>
/// <para>Lowercase-named methods for JVM compatibility.</para>
/// <para>In JVM version, this interface extends Map.Entry.  The equivalent BCL type is either <c>KeyValuePair<object,object></c> 
/// or <c>DictionaryEntry</c>
/// both of which are structs and hence can't be derived from.</para>
/// </remarks>
/// <summary>
/// Get the key in a key/value pair.
/// </summary>
/// <returns>The key.</returns>
/// <summary>
/// Get the value in a key/value pair.
/// </summary>
/// <returns>The value.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IMapEnumerable.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Indicate a map can provide more efficient key and val iterators.
/// </summary>
/// <remarks>
/// Equivalent to IMapIterable in ClojureJVM.
/// </remarks>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IMeta.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents an object that can have metadata attached.
/// </summary>
/// <summary>
/// Gets the metadata attached to the object.
/// </summary>
/// <returns>An immutable map representing the object's metadata.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Indexed.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Returns the n-th item.
/// </summary>
/// <param name="i">Index of the item to access</param>
/// <returns>The item at the given index</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IndexedSeq.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Indicates a sequence that has a current index.
/// </summary>
/// <summary>
/// Gets the index associated with this sequence.
/// </summary>
/// <returns>The index associated with this sequence.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IObj.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents an object that creates a copy with new metadata.
/// </summary>
/// <summary>
/// Create a copy with new metadata.
/// </summary>
/// <param name="meta">The new metadata.</param>
/// <returns>A copy of the object with new metadata attached.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IPending.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IPersistentCollection.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents an immutable collection.
/// </summary>
/// <remarks>
/// <para>Lowercase-named methods for compatibility with JVM code.</para>
/// </remarks>
/// <summary>
/// Gets the number of items in the collection.
/// </summary>
/// <returns>The number of items in the collection.</returns>
/// <summary>
/// Returns a new collection that has the given element cons'd on front of the existing collection.
/// </summary>
/// <param name="o">An item to put at the front of the collection.</param>
/// <returns>A new immutable collection with the item added.</returns>
/// <summary>
/// Gets an empty collection of the same type.
/// </summary>
/// <returns>An emtpy collection.</returns>
/// <summary>
/// Determine if an object is equivalent to this (handles all collections).
/// </summary>
/// <param name="o">The object to compare.</param>
/// <returns><c>true</c> if the object is equivalent; <c>false</c> otherwise.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IPersistentList.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents an immutable list. (sequential + stack + collection)
/// </summary>
// empty
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IPersistentMap.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents an immutable map (key/value collection).
/// </summary>
/// <summary>
/// Add a new key/value pair.
/// </summary>
/// <param name="key">The key</param>
/// <param name="val">The value</param>
/// <returns>A new map with key+value added.</returns>
/// <remarks>Overwrites an exising value for the <paramref name="key"/>, if present.</remarks>
/// <summary>
/// Add a new key/value pair.
/// </summary>
/// <param name="key">The key</param>
/// <param name="val">The value</param>
/// <returns>A new map with key+value added.</returns>
/// <remarks>Throws an exception if <paramref name="key"/> has a value already.</remarks>
/// <summary>
/// Remove a key entry.
/// </summary>
/// <param name="key">The key to remove</param>
/// <returns>A new map with the key removed (or the same map if the key is not contained).</returns>
/// <summary>
/// Add a new key/value pair.
/// </summary>
/// <param name="obj">The key/value pair to add.</param>
/// <returns>A new map with key+value pair added.</returns>
/// <remarks><para>Overrides <c>cons</c> in <see cref="IPersistentCollection">IPersistentCollection</see> 
/// to specialize the return value.</para>
/// <para>The object can be many things representing a key/value pair, including <c>DictionaryEntry</c>s,
/// <c>KeyValuePair&lt;,&gt;</c>, an <see cref="IMapEntry">IMapEntry</see>, an <see cref="IPersistentVector">IPersistentVector</see>
/// of two elements, etc.</para></remarks>
/// <summary>
/// Gets the number of items in the collection.
/// </summary>
/// <returns>The number of items in the collection.</returns>
/// <remarks>Overrides <c>count()</c> in both <see cref="IPersistentCollection">IPersistentCollection</see> 
/// and <see cref="Counted">Counted</see> to resolve ambiguity for callers.</remarks>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IPersistentSet.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents an immutable set (collection of unique elements).
/// </summary>
/// <summary>
/// Get a set with the given item removed.
/// </summary>
/// <param name="key">The item to remove.</param>
/// <returns>A new set with the item removed.</returns>
/// <summary>
/// Test if the set contains the key.
/// </summary>
/// <param name="key">The value to test for membership in the set.</param>
/// <returns>True if the item is in the collection; false, otherwise.</returns>
/// <summary>
/// Get the value for the key (= the key itself, or null if not present).
/// </summary>
/// <param name="key">The value to test for membership in the set.</param>
/// <returns>the key if the key is in the set, else null.</returns>
/// <summary>
/// Gets the number of items in the collection.
/// </summary>
/// <returns>The number of items in the collection.</returns>
/// <remarks>Overrides <c>count()</c> in both <see cref="IPersistentCollection">IPersistentCollection</see> 
/// and <see cref="Counted">Counted</see> to resolve ambiguity for callers.</remarks>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IPersistentStack.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents an immutable collection with stack operations.
/// </summary>
/// <summary>
/// Peek at the top (first) element in the stack.
/// </summary>
/// <returns>The top (first) element.</returns>
/// <summary>
/// Returns a new stack with the top element popped.
/// </summary>
/// <returns>The new stack.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IPersistentVector.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents an immutable vector (int-indexing).
/// </summary>
/// <summary>
/// Gets the number of items in the vector.
/// </summary>
/// <returns>The number of items.</returns>
/// <remarks>Not sure why you wouldn't use <c>count()</c> intead.</remarks>
/// <summary>
/// Return a new vector with the i-th value set to <c>val</c>.
/// </summary>
/// <param name="i">The index of the item to set.</param>
/// <param name="val">The new value</param>
/// <returns>A new (immutable) vector v with v[i] == val.</returns>
/// <summary>
/// Creates a new vector with a new item at the end.
/// </summary>
/// <param name="o">The item to add to the vector.</param>
/// <returns>A new (immutable) vector with the objected added at the end.</returns>
/// <remarks>Overrides <c>cons</c> in <see cref="IPersistentCollection">IPersistentCollection</see> to specialize the return value.</remarks>
/// <summary>
/// Gets the number of items in the collection.
/// </summary>
/// <returns>The number of items in the collection.</returns>
/// <remarks>Overrides <c>count()</c> in both <see cref="IPersistentCollection">IPersistentCollection</see> 
/// and <see cref="Counted">Counted</see> to resolve ambiguity for callers.</remarks>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IProxy.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IRecord.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IReduce.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents a collection that supports function mapping/reduction.
/// </summary>
/// <summary>
/// Reduce the collection using a function.
/// </summary>
/// <param name="f">The function to apply.</param>
/// <returns>The reduced value</returns>
/// <remarks>Computes f(...f(f(f(i0,i1),i2),i3),...).</remarks>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IReduceInit.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents a collection that supports function mapping/reduction.
/// </summary>
/// <summary>
/// Reduce the collection using a function.
/// </summary>
/// <param name="f">The function to apply.</param>
/// <param name="start">An initial value to get started.</param>
/// <returns>The reduced value</returns>
/// <remarks>Computes f(...f(f(f(start,i0),i1),i2),...).</remarks>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IRef.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents a reference to a value.
/// </summary>
/// <remarks>
/// <para><see cref="IRef">IRef</see> is the basic interface supported 
/// by <see cref="Ref">Ref</see>s, <see cref="Agent">Agent</see>s, 
/// <see cref="Atom">Atom</see>s, <see cref="Var">Var</see>s, and 
/// other references to values.  Many</para>
/// <para>This interface supports  
/// getting/setting the validator for the value, and getting/setting watchers.  
/// Dereferencing is supplied in interface <see cref="IDeref">IDeref</see>.
/// This interface does not support changes to values.  Changes are the responsibility of the implementations of this interface,
/// and often have to be done in concert with <see cref="LockingTransaction">LockingTransaction</see>.</para>
/// <para>The validator function will be applied to any new value before that value is applied.  
/// If the validator throws an exception or returns false, changing the reference to the new value is aborted.  
/// When setting a new validator, it must validate the current value.</para>
/// <para>A reference can be watched by one or more <see cref="Agent">Agent</see>s. The agent will be sent a message when the value changes.</para>
/// </remarks>
/// <summary>
/// Sets the validator.
/// </summary>
/// <param name="vf">The new validtor</param>
/// <summary>
/// Gets the validator.
/// </summary>
/// <returns>The current validator.</returns>
/// <summary>
/// Gets a map of watchers (key=Agent, value=IFn).
/// </summary>
/// <returns>A (immutable) map of watchers (key=Agent, value=IFn). </returns>
/// <summary>
/// Adds a new watcher.
/// </summary>
/// <param name="key">A key for referring to the watcher.</param>
/// <param name="callback">The 'message' to send when the value changes.</param>
/// <returns></returns>
/// <summary>
/// Remove a watcher.
/// </summary>
/// <param name="key">The key for the watcher to be removed.</param>
/// <returns>This IRef (for chaining).</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IReference.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents an object with settable metadata.
/// </summary>
/// <summary>
/// Alter the metadata on the object.
/// </summary>
/// <param name="alter">A function to apply to generate the new metadata</param>
/// <param name="args">Arguments to apply the function to.</param>
/// <returns>The new metadata map.</returns>
/// <remarks>The new value will be the result of <c>(apply alter (cons currentMeta args))</c>.</remarks>
/// <summary>
/// Set the metadata of the object.
/// </summary>
/// <param name="m">The new metadata map</param>
/// <returns>The new metadata map.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\ISeq.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// A persistent, functional, sequence interface.  Immutable values, not changed by any method in the interface.
/// </summary>
/// <remarks><para>Being a non-null ISeq implies that there is at least one element.  
/// A null value for <c>rest()</c> implies the end of the sequence.</para>
/// A standard iteration is of the form:
/// <code>
/// for ( ISeq s = init;  s != null; s = s.rest() )
/// {
///   ... s.first() ...
/// }
/// </code>
/// </remarks>
/// <summary>
/// Gets the first item.
/// </summary>
/// <returns>The first item.</returns>
///// <summary>
///// Gets the rest of the sequence.
///// </summary>
///// <returns>The rest of the sequence, or <c>null</c> if no more elements.</returns>
//ISeq rest();
/// <summary>
/// Return a seq of the items after the first.  Calls <c>seq</c> on its argument.  If there are no more items, returns nil."
/// </summary>
/// <returns>A seq of the items after the first, or <c>nil</c> if there are no more items.</returns>
/// <summary>
/// Adds an item to the beginning of the sequence.
/// </summary>
/// <param name="o">The item to add.</param>
/// <returns>A new sequence containing the new item in front of the items already in the sequence.</returns>
/// <remarks>This overrides the <c>cons</c> method in <see cref="IPersistentCollection">IPersistentCollection</see>
/// by giving an <see cref="ISeq">ISeq</see> in return.</remarks>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Iterate.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/* Alex Miller, Dec 5, 2014 */
/**
// never null
// lazily realized
// cached
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\ITransientAssociative.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\ITransientAssociative2.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\ITransientCollection.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\ITransientMap.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Add a new key/value pair.
/// </summary>
/// <param name="key">The key</param>
/// <param name="val">The value</param>
/// <returns>A new map with key+value added.</returns>
/// <remarks>Overwrites an exising value for the <paramref name="key"/>, if present.</remarks>
/// <summary>
/// Remove a key entry.
/// </summary>
/// <param name="key">The key to remove</param>
/// <returns>A new map with the key removed (or the same map if the key is not contained).</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\ITransientSet.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\ITransientVector.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\IType.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\JavaConcurrentDictionary.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Faking a few of the methods from the Java ConcurrentHashTable class.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\JReMatcher.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Shim class to provide java.util.regex.Matcher capabilities for the re-* functions in core.clj.
/// </summary>
// I'll even keep the names lowercase to match java.util.regex.Matcher
// Careful analysis of the re-* methods in core.clj reveal that exactly these are needed.
// I don't implement the full functionality. 
// This needs to be called on the first attempt to make a match
//  because we have to rewrite the regex pattern to match the whole string
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Keyword.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents a keyword
/// </summary>
// ??JAVA only used IFn, not AFn.  NOt sure why.
/// <summary>
/// The symbol giving the namespace/name (without :) of the keyword.
/// </summary>
/// <summary>
/// Caches the hasheq value for the keyword.
/// </summary>
/// <summary>
/// Map from symbol to keyword to uniquify keywords.
/// </summary>
/// <remarks>Why introduce the JavaConcurrentDictionary?  
/// We really only need a synchronized hash table with one operation: PutIfAbsent.</remarks>
// cache ToString if called
/// <summary>
/// Create (or find existing) keyword with given symbol's namespace/name.
/// </summary>
/// <param name="sym">The symbol giving the keyword's namespace/name.</param>
/// <returns>A keyword</returns>
// entry died in the interim, do over
// let's not get confused, remove it.  (else infinite loop).
/// <summary>
/// Create (or find existing) keyword with given namespace/name.
/// </summary>
/// <param name="ns">The keyword's namespace name.</param>
/// <param name="name">The keyword's name.</param>
/// <returns>A keyword</returns>
/// <summary>
/// Create (or find existing) keyword with the given name.
/// </summary>
/// <param name="nsname">The keyword's name</param>
/// <returns>A keyword</returns>
/// <summary>
/// Construct a keyword based on a symbol.
/// </summary>
/// <param name="sym">A symbol giving namespace/name.</param>
/// <summary>
/// Returns a string representing the keyword.
/// </summary>
/// <returns>A string representing the keyword.</returns>
/// <summary>
/// Determines if an object is equal to this keyword.  Value semantics.
/// </summary>
/// <param name="obj">The object to compare to.</param>
/// <returns><value>true</value> if equal; <value>false</value> otherwise.</returns>
/// <summary>
/// Gets a hash code for the keyword.
/// </summary>
/// <returns>A hash code.</returns>
//  I prefer to use the following internally.
/// <summary>
/// The namespace name.
/// </summary>
/// <summary>
/// The name.
/// </summary>
// the following are in the interface
/// <summary>
/// Gets the namespace name.
/// </summary>
/// <returns>The namespace name.</returns>
/// <summary>
/// Gets the name.
/// </summary>
/// <returns>The name.</returns>
/// <summary>
/// (:keyword arg)  => (get arg :keyword)
/// </summary>
/// <param name="arg1">The object to access.</param>
/// <returns>The value mapped to the keyword.</returns>
/// <summary>
/// (:keyword arg default) => (get arg :keyword default)
/// </summary>
/// <param name="arg1">The object to access.</param>
/// <param name="arg2">Default value if not found.</param>
/// <returns></returns>
/// <summary>
/// Compare this to another object.
/// </summary>
/// <param name="obj">The object to compare to.</param>
/// <returns>neg,zero,pos for &lt; = &gt;</returns>
// Instead of serializing the keyword,
// serialize a KeywordSerializationHelper instead
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\KeywordLookupSite.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\LazilyPersistentVector.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// A persistent vector based on an array.  Holds a lazily-allocated <see cref="PersistentVector">PersistentVector</see>
/// if operations such as <see cref="LazilyPersistentVector.assoc()">assoc()</see> 
/// are called that require a true persistent collection.
/// </summary>
/// <summary>
/// Create a <see cref="LazilyPersistentVector">LazilyPersistentVector</see> for an array of items.
/// </summary>
/// <param name="items">An array of items</param>
/// <returns>A <see cref="LazilyPersistentVector">LazilyPersistentVector</see>.</returns>
//if (items.Length <= Tuple.MAX_SIZE)
//    return Tuple.createFromArray(items);
//else 
//: new LazilyPersistentVector(null, items, null);
//static int fcount(Object c)
//{
//    if (c == null)  // not in Java version.  How did this pass tests?
//        return 0;
//    Counted ctd = c as Counted;
//    if (ctd != null)
//        return ctd.count();
//    String s = c as String;   // not in Java version.  How did this pass tests?
//    if (s != null)
//        return s.Length;
//    return ((ICollection)c).Count;
//}
/// <summary>
/// Create a <see cref="LazilyPersistentVector">LazilyPersistentVector</see> from an ICollection of items.
/// </summary>
/// <param name="coll">The collection of items.</param>
/// <returns>A <see cref="LazilyPersistentVector">LazilyPersistentVector</see>.</returns>
//if ((obj is Counted || RT.SupportsRandomAccess(obj))
//    && fcount(obj) <= Tuple.MAX_SIZE)
//    return Tuple.createFromColl(obj);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\LazySeq.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// Should we do IList -- has index accessor
/// <summary>
/// Gets an <see cref="ISeq"/>to allow first/rest/next iteration through the collection.
/// </summary>
/// <returns>An <see cref="ISeq"/> for iteration.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\LispReader.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//using BigDecimal = java.math.BigDecimal;
/// <summary>
/// Implements the Lisp reader, a marvel to behold.
/// </summary>
//static readonly Symbol READ_COND = Symbol.intern("clojure.core", "read-cond");
//static readonly Symbol READ_COND_SPLICING = Symbol.intern("clojure.core", "read-cond-splicing");
//static readonly Symbol META = Symbol.intern("clojure.core", "meta");
//symbol->gensymbol
/// <summary>
/// Dynamically bound var to a map from <see cref="Symbol">Symbol</see>s to ...
/// </summary>
//sorted-map num->gensymbol
// Dynamic var set to true in a read-cond context
//new DerefReader();
////	macros['|'] = new ArgVectorReader();            
// Reader opts
// EOF special value to throw on eof
// Platform features - always installed
// Reader conditional options - use with :read-cond
// no op macros return the reader
//string token = readToken(r, (char)ch);
//return RT.suppressRead() ? null : interpretToken(token);
// Roughly a match to Java Character.digit(char,int),
// though I don't handle all unicode digits.
// Sentinel values for reading lists
// RT.T
// RT.F;
//static Regex symbolPat = new Regex("[:]?([\\D&&[^/]].*/)?(/|[\\D&&[^/]][^/]*)");
// auto-resolving keyword
// auto-resolving keyword
//    // either namespaceToken is null or containts
//    // no :: except at beginning
//    if (token.IndexOf("::", 1) != -1)
//        return null;
//    string nsStr;
//    string nameStr;
//    bool hasNS;
//    if (lastSlashIndex == -1)
//    {
//        hasNS = false;
//        nsStr = String.Empty;
//        nameStr = token;
//    }
//    else
//    {
//        hasNS = true;
//        nsStr = token.Substring(0, lastSlashIndex);
//        nameStr = token.Substring(lastSlashIndex + 1);
//    }
//    // Must begin with non-digit, or ':' + non-digit if there is a namespace
//    Match nameMatch = hasNS ? nameSymbolPat.Match(nameStr) : nsSymbolPat.Match(nameStr);
//    if (!nameMatch.Success)
//        return null;
//    // no trailing :
//    if (nameStr.EndsWith(":"))
//        return null;
//    if (hasNS)
//    {
//        // Must begin with non-digit or ':' + non-digit
//        Match nsMatch = nsSymbolPat.Match(nsStr);
//        if (!nsMatch.Success)
//            return null;
//        // no trailing :
//        if (nsStr.EndsWith(":"))
//            return null;
//    }
//    // Do keyword detection
//    if (hasNS)
//    {
//        if (nsStr.StartsWith("::"))
//        {
//            Symbol nsSym = Symbol.intern(nsStr.Substring(2));
//            Namespace ns = Compiler.CurrentNamespace.LookupAlias(nsSym);
//            if (ns == null)
//                ns = Namespace.find(nsSym);
//            if (ns == null)
//                return null;
//            else
//                return Keyword.intern(ns.Name.getName(), nameStr);
//        }
//        else if (nsStr.StartsWith(":"))
//            return Keyword.intern(nsStr.Substring(1), nameStr);
//        else
//            return Symbol.intern(nsStr, nameStr);
//    }
//    else
//    {
//        if ( nameStr.StartsWith("::"))
//            return Keyword.intern(Compiler.CurrentNamespace.Name.getName(),nameStr.Substring(2));
//        else if ( nameStr.StartsWith(":") )
//            return Keyword.intern(nameStr.Substring(1));
//        else
//            return Symbol.intern(null,nameStr);  // Avoid / interpretation in intern(string)
//    }
//}
// Contains bad character
// contains a :: anywhere
// Begins with +/- and a digit
// matched 0  or 0N only
// N suffix
// MS implementation of java.util.BigDecimal has a bug when the string has a leading+
//if ( val[0] == '+' )
//    val = val.Substring(1);
// There is a bug in the BigInteger c-tor that causes it barf on a leading +.
//return Numbers.BIDivide(new BigInteger(numerString), new BigInteger(denomString));
// surrogate code unit?
//octal377
//escape
//if (CharValueInRadix(ch, 8) != -1)  -- this is correct, but we end up with different error message for 8,9 than JVM, so do the following to match:
//octal377
// We add a :source-span key, value is map with the other values.
// A map is used here so that we are print-dup--serializable.
// :a.b{:c 1} => {:a.b/c 1}
// ::{:c 1}   => {:a.b/c 1}  (where *ns* = a.b)
// ::a{:c 1}  => {:a.b/c 1}  (where a is aliased to a.b)
// the #:: { } case or an error
// #:foo { } or #::foo { }
// Resolve autoresolved ns
// Read map
// Construct output map
//IPersistentMap m = RT.map();
//object o = read(r, true, null, true, opts, pendingForms);
//object o = read(r, true, null, true, opts, pendingForms);
//object form = read(r, true, null, true, opts, pendingForms);
//filter line numbers & source span info
// simply quote method names
//Classname/foo => package.qualified.Classname/foo
// leave alone if no qualified
// Classname/foo -> package.qualified.Classname/foo
//if (item is Unquote)
//    ret = ret.cons(RT.list(LIST, ((Unquote)item).Obj));
// REV 1184
//object o = read(r, true, null, true, opts, pendingForms);
//object o = read(r, true, null, true, opts, pendingForms);
//return new Unquote(o);
// per Rev 1184
// Per rev 1184
// Try the ctor reader first
//object o = read(r, true, null, true, opts, pendingForms);
//		if(o instanceof Symbol)
//			{
//			Object v = Compiler.maybeResolveIn(Compiler.currentNS(), (Symbol) o);
//			if(v instanceof Var)
//				return v;
//			}
//escape
//static ListReader _listReader = new ListReader();
////object form = ReadAux(r, true, null, true, opts, pendingForms);
//object form = _listReader.invoke(r, '(');
//if (ARG_ENV.deref() == null)
//    return interpretToken(readToken(r, '%'));
//% alone is first arg
//object n = ReadAux(r, true, null, true, opts, pendingForms);
//TODO: Need to figure out who to deal with typenames in the context of multiple loaded assemblies.
//Compiler.resolve((Symbol) RT.second(o),true);
//return Reflector.InvokeConstructor(RT.classForName(fs.Name.Substring(0, fs.Name.Length - 1)), args);
// I think the JVM code is wrong here
// shortForm
/* RT.T */));
// should always be a list
// The most recently ready form
// Read the next feature
// read-cond form is done
//Read the form corresponding to the feature, and assign it to result if everything is kosher
// When we already have a result, or when the feature didn't match, discard the next form in the reader
/* RT.T */));
// no features matched
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\LockingTransaction.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Provides transaction semantics for <see cref="Agent">Agent</see>s, <see cref="Ref">Ref</see>s, etc.
/// </summary>
/// <summary>
/// The number of times to retry a transaction in case of a conflict.
/// </summary>
/// <summary>
/// How long to wait for a lock.
/// </summary>
/// <summary>
/// How old another transaction must be before we 'barge' it.
/// </summary>
/// <remarks>
/// Java version has BARGE_WAIT_NANOS, set at 10*1000000.
/// If I'm thinking correctly tonight, that's 10 milliseconds.
/// Ticks here are 100 nanos, so we should have  10 * 1000000/100 = 100000.
/// </remarks>
// State constants
// Should be an enum, but we want Interlocked capability
/// <summary>
/// Value: The transaction is running.
/// </summary>
/// <summary>
/// Value: The transaction is committing.
/// </summary>
/// <summary>
/// Value: the transaction is getting ready to retry.
/// </summary>
/// <summary>
/// The transaction has been killed.
/// </summary>
/// <summary>
/// The transaction has been committed.
/// </summary>
/// <summary>
/// Exception thrown when a retry is necessary.
/// </summary>
/// <summary>
/// Exception thrown when a transaction has been aborted.
/// </summary>
/// <summary>
/// The current state of a transaction.
/// </summary>
/// <summary>
/// The status of the transaction.
/// </summary>
/// <summary>
/// The status of the transaction.
/// </summary>
/// <summary>
/// The start point of the transaction.
/// </summary>
/// <summary>
/// The start point of the transaction.
/// </summary>
/// <summary>
/// Construct an info.
/// </summary>
/// <param name="status">Current status.</param>
/// <param name="startPoint">Start point.</param>
/// <summary>
/// Is the transaction running?
/// </summary>
/// <summary>
/// Pending call of a function on arguments.
/// </summary>
/// <summary>
///  The function to be called.
/// </summary>
/// <summary>
///  The function to be called.
/// </summary>
/// <summary>
/// The arguments to the function.
/// </summary>
/// <summary>
/// The arguments to the function.
/// </summary>
/// <summary>
/// Construct one.
/// </summary>
/// <param name="fn">The function to invoke.</param>
/// <param name="args">The arguments to invoke the function on.</param>
/// <summary>
/// The transaction running on the current thread.  (Thread-local.)
/// </summary>
/// <summary>
/// The current point.
/// </summary>
/// <remarks>
/// <para>Used to provide a total ordering on transactions 
/// for the purpose of determining preference on transactions 
/// when there are conflicts.  
/// Transactions consume a point for init, for each retry, 
/// and on commit if writing.</para>
/// </remarks>
/// <summary>
///  The state of the transaction.
/// </summary>
/// <remarks>Encapsulated so things like Refs can look.</remarks>
/// <summary>
/// The point at the start of the current retry (or first try).
/// </summary>
/// <summary>
/// The point at the start of the transaction.
/// </summary>
/// <summary>
/// The system ticks at the start of the transaction.
/// </summary>
/// <summary>
/// Cached retry exception.
/// </summary>
/// <summary>
/// Agent actions pending on this thread.
/// </summary>
/// <summary>
/// Ref assignments made in this transaction (both sets and commutes).
/// </summary>
/// <summary>
/// Refs that have been set in this transaction.
/// </summary>
/// <summary>
/// Ref commutes that have been made in this transaction.
/// </summary>
/// <summary>
/// The set of Refs holding read locks.
/// </summary>
//string TId() 
//{ 
//    return String.Format("<{0}:{1}>", Thread.CurrentThread.ManagedThreadId, _readPoint);
//}
/// <summary>
/// Get a new read point value.
/// </summary>
/// <summary>
/// Get a commit point value.
/// </summary>
/// <returns></returns>
/// <summary>
/// Stop this transaction.
/// </summary>
/// <param name="status">The new status.</param>
// Java commented out: _actions.Clear();
//stop prior to blocking
//ignore
/// <summary>
/// Lock a ref.
/// </summary>
/// <param name="r">The ref to lock.</param>
/// <returns>The most recent value of the ref.</returns>
// can't upgrade read lock, so release it.
// write lock conflict
/// <summary>
/// Kill this transaction.
/// </summary>
/// <summary>
/// Determine if sufficient clock time has elapsed to barge another transaction.
/// </summary>
/// <returns><value>true</value> if enough time has elapsed; <value>false</value> otherwise.</returns>
/// <summary>
/// Try to barge a conflicting transaction.
/// </summary>7
/// <param name="refinfo">The info on the other transaction.</param>
/// <returns><value>true</value> if we killed the other transaction; <value>false</value> otherwise.</returns>
// if this transaction is older
//   try to abort the other
/// <summary>
/// Get the transaction running on this thread (throw exception if no transaction). 
/// </summary>
/// <returns>The running transaction.</returns>
/// <summary>
/// Get the transaction running on this thread (or null if no transaction).
/// </summary>
/// <returns>The running transaction if there is one, else <value>null</value>.</returns>
/// <summary>
/// Is there a transaction running on this thread?
/// </summary>
/// <returns><value>true</value> if there is a transaction running on this thread; <value>false</value> otherwise.</returns>
/// <remarks>Initial lowercase in name for core.clj compatibility.</remarks>
/// <summary>
/// Invoke a function in a transaction
/// </summary>
/// <param name="fn">The function to invoke.</param>
/// <returns>The value computed by the function.</returns>
/// <remarks>Initial lowercase in name for core.clj compatibility.</remarks>
// TODO: This can be called on something more general than  an IFn.
// We can could define a delegate for this, probably use ThreadStartDelegate.
// Should still have a version that takes IFn.
/// <summary>
/// Start a transaction and invoke a function.
/// </summary>
/// <param name="fn">The function to invoke.</param>
/// <returns>The value computed by the function.</returns>
// TODO: Define an overload called on ThreadStartDelegate or something equivalent.
// make sure no one has killed us before this point,
// and can't from now on
// can't upgrade read lock, so release
// validate and enqueue notifications
// at this point, all values calced, all refs to be written locked
// no more client code to be called
// eat this so we retry rather than fall out
// Wrapped exception, eat it.
// re-dispatch out of transaction
/// <summary>
/// Determine if the exception wraps a <see cref="RetryEx">RetryEx</see> at some level.
/// </summary>
/// <param name="ex">The exception to test.</param>
/// <returns><value>true</value> if there is a nested  <see cref="RetryEx">RetryEx</see>; <value>false</value> otherwise.</returns>
/// <remarks>Needed because sometimes our retry exceptions get wrapped.  You do not want to know how long it took to track down this problem.</remarks>
/// <summary>
/// Add an agent action sent during the transaction to a queue.
/// </summary>
/// <param name="action">The action that was sent.</param>
/// <summary>
/// Get the value of a ref most recently set in this transaction (or prior to entering).
/// </summary>
/// <param name="r"></param>
/// <param name="tvals"></param>
/// <returns>The value.</returns>
// no version of val precedes the read point
/// <summary>
/// Set the value of a ref inside the transaction.
/// </summary>
/// <param name="r">The ref to set.</param>
/// <param name="val">The value.</param>
/// <returns>The value.</returns>
/// <summary>
/// Touch a ref.  (Lock it.)
/// </summary>
/// <param name="r">The ref to touch.</param>
// someone completed a write after our shapshot
// writer exists
// not us, ensure is doomed
/// <summary>
/// Post a commute on a ref in this transaction.
/// </summary>
/// <param name="r">The ref.</param>
/// <param name="fn">The commuting function.</param>
/// <param name="args">Additional arguments to the function.</param>
/// <returns>The computed value.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\LongRange.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Implements the special common case of a finite range based on long start, end, and step.
/// </summary>
// Invariants guarantee this is never an empty or infinite seq
//   assert(start != end && step != 0)
// lazy
// lazy
// cached
// this is a one method interface in the JVM version
// Originally, I converted it to a delegate.
// Subsequently, they decided to make this class serializable, and serializability and lambdas/delegates do not mix.
// So I'm moving to the JVM solution.  Sigh.
// size of total range is > Long.MAX_VALUE so must step to count
// this only happens in pathological range cases like:
// (range -9223372036854775808 9223372036854775807 9223372036854775807)
// not last chunk
// cannot overflow, must be < end
// last chunk
// count must 
// fallback count mechanism for pathological cases
// returns either exact count or CHUNK_SIZE+1
// returns exact size of remaining items OR throws ArithmeticException for overflow case
// (1) count = ceiling ( (end - start) / step )
// (2) ceiling(a/b) = (a+b+o)/b where o=-1 for positive stepping and +1 for negative stepping
// thus: count = end - start + step + o / step
// rare case from large range or step, fall back to iterating and counting
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\MapEntry.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Implements an (immutable) entry in a persistent map.
/// </summary>
/// <remarks>
/// <para>In built-in BCL collections, this is a struct.  We cannot do this here 
/// because of all the other baggage this carries 
/// (see <see cref="AMapEntry">AMapEntry</see>.</para>
/// <para>Provides storage for a key and a value.  What more can be said?</para></remarks>
//Should we make this a sealed class? Any reason we need to derive from this?
/// <summary>
/// The key.
/// </summary>
/// <summary>
/// The value.
/// </summary>
/// <summary>
/// Initialize a <see cref="MapEntry">MapEntry</see> with a key and a value.
/// </summary>
/// <param name="key">The key.</param>
/// <param name="val">The value.</param>
/// <summary>
/// Get the key in a key/value pair.
/// </summary>
/// <returns>The key.</returns>
/// <summary>
/// Get the value in a key/value pair.
/// </summary>
/// <returns>The value.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\MapEnumerator.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Provides an IDictionaryEnumerator running over a <see cref="SeqEnumerator">SeqEnumerator</see>.
/// </summary>
/// <remarks>
/// <para>Mirrors <see cref="SeqEnumerator">SeqEnumerator</see>.</para> 
/// <para>No equivalent in Java version.</para>
/// <para>The map provides <see cref="IMapEntry">IMapEntry</see> key/value pairs.  
/// This converts an <see cref="IMapEntry">IMapEntry</see> to a DictionaryEntry.
/// </para>
/// </remarks>
/// <summary>
/// The <see cref="SeqEnumerator">SeqEnumerator</see> to iterate over.
/// </summary>
/// <summary>
/// The key of the current entry.
/// </summary>
/// <summary>
/// The value of the current entry.
/// </summary>
/// <summary>
/// Construct a <see cref="MapEnumerator">MapEnumerator</see> from a persistent map.
/// </summary>
/// <param name="map">The map to iterate over.</param>
/// <summary>
/// The current entry.
/// </summary>
/// <summary>
/// The current key.
/// </summary>
/// <summary>
/// The current value.
/// </summary>
/// <summary>
/// The current entry.
/// </summary>
/// <summary>
/// Advance to the next item.
/// </summary>
/// <returns><value>true</value> if there is a next value; <value>false</value> otherwise.</returns>
/// <summary>
/// Reset the enumerator.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\MapEquivalence.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// marker interface
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\MethodImplCache.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: This is a cache for a type=>IFn map.  Should be replaced by the DLR CallSite mechanism
//[class, entry. class, entry ...]
// //these are not volatile by design
// private object _lastType;
//// core_deftype.clj compatibility
// public object lastClass
// {
//     get { return _lastType; }
//     set { _lastType = value; }  
// }
// private IFn _lastImpl;
// // core_deftype.clj compatibility 
// public IFn lastImpl
// {
//     get { return _lastImpl; }
//     set { _lastImpl = value; }
//}
// initial lowercase for core.clj compatibility
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\MultiFn.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents a multifunction.
/// </summary>
/// <remarks>See the Clojure documentation for more details.</remarks>
/// <summary>
/// The function that dispatches calls to the correct method.
/// </summary>
/// <summary>
/// The default dispatch value.
/// </summary>
/// <summary>
/// The hierarchy for this defmulti.
/// </summary>
/// <summary>
/// The name of this multifunction.
/// </summary>
/// <summary>
/// The methods defined for this multifunction.
/// </summary>
/// <summary>
/// The methods defined for this multifunction.
/// </summary>
/// <summary>
/// Method preferences.
/// </summary>
/// <summary>
/// Method preferences.
/// </summary>
/// <summary>
/// Cache of previously encountered dispatch-value to method mappings.
/// </summary>
/// <summary>
/// Hierarchy on which cached computations are based.
/// </summary>
//static readonly Var _assoc = RT.var("clojure.core", "assoc");
//static readonly Var _dissoc = RT.var("clojure.core", "dissoc");
//static readonly Var _isa = RT.var("clojure.core", "isa?", null);  -- loading order dependent. bad.
//static readonly Var _hierarchy = RT.var("clojure.core", "global-hierarchy", null);
/// Construct a multifunction.
/// </summary>
/// <param name="name">The name</param>
/// <param name="dispatchFn">The dispatch function.</param>
/// <param name="defaultDispatchVal">The default dispatch value.</param>
/// <param name="hierarchy">The hierarchy for this multifunction</param>
/// <summary>
/// Add a new method to this multimethod.
/// </summary>
/// <param name="dispatchVal">The discriminator value for this method.</param>
/// <param name="method">The method code.</param>
/// <returns>This multifunction.</returns>
/// <summary>
/// Remove a method.
/// </summary>
/// <param name="dispatchVal">The dispatch value for the multimethod.</param>
/// <returns>This multifunction.</returns>
/// <summary>
/// Add a preference for one method over another.
/// </summary>
/// <param name="dispatchValX">The more preferred dispatch value.</param>
/// <param name="dispatchValY">The less preferred dispatch value.</param>
/// <returns>This multifunction.</returns>
/// <summary>
/// Is one value preferred over another?
/// </summary>
/// <param name="x">The first dispatch value.</param>
/// <param name="y">The second dispatch value.</param>
/// <returns><value>true</value> if <paramref name="x"/> is preferred over <paramref name="y"/></returns>
/// <summary>
/// Check the hierarchy.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns></returns>
/// <summary>
/// Determine if one dispatch is preferred over another.
/// </summary>
/// <param name="x"></param>
/// <param name="y"></param>
/// <returns></returns>
/// <summary>
/// Reset the method cache.
/// </summary>
/// <returns></returns>
/// <summary>
/// Get the method for a dispatch value.
/// </summary>
/// <param name="dispatchVal">The dispatch value.</param>
/// <returns>The preferred method for the value.</returns>
/// <remarks>lower initial letter for core.clj compatibility</remarks>
/// <summary>
/// Get the method for a dispatch value and cache it.
/// </summary>
/// <param name="dispatchVal">The disaptch value.</param>
/// <returns>The mest method.</returns>
// ensure basis has stayed stable throughout, else redo
// place in cache
/// <summary>
/// Get the map of dispatch values to dispatch fns.
/// </summary>
/// <returns>The map of dispatch values to dispatch fns.</returns>
/// <summary>
/// Get the map of preferred value to set of other values.
/// </summary>
/// <returns>The map of preferred value to set of other values.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Murmur3.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Provides Murmur3 hashing algorithm
/// </summary>
/// <remarks>
/// <para>The ClojureJVM version imported the Guava Murmur3 implementation and made some changes.</para>
/// <para>I copied the API stubs, then implemented the API based on the algorithm description at 
///     http://en.wikipedia.org/wiki/MurmurHash.
///     See also: https://code.google.com/p/smhasher/wiki/MurmurHash3. </para>
/// <para>Because the original algorithm was based on unsigned arithmetic, 
/// I built methods that implemented those directly, then built versions 
/// returning signed integers, as required by most users.</para>
/// <para>Implementation of HashUnordered and HashOrdered taken from ClojureJVM.</para>
/// </remarks>
// step through the string 2 chars at a time
// deal with remaining character if odd
// Finalization mix - force all bits of a hash block to avalanche
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Named.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents an object that has a namespace/name.
/// </summary>
/// <remarks>Lowercase-named methods for compatibility with the JVM implementation.</remarks>
/// <summary>
/// Gets the namespace name for the object.
/// </summary>
/// <returns>The namespace name.</returns>
/// <summary>
/// Gets the name of the object
/// </summary>
/// <returns>The name.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Namespace.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents a namespace for holding symbol-&gt;reference mappings.
/// </summary>
/// <remarks>
/// <para>Symbol to reference mappings come in several flavors:
/// <list>
/// <item><b>Simple:</b> <see cref="Symbol">Symbol</see> to a <see cref="Var">Var</see> in the namespace.</item>
/// <item><b>Use/refer:</b> <see cref="Symbol">Symbol</see> to a <see cref="Var">Var</see> that is homed in another namespace.</item>
/// <item>Import:</item> <see cref="Symbol">Symbol</see> to a Type
/// </list>
/// </para>
/// <para>One namespace can also refer to another namespace by an alias.</para>
/// </remarks>
/// <summary>
/// The namespace's name.
/// </summary>
/// <summary>
/// The namespace's name.
/// </summary>
/// <summary>
/// Maps <see cref="Symbol">Symbol</see>s to their values (Types, <see cref="Var">Var</see>s, or arbitrary).
/// </summary>
/// <summary>
/// Maps <see cref="Symbol">Symbol</see>s to other namespaces (aliases).
/// </summary>
// Why not use one of the IPersistentMap implementations?
/// <summary>
/// All namespaces, keyed by <see cref="Symbol">Symbol</see>.
/// </summary>
/// <summary>
/// Get the variable-to-value map.
/// </summary>
//set { mappings = value; }
/// <summary>
/// Get the variable-to-namespace alias map.
/// </summary>
/// <summary>
/// Get all namespaces.
/// </summary>
/// <summary>
/// Find or create a namespace named by the symbol.
/// </summary>
/// <param name="name">The symbol naming the namespace.</param>
/// <returns>An existing or new namespace</returns>
/// <summary>
/// Remove a namespace (by name).
/// </summary>
/// <param name="name">The (Symbol) name of the namespace to remove.</param>
/// <returns>The namespace that was removed.</returns>
/// <remarks>Trying to remove the clomure namespace throws an exception.</remarks>
/// <summary>
/// Find the namespace with a given name.
/// </summary>
/// <param name="name">The name of the namespace to find.</param>
/// <returns>The namespace with the given name, or <value>null</value> if no such namespace exists.</returns>
/// <summary>
/// Construct a namespace with a given name.
/// </summary>
/// <param name="name">The name.</param>
/// <summary>
/// Returns a string representing the namespace.
/// </summary>
/// <returns>A string representing the namespace.</returns>
/// <summary>
/// Intern a <see cref="Symbol">Symbol</see> in the namespace, with a (new) <see cref="Var">Var</see> as its value.
/// </summary>
/// <param name="sym">The symbol to intern.</param>
/// <returns>The <see cref="Var">Var</see> associated with the symbol.</returns>
/// <remarks>
/// <para>It is an error to intern a symbol with a namespace.</para>
/// <para>This has to deal with other threads also interning.</para>
/// </remarks>
// race condition
/// <summary>
/// Intern a symbol with a specified value.
/// </summary>
/// <param name="sym">The symbol to intern.</param>
/// <param name="val">The value to associate with the symbol.</param>
/// <returns>The value that is associated. (only guaranteed == to the value given).</returns>
// race condition
/// <summary>
/// Remove a symbol mapping from the namespace.
/// </summary>
/// <param name="sym">The symbol to remove.</param>
/// <summary>
/// Map a symbol to a Type (import).
/// </summary>
/// <param name="sym">The symbol to associate with a Type.</param>
/// <param name="t">The type to associate with the symbol.</param>
/// <returns>The Type.</returns>
/// <remarks>Named importClass instead of ImportType for core.clj compatibility.</remarks>
/// <summary>
/// Map a symbol to a Type (import) using the type name for the symbol name.
/// </summary>
/// <param name="t">The type to associate with the symbol</param>
/// <returns>The Type.</returns>
/// <remarks>Named importClass instead of ImportType for core.clj compatibility.</remarks>
/// <summary>
/// Add a <see cref="Symbol">Symbol</see> to <see cref="Var">Var</see> reference.
/// </summary>
/// <param name="sym"></param>
/// <param name="var"></param>
/// <returns></returns>
/// <summary>
/// Get the value mapped to a symbol.
/// </summary>
/// <param name="name">The symbol to look up.</param>
/// <returns>The mapped value.</returns>
/// <summary>
/// Find the <see cref="Var">Var</see> mapped to a <see cref="Symbol">Symbol</see>.
/// </summary>
/// <param name="sym">The symbol to look up.</param>
/// <returns>The mapped var.</returns>
/// <summary>
/// Find the <see cref="Namespace">Namespace</see> aliased by a <see cref="Symbol">Symbol</see>.
/// </summary>
/// <param name="alias">The symbol alias.</param>
/// <returns>The aliased namespace</returns>
/// <summary>
/// Add an alias for a namespace.
/// </summary>
/// <param name="alias">The alias for the namespace.</param>
/// <param name="ns">The namespace being aliased.</param>
/// <remarks>Lowercase name for core.clj compatibility</remarks>
// race condition
// you can rebind an alias, but only to the initially-aliased namespace
/// <summary>
/// Remove an alias.
/// </summary>
/// <param name="alias">The alias name</param>
/// <remarks>Lowercase name for core.clj compatibility</remarks>
/// <summary>
/// Get the namespace name.
/// </summary>
/// <returns>The <see cref="Symbol">Symbol</see> naming the namespace.</returns>
/// <summary>
/// Get the mappings of the namespace.
/// </summary>
/// <returns>The mappings.</returns>
/// <summary>
/// Get the aliases.
/// </summary>
/// <returns>A map of aliases.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Numbers.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/* 
// Interesting problem mixing long/ulong -- what should the semantics be?
// easiest is to punt.
// missing divide: uu du ud lu ul uo ou
// bigint quotient
// missing divide:  du ud lu ul uo ou
// bigint quotient
// missing remainder:  du ud lu ul uo ou
//public static object num(int x)
//{
//    return x;
//}
//return n >= 0 ? x << n : x >> -n;
//return n >= 0 ? x << n : x >> -n;
// return n >= 0 ? x >> n : x << -n;
// return n >= 0 ? x >> n : x << -n;
//static object NormalizeRet(object ret, object x, object y)
//{
//    if (ret is BigInteger && !(x is BigInteger || y is BigInteger))
//        return reduceBigInteger((BigInteger)ret);
//    return ret;
//}
// add NormalizeRet
// add NormalizeRet
// add NormalizeRet
// add NormalizeRet
// add NormalizeRet
//static readonly Ratio ONE = new Ratio(BigInteger.ONE, BigInteger.ONE);
//static readonly Ratio MINUS_ONE = new Ratio(BigInteger.NEGATIVE_ONE, BigInteger.ONE);
// TODO
//return (int)(lpart ^ (lpart >> 32));
//{
//    // Make BigInteger conform with Int64 when in Int64 range
//    long lval;
//    BigInteger bi = x as BigInteger;
//    if (bi != null && bi.AsInt64(out lval))
//        return Murmur3.HashLong(lval);
//}
// stripTrailingZeros() to make all numerically equal
// BigDecimal values come out the same before calling
// hashCode.  Special check for 0 because
// stripTrailingZeros() does not do anything to values
// equal to 0 with different scales.
// match 0.0f
//return (int)(lpart ^ (lpart >> 32));
// match 0.0
// no bignums, no decimals
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Obj.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Provides a basic implementation of <see cref="IObj">IObj</see> functionality.
/// </summary>
/// <summary>
/// The metatdata for the object.
/// </summary>
/// <summary>
/// Initializes a new instance of <see cref="Obj">Obj</see> that has null metadata.
/// </summary>
/// <summary>
/// Initializes a new instance of <see cref="Obj">Obj</see> that has 
/// the given <see cref="IPersistentMap">IPersistentMap</see> as its metadata.
/// </summary>
/// <param name="meta">The map used to initialize the metadata.</param>
/// <summary>
/// Gets the metadata attached to the object.
/// </summary>
/// <returns>An immutable map representing the object's metadata.</returns>
/// <summary>
/// Create a copy with new metadata.
/// </summary>
/// <param name="meta">The new metadata.</param>
/// <returns>A copy of the object with new metadata attached.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\PersistentArrayMap.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Implements a persistent map as an array of alternating keys/values(suitable for small maps only).
/// </summary>
/// <remarks>
/// <para>Note that instances of this class are constant values, i.e., add/remove etc return new values.</para>
/// <para>Copies the array on every change, so only appropriate for <i>very small</i> maps</para>
/// <para><value>null</value> keys and values are okay, 
/// but you won't be able to distinguish a <value>null</value> value via <see cref="valAt">valAt</see> --
/// use <see cref="contains">contains</see> or <see cref="entryAt">entryAt</see>.</para>
/// </remarks>
/// <summary>
/// The maximum number of entries to hold using this implementation.
/// </summary>
/// <remarks>
/// <para>Operations adding more than this number of entries should switch to another implementation.</para>
/// <para>The value was changed from 8 to 16 in Java Rev 1159 to improve proxy perf -- we don't have proxy yet,
/// but I changed it here anyway.</para>
/// </remarks>
/// <summary>
/// The array holding the key/value pairs.
/// </summary>
/// <remarks>The i-th pair is in _array[2*i] and _array[2*i+1].</remarks>
/// <summary>
/// An empty <see cref="PersistentArrayMap">PersistentArrayMap</see>. Constant.
/// </summary>
/// <summary>
/// Create a <see cref="PersistentArrayMap">PersistentArrayMap</see> (if small enough, else create a <see cref="PersistentHashMap">PersistentHashMap</see>.
/// </summary>
/// <param name="other">The BCL map to initialize from</param>
/// <returns>A new persistent map.</returns>
/// <summary>
/// Create a <see cref="PersistentArrayMap">PersistentArrayMap</see> with new data but same metadata as the current object.
/// </summary>
/// <param name="init">The new key/value array</param>
/// <returns>A new <see cref="PersistentArrayMap">PersistentArrayMap</see>.</returns>
/// <remarks>The array is used directly.  Do not modify externally or immutability is sacrificed.</remarks>
// ClojureJVM says: If this looks like it is doing busy-work, it is because it
// is achieving these goals: O(n^2) run time like
// createWithCheck(), never modify init arg, and only
// allocate memory if there are duplicate keys.
// Create a new shorter array with unique keys, and
// the last value associated with each key.  To behave
// like assoc, the first occurrence of each key must
// be used, since its metadata may be different than
// later equal keys.
/// <summary>
/// Create an empty <see cref="PersistentArrayMap">PersistentArrayMap</see>.
/// </summary>
/// <summary>
/// Initializes a <see cref="PersistentArrayMap">PersistentArrayMap</see> to use the supplied key/value array.
/// </summary>
/// <param name="init">An array with alternating keys and values.</param>
/// <remarks>The array is used directly.  Do not modify externally or immutability is sacrificed.</remarks>
// The Java version doesn't seem to care.  Why should I?
//if (init.Length % 2 != 0)
//    throw new ArgumentException("Key/value array must have an even number of elements.");
/// <summary>
/// Initializes a <see cref="PersistentArrayMap">PersistentArrayMap</see> to use the supplied key/value array and metadata.
/// </summary>
/// <param name="meta">The metadata to attach.</param>
/// <param name="init">An array with alternating keys and values.</param>
/// <remarks>The array is used directly.  Do not modify externally or immutability is sacrificed.</remarks>
// The Java version doesn't seem to care.  Why should I?
//if (init.Length % 2 != 0)
//    throw new ArgumentException("Key/value array must have an even number of elements.");
/// <summary>
/// Create a copy with new metadata.
/// </summary>
/// <param name="meta">The new metadata.</param>
/// <returns>A copy of the object with new metadata attached.</returns>
/// <summary>
/// Gets the index of the key in the array.
/// </summary>
/// <param name="key">The key to search for.</param>
/// <returns>The index of the key if found; -1 otherwise.</returns>
/// <summary>
/// Gets the index of the key in the array.
/// </summary>
/// <param name="key">The key to search for.</param>
/// <returns>The index of the key if found; -1 otherwise.</returns>
/// <summary>
/// Compare two keys for equality.
/// </summary>
/// <param name="k1">The first key to compare.</param>
/// <param name="k2">The second key to compare.</param>
/// <returns></returns>
/// <remarks>Handles nulls properly.</remarks>
/// <summary>
/// Test if the map contains a key.
/// </summary>
/// <param name="key">The key to test for membership</param>
/// <returns>True if the key is in this map.</returns>
/// <summary>
/// Returns the key/value pair for this key.
/// </summary>
/// <param name="key">The key to retrieve</param>
/// <returns>The key/value pair for the key, or null if the key is not in the map.</returns>
/// <summary>
/// Gets the value associated with a key.
/// </summary>
/// <param name="key">The key to look up.</param>
/// <returns>The associated value. (Throws an exception if key is not present.)</returns>
/// <summary>
/// Gets the value associated with a key.
/// </summary>
/// <param name="key">The key to look up.</param>
/// <param name="notFound">The value to return if the key is not present.</param>
/// <returns>The associated value (or <c>notFound</c> if the key is not present.</returns>
/// <summary>
/// Gets the number of items in the collection.
/// </summary>
/// <returns>The number of items in the collection.</returns>
/// <summary>
/// Gets an ISeq to allow first/rest iteration through the collection.
/// </summary>
/// <returns>An ISeq for iteration.</returns>
/// <summary>
/// Gets an empty collection of the same type.
/// </summary>
/// <returns>An emtpy collection.</returns>
/// <summary>
/// Add a new key/value pair.
/// </summary>
/// <param name="key">The key</param>
/// <param name="val">The value</param>
/// <returns>A new map with key+value added.</returns>
/// <remarks>Overwrites an exising value for the <paramref name="key"/>, if present.</remarks>
// already have key, same sized replacement
// no change, no-op
// new key, grow
/// <summary>
/// Create an <see cref="IPersistentMap">IPersistentMap</see> to hold the data when 
/// an operation causes the threshhold size to be exceeded.
/// </summary>
/// <param name="init">The array of key/value pairs.</param>
/// <returns>A new <see cref="IPersistentMap">IPersistentMap</see>.</returns>
/// <summary>
/// Add a new key/value pair.
/// </summary>
/// <param name="key">The key</param>
/// <param name="val">The value</param>
/// <returns>A new map with key+value added.</returns>
/// <remarks>Throws an exception if <paramref name="key"/> has a value already.</remarks>
/// <summary>
/// Remove a key entry.
/// </summary>
/// <param name="key">The key to remove</param>
/// <returns>A new map with the key removed (or the same map if the key is not contained).</returns>
// key exists, remove
/// <summary>
/// Internal class providing an <see cref="ISeq">ISeq</see> 
/// for <see cref="PersistentArrayMap">PersistentArrayMap</see>s.
/// </summary>
/// <summary>
/// The array to iterate over.
/// </summary>
/// <summary>
/// Current index position in the array.
/// </summary>
/// <summary>
/// Initialize the sequence to a given array and index.
/// </summary>
/// <param name="array">The array being sequenced over.</param>
/// <param name="i">The current index.</param>
/// <summary>
/// Initialize the sequence with given metatdata and array/index.
/// </summary>
/// <param name="meta">The metadata to attach.</param>
/// <param name="array">The array being sequenced over.</param>
/// <param name="i">The current index.</param>
/// <summary>
/// Gets the first item.
/// </summary>
/// <returns>The first item.</returns>
/// <summary>
/// Return a seq of the items after the first.  Calls <c>seq</c> on its argument.  If there are no more items, returns nil."
/// </summary>
/// <returns>A seq of the items after the first, or <c>nil</c> if there are no more items.</returns>
/// <summary>
/// Gets the number of items in the collection.
/// </summary>
/// <returns>The number of items in the collection.</returns>
/// <summary>
/// Create a copy with new metadata.
/// </summary>
/// <param name="meta">The new metadata.</param>
/// <returns>A copy of the object with new metadata attached.</returns>
/// <summary>
/// Gets the index of the key in the array.
/// </summary>
/// <param name="key">The key to search for.</param>
/// <returns>The index of the key if found; -1 otherwise.</returns>
//already have key,
//no change, no op
//didn't have key, grow
//have key, will remove
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\PersistentHashMap.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: Get rid of Box in favor of 'out' parameer.
/// <summary>
/// A persistent rendition of Phil Bagwell's Hash Array Mapped Trie
/// </summary>
/// <remarks>
/// <para>Uses path copying for persistence.</para>
/// <para>HashCollision leaves vs extended hashing</para>
/// <para>Node polymorphism vs conditionals</para>
/// <para>No sub-tree pools or root-resizing</para>
/// <para>Any errors are Rich Hickey's (so he says), except those that I introduced.</para>
/// </remarks>
/// <summary>
/// The number of entries in the map.
/// </summary>
/// <summary>
/// The root of the trie.
/// </summary>
/// <summary>
/// Indicates if the map has the null value as a key.
/// </summary>
/// <summary>
/// The value associated with the null key, if present.
/// </summary>
/// <summary>
/// An empty <see cref="PersistentHashMap">PersistentHashMap</see>.
/// </summary>
/// <summary>
/// Create a <see cref="PersistentHashMap">PersistentHashMap</see> initialized from a CLR dictionary.
/// </summary>
/// <param name="other">The dictionary to copy from.</param>
/// <returns>A <see cref="PersistentHashMap">PersistentHashMap</see>.</returns>
/// <summary>
/// Create a <see cref="PersistentHashMap">PersistentHashMap</see> initialized from an array of alternating keys and values.
/// </summary>
/// <param name="init">An array of alternating keys and values.</param>
/// <returns>A <see cref="PersistentHashMap">PersistentHashMap</see>.</returns>
/// <summary>
/// Create a <see cref="PersistentHashMap">PersistentHashMap</see> initialized from an IList of alternating keys and values.
/// </summary>
/// <param name="init">An IList of alternating keys and values.</param>
/// <returns>A <see cref="PersistentHashMap">PersistentHashMap</see>.</returns>
/// <summary>
/// Create a <see cref="PersistentHashMap">PersistentHashMap</see> initialized from 
/// an <see cref="ISeq">ISeq</see> of alternating keys and values.
/// </summary>
/// <param name="items">An <see cref="ISeq">ISeq</see> of alternating keys and values.</param>
/// <returns>A <see cref="PersistentHashMap">PersistentHashMap</see>.</returns>
/// <summary>
/// Create a <see cref="PersistentHashMap">PersistentHashMap</see> with given metadata initialized from an array of alternating keys and values.
/// </summary>
/// <param name="meta">The metadata to attach.</param>
/// <param name="init">An array of alternating keys and values.</param>
/// <returns>A <see cref="PersistentHashMap">PersistentHashMap</see>.</returns>
/// <summary>
/// Initialize a <see cref="PersistentHashMap">PersistentHashMap</see> with a given count and root node.
/// </summary>
/// <param name="count">The count.</param>
/// <param name="root">The root node.</param>
/// <param name="hasNull"></param>
/// <param name="nullValue"></param>
/// <summary>
/// Initialize a <see cref="PersistentHashMap">PersistentHashMap</see> with given metadata, count and root node.
/// </summary>
/// <param name="meta">The metadata to attach</param>
/// <param name="count">The count.</param>
/// <param name="root">The root node.</param>
/// <param name="hasNull"></param>
/// <param name="nullValue"></param>
/// <summary>
/// Create a copy with new metadata.
/// </summary>
/// <param name="meta">The new metadata.</param>
/// <returns>A copy of the object with new metadata attached.</returns>
/// <summary>
/// Test if the map contains a key.
/// </summary>
/// <param name="key">The key to test for membership</param>
/// <returns>True if the key is in this map.</returns>
/// <summary>
/// Returns the key/value pair for this key.
/// </summary>
/// <param name="key">The key to retrieve</param>
/// <returns>The key/value pair for the key, or null if the key is not in the map.</returns>
/// <summary>
/// Gets the value associated with a key.
/// </summary>
/// <param name="key">The key to look up.</param>
/// <returns>The associated value. (Throws an exception if key is not present.)</returns>
/// <summary>
/// Gets the value associated with a key.
/// </summary>
/// <param name="key">The key to look up.</param>
/// <param name="notFound">The value to return if the key is not present.</param>
/// <returns>The associated value (or <c>notFound</c> if the key is not present.</returns>
/// <summary>
/// Add a new key/value pair.
/// </summary>
/// <param name="key">The key</param>
/// <param name="val">The value</param>
/// <returns>A new map with key+value added.</returns>
/// <remarks>Overwrites an exising value for the <paramref name="key"/>, if present.</remarks>
/// <summary>
/// Add a new key/value pair.
/// </summary>
/// <param name="key">The key</param>
/// <param name="val">The value</param>
/// <returns>A new map with key+value added.</returns>
/// <remarks>Throws an exception if <paramref name="key"/> has a value already.</remarks>
/// <summary>
/// Remove a key entry.
/// </summary>
/// <param name="key">The key to remove</param>
/// <returns>A new map with the key removed (or the same map if the key is not contained).</returns>
/// <summary>
/// Gets the number of items in the collection.
/// </summary>
/// <returns>The number of items in the collection.</returns>
/// <summary>
/// Gets an ISeq to allow first/rest iteration through the collection.
/// </summary>
/// <returns>An ISeq for iteration.</returns>
/// <summary>
/// Gets an empty collection of the same type.
/// </summary>
/// <returns>An emtpy collection.</returns>
//// not part of this interface, but I don't know a better place for it
//IMapEntry entryAt(Object key)
//{
//    return (IMapEntry)_root.find(Hash(key), key);
//}
// JVM: we are ignoring n for now
/// <summary>
/// Interface for all nodes in the trie.
/// </summary>
/// <summary>
/// Return a trie with a new key/value pair.
/// </summary>
/// <param name="shift"></param>
/// <param name="hash"></param>
/// <param name="key"></param>
/// <param name="val"></param>
/// <param name="addedLeaf"></param>
/// <returns></returns>
/// <summary>
/// Return a trie with the given key removed.
/// </summary>
/// <param name="shift"></param>
/// <param name="hash"></param>
/// <param name="key"></param>
/// <returns></returns>
/// <summary>
/// Gets the entry containing a given key and its value.
/// </summary>
/// <param name="shift"></param>
/// <param name="hash"></param>
/// <param name="key"></param>
/// <returns></returns>
/// <summary>
/// Gets the value associated with a given key, or return a default value if not found.
/// </summary>
/// <param name="shift"></param>
/// <param name="hash"></param>
/// <param name="key"></param>
/// <param name="notFound"></param>
/// <returns></returns>
/// <summary>
/// Return an <see cref="ISeq">ISeq</see> with iterating the tree defined by the current node.
/// </summary>
/// <returns>An <see cref="ISeq">ISeq</see> </returns>
///// <summary>
///// Get the hash for the current ndoe.
///// </summary>
///// <returns></returns>
//int getHash();
/// <summary>
/// Return a trie with a new key/value pair.
/// </summary>
/// <param name="edit"></param>
/// <param name="shift"></param>
/// <param name="hash"></param>
/// <param name="key"></param>
/// <param name="val"></param>
/// <param name="addedLeaf"></param>
/// <returns></returns>
/// <summary>
/// Return a trie with the given key removed.
/// </summary>
/// <param name="edit"></param>
/// <param name="shift"></param>
/// <param name="hash"></param>
/// <param name="key"></param>
/// <param name="removedLeaf"></param>
/// <returns></returns>
/// <summary>
/// Perform key-value reduce.
/// </summary>
/// <param name="f"></param>
/// <param name="init"></param>
/// <returns></returns>
/// <summary>
/// Fold
/// </summary>
/// <param name="combinef"></param>
/// <param name="reducef"></param>
/// <param name="fjtask"></param>
/// <param name="fjfork"></param>
/// <param name="fjjoin"></param>
/// <returns></returns>
// shrink
// shrink
/// <summary>
///  Represents an internal node in the trie, not full.
/// </summary>
// TODO: collapse
// make room for next assoc
/// <summary>
/// Represents a leaf node corresponding to multiple map entries, all with keys that have the same hash value.
/// </summary>
// nest it in a bitmap node
// nest it in a bitmap node
// make room for next assoc
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\PersistentHashSet.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// A persistent set built on a <see cref="IPersistentMap">IPersistentMap</see>.
/// </summary>
/// <summary>
/// An empty <see cref="PersistentHashSet">PersistentHashSet</see>.
/// </summary>
/// <summary>
/// Create a <see cref="PersistentHashSet">PersistentHashSet</see> initialized from an array of items.
/// </summary>
/// <param name="init">An array of items.</param>
/// <returns>A <see cref="PersistentHashSet">PersistentHashSet</see>.</returns>
/// <summary>
/// Create a <see cref="PersistentHashSet">PersistentHashSet</see> initialized from an IList of items.
/// </summary>
/// <param name="init">An IList of items.</param>
/// <returns>A <see cref="PersistentHashSet">PersistentHashSet</see>.</returns>
/// <remarks>This is called just 'create' in the Java version.  CLR can't handle this overload when called on something that is 
/// both an IList and an ISeq, such as any ASeq.</remarks>
/// <summary>
/// Create a <see cref="PersistentHashSet">PersistentHashSet</see> initialized from an <see cref="ISeq">ISeq</see> of items.
/// </summary>
/// <param name="items">An <see cref="ISeq">ISeq</see> of items</param>
/// <returns>A <see cref="PersistentHashSet">PersistentHashSet</see>.</returns>
/// <summary>
/// Initialize a <see cref="PersistentHashSet">PersistentHashSet</see> to use given metadata and underlying map.
/// </summary>
/// <param name="meta">The metadata to attach.</param>
/// <param name="impl">The implementating map.</param>
/// <summary>
/// Create a copy with new metadata.
/// </summary>
/// <param name="meta">The new metadata.</param>
/// <returns>A copy of the object with new metadata attached.</returns>
/// <summary>
/// Get a set with the given item removed.
/// </summary>
/// <param name="key">The item to remove.</param>
/// <returns>A new set with the item removed.</returns>
/// <summary>
/// Returns a new collection that has the given element cons'd on front of the existing collection.
/// </summary>
/// <param name="o">An item to put at the front of the collection.</param>
/// <returns>A new immutable collection with the item added.</returns>
/// <summary>
/// Gets an empty collection of the same type.
/// </summary>
/// <returns>An emtpy collection.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\PersistentList.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents a persistent list.
/// </summary>
/// <summary>
/// The first item in the list.
/// </summary>
/// <summary>
/// The rest of the list.
/// </summary>
/// <summary>
/// The number of items in the list.
/// </summary>
/// <summary>
/// An empty <see cref="IPersistentList">IPersistentList</see>.
/// </summary>
/// <summary>
/// Initializes a list of one member.
/// </summary>
/// <param name="first">The one member.</param>
/// <summary>
/// Create a list initialized from a given IList.
/// </summary>
/// <param name="init">The list to initialize from.</param>
/// <returns>A list.</returns>
/// <summary>
/// Initialize a list with given metadata, first element and rest of list.
/// </summary>
/// <param name="meta">The metadata to attach.</param>
/// <param name="first">The first element in the list.</param>
/// <param name="rest">The rest of the list.</param>
/// <param name="count">The number of elements in the list.</param>
/// <summary>
/// Provides a function to create a list from a sequence of arguments. (Internal use only.)
/// </summary>
/// <remarks>Internal use only.  Used to interface with core.clj.</remarks>
/// <summary>
/// The creator method.
/// </summary>
/// <param name="args">A sequence of elements.</param>
/// <returns>A new list.</returns>
/// <summary>
/// An <see cref="IFn">IFn</see> to create a list from a sequence of items.
/// </summary>
/// <remarks>The name is without our usual leading underscore for compatiblity with core.clj.</remarks>
/// <summary>
/// Gets the first item.
/// </summary>
/// <returns>The first item.</returns>
/// <summary>
/// Return a seq of the items after the first.  Calls <c>seq</c> on its argument.  If there are no more items, returns nil."
/// </summary>
/// <returns>A seq of the items after the first, or <c>nil</c> if there are no more items.</returns>
/// <summary>
/// Adds an item to the beginning of the list.
/// </summary>
/// <param name="o">The item to add.</param>
/// <returns>A new list containing the new item in front of the items already in the sequence.</returns>
/// <summary>
/// Peek at the top (first) element in the stack.
/// </summary>
/// <returns>The top (first) element.</returns>
/// <summary>
/// Returns a new stack with the top element popped.
/// </summary>
/// <returns>The new stack</returns>
/// <summary>
/// Gets the number of items in the collection.
/// </summary>
/// <returns>The number of items in the collection.</returns>
/// <summary>
/// Gets an empty collection of the same type.
/// </summary>
/// <returns>An emtpy collection.</returns>
/// <summary>
/// Reduce the collection using a function.
/// </summary>
/// <param name="f">The function to apply.</param>
/// <returns>The reduced value</returns>
/// <summary>
/// Reduce the collection using a function.
/// </summary>
/// <param name="f">The function to apply.</param>
/// <param name="start">An initial value to get started.</param>
/// <returns>The reduced value</returns>
/// <summary>
/// Represents an empty <see cref="IPersistentList">IPersistentList</see>.
/// </summary>
/// <summary>
/// Initialize an <see cref="EmptyList">PersistentList.EmptyList</see> with given metadata.
/// </summary>
/// <param name="meta">The metadata to attach.</param>
/// <summary>
/// Initialize an <see cref="EmptyList">PersistentList.EmptyList</see> with null metadata.
/// </summary>
/// <summary>
/// Return the hash code for the object.
/// </summary>
/// <returns>The hash code</returns>
/// <summary>
/// Determines if an object is equal to the current object.
/// </summary>
/// <param name="obj">The object to compare to.</param>
/// <returns><value>true</value> if the object is the same; <value>false</value> otherwise.</returns>
/// <remarks>
/// Equality is value-based.  Any empty sequence will do.
/// </remarks>
/// <summary>
/// Create a copy with new metadata.
/// </summary>
/// <param name="meta">The new metadata.</param>
/// <returns>A copy of the object with new metadata attached.</returns>
/// <summary>
/// Peek at the top (first) element in the stack.
/// </summary>
/// <returns>The top (first) element.  )(Always null.)</returns>
/// <summary>
/// Returns a new stack with the top element popped.
/// </summary>
/// <returns>The new stack.  Always throws an exception.</returns>
/// <summary>
/// Gets the number of items in the collection.
/// </summary>
/// <returns>The number of items in the collection.  Always zero.</returns>
/// <summary>
/// Gets an ISeq to allow first/rest iteration through the collection.
/// </summary>
/// <returns>An ISeq for iteration.  The sequence is empty, so always null.</returns>
/// <summary>
/// Gets an empty collection of the same type.
/// </summary>
/// <returns>An emtpy collection.  Always returns itself.</returns>
/// <summary>
/// Determine if an object is equivalent to this (handles all collections).
/// </summary>
/// <param name="o">The object to compare.</param>
/// <returns><c>true</c> if the object is equivalent; <c>false</c> otherwise.</returns>
// no-op: no items to copy.
// no-op: no items to copy.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\PersistentQueue.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// A persistent queue. (Conses onto rear, peeks/pops from front.)
/// </summary>
/// <remarks>
/// <para>See Okasaki's Batched Queues.</para>
/// <para>This differs in that it uses an <see cref="IPersistentList">PersistentVector</see>
/// as the rear, which is in-order,
/// so no reversing or suspensions required for persistent use.</para>
/// </remarks>
/// <summary>
/// An empty <see cref="PersistentQueue">PersistentQueue</see>.
/// </summary>
/// <summary>
/// The number of elements in the queue.
/// </summary>
/// <summary>
/// The front elements of the queue.
/// </summary>
/// <summary>
/// The rear elements of the queue.
/// </summary>
/// <summary>
/// Cached hash code.
/// </summary>
/// <summary>
/// Caches the hashseq code, when computed.
/// </summary>
/// <remarks>The default value indicates that the hasheq code has not been computed yet.</remarks>
/// <summary>
/// Inititalizes a <see cref="PersistentQueue">PersistentQueue</see> from given metadata, front, rear.
/// </summary>
/// <param name="meta"></param>
/// <param name="f"></param>
/// <param name="r"></param>
/// <summary>
/// Determines if an object is equal to the current object.
/// </summary>
/// <param name="obj">The object to compare to.</param>
/// <returns><value>true</value> if they are the same; <value>false</value> otherwise.</returns>
/// <summary>
/// Get the hash code for the current object.
/// </summary>
/// <returns>The hash code.</returns>
/// <remarks>Result is cached.</remarks>
/// <summary>
/// Create a copy with new metadata.
/// </summary>
/// <param name="meta">The new metadata.</param>
/// <returns>A copy of the object with new metadata attached.</returns>
/// <summary>
/// Peek at the top (first) element in the stack.
/// </summary>
/// <returns>The top (first) element.</returns>
/// <summary>
/// Returns a new stack with the top element popped.
/// </summary>
/// <returns>The new stack.</returns>
//Java code: hmmmm... pop of empty queue => empty queue?
/// <summary>
/// Gets the number of items in the collection.
/// </summary>
/// <returns>The number of items in the collection.</returns>
/// <summary>
/// Gets an <see cref="ISeq">ISeq</see> to allow first/rest iteration through the collection.
/// </summary>
/// <returns>An <see cref="ISeq">ISeq</see> for iteration.</returns>
/// <summary>
/// Returns a new collection that has the given element cons'd on front of the existing collection.
/// </summary>
/// <param name="o">An item to put at the front of the collection.</param>
/// <returns>A new immutable collection with the item added.</returns>
// TODO: What if _f is null and _r is not?
// empty
//int hash = 1;
//for (ISeq s = seq(); s != null; s = s.next())
//{
//    hash = 31 * hash + Util.hasheq(s.first());
//}
//_hasheq = hash;
/// <summary>
/// Represents an <see cref="ISeq">ISeq</see> over a <see cref="PersistentQueue">PersistentQueue</see>.
/// </summary>
/// <summary>
/// The front elements.
/// </summary>
/// <summary>
/// The rear elements.
/// </summary>
/// <summary>
/// Initializes a <see cref="Seq">PersistentQueue.Seq</see> from given front and rear elements.
/// </summary>
/// <param name="f">The front elements.</param>
/// <param name="rseq">The rear elements.</param>
/// <summary>
/// Initializes a <see cref="Seq">PersistentQueue.Seq</see> from given metadata and front and rear elements.
/// </summary>
/// <param name="meta">The metadata to attach.</param>
/// <param name="f">The front elements.</param>
/// <param name="rseq">The rear elements.</param>
/// <summary>
/// Create a copy with new metadata.
/// </summary>
/// <param name="meta">The new metadata.</param>
/// <returns>A copy of the object with new metadata attached.</returns>
/// <summary>
/// Gets the number of items in the collection.
/// </summary>
/// <returns>The number of items in the collection.</returns>
/// <summary>
/// Gets the first item.
/// </summary>
/// <returns>The first item.</returns>
/// <summary>
/// Return a seq of the items after the first.  Calls <c>seq</c> on its argument.  If there are no more items, returns nil."
/// </summary>
/// <returns>A seq of the items after the first, or <c>nil</c> if there are no more items.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\PersistentStructMap.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents a structure map (map with fixed set of quickly accessible keys).
/// </summary>
/// <remarks>See the Clojure API for more information.</remarks>
/// <summary>
/// Holds the fixed keys and map of keys to indexes.
/// </summary>
/// <summary>
/// The fixed keys.
/// </summary>
/// <summary>
/// Get the fixed keys.
/// </summary>
/// <summary>
/// The map from (fixed) keys to indexes.
/// </summary>
/// <summary>
/// Get the map from (fixed) keys to indexes.
/// </summary>
/// <summary>
/// Initialize a <see cref="Def">Def</see>.
/// </summary>
/// <param name="keys">The fixed keys.</param>
/// <param name="keyslots">The map of keys/values for the fixed keys.</param>
/// <summary>
/// The <see cref="Def">Def</see> holding the fixed key definitions.
/// </summary>
/// <summary>
/// Holds the values for the fixed keys.
/// </summary>
/// <summary>
/// The map for non-fixed keys.
/// </summary>
/// <summary>
/// Creates a struct definition.
/// </summary>
/// <param name="keys">The set of fixed keys.</param>
/// <returns>A struct definition.</returns>
/// <summary>
/// Create a struct from a struct definition and a sequence of alternating keys and values.
/// </summary>
/// <param name="def">The struct definition</param>
/// <param name="keyvals">A sequence of alternating keys and values.</param>
/// <returns>A <see cref="PersistentStructMap">PersistentStructMap</see>.</returns>
/// <summary>
/// Create a struct from a struct definition and values (in order) for the fixed keys.
/// </summary>
/// <param name="def">A struct definition</param>
/// <param name="valseq">A sequence of values for the fixed keys (in definition order).</param>
/// <returns>A <see cref="PersistentStructMap">PersistentStructMap</see>.</returns>
/// <summary>
/// Initialize a struct from given data.
/// </summary>
/// <param name="meta">The metadata to attach.</param>
/// <param name="def">The structure definition.</param>
/// <param name="vals">Values for the fixed keys.</param>
/// <param name="ext">Additional keys/values.</param>
/// <summary>
/// Create a structure from the given data.
/// </summary>
/// <param name="meta"></param>
/// <param name="def"></param>
/// <param name="vals"></param>
/// <param name="ext"></param>
/// <returns></returns>
/// <remarks>
/// This method is used instead of the PersistentStructMap constructor by
/// all methods that return a new PersistentStructMap.  This is done
/// to allow subclasses to override this method to return instances of their own class from 
/// all PersistentStructMap methods.
/// </remarks>
/// <summary>
/// A function providing quick access to given fixed key of a struct.
/// </summary>
/// <summary>
/// The struct definition.
/// </summary>
/// <summary>
/// The index of the key to access.
/// </summary>
/// <summary>
/// Initialize.
/// </summary>
/// <param name="def">The struct definition.</param>
/// <param name="index">The index of the key to access.</param>
/// <summary>
/// Get a fast accessor for a fixed key.
/// </summary>
/// <param name="def">The struct definition.</param>
/// <param name="key">The fixed key to access.</param>
/// <returns>An accessor function.</returns>
/// <summary>
/// Create a copy with new metadata.
/// </summary>
/// <param name="meta">The new metadata.</param>
/// <returns>A copy of the object with new metadata attached.</returns>
/// <summary>
/// Gets the number of items in the collection.
/// </summary>
/// <returns>The number of items in the collection.</returns>
/// <summary>
/// Gets an <see cref="ISeq">ISeq</see> to allow first/rest iteration through the collection.
/// </summary>
/// <returns>An <see cref="ISeq">ISeq</see> for iteration.</returns>
/// <summary>
/// Gets an empty collection of the same type.
/// </summary>
/// <returns>An emtpy collection.</returns>
/// <summary>
/// Test if the map contains a key.
/// </summary>
/// <param name="key">The key to test for membership</param>
/// <returns>True if the key is in this map.</returns>
/// <summary>
/// Returns the key/value pair for this key.
/// </summary>
/// <param name="key">The key to retrieve</param>
/// <returns>The key/value pair for the key, or null if the key is not in the map.</returns>
/// <summary>
/// Gets the value associated with a key.
/// </summary>
/// <param name="key">The key to look up.</param>
/// <returns>The associated value. (Throws an exception if key is not present.)</returns>
/// <summary>
/// Gets the value associated with a key.
/// </summary>
/// <param name="key">The key to look up.</param>
/// <param name="notFound">The value to return if the key is not present.</param>
/// <returns>The associated value (or <c>notFound</c> if the key is not present.</returns>
/// <summary>
/// Add a new key/value pair.
/// </summary>
/// <param name="key">The key</param>
/// <param name="val">The value</param>
/// <returns>A new map with key+value added.</returns>
/// <remarks>Overwrites an exising value for the <paramref name="key"/>, if present.</remarks>
/// <summary>
/// Add a new key/value pair.
/// </summary>
/// <param name="key">The key</param>
/// <param name="val">The value</param>
/// <returns>A new map with key+value added.</returns>
/// <remarks>Throws an exception if <paramref name="key"/> has a value already.</remarks>
/// <summary>
/// Remove a key entry.
/// </summary>
/// <param name="key">The key to remove</param>
/// <returns>A new map with the key removed (or the same map if the key is not contained).</returns>
/// <summary>
/// Implements an <see cref="ISeq">ISeq</see> iterating over a <see cref="PersistentStructMap">PersistentStructMap</see>.
/// </summary>
/// <remarks>Combines an index-iteration over the array of fixed keys, 
/// followed by a regular iteration of the map of non-fixed keys.
/// </remarks>
/// <summary>
/// Index into the fixed keys.
/// </summary>
/// <summary>
/// The (remaining) fixed keys.
/// </summary>
/// <summary>
/// The values for the fixed keys.
/// </summary>
/// <summary>
/// The map of non-fixed keys and their values.
/// </summary>
/// <summary>
/// Initialize a <see cref="Seq">PersistentStuctMap.Seq</see>.
/// </summary>
/// <param name="meta">The metadata to attach.</param>
/// <param name="keys">The remaining fixed keys.</param>
/// <param name="vals">The values for the fixed keys.</param>
/// <param name="i">The index of the first fixed key.</param>
/// <param name="ext">The non-fixed keys and their values.</param>
/// <summary>
/// Create a copy with new metadata.
/// </summary>
/// <param name="meta">The new metadata.</param>
/// <returns>A copy of the object with new metadata attached.</returns>
/// <summary>
/// Gets the first item.
/// </summary>
/// <returns>The first item.</returns>
/// <summary>
/// Return a seq of the items after the first.  Calls <c>seq</c> on its argument.  If there are no more items, returns nil."
/// </summary>
/// <returns>A seq of the items after the first, or <c>nil</c> if there are no more items.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\PersistentTreeMap.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Implements a persistent Red-Black Tree.
/// </summary>
/// <remarks>
/// <para>>Note that instances of this class are constant values
/// i.e., add/remove etc return new values.</para>
/// <para>See Okasaki, Kahrs, Larsen et al</para>
/// </remarks>
/// <summary>
/// The method used to compare elements for sorting.
/// </summary>
/// <summary>
/// Root node of the Red-Black tree.
/// </summary>
/// <summary>
/// Number of items in the tree.
/// </summary>
/// <summary>
/// An empty <see cref="PersistentTreeMap">PersistentTreeMap</see>.
/// </summary>
/// <summary>
/// Create a <see cref="PersistentTreeMap">PersistentTreeMap</see> from a dictionary.
/// </summary>
/// <param name="other">The dictionary to initialize from.</param>
/// <returns>A <see cref="PersistentTreeMap">PersistentTreeMap</see>.</returns>
/// <summary>
/// Create a <see cref="PersistentTreeMap">PersistentTreeMap</see> from 
/// an <see cref="ISeq">ISeq</see> of alternating keys and values.
/// </summary>
/// <param name="items">The <see cref="ISeq">ISeq</see>  of alternating keys and values.</param>
/// <returns>A <see cref="PersistentTreeMap">PersistentTreeMap</see>.</returns>
/// <summary>
/// Create a <see cref="PersistentTreeMap">PersistentTreeMap</see> from a comparison method
/// an <see cref="ISeq">ISeq</see> of alternating keys and values.
/// </summary>
/// <param name="comp">A comparison method.</param>
/// <param name="items">The <see cref="ISeq">ISeq</see>  of alternating keys and values.</param>
/// <returns>A <see cref="PersistentTreeMap">PersistentTreeMap</see>.</returns>
/// <summary>
/// Initialize a <see cref="PersistentTreeMap">PersistentTreeMap</see> using a default comparer.
/// </summary>
/// <summary>
/// Initialize a <see cref="PersistentTreeMap">PersistentTreeMap</see> using a given comparer.
/// </summary>
/// <param name="comp"></param>
/// <summary>
/// Initialize a <see cref="PersistentTreeMap">PersistentTreeMap</see> using  given metadata and comparer.
/// </summary>
/// <param name="meta"></param>
/// <param name="comp"></param>
/// <summary>
/// Initialize a <see cref="PersistentTreeMap">PersistentTreeMap</see> using given internal data. (Internal use only.)
/// </summary>
/// <param name="comp">The comparer for sorting.</param>
/// <param name="tree">The root node of the RB tree.</param>
/// <param name="count">The number of elements in the tree.</param>
/// <param name="meta">The metadata to attach.</param>
// Why we have this and the previous, I don't know.
/// <summary>
/// Create a copy with new metadata.
/// </summary>
/// <param name="meta">The new metadata.</param>
/// <returns>A copy of the object with new metadata attached.</returns>
/// <summary>
/// Test if the map contains a key.
/// </summary>
/// <param name="key">The key to test for membership</param>
/// <returns>True if the key is in this map.</returns>
/// <summary>
/// Returns the key/value pair for this key.
/// </summary>
/// <param name="key">The key to retrieve</param>
/// <returns>The key/value pair for the key, or null if the key is not in the map.</returns>
/// <summary>
/// Gets the value associated with a key.
/// </summary>
/// <param name="key">The key to look up.</param>
/// <returns>The associated value. (Throws an exception if key is not present.)</returns>
/// <summary>
/// Gets the value associated with a key.
/// </summary>
/// <param name="key">The key to look up.</param>
/// <param name="notFound">The value to return if the key is not present.</param>
/// <returns>The associated value (or <c>notFound</c> if the key is not present.</returns>
/// <summary>
/// Gets the number of items in the collection.
/// </summary>
/// <returns>The number of items in the collection.</returns>
/// <summary>
/// Gets an <see cref="ISeq">ISeq</see> to allow first/rest iteration through the collection.
/// </summary>
/// <returns>An <see cref="ISeq">ISeq</see> for iteration.</returns>
/// <summary>
/// Gets an empty collection of the same type.
/// </summary>
/// <returns>An emtpy collection.</returns>
/// <summary>
/// Add a new key/value pair.
/// </summary>
/// <param name="key">The key</param>
/// <param name="val">The value</param>
/// <returns>A new map with key+value added.</returns>
/// <remarks>Overwrites an exising value for the <paramref name="key"/>, if present.</remarks>
/// <summary>
/// Add a new key/value pair.
/// </summary>
/// <param name="key">The key</param>
/// <param name="val">The value</param>
/// <returns>A new map with key+value added.</returns>
/// <remarks>Throws an exception if <paramref name="key"/> has a value already.</remarks>
/// <summary>
/// Remove a key entry.
/// </summary>
/// <param name="key">The key to remove</param>
/// <returns>A new map with the key removed (or the same map if the key is not contained).</returns>
/// <summary>
/// Gets an <see cref="ISeq">ISeq</see> to travers the sequence in reverse.
/// </summary>
/// <returns>An <see cref="ISeq">ISeq</see> .</returns>
/// <summary>
/// Returns the comparer used to sort the elements in the collection.
/// </summary>
/// <returns>The <c>IComparer</c> used to sort the items.</returns>
/// <remarks>Would be called <c>Comparer</c> except we need to match the JVM name.</remarks>
/// <summary>
/// Returns the key to be passed to the comparator to sort the element.
/// </summary>
/// <param name="entry">An element in the collection.</param>
/// <returns>The key used to sort the element.</returns>
/// <summary>
/// Returns an <see cref="ISeq">ISeq</see> to iterate through the collection in the designated direction. 
/// </summary>
/// <param name="ascending">A flag indicating if the iteration is ascending or descending.</param>
/// <returns>A sequence for first/rest iteration.</returns>
/// <summary>
/// Returns an <see cref="ISeq">ISeq</see> to iterate through the collection in the designated direction starting from a particular key. 
/// </summary>
/// <param name="key">The key at which to start the iteration.</param>
/// <param name="ascending">A flag indicating if the iteration is ascending or descending.</param>
/// <returns>A sequence for first/rest iteration.</returns>
/// <remarks>The key need not be in the collection.  If not present, the iteration will start with 
/// the first element with a key greater than (if asscending) or less than (if descending) the given key.</remarks>
// TODO: finish commenting RB tree operations.
/// <summary>
/// Get the Node containing a key, or null if key not in tree.
/// </summary>
/// <param name="key">The key to find.</param>
/// <returns>The node containing the key, or null if key not found.</returns>
/// <summary>
/// Compare two keys.
/// </summary>
/// <param name="k1">The first key.</param>
/// <param name="k2">The second key.</param>
/// <returns>negative, zero, positive</returns>
/// <summary>
/// Add a node for a key
/// </summary>
/// <param name="t"></param>
/// <param name="key"></param>
/// <param name="val"></param>
/// <param name="found"></param>
/// <returns></returns>
// end class Node
//public NodeIterator iterator(){
//    return new NodeIterator(tree, true);
//}
//public NodeIterator reverseIterator(){
//    return new NodeIterator(tree, false);
//}
//public Iterator keys(){
//    return keys(iterator());
//}
//public Iterator vals(){
//    return vals(iterator());
//}
//public Iterator keys(NodeIterator it){
//    return new KeyIterator(it);
//}
//public Iterator vals(NodeIterator it){
//    return new ValIterator(it);
//}
//public Object minKey(){
//    Node t = min();
//    return t != null ? t.key : null;
//}
//public Node min(){
//    Node t = tree;
//    if(t != null)
//        {
//        while(t.left() != null)
//            t = t.left();
//        }
//    return t;
//}
//public Object maxKey(){
//    Node t = max();
//    return t != null ? t.key : null;
//}
//public Node max(){
//    Node t = tree;
//    if(t != null)
//        {
//        while(t.right() != null)
//            t = t.right();
//        }
//    return t;
//}
//public int depth(){
//    return depth(tree);
//}
//int depth(Node t){
//    if(t == null)
//        return 0;
//    return 1 + Math.max(depth(t.left()), depth(t.right()));
//}
//static class KeyIterator implements Iterator{
//    NodeIterator it;
//    KeyIterator(NodeIterator it){
//        this.it = it;
//    }
//    public boolean hasNext(){
//        return it.hasNext();
//    }
//    public Object next(){
//        return ((Node) it.next()).key;
//    }
//    public void remove(){
//        throw new UnsupportedOperationException();
//    }
//}
//static class ValIterator implements Iterator{
//    NodeIterator it;
//    ValIterator(NodeIterator it){
//        this.it = it;
//    }
//    public boolean hasNext(){
//        return it.hasNext();
//    }
//    public Object next(){
//        return ((Node) it.next()).val();
//    }
//    public void remove(){
//        throw new UnsupportedOperationException();
//    }
//}
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\PersistentTreeSet.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Implements an persistent, ordered set.
/// </summary>
/// <summary>
/// An empty <see cref="PersistentTreeSet">PersistentTreeSet</see>.
/// </summary>
/// <summary>
/// Create a <see cref="PersistentTreeSet"/> initialized from an <see cref="ISeq"/>.
/// </summary>
/// <param name="init">A sequence of elements.</param>
/// <returns>A <see cref="PersistentTreeSet">PersistentTreeSet</see>.</returns>
/// <summary>
/// Create a <see cref="PersistentTreeSet"/> using a given comparator function initialized from an <see cref="ISeq"/>.
/// </summary>
/// <param name="comp"></param>
/// <param name="init"></param>
/// <returns></returns>
/// <summary>
/// Initialize a <see cref="PersistentTreeSet">PersistentTreeSet</see> using given metadata and underlying implementation map.
/// </summary>
/// <param name="meta">The metadata to attach</param>
/// <param name="impl">A map to implement the set.</param>
/// <summary>
/// Create a copy with new metadata.
/// </summary>
/// <param name="meta">The new metadata.</param>
/// <returns>A copy of the object with new metadata attached.</returns>
/// <summary>
/// Returns a new collection that has the given element cons'd on front of the existing collection.
/// </summary>
/// <param name="o">An item to put at the front of the collection.</param>
/// <returns>A new immutable collection with the item added.</returns>
/// <summary>
/// Gets an empty collection of the same type.
/// </summary>
/// <returns>An emtpy collection.</returns>
/// <summary>
/// Get a set with the given item removed.
/// </summary>
/// <param name="key">The item to remove.</param>
/// <returns>A new set with the item removed.</returns>
/// <summary>
/// Gets an <see cref="ISeq">ISeq</see> to travers the sequence in reverse.
/// </summary>
/// <returns>An <see cref="ISeq">ISeq</see> .</returns>
/// <summary>
/// Returns the comparer used to sort the elements in the collection.
/// </summary>
/// <returns>The <c>IComparer</c> used to sort the items.</returns>
/// <remarks>Would be called <c>Comparer</c> except we need to match the JVM name.</remarks>
/// <summary>
/// Returns the key to be passed to the comparator to sort the element.
/// </summary>
/// <param name="entry">An element in the collection.</param>
/// <returns>The key used to sort the element.</returns>
/// <summary>
/// Returns an <see cref="ISeq">ISeq</see> to iterate through the collection in the designated direction. 
/// </summary>
/// <param name="ascending">A flag indicating if the iteration is ascending or descending.</param>
/// <returns>A sequence for first/rest iteration.</returns>
/// <summary>
/// Returns an <see cref="ISeq">ISeq</see> to iterate through the collection in the designated direction starting from a particular key. 
/// </summary>
/// <param name="key">The key at which to start the iteration.</param>
/// <param name="ascending">A flag indicating if the iteration is ascending or descending.</param>
/// <returns>A sequence for first/rest iteration.</returns>
/// <remarks>The key need not be in the collection.  If not present, the iteration will start with 
/// the first element with a key greater than (if asscending) or less than (if descending) the given key.</remarks>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\PersistentVector.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Implements a persistent vector using a specialized form of array-mapped hash trie.
/// </summary>
/// <summary>
/// An empty <see cref="PersistentVector">PersistentVector</see>.
/// </summary>
/// <summary>
/// Create a <see cref="PersistentVector">PersistentVector</see> from an <see cref="ISeq">IReduceInit</see>.
/// </summary>
/// <param name="items"></param>
/// <returns></returns>
/// <summary>
/// Create a <see cref="PersistentVector">PersistentVector</see> from an <see cref="ISeq">ISeq</see>.
/// </summary>
/// <param name="items">A sequence of items.</param>
/// <returns>An initialized vector.</returns>
// >32, construct with array directly
// exactly 32, skip copy
// <32, copy to minimum array and construct
/// <summary>
/// Create a <see cref="PersistentVector">PersistentVector</see> from an array of items.
/// </summary>
/// <param name="items"></param>
/// <returns></returns>
/// <summary>
/// Create a <see cref="PersistentVector">PersistentVector</see> from an IEnumerable.
/// </summary>
/// <param name="items"></param>
/// <returns></returns>
// optimize common case
/// <summary>
/// Initialize a <see cref="PersistentVector">PersistentVector</see> from basic components.
/// </summary>
/// <param name="cnt"></param>
/// <param name="shift"></param>
/// <param name="root"></param>
/// <param name="tail"></param>
/// <summary>
/// Initialize a <see cref="PersistentVector">PersistentVector</see> from given metadata and basic components.
/// </summary>
/// <param name="meta"></param>
/// <param name="cnt"></param>
/// <param name="shift"></param>
/// <param name="root"></param>
/// <param name="tail"></param>
/// <summary>
/// Get the i-th item in the vector.
/// </summary>
/// <param name="i">The index of the item to retrieve/</param>
/// <returns>The i-th item</returns>
/// <remarks>Throws an exception if the index <c>i</c> is not in the range of the vector's elements.</remarks>
/// <summary>
/// Return a new vector with the i-th value set to <c>val</c>.
/// </summary>
/// <param name="i">The index of the item to set.</param>
/// <param name="val">The new value</param>
/// <returns>A new (immutable) vector v with v[i] == val.</returns>
/// <summary>
/// Creates a new vector with a new item at the end.
/// </summary>
/// <param name="o">The item to add to the vector.</param>
/// <returns>A new (immutable) vector with the objected added at the end.</returns>
/// <remarks>Overrides <c>cons</c> in <see cref="IPersistentCollection">IPersistentCollection</see> to specialize the return value.</remarks>
//if (_tail.Length < 32)
// full tail, push into tree
// overflow root?
// if parent is leaf, insert node,
// else does it map to existing child?  -> nodeToInsert = pushNode one more level
// else alloc new path
// return nodeToInsert placed in copy of parent
/// <summary>
/// Gets the number of items in the collection.
/// </summary>
/// <returns>The number of items in the collection.</returns>
/// <summary>
/// Gets an empty collection of the same type.
/// </summary>
/// <returns>An emtpy collection.</returns>
/// <summary>
/// Returns a new stack with the top element popped.
/// </summary>
/// <returns>The new stack.</returns>
//if ( _tail.Length > 1 )
//public new IPersistentCollection cons(object o)
//{
//    throw new NotImplementedException();
//}
//if parent is leaf, insert node,
// else does it map to an existing child? -> nodeToInsert = pushNode one more level
// else alloc new path
//return  nodeToInsert placed in copy of parent
// pop in tail?
//room in tail?
//full tail, push into tree
//overflow root?
// note - relies on EnsureEditable in 2-arg valAt
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Range.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Implements generic numeric (potentially infinite) range.    
/// </summary>
// Invariants guarantee this is never an empty or infinite seq
//   assert(start != end && step != 0)
// lazy
// lazy
// cached
///// <summary>
///// Gets the number of items in the collection.
///// </summary>
///// <returns>The number of items in the collection.</returns>
//public override int count()
//{
//    return _n < _end ? _end - _n : 0;
//}
/// <summary>
/// Gets the first item.
/// </summary>
/// <returns>The first item.</returns>
//partial last chunk
// full last chunk
// full intermediate chunk
/// <summary>
/// Return a seq of the items after the first.  Calls <c>seq</c> on its argument.  If there are no more items, returns nil."
/// </summary>
/// <returns>A seq of the items after the first, or <c>nil</c> if there are no more items.</returns>
/// <summary>
/// Create a copy with new metadata.
/// </summary>
/// <param name="meta">The new metadata.</param>
/// <returns>A copy of the object with new metadata attached.</returns>
/// <summary>
/// Reduce the collection using a function.
/// </summary>
/// <param name="f">The function to apply.</param>
/// <returns>The reduced value</returns>
/// <remarks>Computes f(...f(f(f(i0,i1),i2),i3),...).</remarks>
/// <summary>
/// Reduce the collection using a function.
/// </summary>
/// <param name="f">The function to apply.</param>
/// <param name="start">An initial value to get started.</param>
/// <returns>The reduced value</returns>
/// <remarks>Computes f(...f(f(f(start,i0),i1),i2),...).</remarks>
//public new IPersistentCollection cons(object o)
//{
//    throw new NotImplementedException();
//}
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Ratio.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//using BigDecimal = java.math.BigDecimal;
/// <summary>
/// Represents a rational number.
/// </summary>
/// <summary>
/// The numerator.
/// </summary>
/// <summary>
/// Get the numerator.
/// </summary>
/// <summary>
///  The denominator.
/// </summary>
/// <summary>
/// Get the denominator.
/// </summary>
/// <summary>
/// Initialize a Ratio from num/denom.
/// </summary>
/// <param name="numerator">The numerator.</param>
/// <param name="denominator">The denominator.</param>
/// <summary>
/// Determines of an object is equal to this object.
/// </summary>
/// <param name="obj">The object to compare to.</param>
/// <returns><value>true</value> if the object is equal to this object; <value>false</value> otherwise.</returns>
/// <summary>
/// Gets a hash code for this.
/// </summary>
/// <returns>A hash code.</returns>
/// <summary>
/// Returns a string representing the ratio.
/// </summary>
/// <returns>A string.</returns>
//return Convert.ToDecimal(ToDouble(provider));
//return _numerator.ToDouble(provider) / _denominator.ToDouble(provider);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\ReaderConditional.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//if (o == null || GetType() != o.GetType()) return false;
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\RecordEnumerable.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/* ghadi shayban Sep 24, 2014 */ 
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Reduced.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Ref.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents a reference.
/// </summary>
/// <summary>
/// Represents the value of reference on a thread at particular point in time.
/// </summary>
/// <summary>
/// The value.
/// </summary>
/// <summary>
/// The value.
/// </summary>
/// <summary>
/// The transaction commit/read point at which this value was set.
/// </summary>
/// <summary>
/// The transaction commit/read point at which this value was set.
/// </summary>
/// <summary>
/// The prior <see cref="TVal">TVal</see>.
/// </summary>
/// <remarks>Implements a doubly-linked circular list.</remarks>
/// <summary>
/// The prior <see cref="TVal">TVal</see>.
/// </summary>
/// <remarks>Implements a doubly-linked circular list.</remarks>
//set { _prior = value; }
/// <summary>
/// The next  <see cref="TVal">TVal</see>.
/// </summary>
/// <remarks>Implements a doubly-linked circular list.</remarks>
/// <summary>
/// The next  <see cref="TVal">TVal</see>.
/// </summary>
/// <remarks>Implements a doubly-linked circular list.</remarks>
//set { _next = value; }
/// <summary>
/// Construct a TVal, linked to a previous TVal.
/// </summary>
/// <summary>
/// Construct a TVal, linked to itself.
/// </summary>
/// <summary>
/// Set the value/point.
/// </summary>
/// <param name="val"></param>
/// <param name="point"></param>
/// <summary>
/// Values at points in time for this reference.
/// </summary>
/// <summary>
/// Values at points in time for this reference.
/// </summary>
/// <summary>
/// Number of faults for the reference.
/// </summary>
/// <summary>
/// Reader/writer lock for the reference.
/// </summary>
/// <summary>
/// Info on the transaction locking this ref.
/// </summary>
/// <summary>
/// Info on the transaction locking this ref.
/// </summary>
/// <summary>
/// An id uniquely identifying this reference.
/// </summary>
/// <summary>
/// An id uniquely identifying this reference.
/// </summary>
/// <summary>
/// Used to generate unique ids.
/// </summary>
/// <summary>
///  Construct a ref with given initial value.
/// </summary>
/// <param name="initVal">The initial value.</param>
/// <summary>
///  Construct a ref with given initial value and metadata.
/// </summary>
/// <param name="initVal">The initial value.</param>
/// <param name="meta">The metadat to attach.</param>
///// <summary>
///// I was having a hard day.
///// </summary>
///// <returns></returns>
//public string DebugStr()
//{
//    StringBuilder sb = new StringBuilder();
//    sb.Append("<Ref ");
//    sb.Append(Id);
//    sb.Append(", ");
//    if (_tinfo == null)
//        sb.Append("NO");
//    else
//        sb.AppendFormat("{0} {1}", _tinfo.Status.get(), _tinfo.StartPoint);
//    sb.Append(", ");
//    if (_tvals == null)
//        sb.Append("TVals: NO");
//    else
//    {
//        sb.Append("TVals: ");
//        TVal t = _tvals;
//        do
//        {
//            sb.Append(t.Point);
//            sb.Append(" ");
//        } while ((t = t.Prior) != _tvals);
//    }
//    sb.Append(">");
//    return sb.ToString();
//}
/// <summary>
/// Gets the (immutable) value the reference is holding.
/// </summary>
/// <returns>The value</returns>
//Console.WriteLine("Thr {0}, {1}: No-trans get => {2}", Thread.CurrentThread.ManagedThreadId,DebugStr(), ret);
/// <summary>
/// Get the read lock.
/// </summary>
/// <summary>
/// Release the read lock.
/// </summary>
/// <summary>
/// Get the write lock.
/// </summary>
/// <summary>
/// Get the write lock.
/// </summary>
/// <summary>
/// Release the write lock.
/// </summary>
/// <summary>
/// Add to the fault count.
/// </summary>
/// <summary>
/// Get the read/commit point associated with the current value.
/// </summary>
/// <returns></returns>
/// <summary>
/// Try to get the value (else null).
/// </summary>
/// <returns>The value if it has been set; <value>null</value> otherwise.</returns>
/// <summary>
/// Set the value.
/// </summary>
/// <param name="val">The new value.</param>
/// <param name="commitPoint">The transaction's commit point.</param>
/// <summary>
/// Set the value (must be in a transaction).
/// </summary>
/// <param name="val">The new value.</param>
/// <returns>The new value.</returns>
/// <summary>
/// Apply a commute to the reference. (Must be in a transaction.)
/// </summary>
/// <param name="fn">The function to apply to the current state and additional arguments.</param>
/// <param name="args">Additional arguments.</param>
/// <returns>The computed value.</returns>
/// <summary>
/// Change to a computed value.
/// </summary>
/// <param name="fn">The function to apply to the current state and additional arguments.</param>
/// <param name="args">Additional arguments.</param>
/// <returns>The computed value.</returns>
/// <summary>
/// Touch the reference.  (Add to the tracking list in the current transaction.)
/// </summary>
/// <summary>
/// Compare to another ref.
/// </summary>
/// <param name="other">The other ref.</param>
/// <returns><value>true</value> if they are identical; <value>false</value> otherwise.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Repeat.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/* Alex Miller, Dec 5, 2014 */
/**
// always INFINITE or >0
// cached
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\RestFn.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\RestFnImpl.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// The problem here is that I need the functionality of both RestFn and AfnImpl.
// Because they are both classes, we can't derive from both.
// For the time being, I choose to inherit from RestFn and re-implement the AFnImpl code.
// Eventually, we need to do overloading to solve this problem.
// Overloading is not possible at the moment do to a bug in LambdaExpression.CompileToMethod
//public override object invoke(object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7, object arg8, object arg9, object arg10, object arg11, object arg12, object arg13, object arg14, object arg15, object arg16, object arg17, object arg18, object arg19, object arg20, params object[] args)
//{
//    return (_fnRest == null) ? base.invoke() 
//    : _fnRest(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, args);
//}
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Reversible.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents a sequence that can be traversed in reverse.
/// </summary>
/// <summary>
/// Gets an <see cref="ISeq">ISeq</see> to travers the sequence in reverse.
/// </summary>
/// <returns>An <see cref="ISeq">ISeq</see> .</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\RT.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//using BigDecimal = java.math.BigDecimal;
//simple-symbol->class
//classes
//Symbol.intern("ContextMarshalException"), typeof(ContextMarshalException), -- obsolete
// Symbol.intern("TimeZoneInfo.AdjustmentRule"),typeof(TimeZoneInfo.AdjustmentRule),
// Symbol.intern(""),typeof(UriTemplate),
// Symbol.intern(""),typeof(UriTemplateEquivalenceComparer),
// Symbol.intern(""),typeof(UriTemplateMatch),
// Symbol.intern(""),typeof(UriTemplateMatchException),
// Symbol.intern(""),typeof(UriTemplateTable),
// structures/
// Symbol.intern(""),typeof(ArraySegment<T>),
// Symbol.intern(""),typeof(Nullable<T>),
// Symbol.intern(""),typeof(Void),
// interfaces/
//Symbol.intern("AppDomain"), typeof(AppDomain),
//Symbol.intern(""),typeof(IComparable<T>),
//Symbol.intern(""),typeof(IEquatable<T>),
// delegates/
// Symbol.intern(""),typeof(Action<T>/
// Symbol.intern(""),typeof(Action<T1,T2>/
// Symbol.intern(""),typeof(Action<T1,T2,T3>/
// Symbol.intern(""),typeof(Action<T1,T2,T3,T4>/
// Symbol.intern(""),typeof(Comparison<T>),
//Symbol.intern(""),typeof(Converter<TInput,TOutput>),
// Symbol.intern(""),typeof(EventHandler<TEventArgs>),
// Symbol.intern(""),typeof(Func<TResult>),
// Symbol.intern(""),typeof(Func<T,TResult>/
// Symbol.intern(""),typeof(Func<T1, T2, TResult>/
// Symbol.intern(""),typeof(Func<T1, T2, T3, TResult>/
// FSymbol.intern(""),typeof(Func<T1, T2, T3, T4, TResult>/
// Symbol.intern(""),typeof(Predicate<T>),
// Enumerations/
// ADDED THESE TO SUPPORT THE BOOTSTRAPPING IN THE JAVA CORE.CLJ
//Symbol.intern("Environment"), typeof(System.Environment)
// Note that we name the environment variable such that it can be
// directly manipulated as a POSIX shell identifier, which is useful
// for folks using Cygwin and its ilk.
// The JVM version has these to provide standard boxed values for true/false.
// I've tried it in the CLR version, two ways: with the types of the as bool and the types as Object.
// Very little difference between those.
// However, getting rid of them entirely speeds up compilation by about 25%.
// Thus, I'm thinking boxing bools is less expensive than a static field lookup.
//public static readonly Object T = true;//Keyword.intern(Symbol.intern(null, "t"));
//public static readonly Object F = false;//Keyword.intern(Symbol.intern(null, "t"));
// We need this initialization to happen earlier than most of the Var inits.
//= Var.intern(CLOJURE_NS, Symbol.intern("in-ns"), RT.F);
//= Var.intern(CLOJURE_NS, Symbol.intern("ns"), RT.F);
//= Var.intern(CLOJURE_NS, Symbol.intern("*print-readably*"), RT.T);
//= Var.intern(CLOJURE_NS, Symbol.intern("*print-meta*"), RT.F);
//= Var.intern(CLOJURE_NS, Symbol.intern("*print-dup*"), RT.F);
// We need this Var initializaed early on, I'm willing to waste the local init overhead to keep the code here with the others.
//= Var.intern(CLOJURE_NS, Symbol.intern("*flush-on-newline*"), RT.T);
//= Var.intern(CLOJURE_NS, Symbol.intern("*allow-unresolved-vars*"), RT.F);
//= Var.intern(CLOJURE_NS, Symbol.intern("*warn-on-reflection*"), RT.F);
//public static readonly Var MACRO_META 
//    = Var.intern(CLOJURE_NS, Symbol.intern("*macro-meta*"), null);
//= Var.intern(CLOJURE_NS, Symbol.intern("*assert*"), RT.T);
//= Var.intern(CLOJURE_NS, Symbol.intern("*use-context-classloader*"), RT.T);
// boolean
//static readonly Symbol IDENTICAL = Symbol.intern("identical?");
//sealed class IdenticalFn : AFn
//{
//    public override object invoke(object arg1, object arg2)
//    {
//        //return Object.ReferenceEquals(arg1, arg2) ? RT.T : RT.F;
//        if ( arg1 is ValueType )
//            //return arg1.Equals(arg2) ? RT.T : RT.F;
//            return arg1.Equals(arg2);
//        else
//            //return arg1 == arg2 ? RT.T : RT.F;
//            return arg1 == arg2;
//    }
//}
// TODO: Check for existence of ClojureContext.Default before doing this?
// We don't have MathContext (yet)
//MATH_CONTEXT.Tag = Symbol.intern("java.math.MathContext");
//// during bootstrap, ns same as in-ns
//Var nv = Var.intern(CLOJURE_NS, NAMESPACE, new InNamespaceFn());
//v = Var.intern(CLOJURE_NS, IDENTICAL, new IdenticalFn());
//v.setMeta(map(dockw, "tests if 2 arguments are the same object",
//    arglistskw, list(vector(Symbol.intern("x"), Symbol.intern("y")))));
// We need to prevent loading more than once.
//load("clojure/spec/alpha");
//load("clojure/core/specs/alpha");
// Load clojure.core
//Stopwatch sw = new Stopwatch();
//sw.Start();
//sw.Stop();
//Console.WriteLine("Initial clojure/core load: {0} milliseconds.", sw.ElapsedMilliseconds);
// load spec
// start socket servers
// This is AtomicInteger in the JVM version.
// The only place accessed is in nextID, so seems unnecessary.
// initial-lowercase name, used in core.clj
// Because of the need to look before you leap (make sure one element exists)
// this is more complicated than the JVM version:  In JVM-land, you can hasNext before you move.
// Assumes MoveNext has already been called on _iter.
// N.B. canSeq must be kept in sync with this!
// java: Iterable  -- reordered clauses so others take precedence.
// chunkIteratorSeq
// The equivalent for Java:Map is IDictionary.  IDictionary is IEnumerable, so is handled above.
//else if(coll isntanceof Map)  
//     return seq(((Map) coll).entrySet());
// Used to be in the java version:
//else if (coll is IEnumerator)  // java: Iterator
//    return EnumeratorSeq.create((IEnumerator)coll);
// handled by IEnumerable case above
// reordered
//return RT.F;
//return ((Associative)coll).containsKey(key) ? RT.T : RT.F;
//return ((IPersistentSet)coll).contains(key) ? RT.T : RT.F;
//return m.Contains(key) ? RT.T : RT.F;
// ISet<T> does not exist for CLR2
// TODO: Make this work for HashSet<T> no matter the T
// return  hs.Contains(key) ? RT.T : RT.F;
// TODO: Make this work for ISet<T> no matter the T
// return  iso.Contains(key) ? RT.T : RT.F;
// RT.T, RT.F
// RT.T, RT.F
//static public Object nth(object coll, long n)
//{
//    return nth(coll, (int)n);
//}
// Java has RandomAccess here.  CLR has no equiv.
// Trying to replace it with IList caused some real problems,  See the fix in ASeq.
//static public Object nth(Object coll, long n, Object notFound)
//{
//    return nth(coll, (int)n, notFound);
//}
// Causes a problem with infinite LazySequences
// Four years after the fact, I now know why the change was made in Java Rev 1218.
// There is no RandomAccess equivalent in CLR.
// So we don't blow off IList's completely, I put this after the code that catches LazySeqs.
//IList list = coll as IList;
//if (list != null)   // Changed to RandomAccess in Java Rev 1218.  
//{
//    if (n < list.Count)
//        return list[n];
//    return notFound;
//}
// release in case GC
// JVM version has the following, but they really seem to mess things up for me.
//public static char charCast(byte x)
//{
//    char i = (char)x;
//    if (i != x)
//        throw new ArgumentException("Value out of range for char: " + x);
//    return i;
//}
//public static char charCast(sbyte x)
//{
//    char i = (char)x;
//    if (i != x)
//        throw new ArgumentException("Value out of range for char: " + x);
//    return i;
//}
//public static char charCast(short x)
//{
//    char i = (char)x;
//    if (i != x)
//        throw new ArgumentException("Value out of range for char: " + x);
//    return i;
//}
//public static char charCast(ushort x)
//{
//    char i = (char)x;
//    if (i != x)
//        throw new ArgumentException("Value out of range for char: " + x);
//    return i;
//}
//public static char charCast(int x)
//{
//    char i = (char)x;
//    if (i != x)
//        throw new ArgumentException("Value out of range for char: " + x);
//    return i;
//}
//public static char charCast(uint x)
//{
//    char i = (char)x;
//    if (i != x)
//        throw new ArgumentException("Value out of range for char: " + x);
//    return i;
//}
//public static char charCast(ulong x)
//{
//    char i = (char)x;
//    if (i != x)
//        throw new ArgumentException("Value out of range for char: " + x);
//    return i;
//}
//public static char charCast(float x)
//{
//    if (x >= Char.MinValue && x <= char.MaxValue)
//        return (char)x;
//    throw new ArgumentException("Value out of range for char: " + x);
//}
// In CLR, ICollection does not have a toArray.  
// ICollection derives from IEnumerable, so the IEnumerable clause will take care of it.
//if (coll instanceof Collection)
//  return ((Collection)coll).toArray();
//  TODO: List has a toArray -- generic -- need type. 
// Java has Map here, but IDictionary is IEnumerable, so it will be handled by previous clause.
// TODO: Determine if we need to make a copy (Java version does, not sure if CLR requires it)
// This used to be in the java version.  No longer.  Do we need?
//else if (coll is ISeq)
//    return toArray((ISeq)coll);
//else if (coll is IPersistentCollection)
//    return toArray(((IPersistentCollection)coll).seq());
//private static object[] toArray(ISeq seq)
//{
//    object[] array = new object[seq.count()];
//    int i = 0;
//    for (ISeq s = seq; s != null; s = s.rest(), i++)
//        array[i] = s.first();
//    return array;
//}
//call multimethod
// Print meta, if exists & should be printed
//else
//    w.Write(x.ToString());
// The clause above is what Java has, and would have been nice.
// Doesn't work for me, for one reason:  
// When generating initializations for static variables in the classes representing IFns,
//    let's say the value is the double 7.0.
//    we generate code that says   (double)RT.readFromString("7")
//    so we get a boxed int, which CLR won't cast to double.  Sigh.
//    So I need double/float to print a trailing .0 even when integer-valued.
// fastest path, will succeed for assembly qualified names (returned by Type.AssemblyQualifiedName)
// or namespace qualified names (returned by Type.FullName) in the executing assembly or mscorlib
// e.g. "UnityEngine.Transform, UnityEngine, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null"
// fast path, will succeed for namespace qualified names (returned by Type.FullName)
// e.g. "UnityEngine.Transform"
// slow path, will succeed for display names (returned by Type.Name)
// e.g. "Transform"
// I do not know why Assembly.GetType fails to find types in our assemblies in Mono
// multiple, ambiguous
// overloads for array getters/setters
// was ((IComparable)x).CompareTo(y); -- changed in Java rev 1145
//  Somewhere, there is an explicit call to compare
// was ((IComparable)x).CompareTo(y);-- changed in Java rev 1145
// do we need this?
//static Boolean HasTag(object o, object tag)
//{
//    return Util.equals(tag,,RT.get(RT.meta(o),TAG_KEY);
//}
// In core.clj, we see (cast Number x)  in a number of numeric methods.
// There is no Number wrapper here.
// The intent is:  if x is not a numeric value, throw a ClassCastException (Java),
//                 else return x
// And here it is:
// The Java guys use Class.cast to do casting.
// We don't have that.
// Perhaps this will work.
// NOPE!
//public static object Cast(Type t, object o)
//{
//    return Type.DefaultBinder.ChangeType(o, t, null);
//}
// The Java version goes through Array.sort to do this,
// but I don't have a way to pass a comparator.
// Surprisingly hard, due to non-BMP (multiple character) codes.
// This solution from http://stackoverflow.com/questions/228038/best-way-to-reverse-a-string-in-c-2-0
// allocate a buffer to hold the output
// check for surrogate pair
// preserve the order of the surrogate pair code units
// Hopefully only dynamic assemblies
// We catch them above because we know dynamic assemblies do not support this
// duck typing stderr plays nice with e.g. swank 
/// <summary>
/// Disable file loading
/// </summary>
/// <remarks>Prevent the load method from searching the file system for .clj and .clj.dll files.  
/// Used in production systems when all namespaces are to be found in loaded assemblies.</remarks>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Seqable.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents an object that can produce an <see cref="ISeq"/>.
/// </summary>
/// <summary>
/// Gets an <see cref="ISeq"/>to allow first/rest/next iteration through the collection.
/// </summary>
/// <returns>An <see cref="ISeq"/> for iteration.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\SeqEnumerator.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Construct one from a given sequence.  (preserve original ctor for compatibility)
/// </summary>
/// <param name="seq">The underlying sequence.</param>
/// <summary>
/// Construct one from a given sequence.
/// </summary>
/// <param name="seq">The underlying sequence.</param>
/// <summary>
/// The current item.
/// </summary>
/// <summary>
/// Move to the next item.
/// </summary>
/// <returns><value>true</value> if there is a next item; 
/// <value>false</value> if the sequence is already at the end.</returns>
// TODO: Fix this -- we already realized this.
/// <summary>
/// Implements standard IEnumerator behavior over an <see cref="ISeq">ISeq</see>.
/// </summary>
/// <remarks>Equivalent to Java verion: SeqIterator</remarks>
/// <summary>
/// Construct one from a given sequence. (preserve original ctor for compatibility)
/// </summary>
/// <param name="seq">The underlying sequence.</param>
/// <summary>
/// Construct one from a given sequence.
/// </summary>
/// <param name="seq">The underlying sequence.</param>
/// <summary>
/// Construct one from a given sequence. (preserve original ctor for compatibility)
/// </summary>
/// <param name="seq">The underlying sequence.</param>
/// <summary>
/// Construct one from a given sequence.
/// </summary>
/// <param name="seq">The underlying sequence.</param>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Sequential.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Marks the object as being a sequential collection.
/// </summary>
//empty
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Settable.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
///  Represents an object with a value that can be set.
/// </summary>
/// <summary>
/// Sets the value.
/// </summary>
/// <param name="val">The new value</param>
/// <returns>The new value.</returns>
/// <remarks>Can only be called in a transaction or with a binding on the stack, else throws an exception.</remarks>
/// <summary>
/// Sets the root value.
/// </summary>
/// <param name="val">The new value</param>
/// <returns>The new value.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Sorted.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents an immutable collection that is sorted.
/// </summary>
/// <remarks>
/// <para>Lowercase-named methods for compatibility with the JVM implementation.</para>
/// </remarks>
/// <summary>
/// Returns the comparer used to sort the elements in the collection.
/// </summary>
/// <returns>The <c>IComparer</c> used to sort the items.</returns>
/// <remarks>Would be called <c>Comparer</c> except we need to match the JVM name.</remarks>
/// <summary>
/// Returns the key to be passed to the comparator to sort the element.
/// </summary>
/// <param name="entry">An element in the collection.</param>
/// <returns>The key used to sort the element.</returns>
/// <summary>
/// Returns an <see cref="ISeq">ISeq</see> to iterate through the collection in the designated direction. 
/// </summary>
/// <param name="ascending">A flag indicating if the iteration is ascending or descending.</param>
/// <returns>A sequence for first/rest iteration.</returns>
/// <summary>
/// Returns an <see cref="ISeq">ISeq</see> to iterate through the collection in the designated direction starting from a particular key. 
/// </summary>
/// <param name="key">The key at which to start the iteration.</param>
/// <param name="ascending">A flag indicating if the iteration is ascending or descending.</param>
/// <returns>A sequence for first/rest iteration.</returns>
/// <remarks>The key need not be in the collection.  If not present, the iteration will start with 
/// the first element with a key greater than (if asscending) or less than (if descending) the given key.</remarks>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\StringSeq.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// A sequence of characters from a string.
/// </summary>
/// <summary>
/// The string providing the characters.
/// </summary>
/// <summary>
/// Current position in the string.
/// </summary>
/// <summary>
/// Create a <see cref="StringSeq">StringSeq</see> from a String.
/// </summary>
/// <param name="s"></param>
/// <returns></returns>
/// <summary>
/// Construct a <see cref="StringSeq">StringSeq</see> from given metadata, string, position.
/// </summary>
/// <param name="meta">The metadata to attach.</param>
/// <param name="s">The string.</param>
/// <param name="i">The current position.</param>
/// <summary>
/// Gets the first item.
/// </summary>
/// <returns>The first item.</returns>
/// <summary>
/// Return a seq of the items after the first.  Calls <c>seq</c> on its argument.  If there are no more items, returns nil."
/// </summary>
/// <returns>A seq of the items after the first, or <c>nil</c> if there are no more items.</returns>
/// <summary>
/// Gets the number of items in the collection.
/// </summary>
/// <returns>The number of items in the collection.</returns>
/// <summary>
/// Create a copy with new metadata.
/// </summary>
/// <param name="meta">The new metadata.</param>
/// <returns>A copy of the object with new metadata attached.</returns>
/// <summary>
/// Gets the index associated with this sequence.
/// </summary>
/// <returns>The index associated with this sequence.</returns>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Symbol.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents a symbol.
/// </summary>
/// <remarks>See the Clojure documentation for more information.</remarks>
/// <summary>
/// The name of the namespace for this symbol (if namespace-qualified).
/// </summary>
/// <summary>
/// The name of the symbol.
/// </summary>
/// <summary>
/// The cached hashcode.
/// </summary>
// cache ToString/ToStringEscaped if called
// the create thunks preserve binary compatibility with code compiled
// against earlier version of Clojure and can be removed (at some point).
/// <summary>
/// Intern a symbol with the given name  and namespace-name.
/// </summary>
/// <param name="ns">The name of the namespace.</param>
/// <param name="name">The name of the symbol.</param>
/// <returns>A new symbol.</returns>
/// <remarks>
/// Interning here does not imply uniquifying.  
/// The strings for the namespace-name and the symbol-name are uniquified.
/// </remarks>
/// <summary>
/// Intern a symbol with the given name (extracting the namespace if name is of the form ns/name).
/// </summary>
/// <param name="nsname">The (possibly qualified) name</param>
/// <returns>A new symbol.</returns>
/// <summary>
/// Construct a symbol from interned namespace name and symbol name.
/// </summary>
/// <param name="ns_interned">The (interned) namespace name.</param>
/// <param name="name_interned">The (interned) symbol name.</param>
/// <summary>
/// Construct a symbol from interned namespace name and symbol name,  with given metadata.
/// </summary>
/// <param name="meta">The metadata to attach.</param>
/// <param name="ns_interned">The (interned) namespace name.</param>
/// <param name="name_interned">The (interned) symbol name.</param>
/// <summary>
/// Construct a Symbol during deserialization.
/// </summary>
/// <param name="info"></param>
/// <param name="context"></param>
/// <summary>
/// Return  a string representing the symbol.
/// </summary>
/// <returns>A string representing the symbol.</returns>
/// <summary>
/// Determine if an object is equal to this symbol.
/// </summary>
/// <param name="obj">The object to compare to.</param>
/// <returns><value>true</value> if they are the same;<value>false</value> otherwise.</returns>
/// <remarks>Uses value semantics, value determined by namespace name and symbol name.</remarks>
/// <summary>
/// Get the hash code.
/// </summary>
/// <returns>The hash code.</returns>
/// <summary>
/// Create a copy with new metadata.
/// </summary>
/// <param name="meta">The new metadata.</param>
/// <returns>A copy of the object with new metadata attached.</returns>
// I prefer to use these internally.
/// <summary>
/// Get the namespace name.
/// </summary>
/// <summary>
/// Get the symbol name.
/// </summary>
// the following are in the interface
/// <summary>
/// Get the namespace name.
/// </summary>
/// <returns>The namespace name.</returns>
/// <summary>
/// Gets the symbol name.
/// </summary>
/// <returns>The symbol name.</returns>
/// <summary>
/// Compare this symbol to another object.
/// </summary>
/// <param name="obj">The object to compare to.</param>
/// <returns>neg,zero,pos semantics.</returns>
///// <summary>
///// Create a copy of this symbol.
///// </summary>
///// <returns>A copy of this symbol.</returns>
//private object readResolve()
//{
//    return intern(_ns, _name);
//}
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\TaggedLiteral.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//if (o == null || GetType() != o.GetType()) return false;
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Task35.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Minimal implementation of task functionality to support reducers library under .Net 3.5
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\TransformerEnumerator.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/* Alex Miller 3/3/15 */
/**
// Source
// Iteration state
// continue
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Tuple.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/* rich 7/16/15 */
// proposed by Zach Tellman
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\TypeNotFoundException.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Util.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//using BigDecimal = java.math.BigDecimal;
//a la boost
// Had to change this back when doing the new == vs = 
// Changed in Rev 1215
//if (k1 == k2)
//    return true;
//if (k1 != null)
//{
//    if (IsNumeric(k1) && IsNumeric(k2))
//        return Numbers.equiv(k1, k2);
//    return k1.Equals(k2);
//}
//return false;
//public static bool equals(long x, long y)
//{
//    return x == y;
//}
//public static bool equals(double x, double y)
//{
//    return x == y;
//}
//public static bool equals(long x, object y)
//{
//    return equals(Numbers.num(x), y);
//}
//public static bool equals(object x, long y)
//{
//    return equals(x, Numbers.num(y));
//}
//public static bool equals(double x, object y)
//{
//    return equals(Numbers.num(x), y);
//}
//public static bool equals(object x, double y)
//{
//    return equals(x, Numbers.num(y));
//}
// I would prefer simpler version below, but it can't handle simple true/false (boxed booleans)
//return k1 == k2;
//
//
//
// A variant of the above that avoids multiplying
// This algo is in a lot of places.
// See, for example, http://aggregate.org/MAGIC/#Population%20Count%20(Ones%20Count)
// This algo is in a lot of places.
// See, for example, http://aggregate.org/MAGIC/#Leading%20Zero%20Count
// THE DLR BigInteger code uses the following.
// It's probably faster.
//int shift = 0;
//if ((value & 0xFFFF0000) == 0) { value <<= 16; shift += 16; }
//if ((value & 0xFF000000) == 0) { value <<= 8; shift += 8; }
//if ((value & 0xF0000000) == 0) { value <<= 4; shift += 4; }
//if ((value & 0xC0000000) == 0) { value <<= 2; shift += 2; }
//if ((value & 0x80000000) == 0) { value <<= 1; shift += 1; }
//return shift;
//return t != null && t.IsPrimitive && t != typeof(void);
// STRUCT TEST
// for nested types, we have to work harder
//type = GetNonNullableType(type);
//if (!type.IsEnum)
//{
//}
// I can hardly claim this is original.
// The following code is from Microsoft's DLR..
// It had the following notice:
/* ****************************************************************************
//type = GetNonNullableType(type);
//if (!type.IsEnum)
//{
//}
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Var.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Represents a Var.
/// </summary>
/// <remarks>
/// <para>From the Clojure documentation:</para>
/// <blockquote>"Vars provide a mechanism to refer to a mutable storage location 
/// that can be dynamically rebound (to a new storage location) on a per-thread basis. 
/// Every Var can (but needn't) have a root binding, 
/// which is a binding that is shared by all threads that do not have a per-thread binding."</blockquote>
/// </remarks>
//public Object throwArity(int n)
//{
//    throw new InvalidOperationException("Attempting to call unbound fn: " + _v.ToString());
//}
/// <summary>
/// Represents a set of Var bindings established at a particular point in the call stack.
/// </summary>
/// <summary>
/// A mapping from <see cref="Var">Var</see>s to <see cref="TBox"/>es holding their values.
/// </summary>
/// <summary>
/// Get mapping from <see cref="Var">Var</see>s to <see cref="TBox"/>es holding their values.
/// </summary>
/// <summary>
/// The previous <see cref="Frame">Frame</see> on the stack.
/// </summary>
/// <summary>
/// Get the previous <see cref="Frame">Frame</see> on the stack.
/// </summary>
/// <summary>
/// Construct a frame on the stack.
/// </summary>
/// <param name="frameBindings">The bindings for this frame only.</param>
/// <param name="bindings">Bindings all the way down the stack.</param>
/// <param name="prev">The previous frame.</param>
//_frameBindings = frameBindings;
/// <summary>
/// Revision counter
/// </summary>
//set { Var._rev = value; }
/// <summary>
/// The current frame.  Thread-local.
/// </summary>
/// <summary>
/// Get/set the current frame.
/// </summary>
/// <remarks>Best to make all access to _currentFrame through this accessor.</remarks>
/// <summary>
/// The root value.
/// </summary>
/// <summary>
/// If true, supports dynamic binding.
/// </summary>
//static IPersistentMap _privateMeta = new PersistentArrayMap(new object[] { _privateKey, RT.T });
/// <summary>
/// The number of bindings for this var on the binding stack.
/// </summary>
//AtomicInteger _count;       
/// <summary>
/// The symbol naming this var, if named.
/// </summary>
/// <summary>
/// Get the symbol naming this var, if named.
/// </summary>
/// <summary>
/// The namespace holding this var.
/// </summary>
/// <summary>
/// Get the namespace holding this var.
/// </summary>
/// <summary>
/// Intern a named var in a namespace, with given value.
/// </summary>
/// <param name="ns">The namespace.</param>
/// <param name="sym">The name.</param>
/// <param name="root">The root value.</param>
/// <returns>The var that was found or created.</returns>
/// <summary>
/// Intern a named var in a namespace, with given value (if has a root value already, then change only if replaceRoot is true).
/// </summary>
/// <param name="ns">The namespace.</param>
/// <param name="sym">The name.</param>
/// <param name="root">The root value.</param>
/// <param name="replaceRoot">Replace an existing root value if <value>true</value>.</param>
/// <returns>The var that was found or created.</returns>
/// <summary>
/// Intern a named var in a namespace (creating the namespece if necessary).
/// </summary>
/// <param name="nsName">The name of the namespace.  (A namespace with this name will be created if not existing already.)</param>
/// <param name="sym">The name of the var.</param>
/// <returns>The var that was found or created.</returns>
/// <summary>
/// Intern a named var (flagged private) in a namespace (creating the namespece if necessary).
/// </summary>
/// <param name="nsName">The name of the namespace.  (A namespace with this name will be created if not existing already.)</param>
/// <param name="sym">The name of the var.</param>
/// <returns>The var that was found or created.</returns>
/// <remarks>Added in Java Rev 1110.</remarks>
/// <summary>
/// Intern a named var in a namespace.
/// </summary>
/// <param name="ns">The namespace.</param>
/// <param name="sym">The name.</param>
/// <returns></returns>
/// <summary>
/// Create an uninterned var.
/// </summary>
/// <returns>An uninterned var.</returns>
/// <summary>
/// Create an uninterned var with a root value.
/// </summary>
/// <param name="root">The root value.</param>
/// <returns>An uninterned var.</returns>
/// <summary>
/// Construct a var in a given namespace with a given name.
/// </summary>
/// <param name="ns">The namespace.</param>
/// <param name="sym">The var.</param>
/// <summary>
/// Construct a var in a given namespace with a given name and root value.
/// </summary>
/// <param name="ns">The namespace.</param>
/// <param name="sym">The var.</param>
/// <param name="root">The root value.</param>
/// <summary>
/// Return a string representing this var.
/// </summary>
/// <returns>A string representing this var.</returns>
/// <summary>
/// Set the metadata attached to this var.
/// </summary>
/// <param name="m">The metadata to attach.</param>
/// <remarks>The metadata must contain entries for the namespace and name.
/// <para>Lowercase name for core.clj compatability.</para></remarks>
// ensure these basis keys
/// <summary>
/// Add a macro=true flag to the metadata.
/// </summary>
/// <remarks>Lowercase name for core.clj compatability.</remarks>
//alterMeta(_assoc, RT.list(_macroKey, RT.T));
/// <summary>
/// Is the var a macro?
/// </summary>
/// <summary>
/// Is the var public?
/// </summary>
/// <summary>
/// Get the tag on the var.
/// </summary>
/// <remarks>In Java code, setTag takes only Symbols.  Don't know why.  I ran into a problem when I changed the type to Symbol.</remarks>
/// <summary>
/// Does the var have value?
/// </summary>
/// <summary>
/// Does the var have a root value?
/// </summary>
/// <returns></returns>
/// <summary>
/// Set the value of the var.
/// </summary>
/// <param name="val">The new value.</param>
/// <returns>the new value.</returns>
/// <remarks>It is an error to set the root binding with this method.</remarks>
/// <summary>
/// Change the root value.  (And clear the macro flag.)
/// </summary>
/// <param name="root">The new value.</param>
/// <remarks>binding root clears macro flag
/// <summary>
/// Change the root value.
/// </summary>
/// <param name="root">The new value.</param>
/// <summary>
/// Unbind the var's root value.
/// </summary>
/// <summary>
/// Set var's root to a computed value.
/// </summary>
/// <param name="fn">The function to apply to the current value to get the new value.</param>
/// <summary>
/// Change the var's root to a computed value (based on current value and supplied arguments).
/// </summary>
/// <param name="fn">The function to compute the new value.</param>
/// <param name="args">Additional arguments.</param>
/// <returns>The new value.</returns>
/// <remarks> initial lowercase in name needed for core.clj</remarks>
/// <summary>
/// Push a new frame of bindings onto the binding stack.
/// </summary>
/// <param name="bindings">The new bindings.</param>
/// <remarks>Lowercase name for core.clj compatability.</remarks>
/// <summary>
/// Pop the topmost binding frame from the stack.
/// </summary>
/// <remarks>Lowercase name for core.clj compatability.</remarks>
/// <summary>
/// 
/// </summary>
/// <returns></returns>
/// <remarks>Lowercase name for core.clj compatability.</remarks>
/// <summary>
/// Get the box of the current binding on the stack for this var, or null if no binding.
/// </summary>
/// <returns>The box of the current binding on the stack (or null if no binding).</returns>
/// <summary>
/// Gets the (immutable) value the reference is holding.
/// </summary>
/// <returns>The value</returns>
/// <remarks>When IDeref was added and get() was renamed to deref(), this was put in.  
/// Why?  Perhaps to avoid having to change Var.get() references all over.  
/// For example, core.clj still has var-get calling this.
/// But then they rename all uses anyway.</remarks>
/// <summary>
/// Gets the (immutable) value the reference is holding.
/// </summary>
/// <returns>The value</returns>
//if (hasRoot())
//    return _root;
//throw new InvalidOperationException(String.Format("Var {0}/{1} is unbound.", _ns,_sym));
/// <summary>
/// Sets the validator.
/// </summary>
/// <param name="vf">The new validtor</param>
/// <summary>
/// Find the var from a namespace-qualified symbol.
/// </summary>
/// <param name="nsQualifiedSym">A namespace-qualified symbol.</param>
/// <returns>The var, if found.</returns>
/// <summary>
/// The namespace this var is interned in.
/// </summary>
/// <returns></returns>
/// <summary>
/// Sets the value.
/// </summary>
/// <param name="val">The new value</param>
/// <returns>The new value.</returns>
/// <remarks>Can only be called with a binding on the stack, else throws an exception.</remarks>
/// <summary>
/// Sets the root value.
/// </summary>
/// <param name="val">The new value</param>
/// <returns>The new value.</returns>
/// <summary>
/// Used in calls to alterMeta, above.
/// </summary>
/// <summary>
/// Used in calls to alterMeta, above.
/// </summary>
/// <summary>
/// Return a symbol naming this Var
/// </summary>
/// <returns></returns>
// note from JVM version:
/***
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Volatile.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\WarnBoxedMathAttribute.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Lib\Properties\AssemblyInfo.cs
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
// The following GUID is for the ID of the typelib if this project is exposed to COM
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Properties\AssemblyInfo.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
// The following GUID is for the ID of the typelib if this project is exposed to COM
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Properties\Resources.Designer.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18034
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
/// <summary>
///   A strongly-typed resource class, for looking up localized strings, etc.
/// </summary>
// This class was auto-generated by the StronglyTypedResourceBuilder
// class via a tool like ResGen or Visual Studio.
// To add or remove a member, edit your .ResX file then rerun ResGen
// with the /str option, or rebuild your VS project.
/// <summary>
///   Returns the cached ResourceManager instance used by this class.
/// </summary>
/// <summary>
///   Overrides the current thread's CurrentUICulture property for all
///   resource lookups using this strongly typed resource class.
/// </summary>
/// <summary>
///   Looks up a localized string similar to version=1.5.0-master-SNAPSHOT.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Readers\LineNumberingTextReader.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// 
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Readers\PushbackInputStream.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Readers\PushbackTextReader.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Runtime\ClojureContext.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Returns an overload resolver for the current ClojureContext.  
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Runtime\ClojureOps.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Contains functions that are called directly from
/// generated code to perform low-level runtime functionality.
/// </summary>
// TODO: Scour gen code to find things to move here.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Runtime\ClojureOptions.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Gets the collection of command line arguments.
/// </summary>
/*!*/ Arguments
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Runtime\ConversionWrappers.cs
// Ripped off directly from IPy
// I couldn't think of a better way to do it.
// So the code below is under the following:
/* ****************************************************************************
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Runtime\Converter.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// NarrowingLevel.Zero
//  I don't want to consider boxing before numeric conversion, else I don't get the convert-int-to-long  behavior required to select Numbers.lt(long,long) over Numbers.lt(long,Object)
//  We also need to get the narrow-long-to-int behavior required to avoid casting in host expression calls.
//  IronRuby and IronPython both do this here: 
//if (toType.IsAssignableFrom(fromType))
//{
//    return true;
//}
// Because long[] and ulong[] are inter-assignable, we run into problems.
// Let's just not convert from an array of one primitive type to another.
// A COM object could be cast to any interface
// try available type conversions...
//!!!do user-defined implicit conversions here
// NarrowingLevel.One
// NarrowingLevel.Two
// NarrowingLevel.Three
// Handle conversions of IEnumerable<Object> or IEnumerable to IEnumerable<T> for any T
// Similar to code in IPy's IronPython.Runtime.Converter.HasNarrowingConversion
// NarrowingLevel.All
// pick up boxing numerics here
// TODO: Rethink.  IPy has the following, but we get overload problems on Numbers ops
//return HasNarrowingConversion(fromType, toType, level);
// Handle conversions of IEnumerable<Object> or IEnumerable to IEnumerable<T> for any T
// Similar to code in IPy's IronPython.Runtime.Converter.HasNarrowingConversion
// Ripped off from IPy
// this can be handled later.
// Modified from IPy code
//case TypeCode.Single:
//case TypeCode.Double:
//case TypeCode.Decimal:
//if (toType == BigDecimalType) return true;
//case TypeCode.Int16:
//case TypeCode.Int32:
//case TypeCode.Int64:
//case TypeCode.Single:
//case TypeCode.Double:
//case TypeCode.Decimal:
//if (toType == BigDecimalType) return true;
//case TypeCode.Single:
//case TypeCode.Double:
//case TypeCode.Decimal:
//case TypeCode.Int32:
//case TypeCode.Int64:
//case TypeCode.Single:
//case TypeCode.Double:
//case TypeCode.Decimal:
//if (toType == BigDecimalType) return true;
//case TypeCode.Single:
//case TypeCode.Double:
//case TypeCode.Decimal:
//if (toType == BigDecimalType) return true;
//case TypeCode.Int64:
//case TypeCode.Single:
//case TypeCode.Double:
//case TypeCode.Decimal:
//if (toType == BigDecimalType) return true;
//case TypeCode.Single:
//case TypeCode.Double:
//case TypeCode.Decimal:
//    return true;
//if (toType == BigDecimalType) return true;
//case TypeCode.Single:
//case TypeCode.Double:
//case TypeCode.Decimal:
//    return true;
//if (toType == BigDecimalType) return true;
//case TypeCode.UInt16:
//case TypeCode.Int32:
//case TypeCode.UInt32:
//case TypeCode.Int64:
//case TypeCode.UInt64:
//case TypeCode.Single:
//case TypeCode.Double:
//case TypeCode.Decimal:
//    return true;
//if (toType == BigIntegerType) return true;
//if (toType == BigIntType) return true;
//if (toType == BigDecimalType) return true;
//        //private static bool HasNarrowingConversion(Type fromType, Type toType, NarrowingLevel level)
//        //{
//        //    if (level == NarrowingLevel.Three)
//        //    {
//        //        if (toType == CharType && fromType == StringType) return true;
//        //        if (toType == StringType && fromType == CharType) return true;
//        //        //Check if there is an implicit convertor defined on fromType to toType
//        //        if (HasImplicitConversion(fromType, toType))
//        //        {
//        //            return true;
//        //        }
//        //    }
//        //    if (toType == DoubleType && fromType == DecimalType) return true;
//        //    if (toType == SingleType && fromType == DecimalType) return true;
//        //    //if (toType.IsArray)
//        //    //{
//        //    //    return typeof(PythonTuple).IsAssignableFrom(fromType);
//        //    //}
//        //    if (level == NarrowingLevel.Three)
//        //    {
//        //        if (IsNumeric(fromType) && IsNumeric(toType))
//        //        {
//        //            if (fromType != typeof(float) && fromType != typeof(double) && fromType != typeof(decimal))
//        //            {
//        //                return true;
//        //            }
//        //        }
//        //        if (fromType == typeof(bool) && IsNumeric(toType)) return true;
//        //        if (toType == CharType && fromType == StringType) return true;
//        //        if (toType == Int32Type && fromType == BooleanType) return true;
//        //        // Everything can convert to Boolean in Python
//        //        if (toType == BooleanType) return true;
//        //        // TODO: Figure out Clojure equivalent
//        //        //if (DelegateType.IsAssignableFrom(toType) && IsPythonType(fromType)) return true;
//        //        //if (IEnumerableType == toType && IsPythonType(fromType)) return true;
//        //        //if (toType == typeof(IEnumerator))
//        //        //{
//        //        //    if (IsPythonType(fromType)) return true;
//        //        //}
//        //        //else if (toType.IsGenericType)
//        //        //{
//        //        //    Type genTo = toType.GetGenericTypeDefinition();
//        //        //    if (genTo == IEnumerableOfTType)
//        //        //    {
//        //        //        return IEnumerableOfObjectType.IsAssignableFrom(fromType) ||
//        //        //            IEnumerableType.IsAssignableFrom(fromType) ||
//        //        //            fromType == typeof(OldInstance);
//        //        //    }
//        //        //    else if (genTo == typeof(System.Collections.Generic.IEnumerator<>))
//        //        //    {
//        //        //        if (IsPythonType(fromType)) return true;
//        //        //    }
//        //        //}
//        //    }
//        //    if (level == NarrowingLevel.All)
//        //    {
//        //        //__int__, __float__, __long__
//        //        if (IsNumeric(fromType) && IsNumeric(toType)) return true;
//        //   }
//        //    if (toType.IsGenericType)
//        //    {
//        //        Type genTo = toType.GetGenericTypeDefinition();
//        //        if (genTo == IListOfTType)
//        //        {
//        //            return IListOfObjectType.IsAssignableFrom(fromType);
//        //        }
//        //        else if (genTo == NullableOfTType)
//        //        {
//        //            if (fromType == typeof(DynamicNull) || CanConvertFrom(fromType, toType.GetGenericArguments()[0], level))
//        //            {
//        //                return true;
//        //            }
//        //        }
//        //        else if (genTo == IDictOfTType)
//        //        {
//        //            return IDictionaryOfObjectType.IsAssignableFrom(fromType);
//        //        }
//        //    }
//        //    if (fromType == BigIntegerType && toType == Int64Type) return true;
//        //    if (fromType == BigIntType && toType == Int64Type) return true;
//        //    if (toType.IsEnum && fromType == Enum.GetUnderlyingType(toType)) return true;
//        //    return false;
//        //}
//        // TODO: Merge with equivalent in clojure.lang.Util
//        internal static bool IsNumeric(Type t)
//        {
//            if (t.IsEnum) return false;
//            switch (Type.GetTypeCode(t))
//            {
//                case TypeCode.DateTime:
//                case TypeCode.DBNull:
//                case TypeCode.Char:
//                case TypeCode.Empty:
//                case TypeCode.String:
//                case TypeCode.Boolean:
//                    return false;
//                case TypeCode.Object:
//                    return t == BigIntType || t == BigIntegerType || t == BigDecimalType;
//                default:
//                    return true;
//            }
//        }
//        // ripped off from IPy
//        private static bool HasImplicitConversion(Type fromType, Type toType)
//        {
//            return
//                HasImplicitConversionWorker(fromType, fromType, toType) ||
//                HasImplicitConversionWorker(toType, fromType, toType);
//        }
//        // ripped off from IPy
//        private static bool HasImplicitConversionWorker(Type lookupType, Type fromType, Type toType)
//        {
//            while (lookupType != null)
//            {
//                foreach (MethodInfo method in lookupType.GetMethods())
//                {
//                    if (method.Name == "op_Implicit" &&
//                        method.GetParameters()[0].ParameterType.IsAssignableFrom(fromType) &&
//                        toType.IsAssignableFrom(method.ReturnType))
//                    {
//                        return true;
//                    }
//                }
//                lookupType = lookupType.BaseType;
//            }
//            return false;
//        }
// TODO:  Cache created delegates
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Runtime\ImmutableDictionaryEnumerator.cs
/// <summary>
/// Enumerator for IDictionary objects that are immutable.  (No caching, not explicitly made thread-safe.)
/// </summary>
// Make a copy of the dictionary entries currently in the SimpleDictionary object.
// Return the current item.
// Return the current dictionary entry.
// Return the key of the current item.
// Return the value of the current item.
// Advance to the next item.
// Validate the enumeration index and throw an exception if the index is out of range.
// Reset the index to restart the enumeration.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Runtime\Printf.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// An implementation of Java-style printf/format
/// </summary>
/// <remarks>
/// <para>Primary inspiration from the Java OpenJDK source.  In fact, this is a pretty straightforward translations
/// of the relevant parts.  I make no claims to any originality in what follows.
/// The idea was to get something working with the minimum of thought and effort.</para>
/// </remarks>
// TODO: extend Printf to BigDecimal
// TODO: extend Printf to decimal
// TODO: implement DateTime
// TODO: implement HexFloat
// TODO: implement grouping for GeneralFloat
// TODO: implement grouping for %d on BigInteger
/// <summary>
/// Detects % formatting codes:  %[argument_index$][flags][width][.precision][t]conversion
/// </summary>
// Find the text chunks between the matches.
// no specifiers, just treat as one big text chunk
// we have a plain text chunk in between
// see if there is trailing plain text chunk
// should be no bare naked %s
// must come after ComputeIndex
// must come after ComputeFlags
// must come after ComputeFlags, ComputeDT
// skip trailing $
// skip leading .
// '-' and '0' require a width
// bad combination
// '-' requires a width
// TODO: figure out what formatting spec to use for strings)
// TODO: Decide if we want to make this match the number of digits in the exponent.
// The java version uses two digits.  This flag uses three.
// We could get rid of the extra leading 0 in the exponent if necessary
// TODO: Implement grouping for General Float.
// This would require detecting the Fixed/Float split and
// switching to N format if fixed range and grouping.
// TODO: Implement HexFloat.
// huh.  ConvertToString doesnn't take base with long.
// hex
// Duplicates some code in PrintInteger(StringBuilder,bool,string)
// = 'H' (00 - 23)
//  = 'I' (01 - 12)
//  = 'k' (0 - 23) -- like H
//  = 'l' (1 - 12) -- like I
//  = 'M' (00 - 59)
//  = 'N' (000000000 - 999999999)
//  = 'L' jdk, not in gnu (000 - 999)
//  = 'Q' (0 - 99...?)
//  = 'p' (am or pm)
//  = 's' (0 - 99...?)
//  = 'S' (00 - 60 - leap second)
//  = 'T' (24 hour hh:mm:ss)
//  = 'z' (-1200 - +1200) - ls minus
// TODO: This is not exactly the same as the Java version
//  = 'Z' (symbol)
// Can't do this directly from DateTime.
// Date
//  = 'a' 'a'
//  = 'A' 'A'
//  = 'b' 'b'
//  = 'h' -- same b
//  = 'B' 'B'
//  = 'C' (00 - 99)
//  = 'd' (01 - 31)
//  = 'e' (1 - 31) -- like d
//  = 'j' (001 - 366)
//  = 'm' (01 - 12)
//  = 'y' (00 - 99)
//  = 'Y' (0000 - 9999)
// Composites
//  = 'r' (hh:mm:ss [AP]M)
//  = 'R' (hh:mm same as %H:%M)
// 'c' (Sat Nov 04 12:02:33 EST 1999)
// 'D' (mm/dd/yy)
//  'F' (%Y-%m-%d)
//  = 'z' (-1200 - +1200) - ls minus
// TODO: This is not exactly the same as the Java version -- has : inserted.
// Provide non-virtual to avoid warning from ctor=>CheckDateTime=>CheckLeftJustifyWidth
// ''
// misc
// '-'
// '^'
// '#'
// numerics
// '+'
// ' '
// '0'
// ','
// '('
// indexing
// '<'
// (00 - 23)
// (01 - 12)
// (0 - 23) -- like H
// (1 - 12) -- like I
// (00 - 59)
// (000000000 - 999999999)
// jdk, not in gnu (000 - 999)
// (0 - 99...?)
// (am or pm)
// (0 - 99...?)
// (00 - 60 - leap second)
// (24 hour hh:mm:ss)
// (-1200 - +1200) - ls minus?
// (symbol)
// Date
// 'a'
// 'A'
// 'b'
// 'B'
// (00 - 99)
// (01 - 31)
// (1 - 31) -- like d
// -- same b
// (001 - 366)
// (01 - 12)
// (00 - 99)
// (0000 - 9999)
// Composites
// (hh:mm:ss [AP]M)
// (hh:mm same as %H:%M)
// (Sat Nov 04 12:02:33 EST 1999)
// (mm/dd/yy)
// (%Y-%m-%d)
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Runtime\Properties.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Implements part of the functionaligy of java.util.Properties.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Runtime\Reflector.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// Look for the one declared on this type, if it exists
// This handles the situation where we have overloads.
// Used in generated code
// used in generated code
/// <summary>
/// Parse-time lookup of static method
/// </summary>
/// <param name="spanMap"></param>
/// <param name="targetType"></param>
/// <param name="args"></param>
/// <param name="methodName"></param>
/// <param name="typeArgs"></param>
/// <returns></returns>
/// <summary>
/// Parse-time lookup of instance method
/// </summary>
/// <param name="spanMap"></param>
/// <param name="target"></param>
/// <param name="args"></param>
/// <param name="methodName"></param>
/// <param name="typeArgs"></param>
/// <returns></returns>
/// <summary>
/// Get methods of fixed name and arity.
/// </summary>
/// <param name="targetType"></param>
/// <param name="methodName"></param>
/// <param name="typeArgs"></param>
/// <param name="arity"></param>
/// <param name="getStatics"></param>
/// <returns></returns>
/// <summary>
/// Get constructor matching args for type.
/// </summary>
/// <param name="spanMap"></param>
/// <param name="targetType"></param>
/// <param name="args"></param>
/// <param name="ctorCount"></param>
/// <returns></returns>
// Because no-arg c-tors for value types are handled elsewhere, we defer the warning to there.
/// <summary>
/// Select matching method from list based on args.
/// </summary>
/// <param name="targetType"></param>
/// <param name="args"></param>
/// <param name="methods"></param>
/// <param name="methodName"></param>
/// <param name="isStatic"></param>
/// <returns></returns>
// TODO: See if we can get rid of .Default
//if (methods.Count == 1)
//    return methods[0];
//BindingFlags flags = BindingFlags.Public | BindingFlags.FlattenHierarchy | BindingFlags.InvokeMethod;
//if (getStatics)
//    flags |= BindingFlags.Static;
//else
//    flags |= BindingFlags.Instance;
////MethodInfo[] all = t.GetMethods();
//IEnumerable<MethodInfo> einfo = t.GetMethods(flags).Where(mi => mi.Name == name && mi.GetParameters().Length == 0);
//List<MethodInfo> infos = new List<MethodInfo>(einfo);
// static method with no arguments, multiple implementations.  Find closest to leaf in hierarchy.
//  TODO: Replace with GetContructors/GetMatchingMethodAux
// invoke default c-tor
// More than one with correct arity.  Find best match.
// At the moment, only used by the LispReader
// More than one with correct arity.  Find best match.
//presumes matching lengths
// || c2[i].isPrimitive() && c1[i] == Object.class))
//|| Number.class.isAssignableFrom(c1[i]) && c2[i].isPrimitive()
//Type argType = arg.GetType();
// don't know yet what we need here
//if (!t.IsPrimitive)
//    return x;
//if (x is Boolean)
//    //return ((Boolean)x) ? RT.T : RT.F;
//    return ((Boolean)x) ? true : false;
//else if (x is Int32)
//    return (long)(int)x;
////else if (x is Single)
////    return (double)(float)x;
// Stolen from DLR TypeUtils
// Stolen from DLR TypeUtils
// WARNING: This actually implements "Is this identity assignable and/or reference assignable?"
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Runtime\Binding\BindingHelpers.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Runtime\Binding\ClojureBinder.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// Follow through on our promise to convert IEnumerable<Object> or IEnumerable to IEnumerable<T> for any T
// The following is inspired by IronPython.Runtime.Binding.Python.ConversionBinder.FallbackConvert
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Runtime\Binding\ClojureCreateInstanceBinder.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Runtime\Binding\ClojureGetZeroArityMemberBinder.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Runtime\Binding\ClojureInvokeMemberBinder.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//; Console.WriteLine(dmo.Expression.DebugView);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Runtime\Binding\ClojureOverloadResolver.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//private new ClojureBinder Binder { get { return (ClojureBinder)base.Binder; } }
// instance method call
// method call
// method call
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Runtime\Binding\DynUtils.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Runtime\Binding\IClojureSite.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Gets the ClojureContext that the call site binder is associated with.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure\Runtime\Binding\MetaAFn.cs
//  Below is what we should be returning.
//  However, for some reason, the restriction fails,
//    and our dynamic method call goes into an infinite loop trying to fallback again and again.
//return new InferenceResult(
//    typeof(object),
//    Restrictions.Merge(
//        BindingRestrictions.GetTypeRestriction(Expression, typeof(IFnArity)
//        ).Merge(
//        BindingRestrictions.GetExpressionRestriction(
//            Expression.Call(
//                Method_MetaAFn_FnHasArity,
//                Expression.Convert(Expression, typeof(IFnArity)),
//                Expression.Constant(pis.Length))))));
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure.Compile\Compile.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// Force load to avoid transitive compilation during lazy load
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure.Compile\GlobalSuppressions.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: Determine if we want to make Clojure.dll CLSCompliant
// TODO: Consider implications of strong-signing (has been requested by people who want to install in the GAC)
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure.Compile\Properties\AssemblyInfo.cs
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
// The following GUID is for the ID of the typelib if this project is exposed to COM
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure.Main\GlobalSuppressions.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: Determine if we want to make Clojure.dll CLSCompliant
// TODO: Consider implications of strong-signing (has been requested by people who want to install in the GAC)
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure.Main\Main.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure.Main\Properties\AssemblyInfo.cs
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
// The following GUID is for the ID of the typelib if this project is exposed to COM
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure.Source\GlobalSuppressions.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure.Source\clojure\samples\attributes\C.cs
// stolen mostly from the MS docs on System.Attribute
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure.Source\clojure\samples\genclass\C.cs
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure.Source\clojure\samples\interop\C.cs
// Testing property/field/0-arity-method
// Testing static poperty/field/0-arity-method
// Testing overloads
// Testing ref/out resolving
// Testing non-resolving of simple arg
// Testing some ambiguity
// Testing ambiguity in the ref
// All attempts at resolving members should fail here.
// For playing with c-tors
// Trying for some ambiguity in calls with ref parameters
// Trying for some ambiguity in calls with ref parameters
// For testing params, with and without ref/out, with and without ambiguity
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure.Tests\ReflectorTryCatchFixture.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// This is pretty irrelevant for CLR.  Trying to deal with checked exceptions in the JVM code.
// But no harm in matching their code.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Clojure.Tests\Properties\AssemblyInfo.cs
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
// The following GUID is for the ID of the typelib if this project is exposed to COM
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\FixtureSetupClass.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\AFnImplTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: Add AFnImpl tests
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\AgentTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: Add tests for Agent
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\APersistentVectorTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: Add tests for APersistentVector.SubVector
// Usually, we test the abstract classes via the simplest concrete class that derives from it.
// For APersistentVector, all the concrete classes are fairly complicated.
// Hence we create a test concrete implementation class.
// This class has no guarantees of persistence/immutability, thread-safety,
//   or much of anything else, certainly not efficiency.
// We determined the methods to override by trying to compile the class with no methods.
// Thus, we have implemented only the absolute minimum.
// We will write tests for these methods, too.
// This class just has an underlying  List<int> to hold values.
//public override object applyTo(ISeq arglist)
//{
//    throw new NotImplementedException();
//}
//[Test]
//public void NoMetaCtorHasNoMeta()
//{
//    CPV v = new CPV(new object[] { 1, 2, 3 });
//    Expect(v.meta(),Null);
//}
//[Test]
//public void MetaCtorHasMeta()
//{
//    MockRepository mocks = new MockRepository();
//    IPersistentMap meta = mocks.StrictMock<IPersistentMap>();
//    mocks.ReplayAll();
//    CPV v = new CPV(meta,new object[] { 1, 2, 3 });
//    Expect(v.meta(), SameAs(meta));
//    mocks.VerifyAll();
//}
// Rounds or not-- should it?
//This just checks that APersistentVector.assoc calls CPV.assocN
//This just checks that APersistentVector.assoc calls CPV.assocN
//This just checks that APersistentVector.assoc calls CPV.assocN
//This just checks that APersistentVector.assoc calls CPV.assocN
// We'll do all the tests indirectly.
// We'll do all the tests indirectly.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\AReferenceTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// AReference is abstract.  We need a class to instantiate.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\ARefTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: Add tests for Aref
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\ArraySeqTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\ArrayStreamTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: Add ArrayStream tests
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\AtomTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: Add tests for Atom
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\BigDecimalTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Tests for BigDecimal operations
/// </summary>
/// <remarks>
/// Many of the tests here are generated from the test suite available at:
/// http://speleotrove.com/decimal/dectest.zip
/// 
/// All the files in that test suite contain the following:
/// <code>
/// -- Copyright (c) IBM Corporation, 1981, 2008.  All rights reserved.   --
/// ------------------------------------------------------------------------
/// -- Please see the document "General Decimal Arithmetic Testcases"     --
/// -- at http://www2.hursley.ibm.com/decimal for the description of      --
/// -- these testcases.                                                   --
/// --                                                                    --
/// -- These testcases are experimental ('beta' versions), and they       --
/// -- may contain errors.  They are offered on an as-is basis.  In       --
/// -- particular, achieving the same results as the tests here is not    --
/// -- a guarantee that an implementation complies with any Standard      --
/// -- or specification.  The tests are not exhaustive.                   --
/// --                                                                    --
/// -- Please send comments, suggestions, and corrections to the author:  --
/// --   Mike Cowlishaw, IBM Fellow                                       --
/// --   IBM UK, PO Box 31, Birmingham Road, Warwick CV34 5JL, UK         --
/// --   mfc@uk.ibm.com                                                   --
/// ------------------------------------------------------------------------
/// </code>
/// </remarks>
// POwers of two have their own representations.
// random goodness
//[Test]
//public void ZeroPrecisionDoesNoRounding()
//{
//    BigDecimal.Context mc = new BigDecimal.Context(0,BigDecimal.RoundingMode.Up);
//    BigDecimal bd;
//    bd = new BigDecimal(BigInteger.Parse("123"), -3);
//    Expect(bd, EqualTo(BigDecimal.Round(bd,mc)));
//    bd = new BigDecimal(BigInteger.Parse("999"), -1);
//    Expect(bd, EqualTo(BigDecimal.Round(bd,mc)));
//}
// The following tests are taken from the spec test cases.
// modded from NaN
//-- negatives
// neg zero
// neg zero
// neg zero
// neg zero
// neg zero
// mod: neg zero
// mod: neg zero
// -- next one tries to add 9 zeros --  This fails in the original due to precision=9 limit
// mod from NaN
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// Mod: NaN
// Mod: NaN
// Mod: NaN
// Mod: NaN
// Mod: NaN
// Mod: NaN
// Mod: NaN
// Some operations here were invalid in the original due to overal precision limits that we do not capture.
//precision: 8
// mod: NaN
//precision: 7
// mod: NaN
//precision: 6
//precision: 3
// mod: NaN
// mod: NaN
// mod: NaN
// mod: NaN
// mod: NaN
// mod: NaN
//  precision: 7
//  precision: 6
//  precision: 3
//-- examples from decArith
//precision: 9
//-- more fixed, potential LHS swaps/overlays if done by subtract 0
//precision: 9
//[Test]
//public void TestAddition()
//{
//    TestAddition("12345", "678e00", "13023", 0);
//    TestAddition("12345", "678e-1", "124128", -1);
//    TestAddition("12345", "678e-2", "1235178", -2);
//    TestAddition("12345", "678e-3", "12345678", -3);
//    TestAddition("12345", "678e-4", "123450678", -4);
//    TestAddition("12345", "678e-5", "1234500678", -5);
//    TestAddition("12345", "678e-6", "12345000678", -6);
//}
//private void TestAddition(string xStr, string yStr, string biStr, int exponent)
//{
//    BigDecimal x = BigDecimal.Parse(xStr);
//    BigDecimal y = BigDecimal.Parse(yStr);
//    BigDecimal z = x.Add(y);
//    BigInteger bi = BigInteger.Parse(biStr);
//    Expect(z.Coefficient, EqualTo(bi));
//    Expect(z.Exponent, EqualTo(exponent));
//}
//-- [first group are 'quick confidence check']
//-- some carrying effects
// -- symmetry:
//-- same, higher precision
//precision: 15
// -- examples from decarith
// -- zero preservation
// precision: 6
// -- some funny zeros [in case of bad signum]
// precision: 9
// -- some carries
//-- more LHS swaps
// -- more RHS swaps
//-- related
// -- [some of the next group are really constructor tests]
// -- try borderline precision, with carries, etc.
// precision: 15
//--                 123456789012345      123456789012345      1 23456789012345
// -- and some more, including residue effects and different roundings
// precision: 9
// rounding: half_up
// rounding: half_even
//-- critical few with even bottom digit...
// rounding: down
//-- input preparation tests (operands should not be rounded)
//precision: 3
//rounding: half_up
//rounding: half_down
// -- 1 in last place tests
// rounding: half_up
// -- some more cases where adding 0 affects the coefficient
//    precision: 9
// -- which simply follow from these cases ...
// -- tryzeros cases
// precision:   7
// rounding:    half_up
// maxExponent: 92
// minexponent: -92
// -- a curiosity from JSR 13 testing
// rounding:    half_down
// precision:   10
// precision:      6
// rounding:    half_up
// precision:   10
// precision:      6
// rounding:    half_even
// precision:   10
// precision:      6
// -- ulp replacement tests
// precision: 9
// maxexponent: 999999999
// minexponent: -999999999
//TAdd("addx407 add   1   77e-9999999 ->  1.00000000 Inexact Rounded", c9he);
//TAdd("addx417 add  10   77e-9999999 ->  10.0000000 Inexact Rounded", c9he);
//TAdd("addx427 add  77e-9999999  1   ->  1.00000000 Inexact Rounded", c9he);
//TAdd("addx437 add  77e-9999999 10   ->  10.0000000 Inexact Rounded", c9he);
// -- negative ulps
//TAdd("addx447 add   1   -77e-9999999 ->  1.00000000 Inexact Rounded", c9he);
//TAdd("addx457 add  10   -77e-9999999 ->  10.0000000 Inexact Rounded", c9he);
//TAdd("addx467 add  -77e-9999999  1   ->  1.00000000 Inexact Rounded", c9he);
//TAdd("addx477 add  -77e-9999999 10   ->  10.0000000 Inexact Rounded", c9he);
//version: 2.59
//
//extended:    1
//precision:   9
//rounding:    half_up
//maxExponent: 384
//minexponent: -383
//
//-- [first group are 'quick confidence check']
// mod: neg zero
//  -- symmetry:
//  -- change precision
//precision: 6
//precision: 9
//  -- some of the next group are really constructor tests
//-- the above all from add; massaged and extended.  Now some new ones...
//-- [particularly important for comparisons]
//-- NB: -xE-8 below were non-exponents pre-ANSI X3-274, and -1E-7 or 0E-7
//-- with input rounding.
//precision: 3
//precision: 6
//precision: 9
//precision: 12
//precision: 15
//precision: 9
//-- additional scaled arithmetic tests [0.97 problem]
//-- 0. on left
//-- negatives of same
//-- more fixed, LHS swaps [really the same as testcases under add]
//-- symmetry ...
//-- now some more from the 'new' add
//precision: 9
//-- some carrying effects
//-- symmetry:
//-- same, higher precision
//precision: 15
//-- zero preservation
//precision: 6
//-- some funny zeros [in case of bad signum]
//precision: 9
//-- leading 0 digit before round
//-- more of the same; probe for cluster boundary problems
//precision: 1
//precision: 2
//precision: 3
//precision: 4
//precision: 5
//precision: 6
//precision: 7
//precision: 8
//precision: 9
//precision: 9
//-- more LHS swaps [were fixed]
//-- more RHS swaps [were fixed]
//-- try borderline precision, with carries, etc.
//precision: 15
//--                 123456789012345       123456789012345      1 23456789012345
//-- and some more, including residue effects and different roundings
//precision: 9
//rounding: half_up
//rounding: half_even
//-- critical few with even bottom digit...
//rounding: down
//-- symmetry...
//rounding: half_up
//rounding: half_even
//-- critical few with even bottom digit...
//rounding: down
//-- lots of leading zeros in intermediate result, and showing effects of
//-- input rounding would have affected the following
//precision: 9
//rounding: half_up
//rounding: half_even
//rounding: down
//-- input preparation tests
//rounding: half_up
//precision: 3
//-- overflow and underflow tests [subnormals now possible]
//maxexponent: 999999999
//minexponent: -999999999
//precision: 9
//rounding: down
//TSub("subx710 subtract 1E+999999999    -9E+999999999   -> 9.99999999E+999999999 Overflow Inexact Rounded", c9d);
//TSub("subx711 subtract 9E+999999999    -1E+999999999   -> 9.99999999E+999999999 Overflow Inexact Rounded", c9d);
//rounding: half_up
//TSub("subx712 subtract 1E+999999999    -9E+999999999   -> Infinity Overflow Inexact Rounded", c9hu);
//TSub("subx713 subtract 9E+999999999    -1E+999999999   -> Infinity Overflow Inexact Rounded", c9hu);
//TSub("subx714 subtract -1.1E-999999999 -1E-999999999   -> -1E-1000000000 Subnormal", c9hu);
//TSub("subx715 subtract 1E-999999999    +1.1e-999999999 -> -1E-1000000000 Subnormal", c9hu);
//TSub("subx716 subtract -1E+999999999   +9E+999999999   -> -Infinity Overflow Inexact Rounded", c9hu);
//TSub("subx717 subtract -9E+999999999   +1E+999999999   -> -Infinity Overflow Inexact Rounded", c9hu);
//TSub("subx718 subtract +1.1E-999999999 +1E-999999999   -> 1E-1000000000 Subnormal", c9hu);
//TSub("subx719 subtract -1E-999999999   -1.1e-999999999 -> 1E-1000000000 Subnormal", c9hu);
//precision: 3
//TSub("subx720 subtract 1  9.999E+999999999   -> -Infinity Inexact Overflow Rounded", c3hu);
//TSub("subx721 subtract 1 -9.999E+999999999   ->  Infinity Inexact Overflow Rounded", c3hu);
//TSub("subx722 subtract    9.999E+999999999 1 ->  Infinity Inexact Overflow Rounded", c3hu);
//TSub("subx723 subtract   -9.999E+999999999 1 -> -Infinity Inexact Overflow Rounded", c3hu);
//TSub("subx724 subtract 1  9.999E+999999999   -> -Infinity Inexact Overflow Rounded", c3hu);
//TSub("subx725 subtract 1 -9.999E+999999999   ->  Infinity Inexact Overflow Rounded", c3hu);
//TSub("subx726 subtract    9.999E+999999999 1 ->  Infinity Inexact Overflow Rounded", c3hu);
//TSub("subx727 subtract   -9.999E+999999999 1 -> -Infinity Inexact Overflow Rounded", c3hu);
//-- [more below]
//-- long operand checks
//maxexponent: 999
//minexponent: -999
//precision: 9
//precision: 15
//-- Specials
//TSub("subx780 subtract -Inf   Inf   -> -Infinity
//TSub("subx781 subtract -Inf   1000  -> -Infinity
//TSub("subx782 subtract -Inf   1     -> -Infinity
//TSub("subx783 subtract -Inf  -0     -> -Infinity
//TSub("subx784 subtract -Inf  -1     -> -Infinity
//TSub("subx785 subtract -Inf  -1000  -> -Infinity
//TSub("subx787 subtract -1000  Inf   -> -Infinity
//TSub("subx788 subtract -Inf   Inf   -> -Infinity
//TSub("subx789 subtract -1     Inf   -> -Infinity
//TSub("subx790 subtract  0     Inf   -> -Infinity
//TSub("subx791 subtract  1     Inf   -> -Infinity
//TSub("subx792 subtract  1000  Inf   -> -Infinity
//TSub("subx800 subtract  Inf   Inf   ->  NaN  Invalid_operation
///TSub("subx801 subtract  Inf   1000  ->  Infinity
//TSub("subx802 subtract  Inf   1     ->  Infinity
//TSub("subx803 subtract  Inf   0     ->  Infinity
//TSub("subx804 subtract  Inf  -0     ->  Infinity
//TSub("subx805 subtract  Inf  -1     ->  Infinity
//TSub("subx806 subtract  Inf  -1000  ->  Infinity
//TSub("subx807 subtract  Inf  -Inf   ->  Infinity
//TSub("subx808 subtract -1000 -Inf   ->  Infinity
//TSub("subx809 subtract -Inf  -Inf   ->  NaN  Invalid_operation
//TSub("subx810 subtract -1    -Inf   ->  Infinity
//TSub("subx811 subtract -0    -Inf   ->  Infinity
//TSub("subx812 subtract  0    -Inf   ->  Infinity
//TSub("subx813 subtract  1    -Inf   ->  Infinity
//TSub("subx814 subtract  1000 -Inf   ->  Infinity
//TSub("subx815 subtract  Inf  -Inf   ->  Infinity
//TSub("subx821 subtract  NaN   Inf   ->  NaN
//TSub("subx822 subtract -NaN   1000  -> -NaN
//TSub("subx823 subtract  NaN   1     ->  NaN
//TSub("subx824 subtract  NaN   0     ->  NaN
//TSub("subx825 subtract  NaN  -0     ->  NaN
//TSub("subx826 subtract  NaN  -1     ->  NaN
//TSub("subx827 subtract  NaN  -1000  ->  NaN
//TSub("subx828 subtract  NaN  -Inf   ->  NaN
//TSub("subx829 subtract -NaN   NaN   -> -NaN
//TSub("subx830 subtract -Inf   NaN   ->  NaN
//TSub("subx831 subtract -1000  NaN   ->  NaN
//TSub("subx832 subtract -1     NaN   ->  NaN
//TSub("subx833 subtract -0     NaN   ->  NaN
//TSub("subx834 subtract  0     NaN   ->  NaN
//TSub("subx835 subtract  1     NaN   ->  NaN
//TSub("subx836 subtract  1000 -NaN   -> -NaN
//TSub("subx837 subtract  Inf   NaN   ->  NaN
//TSub("subx841 subtract  sNaN  Inf   ->  NaN  Invalid_operation
//TSub("subx842 subtract -sNaN  1000  -> -NaN  Invalid_operation
//TSub("subx843 subtract  sNaN  1     ->  NaN  Invalid_operation
//TSub("subx844 subtract  sNaN  0     ->  NaN  Invalid_operation
//TSub("subx845 subtract  sNaN -0     ->  NaN  Invalid_operation
//TSub("subx846 subtract  sNaN -1     ->  NaN  Invalid_operation
//TSub("subx847 subtract  sNaN -1000  ->  NaN  Invalid_operation
//TSub("subx848 subtract  sNaN  NaN   ->  NaN  Invalid_operation
//TSub("subx849 subtract  sNaN sNaN   ->  NaN  Invalid_operation
//TSub("subx850 subtract  NaN  sNaN   ->  NaN  Invalid_operation
//TSub("subx851 subtract -Inf -sNaN   -> -NaN  Invalid_operation
//TSub("subx852 subtract -1000 sNaN   ->  NaN  Invalid_operation
//TSub("subx853 subtract -1    sNaN   ->  NaN  Invalid_operation
//TSub("subx854 subtract -0    sNaN   ->  NaN  Invalid_operation
//TSub("subx855 subtract  0    sNaN   ->  NaN  Invalid_operation
//TSub("subx856 subtract  1    sNaN   ->  NaN  Invalid_operation
//TSub("subx857 subtract  1000 sNaN   ->  NaN  Invalid_operation
//TSub("subx858 subtract  Inf  sNaN   ->  NaN  Invalid_operation
//TSub("subx859 subtract  NaN  sNaN   ->  NaN  Invalid_operation
//-- propagating NaNs
//TSub("subx861 subtract  NaN01   -Inf     ->  NaN1
//TSub("subx862 subtract -NaN02   -1000    -> -NaN2
//TSub("subx863 subtract  NaN03    1000    ->  NaN3
//TSub("subx864 subtract  NaN04    Inf     ->  NaN4
//TSub("subx865 subtract  NaN05    NaN61   ->  NaN5
//TSub("subx866 subtract -Inf     -NaN71   -> -NaN71
//TSub("subx867 subtract -1000     NaN81   ->  NaN81
//TSub("subx868 subtract  1000     NaN91   ->  NaN91
//TSub("subx869 subtract  Inf      NaN101  ->  NaN101
//TSub("subx871 subtract  sNaN011  -Inf    ->  NaN11  Invalid_operation
//TSub("subx872 subtract  sNaN012  -1000   ->  NaN12  Invalid_operation
//TSub("subx873 subtract -sNaN013   1000   -> -NaN13  Invalid_operation
//TSub("subx874 subtract  sNaN014   NaN171 ->  NaN14  Invalid_operation
//TSub("subx875 subtract  sNaN015  sNaN181 ->  NaN15  Invalid_operation
//TSub("subx876 subtract  NaN016   sNaN191 ->  NaN191 Invalid_operation
//TSub("subx877 subtract -Inf      sNaN201 ->  NaN201 Invalid_operation
//TSub("subx878 subtract -1000     sNaN211 ->  NaN211 Invalid_operation
//TSub("subx879 subtract  1000    -sNaN221 -> -NaN221 Invalid_operation
//TSub("subx880 subtract  Inf      sNaN231 ->  NaN231 Invalid_operation
//TSub("subx881 subtract  NaN025   sNaN241 ->  NaN241 Invalid_operation
//-- edge case spills
//-- subnormals and underflows
//precision: 3
//maxexponent: 999
//minexponent: -999
//?TSub("subx1013 subtract  0  0.100E-999      ->  -1.0E-1000 Subnormal Rounded", c3hu);
//-- next is rounded to Emin
//?TSub("subx1015 subtract  0  0.999E-999      ->  -1.00E-999 Inexact Rounded Subnormal Underflow", c3hu);
//?TSub("subx1016 subtract  0  0.099E-999      ->  -1.0E-1000 Inexact Rounded Subnormal Underflow", c3hu);
//?TSub("subx1017 subtract  0  0.009E-999      ->  -1E-1001   Inexact Rounded Subnormal Underflow", c3hu);
//?TSub("subx1018 subtract  0  0.001E-999      ->  -0E-1001   Inexact Rounded Subnormal Underflow Clamped", c3hu);
//?TSub("subx1019 subtract  0  0.0009E-999     ->  -0E-1001   Inexact Rounded Subnormal Underflow Clamped", c3hu);
//?TSub("subx1020 subtract  0  0.0001E-999     ->  -0E-1001   Inexact Rounded Subnormal Underflow Clamped", c3hu);
//?TSub("subx1030 subtract  0 -1.00E-999       ->   1.00E-999", c3hu);
//?TSub("subx1031 subtract  0 -0.1E-999        ->   1E-1000   Subnormal", c3hu);
//?TSub("subx1032 subtract  0 -0.10E-999       ->   1.0E-1000 Subnormal", c3hu);
//?TSub("subx1033 subtract  0 -0.100E-999      ->   1.0E-1000 Subnormal Rounded", c3hu);
//?TSub("subx1034 subtract  0 -0.01E-999       ->   1E-1001   Subnormal", c3hu);
//-- next is rounded to Emin
//?TSub("subx1035 subtract  0 -0.999E-999      ->   1.00E-999 Inexact Rounded Subnormal Underflow", c3hu);
//?TSub("subx1036 subtract  0 -0.099E-999      ->   1.0E-1000 Inexact Rounded Subnormal Underflow", c3hu);
//?TSub("subx1037 subtract  0 -0.009E-999      ->   1E-1001   Inexact Rounded Subnormal Underflow", c3hu);
//?TSub("subx1038 subtract  0 -0.001E-999      ->   0E-1001   Inexact Rounded Subnormal Underflow Clamped", c3hu);
//?TSub("subx1039 subtract  0 -0.0009E-999     ->   0E-1001   Inexact Rounded Subnormal Underflow Clamped", c3hu);
//?TSub("subx1040 subtract  0 -0.0001E-999     ->   0E-1001   Inexact Rounded Subnormal Underflow Clamped", c3hu);
//-- some non-zero subnormal subtracts
//-- TSub("subx1056 is a tricky case
//rounding: half_up
//?TSub("subx1050 subtract  1.00E-999   0.1E-999  ->   9.0E-1000  Subnormal", c3hu);
//?TSub("subx1051 subtract  0.1E-999    0.1E-999  ->   0E-1000", c3hu);
//?TSub("subx1052 subtract  0.10E-999   0.1E-999  ->   0E-1001", c3hu);
//?TSub("subx1053 subtract  0.100E-999  0.1E-999  ->   0E-1001    Clamped", c3hu);
//?TSub("subx1054 subtract  0.01E-999   0.1E-999  ->   -9E-1001   Subnormal", c3hu);
//?TSub("subx1055 subtract  0.999E-999  0.1E-999  ->   9.0E-1000  Inexact Rounded Subnormal Underflow", c3hu);
//?TSub("subx1056 subtract  0.099E-999  0.1E-999  ->   -0E-1001   Inexact Rounded Subnormal Underflow Clamped", c3hu);
//?TSub("subx1057 subtract  0.009E-999  0.1E-999  ->   -9E-1001   Inexact Rounded Subnormal Underflow", c3hu);
//?TSub("subx1058 subtract  0.001E-999  0.1E-999  ->   -1.0E-1000 Inexact Rounded Subnormal Underflow", c3hu);
//?TSub("subx1059 subtract  0.0009E-999 0.1E-999  ->   -1.0E-1000 Inexact Rounded Subnormal Underflow", c3hu);
//?TSub("subx1060 subtract  0.0001E-999 0.1E-999  ->   -1.0E-1000 Inexact Rounded Subnormal Underflow", c3hu);
//-- check for double-rounded subnormals
//precision:   5
//maxexponent: 79
//minexponent: -79
//?TSub("subx1101 subtract  0 1.52444E-80 -> -1.524E-80 Inexact Rounded Subnormal Underflow", c5hu);
//?TSub("subx1102 subtract  0 1.52445E-80 -> -1.524E-80 Inexact Rounded Subnormal Underflow", c5hu);
//?TSub("subx1103 subtract  0 1.52446E-80 -> -1.524E-80 Inexact Rounded Subnormal Underflow", c5hu);
//?TSub("subx1104 subtract  1.52444E-80 0 ->  1.524E-80 Inexact Rounded Subnormal Underflow", c5hu);
//?TSub("subx1105 subtract  1.52445E-80 0 ->  1.524E-80 Inexact Rounded Subnormal Underflow", c5hu);
//?TSub("subx1106 subtract  1.52446E-80 0 ->  1.524E-80 Inexact Rounded Subnormal Underflow", c5hu);
//?TSub("subx1111 subtract  1.2345678E-80  1.2345671E-80 ->  0E-83 Inexact Rounded Subnormal Underflow Clamped", c5hu);
//?TSub("subx1112 subtract  1.2345678E-80  1.2345618E-80 ->  0E-83 Inexact Rounded Subnormal Underflow Clamped", c5hu);
//?TSub("subx1113 subtract  1.2345678E-80  1.2345178E-80 ->  0E-83 Inexact Rounded Subnormal Underflow Clamped", c5hu);
//?TSub("subx1114 subtract  1.2345678E-80  1.2341678E-80 ->  0E-83 Inexact Rounded Subnormal Underflow Clamped", c5hu);
//?TSub("subx1115 subtract  1.2345678E-80  1.2315678E-80 ->  3E-83         Rounded Subnormal", c5hu);
//?TSub("subx1116 subtract  1.2345678E-80  1.2145678E-80 ->  2.0E-82       Rounded Subnormal", c5hu);
//?TSub("subx1117 subtract  1.2345678E-80  1.1345678E-80 ->  1.00E-81      Rounded Subnormal", c5hu);
//?TSub("subx1118 subtract  1.2345678E-80  0.2345678E-80 ->  1.000E-80     Rounded Subnormal", c5hu);
//precision:   34
//rounding:    half_up
//maxExponent: 6144
//minExponent: -6143
//-- Examples from SQL proposal (Krishna Kulkarni)
//-- Null tests
//subx9990 subtract 10  # -> NaN Invalid_operation
//subx9991 subtract  # 10 -> NaN Invalid_operation
//version: 2.59
//extended:    1
//precision:   9
//rounding:    half_up
//maxExponent: 384
//minexponent: -383
//-- sanity checks (as base, above)
// mod: neg 0
//precision: 6
//-- 1999.12.21: next one is a edge case if intermediate longs are used
//precision: 15
//precision: 30
//precision: 9
//-----
//-- zeros, etc.
// mod: neg 0
// mod: neg 0
// mod: neg 0
// mod: neg 0
// mod: neg 0
// mod: neg 0
// mod: neg 0
// mod: neg 0
//-- examples from decarith
// mod: neg 0
//-- test some intermediate lengths
//precision: 9
//precision: 8
//precision: 7
//precision: 9
//precision: 8
//precision: 7
//-- test some more edge cases and carries
//maxexponent: 9999
//minexponent: -9999
//precision: 33
//-- test some more edge cases without carries
//maxexponent: 999999999
//minexponent: -999999999
//precision: 9
//-- test some cases that are close to exponent overflow/underflow
//-- long operand triangle
//precision: 33
//precision: 32
//precision: 31
//precision: 30
//precision: 29
//precision: 28
//precision: 27
//precision: 26
//precision: 25
//precision: 24
//precision: 23
//precision: 22
//precision: 21
//precision: 20
//precision: 19
//precision: 18
//precision: 17
//precision: 16
//precision: 15
//precision: 14
//precision: 13
//precision: 12
//precision: 11
//precision: 10
//precision:  9
//precision:  8
//precision:  7
//precision:  6
//precision:  5
//precision:  4
//precision:  3
//precision:  2
//precision:  1
//-- test some edge cases with exact rounding
//maxexponent: 9999
//minexponent: -9999
//precision: 9
//-- fastpath breakers
//precision:   29
//precision:   55
//-- tryzeros cases
//precision:   7
//rounding:    half_up
//maxExponent: 92
//minexponent: -92
//TMul("mulx504  multiply  0E-60 1000E-60  -> 0E-98 Clamped", new BigDecimal.Context(7, BigDecimal.RoundingMode.HalfUp));
//TMul("mulx505  multiply  100E+60 0E+60   -> 0E+92 Clamped", new BigDecimal.Context(7, BigDecimal.RoundingMode.HalfUp));
//-- mixed with zeros
//maxexponent: 999999999
//minexponent: -999999999
//precision: 9
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
//-- Specials
//-- test subnormals rounding
//precision:   5
//maxExponent: 999
//minexponent: -999
//rounding:    half_even
//...
//version: 2.59
//extended:    1
//precision:   9
//rounding:    half_up
//maxExponent: 384
//minexponent: -383
//-- sanity checks
//precision: 6
//precision: 9
//precision:   9
//maxexponent: 999999999
//minexponent: -999999999
//-- test possibly imprecise results
//-- test some cases that are close to exponent overflow
//maxexponent: 999999999
//minexponent: -999999999
//-- Divide into 0 tests
//maxexponent: 92
//minexponent: -92
//precision:    7
//TDiv("divx355 divide 0E-92   7E+7  -> 0E-98 Clamped", c7hu);
//TDiv("divx362 divide 0E-92 777E+7  -> 0E-98 Clamped", c7hu);
//TDiv("divx363 divide 0E-92   7E+92 -> 0E-98 Clamped", c7hu);
//TDiv("divx377 divide 0E-92 700E+7  -> 0E-98 Clamped", c7hu);
//TDiv("divx383 divide 0E+92   7E-1  -> 0E+92 Clamped", c7hu);
//TDiv("divx387 divide 0E+90 777E-3  -> 0E+92 Clamped", c7hu);
//TDiv("divx388 divide 0E+90 777E-4  -> 0E+92 Clamped", c7hu);
//TDiv("divx394 divide 0E+90 700E-3  -> 0E+92 Clamped", c7hu);
//TDiv("divx395 divide 0E+90 700E-4  -> 0E+92 Clamped", c7hu);
//-- input rounding checks
//maxexponent: 999
//minexponent: -999
//precision: 9
//-- some longies
//precision: 15
//-- still checking...
//-- high-lows
//-- some from IEEE discussions
//-- some reciprocals
//-- RMS discussion table
//maxexponent:  96
//minexponent: -95
//precision:     7
//-- tryzeros cases
//precision:   7
//rounding:    half_up
//maxExponent: 92
//minexponent: -92
//TDiv("divx497  divide  0E+86 1000E-13  -> 0E+92 Clamped", c7hu);
//TDiv("divx498  divide  0E-98 1000E+13  -> 0E-98 Clamped", c7hu);
//precision:   9
//rounding:    half_up
//maxExponent: 999
//minexponent: -999
//-- focus on trailing zeros issues
//precision:   9
//precision:   8
//precision:   7
//precision:   6
//precision:   9
//-- +ve exponent
//precision: 5
//precision: 6
//precision: 7
//precision:   9
//-- long operand triangle
//precision: 33
//precision: 32
//precision: 31
//precision: 30
//precision: 29
//precision: 28
//precision: 27
//precision: 26
//precision: 25
//precision: 24
//precision: 23
//precision: 22
//precision: 21
//precision: 20
//precision: 19
//precision: 18
//precision: 17
//precision: 16
//precision: 15
//precision: 14
//precision: 13
//precision: 12
//precision: 11
//precision: 10
//precision:  9
//precision:  8
//precision:  7
//precision:  6
//precision:  5
//precision:  4
//precision:  3
//precision:  2
//precision:  1
//-- more zeros, etc.
//precision:   16
//rounding:    half_up
//maxExponent: 384
//minExponent: -383
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
//precision:   34
//rounding:    half_up
//maxExponent: 6144
//minExponent: -6143
//-- Examples from SQL proposal (Krishna Kulkarni)
//precision: 7
//-- ECMAScript bad examples
//rounding:    half_down
//precision: 7
//rounding:    half_even
//-- Various flavours of divide by 0
//-- sanity checks
// result irrelevant
//extended:    1
//precision:   9
//rounding:    half_up
//maxExponent: 384
//minexponent: -383
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
//-- similar with powers of ten
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
//-- some long operand cases here
//precision: 6
//precision: 9
//-- from DiagBigDecimal
//-- Others
//-- Various flavours of divideint by 0
//maxexponent: 999999999
//minexponent: -999999999
// TODO: Reactivate these tests when we can handle the align (irrelevant when the numbers are so different)
// -- test some cases that are close to exponent overflow
//maxexponent: 999999999
//minexponent: -999999999
//TDivI("dvix270 divideint 1 1e999999999    -> 0", c9hu);
//TDivI("dvix271 divideint 1 0.9e999999999  -> 0", c9hu);
//TDivI("dvix272 divideint 1 0.99e999999999 -> 0", c9hu);
//TDivI("dvix273 divideint 1 0.999999999e999999999 -> 0", c9hu);
//TDivIEx("dvix274 divideint 9e999999999    1       -> NaN Division_impossible", c9hu);
//TDivIEx("dvix275 divideint 9.9e999999999  1       -> NaN Division_impossible", c9hu);
//TDivIEx("dvix276 divideint 9.99e999999999 1       -> NaN Division_impossible", c9hu);
//TDivIEx("dvix277 divideint 9.99999999e999999999 1 -> NaN Division_impossible", c9hu);
//TDivIEx("dvix280 divideint 0.1 9e-999999999       -> NaN Division_impossible", c9hu);
//TDivIEx("dvix281 divideint 0.1 99e-999999999      -> NaN Division_impossible", c9hu);
//TDivIEx("dvix282 divideint 0.1 999e-999999999     -> NaN Division_impossible", c9hu);
//TDivIEx("dvix283 divideint 0.1 9e-999999998       -> NaN Division_impossible", c9hu);
//TDivIEx("dvix284 divideint 0.1 99e-999999998      -> NaN Division_impossible", c9hu);
//TDivIEx("dvix285 divideint 0.1 999e-999999998     -> NaN Division_impossible", c9hu);
//TDivIEx("dvix286 divideint 0.1 999e-999999997     -> NaN Division_impossible", c9hu);
//TDivIEx("dvix287 divideint 0.1 9999e-999999997    -> NaN Division_impossible", c9hu);
//TDivIEx("dvix288 divideint 0.1 99999e-999999997   -> NaN Division_impossible", c9hu);
//-- GD edge cases: lhs smaller than rhs but more digits
//-- overflow and underflow tests [from divide]
//maxexponent: 999999999
//minexponent: -999999999
//TDivI("dvix330 divideint +1.23456789012345E-0 9E+999999999    -> 0", c9hu);
//TDivIEx("dvix331 divideint 9E+999999999 +0.23456789012345E-0 -> NaN Division_impossible", c9hu);
//TDivI("dvix332 divideint +0.100 9E+999999999    -> 0", c9hu);
//TDivI("dvix333 divideint 9E-999999999 +9.100    -> 0", c9hu);
//TDivI("dvix335 divideint -1.23456789012345E-0 9E+999999999    -> -0", c9hu);
//TDivIEx("dvix336 divideint 9E+999999999 -0.83456789012345E-0 -> NaN Division_impossible", c9hu);
//TDivI("dvix337 divideint -0.100 9E+999999999    -> -0", c9hu);
//TDivI("dvix338 divideint 9E-999999999 -9.100    -> -0", c9hu);
//-- long operand checks
//maxexponent: 999
//minexponent: -999
//precision: 9
//precision: 15
//precision:   9
//rounding:    half_up
//maxExponent: 999
//minexponent: -999
//-- more zeros, etc.
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
// mod: neg zero
//extended:    1
//precision:   16
//rounding:    half_even
//maxExponent: 384
//minExponent: -383
//-- base checks.  Note 0**0 is an error.
//TPow("powx001 power    '0'  '0'         -> NaN Invalid_operation
//-- NB 0 not stripped in next
//precision: 9
//-- NB 0 not stripped in next
//precision: 10
//precision: 9
//TPow("powx072 power  '0.3'  '1.00'        -> '0.3'", c9he);
//TPow("powx073 power  '0.3'  '2.00'        -> '0.09'", c9he);
//TPow("powx074 power  '0.3'  '2.000000000' -> '0.09'", c9he);
//-- negative powers
//TPow("powx126 power   '0'  '-1'   -> Infinity", c9he);
//TPow("powx127 power   '0'  '-2'   -> Infinity", c9he);
//TPow("powx128 power   -0   '-1'   -> -Infinity", c9he);
//TPow("powx129 power   -0   '-2'   -> Infinity", c9he);
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\BigIntegerTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// Powers of two are special-cased in the code.
// We test some of the internals, too.
// This is because the code had a fall-through error due to a missing return statement.
// THe following is taken from a suggestion in Knuth.
// In Radix t,
//  (t^m - 1)*(t^n - 1) has expansion
//    (t-1) ... (t-1) (t-2) (t-1) ... (t-1) 0 ... 0 1
//    --------------------- --------------- --------
//         m-1 places         n-m places    m-1 places
//
//  if m < n
//
//  Of course, (t^m -1) is (t-1)  repeated m-1 places.
//
//  So, we can construct lots of cute little test samples
//BigInteger z = new BigInteger(1, new uint[] { digit2 & digit1, digit1 & digit2, 0 });
//BigInteger z = new BigInteger(1, new uint[] { digit1, digit2 & ~digit1, digit1 & (~digit2 + 1), 0 });
//BigInteger z = new BigInteger(1, new uint[] { ~digit2 & digit1, ~digit1 & digit2, 0 });
// TODO: tests for IConvertible
// TODO: tests for conversion methods
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\CachedSeqTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: write tests for CachedSeq
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\ConsTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// Test of ASeq
// Some aspects of ASeq have been tested above.  
// Here are the remaining bits
// Have to assign to access
// Have to assign to access
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\CountDownLatchTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\DelayTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//TODO: Write Delay tests
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\DummyFn.cs
/// <summary>
/// Dummy IFn to use in reduce tests
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\DummyMeta.cs
/// <summary>
/// This class is used to provide a dummy value for meta calls.
/// </summary>
/// <remarks>Most of the use of mocking within these tests was to provide a meta value for objects.  
/// Only identity was tested.  An instance of this class will suffice for most testing uses.  
/// Anything that needs more can just tie its test to a real implementation of IPersistentMap.</remarks>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\EnumeratorSeqTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: Add tests for EnumeratorSeq
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\FutureTests.cs
// Same result for subsequent derefs.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\GenProxyTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//overload on method name
//overload on paramtype+returntype
// Collides with method on I1
//Console.WriteLine("In Impl1.m1({0})", s);
//Console.WriteLine("In Impl1.m1({0})", s);
//Console.WriteLine("In Impl1.im2({0})", s);
//Console.WriteLine("In Impl1.im3({0})", s);
//overload on method name
//overload on paramtype+returntype
// Collides with method on I1
//Console.WriteLine("In Fn1");
//Console.WriteLine("In Fn2");
//Console.WriteLine("In Fn2V");
//Console.WriteLine("In Fn2S");
//Console.WriteLine("In Fn3");
//Console.WriteLine("In Fn4");
//[Test]
//public void InitClojureFnMappingsDebug()
//{
//    GenProxy.SaveProxyContext();
//}
//SanityCheck.PrintMethods(_obj.GetType());
// just hoping the next one doesn't blow up
// We set a flag to test
//overload on method name
//overload on paramtype+returntype
// This example sets up a proxy for System.IO.TextWriter that converts all characters to upper case.
// The original code (in Clojure) from clojure-contrib is here:
// (defn- upcase-writer 
//  "Returns a proxy that wraps writer, converting all characters to upper case"
//  [^java.io.Writer writer]
//  (proxy [java.io.Writer] []
//    (close [] (.close writer))
//    (flush [] (.flush writer))
//    (write ([^chars cbuf ^Integer off ^Integer len] 
//              (.write writer cbuf off len))
//           ([x]
//              (condp = (class x)
//                        String 
//                          (let [s ^String x]
//                             (.write writer (.toUpperCase s)))
//                        Integer
//                         (let [c ^Character x]
//                             (.write writer (int (Character/toUpperCase (char c))))))))))
// In a CLR version:
//  (defn upcase-writer
//    [^System.IO.TextWriter tw]
//    (proxy [System.IO.TextWriter] []
//      (Write ([^chars cbuf ^Int32 off #Int32 len] (.Write tw cbuf off len))
//             ([x] (condp (class x)
//                    System.String (let [s ^System.String x] (.Write tw (. s ToUpper)))
//                    Int32 (let [c ^Int32 x] (.Write tw (int (Char/ToUpper (char c))))))))))
// Not having the kind of closures I want, I'll fake it with a static variable.
//[TestFixture]
//[Test]
//public void TestThis()
//{
//    PrintMethods(typeof(Impl1));
//    PrintMethods(typeof(Impl2));
//    PrintMethods(typeof(Impl3));
//    PrintMethods(typeof(I1));
//    PrintInterfaceMaps(typeof(Impl1));
//    PrintInterfaceMaps(typeof(Impl2));
//    PrintInterfaceMaps(typeof(Impl3));
//    Expect(true);
//}
//[TestFixture]
//[Test]
//public void BoxingHurts()
//{
//    AssemblyName aname = new AssemblyName("MyAssy3");
//    AssemblyBuilder assyBldr = AppDomain.CurrentDomain.DefineDynamicAssembly(aname, AssemblyBuilderAccess.RunAndSave, ".");
//    ModuleBuilder moduleBldr = assyBldr.DefineDynamicModule(aname.Name, aname.Name + ".dll", true);
//    TypeBuilder tb = moduleBldr.DefineType("TheBoxer", TypeAttributes.Public, typeof(object));
//    MethodAttributes baseAttr = MethodAttributes.Public | MethodAttributes.HideBySig;
//    MethodBuilder mb1 = tb.DefineMethod("Add1", baseAttr, typeof(int), new Type[] { typeof(int), typeof(int) });
//    ILGenerator gen1 = mb1.GetILGenerator();
//    LocalBuilder loc_i = gen1.DeclareLocal(typeof(Int32));
//    LocalBuilder loc_sum = gen1.DeclareLocal(typeof(Int32));
//    Label loopLabel = gen1.DefineLabel();
//    Label testLabel = gen1.DefineLabel();
//    // i=0;
//    gen1.Emit(OpCodes.Ldc_I4_0);
//    gen1.Emit(OpCodes.Stloc,loc_i);
//    // sum = 0;
//    gen1.Emit(OpCodes.Ldc_I4_0);
//    gen1.Emit(OpCodes.Stloc,loc_sum);
//    gen1.MarkLabel(loopLabel);
//    // sum = sum + (c+c) + (c+c)
//    gen1.Emit(OpCodes.Ldarg_2);
//    gen1.Emit(OpCodes.Box,typeof(Int32));
//    gen1.Emit(OpCodes.Unbox_Any, typeof(Int32));
//    gen1.Emit(OpCodes.Ldarg_2);
//    gen1.Emit(OpCodes.Box, typeof(Int32));
//    gen1.Emit(OpCodes.Unbox_Any, typeof(Int32));
//    gen1.Emit(OpCodes.Add);
//    gen1.Emit(OpCodes.Ldarg_2);
//    gen1.Emit(OpCodes.Box, typeof(Int32));
//    gen1.Emit(OpCodes.Unbox_Any, typeof(Int32));
//    gen1.Emit(OpCodes.Ldarg_2);
//    gen1.Emit(OpCodes.Box, typeof(Int32));
//    gen1.Emit(OpCodes.Unbox_Any, typeof(Int32));
//    gen1.Emit(OpCodes.Add);
//    gen1.Emit(OpCodes.Add);
//    gen1.Emit(OpCodes.Ldloc, loc_sum);
//    gen1.Emit(OpCodes.Add);
//    gen1.Emit(OpCodes.Stloc, loc_sum);
//    // i = i + 1
//    gen1.Emit(OpCodes.Ldloc, loc_i);
//    gen1.Emit(OpCodes.Ldc_I4_1);
//    gen1.Emit(OpCodes.Add);
//    gen1.Emit(OpCodes.Stloc, loc_i);
//    // Test: i < n
//    gen1.MarkLabel(testLabel);
//    gen1.Emit(OpCodes.Ldloc, loc_i);
//    gen1.Emit(OpCodes.Ldarg_1);
//    gen1.Emit(OpCodes.Blt, loopLabel);
//    gen1.Emit(OpCodes.Ret);
//    MethodBuilder mb2 = tb.DefineMethod("Add2", baseAttr, typeof(int), new Type[] { typeof(int), typeof(int) });
//    ILGenerator gen2 = mb2.GetILGenerator();
//    loc_i = gen2.DeclareLocal(typeof(Int32));
//    loc_sum = gen2.DeclareLocal(typeof(Int32));
//    loopLabel = gen2.DefineLabel();
//    testLabel = gen2.DefineLabel();
//    // i=0;
//    gen2.Emit(OpCodes.Ldc_I4_0);
//    gen2.Emit(OpCodes.Stloc, loc_i);
//    // sum = 0;
//    gen2.Emit(OpCodes.Ldc_I4_0);
//    gen2.Emit(OpCodes.Stloc, loc_sum);
//    gen2.MarkLabel(loopLabel);
//    // sum = sum + (c+c) + (c+c)
//    gen2.Emit(OpCodes.Ldarg_2);
//    gen2.Emit(OpCodes.Ldarg_2);
//    gen2.Emit(OpCodes.Add);
//    gen2.Emit(OpCodes.Ldarg_2);
//    gen2.Emit(OpCodes.Ldarg_2);
//    gen2.Emit(OpCodes.Add);
//    gen2.Emit(OpCodes.Add);
//    gen2.Emit(OpCodes.Ldloc, loc_sum);
//    gen2.Emit(OpCodes.Add);
//    gen2.Emit(OpCodes.Stloc, loc_sum);
//    // i = i + 1
//    gen2.Emit(OpCodes.Ldloc, loc_i);
//    gen2.Emit(OpCodes.Ldc_I4_1);
//    gen2.Emit(OpCodes.Add);
//    gen2.Emit(OpCodes.Stloc, loc_i);
//    // Test: i < n
//    gen2.MarkLabel(testLabel);
//    gen2.Emit(OpCodes.Ldloc, loc_i);
//    gen2.Emit(OpCodes.Ldarg_1);
//    gen2.Emit(OpCodes.Blt, loopLabel);
//    gen2.Emit(OpCodes.Ret);
//    Type myType = tb.CreateType();
//    ConstructorInfo ctor = myType.GetConstructor(Type.EmptyTypes);
//    object o = ctor.Invoke(new object[0]);
//    MethodInfo add1 = myType.GetMethod("Add1");
//    MethodInfo add2 = myType.GetMethod("Add2");
//    Stopwatch sw = new Stopwatch();
//    sw.Start();
//    add1.Invoke(o, new object[] { 1000000, 2 });
//    sw.Stop();
//    Console.WriteLine("Add1: {0} ticks", sw.ElapsedTicks);
//    sw.Reset();
//    sw.Start();
//    add1.Invoke(o, new object[] { 1000000, 2 });
//    sw.Stop();
//    Console.WriteLine("Add2: {0} ticks", sw.ElapsedTicks);
//}
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\IObjTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
/// <summary>
/// Base class for testing the IMeta interface functionality.
/// </summary>
/// <summary>
/// Object to test for null meta.  Set null if no test.  Initialize in Setup.
/// </summary>
/// <summary>
/// The object to test.  Initialize in Setup.
/// </summary>
/// <summary>
/// Expected type of return from withMeta.  Set null if no test.  Initialize in Setup.
/// </summary>
/// <summary>
/// Test if same object with no change in meta.  Set to false to skip test.
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\ISeqTestHelper.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\IteratorStreamTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//TODO: add tests for IteratorStream
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\KeywordTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//[Test]
//public void EqualsDependsOnSym()
//{
//    Symbol sym1 = Symbol.intern("abc");
//    Symbol sym2 = Symbol.intern("abc");
//    Keyword k1 = Keyword.intern(sym1);
//    Keyword k2 = Keyword.intern(sym2);
//    // I don't know how we ever create two keywords that will force
//    // the code to go into the sym.equals part of the code.
//    // At least, not through the factory methods.
//}
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\LazilyPersistentVectorTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\LazySeqTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: Add LazySeq tests
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\LispReaderTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//using BigDecimal = java.math.BigDecimal;
//Expect(o4, EqualTo(new BigInteger("123456789123456789123456789")));
//Expect(o3, EqualTo(new BigInteger("FFFFFFFFFFFFFFFFFFFFFFFF", 16)));
//Expect(o4, EqualTo(new BigInteger("1234567012345670123456777", 8)));
//Expect(o4, EqualTo(new BigInteger("1234AQ", 30).longValue()));
//Expect(o4, EqualTo(new BigInteger("123456789123456789123456789")));
//");
// TODO: Add more tests dealing with :: resolution.
// At one time, this test worked.  Now, according to the documentation, it should not work.  Did something change?  Never mind.
//[Test]
//public void LeadingDoubleColonDoesNotSetNamespaceIfPeriodsInName()
//{
//    object o1 = ReadFromString("::ab.cd");
//    Expect(o1, TypeOf(typeof(Keyword)));
//    Expect(((Keyword)o1).Namespace, Null);
//    Expect(((Keyword)o1).Name, EqualTo("ab.cd"));
//}
// hex/octal conversion
//[Test]
//[ExpectedException(typeof(ArgumentException))]
//public void MapWithOddNumberOfEntriesFails()
//{
//    Object o1 = ReadFromString("{a b 1}");
//}
// Return should be 
//    (clojure/seq (clojure/concat (clojure/list (quote abc__N)) 
//                                 (clojure/list (quote abc__N)))))
//  (clojure/apply 
//      clojure/hash-map 
//         (clojure/seq 
//             (clojure/concat (clojure/list :a) 
//                             (clojure/list 1) 
//                             (clojure/list :b) 
//                             (clojure/list 2))))
//  (clojure/apply 
//      clojure/vector 
//         (clojure/concat (clojure/list :b) 
//                         (clojure/list 2)))
//  (clojure/apply 
//      clojure/hash-set 
//         (clojure/seq
//             (clojure/concat (clojure/list :b) 
//                             (clojure/list 2))))
// Set elements can occur in any order
//   (clojure/seq (clojure/concat (clojure/list :b) 
//                                (clojure/list 2))))
//Expect(o1, InstanceOf(typeof(LispReader.Unquote)));
//LispReader.Unquote u = o1 as LispReader.Unquote;
//Expect(u.Obj, EqualTo(Symbol.intern("x")));
// (clojure/seq (clojure/concat (clojure/list (quote NS/a)) 
//                              (clojure/list b)))
// (clojure/seq (clojure/concat (clojure/list (quote user/a)) b))
// We should test to see that 'line' meta info is not preserved.
//  (clojure/list)
//  input =  #"a\"bc" -- should go over the "
// (fn* [] (+ 1 2))
// (fn* [p1__N p2__M] (+ p2__M 2))
// (fn* [p1__N p2__M & rest__X] (+ p2__M rest__X))
// (fn* [p1__N] (+ p1__N 2))
// TODO: EvalReader tests
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\LockingTransactionTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: Add tests for LockingTransaction
//// TODO: Make this work.
//// This test is taken from the Java code.
//[Test]
//public void BigTest()
//{
//    // We have to start the main work unit on its own thread because
//    // the main during testing is STA and so does not support waiting on multiple handles.
//    BigTester<Incrementer> tester = new BigTester<Incrementer>(5, 10, 2000);
//    EventWaitHandle h = new EventWaitHandle(false, EventResetMode.ManualReset);
//    Thread t = new Thread(tester.Work);
//    t.Start(h);
//    h.WaitOne();
//    Console.WriteLine("Done");
//}
//class BigTester<T> where T : LockingTransactionTests.RefTester
//{
//    int _nthreads;
//    int _niters;
//    int _nitems;
//    public BigTester(int nthreads, int nitems, int niters)
//    {
//        _nthreads = nthreads;
//        _nitems = nitems;
//        _niters = niters;
//    }
//    public void Work(object o)
//    {
//        List<Ref> refs = new List<Ref>();
//        for (int i = 0; i < _nitems; i++)
//            refs.Add(new Ref(0));
//        List<Thread> threads = new List<Thread>(_nthreads);
//        List<EventWaitHandle> handles = new List<EventWaitHandle>(_nthreads);
//        List<Incrementer> tasks = new List<Incrementer>(_nthreads);
//        for (int i = 0; i < _nthreads; i++)
//        {
//            List<Ref> copy = refs.GetRange(0, refs.Count);
//            Shuffle(copy);
//            tasks.Add(new Incrementer(i, _niters, copy));
//            threads.Add(new Thread(tasks[i].Work));
//            handles.Add(new EventWaitHandle(false, EventResetMode.ManualReset));
//        }
//        for (int i = 0; i < _nthreads; i++)
//        {
//            threads[i].Name = "Thr " + i;
//            threads[i].Start(handles[i]);
//        }
//        EventWaitHandle.WaitAll(handles.ToArray());
//        foreach (Incrementer task in tasks)
//            Console.WriteLine("Task {0}: {1} millisecs", task.Id, task.Nanos / 10000.0);
//        foreach (Ref r in refs)
//            Console.WriteLine("Ref is {0}", r.get());
//        EventWaitHandle ewh = (EventWaitHandle)o;
//        ewh.Set();
//    }
//    void Shuffle(List<Ref> refs)
//    {
//    }
//}
//public abstract class RefTester
//{
//    readonly int _id;
//    public int Id
//    {
//      get { return _id; }  
//    } 
//    protected readonly int _niters;
//    protected readonly List<Ref> _items;
//    long _nanos = 0;
//    public long Nanos
//    {
//      get { return _nanos; }
//    }
//    public RefTester(int id, int niters, List<Ref> items)
//    {
//        _id = id;
//        _niters = niters;
//        _items = items;
//    }
//    public void Work(object o)
//    {
//        for (int i = 0; i < _niters; i++)
//        {
//            long startTime = DateTime.Now.Ticks;
//            LockingTransaction.runInTransaction(this.TxUnit);
//            long finishTime = DateTime.Now.Ticks;
//            _nanos += finishTime - startTime;
//        }
//        EventWaitHandle h = (EventWaitHandle)o;
//        h.Set();
//    }
//    public abstract object TxUnit(object[] args);
//}
//class Incrementer : RefTester
//{
//    public Incrementer(int id, int niters, List<Ref> items)
//        : base(id, niters, items)
//    {
//    }
//    public override object TxUnit(object[] args)
//    {
//        foreach (Ref r in _items)
//        {
//            int val = (int)r.get();
//            r.set(val + 1);
//        }
//        return null;
//    }
//}
//class Commuter : RefTester
//{
//    public Commuter(int id, int niters, List<Ref> items)
//        : base(id, niters, items)
//    {
//    }
//    public override object TxUnit(object[] args)
//    {
//        foreach (Ref r in _items)
//        {
//            r.commute(Commuter.Incr,null);
//        }
//        return null;
//    }
//    static object Incr(object[] args)
//    {
//        int val = (int)args[0];
//        return val + 1;
//    }
//}
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\MapEntryTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\NamespaceTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//TODO: NEed to fix NS tests to clear the created namespaces after each test.
/*
// how to test the thread-safety of findOrCreatea?
// do we care all that much?
// I don't know why
// Don't know how to test the race condition in the loops for
//  intern(Symbol), reference(Symbol), unmap(Symbol)
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\NumbersTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//[Test]
//public void ReduceOnBigIntReducesSmallerValues()
//{
//    //BigInteger b1 = new BigInteger("123");
//    //BigInteger b2 = new BigInteger("0");
//    //BigInteger b3 = new BigInteger(Int32.MaxValue.ToString());
//    //BigInteger b4 = new BigInteger(Int32.MinValue.ToString()); BigInteger b1 = new BigInteger("123");
//    BigInteger b1 = BigInteger.Create(123);
//    BigInteger b2 = BigInteger.Create(0);
//    BigInteger b3 = BigInteger.Create(Int32.MaxValue);
//    BigInteger b4 = BigInteger.Create(Int32.MinValue);
//    ExpectInt32(Numbers.reduceBigInt(b1));
//    ExpectInt32(Numbers.reduceBigIntege(b2));
//    ExpectInt32(Numbers.reduceBigInteger(b3));
//    ExpectInt32(Numbers.reduceBigInteger(b4));
//}
//[Test]
//public void ReduceOnBigIntReturnsLargerValues()
//{
//    //BigInteger b1 = new BigInteger("100000000000000000000", 16);
//    //BigInteger b2 = b1.negate();
//    //BigInteger b3 = new BigInteger("123456789012345678901234567890");
//    //BigInteger b4 = b3.negate();
//    BigInteger b1 = BigInteger.Parse("100000000000000000000", 16);
//    BigInteger b2 = b1.Negate();
//    BigInteger b3 = BigInteger.Parse("123456789012345678901234567890");
//    BigInteger b4 = b3.Negate();
//    ExpectSameObject(b1, Numbers.reduceBigInteger(b1));
//    ExpectSameObject(b2, Numbers.reduceBigInteger(b2));
//    ExpectSameObject(b3, Numbers.reduceBigInteger(b3));
//    ExpectSameObject(b4, Numbers.reduceBigInteger(b4));
//}
//[Test]
//public void ReduceOnLongReducesSmallerValues()
//{
//    long b1 = 123;
//    long b2 = 0;
//    long b3 = Int32.MaxValue;
//    long b4 = Int32.MinValue;
//    ExpectInt32(Numbers.reduce(b1));
//    ExpectInt32(Numbers.reduce(b2));
//    ExpectInt32(Numbers.reduce(b3));
//    ExpectInt32(Numbers.reduce(b4));
//}
//[Test]
//public void ReduceOnLongReturnsLargerValues()
//{
//    long b1 = ((long)Int32.MaxValue) + 1;
//    long b2 = ((long)Int32.MinValue) - 1;
//    long b3 = 123456789000;
//    long b4 = -b3;
//    ExpectEqualObject(b1, Numbers.reduce(b1));
//    ExpectEqualObject(b2, Numbers.reduce(b2));
//    ExpectEqualObject(b3, Numbers.reduce(b3));
//    ExpectEqualObject(b4, Numbers.reduce(b4));
//}
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\ObjTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\PersistentArrayMapTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// other c-tors are not public.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\PersistentHashMapTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\PersistentHashSetTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\PersistentListTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\PersistentQueueTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: Add tests for PersistentQueue
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\PersistentStructMapTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: Add tests for PersistentStructMap
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\PersistentTreeMapTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//[Test]
//public void CreateOnEmptyListReturnsEmptyMap()
//{
//    ArrayList a = new ArrayList();
//    IPersistentMap m = PersistentTreeMap.create(a);
//    Expect(m.count(), EqualTo(0));
//}
//[Test]
//public void CreateOnListReturnsMap()
//{
//    object[] items = new object[] { 1, "a", 2, "b" };
//    ArrayList a = new ArrayList(items);
//    IPersistentMap m = PersistentTreeMap.create(a);
//    Expect(m.count(), EqualTo(2));
//    Expect(m.valAt(1), EqualTo("a"));
//    Expect(m.valAt(2), EqualTo("b"));
//    Expect(m.containsKey(3), False);
//}
//[Test]
//public void CreateOnMetaNoArgsReturnsEmptyMap()
//{
//    MockRepository mocks = new MockRepository();
//    IPersistentMap meta = mocks.StrictMock<IPersistentMap>();
//    mocks.ReplayAll();
//    PersistentTreeMap m = PersistentTreeMap.create(meta);
//    Expect(m.count(), EqualTo(0));
//    Expect(m.meta(), SameAs(meta));
//    mocks.VerifyAll();
//}
//[Test]
//public void CreateOnMetaNoArgsReturnsMap()
//{
//    MockRepository mocks = new MockRepository();
//    IPersistentMap meta = mocks.StrictMock<IPersistentMap>();
//    mocks.ReplayAll();
//    PersistentTreeMap m = PersistentTreeMap.create(meta, 1, "a", 2, "b");
//    Expect(m.count(), EqualTo(2));
//    Expect(m.valAt(1), EqualTo("a"));
//    Expect(m.valAt(2), EqualTo("b"));
//    Expect(m.containsKey(3), False);
//    Expect(m.meta(), SameAs(meta));
//    mocks.VerifyAll();
//}
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\PersistentTreeSetTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: Add tests for PersistentTreeSet
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\PersistentVectorTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// Want to bust out of the first tail, so need to insert more than 32 elements.
// Want to bust out of the first tail, so need to insert more than 32 elements.
// Let's get out of the second level, too.
// nth - tested in c-tor tests
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\PrintfTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// Conversions: b B s S h H
// Spec error: false.ToString() == "False", spec says do this but expects "false"
// Spec error: false.ToString() == "False", spec says do this but expects "false"
// Spec error: true.ToString() == "True", spec says do this but expects "true"
// Spec error: true.ToString() == "True", spec says do this but expects "true"
//TODO: For String spec, test other arg types
// TODO: For String spec, test IFormattable
// not implemented yet
//Test("    123,456,789", "%,15d", BigInteger.Parse("123456789"));
//Test("   -123,456,789", "%,15d", BigInteger.Parse("-123456789"));
// Do we want to match the e+xx of the Java version?
//Test("       1.235","%,12.4g", 1.23456789e0);
//Test("       1,235", "%,12.4g", 1.23456789e3);
//Test("    0.001235", "%,12.4g", 1.23456789e-3);
//Test("   1.235e+07", "%,12.4g", 1.23456789e7);
//Test("   1.235e-07", "%,12.4g", 1.23456789e-7);
// java has lowercase here.
// java has lowercase here.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\RangeTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// NB: in Range prior to CLJ-1515 (commit 07d6129 2015-04-10), next preserved meta.
// in Range after, it does not.
//[Test]
//public void Rest_preserves_meta()
//{
//    VerifyISeqRestMaintainsMeta(_rWithMeta);
//}
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\RatioTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// precision = 16
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\RefTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: Add tests for Ref
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\RestFnImplTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//TODO: Add RestFnImpl tests
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\RestFnTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: Add RestFn tests
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\StreamTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// TODO: add tests for Stream
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\StringSeqTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\SymbolTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// We've been testing these all along.
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\LibTests\TestTest.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//public class BaseTest : AssertionHelper
//{
//    [Test]
//    public void Test1()
//    {
//        Console.WriteLine("T1");
//    }
//    [Test]
//    public void Test2()
//    {
//        Console.WriteLine("T2");
//    }
//}
//[TestFixture]
//public class TestTest : BaseTest
//{
//    [Test]
//    public void Test3()
//    {
//        Console.WriteLine("T3");
//    }
//}
//[TestFixture]
//public class TestTest2 : BaseTest
//{
//    [Test]
//    public void Test4()
//    {
//        Console.WriteLine("T4");
//    }
//}
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\Properties\AssemblyInfo.cs
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
// The following GUID is for the ID of the typelib if this project is exposed to COM
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Csharp.Tests\ReaderTests\LineNumberingTextReaderTests.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
// \r\n
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\DlrConsole\Program.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//ScriptRuntime env = ScriptRuntime.CreateFromConfiguration();
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\DlrConsole\Properties\AssemblyInfo.cs
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
// The following GUID is for the ID of the typelib if this project is exposed to COM
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Simple.Console\SimpleConsole.cs
/**
//opensource.org/licenses/eclipse-1.0.php)
/**
//LoadFromStream(new StringReader(clojure.lang.Properties.Resources.core),false);
//RT.load("/core");
//LoadFromStream(new StringReader(clojure.lang.Properties.Resources.core_print), false);
//LoadFromStream(new StringReader(clojure.lang.Properties.Resources.test), false);
//LambdaExpression ast = Compiler.GenerateLambda(form, addPrint);
//ret = ast.Compile().DynamicInvoke();
//RT.PRINT_LENGTH, RT.PRINT_LENGTH.deref(),
//RT.PRINT_LEVEL, RT.PRINT_LEVEL.deref(),
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\Clojure\Simple.Console\Properties\AssemblyInfo.cs
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
// The following GUID is for the ID of the typelib if this project is exposed to COM
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
________________________________________________________________________________________
E:/AllLangDS/ds/csharp/clojure-clr-master\clojure-clr-master\docs\TestJavaFormat\src\testjavaformat\Main.java
/*
/**
/**
//Test("%,12.4e", 1234.56789);
//System.out.println("char1 =" + String.format("%x", (int) s.charAt(1)));
