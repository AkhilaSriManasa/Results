# How to contribute

The easiest way to contribute is to open an issue and start a discussion.
Then we can decide if and how a feature or a change could be implemented and if you should submit a pull requests with code changes. We encourage all contributors to write tests for the features they are contributing.

Also read this first: [Being a good open source citizen](https://hackernoon.com/being-a-good-open-source-citizen-9060d0ab9732#.x3hocgw85)

## General feedback and discussions

Please start a discussion on the [core repo issue tracker](https://github.com/CoreWCF/CoreWCF/issues).

## Platform

Core WCF is built on top of .NET Core 2.2.

## Building

Run `dotnet build` from the command line inside the src folder. This builds Core WCF.

## Other discussions

https://gitter.im/CoreWCF/CoreWCF

## Filing issues

The best way to get your bug fixed is to be as detailed as you can be about the problem.
Providing a minimal project with steps to reproduce the problem is ideal.
Here are questions you can answer before you file a bug to make sure you're not missing any important information.

1. Did you read the [documentation](https://corewcf.readthedocs.io/en/latest/)?
2. Did you include the snippet of broken code in the issue?
3. What are the *EXACT* steps to reproduce this problem (including source/destination types, mapping configuration and execution)?

GitHub supports [markdown](https://github.github.com/github-flavored-markdown/), so when filing bugs make sure you check the formatting before clicking submit.

## Contributing code and content

You will need to sign a [Contributor License Agreement](https://cla.dotnetfoundation.org/) before submitting your pull request.

Make sure you can build the code. Familiarize yourself with the project workflow and our coding conventions. If you don't know what a pull request is read this article: https://help.github.com/articles/using-pull-requests.

**We only accept PRs to the master branch.**

Before submitting a feature or substantial code contribution please discuss it with the team and ensure it follows the product roadmap. Here's a list of blog posts that are worth reading before doing a pull request:

* [Open Source Contribution Etiquette](http://tirania.org/blog/archive/2010/Dec-31.html) by Miguel de Icaza
* [Don't "Push" Your Pull Requests](http://www.igvita.com/2011/12/19/dont-push-your-pull-requests/) by Ilya Grigorik.
* [10 tips for better Pull Requests](http://blog.ploeh.dk/2015/01/15/10-tips-for-better-pull-requests/) by Mark Seemann
* [How to write the perfect pull request](https://github.com/blog/1943-how-to-write-the-perfect-pull-request) by GitHub

Here's a few things you should always do when making changes to the code base:

**Commit/Pull Request Format**

```
Summary of the changes (Less than 80 chars)
 - Detail 1
 - Detail 2

#bugnumber (in this specific format)
```

**Tests**

-  Tests need to be provided for every bug/feature that is completed.
-  Tests only need to be present for issues that need to be verified by QA (e.g. not tasks).
-  If there is a scenario that is far too hard to test there does not need to be a test for it.
  - "Too hard" is determined by the team as a whole.
  - With WCF there are many infrastructure scenarios which are hard to automate because of that infrastructure (kerberos auth in a Windows domain for example) but the tests are simple to write, just not execute. We will clarify such  scenarios which are too hard to test because of infrastructure requirements, but we will provide test code which isn't run as part of automated tests, but can be run manually in a configured environment. For example, on the WCF client we have tests which require being in a domain which are disabled but we have a flag we can set to enable running those tests so that if you are executing them in a domain, you can still test it.
The MIT License (MIT)

Copyright (c) 2019 .NET Foundation

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
### What is Core WCF? 

Core WCF is a port of Windows Communication Framework (WCF) to .NET Core. The goal of this project is to enable existing WCF projects to move to .NET Core. Please note that right now, this port is not production ready. We suggest waiting until there are release packages available before using WCF in a production environment. 

### How do I get started?

There are pre-release packages available from a NuGet feed hosted in Azure DevOps. You can download the packages by adding the following package source to your list of feeds.

    https://pkgs.dev.azure.com/dotnet/CoreWCF/_packaging/CoreWCF/nuget/v3/index.json

If you are using a nuget.config file with only the default nuget.org package source, after adding the CoreWCF feed it would like like this:
```xml
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <clear />
    <add key="nuget.org" value="https://api.nuget.org/v3/index.json" />
    <add key="CoreWCF" value="https://pkgs.dev.azure.com/dotnet/CoreWCF/_packaging/CoreWCF/nuget/v3/index.json" />
  </packageSources>
</configuration>
```
### How do I contribute?

Please see the [CONTRIBUTING.md](CONTRIBUTING.md) file for details.



### License, etc.

This project has adopted the code of conduct defined by the Contributor Covenant to clarify expected behavior in our community.
For more information see the [.NET Foundation Code of Conduct](https://dotnetfoundation.org/code-of-conduct).

Core WCF is Copyright &copy; 2019 .NET Foundation and other contributors under the [MIT license](LICENSE.txt).

### .NET Foundation

This project is supported by the [.NET Foundation](https://dotnetfoundation.org).
Using the CoreWCF Postman Samples Collection.json within Postman

- Run the DesktopServer or NetCoreServer example applications
- Start Postman
- Go to 'File' and then select 'Import..' on the dropdown menu
- Click on 'Choose Files'
- Browse to thse location of, and select, the JSON file
- Expand the collection in the left-hand pane and select the 'CoreWCF NetCoreServer Sample Request'
- Click on 'Send'// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
// This method is used to decide if we need to append the exception message parameters to the message when calling SR.Format. 
// by default it returns false.
// This is to make conversions of SR.Format(SR.ResourceName) to SR.Format(SR.ResourceName) be equivalent
// to SR.ResourceName. The call should be automatically refactored out.
// Throws if disposed
//message.Properties.Add() creates a copy...
// Explicitly cast to IDisposable to avoid the SecurityException.
// I don't think this is relevant on .Net Core but I don't believe
// it will emit any extra code from the JIT.
// Double-checked locking pattern requires volatile for read/write synchronization
// TODO: Convert to Async as Dns.GetHostEntry is now async
// MruCache doesn't have a this[] operator, so we first remove (just in case it exists already)
//if (DiagnosticUtility.ShouldTraceWarning)
//{
//    TraceUtility.TraceEvent(TraceEventType.Warning, TraceCode.RequestContextAbort,
//        SR.Format(SR.TraceCodeRequestContextAbort), this);
//}
/// <summary>
/// Attempts to initiate the reply. If a reply is not initiated already (and the object is opened), 
/// then it initiates the reply and returns true. Otherwise, it returns false.
/// </summary>
// "null" is a valid reply (signals a 202-style "ack"), so we don't have a null-check here
// This method is designed for WebSocket only, and will only be used once the WebSocket response was sent.
// For WebSocket, we never call HttpRequestContext.Reply to send the response back. 
// Instead we call AcceptWebSocket directly. So we need to set the replyInitiated and 
// replySent boolean to be true once the response was sent successfully. Otherwise when we 
// are disposing the HttpRequestContext, we will see a bunch of warnings in trace log.
//if (TD.CloseTimeoutIsEnabled())
//{
//    TD.CloseTimeout(e.Message);
//}
// cache matches, for lookup speed
// The UriPrefixTable instance itself is used as a 
// synchronization primitive in the TransportManagers and the 
// TransportManagerContainers so we return 'this' to keep them in sync.                 
// don't need to normalize path since SegmentHierarchyNode is 
// already OrdinalIgnoreCase
// We might return null and true in the case of DBNull (cached negative result).
// When TItem is object, the cast isn't sufficient to weed out DBNulls, so we need an explicit check.
// Don't allow explicitly adding DBNulls.
// HopperCache uses null as 'doesn't exist', so use DBNull as a stand-in for null.
// exact match failed, perform the full lookup (which will also
// catch case-insensitive variations that aren't yet in our cache)
// We want to cache both positive AND negative results
// Since every newly registered Uri could alter what Prefixes should have matched, we
// should clear the cache of any existing results and start over
// Since every removed Uri could alter what Prefixes should have matched, we
// should clear the cache of any existing results and start over
// Never remove the root
// struct
// The userName+password also accompany...
// bool is whether to remove this node
//
// The cache will grow until the high watermark. At which point, the least recently used items
// will be purge until the cache's size is reduced to low watermark
//
// if anything goes wrong (duplicate entry, etc) we should 
// clear our caches so that we don't get out of sync
// If the cache is full, purge enough LRU items to shrink the 
// cache down to the low watermark
// Add  the new entry to the cache and make it the MRU element
//
// If found, make the entry most recently used
//
// first check our MRU item
// Move the node to the head of the MRU list if it's not already there
// Without this fixup, when completing the call to await TakeLockAsync there is
// a switch of Context and _localTaken will be reset to false. This is because
// of leaving the task.
//[Serializable]
// This can't throw something like ArgumentException because that would be worse than
// throwing the callback exception that was requested.
//protected CallbackException(SerializationInfo info, StreamingContext context) : base(info, context)
//{
//}
// AggregateExceptions are automatically unwrapped.
// TargetInvocationExceptions are automatically unwrapped.
// If aggregateException contains any fatal exceptions, return it directly
// without tracing it or any inner exceptions.
// Collapse possibly nested graph into a flat list.
// Empty inner exception list is unlikely but possible via public api.
// Find the first inner exception, giving precedence to TPreferredException
// AggregateException may wrap TargetInvocationException, so unwrap those as well
// All inner exceptions are traced
//if (TraceCore.ThrowingExceptionIsEnabled(this.diagnosticTrace))
//{
//    TraceCore.ThrowingException(this.diagnosticTrace, eventSource, exception != null ? exception.ToString() : string.Empty, exception);
//}
//BreakOnException(exception);
//TraceCore.UnhandledException(this.diagnosticTrace, exception != null ? exception.ToString() : string.Empty, exception);
//switch (traceEventType)
//{
//    case TraceEventType.Error:
//        if (TraceCore.HandledExceptionErrorIsEnabled(this.diagnosticTrace))
//        {
//            TraceCore.HandledExceptionError(this.diagnosticTrace, exception != null ? exception.ToString() : string.Empty, exception);
//        }
//        break;
//    case TraceEventType.Warning:
//        if (TraceCore.HandledExceptionWarningIsEnabled(this.diagnosticTrace))
//        {
//            TraceCore.HandledExceptionWarning(this.diagnosticTrace, exception != null ? exception.ToString() : string.Empty, exception);
//        }
//        break;
//    case TraceEventType.Verbose:
//        if (TraceCore.HandledExceptionVerboseIsEnabled(this.diagnosticTrace))
//        {
//            TraceCore.HandledExceptionVerbose(this.diagnosticTrace, exception != null ? exception.ToString() : string.Empty, exception);
//        }
//        break;
//    default:
//        if (TraceCore.HandledExceptionIsEnabled(this.diagnosticTrace))
//        {
//            TraceCore.HandledException(this.diagnosticTrace, exception != null ? exception.ToString() : string.Empty, exception);
//        }
//        break;
//}
// TODO: This is in internals so probably needs to go away
//SystemException
// This can't throw something like ArgumentException because that would be worse than
// throwing the fatal exception that was requested.
//protected FatalException(SerializationInfo info, StreamingContext context) : base(info, context)
//{
//}
// don't need a lock here since a true singleton is not required
//if (null != trace.EtwProvider)
//{
//    trace.RefreshState += delegate ()
//    {
//        Fx.UpdateLevel();
//    };
//}
//Fx.UpdateLevel(trace);
//TraceCore.ShipAssertExceptionMessage(Trace, description);
//TraceCore.ShipAssertExceptionMessage(Trace, description);
/*&& !(exception is InsufficientMemoryException)*/) ||
//exception is ThreadAbortException ||
// These exceptions aren't themselves fatal, but since the CLR uses them to wrap other exceptions,
// we want to check to see whether they've been used to wrap a fatal exception.  If so, then they
// count as fatal.
// AggregateExceptions have a collection of inner exceptions, which may themselves be other
// wrapping exceptions (including nested AggregateExceptions).  Recursively walk this
// hierarchy.  The (singular) InnerException is included in the collection.
/*InternalSR.ShipAssertExceptionMessage(description)*/)
// Safe to catch OOM from this as long as the ONLY thing it does is a simple allocation of a primitive type (no method calls).
// Convert OOM into an exception that can be safely handled by higher layers.
//new InsufficientMemoryException(InternalSR.BufferAllocationFailed(size), exception));
// PrepareConstrainedRegions are in .net standard 1.7+
//RuntimeHelpers.PrepareConstrainedRegions();
// This call exits the CER.  However, when still inside a catch, normal ThreadAbort is prevented.
// Rude ThreadAbort will still be allowed to terminate processing.
// This empty catch is only acceptable because we are a) in a CER and b) processing an exception
// which is about to crash the process anyway.
// This area is too sensitive to do anything but return.
// Don't let a new exception hide the original exception.
// This can't derive from Thunk since T would be unsafe.
// Do not increase the maximum capacity above 32k!  It must be a power of two, 0x8000 or less, in order to
// work with the strategy for 'headTail'.
// This method is only valid if you already know that (gate & HiBits) != 0.
// This field holds both the head (HiWord) and tail (LoWord) indices into the slot array.  This limits each
// value to 64k.  In order to be able to distinguish wrapping the slot array (allowed) from wrapping the
// indices relative to each other (not allowed), the size of the slot array is limited by an additional bit
// to 32k.
//
// The HiWord (head) holds the index of the last slot to have been scheduled into.  The LoWord (tail) holds
// the index of the next slot to be dispatched from.  When the queue is empty, the LoWord will be exactly
// one slot ahead of the HiWord.  When the two are equal, the queue holds one item.
//
// When the tail is *two* slots ahead of the head (equivalent to a count of -1), that means the IOTS is
// idle.  Hence, we start out headTail with a -2 (equivalent) in the head and zero in the tail.
// This field is the same except that it governs the low-priority work items.  It doesn't have a concept
// of idle (-2) so starts empty (-1).
// Called in a finally because it needs to run uninterrupted in order to maintain consistency.
// Called in a finally because it needs to run uninterrupted in order to maintain consistency.
// Returns true if successfully scheduled, false otherwise.
// See if there's a free slot.  Fortunately the overflow bit is simply lost.
// If this brings us to 'empty', then the IOTS used to be 'idle'.  Remember that, and increment
// again.  This doesn't need to be in a loop, because until we call Post(), we can't go back to idle.
// Check if we wrapped *around* to idle.
// Since the capacity is limited to 32k, this means we wrapped the array at least twice.  That's bad
// because headTail no longer knows how many work items we have - it looks like zero.  This can
// only happen if 32k threads come through here while one is swapped out.
// Wrapped around the circular buffer.  Create a new, bigger IOThreadScheduler.
// It's our responsibility to kick off the overlapped.
// Returns true if successfully scheduled, false otherwise.
// See if there's a free slot.  Fortunately the overflow bit is simply lost.
// If this is the first low-priority work item, make sure we're not idle.
// Since Interlocked calls create a full thread barrier, this will read the value of headTail
// at the time of the Interlocked.Add or later.  The invariant is that the IOTS is unidle at some
// point after the Add.
// Use a temporary local here to store the result of the Interlocked.CompareExchange.  This
// works around a codegen bug in the 32-bit JIT (TFS 749182).
// Check if we wrapped *around* to empty.
// Since the capacity is limited to 32k, this means we wrapped the array at least twice.  That's bad
// because headTail no longer knows how many work items we have - it looks like zero.  This can
// only happen if 32k threads come through here while one is swapped out.
// It's our responsibility to kick off the overlapped.
// We're about to set this to idle.  First check the low-priority queue.  This alone doesn't
// guarantee we service all the low-pri items - there hasn't even been an Interlocked yet.  But
// we take care of that later.
// We just set the IOThreadScheduler to idle.  Check if a low-priority item got added in the
// interim.
// Interlocked calls create a thread barrier, so this read will give us the value of
// headTailLowPri at the time of the interlocked that set us to idle, or later.  The invariant
// here is that either the low-priority queue was empty at some point after we set the IOTS to
// idle (so that the next enqueue will notice, and issue a Post), or that the IOTS was unidle at
// some point after we set it to idle (so that the next attempt to go idle will verify that the
// low-priority queue is empty).
// Whoops, go back from being idle (unless someone else already did).  If we go back, start
// over.  (We still owe a Post.)
// We know that there's a low-priority work item.  But we also know that the IOThreadScheduler
// wasn't idle.  It's best to let it take care of itself, since according to this method, we
// just set the IOThreadScheduler to idle so shouldn't take on any tasks.
//TODO, Dev10,607596 cannot apply security critical on finalizer
//[Fx.Tag.SecurityNote(Critical = "touches slots, may be called outside of user context")]
//[SecurityCritical]
// If the AppDomain is shutting down, we may still have pending ops.  The AppDomain shutdown will clean
// everything up.
// The headTail value could technically be zero if the constructor was aborted early.  The
// constructor wasn't aborted early if the slot array got created.
// TryEnqueueWorkItem and DequeueWorkItem use the slot's 'gate' field for synchronization.  Because the
// slot array is circular and there are no locks, we must assume that multiple threads can be entering each
// method simultaneously.  If the first DequeueWorkItem occurs before the first TryEnqueueWorkItem, the
// sequencing (and the enqueue) fails.
//
// The gate is a 32-bit int divided into four fields.  The bottom 15 bits (0x00007fff) are the count of
// threads that have entered TryEnqueueWorkItem.  The first thread to enter is the one responsible for
// filling the slot with work.  The 16th bit (0x00008000) is a flag indicating that the slot has been
// successfully filled.  Only the first thread to enter TryEnqueueWorkItem can set this flag.  The
// high-word (0x7fff0000) is the count of threads entering DequeueWorkItem.  The first thread to enter
// is the one responsible for accepting (and eventually dispatching) the work in the slot.  The
// high-bit (0x80000000) is a flag indicating that the slot has been successfully emptied.
//
// When the low-word and high-work counters are equal, and both bit flags have been set, the gate is considered
// 'complete' and can be reset back to zero.  Any operation on the gate might bring it to this state.
// It's the responsibility of the thread that brings the gate to a completed state to reset it to zero.
// (It's possible that the gate will fall out of the completed state before it can be reset - that's ok,
// the next time it becomes completed it can be reset.)
//
// It's unlikely either count will ever go higher than 2 or 3.
//
// The value of 'callback' has these properties:
//   -  When the gate is zero, callback is null.
//   -  When the low-word count is non-zero, but the 0x8000 bit is unset, callback is writable by the thread
//      that incremented the low word to 1.  Its value is undefined for other threads.  The thread that
//      sets callback is responsible for setting the 0x8000 bit when it's done.
//   -  When the 0x8000 bit is set and the high-word count is zero, callback is valid.  (It may be null.)
//   -  When the 0x8000 bit is set, the high-word count is non-zero, and the high bit is unset, callback is
//      writable by the thread that incremented the high word to 1 *or* the thread that set the 0x8000 bit,
//      whichever happened last.  That thread can read the value and set callback to null.  Its value is
//      undefined for other threads.  The thread that clears the callback is responsible for setting the
//      high bit.
//   -  When the high bit is set, callback is null.
//   -  It's illegal for the gate to be in a state that would satisfy more than one of these conditions.
//   -  The state field follows the same rules as callback.
// Register our arrival and check the state of this slot.  If the slot was already full, we wrapped.
// Set the special bit to show that the slot is filled.
// Good - no one has shown up looking for this work yet.
// Oops - someone already came looking for this work.  We have to abort and reschedule.
// Indicate that the slot is clear.  We might be able to bypass setting the high bit.
// Stake our claim on the item.
// Whoops, a race.  The work item hasn't made it in yet.  In this context, returning a null callback
// is treated like a degenerate work item (rather than an empty queue).  The enqueuing thread will
// notice this race and reschedule the real work in a new slot.  Do not reset the slot to zero,
// since it's still going to get enqueued into.  (The enqueueing thread will reset it.)
// If we're the first, we get to do the work.
// Indicate that the slot is clear.
// We should be able to bypass setting the high-bit in the common case.
// If we're the last, we get to reset the slot.
// A note about the IOThreadScheduler and the ScheduledOverlapped references:
// Although for each scheduler we have a single instance of overlapped, we cannot point to the scheduler from the
// overlapped, through the entire lifetime of the overlapped. This is because the ScheduledOverlapped is pinned
// and if it has a reference to the IOTS, it would be rooted and the finalizer will never get called.
// Therefore, we are passing the reference, when we post a pending callback and reset it, once the callback was
// invoked; during that time the scheduler is rooted but in that time we don't want that it would be collected
// by the GC anyway.
// Unhook the IOThreadScheduler ASAP to prevent it from leaking.
// Called in a finally because it needs to run uninterrupted in order to maintain consistency.
// The callback can be null if synchronization misses result in unusable slots.  Keep going onto
// the next slot in such cases until there are no more slots.
// Called in a finally because it needs to run uninterrupted in order to maintain consistency.
// IOThreadTimer has several characterstics that are important for performance:
// - Timers that expire benefit from being scheduled to run on IO threads using IOThreadScheduler.Schedule.
// - The timer "waiter" thread thread is only allocated if there are set timers.
// - The timer waiter thread itself is an IO thread, which allows it to go away if there is no need for it,
//   and allows it to be reused for other purposes.
// - After the timer count goes to zero, the timer waiter thread remains active for a bounded amount
//   of time to wait for additional timers to be set.
// - Timers are stored in an array-based priority queue to reduce the amount of time spent in updates, and
//   to always provide O(1) access to the minimum timer (the first one that will expire).
// - The standard textbook priority queue data structure is extended to allow efficient Delete in addition to 
//   DeleteMin for efficient handling of canceled timers.
// - Timers that are typically set, then immediately canceled (such as a retry timer, 
//   or a flush timer), are tracked separately from more stable timers, to avoid having 
//   to update the waitable timer in the typical case when a timer is canceled.  Whether 
//   a timer instance follows this pattern is specified when the timer is constructed.
// - Extending a timer by a configurable time delta (maxSkew) does not involve updating the
//   waitable timer, or taking a lock.
// - Timer instances are relatively cheap.  They share "heavy" resources like the waiter thread and 
//   waitable timer handle.
// - Setting or canceling a timer does not typically involve any allocations.
// Ticks
// We might be waiting on a later time so nudge it to reworkout the time
// Already passed the due time
// Always loop around and check wait time again as values might have changed.
// Covers CancellationToken.None as well as any other non-cancellable token
// TODO: Consider if unregistering would be helpful. It would require
// knowing that the CancellationToken is no longer needed.
// Timer has already fired so cancelling now.
// Ensure all callbacks are fired
// Callbacks shouldn't be throwing
// Once _timerFired is set, there's no need to hold the lock as
// no more will be added to the list.
// TODO: ActionItem.Schedule might be overkill here as I don't expect there
// to be many cancellations. There's just no
//This replaces the Wait<TException>(this Task task) method as we want to await and not Wait()
// Helper method when implementing an APM wrapper around a Task based async method which returns a result. 
// In the BeginMethod method, you would call use ToApm to wrap a call to MethodAsync:
//     return MethodAsync(params).ToApm(callback, state);
// In the EndMethod, you would use ToApmEnd<TResult> to ensure the correct exception handling
// This will handle throwing exceptions in the correct place and ensure the IAsyncResult contains the provided
// state object
/// <summary>
/// Helper method to convert from Task async method to "APM" (IAsyncResult with Begin/End calls)
/// </summary>
// We use OnCompleted rather than ContinueWith in order to avoid running synchronously
// if the task has already completed by the time we get here. 
// This will allocate a delegate and some extra data to add it as a TaskContinuation
/// <summary>
/// Helper method to convert from Task async method to "APM" (IAsyncResult with Begin/End calls)
/// </summary>
// We use OnCompleted rather than ContinueWith in order to avoid running synchronously
// if the task has already completed by the time we get here. 
// This will allocate a delegate and some extra data to add it as a TaskContinuation
// Calls the async callback with this as parameter
// Awaitable helper to await a maximum amount of time for a task to complete. If the task doesn't
// complete in the specified amount of time, returns false. This does not modify the state of the
// passed in class, but instead is a mechanism to allow interrupting awaiting a task if a timeout
// period passes.
// Task.GetAwaiter().GetResult() calls an internal variant of Wait() which doesn't wrap exceptions in
// an AggregateException. It does spinwait so if it's expected that the Task isn't about to complete,
// then use the NoSpin variant.
// If the task is about to complete, this method will be more expensive than the regular method as it
// always causes a WaitHandle to be allocated. If it is expected that the task will take longer than
// the time of a spin wait, then a WaitHandle will be allocated anyway and this method avoids the CPU
// cost of the spin wait.
// Call GetResult() to get any exceptions that were thrown
// Throw any exceptions if there are any
// Used by WebSocketTransportDuplexSessionChannel on the sync code path.
// TODO: Try and switch as many code paths as possible which use this to async
// Method to act as callback for asynchronous code which uses AsyncCompletionResult as the return type when used within
// a Task based async method. These methods require a callback which is called in the case of the IO completing asynchronously.
// This pattern still requires an allocation, whereas the purpose of using the AsyncCompletionResult enum is to avoid allocation.
// In the future, this pattern should be replaced with a reusable awaitable object, potentially with a global pool.
// No need to save and restore state as we're already using the correct sync context
// Calls the given Action asynchronously.
// No need to change threads if already off of thread pool
// Move synchronous method off of thread pool
// This awaiter causes an awaiting async method to continue on the same thread if using the
// default task scheduler, otherwise it posts the continuation to the ThreadPool. While this
// does a similar function to Task.ConfigureAwait, this code doesn't require a Task to function.
// With Task.ConfigureAwait, you would need to call it on the first task on each potential code
// path in a method. This could mean calling ConfigureAwait multiple times in a single method.
// This awaiter can be awaited on at the beginning of a method a single time and isn't dependant
// on running other awaitable code.
// If the current TaskScheduler is the default, if we aren't currently running inside a task and
// the default SynchronizationContext isn't current, when a Task starts, it will change the TaskScheduler
// to one based off the current SynchronizationContext. Also, any async api's that WCF consumes will
// post back to the same SynchronizationContext as they were started in which could cause WCF to deadlock
// on our Sync code path.
// Only called when IsCompleted returns false, otherwise the caller will call the continuation
// directly causing it to stay on the same thread.
// Awaiter is only used to control where subsequent awaitable's run so GetResult needs no
// implementation. Normally any exceptions would be thrown here, but we have nothing to throw
// as we don't run anything, only control where other code runs.
// Async methods can't take an out (or ref) argument. This wrapper allows passing in place of an out argument
// and can be used to return a value via a method argument.
// This is a brief plan on how to recover original timeout from CancellationToken
// The coalescing is needed to prevent hammering at the timer queue otherwise we
// get a lot of contention on it. It's really only the timer that needs to be coalesced.
// 1. Change the coalescing to keep track of IOThreadTimer object
// 2. Create a class which derives from/encapsulates an IOThreadTimer which can be used to
//    register CancellationTokenSource objects to call cancel when the timer fires. This
//    is the class that we coalesce.
// 3. Create RecoverableTimeoutCancellationTokenSource which derives from Cancellation token source.
//    It has the following behavior:
//    a. Takes the derived IOThreadTimer from (2) in the constructor and registers cancelling itself
//       when the timer fires.
//    b. Takes the requested timeout in the constructor and saves it.
//    c. Override the GetHashCode method to return a value representing the original timeout value.
//       CancellationToken defers to the owning CancellationTokenSource to implement GetHashCode()
// 4. Add a TimeoutHelper method which returns a TimeSpan from a CancellationToken. It queries the
//    GetHashCode method to get the original requested timeout.
// http://msdn.microsoft.com/en-us/library/85bbbxt9(v=vs.110).aspx 
// with exitContext was used in Desktop which is not supported in Net Native or CoreClr
/// <summary>
/// This class coalesces timeout tokens because cancelation tokens with timeouts are more expensive to expose.
/// Disposing too many such tokens will cause thread contentions in high throughput scenario.
///
/// Tokens with target cancelation time 15ms apart would resolve to the same instance.
/// </summary>
/// <summary>
/// These are constants use to calculate timeout coalescing, for more description see method FromTimeoutAsync
/// </summary>
// Note that CancellationTokenSource constructor requires input to be >= -1,
// restricting millisecondsTimeout to be >= -1 would enforce that
// To prevent s_tokenCache growing too large, we have to adjust the granularity of the our coalesce depending
// on the value of millisecondsTimeout. The coalescing span scales proportionally with millisecondsTimeout which
// would guarantee constant s_tokenCache size in the case where similar millisecondsTimeout values are accepted.
// If the method is given a wildly different millisecondsTimeout values all the time, the dictionary would still
// only grow logarithmically with respect to the range of the input values
// Formula for our coalescing span:
// Divide millisecondsTimeout by SegmentationFactor and take the highest bit and then multiply CoalescingFactor back
// only a single thread may succeed adding its timer into the cache
// Clean up cache when timer fires
// for threads that failed when calling TryAdd, there should be one already in the cache
// In unlikely scenario the timer has already fired, we would not find it in cache.
// In this case we would simply create a CTS which doesn't use the coalesced timer. 
/* Here are the TraceSR resource strings which come from SMDiagnostics
// This cache works like a MruCache, but operates loosely and without locks in the mainline path.
//
// It consists of three 'hoppers', which are Hashtables (chosen for their nice threading characteristics - reading
// doesn't require a lock).  Items enter the cache in the second hopper.  On lookups, cache hits result in the
// cache entry being promoted to the first hopper.  When the first hopper is full, the third hopper is dropped,
// and the first and second hoppers are shifted down, leaving an empty first hopper.  If the second hopper is
// full when a new cache entry is added, the third hopper is dropped, the second hopper is shifted down, and a
// new second hopper is slotted in to become the new item entrypoint.
//
// Items can only be added and looked up.  There's no way to remove an item besides through attrition.
//
// This cache has a built-in concept of weakly-referenced items (which can be enabled or disabled in the
// constructor).  It needs this concept since the caller of the cache can't remove dead cache items itself.
// A weak HopperCache will simply ignore dead entries.
//
// This structure allows cache lookups to be almost lock-free.  The only time the first hopper is written to
// is when a cache entry is promoted.  Promoting a cache entry is not critical - it's ok to skip a promotion.
// Only one promotion is allowed at a time.  If a second is attempted, it is skipped.  This allows promotions
// to be synchronized with just an Interlocked call.
//
// New cache entries go into the second hopper, which requires a lock, as does shifting the hoppers down.
//
// The hopperSize parameter determines the size of the first hopper.  When it reaches this size, the hoppers
// are shifted.  The second hopper is allowed to grow to twice this size.  This is because it needs room to get
// new cache entries into the system, and the second hopper typically starts out 'full'.  Entries are never added
// directly to the third hopper.
//
// It's a error on the part of the caller to add the same key to the cache again if it's already in the cache
// with a different value.  The new value will not necessarily overwrite the old value.
//
// If a cache entry is about to be promoted from the third hopper, and in the mean time the third hopper has been
// shifted away, an intervening GetValue for the same key might return null, even though the item is still in
// the cache and a later GetValue might find it.  So it's very important never to add the same key to the cache
// with two different values, even if GetValue returns null for the key in-between the first add and the second.
// (If this particular behavior is a problem, it may be possible to tighten up, but it's not necessary for the
// current use of HopperCache - UriPrefixTable.)
// Calls to Add must be synchronized.
// Special-case DBNull since it can never be collected.
// The try/finally is here to make sure these happen without interruption.
// We do nothing to prevent things from getting added multiple times.  Also may be writing over
// a dead weak entry.
// Calls to GetValue do not need to be synchronized, but the object used to synchronize the Add calls
// must be passed in.  It's sometimes used.
// The MruCache does this so we have to too.
// Try the first hopper.
// Try the subsequent hoppers.
// Still no value?  It's not here.
// If we can get the promoting semaphore, move up to the outstanding hopper.
// This is effectively a lock, which is why it uses lock semantics.  If the Interlocked call
// were 'lost', the cache wouldn't deadlock, but it would be permanently broken.
// Only one thread can be inside this 'if' at a time.
// The try/finally is here to make sure these happen without interruption.
// It's easy for this to happen twice with the same key.
//
// It's important that no one else can be shifting the current oustandingHopper
// during this operation.  We are only allowed to modify the *current* outstandingHopper
// while holding the pseudo-lock, which would be violated if it could be shifted out from
// under us (and potentially added to by Add in a race).
//public BasicHttpBinding(System.ServiceModel.BasicHttpSecurityMode securityMode) { }
//public System.ServiceModel.BasicHttpSecurity Security { get { return default(CoreWCF.BasicHttpSecurity); } set { } }
//public override CoreWCF.Channels.IChannelFactory<TChannel> BuildChannelFactory<TChannel>(CoreWCF.Channels.BindingParameterCollection parameters) { return default(CoreWCF.Channels.IChannelFactory<TChannel>); }
// return collection of BindingElements
// order of BindingElements is important
// add security (*optional)
//SecurityBindingElement wsSecurity = BasicHttpSecurity.CreateMessageSecurity();
//if (wsSecurity != null)
//{
//    bindingElements.Add(wsSecurity);
//}
// add encoding
// add transport (http or https)
// TODO: Make this generic shared code used by multiple assemblies
//exceptionUtility = new ExceptionUtility("System.ServiceModel", "System.ServiceModel 4.0.0.0", (object)DiagnosticUtility.diagnosticTrace, (object)FxTrace.Exception);
//FxTrace.Exception.TraceHandledException(exception, traceEventType);
//internal Exception ThrowHelperFatal(string message, Exception innerException)
//{
//    return ThrowHelperError(new FatalException(message, innerException));
//}
//if ((_diagnosticTrace == null ? 0 : (_diagnosticTrace.ShouldTrace(eventType) ? 1 : 0)) != 0)
//{
//    using (
//        ExceptionUtility.useStaticActivityId
//            ? Activity.CreateActivity(ExceptionUtility.activityId)
//            : (Activity)null)
//        _diagnosticTrace.TraceEvent(eventType, 131075,
//            LegacyDiagnosticTrace.GenerateMsdnTraceCode("System.ServiceModel.Diagnostics",
//                "ThrowingException"), TraceSR.Format("ThrowingException"), extendedData, exception,
//            (object)null);
//    IDictionary data = exception.Data;
//    if (data != null && !data.IsReadOnly && !data.IsFixedSize)
//    {
//        object obj =
//            data[(object)"System.ServiceModel.Diagnostics.ExceptionUtility.ExceptionStackAsString"];
//        string str1 = obj == null ? "" : obj as string;
//        if (str1 != null)
//        {
//            string stackTrace = exception.StackTrace;
//            if (!string.IsNullOrEmpty(stackTrace))
//            {
//                string str2 = str1 + (str1.Length == 0 ? "" : Environment.NewLine) + "throw" +
//                              Environment.NewLine + stackTrace + Environment.NewLine + "catch" +
//                              Environment.NewLine;
//                data[(object)"System.ServiceModel.Diagnostics.ExceptionUtility.ExceptionStackAsString"]
//                    = (object)str2;
//            }
//        }
//    }
//}
//this.exceptionTrace.TraceEtwException(exception, eventType);
//Microsoft.Runtime.Diagnostics.EventLogger logger = null;
//try
//{
//    logger = new Microsoft.Runtime.Diagnostics.EventLogger(this.eventSourceName, this.diagnosticTrace);
//}
//finally
//{
//    TraceFailFast(message, logger);
//}
// [System.ComponentModel.DefaultValueAttribute(false)]
// public bool AllowCookies { get { return default(bool); } set { } }
// [System.ComponentModel.DefaultValueAttribute((long)524288)]
// public long MaxBufferPoolSize { get { return default(long); } set { } }
// [System.ComponentModel.DefaultValueAttribute(65536)]
// public int MaxBufferSize { get { return default(int); } set { } }
// [System.ComponentModel.DefaultValueAttribute((System.ServiceModel.TransferMode)(0))]
// public System.ServiceModel.TransferMode TransferMode { get { return default(System.ServiceModel.TransferMode); } set { } }
//Contract.Assert(this.BasicHttpSecurity != null, "this.BasicHttpSecurity should not return null from a derived class.");
//BasicHttpSecurity basicHttpSecurity = this.BasicHttpSecurity;
//if (basicHttpSecurity.Mode == BasicHttpSecurityMode.Transport || basicHttpSecurity.Mode == BasicHttpSecurityMode.TransportWithMessageCredential)
//{
//    basicHttpSecurity.EnableTransportSecurity(_httpsTransport);
//    return _httpsTransport;
//}
//else if (basicHttpSecurity.Mode == BasicHttpSecurityMode.TransportCredentialOnly)
//{
//    basicHttpSecurity.EnableTransportAuthentication(_httpTransport);
//    return _httpTransport;
//}
//else
//{
//    // ensure that there is no transport security
//    basicHttpSecurity.DisableTransportAuthentication(_httpTransport);
//    return _httpTransport;
//}
//BasicHttpSecurity security = this.BasicHttpSecurity;
//if (security == null)
//{
//    return;
//}
//BasicHttpSecurityMode mode = security.Mode;
//if (mode == BasicHttpSecurityMode.None)
//{
//    return;
//}
//else if (mode == BasicHttpSecurityMode.Message || mode == BasicHttpSecurityMode.TransportWithMessageCredential)
//{
//    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException(SR.Format(SR.UnsupportedSecuritySetting, "Mode", mode)));
//}
//// Transport.ClientCredentialType = InheritedFromHost are not supported.
//Fx.Assert(
//    (mode == BasicHttpSecurityMode.Transport) || (mode == BasicHttpSecurityMode.TransportCredentialOnly),
//    "Unexpected BasicHttpSecurityMode value: " + mode);
//HttpTransportSecurity transport = security.Transport;
//if (transport != null && transport.ClientCredentialType == HttpClientCredentialType.InheritedFromHost)
//{
//    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException(SR.Format(SR.UnsupportedSecuritySetting, "Transport.ClientCredentialType", transport.ClientCredentialType)));
//}
//www.w3.org/2003/05/soap-envelope";
//www.w3.org/2005/08/addressing";
//www.w3.org/2005/08/addressing/anonymous";
//schemas.xmlsoap.org/ws/2005/02/rm";
//schemas.microsoft.com/ws/2006/05/rm";
//schemas.xmlsoap.org/ws/2005/02/rm/SequenceAcknowledgement";
//www.w3.org/2000/09/xmldsig#";
//www.w3.org/2000/09/xmldsig#enveloped-signature";
//docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd";
//www.w3.org/2001/04/xmlenc#";
//schemas.xmlsoap.org/ws/2005/02/sc";
//docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd";
//docs.oasis-open.org/wss/oasis-wss-wssecurity-secext-1.1.xsd";
//schemas.xmlsoap.org/ws/2005/02/trust";
//schemas.xmlsoap.org/ws/2005/02/trust#BinarySecret";
//schemas.microsoft.com/ws/2006/02/transactions";
//schemas.xmlsoap.org/ws/2006/02/addressingidentity";
//www.w3.org/2005/08/addressing/fault";
//www.w3.org/2005/08/addressing/reply";
//www.w3.org/2005/08/addressing/none";
//schemas.xmlsoap.org/ws/2004/08/addressing";
//schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous";
//schemas.xmlsoap.org/ws/2004/08/addressing/fault";
//schemas.xmlsoap.org/ws/2004/06/addressingex";
//www.w3.org/2001/10/xml-exc-c14n#";
//schemas.xmlsoap.org/ws/2004/04/sc";
//schemas.xmlsoap.org/ws/2004/04/security/sc/dk";
//schemas.xmlsoap.org/ws/2004/04/security/sc/sct";
//schemas.xmlsoap.org/ws/2004/04/security/trust/RST/SCT";
//schemas.xmlsoap.org/ws/2004/04/security/trust/RSTR/SCT";
//schemas.xmlsoap.org/ws/2005/02/sc/dk";
//schemas.xmlsoap.org/ws/2005/02/sc/sct";
//schemas.xmlsoap.org/ws/2005/02/trust/RST/SCT";
//schemas.xmlsoap.org/ws/2005/02/trust/RSTR/SCT";
//schemas.xmlsoap.org/ws/2005/02/trust/RST/SCT/Renew";
//schemas.xmlsoap.org/ws/2005/02/trust/RSTR/SCT/Renew";
//schemas.xmlsoap.org/ws/2005/02/trust/RST/SCT/Cancel";
//schemas.xmlsoap.org/ws/2005/02/trust/RSTR/SCT/Cancel";
//www.w3.org/2001/04/xmlenc#aes128-cbc";
//www.w3.org/2001/04/xmlenc#kw-aes128";
//www.w3.org/2001/04/xmlenc#aes192-cbc";
//www.w3.org/2001/04/xmlenc#kw-aes192";
//www.w3.org/2001/04/xmlenc#aes256-cbc";
//www.w3.org/2001/04/xmlenc#kw-aes256";
//www.w3.org/2001/04/xmlenc#des-cbc";
//www.w3.org/2000/09/xmldsig#dsa-sha1";
//www.w3.org/2001/10/xml-exc-c14n#WithComments";
//www.w3.org/2000/09/xmldsig#hmac-sha1";
//www.w3.org/2001/04/xmldsig-more#hmac-sha256";
//schemas.xmlsoap.org/ws/2005/02/sc/dk/p_sha1";
//www.w3.org/2001/04/xmlenc#ripemd160";
//www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p";
//www.w3.org/2000/09/xmldsig#rsa-sha1";
//www.w3.org/2001/04/xmldsig-more#rsa-sha256";
//www.w3.org/2001/04/xmlenc#rsa-1_5";
//www.w3.org/2000/09/xmldsig#sha1";
//www.w3.org/2001/04/xmlenc#sha256";
//www.w3.org/2001/04/xmlenc#sha512";
//www.w3.org/2001/04/xmlenc#tripledes-cbc";
//www.w3.org/2001/04/xmlenc#kw-tripledes";
//schemas.xmlsoap.org/2005/02/trust/tlsnego#TLS_Wrap";
//schemas.xmlsoap.org/2005/02/trust/spnego#GSS_Wrap";
//schemas.microsoft.com/ws/2006/05/security";
//docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary";
//docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#HexBinary";
//docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Text";
//docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509SubjectKeyIdentifier";
//docs.oasis-open.org/wss/oasis-wss-kerberos-token-profile-1.1#GSS_Kerberosv5_AP_REQ";
//docs.oasis-open.org/wss/oasis-wss-kerberos-token-profile-1.1#GSS_Kerberosv5_AP_REQ1510";
//docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.0#SAMLAssertionID";
//docs.oasis-open.org/wss/oasis-wss-rel-token-profile-1.0.pdf#license";
//docs.oasis-open.org/wss/oasis-wss-soap-message-security-1.1#ThumbprintSHA1";
//docs.oasis-open.org/wss/oasis-wss-soap-message-security-1.1#EncryptedKey";
//docs.oasis-open.org/wss/oasis-wss-soap-message-security-1.1#EncryptedKeySHA1";
//docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV1.1";
//docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV2.0";
//docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLID";
//schemas.xmlsoap.org/ws/2005/02/trust/spnego";
//schemas.xmlsoap.org/ws/2005/02/trust/tlsnego";
//schemas.xmlsoap.org/ws/2004/04/trust";
//schemas.xmlsoap.org/ws/2004/04/security/trust/RST/Issue";
//schemas.xmlsoap.org/ws/2004/04/security/trust/RSTR/Issue";
//schemas.xmlsoap.org/ws/2004/04/security/trust/Issue";
//schemas.xmlsoap.org/ws/2004/04/security/trust/CK/PSHA1";
//schemas.xmlsoap.org/ws/2004/04/security/trust/SymmetricKey";
//schemas.xmlsoap.org/ws/2004/04/security/trust/Nonce";
//schemas.xmlsoap.org/ws/2004/04/trust/SymmetricKey";
//schemas.xmlsoap.org/ws/2004/04/trust/PublicKey";
//schemas.microsoft.com/net/2004/07/secext/WS-SPNego";
//schemas.microsoft.com/net/2004/07/secext/TLSNego";
//schemas.xmlsoap.org/ws/2005/02/trust/RST/Issue";
//schemas.xmlsoap.org/ws/2005/02/trust/RSTR/Issue";
//schemas.xmlsoap.org/ws/2005/02/trust/Issue";
//schemas.xmlsoap.org/ws/2005/02/trust/SymmetricKey";
//schemas.xmlsoap.org/ws/2005/02/trust/CK/PSHA1";
//schemas.xmlsoap.org/ws/2005/02/trust/Nonce";
//schemas.xmlsoap.org/ws/2005/02/trust/Renew";
//schemas.xmlsoap.org/ws/2005/02/trust/Cancel";
//schemas.xmlsoap.org/ws/2005/02/trust/PublicKey";
//schemas.microsoft.com/ws/2005/02/duplex";
//www.w3.org/2001/04/xmlenc#Element";
//www.w3.org/2001/04/xmlenc#Content";
//schemas.xmlsoap.org/ws/2005/02/rm/AckRequested";
//schemas.xmlsoap.org/ws/2005/02/rm/CreateSequence";
//schemas.xmlsoap.org/ws/2005/02/rm/CreateSequenceResponse";
//schemas.xmlsoap.org/ws/2005/02/rm/LastMessage";
//schemas.xmlsoap.org/ws/2005/02/rm/TerminateSequence";
//schemas.microsoft.com/ws/2006/02/tx/oletx";
//schemas.xmlsoap.org/ws/2004/10/wscoor";
//schemas.xmlsoap.org/ws/2004/10/wscoor/CreateCoordinationContext";
//schemas.xmlsoap.org/ws/2004/10/wscoor/CreateCoordinationContextResponse";
//schemas.xmlsoap.org/ws/2004/10/wscoor/Register";
//schemas.xmlsoap.org/ws/2004/10/wscoor/RegisterResponse";
//schemas.xmlsoap.org/ws/2004/10/wscoor/fault";
//schemas.xmlsoap.org/ws/2004/10/wsat";
//schemas.xmlsoap.org/ws/2004/10/wsat/Completion";
//schemas.xmlsoap.org/ws/2004/10/wsat/Durable2PC";
//schemas.xmlsoap.org/ws/2004/10/wsat/Volatile2PC";
//schemas.xmlsoap.org/ws/2004/10/wsat/Commit";
//schemas.xmlsoap.org/ws/2004/10/wsat/Rollback";
//schemas.xmlsoap.org/ws/2004/10/wsat/Committed";
//schemas.xmlsoap.org/ws/2004/10/wsat/Aborted";
//schemas.xmlsoap.org/ws/2004/10/wsat/Prepare";
//schemas.xmlsoap.org/ws/2004/10/wsat/Prepared";
//schemas.xmlsoap.org/ws/2004/10/wsat/ReadOnly";
//schemas.xmlsoap.org/ws/2004/10/wsat/Replay";
//schemas.xmlsoap.org/ws/2004/10/wsat/fault";
//schemas.microsoft.com/2004/09/ServiceModel/Diagnostics";
//docs.oasis-open.org/wss/oasis-wss-kerberos-token-profile-1.1#Kerberosv5APREQSHA1";
//schemas.xmlsoap.org/ws/2002/12/policy";
//schemas.microsoft.com/net/2006/05/peer/HopCount";
//schemas.microsoft.com/net/2006/05/peer";
//schemas.microsoft.com/ws/2005/05/routing";
//schemas.microsoft.com/ws/2005/05/addressing/none";
//schemas.microsoft.com/ws/2005/05/envelope/none";
//www.w3.org/2001/XMLSchema-instance";
//www.w3.org/2001/XMLSchema";
//schemas.xmlsoap.org/soap/envelope/";
// Soap11 wants the detail in the header
// Main dictionary strings
// String constants
//schemas.microsoft.com/2005/12/ServiceModel/Addressing/Anonymous";
//schemas.microsoft.com/2005/12/ServiceModel/Addressing/None";
//schemas.microsoft.com/serviceModel/2004/05/addressing";
// Main dictionary strings
// String constants
//www.w3.org/2005/08/addressing/soap/fault";
// TODO: Verify what happens on .NET Framework. Looking at code it looks like it doesn't set this value
// TODO: Might want to do something a bit smarter with the state and actually have a concept of opening and closing to enable event handlers to be
// connected and fire them when the service is shutting down.
// TODO: This is duplicated from Primitives. Either move to common code and include in both places or add to contract. I would prefer the latter.
/// <summary>
/// Base class for non-SOAP messages
/// </summary>
//------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------
// abstract out the common functionality of an "HttpInput"
// Note: This method will return null in the case where throwOnError is false, and a non-fatal error occurs.
// Please exercise caution when passing in throwOnError = false.  This should basically only be done in error
// code paths, or code paths where there is very good reason that you would not want this method to throw.
// When passing in throwOnError = false, please handle the case where this method returns null.
// -1 if chunked
// if we're chunked, make sure we've consumed the whole body
// EOF 
// used for buffered streaming
// makes sure that appropriate HTTP level headers are included in the received Message
// check if user is receiving WS-1 messages
// fix to grab action from start-info as stated in RFC2387
// only if we can't find an action inside start-info
// abstract out the common functionality of an "HttpOutput"
//MtomMessageEncoder mtomMessageEncoder = messageEncoder as MtomMessageEncoder;
//if (mtomMessageEncoder == null)
//{
//}
//else
//{
//    contentType = mtomMessageEncoder.GetContentType(out this.mtomBoundary);
//    // For MTOM messages, add a MIME version header
//    AddMimeVersion("1.0");
//}
// by default, the HttpOutput should own the buffer and clean it up
//MtomMessageEncoder mtomMessageEncoder = messageEncoder as MtomMessageEncoder;
//if (mtomMessageEncoder == null)
//{
//}
//else
//{
//    result = mtomMessageEncoder.WriteMessage(message, int.MaxValue, bufferManager, 0, this.mtomBoundary);
//}
// Only set this.bufferToRecycle if the HttpOutput owns the buffer, we will clean it up upon httpOutput.Close()
// Otherwise, caller of SerializeBufferedMessage assumes responsibility for returning the buffer to the buffer pool
// buffer size used for synchronous writes
// const int BufferSize = 16384;   // buffer size used for asynchronous writes
// const int BufferCount = 4;      // buffer count used for asynchronous writes
// Writing an HTTP request chunk has a high fixed cost, so use BufferedStream to avoid writing 
// small ones. 
// TODO: Evaluate whether we need to buffer the output stream and if concurrent io is supported
//return supportsConcurrentIO ? (Stream)new BufferedOutputAsyncStream(outputStream, BufferSize, BufferCount) : new BufferedStream(outputStream, ChunkSize);
//return this.supportsConcurrentIO ? (Stream)new BufferedOutputAsyncStream(this.outputStream, BufferSize, BufferCount) : new BufferedStream(this.outputStream, ChunkSize);
// Since HTTP streams don't support timeouts, we can't just use TimeoutStream here. 
// Rather, we need to run a timer to bound the overall operation
// TODO: Verify that the cancellation token is honored for timeout
//IOThreadTimer sendTimer = new IOThreadTimer(onStreamSendTimeout, this, true);
//sendTimer.Set(timeout);
//MtomMessageEncoder mtomMessageEncoder = messageEncoder as MtomMessageEncoder;
//if (mtomMessageEncoder == null)
//{
//}
//else
//{
//    mtomMessageEncoder.WriteMessage(this.message, this.outputStream, this.mtomBoundary);
//}
//if (this.supportsConcurrentIO)
//{
//    this.outputStream.Close();
//}
//sendTimer.Cancel();
// requests can't always support an output stream (for GET, etc)
//need to get the Channel binding token (CBT), apply channel binding info to the message and then write the message                    
//CBT is only enabled when message security is in the stack, which also requires an HTTP entity body, so we 
//should be safe to always get the stream.
// requests can't always support an output stream (for GET, etc)
// TODO: Validate what to do about httpResponse.SendChunked property
//httpResponse.SendChunked = false;
//    public static void EnsureHttpRequestMessageContentNotNull(HttpRequestMessage httpRequestMessage)
//    {
//        if (httpRequestMessage.Content == null)
//        {
//            httpRequestMessage.Content = new ByteArrayContent(EmptyArray<byte>.Instance);
//        }
//    }
//    public static void EnsureHttpResponseMessageContentNotNull(HttpResponseMessage httpResponseMessage)
//    {
//        if (httpResponseMessage.Content == null)
//        {
//            httpResponseMessage.Content = new ByteArrayContent(EmptyArray<byte>.Instance);
//        }
//    }
//    public static bool IsEmpty(HttpResponseMessage httpResponseMessage)
//    {
//        return httpResponseMessage.Content == null
//           || (httpResponseMessage.Content.Headers.ContentLength.HasValue && httpResponseMessage.Content.Headers.ContentLength.Value == 0);
//    }
//    internal static void HandleContinueWithTask(Task task)
//    {
//        HandleContinueWithTask(task, null);
//    }
//    internal static void HandleContinueWithTask(Task task, Action<Exception> exceptionHandler)
//    {
//        if (task.IsFaulted)
//        {
//            if (exceptionHandler == null)
//            {
//                throw FxTrace.Exception.AsError<FaultException>(task.Exception);
//            }
//            else
//            {
//                exceptionHandler.Invoke(task.Exception);
//            }
//        }
//        else if (task.IsCanceled)
//        {
//            throw FxTrace.Exception.AsError(new TimeoutException(SR.GetString(SR.TaskCancelledError)));
//        }
//    }
//    public static void AbortRequest(HttpWebRequest request)
//    {
//        request.Abort();
//    }
//    public static void SetRequestTimeout(HttpWebRequest request, TimeSpan timeout)
//    {
//        int millisecondsTimeout = TimeoutHelper.ToMilliseconds(timeout);
//        if (millisecondsTimeout == 0)
//        {
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new TimeoutException(SR.GetString(
//                SR.HttpRequestTimedOut, request.RequestUri, timeout)));
//        }
//        request.Timeout = millisecondsTimeout;
//        request.ReadWriteTimeout = millisecondsTimeout;
//    }
//    public static void AddReplySecurityProperty(HttpChannelFactory<IRequestChannel> factory, HttpWebRequest webRequest,
//        HttpWebResponse webResponse, Message replyMessage)
//    {
//        SecurityMessageProperty securityProperty = factory.CreateReplySecurityProperty(webRequest, webResponse);
//        if (securityProperty != null)
//        {
//            replyMessage.Properties.Security = securityProperty;
//        }
//    }
//    public static void CopyHeaders(HttpRequestMessage request, AddHeaderDelegate addHeader)
//    {
//        HttpChannelUtilities.CopyHeaders(request.Headers, addHeader);
//        if (request.Content != null)
//        {
//            HttpChannelUtilities.CopyHeaders(request.Content.Headers, addHeader);
//        }
//    }
//    public static void CopyHeaders(HttpResponseMessage response, AddHeaderDelegate addHeader)
//    {
//        HttpChannelUtilities.CopyHeaders(response.Headers, addHeader);
//        if (response.Content != null)
//        {
//            HttpChannelUtilities.CopyHeaders(response.Content.Headers, addHeader);
//        }
//    }
//    static void CopyHeaders(HttpHeaders headers, AddHeaderDelegate addHeader)
//    {
//        foreach (KeyValuePair<string, IEnumerable<string>> header in headers)
//        {
//            foreach (string value in header.Value)
//            {
//                TryAddToCollection(addHeader, header.Key, value);
//            }
//        }
//    }
//    public static void CopyHeaders(NameValueCollection headers, AddHeaderDelegate addHeader)
//    {
//        //this nested loop logic was copied from NameValueCollection.Add(NameValueCollection)
//        int count = headers.Count;
//        for (int i = 0; i < count; i++)
//        {
//            string key = headers.GetKey(i);
//            string[] values = headers.GetValues(i);
//            if (values != null)
//            {
//                for (int j = 0; j < values.Length; j++)
//                {
//                    TryAddToCollection(addHeader, key, values[j]);
//                }
//            }
//            else
//            {
//                addHeader(key, null);
//            }
//        }
//    }
//    public static void CopyHeadersToNameValueCollection(NameValueCollection headers, NameValueCollection destination)
//    {
//        CopyHeaders(headers, destination.Add);
//    }
//    [System.Diagnostics.CodeAnalysis.SuppressMessage(FxCop.Category.ReliabilityBasic, "Reliability104",
//                        Justification = "The exceptions are traced already.")]
//    static void TryAddToCollection(AddHeaderDelegate addHeader, string headerName, string value)
//    {
//        try
//        {
//            addHeader(headerName, value);
//        }
//        catch (ArgumentException ex)
//        {
//            string encodedValue = null;
//            if (TryEncodeHeaderValueAsUri(headerName, value, out encodedValue))
//            {
//                //note: if the hosthame of a referer header contains illegal chars, we will still throw from here
//                //because Uri will not fix this up for us, which is ok. The request will get rejected in the error code path.
//                addHeader(headerName, encodedValue);
//            }
//            else
//            {
//                // In self-hosted scenarios, some of the headers like Content-Length cannot be added directly.
//                // It will throw ArgumentException instead.
//                FxTrace.Exception.AsInformation(ex);
//            }
//        }
//    }
//    static bool TryEncodeHeaderValueAsUri(string headerName, string value, out string result)
//    {
//        result = null;
//        //Internet Explorer will send the referrer header on the wire in unicode without encoding it
//        //this will cause errors when added to a WebHeaderCollection.  This is a workaround for sharepoint, 
//        //but will only work for WebHosted Scenarios.
//        if (String.Compare(headerName, "Referer", StringComparison.OrdinalIgnoreCase) == 0)
//        {
//            Uri uri;
//            if (Uri.TryCreate(value, UriKind.RelativeOrAbsolute, out uri))
//            {
//                if (uri.IsAbsoluteUri)
//                {
//                    result = uri.AbsoluteUri;
//                }
//                else
//                {
//                    result = uri.GetComponents(UriComponents.SerializationInfoString, UriFormat.UriEscaped);
//                }
//                return true;
//            }
//        }
//        return false;
//    }
//    //TODO, weixi, CSDMain 231775: Refactor the code for GetType logic in System.ServiceModel.dll and System.ServiceModel.Activation.dll
//    internal static Type GetTypeFromAssembliesInCurrentDomain(string typeString)
//    {
//        Type type = Type.GetType(typeString, false);
//        if (null == type)
//        {
//            if (!allReferencedAssembliesLoaded)
//            {
//                allReferencedAssembliesLoaded = true;
//                AspNetEnvironment.Current.EnsureAllReferencedAssemblyLoaded();
//            }
//            Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
//            for (int i = 0; i < assemblies.Length; i++)
//            {
//                type = assemblies[i].GetType(typeString, false);
//                if (null != type)
//                {
//                    break;
//                }
//            }
//        }
//        return type;
//    }
//    public static NetworkCredential GetCredential(AuthenticationSchemes authenticationScheme,
//        SecurityTokenProviderContainer credentialProvider, TimeSpan timeout,
//        out TokenImpersonationLevel impersonationLevel, out AuthenticationLevel authenticationLevel)
//    {
//        impersonationLevel = TokenImpersonationLevel.None;
//        authenticationLevel = AuthenticationLevel.None;
//        NetworkCredential result = null;
//        if (authenticationScheme != AuthenticationSchemes.Anonymous)
//        {
//            result = GetCredentialCore(authenticationScheme, credentialProvider, timeout, out impersonationLevel, out authenticationLevel);
//        }
//        return result;
//    }
//    [MethodImpl(MethodImplOptions.NoInlining)]
//    static NetworkCredential GetCredentialCore(AuthenticationSchemes authenticationScheme,
//        SecurityTokenProviderContainer credentialProvider, TimeSpan timeout,
//        out TokenImpersonationLevel impersonationLevel, out AuthenticationLevel authenticationLevel)
//    {
//        impersonationLevel = TokenImpersonationLevel.None;
//        authenticationLevel = AuthenticationLevel.None;
//        NetworkCredential result = null;
//        switch (authenticationScheme)
//        {
//            case AuthenticationSchemes.Basic:
//                result = TransportSecurityHelpers.GetUserNameCredential(credentialProvider, timeout);
//                impersonationLevel = TokenImpersonationLevel.Delegation;
//                break;
//            case AuthenticationSchemes.Digest:
//                result = TransportSecurityHelpers.GetSspiCredential(credentialProvider, timeout,
//                    out impersonationLevel, out authenticationLevel);
//                HttpChannelUtilities.ValidateDigestCredential(ref result, impersonationLevel);
//                break;
//            case AuthenticationSchemes.Negotiate:
//                result = TransportSecurityHelpers.GetSspiCredential(credentialProvider, timeout,
//                    out impersonationLevel, out authenticationLevel);
//                break;
//            case AuthenticationSchemes.Ntlm:
//                result = TransportSecurityHelpers.GetSspiCredential(credentialProvider, timeout,
//                    out impersonationLevel, out authenticationLevel);
//                if (authenticationLevel == AuthenticationLevel.MutualAuthRequired)
//                {
//                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
//                        new InvalidOperationException(SR.GetString(SR.CredentialDisallowsNtlm)));
//                }
//                break;
//            default:
//                // The setter for this property should prevent this.
//                throw Fx.AssertAndThrow("GetCredential: Invalid authentication scheme");
//        }
//        return result;
//    }
//    public static HttpWebResponse ProcessGetResponseWebException(WebException webException, HttpWebRequest request, HttpAbortReason abortReason)
//    {
//        HttpWebResponse response = null;
//        if (webException.Status == WebExceptionStatus.Success ||
//            webException.Status == WebExceptionStatus.ProtocolError)
//        {
//            response = (HttpWebResponse)webException.Response;
//        }
//        if (response == null)
//        {
//            Exception convertedException = ConvertWebException(webException, request, abortReason);
//            if (convertedException != null)
//            {
//                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(convertedException);
//            }
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new CommunicationException(webException.Message,
//                webException));
//        }
//        if (response.StatusCode == HttpStatusCode.NotFound)
//        {
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new EndpointNotFoundException(SR.GetString(SR.EndpointNotFound, request.RequestUri.AbsoluteUri), webException));
//        }
//        if (response.StatusCode == HttpStatusCode.ServiceUnavailable)
//        {
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ServerTooBusyException(SR.GetString(SR.HttpServerTooBusy, request.RequestUri.AbsoluteUri), webException));
//        }
//        if (response.StatusCode == HttpStatusCode.UnsupportedMediaType)
//        {
//            string statusDescription = response.StatusDescription;
//            if (!string.IsNullOrEmpty(statusDescription))
//            {
//                if (string.Compare(statusDescription, HttpChannelUtilities.StatusDescriptionStrings.HttpContentTypeMissing, StringComparison.OrdinalIgnoreCase) == 0)
//                {
//                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ProtocolException(SR.GetString(SR.MissingContentType, request.RequestUri), webException));
//                }
//            }
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ProtocolException(SR.GetString(SR.FramingContentTypeMismatch, request.ContentType, request.RequestUri), webException));
//        }
//        if (response.StatusCode == HttpStatusCode.GatewayTimeout)
//        {
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new TimeoutException(webException.Message, webException));
//        }
//        // if http.sys has a request queue on the TCP port, then if the path fails to match it will send
//        // back "<h1>Bad Request (Invalid Hostname)</h1>" in the body of a 400 response.
//        // See code at \\index1\sddnsrv\net\http\sys\httprcv.c for details
//        if (response.StatusCode == HttpStatusCode.BadRequest)
//        {
//            const string httpSysRequestQueueNotFound = "<h1>Bad Request (Invalid Hostname)</h1>";
//            const string httpSysRequestQueueNotFoundVista = "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\"\"http://www.w3.org/TR/html4/strict.dtd\">\r\n<HTML><HEAD><TITLE>Bad Request</TITLE>\r\n<META HTTP-EQUIV=\"Content-Type\" Content=\"text/html; charset=us-ascii\"></HEAD>\r\n<BODY><h2>Bad Request - Invalid Hostname</h2>\r\n<hr><p>HTTP Error 400. The request hostname is invalid.</p>\r\n</BODY></HTML>\r\n";
//            string notFoundTestString = null;
//            if (response.ContentLength == httpSysRequestQueueNotFound.Length)
//            {
//                notFoundTestString = httpSysRequestQueueNotFound;
//            }
//            else if (response.ContentLength == httpSysRequestQueueNotFoundVista.Length)
//            {
//                notFoundTestString = httpSysRequestQueueNotFoundVista;
//            }
//            if (notFoundTestString != null)
//            {
//                Stream responseStream = response.GetResponseStream();
//                byte[] responseBytes = new byte[notFoundTestString.Length];
//                int bytesRead = responseStream.Read(responseBytes, 0, responseBytes.Length);
//                // since the response is buffered by System.Net (it's an error response), we should have read
//                // the amount we were expecting
//                if (bytesRead == notFoundTestString.Length
//                    && notFoundTestString == UTF8Encoding.ASCII.GetString(responseBytes))
//                {
//                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new EndpointNotFoundException(SR.GetString(SR.EndpointNotFound, request.RequestUri.AbsoluteUri), webException));
//                }
//            }
//        }
//        return response;
//    }
//    public static Exception ConvertWebException(WebException webException, HttpWebRequest request, HttpAbortReason abortReason)
//    {
//        switch (webException.Status)
//        {
//            case WebExceptionStatus.ConnectFailure:
//            case WebExceptionStatus.NameResolutionFailure:
//            case WebExceptionStatus.ProxyNameResolutionFailure:
//                return new EndpointNotFoundException(SR.GetString(SR.EndpointNotFound, request.RequestUri.AbsoluteUri), webException);
//            case WebExceptionStatus.SecureChannelFailure:
//                return new SecurityNegotiationException(SR.GetString(SR.SecureChannelFailure, request.RequestUri.Authority), webException);
//            case WebExceptionStatus.TrustFailure:
//                return new SecurityNegotiationException(SR.GetString(SR.TrustFailure, request.RequestUri.Authority), webException);
//            case WebExceptionStatus.Timeout:
//                return new TimeoutException(CreateRequestTimedOutMessage(request), webException);
//            case WebExceptionStatus.ReceiveFailure:
//                return new CommunicationException(SR.GetString(SR.HttpReceiveFailure, request.RequestUri), webException);
//            case WebExceptionStatus.SendFailure:
//                return new CommunicationException(SR.GetString(SR.HttpSendFailure, request.RequestUri), webException);
//            case WebExceptionStatus.RequestCanceled:
//                return CreateRequestCanceledException(webException, request, abortReason);
//            case WebExceptionStatus.ProtocolError:
//                HttpWebResponse response = (HttpWebResponse)webException.Response;
//                Fx.Assert(response != null, "'response' MUST NOT be NULL for WebExceptionStatus=='ProtocolError'.");
//                if (response.StatusCode == HttpStatusCode.InternalServerError &&
//                    string.Compare(response.StatusDescription, HttpChannelUtilities.StatusDescriptionStrings.HttpStatusServiceActivationException, StringComparison.OrdinalIgnoreCase) == 0)
//                {
//                    return new ServiceActivationException(SR.GetString(SR.Hosting_ServiceActivationFailed, request.RequestUri));
//                }
//                else
//                {
//                    return null;
//                }
//            default:
//                return null;
//        }
//    }
//    public static Exception CreateResponseIOException(IOException ioException, TimeSpan receiveTimeout)
//    {
//        if (ioException.InnerException is SocketException)
//        {
//            return SocketConnection.ConvertTransferException((SocketException)ioException.InnerException, receiveTimeout, ioException);
//        }
//        return new CommunicationException(SR.GetString(SR.HttpTransferError, ioException.Message), ioException);
//    }
//    public static Exception CreateResponseWebException(WebException webException, HttpWebResponse response)
//    {
//        switch (webException.Status)
//        {
//            case WebExceptionStatus.RequestCanceled:
//                return TraceResponseException(new CommunicationObjectAbortedException(SR.GetString(SR.HttpRequestAborted, response.ResponseUri), webException));
//            case WebExceptionStatus.ConnectionClosed:
//                return TraceResponseException(new CommunicationException(webException.Message, webException));
//            case WebExceptionStatus.Timeout:
//                return TraceResponseException(new TimeoutException(SR.GetString(SR.HttpResponseTimedOut, response.ResponseUri,
//                    TimeSpan.FromMilliseconds(response.GetResponseStream().ReadTimeout)), webException));
//            default:
//                return CreateUnexpectedResponseException(webException, response);
//        }
//    }
//    public static Exception CreateRequestCanceledException(Exception webException, HttpWebRequest request, HttpAbortReason abortReason)
//    {
//        switch (abortReason)
//        {
//            case HttpAbortReason.Aborted:
//                return new CommunicationObjectAbortedException(SR.GetString(SR.HttpRequestAborted, request.RequestUri), webException);
//            case HttpAbortReason.TimedOut:
//                return new TimeoutException(CreateRequestTimedOutMessage(request), webException);
//            default:
//                return new CommunicationException(SR.GetString(SR.HttpTransferError, webException.Message), webException);
//        }
//    }
//    public static Exception CreateRequestIOException(IOException ioException, HttpWebRequest request)
//    {
//        return CreateRequestIOException(ioException, request, null);
//    }
//    public static Exception CreateRequestIOException(IOException ioException, HttpWebRequest request, Exception originalException)
//    {
//        Exception exception = originalException == null ? ioException : originalException;
//        if (ioException.InnerException is SocketException)
//        {
//            return SocketConnection.ConvertTransferException((SocketException)ioException.InnerException, TimeSpan.FromMilliseconds(request.Timeout), exception);
//        }
//        return new CommunicationException(SR.GetString(SR.HttpTransferError, exception.Message), exception);
//    }
//    static string CreateRequestTimedOutMessage(HttpWebRequest request)
//    {
//        return SR.GetString(SR.HttpRequestTimedOut, request.RequestUri, TimeSpan.FromMilliseconds(request.Timeout));
//    }
//    public static Exception CreateRequestWebException(WebException webException, HttpWebRequest request, HttpAbortReason abortReason)
//    {
//        Exception convertedException = ConvertWebException(webException, request, abortReason);
//        if (webException.Response != null)
//        {
//            //free the connection for use by another request
//            webException.Response.Close();
//        }
//        if (convertedException != null)
//        {
//            return convertedException;
//        }
//        if (webException.InnerException is IOException)
//        {
//            return CreateRequestIOException((IOException)webException.InnerException, request, webException);
//        }
//        if (webException.InnerException is SocketException)
//        {
//            return SocketConnectionInitiator.ConvertConnectException((SocketException)webException.InnerException, request.RequestUri, TimeSpan.MaxValue, webException);
//        }
//        return new EndpointNotFoundException(SR.GetString(SR.EndpointNotFound, request.RequestUri.AbsoluteUri), webException);
//    }
//    static Exception CreateUnexpectedResponseException(WebException responseException, HttpWebResponse response)
//    {
//        string statusDescription = response.StatusDescription;
//        if (string.IsNullOrEmpty(statusDescription))
//            statusDescription = response.StatusCode.ToString();
//        return TraceResponseException(
//            new ProtocolException(SR.GetString(SR.UnexpectedHttpResponseCode,
//            (int)response.StatusCode, statusDescription), responseException));
//    }
//    public static Exception CreateNullReferenceResponseException(NullReferenceException nullReferenceException)
//    {
//        return TraceResponseException(
//            new ProtocolException(SR.GetString(SR.NullReferenceOnHttpResponse), nullReferenceException));
//    }
//    static string GetResponseStreamString(HttpWebResponse webResponse, out int bytesRead)
//    {
//        Stream responseStream = webResponse.GetResponseStream();
//        long bufferSize = webResponse.ContentLength;
//        if (bufferSize < 0 || bufferSize > ResponseStreamExcerptSize)
//        {
//            bufferSize = ResponseStreamExcerptSize;
//        }
//        byte[] responseBuffer = DiagnosticUtility.Utility.AllocateByteArray(checked((int)bufferSize));
//        bytesRead = responseStream.Read(responseBuffer, 0, (int)bufferSize);
//        responseStream.Close();
//        return System.Text.Encoding.UTF8.GetString(responseBuffer, 0, bytesRead);
//    }
//    static Exception TraceResponseException(Exception exception)
//    {
//        if (DiagnosticUtility.ShouldTraceError)
//        {
//            TraceUtility.TraceEvent(TraceEventType.Error, TraceCode.HttpChannelUnexpectedResponse, SR.GetString(SR.TraceCodeHttpChannelUnexpectedResponse), (object)null, exception);
//        }
//        return exception;
//    }
//    static bool ValidateEmptyContent(HttpWebResponse response)
//    {
//        bool responseIsEmpty = true;
//        if (response.ContentLength > 0)
//        {
//            responseIsEmpty = false;
//        }
//        else if (response.ContentLength == -1) // chunked 
//        {
//            Stream responseStream = response.GetResponseStream();
//            byte[] testBuffer = new byte[1];
//            responseIsEmpty = (responseStream.Read(testBuffer, 0, 1) != 1);
//        }
//        return responseIsEmpty;
//    }
//    static void ValidateAuthentication(HttpWebRequest request, HttpWebResponse response,
//        WebException responseException, HttpChannelFactory<IRequestChannel> factory)
//    {
//        if (response.StatusCode == HttpStatusCode.Unauthorized)
//        {
//            string message = SR.GetString(SR.HttpAuthorizationFailed, factory.AuthenticationScheme,
//                response.Headers[HttpResponseHeader.WwwAuthenticate]);
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
//                TraceResponseException(new MessageSecurityException(message, responseException)));
//        }
//        if (response.StatusCode == HttpStatusCode.Forbidden)
//        {
//            string message = SR.GetString(SR.HttpAuthorizationForbidden, factory.AuthenticationScheme);
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
//                TraceResponseException(new MessageSecurityException(message, responseException)));
//        }
//        if ((request.AuthenticationLevel == AuthenticationLevel.MutualAuthRequired) &&
//            !response.IsMutuallyAuthenticated)
//        {
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
//                TraceResponseException(new SecurityNegotiationException(SR.GetString(SR.HttpMutualAuthNotSatisfied),
//                responseException)));
//        }
//    }
//    public static void ValidateDigestCredential(ref NetworkCredential credential, TokenImpersonationLevel impersonationLevel)
//    {
//        // this is a work-around to VSWhidbey#470545 (Since the service always uses Impersonation,
//        // we mitigate EOP by preemptively not allowing Identification)
//        if (!SecurityUtils.IsDefaultNetworkCredential(credential))
//        {
//            // With a non-default credential, Digest will not honor a client impersonation constraint of 
//            // TokenImpersonationLevel.Identification.
//            if (!TokenImpersonationLevelHelper.IsGreaterOrEqual(impersonationLevel,
//                TokenImpersonationLevel.Impersonation))
//            {
//                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.GetString(
//                    SR.DigestExplicitCredsImpersonationLevel, impersonationLevel)));
//            }
//        }
//    }
//    // only valid response codes are 500 (if it's a fault) or 200 (iff it's a response message)
//    public static HttpInput ValidateRequestReplyResponse(HttpWebRequest request, HttpWebResponse response,
//        HttpChannelFactory<IRequestChannel> factory, WebException responseException, ChannelBinding channelBinding)
//    {
//        ValidateAuthentication(request, response, responseException, factory);
//        HttpInput httpInput = null;
//        // We will close the HttpWebResponse if we got an error code betwen 200 and 300 and 
//        // 1) an exception was thrown out or 
//        // 2) it's an empty message and we are using SOAP.
//        // For responses with status code above 300, System.Net will close the underlying connection so we don't need to worry about that.
//        if ((200 <= (int)response.StatusCode && (int)response.StatusCode < 300) || response.StatusCode == HttpStatusCode.InternalServerError)
//        {
//            if (response.StatusCode == HttpStatusCode.InternalServerError
//                && string.Compare(response.StatusDescription, HttpChannelUtilities.StatusDescriptionStrings.HttpStatusServiceActivationException, StringComparison.OrdinalIgnoreCase) == 0)
//            {
//                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ServiceActivationException(SR.GetString(SR.Hosting_ServiceActivationFailed, request.RequestUri)));
//            }
//            else
//            {
//                bool throwing = true;
//                try
//                {
//                    if (string.IsNullOrEmpty(response.ContentType))
//                    {
//                        if (!ValidateEmptyContent(response))
//                        {
//                            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(TraceResponseException(
//                                new ProtocolException(
//                                    SR.GetString(SR.HttpContentTypeHeaderRequired),
//                                    responseException)));
//                        }
//                    }
//                    else if (response.ContentLength != 0)
//                    {
//                        MessageEncoder encoder = factory.MessageEncoderFactory.Encoder;
//                        if (!encoder.IsContentTypeSupported(response.ContentType))
//                        {
//                            int bytesRead;
//                            String responseExcerpt = GetResponseStreamString(response, out bytesRead);
//                            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(TraceResponseException(
//                                new ProtocolException(
//                                    SR.GetString(
//                                        SR.ResponseContentTypeMismatch,
//                                        response.ContentType,
//                                        encoder.ContentType,
//                                        bytesRead,
//                                        responseExcerpt), responseException)));
//                        }
//                        httpInput = HttpInput.CreateHttpInput(response, factory, channelBinding);
//                        httpInput.WebException = responseException;
//                    }
//                    throwing = false;
//                }
//                finally
//                {
//                    if (throwing)
//                    {
//                        response.Close();
//                    }
//                }
//            }
//            if (httpInput == null)
//            {
//                if (factory.MessageEncoderFactory.MessageVersion == MessageVersion.None)
//                {
//                    httpInput = HttpInput.CreateHttpInput(response, factory, channelBinding);
//                    httpInput.WebException = responseException;
//                }
//                else
//                {
//                    // In this case, we got a response with
//                    // 1) status code between 200 and 300
//                    // 2) Non-empty Content Type string
//                    // 3) Zero content length
//                    // Since we are trying to use SOAP here, the message seems to be malicious and we should
//                    // just close the response directly.
//                    response.Close();
//                }
//            }
//        }
//        else
//        {
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(CreateUnexpectedResponseException(responseException, response));
//        }
//        return httpInput;
//    }
//abstract class HttpDelayedAcceptStream : DetectEofStream
//{
//    HttpOutput httpOutput;
//    bool isHttpOutputClosed;
//    /// <summary>
//    /// Indicates whether the HttpOutput should be closed when this stream is closed. In the streamed case, 
//    /// we�ll leave the HttpOutput opened (and it will be closed by the HttpRequestContext, so we won't leak it).
//    /// </summary>
//    bool closeHttpOutput;
//    // sometimes we can't flush the HTTP output until we're done reading the end of the 
//    // incoming stream of the HTTP input
//    protected HttpDelayedAcceptStream(Stream stream)
//        : base(stream)
//    {
//    }
//    public bool EnableDelayedAccept(HttpOutput output, bool closeHttpOutput)
//    {
//        if (IsAtEof)
//        {
//            return false;
//        }
//        this.closeHttpOutput = closeHttpOutput;
//        this.httpOutput = output;
//        return true;
//    }
//    protected override void OnReceivedEof()
//    {
//        if (this.closeHttpOutput)
//        {
//            CloseHttpOutput();
//        }
//    }
//    public override void Close()
//    {
//        if (this.closeHttpOutput)
//        {
//            CloseHttpOutput();
//        }
//        base.Close();
//    }
//    void CloseHttpOutput()
//    {
//        if (this.httpOutput != null && !this.isHttpOutputClosed)
//        {
//            this.httpOutput.Close();
//            this.isHttpOutputClosed = true;
//        }
//    }
//}
//abstract class BytesReadPositionStream : DelegatingStream
//{
//    int bytesSent = 0;
//    protected BytesReadPositionStream(Stream stream)
//        : base(stream)
//    {
//    }
//    public override long Position
//    {
//        get
//        {
//            return bytesSent;
//        }
//        set
//        {
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException(SR.GetString(SR.SeekNotSupported)));
//        }
//    }
//    public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
//    {
//        this.bytesSent += count;
//        return BaseStream.BeginWrite(buffer, offset, count, callback, state);
//    }
//    public override void Write(byte[] buffer, int offset, int count)
//    {
//        BaseStream.Write(buffer, offset, count);
//        this.bytesSent += count;
//    }
//    public override void WriteByte(byte value)
//    {
//        BaseStream.WriteByte(value);
//        this.bytesSent++;
//    }
//}
//class HttpRequestMessageHttpInput : HttpInput, HttpRequestMessageProperty.IHttpHeaderProvider
//{
//    const string SoapAction = "SOAPAction";
//    HttpRequestMessage httpRequestMessage;
//    ChannelBinding channelBinding;
//    public HttpRequestMessageHttpInput(HttpRequestMessage httpRequestMessage, IHttpTransportFactorySettings settings, bool enableChannelBinding, ChannelBinding channelBinding)
//        : base(settings, true, enableChannelBinding)
//    {
//        this.httpRequestMessage = httpRequestMessage;
//        this.channelBinding = channelBinding;
//    }
//    public override long ContentLength
//    {
//        get
//        {
//            if (this.httpRequestMessage.Content.Headers.ContentLength == null)
//            {
//                // Chunked transfer mode
//                return -1;
//            }
//            return this.httpRequestMessage.Content.Headers.ContentLength.Value;
//        }
//    }
//    protected override ChannelBinding ChannelBinding
//    {
//        get
//        {
//            return this.channelBinding;
//        }
//    }
//    public HttpRequestMessage HttpRequestMessage
//    {
//        get { return this.httpRequestMessage; }
//    }
//    protected override bool HasContent
//    {
//        get
//        {
//            // In Chunked transfer mode, the ContentLength header is null
//            // Otherwise we just rely on the ContentLength header
//            return this.httpRequestMessage.Content.Headers.ContentLength == null || this.httpRequestMessage.Content.Headers.ContentLength.Value > 0;
//        }
//    }
//    protected override string ContentTypeCore
//    {
//        get
//        {
//            if (!this.HasContent)
//            {
//                return null;
//            }
//            return this.httpRequestMessage.Content.Headers.ContentType == null ? null : this.httpRequestMessage.Content.Headers.ContentType.MediaType;
//        }
//    }
//    public override void ConfigureHttpRequestMessage(HttpRequestMessage message)
//    {
//        throw FxTrace.Exception.AsError(new InvalidOperationException());
//    }
//    protected override Stream GetInputStream()
//    {
//        if (this.httpRequestMessage.Content == null)
//        {
//            return Stream.Null;
//        }
//        return this.httpRequestMessage.Content.ReadAsStreamAsync().Result;
//    }
//    protected override void AddProperties(Message message)
//    {
//        HttpRequestMessageProperty requestProperty = new HttpRequestMessageProperty(this.httpRequestMessage);
//        message.Properties.Add(HttpRequestMessageProperty.Name, requestProperty);
//        message.Properties.Via = this.httpRequestMessage.RequestUri;
//        foreach (KeyValuePair<string, object> property in this.httpRequestMessage.Properties)
//        {
//            message.Properties.Add(property.Key, property.Value);
//        }
//        this.httpRequestMessage.Properties.Clear();
//    }
//    protected override string SoapActionHeader
//    {
//        get
//        {
//            IEnumerable<string> values;
//            if (this.httpRequestMessage.Headers.TryGetValues(SoapAction, out values))
//            {
//                foreach (string headerValue in values)
//                {
//                    return headerValue;
//                }
//            }
//            return null;
//        }
//    }
//    public void CopyHeaders(WebHeaderCollection headers)
//    {
//        // No special-casing for the "WWW-Authenticate" header required here,
//        // because this method is only called for the incoming request
//        // and the WWW-Authenticate header is a header only applied to responses.
//        HttpChannelUtilities.CopyHeaders(this.httpRequestMessage, headers.Add);
//    }
//    internal void SetHttpRequestMessage(HttpRequestMessage httpRequestMessage)
//    {
//        Fx.Assert(httpRequestMessage != null, "httpRequestMessage should not be null.");
//        this.httpRequestMessage = httpRequestMessage;
//    }
//}
//EventTraceActivity eventTraceActivity;
//ServerWebSocketTransportDuplexSessionChannel webSocketChannel;
//internal ServerWebSocketTransportDuplexSessionChannel WebSocketChannel
//{
//    get
//    {
//        return this.webSocketChannel;
//    }
//    set
//    {
//        Fx.Assert(this.webSocketChannel == null, "webSocketChannel should not be set twice.");
//        this.webSocketChannel = value;
//    }
//}
//internal EventTraceActivity EventTraceActivity
//{
//    get
//    {
//        return this.eventTraceActivity;
//    }
//}
// Note: This method will return null in the case where throwOnError is false, and a non-fatal error occurs.
// Please exercise caution when passing in throwOnError = false.  This should basically only be done in error
// code paths, or code paths where there is very good reason that you would not want this method to throw.
// When passing in throwOnError = false, please handle the case where this method returns null.
// null means we're done
// A null message means either a one-way request or that the service operation returned null and
// hence we can close the HttpOutput. By default we keep the HttpOutput open to allow the writing to the output 
// even after the HttpInput EOF is received and the HttpOutput will be closed only on close of the HttpRequestContext.
// byte[] webSocketInternalBuffer;
// TODO: Enable KeepAlive setting
//if (!_httpBindingElement.KeepAlive)
//{
//    aspNetContext.Response.Headers["Connection"] = "close";
//}
// TODO: Wire up authentication for ASP.Net Core
//return Listener.ProcessAuthentication(listenerContext);
// TODO: Wire up authentication for ASP.Net Core
//return Listener.ValidateAuthentication(listenerContext);
//try
//{
//    // TODO: Work out how to close the HttpContext
//    // Most likely will be some mechanism to complete the Task returned by the RequestDelegate
//    aspNetContext.Response.Close();
//}
//catch (HttpListenerException listenerException)
//{
//    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(
//        HttpChannelUtilities.CreateCommunicationException(listenerException));
//}
// accessing the header in System.Net involves a native transition
// TODO: ChannelBindingSupport
/* ChannelBindingSupportEnabled */) 
// TODO: Look into useing PipeReader with look-ahead
// TODO: Switch to nullable
// TODO: ChannelBindingToken
// return ChannelBindingUtility.GetToken(this.listenerHttpContext.listenerContext.Request.TransportContext);
// TODO: Uri.Query always includes the '?', check if the same is true for ASP.NET Core
// TODO: Test the Via code
//",
// null means use description from status code
//HttpAnonymousUriPrefixMatcher _anonymousUriPrefixMatcher;
// [System.ComponentModel.DefaultValueAttribute(false)]
// public bool AllowCookies { get { return default(bool); } set { } }
// [System.ComponentModel.DefaultValueAttribute((System.Net.AuthenticationSchemes)(32768))]
// public System.Net.AuthenticationSchemes AuthenticationScheme { get { return default(System.Net.AuthenticationSchemes); } set { } }
// [System.ComponentModel.DefaultValueAttribute((System.ServiceModel.TransferMode)(0))]
// public System.ServiceModel.Channels.WebSocketTransportSettings WebSocketSettings { get { return default(System.ServiceModel.Channels.WebSocketTransportSettings); } set { } }
//if (typeof(T) == typeof(ISecurityCapabilities))
//{
//    AuthenticationSchemes effectiveAuthenticationSchemes = HttpTransportBindingElement.GetEffectiveAuthenticationSchemes(this.AuthenticationScheme,
//        context.BindingParameters);
//    return (T)(object)new SecurityCapabilities(this.GetSupportsClientAuthenticationImpl(effectiveAuthenticationSchemes),
//        effectiveAuthenticationSchemes == AuthenticationSchemes.Negotiate,
//        this.GetSupportsClientWindowsIdentityImpl(effectiveAuthenticationSchemes),
//        ProtectionLevel.None,
//        ProtectionLevel.None);
//}
//else if (typeof(T) == typeof(IBindingDeliveryCapabilities))
//{
//    return (T)(object)new BindingDeliveryCapabilitiesHelper();
//}
/*else*/ if (typeof(T) == typeof(TransferMode))
//else if (typeof(T) == typeof(ExtendedProtectionPolicy))
//{
//    return (T)(object)this.ExtendedProtectionPolicy;
//}
//else if (typeof(T) == typeof(IAnonymousUriPrefixMatcher))
//{
//    if (_anonymousUriPrefixMatcher == null)
//    {
//        _anonymousUriPrefixMatcher = new HttpAnonymousUriPrefixMatcher();
//    }
//    return (T)(object)_anonymousUriPrefixMatcher;
//}
//else if (typeof(T) == typeof(ITransportCompressionSupport))
//{
//    return (T)(object)new TransportCompressionSupportHelper();
//}
// This type allows the use of a generally typed HttpHeaders property on Http{Request|Response}MessageProperty
// TODO: Should we throw? Ignore?
// Not an HTTP(S) dispatcher
// TODO: Might not be necessary to compare paths
// Dispatcher address is based on server listening address;
// TODO: Work out how TraceUtility fits in with all the other exception and tracing classes
// If the message is closed, we won't get an activity
//Guid activityId = TraceUtility.ExtractActivityId(message);
//if (DiagnosticUtility.ShouldTraceError)
//{
//    DiagnosticUtility.DiagnosticTrace.TraceEvent(TraceEventType.Error, TraceCode.ThrowingException, GenerateMsdnTraceCode(TraceCode.ThrowingException),
//        TraceSR.Format(TraceSR.ThrowingException), null, exception, activityId, null);
//}
//if (DiagnosticUtility.ShouldTraceError)
//{
//    DiagnosticUtility.DiagnosticTrace.TraceEvent(TraceEventType.Error, TraceCode.ThrowingException, GenerateMsdnTraceCode(TraceCode.ThrowingException),
//        TraceSR.Format(TraceSR.ThrowingException), null, exception, activityId, source);
//}
//if (DiagnosticUtility.ShouldTraceWarning)
//{
//    StringTraceRecord record = new StringTraceRecord("Comment",
//        SR.Format(SR.SFxUserCodeThrewException, method.DeclaringType.FullName, method.Name));
//    DiagnosticUtility.DiagnosticTrace.TraceEvent(TraceEventType.Warning,
//        TraceCode.UnhandledExceptionInUserOperation, GenerateMsdnTraceCode(TraceCode.UnhandledExceptionInUserOperation),
//        SR.Format(SR.TraceCodeUnhandledExceptionInUserOperation, method.DeclaringType.FullName, method.Name),
//        record,
//        e, null);
//}
//if (DiagnosticUtility.ShouldTraceInformation)
//{
//    EndpointAddress endpointAddress = null;
//    if (dispatcher != null)
//    {
//        endpointAddress = dispatcher.EndpointAddress;
//    }
//    TraceUtility.TraceEvent(TraceEventType.Information, TraceCode.DroppedAMessage,
//        SR.Format(SR.TraceCodeDroppedAMessage), new MessageDroppedTraceRecord(message, endpointAddress));
//}
// go through the string's chars collapsing %XX and %uXXXX and
// appending each char as char, with exception of %XX constructs
// that are appended as bytes
// valid 4 hex chars
// only add as char
// valid 2 hex chars
// don't add as char
// 7 bit have to go as bytes because of Unicode
// Private helpers for URL encoding/decoding
// Internal class to facilitate URL decoding -- keeps char buffer and byte buffer, allows appending of either chars or bytes
// Accumulate characters in a special array
// Accumulate bytes for decoding into characters in a special array
// Encoding to convert chars to bytes
// byte buffer created on demand
// if there are no pending bytes treat 7 bit bytes as characters
// this optimization is temp disable as it doesn't work for some encodings
//if (_numBytes == 0 && ((b & 0x80) == 0)) {
//    AddChar((char)b);
//}
//else
//: base(traceSourceName)
//            try
//            {
//                this.TraceSourceName = traceSourceName;
//                this.EventSourceName = string.Concat(this.TraceSourceName, " ", EventSourceVersion);
//                CreateTraceSource();
//            }
//            catch (Exception exception)
//            {
//                if (Fx.IsFatal(exception))
//                {
//                    throw;
//                }
//#pragma warning disable 618
//                EventLogger logger = new EventLogger(this.EventSourceName, null);
//                logger.LogEvent(TraceEventType.Error, TracingEventLogCategory, (uint)System.Runtime.Diagnostics.EventLogEventId.FailedToSetupTracing, false,
//                    exception.ToString());
//#pragma warning restore 618
//            }
//            try
//            {
//                CreateEtwProvider(etwProviderId);
//            }
//            catch (Exception exception)
//            {
//                if (Fx.IsFatal(exception))
//                {
//                    throw;
//                }
//                this.etwProvider = null;
//#pragma warning disable 618
//                EventLogger logger = new EventLogger(this.EventSourceName, null);
//                logger.LogEvent(TraceEventType.Error, TracingEventLogCategory, (uint)System.Runtime.Diagnostics.EventLogEventId.FailedToSetupTracing, false,
//                    exception.ToString());
//#pragma warning restore 618
//            }
//            if (this.TracingEnabled || this.EtwTracingEnabled)
//            {
//#pragma warning disable 618
//                this.AddDomainEventHandlersForCleanup();
//#pragma warning restore 618
//            }
//localhost:8080/BasicWcfService/basichttp.svc")));
// This method gets called by the runtime. Use this method to add services to the container.
// For more information on how to configure your application, visit https://go.microsoft.com/fwlink/?LinkID=398940
// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
//tempuri.org/";
//tempuri.org/", Name = "IEchoService")]
//tempuri.org/";
// DEBUGW
//localhost:8080")
//tempuri.org/";
// TODO: Make this generic shared code used by multiple assemblies
//exceptionUtility = new ExceptionUtility("System.ServiceModel", "System.ServiceModel 4.0.0.0", (object)DiagnosticUtility.diagnosticTrace, (object)FxTrace.Exception);
//FxTrace.Exception.TraceHandledException(exception, traceEventType);
//if ((_diagnosticTrace == null ? 0 : (_diagnosticTrace.ShouldTrace(eventType) ? 1 : 0)) != 0)
//{
//    using (
//        ExceptionUtility.useStaticActivityId
//            ? Activity.CreateActivity(ExceptionUtility.activityId)
//            : (Activity)null)
//        _diagnosticTrace.TraceEvent(eventType, 131075,
//            LegacyDiagnosticTrace.GenerateMsdnTraceCode("System.ServiceModel.Diagnostics",
//                "ThrowingException"), TraceSR.Format("ThrowingException"), extendedData, exception,
//            (object)null);
//    IDictionary data = exception.Data;
//    if (data != null && !data.IsReadOnly && !data.IsFixedSize)
//    {
//        object obj =
//            data[(object)"System.ServiceModel.Diagnostics.ExceptionUtility.ExceptionStackAsString"];
//        string str1 = obj == null ? "" : obj as string;
//        if (str1 != null)
//        {
//            string stackTrace = exception.StackTrace;
//            if (!string.IsNullOrEmpty(stackTrace))
//            {
//                string str2 = str1 + (str1.Length == 0 ? "" : Environment.NewLine) + "throw" +
//                              Environment.NewLine + stackTrace + Environment.NewLine + "catch" +
//                              Environment.NewLine;
//                data[(object)"System.ServiceModel.Diagnostics.ExceptionUtility.ExceptionStackAsString"]
//                    = (object)str2;
//            }
//        }
//    }
//}
//this.exceptionTrace.TraceEtwException(exception, eventType);
//Microsoft.Runtime.Diagnostics.EventLogger logger = null;
//try
//{
//    logger = new Microsoft.Runtime.Diagnostics.EventLogger(this.eventSourceName, this.diagnosticTrace);
//}
//finally
//{
//    TraceFailFast(message, logger);
//}
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
// ------------------------------------------------------------------------------
// private BindingElements
//TODO: Work out if we want IBindingRuntimePreferences. Probably not as we're aiming for 100% async here
//bool IBindingRuntimePreferences.ReceiveSynchronously
//{
//    get { return false; }
//}
// Message.ClientCredentialType = Certificate, IssuedToken or Windows are not supported.
// return collection of BindingElements
// order of BindingElements is important
// add encoding
// add transport security
// TODO: Add ExtendedProtectionPolicy
// add transport (tcp)
//return this.transportSecurity.CreateTransportProtectionOnly();
//internal static TimeSpan ServiceHostCloseTimeout { get { return TimeSpanHelper.FromSeconds(10, ServiceHostCloseTimeoutString); } }
//internal static TimeSpan ServiceHostCloseTimeout => TimeSpan.FromSeconds(10);
//internal const string ServiceHostCloseTimeoutString = "00:00:10";
//internal static TimeSpan CloseTimeout { get { return TimeSpanHelper.FromMinutes(1, CloseTimeoutString); } }
//internal static TimeSpan OpenTimeout { get { return TimeSpanHelper.FromMinutes(1, OpenTimeoutString); } }
//internal static TimeSpan ReceiveTimeout { get { return TimeSpanHelper.FromMinutes(10, ReceiveTimeoutString); } }
//internal static TimeSpan SendTimeout { get { return TimeSpanHelper.FromMinutes(1, SendTimeoutString); } }
//internal static TimeSpan TransactionTimeout { get { return TimeSpanHelper.FromMinutes(1, TransactionTimeoutString); } }
//internal const string TransactionTimeoutString = "00:00:00";
// If the message is closed, we won't get an activity
//Guid activityId = TraceUtility.ExtractActivityId(message);
//if (DiagnosticUtility.ShouldTraceError)
//{
//    DiagnosticUtility.DiagnosticTrace.TraceEvent(TraceEventType.Error, TraceCode.ThrowingException, GenerateMsdnTraceCode(TraceCode.ThrowingException),
//        TraceSR.Format(TraceSR.ThrowingException), null, exception, activityId, null);
//}
// TODO: Consider moving to primitives
// used by MEX to ensure that we don't conflict on base-address scoped settings
//if (DiagnosticUtility.ShouldTraceWarning)
//{
//    TraceUtility.TraceEvent(TraceEventType.Warning,
//        TraceCode.ServerMaxPooledConnectionsQuotaReached,
//        SR.GetString(SR.TraceCodeServerMaxPooledConnectionsQuotaReached, maxPooledConnections),
//        new StringTraceRecord("MaxOutboundConnectionsPerEndpoint", maxPooledConnections.ToString(CultureInfo.InvariantCulture)),
//        this, null);
//}
//if (TD.ServerMaxPooledConnectionsQuotaReachedIsEnabled())
//{
//    TD.ServerMaxPooledConnectionsQuotaReached();
//}
// No space left in the connection pool
// Don't consume any bytes. The pending read is to know when a new client connects.
// After pending read is canceled, next ReadAsync can return immediately with a 0 byte response so another ReadAsync call is needed
// Don't consume any bytes. The pending read is to know when a new client connects.
// TODO: Switch to ValueTask as in many scenarios this will be completed before being requested;
// There's a small race here where we could create a TCS and dispatchInvokedTask is set via OnOperationInvoke.
// In this case, we won't use our TCS and it will simply be an unnecessary allocation. As dispatchInvokedTask is
// always set using Interlocked.CompareExchance, we guarantee returning the correct Task;
// Creating with RunContinuationsAsynchronously otherwise the method awaiting the Task will continue executing on
// the thread which calls OnOperationInvoke;
// TODO: Fix timeout value
//if (upgradeAcceptor != null)
//{
//    this.channelBindingProvider = upgrade.GetProperty<IStreamUpgradeChannelBindingProvider>();
//    this.upgradeAcceptor = upgrade.CreateUpgradeAcceptor();
//}
// TODO: Put connection back into the beginning of the middleware stack
//    IConnection localConnection = null;
//    if (this.sessionReader != null)
//    {
//        lock (ThisLock)
//        {
//            localConnection = this.sessionReader.GetRawConnection();
//        }
//    }
//    if (localConnection != null)
//    {
//        if (abort)
//        {
//            localConnection.Abort();
//        }
//        else
//        {
//            this.connectionDemuxer.ReuseConnection(localConnection, timeout);
//        }
//        this.connectionDemuxer = null;
//    }
// NOOP
// empty
// TODO: Fix the timeout value reported
// check again in case the previous send faulted while we were waiting for the lock
// we're synchronized by sendLock here
// used to return cached connection to the pool/reader pool
// close input session if necessary
// TODO: Come up with some way to know when the input is closed. Maybe register something on the connection transport or have a Task which gets completed on close
//await EnsureInputClosedAsync(token);
// clean up the CBT after transitioning to the closed state
// TODO: Fix the timeout value reported
// check again in case the previous send faulted while we were waiting for the lock
// cleanup after the framing handshake has completed
// we're all done, release the connection
// TODO: Removed performance enhancement to avoid exposing another internal method.
// Evaluate whether we should do something to bring this back. My thoughts are we 
// remove the SetToHeader method as we should be using the same mechanism as third
// parties transports have to use.
// Original comment and code:
// we don't use to.ApplyTo(message) since it's faster to cache and
// use the actual <To> header then to call message.Headers.To = Uri...
//message.Headers.SetToHeader(toHeader);
// TODO: Fix exception message as a negative timeout wasn't passed, a cancelled token was
// TODO: Fix the timeout value reported
// TODO: Fix the timeout value reported
//string _groupName;
//TimeSpan _leaseTimeout;
//_groupName = ConnectionOrientedTransportDefaults.ConnectionPoolGroupName;
//_leaseTimeout = TcpTransportDefaults.ConnectionLeaseTimeout;
//_groupName = tcp._groupName;
//_leaseTimeout = tcp._leaseTimeout;
//public string GroupName
//{
//    get { return _groupName; }
//    set
//    {
//        if (value == null)
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull("value");
//        _groupName = value;
//    }
//}
//public TimeSpan LeaseTimeout
//{
//    get { return _leaseTimeout; }
//    set
//    {
//        if (value < TimeSpan.Zero)
//        {
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
//                SR.GetString(SR.SFxTimeoutOutOfRange0)));
//        }
//        if (TimeoutHelper.IsTooLarge(value))
//        {
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value", value,
//                SR.GetString(SR.SFxTimeoutOutOfRangeTooBig)));
//        }
//        _leaseTimeout = value;
//    }
//}
//if (_groupName != tcp._groupName)
//    return false;
//if (_leaseTimeout != tcp._leaseTimeout)
//    return false;
// TODO: Decide whether to support DeliveryRequirementsAttribute
//if (typeof(T) == typeof(IBindingDeliveryCapabilities))
//{
//    return (T)(object)new BindingDeliveryCapabilitiesHelper();
//}
// TODO: Support ITransportCompressionSupport
//else if (typeof(T) == typeof(ITransportCompressionSupport))
//{
//    return (T)(object)new TransportCompressionSupportHelper();
//}
// Enforces an overall timeout based on the TimeoutHelper passed in
// Supporting a passed in cancellationToken as well as honoring the timeout token in this class would require
// creating a linked token source on every call which is extra allocation and needs disposal. As this is an 
// internal class, it's okay to add this extra constraint to usage of this method.
// Supporting a passed in cancellationToken as well as honoring the timeout token in this class would require
// creating a linked token source on every call which is extra allocation and needs disposal. As this is an 
// internal class, it's okay to add this extra constraint to usage of this method.
//SspiSecurityTokenProvider.DefaultExtractWindowsGroupClaims;
//internal const bool PortSharingEnabled = false;
//internal const bool TeredoEnabled = false;
// We now know the Via address (which endpoint the client is connecting to).
// The connection now needs to be handled by the correct endpoint which can
// handle upgrades etc.
//exit loop
//if (TD.ReceiveTimeoutIsEnabled())
//{
//    TD.ReceiveTimeout(exception.Message);
//}
//if (TD.ReceiveTimeoutIsEnabled())
//{
//    TD.ReceiveTimeout(exception.Message);
//}
// containment -- all exceptions abort the reader, no additional containment action necessary
// TODO: On .NET Framework, this Abort call via a long winding path of plumbing will trigger a new pending Accept
// as this connection establishment handshake has failed. Some back pressure mechanism needs to be implemented to
// stop extra incoming connection handshakes from being started. Maybe a semaphore which is async waited at initial
// incoming request and then released on completion of handshake or on an exception. It also closes the connection
// so that's all that's happening here for now. Returning and completing the task will cause the connection to be closed.
// else:
//   returning will close the connection if it hasn't already been.
// Closing should be async and should accept a timeout. There are improvements coming in future releases of .NET Core which support this.
//if (TD.ConnectionReaderSendFaultIsEnabled())
//{
//    TD.ConnectionReaderSendFault(faultString);
//}
// Connection will be closed on completion of Task returned from NetMessageFramingConnectionHandler.OnConnectedAsync
// TODO: Consider exception filters to remvoe duplicate code
//if (TD.SendTimeoutIsEnabled())
//{
//    TD.SendTimeout(e.Message);
//}
//if (TD.SendTimeoutIsEnabled())
//{
//    TD.SendTimeout(e.Message);
//}
// make sure we read until EOF or a quota is hit
// TODO: Exception filters?
// TODO: Standardize handling of OperationCanceledException/TimeoutException
//if (TD.SendTimeoutIsEnabled())
//{
//    TD.SendTimeout(e.Message);
//}
//if (TD.SendTimeoutIsEnabled())
//{
//    TD.SendTimeout(e.Message);
//}
// special validation for Preamble Ack for usability purposes (MB#39593)
// TODO: Can the position still be recovered?
/*StreamPosition*/ -1, CurrentStateAsString),
// Pattern: 
//   Done
// see if we need to send back a framing fault
// TODO: Drain the rest of the data and send a fault then close the connection
//byte[] drainBuffer = new byte[128];
//InitialServerConnectionReader.SendFault(
//    Connection, framingFault, drainBuffer, GetRemainingTimeout(),
//    MaxViaSize + MaxContentTypeSize);
//base.Close(GetRemainingTimeout());
// Used for Duplex/Simplex
// Pattern: 
//   Start, 
//   (UpgradeRequest, upgrade-content-type)*, 
//   (EnvelopeStart, ReadingEnvelopeBytes*, EnvelopeEnd)*, 
//   End
// Pattern: 
//   Start, 
//   (UpgradeRequest, upgrade-bytes)*, 
//   EnvelopeStart,
// Pattern: 
//   Start, 
//   EnvelopeStart,
// common set of states used on the client-side.
// used by SimplexEncoder/DuplexEncoder
// used by ServerDuplexEncoder/ServerSimplexEncoder
// Pattern: 
//   ModeBytes, 
//   EncodeStart, 
//   EncodeUpgrade*, 
//   EncodeMessageFrame*, 
//   EndBytes
// Pattern: 
//   ModeBytes, 
//   EncodeStart, 
//   EncodeUpgrade*, 
//   EncodeMessageFrame*, 
//   EndBytes
// shared code for client and server
// Pattern: 
//   ModeBytes, 
//   EncodeStart, 
//   EncodeUpgrade*, 
//   EnvelopeStartBytes,
//   streamed-message-bytes*
// Pattern:
//   (UpgradeResponseBytes, upgrade-bytes)?, 
/*
//schemas.microsoft.com/ws/2006/05/framing";
// Input pipe closed
// see if we need to send back a framing fault
// TODO: Timeouts
/*GetRemainingTimeout()*/,
// Completing the returned Task causes the connection to be closed if needed and cleans everything up.
// Unwrap the connection.
// TODO: Investigate calling Dispose on the wrapping stream to improve cleanup. nb: .NET Framework does not call Dispose.
// connection.ServiceDispatcher is null until later middleware layers are executed.
// On .NET Framework, with the way that AspNetCore closes a connection, it sometimes doesn't send the
// final bytes if those bytes haven't been sent yet. Delaying completeing the connection to compensate.
// AspNetCore 2.1 doesn't close the connection. 2.2+ does so these lines can eventually be removed.
// TODO: Should we throw? Ignore?
// TODO: Limit to specifically TcpTransportBindingElement if net.tcp etc
// TODO: Should we throw? Ignore?
// TODO: Limit NamedPipes to prevent it using SslStreamSecurityUpgradeProvider
/*&& this.SupportsUpgrade(upgradeBindingElements[0])*/)
// ValueTask uses .GetAwaiter().GetResult() if necessary
// https://github.com/dotnet/corefx/blob/f9da3b4af08214764a51b2331f3595ffaf162abe/src/System.Threading.Tasks.Extensions/src/System/Threading/Tasks/ValueTask.cs#L156
// TODO: Uncomment once moved to netstandard2.1+
// public override ValueTask<int> ReadAsync(Memory<byte> destination, CancellationToken cancellationToken = default)
// {
//     return ReadAsyncInternal(destination);
// }
// TODO: Uncomment once moved to netstandard2.1+
//public override async ValueTask WriteAsync(ReadOnlyMemory<byte> source, CancellationToken cancellationToken = default)
//{
//    _output.Write(source.Span);
//    await _output.FlushAsync(cancellationToken);
//}
// buffer.Count is int
// Upon sending the session end byte, the client can start another session immediately.
// We need to stop those bytes from being consumed by the upgrade stream (e.g. NegotiateStream),
// but we can't return a zero byte response to the pending read until after we've sent the session 
// end byte otherwise it will close the upgrade stream and prevent the session end byte from being
// sent. Calling StartUnwrapRead prevents any reads from completing until FinisheUnwrapRead has
// been called. This ensures any client bytes from the next session are not consumed and still
// allows a write to be sent through the wrapping stream.
// first validate our content type
// next read any potential upgrades and finish consuming the preamble
// accept upgrade
//await context.Transport.Output.WriteAsync
//Connection.Write(ServerSessionEncoder.UpgradeResponseBytes, 0, ServerSessionEncoder.UpgradeResponseBytes.Length, true, timeoutHelper.RemainingTime());
// TODO: ChannelBinding
//if (this.channelBindingProvider != null && this.channelBindingProvider.IsChannelBindingSupportEnabled)
//{
//    this.SetChannelBinding(this.channelBindingProvider.GetChannelBinding(this.upgradeAcceptor, ChannelBindingKind.Endpoint));
//}
//this.connectionBuffer = Connection.AsyncReadBuffer;
// Audit Authentication Failure
//WriteAuditFailure(upgradeAcceptor as StreamSecurityUpgradeAcceptor, exception);
// we've finished the preamble. Ack and continue to the next middleware.
// TODO: Send fault response
//SendFault(FramingEncodingString.ContentTypeInvalidFault, ref timeoutHelper);
// TODO: SendFault
//SendFault(FramingEncodingString.UpgradeInvalidFault, ref timeoutHelper);
// TODO: SendFault
//SendFault(FramingEncodingString.UpgradeInvalidFault, ref timeoutHelper);
//WriteAuditFailure(securityUpgradeAcceptor, securityFailedException);
// Audit Authentication Success
//WriteAuditEvent(securityUpgradeAcceptor, AuditLevel.Success, null);
// first validate our content type
//ValidateContentType(connection, decoder);
// next read any potential upgrades and finish consuming the preamble
//change the state so that we don't read/decode until it is safe
// accept upgrade
// This state was used to capture any extra read bytes into PreReadConnection but we don't need to do that when using pipes.
// This extra state transition has been left here to maintain the same state transitions as on .NET Framework to make comparison easier.
// Set input pipe so that the next read will return all the unconsumed bytes.
// If all bytes have already been consumed so the buffer has 0 length, AdvanceTo would throw
// as it's already been called.
//Must be a different state here than UpgradeComplete so that we don't try to read from the connection
//Client is doing more than one upgrade, reset the state
//We have done at least one upgrade, but we are now done.
//no upgrade, just send the preample end bytes
// we've finished the preamble. Ack and return.
//terminal state
// If all bytes have already been consumed so the buffer has 0 length, AdvanceTo would throw
// as it's already been called.
//ok to read/decode before we start the upgrade
//and between UpgradeComplete/WritingPreambleAck
//starting first upgrade
//completing one upgrade and starting another
//no upgrade being used
//upgrades are now complete, end the preamble handshake.
//WriteAuditFailure(securityUpgradeAcceptor, securityFailedException);
// Audit Authentication Success
//WriteAuditEvent(securityUpgradeAcceptor, AuditLevel.Success, null);
// No more messages
// TODO: Create a correctly timing out ct
// We don't await DispatchAsync because in a concurrent service we want to read the next request before the previous
// request has finished.
// TODO: Now there's a channel dispatcher, have that handle negotiateing a Task which completes when it's time to get the next request
// TODO: Apply timeouts
// could have read the END record under DecodeMessage
// pipes will return null
// TODO: Remove synchronous wait. This is needed because the buffer is passed by ref.
// Grab only the number of bytes that we want to copy from the source sequence
// TODO: I think that the receive timeout starts counting at the start of the preamble on .NET Framework. This implementation basically resets the timer
// after the preamble has completed. This probably needs to be addressed otherwise worse case you could end up taking 2X as long to timeout.
// I believe the preamble should really use the OpenTimeout but that's not how this is implemented on .NET Framework.
//EnsureDecoderAtEof(connection);
// we're ready to read a message
//using (ServiceModelActivity activity = DiagnosticUtility.ShouldUseActivity ? ServiceModelActivity.CreateBoundedActivity(true) : null)
//{
//    if (DiagnosticUtility.ShouldUseActivity)
//    {
//        ServiceModelActivity.Start(activity, SR.GetString(SR.ActivityProcessingMessage, TraceUtility.RetrieveMessageNumber()), ActivityType.ProcessMessage);
//    }
// TODO: Make async
//if (DiagnosticUtility.ShouldUseActivity)
//{
//    TraceUtility.TransferFromTransport(message);
//}
//}
// pipes will return null
// TODO: ChannelBindingToken
//if (this.channelBindingToken != null)
//{
//    ChannelBindingMessageProperty property = new ChannelBindingMessageProperty(this.channelBindingToken, false);
//    property.AddTo(message);
//    property.Dispose(); //message.Properties.Add() creates a copy...
//}
// we're at the envelope
// ensures that the reader is notified at end-of-stream, and takes care of the framing chunk headers
// run chunk data through the decoder
// run the current data through the decoder to get valid message bytes
/* NOP */ }
// TODO: Create a ReadByte override which is optimized for that single case
// We're in the middle of a chunk.
// How many bytes to copy into the buffer passed to this method. The read from the input pipe might have read bytes 
// from the next chunk and we're not ready to consume them yet. Also we can't copy more bytes than the passed in buffer.
// When copying a ReadOnlySequence to a Span, they must be the same size so create a temporary
// ReadOnlySequence which has the same number of bytes as we wish to copy.
// keep decoder up to date
// Consume those bytes from our buffer
// TODO: Possible perf improvement would be to call ReadAsync and save the Task<ReadResult> with the presumption that it will
// likely have been completed before the next call to avoid blocking waiting for the Task to complete.
// Create Span of the right size to copy the bytes to.
// Fix up counts
// We are starting a new chunk. Read the size, and loop around again
// If the buffer has been exhausted, advance the input pipe to consume them and release the buffer
//if (atEof)
//{
//    _connection.Input.Complete();
//}
// We're in the middle of a chunk.
// How many bytes to copy into the buffer passed to this method. The read from the input pipe might have read bytes 
// from the next chunk and we're not ready to consume them yet. Also we can't copy more bytes than the passed in buffer.
// When copying a ReadOnlySequence to a Span, they must be the same size so create a temporary
// ReadOnlySequence which has the same number of bytes as we wish to copy.
// keep decoder up to date
// Consume those bytes from our buffer
// If the buffer has been exhausted, advance the input pipe to consume them and release the buffer
// Create an ArraySegment of the right size to copy the bytes to. The synchronous Read method uses a Span<byte> instead, but
// you can't instantiate a Span<T> in an async method but there's an implicit case of ArraySegment to Span.
// Fix up counts
// We are starting a new chunk. Read the size, and loop around again
// We now know the Via address (which endpoint the client is connecting to).
// The connection now needs to be handled by the correct endpoint which can
// handle upgrades etc.
//exit loop
//if (TD.ReceiveTimeoutIsEnabled())
//{
//    TD.ReceiveTimeout(exception.Message);
//}
//if (TD.ReceiveTimeoutIsEnabled())
//{
//    TD.ReceiveTimeout(exception.Message);
//}
// containment -- all exceptions abort the reader, no additional containment action necessary
// TODO: On .NET Framework, this Abort call via a long winding path of plumbing will trigger a new pending Accept
// as this connection establishment handshake has failed. Some back pressure mechanism needs to be implemented to
// stop extra incoming connection handshakes from being started. Maybe a semaphore which is async waited at initial
// incoming request and then released on completion of handshake or on an exception. It also closes the connection
// so that's all that's happening here for now. Returning and completing the task will cause the connection to be closed.
// else:
//   returning will close the connection if it hasn't already been.
// TODO: Have a mechanism to stop wrapping as Net.Tcp allows you to unwrap a connection and make it raw again
// Once we've moved past netstandard2.0, we can replace the code with this line:
// await stream.WriteAsync(buffer.First);
// Once we've moved past netstandard2.0, we can replace the code with this line:
// await stream.WriteAsync(memory);
// TODO: make sure the exception propagates somehow
// Once we've moved past netstandard2.0, we can replace the code with this line:
// var bytesRead = await stream.ReadAsync(outputBuffer);
// FIN
// Don't rethrow the exception. It should be handled by the Pipeline consumer.
// first drain our stream if necessary
// send back EOF and then recycle the connection
// TODO: ChannelBinding
//ChannelBindingUtility.Dispose(ref this.channelBindingToken);
// TODO: Determine if timeout stream is needed as StreamingOutputConnectionStream implements some timeout functionality
//Stream writeTimeoutStream = new TimeoutStream(connectionStream, ref timeoutHelper);
// context handles response end bytes
// overrides Stream to add a Framing int at the beginning of each record
/// <summary>
/// Defines a class that provides the mechanisms to configure a connection handshake pipeline.
/// </summary>
/// <summary>
/// Gets or sets the <see cref="IServiceProvider"/> that provides access to the application's service container.
/// </summary>
/// <summary>
/// Gets a key/value collection that can be used to share data between middleware.
/// </summary>
/// <summary>
/// Adds a middleware delegate to the connection handshake pipeline.
/// </summary>
/// <param name="IConnectionHandshakeBuilder">The middleware delegate.</param>
/// <returns>The <see cref="IFramingConnectionHandshakeBuilder"/>.</returns>
/// <summary>
/// Creates a new <see cref="IFramingConnectionHandshakeBuilder"/> that shares the <see cref="Properties"/> of this
/// <see cref="IFramingConnectionHandshakeBuilder"/>.
/// </summary>
/// <returns>The new <see cref="IFramingConnectionHandshakeBuilder"/>.</returns>
/// <summary>
/// Builds the delegate used by this application to process ServiceModel Framed requests.
/// </summary>
/// <returns>The request handling delegate.</returns>
/// <summary>
/// Extension methods for the <see cref="MapMiddleware"/>.
/// </summary>
/// <summary>
/// Branches the handshake pipeline based on the result of a predicate. 
/// If the predicate returns true the branch is executed.
/// </summary>
/// <param name="handshakeBuilder">The <see cref="IFramingConnectionHandshakeBuilder"/> instance.</param>
/// <param name="predicate">The request path to match.</param>
/// <param name="configuration">The branch to take for positive path matches.</param>
/// <returns>The <see cref="IFramingConnectionHandshakeBuilder"/> instance.</returns>
// create branch
/// <summary>
/// Represents a middleware that maps a request path to a sub-request pipeline.
/// </summary>
/// <summary>
/// Creates a new instance of <see cref="MapMiddleware"/>.
/// </summary>
/// <param name="next">The delegate representing the next middleware in the request pipeline.</param>
/// <param name="options">The middleware options.</param>
/// <summary>
/// Executes the middleware.
/// </summary>
/// <param name="context">The <see cref="HttpContext"/> for the current request.</param>
/// <returns>A task that represents the execution of this middleware.</returns>
/// <summary>
/// Options for the <see cref="MapMiddleware"/>.
/// </summary>
/// <summary>
/// The path to match.
/// </summary>
/// <summary>
/// The branch taken for a positive match.
/// </summary>
// Using default port
// Exposes options for how to bind. This could include port sharing in the future
//localhost:{endpoint.Port}/"));
/// <summary>
/// Extension methods for adding typed middleware to a <see cref="IFramingConnectionHandshakeBuilder"/>.
/// </summary>
/// <summary>
/// Adds a middleware type to the connection handshake pipeline.
/// </summary>
/// <typeparam name="TMiddleware">The middleware type.</typeparam>
/// <param name="app">The <see cref="IFramingConnectionHandshakeBuilder"/> instance.</param>
/// <param name="args">The arguments to pass to the middleware type instance's constructor.</param>
/// <returns>The <see cref="IFramingConnectionHandshakeBuilder"/> instance.</returns>
/// <summary>
/// Adds a middleware type to the connection handshake pipeline.
/// </summary>
/// <param name="app">The <see cref="IFramingConnectionHandshakeBuilder"/> instance.</param>
/// <param name="middleware">The middleware type.</param>
/// <param name="args">The arguments to pass to the middleware type instance's constructor.</param>
/// <returns>The <see cref="IFramingConnectionHandshakeBuilder"/> instance.</returns>
// TODO: String resources
// TODO: String resources
// TODO: String resources
// TODO: String resources
// TODO: String resources
// If we call something like
//
// public class Middleware
// {
//    public Task Invoke(ConnectionContext context, ILoggerFactory loggerFactory)
//    {
//
//    }
// }
//
// We'll end up with something like this:
//   Generic version:
//
//   Task Invoke(Middleware instance, ConnectionContext httpContext, IServiceProvider provider)
//   {
//      return instance.Invoke(httpContext, (ILoggerFactory)UseMiddlewareConnectionHandshakeExtensions.GetService(provider, typeof(ILoggerFactory));
//   }
//   Non generic version:
//
//   Task Invoke(object instance, ConnectionContext httpContext, IServiceProvider provider)
//   {
//      return ((Middleware)instance).Invoke(httpContext, (ILoggerFactory)UseMiddlewareConnectionHandshakeExtensions.GetService(provider, typeof(ILoggerFactory));
//   }
// TODO: String resources
// TODO: String resources
// This ensures that people debugging first-chance Exceptions see this Exception,
// and that the Exception shows up in the trace logs.
//: base(traceSourceName)
//            try
//            {
//                this.TraceSourceName = traceSourceName;
//                this.EventSourceName = string.Concat(this.TraceSourceName, " ", EventSourceVersion);
//                CreateTraceSource();
//            }
//            catch (Exception exception)
//            {
//                if (Fx.IsFatal(exception))
//                {
//                    throw;
//                }
//#pragma warning disable 618
//                EventLogger logger = new EventLogger(this.EventSourceName, null);
//                logger.LogEvent(TraceEventType.Error, TracingEventLogCategory, (uint)System.Runtime.Diagnostics.EventLogEventId.FailedToSetupTracing, false,
//                    exception.ToString());
//#pragma warning restore 618
//            }
//            try
//            {
//                CreateEtwProvider(etwProviderId);
//            }
//            catch (Exception exception)
//            {
//                if (Fx.IsFatal(exception))
//                {
//                    throw;
//                }
//                this.etwProvider = null;
//#pragma warning disable 618
//                EventLogger logger = new EventLogger(this.EventSourceName, null);
//                logger.LogEvent(TraceEventType.Error, TracingEventLogCategory, (uint)System.Runtime.Diagnostics.EventLogEventId.FailedToSetupTracing, false,
//                    exception.ToString());
//#pragma warning restore 618
//            }
//            if (this.TracingEnabled || this.EtwTracingEnabled)
//            {
//#pragma warning disable 618
//                this.AddDomainEventHandlersForCleanup();
//#pragma warning restore 618
//            }
//services.AddServiceModelServices();
//var serverAddressesFeature = app.ServerFeatures.Get<IServerAddressesFeature>();
//Assert.NotNull(serverAddressesFeature);
//Assert.NotEmpty(serverAddressesFeature.Addresses);
//string address = serverAddressesFeature.Addresses.Where(url => url.StartsWith("net.tcp", StringComparison.InvariantCultureIgnoreCase)).FirstOrDefault();
//Assert.False(string.IsNullOrEmpty(address));
//string netTcplisteningUrl = "net.tcp://localhost:11808";
//UriBuilder uriBuilder = new UriBuilder(new Uri(netTcplisteningUrl));
//Debug.Assert(ServiceBaseAddress.StartsWith("/"), $"{nameof(ServiceBaseAddress)} must start with /");
//uriBuilder.Path = ServiceBaseAddress;
//Uri baseAddress = uriBuilder.Uri;
//IService service = app.UseService<TService>(baseAddress);
//service.UseServiceEndpoint<TContract>(Binding, RelativeEndpointAddress);
//app.UseMiddleware<ServiceModelMiddleware>(app);
//[Fact]
//public static void NetTcpRequestReplyEchoString()
//{
//    string httpListeningUrl = "http://localhost:18080"; // Dummy for now until we can run without HTTP
//    string netTcplisteningUrl = "net.tcp://localhost:11808";
//    string testString = new string('a', 3000);
//    var host = ServiceHelper.CreateWebHost<Startup>(httpListeningUrl);
//    using (host)
//    {
//        host.Start();
//        var netTcpBinding = new System.ServiceModel.NetTcpBinding();
//        netTcpBinding.Security.Mode = SecurityMode.None;
//        var factory = new ChannelFactory<ClientContract.IEchoService>(netTcpBinding,
//            new EndpointAddress(new Uri(netTcplisteningUrl + "/BasicWcfService/nettcp.svc")));
//        var channel = factory.CreateChannel();
//        System.ServiceModel.Channels.IChannel ichannel = (System.ServiceModel.Channels.IChannel)channel;
//        ichannel.Open();
//        var result = channel.EchoString(testString);
//        Assert.Equal(testString, result);
//        ichannel.Close();
//    }
//}
//[Fact]
//public static void NetTcpRequestReplyEchoStringAsync()
//{
//    string httpListeningUrl = "http://localhost:18080"; // Dummy for now until we can run without HTTP
//    string netTcplisteningUrl = "net.tcp://localhost:11808";
//    string testString = new string('a', 3000);
//    var host = ServiceHelper.CreateWebHost<Startup>(httpListeningUrl);
//    using (host)
//    {
//        host.Start();
//        var netTcpBinding = new System.ServiceModel.NetTcpBinding();
//        netTcpBinding.Security.Mode = SecurityMode.None;
//        var factory = new ChannelFactory<ClientContract.IEchoService>(netTcpBinding,
//            new EndpointAddress(new Uri(netTcplisteningUrl + "/BasicWcfService/nettcp.svc")));
//        var channel = factory.CreateChannel();
//        System.ServiceModel.Channels.IChannel ichannel = (System.ServiceModel.Channels.IChannel)channel;
//        ichannel.Open();
//        var result = channel.EchoStringAsync(testString);
//        Assert.Equal(testString, result);
//    }
//}
//[Fact]
//public static void NetTcpRequestReplyEchoStream()
//{
//    string httpListeningUrl = "http://localhost:18080"; // Dummy for now until we can run without HTTP
//    string netTcplisteningUrl = "net.tcp://localhost:11808";
//    string testString = new string('a', 3000);
//    MemoryStream testStream = new MemoryStream(Encoding.UTF8.GetBytes(testString));
//    var host = ServiceHelper.CreateWebHost<Startup>(httpListeningUrl);
//    using (host)
//    {
//        host.Start();
//        var netTcpBinding = new System.ServiceModel.NetTcpBinding();
//        netTcpBinding.Security.Mode = SecurityMode.None;
//        var factory = new ChannelFactory<ClientContract.IEchoService>(netTcpBinding,
//            new EndpointAddress(new Uri(netTcplisteningUrl + "/BasicWcfService/nettcp.svc")));
//        var channel = factory.CreateChannel();
//        System.ServiceModel.Channels.IChannel ichannel = (System.ServiceModel.Channels.IChannel)channel;
//        ichannel.Open();
//        var result = channel.EchoStream(testStream);
//        testStream.SetLength(0);
//        result.CopyTo(testStream);
//        var resultString = Encoding.UTF8.GetString(testStream.ToArray());
//        Assert.Equal(testString, resultString);
//    }
//}
//[Fact]
//public static void NetTcpRequestReplyEchoStreamAsync()
//{
//    string httpListeningUrl = "http://localhost:18080"; // Dummy for now until we can run without HTTP
//    string netTcplisteningUrl = "net.tcp://localhost:11808";
//    string testString = new string('a', 3000);
//    MemoryStream testStream = new MemoryStream(Encoding.UTF8.GetBytes(testString));
//    var host = ServiceHelper.CreateWebHost<Startup>(httpListeningUrl);
//    using (host)
//    {
//        host.Start();
//        var netTcpBinding = new System.ServiceModel.NetTcpBinding();
//        netTcpBinding.Security.Mode = SecurityMode.None;
//        var factory = new ChannelFactory<ClientContract.IEchoService>(netTcpBinding,
//            new EndpointAddress(new Uri(netTcplisteningUrl + "/BasicWcfService/nettcp.svc")));
//        var channel = factory.CreateChannel();
//        System.ServiceModel.Channels.IChannel ichannel = (System.ServiceModel.Channels.IChannel)channel;
//        ichannel.Open();
//        var result = channel.EchoStreamAsync(testStream);
//        testStream.SetLength(0);
//        result.CopyTo(testStream);
//        var resultString = Encoding.UTF8.GetString(testStream.ToArray());
//        Assert.Equal(testString, resultString);
//    }
//}
//public class Startup : BaseStartup<Services.EchoService, ServiceContract.IEchoService>
//{
//    public override string ServiceBaseAddress => "/BasicWcfService";
//    public override Binding Binding => new NetTcpBinding
//                { Security = new CoreWCF.NetTcpSecurity
//                    { Mode = CoreWCF.SecurityMode.None }
//                };
//    public override string RelativeEndpointAddress => "nettcp.svc";
//}
//localhost:8808";
//localhost:8808";
//localhost:8808" + Startup.BufferedRelatveAddress)));
//localhost:8808" + Startup.BufferedRelatveAddress)));
//localhost:8808" + Startup.StreamedRelatveAddress)));
//localhost:8808" + Startup.StreamedRelatveAddress)));
//tempuri.org/";
//tempuri.org/", Name = Constants.TESTSERVICE_NAME)]
//tempuri.org/";
// DEBUG
// Only want to call Close if it is in the Opened state
// Anything not closed by this point should be aborted
//tempuri.org/";
//[Serializable]
//protected ActionMismatchAddressingException(SerializationInfo info, StreamingContext context)
//    : base(info, context)
//{
//}
//[Serializable]
// protected ActionNotSupportedException(SerializationInfo info, StreamingContext context) : base(info, context) { }
// AddressFilterMode.default
//[Serializable]
//protected ChannelTerminatedException(SerializationInfo info, StreamingContext context) : base(info, context) { }
//SystemException
//protected CommunicationObjectAbortedException(SerializationInfo info, StreamingContext context) : base(info, context) { }
//protected CommunicationObjectFaultedException(SerializationInfo info, StreamingContext context) : base(info, context) { }
// This is first so it is ConcurrencyMode.default
// This class is a substitute for System.DBNull. It's only use with WCF is to allow HopperCache to tell the
// difference between a non-existent value and a null value.
//Package private constructor
// TODO: Make this generic shared code used by multiple assemblies
//exceptionUtility = new ExceptionUtility("System.ServiceModel", "System.ServiceModel 4.0.0.0", (object)DiagnosticUtility.diagnosticTrace, (object)FxTrace.Exception);
//FxTrace.Exception.TraceHandledException(exception, traceEventType);
//if ((_diagnosticTrace == null ? 0 : (_diagnosticTrace.ShouldTrace(eventType) ? 1 : 0)) != 0)
//{
//    using (
//        ExceptionUtility.useStaticActivityId
//            ? Activity.CreateActivity(ExceptionUtility.activityId)
//            : (Activity)null)
//        _diagnosticTrace.TraceEvent(eventType, 131075,
//            LegacyDiagnosticTrace.GenerateMsdnTraceCode("System.ServiceModel.Diagnostics",
//                "ThrowingException"), TraceSR.Format("ThrowingException"), extendedData, exception,
//            (object)null);
//    IDictionary data = exception.Data;
//    if (data != null && !data.IsReadOnly && !data.IsFixedSize)
//    {
//        object obj =
//            data[(object)"System.ServiceModel.Diagnostics.ExceptionUtility.ExceptionStackAsString"];
//        string str1 = obj == null ? "" : obj as string;
//        if (str1 != null)
//        {
//            string stackTrace = exception.StackTrace;
//            if (!string.IsNullOrEmpty(stackTrace))
//            {
//                string str2 = str1 + (str1.Length == 0 ? "" : Environment.NewLine) + "throw" +
//                              Environment.NewLine + stackTrace + Environment.NewLine + "catch" +
//                              Environment.NewLine;
//                data[(object)"System.ServiceModel.Diagnostics.ExceptionUtility.ExceptionStackAsString"]
//                    = (object)str2;
//            }
//        }
//    }
//}
//this.exceptionTrace.TraceEtwException(exception, eventType);
//Microsoft.Runtime.Diagnostics.EventLogger logger = null;
//try
//{
//    logger = new Microsoft.Runtime.Diagnostics.EventLogger(this.eventSourceName, this.diagnosticTrace);
//}
//finally
//{
//    TraceFailFast(message, logger);
//}
/*
// invariant: each section in the buffer will start with a dummy wrapper element
// these are the element name/namespace for the dummy wrapper element that wraps each buffer section
//Dummy";
//public EndpointAddress(Uri uri, EndpointIdentity identity, AddressHeaderCollection headers)
//{
//    if (uri == null)
//    {
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(uri));
//    }
//    Init(uri, identity, headers, null, -1, -1, -1);
//}
//// metadataReader and extensionReader are assumed to not have a starting dummy wrapper element
//public EndpointAddress(Uri uri, EndpointIdentity identity, AddressHeaderCollection headers, XmlDictionaryReader metadataReader, XmlDictionaryReader extensionReader)
//    : this(uri, identity, headers, metadataReader, extensionReader, null)
//{
//}
// TODO: This was internal, I needed to make it public. Is this a problem?
// NOTE: UserInfo, Query, and Fragment are ignored when comparing Uris as addresses
// this is the WCF logic for comparing Uris that represent addresses
// this method must be kept in sync with UriGetHashCode
// PERF: Equals compares everything but UserInfo and Fragments.  It's more strict than
//       we are, and faster, so it is done first.
// Uri.Scheme is always lowercase
// Normalize for trailing slashes
// this method must be kept in sync with UriEquals
// Normalize for trailing slashes
/* ignoreCase */, true /* includeHostInComparison */))
/* includeHostInComparison */);
// returns reader without starting dummy wrapper element
//// returns reader without starting dummy wrapper element
//// returns reader without starting dummy wrapper element
// consume the dummy wrapper element
//public static EndpointAddress ReadFrom(XmlDictionaryReader reader)
//{
//    AddressingVersion dummyVersion;
//    return ReadFrom(reader, out dummyVersion);
//}
//else if (reader.IsNamespaceUri(AddressingVersion.WSAddressingAugust2004.DictionaryNamespace))
//{
//    version = AddressingVersion.WSAddressingAugust2004;
//}
//public static EndpointAddress ReadFrom(XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString ns)
//{
//    AddressingVersion version;
//    return ReadFrom(reader, localName, ns, out version);
//}
//else if (reader.IsNamespaceUri(AddressingVersion.WSAddressingAugust2004.DictionaryNamespace))
//{
//    version = AddressingVersion.WSAddressingAugust2004;
//}
//public static EndpointAddress ReadFrom(AddressingVersion addressingVersion, XmlReader reader)
//{
//    return ReadFrom(addressingVersion, XmlDictionaryReader.CreateDictionaryReader(reader));
//}
//public static EndpointAddress ReadFrom(AddressingVersion addressingVersion, XmlReader reader, string localName, string ns)
//{
//    if (reader == null)
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(reader));
//    if (addressingVersion == null)
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(addressingVersion));
//    XmlDictionaryReader dictReader = XmlDictionaryReader.CreateDictionaryReader(reader);
//    dictReader.ReadFullStartElement(localName, ns);
//    EndpointAddress ea = ReadFromDriver(addressingVersion, dictReader);
//    reader.ReadEndElement();
//    return ea;
//}
//public static EndpointAddress ReadFrom(AddressingVersion addressingVersion, XmlDictionaryReader reader, XmlDictionaryString localName, XmlDictionaryString ns)
//{
//    if (reader == null)
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(reader));
//    if (addressingVersion == null)
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(addressingVersion));
//    reader.ReadFullStartElement(localName, ns);
//    EndpointAddress ea = ReadFromDriver(addressingVersion, reader);
//    reader.ReadEndElement();
//    return ea;
//}
//else if (addressingVersion == AddressingVersion.WSAddressingAugust2004)
//{
//    isAnonymous = ReadContentsFrom200408(reader, out uri, out headers, out identity, out buffer, out metadataSection, out extensionSection, out pspSection);
//}
// EndpointIdentity and extensions
// Cache address string
// Headers
// Metadata
// the wsa10:Metadata element is never stored in the buffer
// Extensions
// Process Address
// this function has a side-effect on the reader (MoveToContent)
// copy all of reader to writer
// Address
// Headers
// Metadata
// EndpointIdentity
// Extensions
// this buffer is wrapped just like in EndpointAddress
// this buffer is wrapped just like in EndpointAddress
// consume the wrapper element
// consume the wrapper element
//return new SpnEndpointIdentity(identity);
//return new UpnEndpointIdentity(identity);
//return new RsaEndpointIdentity(identity);
// as handles null do we need the double null check?
//if (reader.IsStartElement(XD.AddressingDictionary.Spn, XD.AddressingDictionary.IdentityExtensionNamespace))
//{
//    readIdentity = new SpnEndpointIdentity(reader.ReadElementString());
//}
//else if (reader.IsStartElement(XD.AddressingDictionary.Upn, XD.AddressingDictionary.IdentityExtensionNamespace))
//{
//    readIdentity = new UpnEndpointIdentity(reader.ReadElementString());
//}
//else 
//readIdentity = new X509CertificateEndpointIdentity(reader);
//reader.ReadEndElement();
//
// Something unknown
// 
//
// EndpointIdentity element is empty or some other invalid xml
//
//[Serializable]
//protected EndpointNotFoundException(SerializationInfo info, StreamingContext context) : base(info, context) { }
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
// ------------------------------------------------------------------------------
// Changes to this file must follow the http://aka.ms/api-review process.
// ------------------------------------------------------------------------------
//schemas.xmlsoap.org/soap/actor/next",
//www.w3.org/2003/05/soap-envelope/role/ultimateReceiver",
//www.w3.org/2003/05/soap-envelope/role/next",
/// <summary>
/// Defines the mapping to be used for translating exceptions to faults.
/// </summary>
/// <summary>
/// ExceptionMapper constructor.
/// </summary>
/// <summary>
/// Translates the input exception to a fault using the mapping defined in ExceptionMap.
/// </summary>
/// <param name="ex">The exception to be mapped to a fault.</param>
/// <returns>The fault corresponding to the input exception.</returns>
/// <summary>
/// Translates the input exception to a fault using the mapping defined in ExceptionMap.
/// </summary>
/// <param name="ex">The exception to be mapped to a fault.</param>
/// <param name="soapNamespace">The SOAP Namespace to be used when generating the mapped fault.</param>
/// <param name="trustNamespace">The WS-Trust Namespace to be used when generating the mapped fault.</param>
/// <returns>The fault corresponding to the input exception.</returns>
/// <summary>
/// Determines whether an exception that occurred during the processing of a security token 
/// should be handled using the defined ExceptionMap.
/// </summary>
/// <param name="ex">The input exception.</param>
/// <returns>A boolean value indicating whether the exception should be handled using the defined ExceptionMap.</returns>
// Just throw the original exception.
// The exception is not one of the recognized exceptions. Just throw the original exception.
// TODO: Consider making this public
//schemas.microsoft.com/net/2005/12/windowscommunicationfoundation/dispatcher";
//public const string Transactions = "http://schemas.microsoft.com/net/2005/12/windowscommunicationfoundation/transactions";
// 'Transactions' feature fault codes 
//public const string TransactionHeaderMalformed = "TransactionHeaderMalformed";
//public const string TransactionHeaderMissing = "TransactionHeaderMissing";
//public const string TransactionUnmarshalingFailed = "TransactionUnmarshalingFailed";
//public const string TransactionIsolationLevelMismatch = "TransactionIsolationLevelMismatch";
//public const string TransactionAborted = "TransactionAborted";
//public const string IssuedTokenFlowNotAllowed = "IssuedTokenFlowNotAllowed";
//schemas.microsoft.com/net/2005/12/windowscommunicationfoundation/dispatcher/fault";
//public const string Transactions = "http://schemas.microsoft.com/net/2005/12/windowscommunicationfoundation/transactions/fault";
//schemas.xmlsoap.org/Microsoft/WindowsCommunicationFoundation/2005/08/Faults/";
// public on full framework
//[Serializable]
// Let FaultReasonText constructor throw
// Let FaultReasonText constructor throw
// If there's only one translation, use it
// Search for an exact match
// If no exact match is found, proceed by looking for the a translation with a language that is a parent of the current culture
// Search for a more general language
// We don't want to accept xml:lang=""
// Clip off the last subtag and look for a match
// Return the first translation if no match is found
// public on full framework, but exposes a SynchronizedReadOnlyCollection
// public on full framework
// +
// *
//bool AllowOutputBatching { get; set; }
// There's a race condition while on one thread we received a new request from underlying sessionful channel
// and on another thread we just aborted the channel. So the channel will be added to the IncomingChannels list of 
// ServiceChannelManager and never get a chance to be removed.
// TODO: Make this call and it's chain async
//if (TD.CloseTimeoutIsEnabled())
//{
//    TD.CloseTimeout(e.Message);
//}
// TODO: Re-home InstanceContextManager and have a reference to it here.
// TODO: Create new mechanism to register fault event handlers
//_host.FaultInternal();
// TODO: Re-home InstanceContextManager and have a reference to it here.
//[Serializable]
//SystemException
//protected InvalidMessageContractException(SerializationInfo info, StreamingContext context)
//    : base(info, context)
//{
//}
//ProtectionLevel protectionLevel = ProtectionLevel.None;
//bool hasProtectionLevel = false;
//internal const string ProtectionLevelPropertyName = "ProtectionLevel";
//public ProtectionLevel ProtectionLevel
//{
//    get
//    {
//        return this.protectionLevel;
//    }
//    set
//    {
//        if (!ProtectionLevelHelper.IsDefined(value))
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("value"));
//        this.protectionLevel = value;
//        this.hasProtectionLevel = true;
//    }
//}
//public bool HasProtectionLevel
//{
//    get { return this.hasProtectionLevel; }
//}
//ProtectionLevel protectionLevel = ProtectionLevel.None;
//bool hasProtectionLevel = false;
//internal const string ProtectionLevelPropertyName = "ProtectionLevel";
//public ProtectionLevel ProtectionLevel
//{
//    get
//    {
//        return this.protectionLevel;
//    }
//    set
//    {
//        if (!ProtectionLevelHelper.IsDefined(value))
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(value)));
//        this.protectionLevel = value;
//        this.hasProtectionLevel = true;
//    }
//}
//public bool HasProtectionLevel
//{
//    get { return this.hasProtectionLevel; }
//}
//[Serializable]
//[NonSerialized]
//[NonSerialized]
//[NonSerialized]
// IsDuplicate==true means there was more than one; IsDuplicate==false means there were zero
// for serialization
//protected MessageHeaderException(SerializationInfo info, StreamingContext context) : base(info, context) { }
// problem: creating / getting content / settings content on a MessageHeader<T> given the type at runtime
// require reflection.
// solution: This class creates a cache of adapters that provide an untyped wrapper over a particular
// MessageHeader<T> instantiation.
// better solution: implement something like "IUntypedTypedHeader" that has a "object Content" property,
// privately implement this on TypedHeader, and then just use that iface to operation on the header (actually
// you'd still have the creation problem...).  the issue with that is you now have a new public interface
//[Serializable]
// for serialization
//public MustUnderstandSoapException() { }
//protected MustUnderstandSoapException(SerializationInfo info, StreamingContext context) : base(info, context) { }
// empty
//Could be a TransparentProxy
// TODO: Probably want to revert this to public
// yes, we might throw InvalidCastException here.  Is it really
// better to check and throw something else instead?
// This code is used for WebSockets open notification
//if (IsSessionOpenNotificationEnabled)
//{
//    if (!IsOneWay
//     || !this.IsInitiating
//     || methodInfo.GetParameters().Length > 0)
//    {
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(
//            SR.Format(SR.ContractIsNotSelfConsistentWhenIsSessionOpenNotificationEnabled, operationName, "Action", OperationDescription.SessionOpenedAction, "IsOneWay", "IsInitiating")));
//    }
//}
//SystemException
// This is the API called by framework to perform CheckAccess.
// The API is responsible for ...
// 1) Evaluate all policies (Forward\Backward)
// 2) Optionally wire up the resulting AuthorizationContext 
//    to ServiceSecurityContext.
// 3) An availability of message content to make an authoritive decision. 
// 4) Return the authoritive decision true/false (allow/deny).
// default to forward-chaining implementation
// 1) Get policies that will participate in chain process.
//    We provide a safe default policies set below.
// 2) Do forward chaining and wire the new ServiceSecurityContext
// 3) Call the CheckAccessCore
// Define the set of policies taking part in chaining.  We will provide
// the safe default set (primary token + all supporting tokens except token with
// with SecurityTokenAttachmentMode.Signed + transport token).  Implementor
// can override and provide different selection of policies set.
// Combine 
// Implementor overrides this API to make authoritive decision.
// The AuthorizationContext in opContext is generally the result from forward chain.
// if the user passes an object to the ServiceHost, it is stored here
// if the user passes a type to the ServiceHost, and instanceMode==Single, we store the instance here
// Adding to collection called ChannelAdded, so call ChannelRemoved to balance
//internal static TimeSpan ServiceHostCloseTimeout { get { return TimeSpanHelper.FromSeconds(10, ServiceHostCloseTimeoutString); } }
//internal static TimeSpan CloseTimeout { get { return TimeSpanHelper.FromMinutes(1, CloseTimeoutString); } }
//internal static TimeSpan OpenTimeout { get { return TimeSpanHelper.FromMinutes(1, OpenTimeoutString); } }
//internal static TimeSpan ReceiveTimeout { get { return TimeSpanHelper.FromMinutes(10, ReceiveTimeoutString); } }
//internal static TimeSpan SendTimeout { get { return TimeSpanHelper.FromMinutes(1, SendTimeoutString); } }
//internal static TimeSpan TransactionTimeout { get { return TimeSpanHelper.FromMinutes(1, TransactionTimeoutString); } }
//internal const string TransactionTimeoutString = "00:00:00";
//ServiceAuthenticationBehavior readOnlyAuthentication;
//EventTraceActivity eventTraceActivity;
// TODO: Bring in ServiceAuthenticationBehavior
//public ServiceAuthenticationBehavior Authentication
//{
//    get
//    {
//        if (this.Description == null)
//        {
//            return null;
//        }
//        else if (this.State == CommunicationState.Created || this.State == CommunicationState.Opening)
//        {
//            return EnsureAuthentication(this.Description);
//        }
//        else
//        {
//            return this.readOnlyAuthentication;
//        }
//    }
//}
// TODO: Decide if Credentials should be populated?
//if (this.Description == null)
//{
//    return null;
//}
//else if (this.State == CommunicationState.Created || this.State == CommunicationState.Opening)
//{
//    return EnsureCredentials(this.Description);
//}
//else
//{
//    return this.readOnlyCredentials;
//}
/*return this.ServiceThrottle.ManualFlowControlLimit;*/ }
/*this.ServiceThrottle.ManualFlowControlLimit = value;*/ }
//if (null != this.servicePerformanceCounters)
//{
//    lock (this.ThisLock)
//    {
//        if (null != this.servicePerformanceCounters)
//        {
//            this.servicePerformanceCounters.ServiceInstanceCreated();
//        }
//    }
//}
//ServiceAuthenticationBehavior EnsureAuthentication(ServiceDescription description)
//{
//    Fx.Assert(this.State == CommunicationState.Created || this.State == CommunicationState.Opening, "");
//    ServiceAuthenticationBehavior a = description.Behaviors.Find<ServiceAuthenticationBehavior>();
//    if (a == null)
//    {
//        a = new ServiceAuthenticationBehavior();
//        description.Behaviors.Add(a);
//    }
//    return a;
//}
// Configuration
//protected void LoadConfigurationSection(ServiceElement serviceSection)
//{
//    throw new PlatformNotSupportedException();
//}
//if (null != this.servicePerformanceCounters)
//{
//    lock (this.ThisLock)
//    {
//        if (null != this.servicePerformanceCounters)
//        {
//            this.servicePerformanceCounters.ServiceInstanceRemoved();
//        }
//    }
//}
// Any user supplied IServiceBehaviors can be applied now
// Prevent base class throw by overriding
//if (this.behaviors.Contains(typeof(ServiceMetadataBehavior)) && ServiceMetadataBehavior.IsMetadataImplementedType(implementedContract))
//{
//    return true;
//}
//if (this.behaviors.Contains(typeof(ServiceMetadataBehavior)) && ServiceMetadataBehavior.IsMetadataImplementedType(implementedContract))
//{
//    return ServiceMetadataBehavior.MexContractName;
//}
// new Uri(Uri, string.Empty) is broken
//Type _declaringType;
//string _methodName;
// Disallow default constructor
// The named method must take a parameter of ICustomAttributeProvider which isn't available so this overload can't be used
//public ServiceKnownTypeAttribute(string methodName)
//{
//    _methodName = methodName;
//}
//public ServiceKnownTypeAttribute(string methodName, Type declaringType)
//{
//    _methodName = methodName;
//    _declaringType = declaringType;
//}
//public Type DeclaringType => _declaringType;
//public string MethodName => _methodName;
//www.w3.org/2003/05/soap-envelope";
//www.w3.org/2005/08/addressing";
//www.w3.org/2005/08/addressing/anonymous";
//schemas.xmlsoap.org/ws/2005/02/rm";
//schemas.microsoft.com/ws/2006/05/rm";
//schemas.xmlsoap.org/ws/2005/02/rm/SequenceAcknowledgement";
//www.w3.org/2000/09/xmldsig#";
//www.w3.org/2000/09/xmldsig#enveloped-signature";
//docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd";
//www.w3.org/2001/04/xmlenc#";
//schemas.xmlsoap.org/ws/2005/02/sc";
//docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd";
//docs.oasis-open.org/wss/oasis-wss-wssecurity-secext-1.1.xsd";
//schemas.xmlsoap.org/ws/2005/02/trust";
//schemas.xmlsoap.org/ws/2005/02/trust#BinarySecret";
//schemas.microsoft.com/ws/2006/02/transactions";
//schemas.xmlsoap.org/ws/2006/02/addressingidentity";
//www.w3.org/2005/08/addressing/fault";
//www.w3.org/2005/08/addressing/reply";
//www.w3.org/2005/08/addressing/none";
//schemas.xmlsoap.org/ws/2004/08/addressing";
//schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous";
//schemas.xmlsoap.org/ws/2004/08/addressing/fault";
//schemas.xmlsoap.org/ws/2004/06/addressingex";
//www.w3.org/2001/10/xml-exc-c14n#";
//schemas.xmlsoap.org/ws/2004/04/sc";
//schemas.xmlsoap.org/ws/2004/04/security/sc/dk";
//schemas.xmlsoap.org/ws/2004/04/security/sc/sct";
//schemas.xmlsoap.org/ws/2004/04/security/trust/RST/SCT";
//schemas.xmlsoap.org/ws/2004/04/security/trust/RSTR/SCT";
//schemas.xmlsoap.org/ws/2005/02/sc/dk";
//schemas.xmlsoap.org/ws/2005/02/sc/sct";
//schemas.xmlsoap.org/ws/2005/02/trust/RST/SCT";
//schemas.xmlsoap.org/ws/2005/02/trust/RSTR/SCT";
//schemas.xmlsoap.org/ws/2005/02/trust/RST/SCT/Renew";
//schemas.xmlsoap.org/ws/2005/02/trust/RSTR/SCT/Renew";
//schemas.xmlsoap.org/ws/2005/02/trust/RST/SCT/Cancel";
//schemas.xmlsoap.org/ws/2005/02/trust/RSTR/SCT/Cancel";
//www.w3.org/2001/04/xmlenc#aes128-cbc";
//www.w3.org/2001/04/xmlenc#kw-aes128";
//www.w3.org/2001/04/xmlenc#aes192-cbc";
//www.w3.org/2001/04/xmlenc#kw-aes192";
//www.w3.org/2001/04/xmlenc#aes256-cbc";
//www.w3.org/2001/04/xmlenc#kw-aes256";
//www.w3.org/2001/04/xmlenc#des-cbc";
//www.w3.org/2000/09/xmldsig#dsa-sha1";
//www.w3.org/2001/10/xml-exc-c14n#WithComments";
//www.w3.org/2000/09/xmldsig#hmac-sha1";
//www.w3.org/2001/04/xmldsig-more#hmac-sha256";
//schemas.xmlsoap.org/ws/2005/02/sc/dk/p_sha1";
//www.w3.org/2001/04/xmlenc#ripemd160";
//www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p";
//www.w3.org/2000/09/xmldsig#rsa-sha1";
//www.w3.org/2001/04/xmldsig-more#rsa-sha256";
//www.w3.org/2001/04/xmlenc#rsa-1_5";
//www.w3.org/2000/09/xmldsig#sha1";
//www.w3.org/2001/04/xmlenc#sha256";
//www.w3.org/2001/04/xmlenc#sha512";
//www.w3.org/2001/04/xmlenc#tripledes-cbc";
//www.w3.org/2001/04/xmlenc#kw-tripledes";
//schemas.xmlsoap.org/2005/02/trust/tlsnego#TLS_Wrap";
//schemas.xmlsoap.org/2005/02/trust/spnego#GSS_Wrap";
//schemas.microsoft.com/ws/2006/05/security";
//docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary";
//docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#HexBinary";
//docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Text";
//docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509SubjectKeyIdentifier";
//docs.oasis-open.org/wss/oasis-wss-kerberos-token-profile-1.1#GSS_Kerberosv5_AP_REQ";
//docs.oasis-open.org/wss/oasis-wss-kerberos-token-profile-1.1#GSS_Kerberosv5_AP_REQ1510";
//docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.0#SAMLAssertionID";
//docs.oasis-open.org/wss/oasis-wss-rel-token-profile-1.0.pdf#license";
//docs.oasis-open.org/wss/oasis-wss-soap-message-security-1.1#ThumbprintSHA1";
//docs.oasis-open.org/wss/oasis-wss-soap-message-security-1.1#EncryptedKey";
//docs.oasis-open.org/wss/oasis-wss-soap-message-security-1.1#EncryptedKeySHA1";
//docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV1.1";
//docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV2.0";
//docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLID";
//schemas.xmlsoap.org/ws/2005/02/trust/spnego";
//schemas.xmlsoap.org/ws/2005/02/trust/tlsnego";
//schemas.xmlsoap.org/ws/2004/04/trust";
//schemas.xmlsoap.org/ws/2004/04/security/trust/RST/Issue";
//schemas.xmlsoap.org/ws/2004/04/security/trust/RSTR/Issue";
//schemas.xmlsoap.org/ws/2004/04/security/trust/Issue";
//schemas.xmlsoap.org/ws/2004/04/security/trust/CK/PSHA1";
//schemas.xmlsoap.org/ws/2004/04/security/trust/SymmetricKey";
//schemas.xmlsoap.org/ws/2004/04/security/trust/Nonce";
//schemas.xmlsoap.org/ws/2004/04/trust/SymmetricKey";
//schemas.xmlsoap.org/ws/2004/04/trust/PublicKey";
//schemas.microsoft.com/net/2004/07/secext/WS-SPNego";
//schemas.microsoft.com/net/2004/07/secext/TLSNego";
//schemas.xmlsoap.org/ws/2005/02/trust/RST/Issue";
//schemas.xmlsoap.org/ws/2005/02/trust/RSTR/Issue";
//schemas.xmlsoap.org/ws/2005/02/trust/Issue";
//schemas.xmlsoap.org/ws/2005/02/trust/SymmetricKey";
//schemas.xmlsoap.org/ws/2005/02/trust/CK/PSHA1";
//schemas.xmlsoap.org/ws/2005/02/trust/Nonce";
//schemas.xmlsoap.org/ws/2005/02/trust/Renew";
//schemas.xmlsoap.org/ws/2005/02/trust/Cancel";
//schemas.xmlsoap.org/ws/2005/02/trust/PublicKey";
//schemas.microsoft.com/ws/2005/02/duplex";
//www.w3.org/2001/04/xmlenc#Element";
//www.w3.org/2001/04/xmlenc#Content";
//schemas.xmlsoap.org/ws/2005/02/rm/AckRequested";
//schemas.xmlsoap.org/ws/2005/02/rm/CreateSequence";
//schemas.xmlsoap.org/ws/2005/02/rm/CreateSequenceResponse";
//schemas.xmlsoap.org/ws/2005/02/rm/LastMessage";
//schemas.xmlsoap.org/ws/2005/02/rm/TerminateSequence";
//schemas.microsoft.com/ws/2006/02/tx/oletx";
//schemas.xmlsoap.org/ws/2004/10/wscoor";
//schemas.xmlsoap.org/ws/2004/10/wscoor/CreateCoordinationContext";
//schemas.xmlsoap.org/ws/2004/10/wscoor/CreateCoordinationContextResponse";
//schemas.xmlsoap.org/ws/2004/10/wscoor/Register";
//schemas.xmlsoap.org/ws/2004/10/wscoor/RegisterResponse";
//schemas.xmlsoap.org/ws/2004/10/wscoor/fault";
//schemas.xmlsoap.org/ws/2004/10/wsat";
//schemas.xmlsoap.org/ws/2004/10/wsat/Completion";
//schemas.xmlsoap.org/ws/2004/10/wsat/Durable2PC";
//schemas.xmlsoap.org/ws/2004/10/wsat/Volatile2PC";
//schemas.xmlsoap.org/ws/2004/10/wsat/Commit";
//schemas.xmlsoap.org/ws/2004/10/wsat/Rollback";
//schemas.xmlsoap.org/ws/2004/10/wsat/Committed";
//schemas.xmlsoap.org/ws/2004/10/wsat/Aborted";
//schemas.xmlsoap.org/ws/2004/10/wsat/Prepare";
//schemas.xmlsoap.org/ws/2004/10/wsat/Prepared";
//schemas.xmlsoap.org/ws/2004/10/wsat/ReadOnly";
//schemas.xmlsoap.org/ws/2004/10/wsat/Replay";
//schemas.xmlsoap.org/ws/2004/10/wsat/fault";
//schemas.microsoft.com/2004/09/ServiceModel/Diagnostics";
//docs.oasis-open.org/wss/oasis-wss-kerberos-token-profile-1.1#Kerberosv5APREQSHA1";
//schemas.xmlsoap.org/ws/2002/12/policy";
//schemas.microsoft.com/net/2006/05/peer/HopCount";
//schemas.microsoft.com/net/2006/05/peer";
//schemas.microsoft.com/ws/2005/05/routing";
//schemas.microsoft.com/ws/2005/05/addressing/none";
//schemas.microsoft.com/ws/2005/05/envelope/none";
//www.w3.org/2001/XMLSchema-instance";
//www.w3.org/2001/XMLSchema";
//schemas.xmlsoap.org/soap/envelope/";
//
// Summary:
//     A function that can process a ServiceModel request.
//
// Parameters:
//   context:
//     The CoreWCF.Channels.RequestContext for the request.
//
// Returns:
//     A task that represents the completion of request processing.
// Perf: delay created authorizationContext using forward chain.
// TODO: Claim is from IdentityModel but I needed to expose it. This needs to be resolved.
// Multiple Identities is treated as anonymous
// Multiple Identities is treated as anonymous
// Double-checked locking pattern requires volatile for read/write synchronization
// Double-checked locking pattern requires volatile for read/write synchronization
// canonicalize SPN for use in LDAP filter following RFC 1960:
//SecurityTraceRecordHelper.TraceSpnToSidMappingFailure(spn, null);
// covered by FxCOP
// Always immediately rethrow fatal exceptions.
//SecurityTraceRecordHelper.TraceSpnToSidMappingFailure(spn, e);
//" + SecurityUtils.GetPrimaryDomain());
// if the AD cannot be queried for the fully qualified domain name,
// fall back to the downlevel UPN name
// Always immediately rethrow fatal exceptions.
//SecurityTraceRecordHelper.TraceSpnToSidMappingFailure(upn, e);
// Soap11 wants the detail in the header
// This is the first certificate. We assume this as the primary 
// certificate and initialize the base class.
// Static Xml Dictionary
// Main dictionary strings
// Main dictionary strings
// String constants
//schemas.microsoft.com/2005/12/ServiceModel/Addressing/Anonymous";
//schemas.microsoft.com/2005/12/ServiceModel/Addressing/None";
//schemas.microsoft.com/serviceModel/2004/05/addressing";
// Main dictionary strings
// String constants
//www.w3.org/2005/08/addressing/soap/fault";
// Main dictionary strings
// String constants
//schemas.xmlsoap.org/ws/2004/08/addressing/fault";
// Main dictionary strings
// Main dictionary strings
// Main dictionary strings
// Main dictionary strings
// Main dictionary strings
// Main dictionary strings
// Main dictionary strings
// Main dictionary strings
// Main dictionary strings
// String constants
//schemas.microsoft.com/ws/2006/05/security/SecureConversationFault";
// Main dictionary strings
// Main dictionary strings
// Text dictionary strings
// Main dictionary strings
// Main dictionary strings
// Main dictionary strings
// Main dictionary strings
// Main dictionary strings
// Main dictionary strings
// Main dictionary strings
// Main dictionary strings
// String constants
//docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#STR-Transform";
// Main dictionary strings
// String constants
//docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0";
//docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0";
//docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0";
//docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.0";
//www.docs.oasis-open.org/wss/2004/07/oasis-000000-wss-kerberos-token-profile-1.0";
//docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#UsernameToken";
//docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3";
//docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText";
// Main dictionary strings
// String constants
//docs.oasis-open.org/wss/oasis-wss-soap-message-security-1.1";
//docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1";
//docs.oasis-open.org/wss/2004/xx/oasis-2004xx-wss-x509-token-profile-1.1";
// Main dictionary strings
// Main dictionary strings
// Main dictionary strings
// Main dictionary strings
// Main dictionary strings
// Main dictionary strings
// Main dictionary strings
// String constants
// We always want to Dispose of the writer now; previously, writers could be reassigned 
// to a new stream, with a new dictionary and session. 
//www.w3.org/XML/1998/namespace";
//www.w3.org/2000/xmlns/";
//www.w3.org/2001/XMLSchema-instance";
//www.w3.org/2001/XMLSchema";
// This code was copied from XmlDictionaryReader.ReadElementContentAsDateTime which is an internal method
//public static AddressHeader CreateAddressHeader(object value)
//{
//    Type type = GetObjectType(value);
//    return CreateAddressHeader(value, DataContractSerializerDefaults.CreateSerializer(type, int.MaxValue/*maxItems*/));
/*maxItems*/));
//}
//public static AddressHeader CreateAddressHeader(object value, XmlObjectSerializer serializer)
//{
//    if (serializer == null)
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("serializer"));
//    return new XmlObjectSerializerAddressHeader(value, serializer);
//}
/*maxItems*/));
/*maxItems*/));
// WSAddressingAugust2004 does not write the IsReferenceParameter attribute, 
// and that's good for a consistent comparable form. But it's not available for .Net Core
//ParameterHeader.WriteStartHeader(writer, this, AddressingVersion.WSAddressingAugust2004);
//Type type = (objectToSerialize == null) ? typeof(object) : objectToSerialize.GetType();
//XmlQualifiedName rootName = new XsdDataContractExporter().GetRootElementName(type);
//this.name = rootName.Name;
//this.ns = rootName.Namespace;
// astern, This will be kept internal for now.  If the optimization needs to be public, we'll re-evaluate it.
/*maxItems*/))
// avoid allocating an enumerator when possible
// TODO: This needed to be made public for NetTcp, investigate making it internal again
// TODO: This needed to be made public for NetTcp, investigate making it internal again
//static ToHeader anonymousToHeader200408;
//static ToHeader AnonymousTo200408
//{
//    get
//    {
//        if (anonymousToHeader200408 == null)
//            anonymousToHeader200408 = new AnonymousToHeader(AddressingVersion.WSAddressingAugust2004);
//        return anonymousToHeader200408;
//    }
//}
//return AnonymousTo200408;
//return AnonymousTo200408;
//return AnonymousTo200408;
//public static ReplyToHeader AnonymousReplyTo200408
//{
//    get
//    {
//        if (anonymousReplyToHeader200408 == null)
//            anonymousReplyToHeader200408 = new ReplyToHeader(EndpointAddress.AnonymousAddress, AddressingVersion.WSAddressingAugust2004);
//        return anonymousReplyToHeader200408;
//    }
//}
//return AnonymousReplyTo200408;
// The RelationshipType attribute has no namespace.
/*
//Uri relationship;
//this.relationship = relationship;
/*
/*
// The RelationshipType attribute has no namespace.
/*MessagePartSpecification signedMessageParts;*/
/*MessagePartSpecification signedMessageParts,*/ string anonymous, XmlDictionaryString dictionaryAnonymous, string none, string faultAction, string defaultFaultAction)
/*this.signedMessageParts = signedMessageParts;*/
/*Addressing10SignedMessageParts,*/
/*new MessagePartSpecification(),*/ null, null, null, null, null);
/*Addressing200408SignedMessageParts,*/
// the action for addressing faults
// a default string that can be used for non-addressing faults
//public static bool DoesAuthTypeMatch(AuthenticationSchemes authScheme, string authType)
//{
//    if ((authType == null) || (authType.Length == 0))
//    {
//        return authScheme.IsSet(AuthenticationSchemes.Anonymous);
//    }
//    if (authType.Equals("kerberos", StringComparison.OrdinalIgnoreCase) ||
//        authType.Equals("negotiate", StringComparison.OrdinalIgnoreCase))
//    {
//        return authScheme.IsSet(AuthenticationSchemes.Negotiate);
//    }
//    else if (authType.Equals("ntlm", StringComparison.OrdinalIgnoreCase))
//    {
//        return authScheme.IsSet(AuthenticationSchemes.Negotiate) ||
//            authScheme.IsSet(AuthenticationSchemes.Ntlm);
//    }
//    AuthenticationSchemes authTypeScheme;
//    if (!Enum.TryParse<AuthenticationSchemes>(authType, true, out authTypeScheme))
//    {
//        return false;
//    }
//    return authScheme.IsSet(authTypeScheme);
//}
//public static bool IsSingleton(this AuthenticationSchemes v)
//{
//    bool result;
//    switch (v)
//    {
//        case AuthenticationSchemes.Digest:
//        case AuthenticationSchemes.Negotiate:
//        case AuthenticationSchemes.Ntlm:
//        case AuthenticationSchemes.Basic:
//        case AuthenticationSchemes.Anonymous:
//            result = true;
//            break;
//        default:
//            result = false;
//            break;
//    }
//    return result;
//}
//internal static string ToString(AuthenticationSchemes authScheme)
//{
//    return authScheme.ToString().ToLowerInvariant();
//}
// TODO: Make internal again
// Derived from [DataMember] fields
// Note the Uri may contain query string for WSDL purpose.
// So do not check IsValid().
// Set to -1 so that Uri does not show it in the string.
// TODO: Make internal again
// TODO: Make internal again
//splitting the last segment
//splitChar was the last character in the string
// For http, binding format is: "<ipAddress>:<port>:<hostName>"
// as specified in http://www.microsoft.com/resources/documentation/WindowsServ/2003/standard/proddocs/en-us/Default.asp?url=/resources/documentation/WindowsServ/2003/standard/proddocs/en-us/ref_mb_serverbindings.asp
// For https, binding format is the same as http
// For net.tcp, binding format is: "<port>:<hostName>"
// Matching over segments
// Use canonical string representation of the full base address for comparison
// Use canonical string representation of the absolute path for comparison
// Compensate for the fact that the Uri type doesn't know about our default TCP port number
// Double-checked locking pattern requires volatile for read/write synchronization
//volatile SynchronizedPool<XmlDictionaryWriter> streamedWriterPool;
//volatile SynchronizedPool<XmlDictionaryReader> streamedReaderPool;
//running = true;
// TODO: Revert once IXmlBinaryWriterInitializer is available
//if (streamedWriterPool == null)
//{
//    lock (ThisLock)
//    {
//        if (streamedWriterPool == null)
//        {
//            //running = true;
//            streamedWriterPool = new SynchronizedPool<XmlDictionaryWriter>(maxWritePoolSize);
//        }
//    }
//}
//XmlDictionaryWriter xmlWriter = streamedWriterPool.Take();
//if (xmlWriter == null)
//{
//    xmlWriter = XmlDictionaryWriter.CreateBinaryWriter(stream, binaryVersion.Dictionary, null, false);
//}
//else
//{
//    ((IXmlBinaryWriterInitializer)xmlWriter).SetOutput(stream, binaryVersion.Dictionary, null, false);
//}
//return xmlWriter;
//streamedWriterPool.Return(xmlWriter);
//running = true;
// TODO: Revert once IXmlBinaryReaderInitializer is available
//if (streamedReaderPool == null)
//{
//    lock (ThisLock)
//    {
//        if (streamedReaderPool == null)
//        {
//            //running = true;
//            streamedReaderPool = new SynchronizedPool<XmlDictionaryReader>(maxReadPoolSize);
//        }
//    }
//}
//XmlDictionaryReader xmlReader = streamedReaderPool.Take();
//if (xmlReader == null)
//{
//    xmlReader = XmlDictionaryReader.CreateBinaryReader(stream,
//        binaryVersion.Dictionary,
//        readerQuotas,
//        null,
//        onStreamedReaderClose);
//    if (TD.ReadPoolMissIsEnabled())
//    {
//        TD.ReadPoolMiss(xmlReader.GetType().Name);
//    }
//}
//else
//{
//    ((IXmlBinaryReaderInitializer)xmlReader).SetInput(stream,
//        binaryVersion.Dictionary,
//        readerQuotas,
//        null,
//        onStreamedReaderClose);
//}
//return xmlReader;
//streamedReaderPool.Return(xmlReader);
//running = true;
// TODO: Revert once IXmlBinaryReaderInitializer is available
//ArraySegment<byte> buffer = this.Buffer;
//XmlDictionaryReader xmlReader = readerPool.Take();
//if (xmlReader != null)
//{
//    ((IXmlBinaryReaderInitializer)xmlReader).SetInput(buffer.Array, buffer.Offset, buffer.Count,
//        factory.binaryVersion.Dictionary,
//        factory.bufferedReadReaderQuotas,
//        messageEncoder.ReaderSession,
//        onClose);
//}
//else
//{
//    xmlReader = XmlDictionaryReader.CreateBinaryReader(buffer.Array, buffer.Offset, buffer.Count,
//        factory.binaryVersion.Dictionary,
//        factory.bufferedReadReaderQuotas,
//        messageEncoder.ReaderSession,
//        onClose);
//    if (TD.ReadPoolMissIsEnabled())
//    {
//        TD.ReadPoolMiss(xmlReader.GetType().Name);
//    }
//}
//return xmlReader;
// TODO: Revert once IXmlBinaryReaderInitializer is available
//XmlDictionaryWriter returnedWriter = writer;
//if (returnedWriter == null)
//{
//    returnedWriter = XmlDictionaryWriter.CreateBinaryWriter(stream, dictionary, session, false);
//}
//else
//{
//    writer = null;
//    ((IXmlBinaryWriterInitializer)returnedWriter).SetOutput(stream, dictionary, session, false);
//}
//return returnedWriter;
//XmlBinaryReaderSession readerSessionForLogging;
//bool readerSessionForLoggingIsInvalid = false;
//int writeIdCounter;
//MessageLogger.LogMessage(buffer, MessageLoggingSource.Malformed);
//this.readerSessionForLoggingIsInvalid = true;
// <Envelope><Headers><Action>
// </Action><MessageID>
// </MessageID><ReplyTo>...</ReplyTo><To>session-to-key</To></Headers><Body>
// </Action><RelatesTo>
// </RelatesTo><To>static-anonymous-key</To></Headers><Body>
// <Envelope><Body>
// <s:Envelope xmlns:s="soap-ns" xmlns="addressing-ns">
// <s:Header>
// <a:Action>...
// <a:MessageID>...
// <a:ReplyTo><a:Address>static-anonymous-key</a:Address></a:ReplyTo>
// <a:To>session-to-key</a:To>
// </s:Header>
// <s:Body>
// <a:RelatesTo>...
// <a:To>static-anonymous-key</a:To>
// </s:Header>
// <s:Body>
// <s:Envelope xmlns:s="soap-ns" xmlns="addressing-ns">
// <s:Body>
/* public */
//ITransportCompressionSupport compressionSupport = context.GetInnerProperty<ITransportCompressionSupport>();
//if (compressionSupport == null || !compressionSupport.IsCompressionFormatSupported(this.compressionFormat))
//{
//}
// We are guaranteed that a transport exists when building a binding;  
// Allow the regular flow/checks to happen rather than throw here 
// (InternalBuildChannelListener will call into the BindingContext. Validation happens there and it will throw) 
// TODO: Make sure this verification code is executed during pipeline build
//public override IChannelListener<TChannel> BuildChannelListener<TChannel>(BindingContext context)
//{
//    VerifyCompression(context);
//    SetMaxReceivedMessageSizeFromTransport(context);
//    return InternalBuildChannelListener<TChannel>(context);
//}
// compare XmlDictionaryReaderQuotas
// TODO: Ensure any validation logic here is executed in new pipeline
//public virtual IChannelListener<TChannel> BuildChannelListener<TChannel>(Uri listenUriBaseAddress, string listenUriRelativeAddress, ListenUriMode listenUriMode, BindingParameterCollection parameters)
//    where TChannel : class, IChannel
//{
//    EnsureInvariants();
//    BindingContext context = new BindingContext(new CustomBinding(this), parameters, listenUriBaseAddress, listenUriRelativeAddress, listenUriMode);
//    IChannelListener<TChannel> channelListener = context.BuildInnerChannelListener<TChannel>();
//    context.ValidateBindingElementsConsumed();
//    ValidateSecurityCapabilities(channelListener.GetProperty<ISecurityCapabilities>(), parameters);
//    return channelListener;
//}
// kept to ensure each BE builds itself once
// Parameter is never used
// Parameter is never used
//public virtual CoreWCF.Channels.IChannelFactory<TChannel> BuildChannelFactory<TChannel>(CoreWCF.Channels.BindingContext context) { return default(CoreWCF.Channels.IChannelFactory<TChannel>); } // Client
//public virtual bool CanBuildChannelFactory<TChannel>(CoreWCF.Channels.BindingContext context) { return default(bool); } // Client
//TODO: Move back to internal
// returns a new collection with clones of all the elements
// back up the index so we inspect the new item at this location
// Some binding elements can sometimes consume extra information when building factories.
// BindingParameterCollection is a collection of objects with this extra information.
// See comments in SecurityBindingElement and TransactionFlowBindingElement for examples
// of binding elements that go looking for certain data in this collection.
// make sure that maxSize has room for initialOffset without overflowing, since
// the effective buffer size is message size + initialOffset
//if (TD.MaxSentMessageSizeExceededIsEnabled())
//{
//    TD.MaxSentMessageSizeExceeded(excMsg);
//}
// Accessing via IDisposable to avoid Security check (functionally the same)
// none of the obvious speculations about the failure holds, so we fall back to the generic error message
// request-reply or duplex
// TODO: Go through and verify all the internal methods to see if they are needed/used
//bool traceOpenAndClose;
//if (DiagnosticUtility.ShouldTraceInformation)
//{
//    TraceUtility.TraceEvent(TraceEventType.Information, TraceCode.CommunicationObjectAborted, SR.Format(SR.TraceCodeCommunicationObjectAborted, TraceUtility.CreateSourceString(this)), this);
//}
//bool throwing = true;
//try
//{
//throwing = false;
//}
//finally
//{
//    if (throwing)
//    {
//        if (DiagnosticUtility.ShouldTraceWarning)
//            TraceUtility.TraceEvent(TraceEventType.Warning, TraceCode.CommunicationObjectAbortFailed, SR.Format(SR.TraceCodeCommunicationObjectAbortFailed, this.GetCommunicationObjectType().ToString()), this);
//    }
//}
//using (DiagnosticUtility.ShouldUseActivity && this.TraceOpenAndClose ? this.CreateCloseActivity() : null)
//{
//TimeoutHelper actualTimeout = new TimeoutHelper(timeout);
//if (DiagnosticUtility.ShouldTraceWarning)
//{
//    TraceUtility.TraceEvent(TraceEventType.Warning, TraceCode.CommunicationObjectCloseFailed, SR.Format(SR.TraceCodeCommunicationObjectCloseFailed, this.GetCommunicationObjectType().ToString()), this);
//}
//}
// TODO: Switch to TimeoutHelper from client
//using (ServiceModelActivity activity = DiagnosticUtility.ShouldUseActivity && this.TraceOpenAndClose ? ServiceModelActivity.CreateBoundedActivity() : null)
//{
//if (DiagnosticUtility.ShouldUseActivity)
//{
//    ServiceModelActivity.Start(activity, this.OpenActivityName, this.OpenActivityType);
//}
//if (DiagnosticUtility.ShouldTraceWarning)
//{
//    TraceUtility.TraceEvent(TraceEventType.Warning, TraceCode.CommunicationObjectOpenFailed, SR.Format(SR.TraceCodeCommunicationObjectOpenFailed, this.GetCommunicationObjectType().ToString()), this);
//}
//}
// TODO: Make internal again
//if (exception != null && DiagnosticUtility.ShouldTraceInformation)
//{
//    TraceUtility.TraceEvent(TraceEventType.Information, TraceCode.CommunicationObjectFaultReason,
//        SR.TraceCodeCommunicationObjectFaultReason, exception, null);
//}
//if (DiagnosticUtility.ShouldTraceVerbose)
//{
//    TraceUtility.TraceEvent(TraceEventType.Verbose, TraceCode.CommunicationObjectClosed, SR.Format(SR.TraceCodeCommunicationObjectClosed, TraceUtility.CreateSourceString(this)), this);
//}
//if (DiagnosticUtility.ShouldTraceVerbose)
//{
//    TraceUtility.TraceEvent(TraceEventType.Verbose, TraceCode.CommunicationObjectClosing, SR.Format(SR.TraceCodeCommunicationObjectClosing, TraceUtility.CreateSourceString(this)), this);
//}
//if (DiagnosticUtility.ShouldTraceWarning)
//{
//    TraceUtility.TraceEvent(TraceEventType.Warning, TraceCode.CommunicationObjectFaulted, SR.Format(SR.TraceCodeCommunicationObjectFaulted, this.GetCommunicationObjectType().ToString()), this);
//}
//if (DiagnosticUtility.ShouldTraceVerbose)
//    TraceUtility.TraceEvent(TraceEventType.Verbose, TraceCode.CommunicationObjectOpened, SR.Format(SR.TraceCodeCommunicationObjectOpened, TraceUtility.CreateSourceString(this)), this);
//if (DiagnosticUtility.ShouldTraceVerbose)
//{
//    TraceUtility.TraceEvent(TraceEventType.Verbose, TraceCode.CommunicationObjectOpening, SR.Format(SR.TraceCodeCommunicationObjectOpening, TraceUtility.CreateSourceString(this)), this);
//}
//TODO: Make internal again
//Abort can reenter this call as a result of 
//close timeout, Closing input twice is not a
//FailFast case.
/// <summary>
/// Default to compression off
/// </summary>
/// <summary>
/// GZip compression
/// </summary>
/// <summary>
/// Deflate compression
/// </summary>
/// <summary>
/// Base class for non-SOAP messages
/// </summary>
// now we have the quotas from the encoder, we need to update the values with the new quotas from the default read quotas. 
// SOAP MustUnderstand
// WS-Addressing
// WS-Addressing
// WSA
// SOAP
/*
//schemas.microsoft.com/ws/2006/05/framing";
// TODO: Make internal again
// TODO: Add to contract. This is a feature of an encoder but we don't allow other people writing transports to find out about the
// encoder implementing compression and having it enabled. There's no way to work around this without reflection if not public so it should be public.
// BinaryMessageEncoder is the only in-box encoder which supports this.
// This interface needs to be implemented by requests that need to save 
// the RequestReplyCorrelatorKey into the request during RequestReplyCorrelator.Add
// operation. 
// TODO: Derive CancellationToken to carry timeout
// NOTE: don't need to check IsDisposed here: InputQueue will handle dispose
// NOTE: don't need to check IsDisposed here: InputQueue will handle dispose
// NOTE: don't need to check IsDisposed here: InputQueue will handle dispose
// NOTE: don't need to check IsDisposed here: InputQueue will handle dispose
// NOTE: don't need to check IsDisposed here: InputQueue will handle dispose
// NOTE: don't need to check IsDisposed here: InputQueue will handle dispose
// All implementations of this interface are required to be thread-safe
// TODO: Either this interface needs to be public or it needs to be in some internal shared contract
// throws if another object of the same type has been added for the same message
// null is not a valid value for state.
// returns null if no state is found.
// TODO: Make this internal again or get rid of it, probably through DI or Features
// TODO: Derive CancellationToken so that the original timeout can be stored inside
// We have decided not to make this configurable
//SeekableMessageNavigator messageNavigator;
// must never return null
// must never return null
//if (DiagnosticUtility.ShouldTraceVerbose)
//{
//    TraceUtility.TraceEvent(TraceEventType.Verbose, TraceCode.MessageClosed,
//        SR.TraceCodeMessageClosed, this);
//}
//if (DiagnosticUtility.ShouldTraceVerbose)
//{
//    TraceUtility.TraceEvent(TraceEventType.Verbose, TraceCode.MessageClosedAgain,
//        SR.TraceCodeMessageClosedAgain, this);
//}
//if (DiagnosticUtility.ShouldTraceVerbose)
//{
//    TraceUtility.TraceEvent(TraceEventType.Verbose, TraceCode.MessageCopied,
//        SR.TraceCodeMessageCopied, this, this);
//}
/*maxItems*/));
//static internal Message CreateMessage(MessageVersion version, ActionHeader actionHeader)
//{
//    if (version == null)
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("version"));
//    return new BodyWriterMessage(version, actionHeader, EmptyBodyWriter.Value);
//}
//public static Message CreateMessage(MessageVersion version, FaultCode faultCode, string reason, object detail, string action)
//{
//    if (version == null)
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("version"));
//    if (faultCode == null)
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("faultCode"));
//    if (reason == null)
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("reason"));
//    return CreateMessage(version, MessageFault.CreateFault(faultCode, new FaultReason(reason), detail), action);
//}
// TODO: This method SHOULD be made public in the contract as without it, you can't create a Message from a MessageFault without duplicating a LOT of code
// This call will change the message state to Read.
/*maxItems*/));
//if (DiagnosticUtility.ShouldTraceVerbose)
//{
//    TraceUtility.TraceEvent(TraceEventType.Verbose, TraceCode.MessageRead, SR.Format(SR.TraceCodeMessageRead), this);
//}
//internal SeekableMessageNavigator GetNavigator(bool navigateBody, int maxNodes)
//{
//    if (IsDisposed)
//        throw TraceUtility.ThrowHelperError(CreateMessageDisposedException(), this);
//    if (null == this.messageNavigator)
//    {
//        this.messageNavigator = new SeekableMessageNavigator(this, maxNodes, XmlSpace.Default, navigateBody, false);
//    }
//    else
//    {
//        this.messageNavigator.ForkNodeCount(maxNodes);
//    }
//    return this.messageNavigator;
//}
//internal void InitializeReply(Message request)
//{
//    UniqueId requestMessageID = request.Headers.MessageId;
//    if (requestMessageID == null)
//        throw TraceUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.RequestMessageDoesNotHaveAMessageID)), request);
//    Headers.RelatesTo = requestMessageID;
//}
//public IAsyncResult BeginWriteBodyContents(XmlDictionaryWriter writer, AsyncCallback callback, object state)
//{
//    EnsureWriteMessageState(writer);
//    return this.OnBeginWriteBodyContents(writer, callback, state);
//}
//public void EndWriteBodyContents(IAsyncResult result)
//{
//    this.OnEndWriteBodyContents(result);
//}
//protected virtual IAsyncResult OnBeginWriteBodyContents(XmlDictionaryWriter writer, AsyncCallback callback, object state)
//{
//    return new OnWriteBodyContentsAsyncResult(writer, this, callback, state);
//}
//protected virtual void OnEndWriteBodyContents(IAsyncResult result)
//{
//    OnWriteBodyContentsAsyncResult.End(result);
//}
// </Body>
// </Envelope>
// We should call OnWriteBodyContentsAsync instead of WriteBodyContentsAsync here,
// otherwise EnsureWriteMessageState would get called twice. Also see OnWriteMessage()
// for the example.
//if (DiagnosticUtility.ShouldTraceVerbose)
//{
//    TraceUtility.TraceEvent(TraceEventType.Verbose, TraceCode.MessageWritten, SR.TraceCodeMessageWritten, this);
//}
//public IAsyncResult BeginWriteMessage(XmlDictionaryWriter writer, AsyncCallback callback, object state)
//{
//    EnsureWriteMessageState(writer);
//    return OnBeginWriteMessage(writer, callback, state);
//}
//public void EndWriteMessage(IAsyncResult result)
//{
//    OnEndWriteMessage(result);
//}
//bool throwing = true;
//try
//{
//throwing = false;
//}
//finally
//{
//    if (throwing && MessageLogger.LoggingEnabled)
//    {
//        MessageLogger.LogMessage(messageData.Buffer, MessageLoggingSource.Malformed);
//    }
//}
//public XPathNavigator CreateNavigator()
//{
//    return CreateNavigator(int.MaxValue, XmlSpace.None);
//}
//public XPathNavigator CreateNavigator(int nodeQuota)
//{
//    return CreateNavigator(nodeQuota, XmlSpace.None);
//}
//public XPathNavigator CreateNavigator(XmlSpace space)
//{
//    return CreateNavigator(int.MaxValue, space);
//}
//public XPathNavigator CreateNavigator(int nodeQuota, XmlSpace space)
//{
//    if (nodeQuota <= 0)
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("nodeQuota", SR.Format(SR.FilterQuotaRange)));
//    return new SeekableMessageNavigator(this.CreateMessage(), nodeQuota, space, true, true);
//}
//CSDMain 17837: CreateBufferedCopy should have code to copy over the To and Action headers
// used for buffered streaming
// used for buffered streaming
// TODO: Work out what to do about the async message writing, add to contract
// now check case-insensitively
// Linear Whitespace is allowed to appear between the end of one property and the semicolon.
// LWS = [CRLF]? (SP | HT)+
// Consume the [CRLF]?
// Look for a ';' or nothing after (SP | HT)+
// sometimes we get a contentType that has parameters, but our encoders
// merely expose the base content-type, so we will check a stripped version
// bad content type, so we definitely don't support it!
//        internal IChannelFactory<TChannel> InternalBuildChannelFactory<TChannel>(BindingContext context)
//        {
//            if (context == null)
//            {
//                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("context"));
//            }
//#pragma warning suppress 56506 // brianmcn, BindingContext.BindingParameters never be null
//            context.BindingParameters.Add(this);
//            return context.BuildInnerChannelFactory<TChannel>();
//        }
//        internal bool InternalCanBuildChannelFactory<TChannel>(BindingContext context)
//        {
//            if (context == null)
//            {
//                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("context"));
//            }
//#pragma warning suppress 56506 // brianmcn, BindingContext.BindingParameters never be null
//            context.BindingParameters.Add(this);
//            return context.CanBuildInnerChannelFactory<TChannel>();
//        }
/*maxItems*/), "", "");
/*maxItems*/));
// Wrap in soap 1.2 by default
// Skip the detail element
// check if the detail element contains data
// Start the element
// Copy the attributes
// Copy the contents
// End the element
// Start the element
// Copy the attributes
// Skip the detail element
// Handle fault detail version conversion from Soap12 to Soap11 -- scope tightly to only conversion from Soap12 -> Soap11
// SOAP 1.1 specifications allow an arbitrary element within <fault>, hence: 
// transform this IFF the SOAP namespace specified will affect the namespace of the <detail> element, 
// AND the namespace specified is exactly the Soap12 Namespace. 
// original incoming version
// version to serialize to
// attribute prefix
// only transform namespace attributes, don't care about others
// Don't do IsStartElement.  FaultString is required, so let the reader throw.
//else if (IsMessageVersionSupported(MessageVersion.Soap12WSAddressingAugust2004))
//{
//    WriteHeader(writer, MessageVersion.Soap12WSAddressingAugust2004);
//}
//else if (IsMessageVersionSupported(MessageVersion.Soap11WSAddressing10))
//{
//    WriteHeader(writer, MessageVersion.Soap11WSAddressing10);
//}
//else if (IsMessageVersionSupported(MessageVersion.Soap11WSAddressingAugust2004))
//{
//    WriteHeader(writer, MessageVersion.Soap11WSAddressingAugust2004);
//}
//else if (IsMessageVersionSupported(MessageVersion.Soap12))
//{
//    WriteHeader(writer, MessageVersion.Soap12);
//}
// TODO: This needed to be made public for NetTcp, investigate making it internal again
/*maxItems*/);
// Write an enclosing Envelope tag
// Write and enclosing Header tag
// See if we need to move past the enclosing envelope/header
// Envelope
// Header
// The highest node and attribute counts reached by the BVTs were 1829 and 667 respectively.
// Check if we need to change representations
// consume end tag
/*maxItems*/));
/*maxItems*/));
// Envelope
// Header
//if (DiagnosticUtility.ShouldTraceWarning)
//{
//    TraceUtility.TraceEvent(TraceEventType.Warning, TraceCode.DidNotUnderstandMessageHeader,
//        SR.TraceCodeDidNotUnderstandMessageHeader,
//        new MessageHeaderInfoTraceRecord(headerInfo), null, null);
//}
//if (DiagnosticUtility.ShouldTraceVerbose)
//{
//    TraceUtility.TraceEvent(TraceEventType.Verbose, TraceCode.UnderstoodMessageHeader,
//        SR.TraceCodeUnderstoodMessageHeader,
//        new MessageHeaderInfoTraceRecord(info), null, null);
//}
//if ((object)security != null)
//{
//    keys.Add(SecurityKey);
//}
//if ((object)security != null)
//{
//    values.Add(security);
//}
//security = null;
// CopyProperties behavior should be equivalent to the behavior
// of MergeProperties except that Merge supports property values that
// implement the IMergeEnabledMessageProperty.  Any changes to CopyProperties
// should be reflected in MergeProperties as well.
// this[string] will call CreateCopyOfPropertyValue, so we don't need to repeat that here
//this.Security = (properties.Security != null) ? (SecurityMessageProperty)properties.Security.CreateCopy() : null;
// MergeProperties behavior should be equivalent to the behavior
// of CopyProperties except that Merge supports property values that
// implement the IMergeEnabledMessageProperty.  Any changes to CopyProperties
// should be reflected in MergeProperties as well.
// Used with Http transport
//IMergeEnabledMessageProperty currentValue;
//if (!this.TryGetValue<IMergeEnabledMessageProperty>(property.Name, out currentValue) ||
//    !currentValue.TryMergeWithProperty(property.Value))
//{
// Merge wasn't possible so copy
// this[string] will call CreateCopyOfPropertyValue, so we don't need to repeat that here
//}
//this.Security = (properties.Security != null) ? (SecurityMessageProperty)properties.Security.CreateCopy() : null;
// this[string] will call CreateCopyOfPropertyValue, so we don't need to repeat that here
//case SecurityIndex:
//    return (object)security != null;
//if (this.security != null)
//{
//    this.security.Dispose();
//}
//case SecurityIndex:
//    value = security;
//    break;
//case SecurityIndex:
//    exists = (object)security != null;
//    break;
//case SecurityIndex:
//    if (Security != null)
//        Security.Dispose();
//    Security = (SecurityMessageProperty)CreateCopyOfPropertyValue(value);
//    break;
//if (this.security != null)
//    array[index++] = new KeyValuePair<string, object>(SecurityKey, this.security.CreateCopy());
//if (this.security != null)
//    pairs.Add(new KeyValuePair<string, object>(SecurityKey, security));
// MethodCall associates a MethodBase with the arguments to pass to it.
// protects state that may be reverted
//EventTraceActivity eventTraceActivity;
//if (result && FxTrace.Trace.IsEnd2EndActivityTracingEnabled && property.eventTraceActivity == null)
//{
//    property.eventTraceActivity = EventTraceActivityHelper.TryExtractActivity(message);
//}
// Abandon can never be reverted, release the state lock.
//if (TD.ReceiveContextAbandonWithExceptionIsEnabled())
//{
//    TD.ReceiveContextAbandonWithException(this.eventTraceActivity, this.GetType().ToString(), exception.GetType().ToString());
//}
//if (TD.ReceiveContextAbandonFailedIsEnabled())
//{
//    TD.ReceiveContextAbandonFailed(this.eventTraceActivity, this.GetType().ToString());
//}
// Abandon can never be reverted, release the state lock.
//if (TD.ReceiveContextAbandonWithExceptionIsEnabled())
//{
//    TD.ReceiveContextAbandonWithException(this.eventTraceActivity, this.GetType().ToString(), exception.GetType().ToString());
//}
//if (TD.ReceiveContextAbandonFailedIsEnabled())
//{
//    TD.ReceiveContextAbandonFailed(this.eventTraceActivity, this.GetType().ToString());
//}
// Case 1: State validation fails, release the lock.
// Case 2: No transaction, the state can never be reverted, release the lock.
// Case 3: Transaction, keep the lock until we know the transaction outcome (OnTransactionStatusNotification).
/*|| Transaction.Current == null*/)
//if (TD.ReceiveContextCompleteFailedIsEnabled())
//{
//    TD.ReceiveContextCompleteFailed(this.eventTraceActivity, this.GetType().ToString());
//}
// Case 1: State validation fails, release the lock.
// Case 2: No transaction, the state can never be reverted, release the lock.
// Case 3: Transaction, keep the lock until we know the transaction outcome (OnTransactionStatusNotification).
/*|| Transaction.Current == null*/)
//if (TD.ReceiveContextCompleteFailedIsEnabled())
//{
//    TD.ReceiveContextCompleteFailed(this.eventTraceActivity, this.GetType().ToString());
//}
// default implementation: delegate to non-exception overload, ignoring reason
// default implementation: delegate to non-exception overload, ignoring reason
//if (TD.ReceiveContextFaultedIsEnabled())
//{
//    TD.ReceiveContextFaulted(this.eventTraceActivity, this);
//}
//void OnTransactionStatusNotification(TransactionStatus status)
//{
//    lock (ThisLock)
//    {
//        if (status == TransactionStatus.Aborted)
//        {
//            if (this.State == ReceiveContextState.Completing || this.State == ReceiveContextState.Completed)
//            {
//                this.State = ReceiveContextState.Received;
//            }
//        }
//    }
//    if (status != TransactionStatus.Active)
//    {
//        this.ReleaseStateLock();
//    }
//}
//if (Transaction.Current != null)
//{
//    Transaction.Current.EnlistVolatile(new EnlistmentNotifications(this), EnlistmentOptions.None);
//}
// add the correlator key to the request, this will be needed for cleaning up the correlator table in case of 
// channel aborting or faulting while there are pending requests
// This method is used to remove the request from the correlator table when the
// reply is lost. This will avoid leaking the correlator table in cases where the 
// channel faults or aborts while there are pending requests.
//if (TraceUtility.PropagateUserActivity || TraceUtility.ShouldPropagateActivity)
//{
//    TraceUtility.AddAmbientActivityToMessage(request);
//}
//if (TraceUtility.PropagateUserActivity || TraceUtility.ShouldPropagateActivity)
//{
//    TraceUtility.AddAmbientActivityToMessage(reply);
//}
//if (TraceUtility.PropagateUserActivity || TraceUtility.ShouldPropagateActivity)
//{
//    TraceUtility.AddAmbientActivityToMessage(reply);
//}
// Note: even if address.IsAnonymous, it may have identity, reference parameters, etc.
// This class is sealed because the constructor could call Abort, which is virtual
//CallOnceManager autoDisplayUIManager;
//EventTraceActivity eventActivity;
// Only used by ServiceChannelFactory
//internal ServiceChannel(ServiceChannelFactory factory, IChannelBinder binder)
//    : this(binder, factory.MessageVersion, factory)
//{
//    this.factory = factory;
//    this.clientRuntime = factory.ClientRuntime;
//    this.SetupInnerChannelFaultHandler();
//    DispatchRuntime dispatch = factory.ClientRuntime.DispatchRuntime;
//    if (dispatch != null)
//    {
//        this.autoClose = dispatch.AutomaticInputSessionShutdown;
//    }
//    factory.ChannelCreated(this);
//}
//CallOnceManager AutoDisplayUIManager
//{
//    get
//    {
//        if (!this.explicitlyOpened && (this.autoDisplayUIManager == null))
//        {
//            this.EnsureAutoOpenManagers();
//        }
//        return this.autoDisplayUIManager;
//    }
//}
//internal EventTraceActivity EventActivity
//{
//    get
//    {
//        if (this.eventActivity == null)
//        {
//            //Take the id on the thread so that we know the initiating operation.
//            this.eventActivity = EventTraceActivity.GetFromThreadOrCreate();
//        }
//        return this.eventActivity;
//    }
//}
//if (this.IsClient)
//{
//    return factory.InternalCloseTimeout;
//}
//else
//{
//}
//internal ServiceChannelFactory Factory
//{
//    get { return this.factory; }
//}
//if (this.IsClient)
//{
//    return factory.InternalOpenTimeout;
//}
//else
//{
//}
// need to use "proxy" as open/close event source
// need to call this method after this.binder and this.clientRuntime are set to prevent a potential 
// NullReferenceException in this method or in the OnInnerChannelFaulted method; 
// because this method accesses this.binder and OnInnerChannelFaulted accesses this.clientRuntime.
//void BindDuplexCallbacks()
//{
//    IDuplexChannel duplexChannel = this.InnerChannel as IDuplexChannel;
//    if ((duplexChannel != null) && (this.factory != null) && (this.instanceContext != null))
//    {
//        if (this.binder is DuplexChannelBinder)
//            ((DuplexChannelBinder)this.binder).EnsurePumping();
//    }
//}
///// TASKS ******
// Doing a request reply callback when dispatching in-order deadlocks.
// We never receive the reply until we finish processing the current message.
//if (TraceUtility.MessageFlowTracingOnly)
//{
//    //always set a new ID if none provided
//    if (Trace.CorrelationManager.ActivityId == Guid.Empty)
//    {
//        rpc.ActivityId = Guid.NewGuid();
//        FxTrace.Trace.SetAndTraceTransfer(rpc.ActivityId, true);
//    }
//}
//if (rpc.Activity != null)
//{
//    TraceUtility.SetActivity(rpc.Request, rpc.Activity);
//    if (TraceUtility.ShouldPropagateActivity)
//    {
//        TraceUtility.AddActivityHeader(rpc.Request);
//    }
//}
//else if (TraceUtility.PropagateUserActivity || TraceUtility.ShouldPropagateActivity)
//{
//    TraceUtility.AddAmbientActivityToMessage(rpc.Request);
//}
//Attach and transfer Activity
//if (FxTrace.Trace.IsEnd2EndActivityTracingEnabled)
//{
//    TraceClientOperationPrepared(ref rpc);
//}
//TraceUtility.MessageFlowAtMessageSent(rpc.Request, rpc.EventTraceActivity);
//if (MessageLogger.LogMessagesAtServiceLevel)
//{
//    MessageLogger.LogMessage(ref rpc.Request, (oneway ? MessageLoggingSource.ServiceLevelSendDatagram : MessageLoggingSource.ServiceLevelSendRequest) | MessageLoggingSource.LastChance);
//}
//private void TraceClientOperationPrepared(ref ProxyRpc rpc)
//{
//    //Retrieve the old id on the RPC and attach the id on the message since we have a message id now.
//    Guid previousId = rpc.EventTraceActivity != null ? rpc.EventTraceActivity.ActivityId : Guid.Empty;
//    EventTraceActivity requestActivity = EventTraceActivityHelper.TryExtractActivity(rpc.Request);
//    if (requestActivity == null)
//    {
//        requestActivity = EventTraceActivity.GetFromThreadOrCreate();
//        EventTraceActivityHelper.TryAttachActivity(rpc.Request, requestActivity);
//    }
//    rpc.EventTraceActivity = requestActivity;
//    if (TD.ClientOperationPreparedIsEnabled())
//    {
//        string remoteAddress = string.Empty;
//        if (this.RemoteAddress != null && this.RemoteAddress.Uri != null)
//        {
//            remoteAddress = this.RemoteAddress.Uri.AbsoluteUri;
//        }
//        TD.ClientOperationPrepared(rpc.EventTraceActivity,
//                                    rpc.Action,
//                                    this.clientRuntime.ContractName,
//                                    remoteAddress,
//                                    previousId);
//    }
//}
//TraceServiceChannelCallStart(rpc.EventTraceActivity, true);
//using (rpc.Activity = DiagnosticUtility.ShouldUseActivity ? ServiceModelActivity.CreateBoundedActivity() : null)
//{
//    if (DiagnosticUtility.ShouldUseActivity)
//    {
//        ServiceModelActivity.Start(rpc.Activity, SR.Format(SR.ActivityProcessAction, action), ActivityType.ProcessAction);
//    }
//}
// TODO: Async
//if (TD.CloseTimeoutIsEnabled())
//{
//    TD.CloseTimeout(e.Message);
//}
//set the ID after response
//if (TraceUtility.MessageFlowTracingOnly && rpc.ActivityId != Guid.Empty)
//{
//    System.Runtime.Diagnostics.DiagnosticTraceBase.ActivityId = rpc.ActivityId;
//}
//TraceUtility.MessageFlowAtMessageReceived(rpc.Reply, null, rpc.EventTraceActivity, false);
//if (MessageLogger.LogMessagesAtServiceLevel)
//{
//    MessageLogger.LogMessage(ref rpc.Reply, MessageLoggingSource.ServiceLevelReceiveReply | MessageLoggingSource.LastChance);
//}
//if (TraceUtility.MessageFlowTracingOnly)
//{
//    if (rpc.ActivityId != Guid.Empty)
//    {
//        //reset the ID as it was created internally - ensures each call is uniquely correlatable
//        System.Runtime.Diagnostics.DiagnosticTraceBase.ActivityId = Guid.Empty;
//        rpc.ActivityId = Guid.Empty;
//    }
//}
//if (TD.ServiceChannelCallStopIsEnabled())
//{
//    string remoteAddress = string.Empty;
//    if (this.RemoteAddress != null && this.RemoteAddress.Uri != null)
//    {
//        remoteAddress = this.RemoteAddress.Uri.AbsoluteUri;
//    }
//    TD.ServiceChannelCallStop(rpc.EventTraceActivity, rpc.Action,
//                                this.clientRuntime.ContractName,
//                                remoteAddress);
//}
//if (string.Compare(code.Name, FaultCodeConstants.Codes.TransactionAborted, StringComparison.Ordinal) == 0)
//{
//    throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new ProtocolException(fault.Reason.GetMatchingTranslation(CultureInfo.CurrentCulture).Text));
//}
// throw SecurityAccessDeniedException explicitly
// MessageSecurity
//if (string.Compare(code.Namespace, SecurityVersion.Default.HeaderNamespace.Value, StringComparison.Ordinal) == 0)
//{
//    if (string.Compare(code.Name, SecurityVersion.Default.FailedAuthenticationFaultCode.Value, StringComparison.Ordinal) == 0)
//    {
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperWarning(new SecurityAccessDeniedException(fault.Reason.GetMatchingTranslation(CultureInfo.CurrentCulture).Text));
//    }
//}
//ServiceThrottle serviceThrottle = this.serviceThrottle;
//if (serviceThrottle != null)
//    serviceThrottle.DeactivateChannel();
//rollback the attached transaction if one is present
//if ((this.instanceContext != null) && this.HasSession)
//{
//    if (instanceContext.HasTransaction)
//    {
//        instanceContext.Transaction.CompletePendingTransaction(instanceContext.Transaction.Attached, new Exception()); // error!=null forces Tx rollback
//    }
//}
//if (this.InstanceContext != null && this.InstanceContext.HasTransaction)
//{
//    this.InstanceContext.CompleteAttachedTransaction();
//}
//ServiceThrottle serviceThrottle = this.serviceThrottle;
//if (serviceThrottle != null)
//{
//    serviceThrottle.DeactivateChannel();
//}
//this.TraceChannelOpenStarted();
//this.TraceChannelOpenCompleted();
//bool IContextChannel.AllowOutputBatching
//{
//    get { return this.allowOutputBatching; }
//    set { this.allowOutputBatching = value; }
//}
//void TraceChannelOpenStarted()
//{
//    if (TD.ClientChannelOpenStartIsEnabled() && this.endpointDispatcher == null)
//    {
//        TD.ClientChannelOpenStart(this.EventActivity);
//    }
//    else if (TD.ServiceChannelOpenStartIsEnabled())
//    {
//        TD.ServiceChannelOpenStart(this.EventActivity);
//    }
//    //if (DiagnosticUtility.ShouldTraceInformation)
//    //{
//    //    Dictionary<string, string> values = new Dictionary<string, string>(4);
//    //    bool traceNeeded = false;
//    //    DispatchRuntime behavior = this.DispatchRuntime;
//    //    if (behavior != null)
//    //    {
//    //        if (behavior.Type != null)
//    //        {
//    //            values["ServiceType"] = behavior.Type.AssemblyQualifiedName;
//    //        }
//    //        values["ContractNamespace"] = this.clientRuntime.ContractNamespace;
//    //        values["ContractName"] = this.clientRuntime.ContractName;
//    //        traceNeeded = true;
//    //    }
//    //    if ((this.endpointDispatcher != null) && (this.endpointDispatcher.ListenUri != null))
//    //    {
//    //        values["Uri"] = this.endpointDispatcher.ListenUri.ToString();
//    //        traceNeeded = true;
//    //    }
//    //    if (traceNeeded)
//    //    {
//    //        TraceUtility.TraceEvent(TraceEventType.Information, TraceCode.ServiceChannelLifetime,
//    //            SR.Format(SR.TraceCodeServiceChannelLifetime),
//    //            new DictionaryTraceRecord(values), this, null);
//    //    }
//    //}
//}
//void TraceChannelOpenCompleted()
//{
//    if (this.endpointDispatcher == null && TD.ClientChannelOpenStopIsEnabled())
//    {
//        TD.ClientChannelOpenStop(this.EventActivity);
//    }
//    else if (TD.ServiceChannelOpenStopIsEnabled())
//    {
//        TD.ServiceChannelOpenStop(this.EventActivity);
//    }
//}
//static void TraceServiceChannelCallStart(EventTraceActivity eventTraceActivity, bool isSynchronous)
//{
//    if (TD.ServiceChannelCallStartIsEnabled())
//    {
//        if (isSynchronous)
//        {
//            TD.ServiceChannelCallStart(eventTraceActivity);
//        }
//        else
//        {
//            TD.ServiceChannelBeginCallStart(eventTraceActivity);
//        }
//    }
//}
// Invariants for signalling the CallOnce manager.
//
// 1) If a Call, BeginCall, or EndCall on the channel throws,
//    the manager will SignalNext itself.
// 2) If a Waiter times out, it will SignalNext its manager
//    once it is both timed out and signalled.
// 3) Once Call or EndCall returns successfully, it guarantees
//    that SignalNext will be called once the // next stage
//    has sufficiently completed.
// This reads lastActivity atomically without changing its value.
// (it only sets if it is zero, and then it sets it to zero).
//if (TD.SessionIdleTimeoutIsEnabled())
//{
//    string listenUri = string.Empty;
//    if (this.binder.ListenUri != null)
//    {
//        listenUri = this.binder.ListenUri.AbsoluteUri;
//    }
//    TD.SessionIdleTimeout(listenUri);
//}
// ServiceChannelProxy serves 2 roles.  It is the TChannel proxy called by the client,
// and it is also the handler of those calls that dispatches them to the appropriate service channel.
// In .Net Remoting terms, it is conceptually the same as a RealProxy and a TransparentProxy combined.
//Workaround is to set the activityid in remoting call's LogicalCallContext
// Override ToString() to reveal only the expected proxy type, not the generated one
//string activityName = null;
//ActivityType activityType = ActivityType.Unknown;
//if (DiagnosticUtility.ShouldUseActivity)
//{
//    if (ServiceModelActivity.Current == null ||
//        ServiceModelActivity.Current.ActivityType != ActivityType.Close)
//    {
//        MethodData methodData = this.GetMethodData(methodCall);
//        if (methodData.MethodBase.DeclaringType == typeof(System.ServiceModel.ICommunicationObject)
//            && methodData.MethodBase.Name.Equals("Close", StringComparison.Ordinal))
//        {
//            activityName = SR.Format(SR.ActivityClose, _serviceChannel.GetType().FullName);
//            activityType = ActivityType.Close;
//        }
//    }
//}
//using (ServiceModelActivity activity = string.IsNullOrEmpty(activityName) ? null : ServiceModelActivity.CreateBoundedActivity())
//{
//    if (DiagnosticUtility.ShouldUseActivity)
//    {
//        ServiceModelActivity.Start(activity, activityName, activityType);
//    }
//}
// These channel methods exist only to implement additional channel interfaces for ServiceChannelProxy.
// This is required because clients can down-cast typed proxies to the these channel interfaces.
// On the desktop, the .Net Remoting layer allowed that type cast, and subsequent calls against the
// interface went back through the RealProxy and invoked the underlying ServiceChannel.
// Net Native and CoreClr do not have .Net Remoting and therefore cannot use that mechanism.
// But because typed proxies derive from ServiceChannelProxy, implementing these interfaces
// on ServiceChannelProxy permits casting the typed proxy to these interfaces.
// All interface implementations delegate directly to the underlying ServiceChannel.
//Uri IClientChannel.Via
//{
//    get { return _serviceChannel.Via; }
//}
//bool IContextChannel.AllowOutputBatching
//{
//    get
//    {
//        return ((IContextChannel)_serviceChannel).AllowOutputBatching;
//    }
//    set
//    {
//        ((IContextChannel)_serviceChannel).AllowOutputBatching = value;
//    }
//}
// Channel interfaces
// Used for client but there's public api which need this and the compiler complains it's never assigned
// TODO: Solve issue with GetToken/GetTokenAsync needing timeouts and there is only a token available
// for audit
// callback from schannel
// Note: add ref to handle since the caller will reset the cert after the callback return.
// works after call to AcceptUpgrade
// this could be null if upgrade not completed.
//internal static ContentEncoding[] Soap11Content = GetContentEncodingMap(MessageVersion.Soap11WSAddressing10);
// I believe replacing Soap11WSAddressing10 with Soap11 should work
// Check for known/expected content types
// then some heuristic matches (since System.Mime.ContentType is a performance hit)
// start by looking for a parameter. 
// If none exists, we don't have an encoding
// optimize for charset being the first parameter
// for Indigo scenarios, we'll have "; charset=", so check for the c
// need room for parameter + charset + '=' 
// look for charset= somewhere else in the message
// validate there's only whitespace or semi-colons beforehand
// we have a possible charset value. If it's easy to parse, do so
// get the next semicolon
// and some minimal quote stripping
// our quick heuristics failed. fall back to System.Net
// Double-checked locking pattern requires volatile for read/write synchronization
// we support a few extra content types for "none"
// application/xml checked by base method
// TODO: Use the reinitialization API's once moved to .Net Standard 2.0
//else
//{
//    ((IXmlTextWriterInitializer)xmlWriter).SetOutput(stream, this.writeEncoding, false);
//}
// TODO: Use the reinitialization API's once moved to .Net Standard 2.0
//streamedWriterPool.Return((XmlDictionaryWriter)xmlWriter);
// TODO: Use the reinitialization API's once moved to .Net Standard 2.0
//else
//{
//    ((IXmlTextReaderInitializer)xmlReader).SetInput(stream, enc, this.readerQuotas, onStreamedReaderClose);
//}
// TODO: Use the reinitialization API's once moved to .Net Standard 2.0
/*this.encoding,*/ Quotas/*, onClose*/);
// TODO: Use the reinitialization API's once moved to .Net Standard 2.0
//else
//{
//    ((IXmlTextReaderInitializer)xmlReader).SetInput(buffer.Array, buffer.Offset, buffer.Count, this.encoding, this.Quotas, onClose);
//}
//XmlDictionaryWriter writer;
//XmlDictionaryWriter returnedWriter = writer;
//if (returnedWriter == null)
//{
//    returnedWriter = XmlDictionaryWriter.CreateTextWriter(stream, messageEncoder.writeEncoding, false);
//}
//else
//{
//    writer = null;
//    ((IXmlTextWriterInitializer)returnedWriter).SetOutput(stream, messageEncoder.writeEncoding, false);
//}
//return returnedWriter;
// TODO: Use IXmlTextWriterInitializer when moved to .Net Standard 2.0
// TODO: Use IXmlTextWriterInitializer reuse once moved to .Net Standard 2.0
//if (messageEncoder.optimizeWriteForUTF8)
//{
//    if (this.writer == null)
//        this.writer = writer;
//}
// compare XmlDictionaryReaderQuotas
// to cover all our bases, let's iterate through the BindingParameters to make sure
// we haven't missed a query (since we're the Transport and we're at the bottom)
// Ignore.  Ambiguous charSet, so autodetect.
// CharSet omitted, so autodetect.
// Quick check for exact equality
// Check for case insensitive match
// used by server WindowsStream security (from Open)
// core Cred lookup code
// Initialize to the default value if no token provided. A partial trust app should not have access to the
// default network credentials but should be able to provide credentials. The DefaultNetworkCredentials
// getter will throw under partial trust.
// Ensure that baseAddress Path does end with a slash if we have a relative address
// Moved from TcpChannelListener
// TODO: Remove once moved to .Net Standard 1.7
//if (isClient)
//{
//    credentialProvider = ClientCredentials.CreateDefaultCredentials();
//}
//else
//{
//ServiceCredentials.CreateDefaultCredentials();
//}
// If the server credential is null, then we have not been opened yet and have no identity to expose.
// wrap stream
// authenticate
// When NegotiateStream returns a WindowsIdentity the AuthenticationType is passed in the constructor to WindowsIdentity
// by it's internal NegoState class.  If this changes, then the call to remoteIdentity.AuthenticationType could fail if the 
// current process token doesn't have sufficient privileges.  It is a first class exception, and caught by the CLR
// null is returned.
// check if the item exists in the collection
// TODO: Either find an existing SR to use or create a new one.
// TODO : Error handling if TBE doesn't exist
// Not implemented yet. Commented code is for how things will work in the future.
//svc.UseMiddleware(transportMiddlewareType);
//ProtectionLevel protectionLevel;
//bool hasProtectionLevel;
// the property setter validates given value
// ns can be ""
/*isEncoded*/);
// ParameterInfo.GetCustomAttributes can return null instead of an empty enumerable
// Only if we don't find the CoreWCF attribute, look for the S.SM attribute
// ProtectionLevel isn't supported yet so if it was set on the S.SM.SCA, then we can't do the mapping so throw
// ProtectionLevel isn't supported yet so if it was set on the S.SM.SCA, then we can't do the mapping so throw
// String.Empty apparently is fine
// String.Empty apparently is fine
// TODO: IsInitiating and IsTerminating
//, IWsdlExportExtension
// TODO: Reenable SecurityValidationBehavior validation
//(SecurityValidationBehavior.Instance as IServiceBehavior).Validate(description, serviceHost);
// TODO: Make sure the InternalBaseAddresses are populated with the relevant base address for the transport via DI
// TODO: Plumb through expected scheme and update exception message
// VSWhidbey#541152: new Uri(Uri, string.Empty) is broken
// Ensure ListenUri and group endpoints per ListenUri
// same EndpointAddressTable instance must be shared between channelDispatcher and parameters
//ThreadSafeMessageFilterTable<EndpointAddress> endpointAddressTable = new ThreadSafeMessageFilterTable<EndpointAddress>();
//parameters.Add(endpointAddressTable);
// add service-level binding parameters
// ensure all endpoints with this ListenUriInfo have same binding
// ensure all endpoints with this ListenUriInfo have same identity
// add binding parameters (endpoint scope and below)
//channelDispatcher.SetEndpointAddressTable(endpointAddressTable);
//EndpointFilterProvider provider = new EndpointFilterProvider();
/*provider*/ null));
// end foreach "endpoint"
// end foreach "ListenUri/ChannelDispatcher" group
// run service behaviors
// rediscover which dispatcher goes with this endpoint
// run contract behaviors
// run endpoint behaviors
// run operation behaviors
// Warn about obvious demux conflicts
// all elements of endpointInfos share the same Address (and thus EndpointListener.AddressFilter)
// if not same ListenUri, won't conflict
// if not same ChannelType, may not conflict (some transports demux based on this)
// if they share a ChannelDispatcher, this means same ListenUri and same ChannelType
// if not default EndpointFilterProvider, we won't try to throw, you're on your own
// you will definitely get a MultipleFiltersMatchedException at runtime,
// so let's go ahead and throw now
//dispatcher.SetSupportedChannels(DispatcherBuilder.GetSupportedChannelTypes(contractDescription));
// TODO: Create internal behavior which configures any extensibilities which exist in serviceProvider, eg IMessageInspector
// TODO: Add error checking to make sure property chain is correctly populated with objects
// No sync code for .Net Core
// get Contract info security needs, and put in BindingParameterCollection
// ensure existence of binding parameter
// use endpoint.Binding.Version
// This binding does not support response actions, so...
// implement Equals and GetHashCode so that we can use this as a key in a dictionary
/* ignoreCase */, true /* includeHost */);
/* includeHost */);
// InnerClasses
// Not serializable on purpose, metadata import/export cannot
// produce it, only available when binding to runtime
/*isEncoded*/)); }
// By default, when the TypeLoader sees an IContractBehavior attribute on a service implementation class, 
// it will add that behavior to each contract (endpoint) the service implements.  But if the attribute
// implements the interface below, then the TypeLoader will only add the behavior to the applicable contracts.
/*isEncoded*/); }
//XmlQualifiedName xsdType;
//ProtectionLevel protectionLevel;
//bool hasProtectionLevel;
// TODO: Was ICustomAttributeProvider
//string baseType;
/*isEncoded*/);
//this.hasProtectionLevel = other.hasProtectionLevel;
//this.protectionLevel = other.protectionLevel;
//this.baseType = other.baseType;
//this.uniquePartName = other.uniquePartName;
// TODO: Make public and add to contract
//schemas.microsoft.com/2011/02/session/onopen"; //Channels.WebSocketTransportSettings.ConnectionOpenedAction;
/*isEncoded*/);
// Not serializable on purpose, metadata import/export cannot
// produce it, only available when binding to runtime
// Not serializable on purpose, metadata import/export cannot
// produce it, only available when binding to runtime
// Not serializable on purpose, metadata import/export cannot
// produce it, only available when binding to runtime
// Not serializable on purpose, metadata import/export cannot
// produce it, only available when binding to runtime
// Messages[0] is the 'request' (first of MEP), and for non-oneway MEPs, Messages[1] is the 'response' (second of MEP)
// TODO: ServiceMetadataBehavior reference needs to be put back once we have MetadataBehavior
/*&& !ServiceMetadataBehavior.IsHttpGetMetadataDispatcher(description, channelDispatcher)*/)
//IssuedTokenServiceCredential issuedToken;
//SecureConversationServiceCredential secureConversation;
//bool useIdentityConfiguration = false;
//this.issuedToken = new IssuedTokenServiceCredential();
//this.secureConversation = new SecureConversationServiceCredential();
//this.issuedToken = new IssuedTokenServiceCredential(other.issuedToken);
//this.secureConversation = new SecureConversationServiceCredential(other.secureConversation);
//public IssuedTokenServiceCredential IssuedTokenAuthentication
//{
//    get
//    {
//        return this.issuedToken;
//    }
//}
//public SecureConversationServiceCredential SecureConversationAuthentication
//{
//    get
//    {
//        return this.secureConversation;
//    }
//}
/// <summary>
/// Gets or sets the ExceptionMapper to be used when throwing exceptions.
/// </summary>
// throw if bindingParameters already has a SecurityCredentialsManager
// TODO: ServiceMetadataBehavior
//if (channelDispatcher != null && !ServiceMetadataBehavior.IsHttpGetMetadataDispatcher(description, channelDispatcher))
//{
//    foreach (EndpointDispatcher endpointDispatcher in channelDispatcher.Endpoints)
//    {
//        DispatchRuntime behavior = endpointDispatcher.DispatchRuntime;
//        behavior.RequireClaimsPrincipalOnOperationContext = this.useIdentityConfiguration;
//    }
//}
//this.IssuedTokenAuthentication.MakeReadOnly();
//this.SecureConversationAuthentication.MakeReadOnly();
// the XmlName ctor validate the value
/*isEncoded*/);
// This was KeyedByTypeCollection, maybe change to Collection<IServiceBehavior>
// TODO: I made this internal, evaluate making it public as it is on full framework
// TODO: Make ServiceDescription generic?
// TODO: What if the concrete type is different that the generic type?
//serviceImplementation.GetType();
//internal static object CreateImplementation(Type serviceType)
//{
//    var constructors = serviceType.GetConstructors(TypeLoader.DefaultBindingFlags);
//    ConstructorInfo constructor = null;
//    foreach (var constr in constructors)
//    {
//        if (constr.GetParameters().Length == 0)
//        {
//            constructor = constr;
//            break;
//        }
//    }
//    if (constructor == null)
//    {
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(
//            SR.SFxNoDefaultConstructor));
//    }
//    return constructor.Invoke(null, null);
//}
// This method ensures that the description object graph is structurally sound and that none
// of the fundamental SFx framework assumptions have been violated.
// implementation will only be null if not provided using DI
/*isEncoded*/);
// This method ensures that the description object graph is structurally sound and that none
// of the fundamental SFx framework assumptions have been violated.
//Binding.EnsureInvariants(Contract.Name);
// for V1 legacy reasons, a mex endpoint is considered a system endpoint even if IsSystemEndpoint = false
//if (ServiceMetadataBehavior.IsMetadataEndpoint(description, this))
//{
//    return true;
//}
// This method runs validators (both builtin and ones in description).  
// Precondition: EnsureInvariants() should already have been called.
// contract behaviors
// endpoint behaviors
// operation behaviors
//using System.Xml;
//tempuri.org/";
//schemas.microsoft.com/2005/07/ServiceModel";
// simplified rules for appending paths to base URIs. note that this differs from new Uri(baseUri, string)
// 1) CombineUriStrings("http://foo/bar/z", "baz") ==> "http://foo/bar/z/baz"
// 2) CombineUriStrings("http://foo/bar/z/", "baz") ==> "http://foo/bar/z/baz"
// 3) CombineUriStrings("http://foo/bar/z", "/baz") ==> "http://foo/bar/z/baz"
// 4) CombineUriStrings("http://foo/bar/z", "http://baz/q") ==> "http://baz/q"
// 5) CombineUriStrings("http://foo/bar/z", "") ==> ""
// combine
// name, ns could have any combination of nulls
// ns can be empty
// name could be null
// logicalMethodName is MethodInfo.Name with Begin removed for async pattern
// return encoded version to be used in OperationDescription
//internal static string GetMessageAction(OperationDescription operation, bool isResponse)
//{
//    ContractDescription contract = operation.DeclaringContract;
//    XmlQualifiedName contractQname = new XmlQualifiedName(contract.Name, contract.Namespace);
//    return GetMessageAction(contractQname, operation.CodeName, null, isResponse);
//}
// name could be null
// logicalMethodName is MethodInfo.Name with Begin removed for async pattern
//internal delegate bool DoesNameExist(string name, object nameCollection);
//internal static string GetUniqueName(string baseName, DoesNameExist doesNameExist, object nameCollection)
//{
//    for (int i = 0; i < Int32.MaxValue; i++)
//    {
//        string name = i > 0 ? baseName + i : baseName;
//        if (!doesNameExist(name, nameCollection))
//        {
//            return name;
//        }
//    }
//    Fx.Assert("Too Many Names");
//    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(String.Format(CultureInfo.InvariantCulture, "Cannot generate unique name for name {0}", baseName)));
//}
// Converts names that contain characters that are not permitted in XML names to valid names.
// Transforms an XML name into an object name.
/*allowNull*/);
//    bool Matches(XmlName xmlName)
//    {
//        return string.Equals(this.EncodedName, xmlName.EncodedName, StringComparison.Ordinal);
//    }
//    public override bool Equals(object obj)
//    {
//        if (object.ReferenceEquals(obj, this))
//        {
//            return true;
//        }
//        if (object.ReferenceEquals(obj, null))
//        {
//            return false;
//        }
//        XmlName xmlName = obj as XmlName;
//        if (xmlName == null)
//        {
//            return false;
//        }
//        return Matches(xmlName);
//    }
//    public override int GetHashCode()
//    {
//        if (string.IsNullOrEmpty(EncodedName))
//            return 0;
//        return EncodedName.GetHashCode();
//    }
//    public override string ToString()
//    {
//        if (encoded == null && decoded == null)
//            return null;
//        if (encoded != null)
//            return encoded;
//        return decoded;
//    }
//    public static bool operator ==(XmlName a, XmlName b)
//    {
//        if (object.ReferenceEquals(a, null))
//        {
//            return object.ReferenceEquals(b, null);
//        }
//        return (a.Equals(b));
//    }
//    public static bool operator !=(XmlName a, XmlName b)
//    {
//        return !(a == b);
//    }
// Fast path for CoreWCF.ServiceContractAttribute
// GetCustomAttributesData doesn't traverse the inheritence chain so this is the equivalent of IsDefined(..., false)
// returns the set of root interfaces for the service class (meaning doesn't include callback ifaces)
// where the exception is CustomAttributeFormatException and the InnerException is a TargetInvocationException, 
// drill into the InnerException as this will provide a better error experience (fewer nested InnerExceptions)
// there is no good way to know if this is a return type attribute
//static internal T GetSingleAttribute<T>(MethodInfo attrProvider)
//    where T : class
//{
//    Type attrType = typeof(T);
//    object[] attrs = GetCustomAttributes(attrProvider, attrType);
//    if (attrs.Length == 0)
//    {
//        return null;
//    }
//    else if (attrs.Length > 1)
//    {
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.tooManyAttributesOfTypeOn2, attrType, attrProvider.ToString())));
//    }
//    else
//    {
//        return attrs[0] as T;
//    }
//}
//static internal T GetSingleAttribute<T>(ICustomAttributeProvider attrProvider)
//    where T : class
//{
//    Type attrType = typeof(T);
//    object[] attrs = GetCustomAttributes(attrProvider, attrType);
//    if (attrs.Length == 0)
//    {
//        return null;
//    }
//    else if (attrs.Length > 1)
//    {
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.tooManyAttributesOfTypeOn2, attrType, attrProvider.ToString())));
//    }
//    else
//    {
//        return attrs[0] as T;
//    }
//}
//        static internal Type GetContractType(Type interfaceType)
//        {
//            ServiceContractAttribute contractAttribute;
//            return GetContractTypeAndAttribute(interfaceType, out contractAttribute);
//        }
// The metadata for "in" versus "out" seems to be inconsistent, depending upon what compiler generates it.
// The following code assumes this is the truth table that all compilers will obey:
// 
// True Parameter Type     .IsIn      .IsOut    .ParameterType.IsByRef
//
// in                        F          F         F         ...OR...
// in                        T          F         F
//
// in/out                    T          T         T         ...OR...
// in/out                    F          F         T
//
// out                       F          T         T
// conceptually both "in" and "in/out" params return true
// conceptually both "out" and "in/out" params return true
// for async method is the begin method
// length of parameters we care about (-2 for async)
// count the ins
// grab the ins
// for async method is the end method
// length of parameters we care about (-1 for async)
// count the outs
// grab the outs
// length of parameters we care about (-1 for async)
// count the outs
//        static internal XmlName GetOperationName(MethodInfo method)
//        {
//            OperationContractAttribute operationAttribute = GetOperationContractAttribute(method);
//            return NamingHelper.GetOperationName(GetLogicalName(method), operationAttribute.Name);
//        }
// no other method (sync, async) is allowed to co-exist with a task-based method on the server-side.
// no out/ref parameter is allowed on the client-side.
//using System.Diagnostics.CodeAnalysis;
//static Type[] knownTypesMethodParamType = new Type[] { typeof(ICustomAttributeProvider) };
//internal static XmlSerializerFormatAttribute DefaultXmlSerializerFormatAttribute = new XmlSerializerFormatAttribute();
// IContractBehaviors
// we only need to check base _classes_ here, the check for interfaces happens elsewhere
// if not [ServiceContract]
// but does have an OperationContractAttribute
//public ContractDescription LoadContractDescription(Type contractType)
//{
//    Fx.Assert(contractType != null, "");
//    return LoadContractDescriptionHelper(contractType, null, null);
//}
// look for IOperationBehaviors on implementation methods in service class hierarchy
// then look for IOperationBehaviors on interface type
//operationDescription.Behaviors.Add(new DataContractSerializerOperationGenerator());
// The named method must take a parameter of ICustomAttributeProvider which isn't available so this can only specify known types by Type
//if (knownTypeAttributes.Length == 1)
//{
//    ServiceKnownTypeAttribute knownTypeAttribute = (ServiceKnownTypeAttribute)knownTypeAttributes[0];
//    if (!string.IsNullOrEmpty(knownTypeAttribute.MethodName))
//    {
//        Type type = knownTypeAttribute.DeclaringType;
//        if (type == null)
//        {
//            type = (provider as TypeInfo)?.AsType();
//            if (type == null)
//                type = ((MethodInfo)provider).DeclaringType;
//        }
//        type.GetMethods()
//        MethodInfo method = type.GetMethod(knownTypeAttribute.MethodName, BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public, null, knownTypesMethodParamType, null);
//        if (method == null)
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.SFxKnownTypeAttributeUnknownMethod3, provider, knownTypeAttribute.MethodName, type.FullName)));
//        if (!typeof(IEnumerable<Type>).IsAssignableFrom(method.ReturnType))
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.SFxKnownTypeAttributeReturnType3, provider, knownTypeAttribute.MethodName, type.FullName)));
//        return (IEnumerable<Type>)method.Invoke(null, new object[] { provider });
//    }
//}
// implType does not implement any methods from the targetIface, so there is nothing to do
// if opMethod doesn't exist in the interfacemap, it means opMethod was on
// the "other" interface (not the one implemented by implType)
// C++ allows you to create abstract classes that have missing interface method
// implementations, which shows up as nulls in the interfacemapping
// Returns true if the given methods match in name and parameter types
// Returns true if 2 ParameterInfo's match in signature with respect
// to the MemberInfo's in which they are declared. Position is required
// to match but name is not.
// Null is possible for a ParameterInfo from MethodInfo.ReturnParameter.
// If both are null, we have no information to compare and say they are equal.
//        internal void AddBehaviorsSFx(ServiceEndpoint serviceEndpoint, Type contractType)
//        {
//            if (serviceEndpoint.Contract.IsDuplex())
//            {
//                CallbackBehaviorAttribute attr = serviceEndpoint.Behaviors.Find<CallbackBehaviorAttribute>();
//                if (attr == null)
//                {
//                    serviceEndpoint.Behaviors.Insert(0, new CallbackBehaviorAttribute());
//                }
//            }
//        }
//        internal void AddBehaviorsFromImplementationType(ServiceEndpoint serviceEndpoint, Type implementationType)
//        {
//            foreach (IEndpointBehavior behaviorAttribute in ServiceReflector.GetCustomAttributes(implementationType, typeof(IEndpointBehavior), false))
//            {
//                if (behaviorAttribute is CallbackBehaviorAttribute)
//                {
//                    serviceEndpoint.Behaviors.Insert(0, behaviorAttribute);
//                }
//                else
//                {
//                    serviceEndpoint.Behaviors.Add(behaviorAttribute);
//                }
//            }
//            foreach (IContractBehavior behaviorAttribute in ServiceReflector.GetCustomAttributes(implementationType, typeof(IContractBehavior), false))
//            {
//                serviceEndpoint.Contract.Behaviors.Add(behaviorAttribute);
//            }
//            Type targetIface = serviceEndpoint.Contract.CallbackContractType;
//            for (int i = 0; i < serviceEndpoint.Contract.Operations.Count; i++)
//            {
//                OperationDescription opDesc = serviceEndpoint.Contract.Operations[i];
//                KeyedByTypeCollection<IOperationBehavior> opBehaviors = new KeyedByTypeCollection<IOperationBehavior>();
//                // look for IOperationBehaviors on implementation methods in callback class hierarchy
//                ApplyServiceInheritance<IOperationBehavior, KeyedByTypeCollection<IOperationBehavior>>(
//                    implementationType, opBehaviors,
//                    delegate (Type currentType, KeyedByTypeCollection<IOperationBehavior> behaviors)
//                    {
//                        KeyedByTypeCollection<IOperationBehavior> toAdd =
//                            GetIOperationBehaviorAttributesFromType(opDesc, targetIface, currentType);
//                        for (int j = 0; j < toAdd.Count; j++)
//                        {
//                            behaviors.Add(toAdd[j]);
//                        }
//                    });
//                // a bunch of default IOperationBehaviors have already been added, which we may need to replace
//                for (int k = 0; k < opBehaviors.Count; k++)
//                {
//                    IOperationBehavior behavior = opBehaviors[k];
//                    Type t = behavior.GetType();
//                    if (opDesc.Behaviors.Contains(t))
//                    {
//                        opDesc.Behaviors.Remove(t);
//                    }
//                    opDesc.Behaviors.Add(behavior);
//                }
//            }
//        }
/*isEncoded*/);
//Checks whether that the Callback contract provided on a ServiceContract follows rules
//1. It has to be a interface
//2. If its a class then it needs to implement MarshallByRefObject
// checks a contract for substitutability (in the Liskov Substitution Principle sense), throws on error
// we must be covariant in our callbacks
// MessageSecurity not supported
//if (contractAttr.HasProtectionLevel)
//{
//    contractDescription.ProtectionLevel = contractAttr.ProtectionLevel;
//}
// reflect the methods in contractType and add OperationDescriptions to ContractDescription
// get inherited operations
// in a diamond hierarchy, ensure we don't add same op twice from two different parents
// ensure two different parents don't try to add conflicting operations
// this contract 
// CallbackContract 
//Sync and Async should follow the rules:
//    1. Parameter match
//    2. Async cannot have behaviors (verification happens later in ProcessOpMethod - behaviors haven't yet been loaded here)
//    3. Async cannot have known types
//    4. Async cannot have known faults
//    5. Sync and Async have to match on OneWay status
//    6. Sync and Async have to match Action and ReplyAction
// "direction" is the "direction of the interface" (from the perspective of the server, as usual):
//    proxy interface on client: MessageDirection.Input
//    callback interface on client: MessageDirection.Output
//    service interface (or class) on server: MessageDirection.Input
//    callback interface on server: MessageDirection.Output
// if we have already seen a task-based method with the same name, we need to throw.
// Task vs. Sync 
// Task vs. Async
// Async vs. Sync
// Async vs. Task
// Sync vs. Task
// Sync vs. Async
//operationDescription.IsInitiating = opAttr.IsInitiating;
//operationDescription.IsTerminating = opAttr.IsTerminating;
//if (opAttr.HasProtectionLevel)
//{
//    operationDescription.ProtectionLevel = opAttr.ProtectionLevel;
//}
/*isResponse*/));
//if (attr.HasProtectionLevel)
//{
//    fault.ProtectionLevel = attr.ProtectionLevel;
//}
/*inherit*/))
/*inherit*/))
/*inherit*/))
// This function factors out the logic of how programming model attributes interact with service inheritance.
//
// To use this, just call ApplyServiceInheritance() with
//  - the service type you want to pull behavior attributes from
//  - the "destination" behavior collection, where all the right behavior attributes should be added to
//  - a delegate
// The delegate is just a function you write that behaves like this: 
//    imagine that "currentType" was the only type (imagine there was no inheritance hierarchy)
//    find desired behavior attributes on this type, and add them to "behaviors"
// ApplyServiceInheritance then uses the logic you provide for getting behavior attributes from a single type, 
// and it walks the actual type hierarchy and does the inheritance/override logic for you.
// work our way up the class hierarchy, looking for attributes; adding "bottom up" so that for each
// type of attribute, we only pick up the bottom-most one (the one attached to most-derived class)
// To use this, just call AddBehaviorsAtOneScope() with
//  - the type you want to pull behavior attributes from
//  - the "destination" behavior collection, where all the right behavior attributes should be added to
//  - a delegate
// The delegate is just a function you write that behaves like this: 
//    imagine that "currentType" was the only type (imagine there was no inheritance hierarchy)
//    find desired behavior attributes on this type, and add them to "behaviors"
// AddBehaviorsAtOneScope then uses the logic you provide for getting behavior attributes from a single type, 
// and it does the override logic for you (only add the behavior if it wasn't already in the descriptionBehaviors)
// toAdd now contains the set of behaviors we'd add if this type (scope) were the only source of behaviors
// if we didn't already see this type of attribute at a previous scope
// then it belongs in the final result
// used by System.ServiceModel.Web
//operation.Behaviors.Add(new XmlSerializerOperationGenerator(new XmlSerializerImportOptions()));
// helper for reflecting operations
// auto-reflects the operation, returning null if no attribute was found or inherited
// overrides the auto-reflection with an attribute
/*reflectOnDemand*/);
// keyBase needs to be unique within the scope of the parent reflector
//XmlAnyElementAttribute does not apply
// In the original full framework code using XmlAttributes, the XmlAnyElements collection is cleared
// if the XmlIgnore attribute is present.
// XmlIgnore overrides all so no need to continue if found.
// no need to create serializer
// TODO: SoapIgnoreAttribute is in 1.7
//if (member.IsDefined(typeof(SoapIgnoreAttribute), false/*inherit*/))
/*inherit*/))
//    continue;
/*isRpc*/, IsEncoded, false/*isWrapped*/);
/*isWrapped*/, false /*isRpc*/, mappingKey);
/*isEncoded*/), ns, members, hasWrapperElement, rpc, IsEncoded, key);
// the number of reflection members is always 1 because there is only one fault detail type
/*memberName*/, faultElementName, faultNamespace, fault.DetailType,
/*additionalAttributesProvider*/, false /*isMultiple*/, IsEncoded, false /*isWrapped*/);
/*hasWrapperElement*/, IsRpc, mappingKey);
// TODO: Available in 1.7
//SoapReflectionImporter soapImporter;
//this.soapImporter = null;
//SoapReflectionImporter SoapImporter
//{
//    get
//    {
//        if (this.soapImporter == null)
//        {
//            this.soapImporter = new SoapReflectionImporter(NamingHelper.CombineUriStrings(defaultNs, "encoded"));
//        }
//        return this.soapImporter;
//    }
//}
//mapping = this.SoapImporter.ImportMembersMapping(mappingName, ns, members, hasWrapperElement, rpc);
//return this.SoapImporter.ImportTypeMapping(type);
//this.SoapImporter.IncludeType(knownType);
// returns a stub to a serializer
//this.Mappings may have duplicate mappings (for e.g. same message contract is used by more than one operation)
//XmlSerializer.FromMappings require unique mappings. The following code uniquifies, calls FromMappings and deuniquifies
/*isEncoded*/);
//member.SoapAttributes = new SoapAttributes(additionalAttributesProvider);
// TODO: Work out how TraceUtility fits in with all the other exception and tracing classes
// If the message is closed, we won't get an activity
//Guid activityId = TraceUtility.ExtractActivityId(message);
//if (DiagnosticUtility.ShouldTraceError)
//{
//    DiagnosticUtility.DiagnosticTrace.TraceEvent(TraceEventType.Error, TraceCode.ThrowingException, GenerateMsdnTraceCode(TraceCode.ThrowingException),
//        TraceSR.Format(TraceSR.ThrowingException), null, exception, activityId, null);
//}
//if (DiagnosticUtility.ShouldTraceError)
//{
//    DiagnosticUtility.DiagnosticTrace.TraceEvent(TraceEventType.Error, TraceCode.ThrowingException, GenerateMsdnTraceCode(TraceCode.ThrowingException),
//        TraceSR.Format(TraceSR.ThrowingException), null, exception, activityId, source);
//}
//if (DiagnosticUtility.ShouldTraceWarning)
//{
//    StringTraceRecord record = new StringTraceRecord("Comment",
//        SR.Format(SR.SFxUserCodeThrewException, method.DeclaringType.FullName, method.Name));
//    DiagnosticUtility.DiagnosticTrace.TraceEvent(TraceEventType.Warning,
//        TraceCode.UnhandledExceptionInUserOperation, GenerateMsdnTraceCode(TraceCode.UnhandledExceptionInUserOperation),
//        SR.Format(SR.TraceCodeUnhandledExceptionInUserOperation, method.DeclaringType.FullName, method.Name),
//        record,
//        e, null);
//}
//if (DiagnosticUtility.ShouldTraceInformation)
//{
//    EndpointAddress endpointAddress = null;
//    if (dispatcher != null)
//    {
//        endpointAddress = dispatcher.EndpointAddress;
//    }
//    TraceUtility.TraceEvent(TraceEventType.Information, TraceCode.DroppedAMessage,
//        SR.Format(SR.TraceCodeDroppedAMessage), new MessageDroppedTraceRecord(message, endpointAddress));
//}
// Duplicates are removed
//using System;
//using System.Reflection;
//using CoreWCF.Description;
//using CoreWCF.Diagnostics;
//namespace CoreWCF.Dispatcher
//{
//    public class AsyncMethodInvoker : IOperationInvoker
//    {
//        MethodInfo beginMethod;
//        MethodInfo endMethod;
//        InvokeBeginDelegate invokeBeginDelegate;
//        InvokeEndDelegate invokeEndDelegate;
//        int inputParameterCount;
//        int outputParameterCount;
//        public bool IsSynchronous => false;
//        public object[] AllocateInputs()
//        {
//            return EmptyArray<object>.Allocate(this.InputParameterCount);
//        }
//        public object Invoke(object instance, object[] inputs, out object[] outputs)
//        {
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotImplementedException());
//        }
//        public IAsyncResult InvokeBegin(object instance, object[] inputs, AsyncCallback callback, object state)
//        {
//            if (instance == null)
//                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.SFxNoServiceObject));
//            if (inputs == null)
//            {
//                if (this.InputParameterCount > 0)
//                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.SFxInputParametersToServiceNull, this.InputParameterCount)));
//            }
//            else if (inputs.Length != this.InputParameterCount)
//                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.SFxInputParametersToServiceInvalid, this.InputParameterCount, inputs.Length)));
//            //StartOperationInvokePerformanceCounters(this.beginMethod.Name.Substring(ServiceReflector.BeginMethodNamePrefix.Length));
//            IAsyncResult returnValue;
//            //bool callFailed = true;
//            //bool callFaulted = false;
//            //ServiceModelActivity activity = null;
//            try
//            {
//                //Activity boundActivity = null;
//                //CreateActivityInfo(ref activity, ref boundActivity);
//                //StartOperationInvokeTrace(this.beginMethod.Name);
//                //using (boundActivity)
//                //{
//                //    if (DiagnosticUtility.ShouldUseActivity)
//                //    {
//                //        string activityName = null;
//                //        if (this.endMethod == null)
//                //        {
//                //            activityName = SR.Format(SR.ActivityExecuteMethod,
//                //                this.beginMethod.DeclaringType.FullName, this.beginMethod.Name);
//                //        }
//                //        else
//                //        {
//                //            activityName = SR.Format(SR.ActivityExecuteAsyncMethod,
//                //                this.beginMethod.DeclaringType.FullName, this.beginMethod.Name,
//                //                this.endMethod.DeclaringType.FullName, this.endMethod.Name);
//                //        }
//                //        ServiceModelActivity.Start(activity, activityName, ActivityType.ExecuteUserCode);
//                //    }
//                    returnValue = this.InvokeBeginDelegate(instance, inputs, callback, state);
//                    //callFailed = false;
//                //}
//            }
//            catch (System.Security.SecurityException e)
//            {
//                DiagnosticUtility.TraceHandledException(e, TraceEventType.Warning);
//                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(AuthorizationBehavior.CreateAccessDeniedFaultException());
//            }
//            catch (Exception e)
//            {
//                TraceUtility.TraceUserCodeException(e, this.beginMethod);
//                //if (e is FaultException)
//                //{
//                //    callFaulted = true;
//                //    callFailed = false;
//                //}
//                throw;
//            }
//            finally
//            {
//                //ServiceModelActivity.Stop(activity);
//                //// An exception during the InvokeBegin will not call InvokeEnd,
//                //// so we complete the trace and performance counters here.
//                //if (callFailed || callFaulted)
//                //{
//                //    StopOperationInvokeTrace(callFailed, callFaulted, this.EndMethod.Name);
//                //    StopOperationInvokePerformanceCounters(callFailed, callFaulted, endMethod.Name.Substring(ServiceReflector.EndMethodNamePrefix.Length));
//                //}
//            }
//            return returnValue;
//        }
//        public object InvokeEnd(object instance, out object[] outputs, IAsyncResult result)
//        {
//            throw new NotImplementedException();
//        }
//        InvokeBeginDelegate InvokeBeginDelegate
//        {
//            get
//            {
//                EnsureIsInitialized();
//                return invokeBeginDelegate;
//            }
//        }
//        InvokeEndDelegate InvokeEndDelegate
//        {
//            get
//            {
//                EnsureIsInitialized();
//                return invokeEndDelegate;
//            }
//        }
//        int InputParameterCount
//        {
//            get
//            {
//                EnsureIsInitialized();
//                return this.inputParameterCount;
//            }
//        }
//        void EnsureIsInitialized()
//        {
//            if (this.invokeBeginDelegate == null)
//            {
//                // Only pass locals byref because InvokerUtil may store temporary results in the byref.
//                // If two threads both reference this.count, temporary results may interact.
//                int inputParameterCount;
//                InvokeBeginDelegate invokeBeginDelegate = new InvokerUtil().GenerateInvokeBeginDelegate(this.beginMethod, out inputParameterCount);
//                this.inputParameterCount = inputParameterCount;
//                int outputParameterCount;
//                InvokeEndDelegate invokeEndDelegate = new InvokerUtil().GenerateInvokeEndDelegate(this.endMethod, out outputParameterCount);
//                this.outputParameterCount = outputParameterCount;
//                this.invokeEndDelegate = invokeEndDelegate;
//                this.invokeBeginDelegate = invokeBeginDelegate;  // must set this last due to race
//            }
//        }
//    }
//}// TODO: PerformanceCounters
// TODO: Decide if we want Auditing and add back
// TODO: Events 
// I know this code looks weird and it looks like the try/catch block should be removed, but I'm maintaining
// this code structure in preparation for Perf counters and auditing to be put back in.
// TODO: PerformanceCounters
// TODO: Auditing
// Locking:
// Only 1 channelBinder operation call should be active at any given time. All future calls
// will wait on the inputQueue. The semaphore is always released right before the Dispatch on the inputQueue.
// This protects a new call racing with an existing operation that is just about to fully complete.
// Reuse the existing requestContext
//
// TryReceive threads
//
// A RequestContext may be 'null' (some pieces of ChannelHandler depend on this) but the InputQueue
// will not allow null items to be enqueued. Wrap the RequestContexts in another object to
// facilitate this semantic
// This class is now only used as an OM for configuring the service. 
// This class has been kept to enable using existing behaviors.
//bool isTransactedReceive;
//bool asynchronousTransactedAcceptEnabled;
//int maxTransactedBatchSize;
//ServiceThrottle serviceThrottle;
//IsolationLevel transactionIsolationLevel = ServiceBehaviorAttribute.DefaultIsolationLevel;
//bool transactionIsolationLevelSet;
//EventTraceActivity eventTraceActivity;
//this.isTransactedReceive = false;
//this.asynchronousTransactedAcceptEnabled = false;
//this.serviceThrottle = null;
//transactionTimeout = TimeSpan.Zero;
// TODO: As the channel concept is changing, does it make sense to support IChannelInitializer's?
//public ServiceThrottle ServiceThrottle
//{
//    get
//    {
//        return this.serviceThrottle;
//    }
//    set
//    {
//        this.ThrowIfDisposedOrImmutable();
//        this.serviceThrottle = value;
//    }
//}
// TODO: Do we need to worry about this?
// Force a build of the runtime to catch any unexpected errors before we are done opening.
// Lock down the DispatchRuntime.
//if (DiagnosticUtility.ShouldTraceInformation)
//{
//    this.TraceEndpointLifetime(endpoint, TraceCode.EndpointListenerOpen, SR.Format(SR.TraceCodeEndpointListenerOpen));
//}
// TODO: Move this functionality somewhere else as this class is now OM only
// TODO: Fold ChannelDispatcherBase implementation into ChannelDispatcher. I believe this was only here for legacy reasons.
// back-compat
//private RequestInfo _requestInfo;
// TODO: Work out if MultipleReceiveBinder is necessary
//if (channelDispatcher.MaxPendingReceives > 1)
//{
//    // We need to preserve order if the ChannelHandler is not concurrent.
//    this.binder = new MultipleReceiveBinder(
//        this.binder,
//        channelDispatcher.MaxPendingReceives,
//        !this.isConcurrent);
//}
//_requestInfo = new RequestInfo(this);
// TODO: Wire up lifetime management in place of listener state
//if (this.listener.State == CommunicationState.Opened)
//{
//}
// Similar to HandleRequest on Desktop
// TODO: Implement all the exception handling cases from ErrorHandlingReceiver.TryReceive down stack in the transport.
// The transport implementation will need to send a null request to signal closing of the session/channel.
//Would have replied and close the request.
//Only acquire InstanceContext throttle if one doesnt already exist.
// TODO: Add support for needToCreateSessionOpenNotificationMessage, probably in constructor
// Similar to DispatchAndReleasePump on Desktop
// passing responsibility for call throttle to MessageRpc
// (MessageRpc implicitly owns this throttle once it's created)
// explicitly passing responsibility for instance throttle to MessageRpc
// These need to happen before Dispatch but after accessing any ChannelHandler
// state, because we go multi-threaded after this until we reacquire pump mutex.
// TODO: Enable UnknownMessageReceived handler
//this.host.RaiseUnknownMessageReceived(request.RequestMessage);
//For sessionful contracts, the InstanceContext throttle is not copied over to the channel
//as we create the channel before acquiring the lock
// SFx drops a message here
// Comment preserved from .NET Framework:
// When the idle timeout was hit, the constructor of ServiceChannel will abort itself directly. So
// the session throttle will not be released and thus lead to a service unavailablity.
// Note that if the channel is already aborted, the next line "channel.ServiceThrottle = this.throttle;" will throw an exception,
// so we are not going to do any more work inside this method. 
// Ideally we should do a thorough refactoring work for this throttling issue. However, it's too risky. We should consider
// this in a whole release.
// Note that the "wasChannelThrottled" boolean will only be true if we aquired the session throttle. So we don't have to check HasSession
// again here.
// This line will release the "session" throttle.
// No client yet
//else if (_channel != null)
//{
//    DispatchRuntime dispatchBehavior = _channel.ClientRuntime.CallbackDispatchRuntime;
//    dispatchBehavior.ChannelDispatcher.ProvideFault(e, this.channel.GetProperty<FaultConverter>(), ref faultInfo);
//}
// No client yet.
//else if (this.channel != null)
//{
//    return this.channel.ClientRuntime.CallbackDispatchRuntime.ChannelDispatcher.HandleError(e, ref faultInfo);
//}
// By default, the contract filter is just a filter over the set of initiating actions in 
// the contract, so we do error messages accordingly
// some of this code is duplicated in DispatchRuntime.UnhandledActionInvoker
// ideally both places would use FaultConverter and ActionNotSupportedException
// swallow it
// No client yet.
//else if (this._channel != null && this._channel.IsClient)
//{
//    enableFaults = this._channel.ClientRuntime.EnableFaults;
//}
/// <summary>
/// Prepares a reply
/// </summary>
/// <param name="request">The request context to prepare</param>
/// <param name="reply">The reply to prepare</param>
/// <returns>True if channel is open and prepared reply should be sent; otherwise false.</returns>
// Ensure we only reply once (we may hit the same error multiple times)
// swallow it
// swallow it - we don't need to correlate the reply if the MessageId header is bad
// swallow it - we don't need to address the reply if the FaultTo header is bad
// ObjectDisposeException can happen
// if the channel is closed in a different
// thread. 99% this check will avoid false
// exceptions.
//Return: False denotes failure, Caller should discard the request.
//      : True denotes operation is sucessful.
// This can happen if we are pumping for an async client,
// and we receive a bogus reply.  In that case, there is no
// DispatchRuntime, because we are only expecting replies.
//
// One possible fix for this would be in DuplexChannelBinder
// to drop all messages with a RelatesTo that do not match a
// pending request.
//
// However, that would not fix:
// (a) we could get a valid request message with a
// RelatesTo that we should try to process.
// (b) we could get a reply message that does not have
// a RelatesTo.
//
// So we do the null check here.
//
// SFx drops a message here
// TODO: Revert back to struct or pool objects.
// if true, we are responsible for call throttle
// if true, we are responsible for instance/dynamic throttle
//bool addTransactionFlowProperties = true;
//internal bool AddTransactionFlowProperties
//{
//    get { return this.addTransactionFlowProperties; }
//    set
//    {
//        lock (this.ThisLock)
//        {
//            this.InvalidateRuntime();
//            this.addTransactionFlowProperties = value;
//        }
//    }
//}
//HttpResponseMessageProperty prop = message.Properties[HttpResponseMessageProperty.Name] as HttpResponseMessageProperty;
//if (prop == null || prop.StatusCode != HttpStatusCode.InternalServerError)
//{
//    return false;
//}
//this.supportsTransactedBatch = ConcurrencyBehavior.SupportsTransactedBatch(runtime.ChannelDispatcher);
/*, this.supportsTransactedBatch*/);
/*, bool supportsTransactedBatch*/)
//if (supportsTransactedBatch)
//{
//    return false;
//}
//if (ConcurrencyBehavior.SupportsTransactedBatch(runtime))
//{
//    return false;
//}
// TODO: Throw this on setup
//We have no pending Callouts and no new Messages to process
// TODO: Make async to remove blocking Wait call
// Prevent release of waiter from running the waiter on the releasing thread by using RunContinuationsAsynchronously
// Prevent release of waiter from running the waiter on the releasing thread by using RunContinuationsAsynchronously
//XsdDataContractExporter dataContractExporter;
/*isEncoded*/)
//if (dataContractExporter == null)
//{
//    dataContractExporter = new XsdDataContractExporter();
//    if (serializerFactory != null && serializerFactory.DataContractSurrogate != null)
//    {
//        ExportOptions options = new ExportOptions();
//        options.DataContractSurrogate = serializerFactory.DataContractSurrogate;
//        dataContractExporter.Options = options;
//    }
//}
//dataContractExporter.GetSchemaTypeName(type); //Throws if the type is not a valid data contract
/*isXmlElement*/);
//Prefix needed since there may be xsi:type attribute at toplevel with qname value where ns = ""
/* verifyObjectName */);
// Not necessary for basic functionality
//readonly bool transactionAutoComplete;
//readonly bool transactionRequired;
//readonly bool isInsideTransactedReceiveScope;
//AsyncMethodInvoker async = this.invoker as AsyncMethodInvoker;
//if (async != null)
//{
//    this.ValidateInstanceType(operation.Parent.Type, async.BeginMethod);
//    this.ValidateInstanceType(operation.Parent.Type, async.EndMethod);
//}
//internal bool TransactionAutoComplete
//{
//    get { return this.transactionAutoComplete; }
//}
//internal bool TransactionRequired
//{
//    get { return this.transactionRequired; }
//}
//internal bool IsInsideTransactedReceiveScope
//{
//    get { return this.isInsideTransactedReceiveScope; }
//}
//bool success = false;
// If the field is true, then this operation is to be invoked at the time the service 
// channel is opened. The incoming message is created at ChannelHandler level with no 
// content, so we don't need to deserialize the message.
//if (TD.DispatchFormatterDeserializeRequestStartIsEnabled())
//{
//    TD.DispatchFormatterDeserializeRequestStart(rpc.EventTraceActivity);
//}
//if (TD.DispatchFormatterDeserializeRequestStopIsEnabled())
//{
//    TD.DispatchFormatterDeserializeRequestStop(rpc.EventTraceActivity);
//}
//success = true;
//if (!success && MessageLogger.LoggingEnabled)
//{
//    MessageLogger.LogMessage(rpc.Request, MessageLoggingSource.Malformed);
//}
// thread-local storage may be corrupt
//if (TD.ParameterInspectorBeforeCallInvokedIsEnabled())
//{
//    TD.ParameterInspectorBeforeCallInvoked(rpc.EventTraceActivity, this.ParameterInspectors[i].GetType().FullName);
//}
//if (TD.ParameterInspectorAfterCallInvokedIsEnabled())
//{
//    TD.ParameterInspectorAfterCallInvoked(rpc.EventTraceActivity, this.ParameterInspectors[i].GetType().FullName);
//}
// Make sure user Exception filters are not impersonated.
// TODO: Reenable this code
//ServiceSecurityContext securityContext = rpc.SecurityContext;
//if (!rpc.HasSecurityContext)
//{
//    SecurityMessageProperty securityContextProperty = rpc.Request.Properties.Security;
//    if (securityContextProperty != null)
//    {
//        securityContext = securityContextProperty.ServiceSecurityContext;
//    }
//}
//if (securityContext != null)
//{
//    object principal;
//    if (securityContext.AuthorizationContext.Properties.TryGetValue(AuthorizationPolicy.ClaimsPrincipalKey, out principal))
//    {
//        ClaimsPrincipal claimsPrincipal = principal as ClaimsPrincipal;
//        if (claimsPrincipal != null)
//        {
//            //
//            // Always set ClaimsPrincipal to OperationContext.Current if identityModel pipeline is used.
//            //
//            OperationContext.Current.ClaimsPrincipal = claimsPrincipal;
//        }
//        else
//        {
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.NoPrincipalSpecifiedInAuthorizationContext));
//        }
//    }
//}
//if (TD.DispatchFormatterSerializeReplyStartIsEnabled())
//{
//    TD.DispatchFormatterSerializeReplyStart(rpc.EventTraceActivity);
//}
//if (TD.DispatchFormatterSerializeReplyStopIsEnabled())
//{
//    TD.DispatchFormatterSerializeReplyStop(rpc.EventTraceActivity);
//}
//if (DiagnosticUtility.ShouldUseActivity && rpc.Activity != null && reply != null)
//{
//    TraceUtility.SetActivity(reply, rpc.Activity);
//    if (TraceUtility.ShouldPropagateActivity)
//    {
//        TraceUtility.AddActivityHeader(reply);
//    }
//}
//else if (TraceUtility.ShouldPropagateActivity && reply != null && rpc.ResponseActivityId != Guid.Empty)
//{
//    ActivityIdHeader header = new ActivityIdHeader(rpc.ResponseActivityId);
//    header.AddTo(reply);
//}
//rely on the property set during the message receive to correlate the trace
//if (TraceUtility.MessageFlowTracingOnly)
//{
//    //Guard against MEX scenarios where the message is closed by now
//    if (null != rpc.OperationContext.IncomingMessage && MessageState.Closed != rpc.OperationContext.IncomingMessage.State)
//    {
//        FxTrace.Trace.SetAndTraceTransfer(TraceUtility.GetReceivedActivityId(rpc.OperationContext), true);
//    }
//    else
//    {
//        if (rpc.ResponseActivityId != Guid.Empty)
//        {
//            FxTrace.Trace.SetAndTraceTransfer(rpc.ResponseActivityId, true);
//        }
//    }
//}
// Add the ImpersonateOnSerializingReplyMessageProperty on the reply message iff
// a. reply message is not null.
// b. Impersonation is enabled on serializing Reply
//if (MessageLogger.LoggingEnabled && null != reply)
//{
//    MessageLogger.LogMessage(ref reply, MessageLoggingSource.ServiceLevelSendReply | MessageLoggingSource.LastChance);
//}
//AuditLogLocation securityAuditLogLocation;
//bool suppressAuditFailure;
//AuditLevel serviceAuthorizationAuditLevel;
//AuditLevel messageAuthenticationAuditLevel;
//object roleProvider;
//public RoleProvider RoleProvider
//{
//    get { return (RoleProvider)this.roleProvider; }
//    set
//    {
//        lock (this.ThisLock)
//        {
//            this.InvalidateRuntime();
//            this.roleProvider = value;
//        }
//    }
//}
//public bool TransactionAutoCompleteOnSessionClose
//{
//    get { return this.transactionAutoCompleteOnSessionClose; }
//    set
//    {
//        lock (this.ThisLock)
//        {
//            this.InvalidateRuntime();
//            this.transactionAutoCompleteOnSessionClose = value;
//        }
//    }
//}
// TODO: Only used for WF so remove
//lock (ThisLock)
//{
//    InvalidateRuntime();
//    preserveMessage = value;
//}
// Internal access to CallbackClientRuntime, but this one doesn't create on demand
//internal bool IsRoleProviderSet
//{
//    get { return this.roleProvider != null; }
//}
//if (DiagnosticUtility.ShouldTraceInformation)
//{
//    TraceUtility.TraceEvent(TraceEventType.Information, TraceCode.UnhandledAction,
//        SR.TraceCodeUnhandledAction,
//        new StringTraceRecord("Action", action),
//        this, null, message);
//}
//Some unhandled exception happened on the channel. 
//So close all pending requests so the callbacks (in case of async)
//on the requests are called.
// Remove requests from the correlator since the channel might be either faulting or aborting,
// We are not going to get a reply for these requests. If they are not removed from the correlator, this will cause a leak.
// This operation does not have to be under the lock
//if there are any timed out requests, delete it from the correlator table
// ignore it
// TODO: Resolve this method being called and remove method
//lock (ThisLock)
//{
//    if (!syncPumpEnabled)
//    {
//        if (!ChannelHandler.HasRegisterBeenCalled)
//        {
//            ChannelHandler.Register(ChannelHandler);
//        }
//    }
//}
//if (DiagnosticUtility.ShouldUseActivity &&
//    ServiceModelActivity.Current != null &&
//    ServiceModelActivity.Current.ActivityType == ActivityType.ProcessAction)
//{
//    ServiceModelActivity.Current.Suspend();
//}
// TODO: Derive CancellationToken to attach timeout
// SFx drops a message here
//if (DiagnosticUtility.ShouldTraceInformation)
//{
//    EndpointDispatcher dispatcher = null;
//    if (this.ChannelHandler != null && this.ChannelHandler.Channel != null)
//    {
//        dispatcher = this.ChannelHandler.Channel.EndpointDispatcher;
//    }
//    TraceUtility.TraceDroppedMessage(reply, dispatcher);
//}
// ASSUMPTION: (mmaruch) caller holds lock (this.mutex)
// ASSUMPTION: (mmaruch) caller holds lock (this.mutex)
// ASSUMPTION: caller holds ThisLock
// ASSUMPTION: caller holds  ThisLock
// Remove requests from the correlator since the channel might be either faulting, aborting or closing 
// We are not going to get a reply for these timed out requests. If they are not removed from the correlator, this will cause a leak.
// This operation does not have to be under the lock
//[MethodImpl(MethodImplOptions.NoInlining)]
//void EnsureIncomingIdentity(SecurityMessageProperty property, EndpointAddress address, Message reply)
//{
//    this.IdentityVerifier.EnsureIncomingIdentity(address, property.ServiceSecurityContext.AuthorizationContext);
//}
//if (!this.isSession)
//{
//    SecurityMessageProperty property = reply.Properties.Security;
//    EndpointAddress address = this.channel.RemoteAddress;
//    if ((property != null) && (address != null))
//    {
//        EnsureIncomingIdentity(property, address, reply);
//    }
//}
// TODO: Remove as unused and we're now using a push model
// used to read-ahead by a single message and auto-close the session when we read null
// kick off a new receive when a message is picked up
// kick off an async receive so that we notice when the server is trying to shutdown
// we've hit end of session, time for auto-close to kick in
// stash away exception to throw out of user's Close()
// called from both Abort and Close paths
// To
/* ignoreCase */, CompareHost, ComparePort);
// Create the candidate
// Update the QName ref count
/*includeHostNameInComparison*/, out cset))
/*includeHostNameInComparison*/, out cset))
/*includeHostNameInComparison*/, out cset))
/*includeHostNameInComparison*/, out cset))
/*includeHostNameInComparison*/, out cset))
/*includeHostNameInComparison*/, out cset))
// Clear out all the bits.
// Rebuild the masks
// Remove Candidate
// Adjust QName counts
// QName Attributes
//internal static readonly string XsiNs = XmlSchema.InstanceNamespace;
//www.w3.org/2001/XMLSchema-instance";
//schemas.microsoft.com/2003/10/Serialization/";
// Pooling
// Scan attributes
// Ignore namespaces
// ignore IsReferenceParameter
// ignore wsu:Id attributes added by security to sign the header
// Should be the same as an empty tag.
// Need to escape CDATA values
// Do nothing
// Needed after call to ReadSubtree
//string perfCounterId;
//string perfCounterBaseId;
// for ServiceMetadataBehavior, to help get EndpointIdentity of ServiceEndpoint from EndpointDispatcher
// channelDispatcher is Attached
// endpointFilter is lazy
//if (PerformanceCounters.PerformanceCountersEnabled)
//{
//    this.perfCounterId = baseEndpoint.perfCounterId;
//    this.perfCounterBaseId = baseEndpoint.perfCounterBaseId;
//}
// Can't optimize addressFilter similarly.
// AndMessageFilter tracks when the address filter matched so the correct
// fault can be sent back.
//internal string PerfCounterId
//{
//    get { return this.perfCounterId; }
//}
//internal string PerfCounterBaseId
//{
//    get { return this.perfCounterBaseId; }
//}
// TODO: Plumb through the listening Uri
//listenUri = channelDispatcher.Listener?.Uri;
//this.ReleasePerformanceCounters();
//internal void ReleasePerformanceCounters()
//{
//    if (PerformanceCounters.PerformanceCountersEnabled)
//    {
//        PerformanceCounters.ReleasePerformanceCountersForEndpoint(this.perfCounterId, this.perfCounterBaseId);
//    }
//}
//internal bool SetPerfCounterId()
//{
//    Uri keyUri = null;
//    if (null != this.ListenUri)
//    {
//        keyUri = this.ListenUri;
//    }
//    else
//    {
//        EndpointAddress endpointAddress = this.EndpointAddress;
//        if (null != endpointAddress)
//        {
//            keyUri = endpointAddress.Uri;
//        }
//    }
//    if (null != keyUri)
//    {
//        this.perfCounterBaseId = keyUri.AbsoluteUri.ToUpperInvariant();
//        this.perfCounterId = this.perfCounterBaseId + "/" + contractName.ToUpperInvariant();
//        return true;
//    }
//    else
//    {
//        return false;
//    }
//}
//debug = channelDispatcher.IncludeExceptionDetailInFaults;
//isOnServer = channelDispatcher.IsOnServer;
//messageVersion = channelDispatcher.MessageVersion;
//if this is an InternalServiceFault coming from another service dispatcher we should treat it as unhandled so that the channels are cleaned up
//if (TD.FaultProviderInvokedIsEnabled())
//{
//    TD.FaultProviderInvoked(handlers[i].GetType().FullName, e.Message);
//}
// there is a message
// and it's not the internal-server-error one
//if (TD.ServiceExceptionIsEnabled())
//{
//    TD.ServiceException(null, error.ToString(), error.GetType().FullName);
//}
//if (TD.ErrorHandlerInvokedIsEnabled())
//{
//    TD.ErrorHandlerInvoked(handlers[i].GetType().FullName, handledByThis, error.GetType().FullName);
//}
// This ensures that people debugging first-chance Exceptions see this Exception,
// and that the Exception shows up in the trace logs.
// if this is null, then we aren't interested in sending back a fault
// if this is true, it means Fault is the 'internal server error' fault
// Returns true if the exception has been handled.  If it returns false or
// throws a different exception, the original exception will be rethrown.
/* maxItemsInObjectGraph */);
/* maxItemsInObjectGraph */);
/* maxItemsInObjectGraph */ );
/*actor*/,
/*node*/)
// TODO: See if there's a way to pool resettable awaitables to remove allocation. Same in QuotaThrottle
//if (TD.MessageThrottleExceededIsEnabled())
//{
//    if (!this.warningIssued)
//    {
//        TD.MessageThrottleExceeded(this.propertyName, this.capacity);
//        this.warningIssued = true;
//    }
//}
//if (DiagnosticUtility.ShouldTraceWarning)
//{
//    string traceMessage;
//    if (this.propertyName != null)
//    {
//        traceMessage = SR.GetString(SR.TraceCodeServiceThrottleLimitReached,
//                         this.propertyName, this.capacity, this.configName);
//    }
//    else
//    {
//        traceMessage = SR.GetString(SR.TraceCodeServiceThrottleLimitReachedInternal,
//                         this.capacity);
//    }
//    TraceUtility.TraceEvent(
//        TraceEventType.Warning, TraceCode.ServiceThrottleLimitReached, traceMessage);
//}
// To prevent the thread that's releasing a throttle being hijacked to run the continuations,
// set the TaskCreationOptions to make the waiting method run on a new thread.
//if (TD.MessageThrottleAtSeventyPercentIsEnabled() && this.warningIssued)
//{
//    TD.MessageThrottleAtSeventyPercent(this.propertyName, this.capacity);
//}
// Only used on full framework by WebHttpBehavior
// message=null for singleton
// return a single match
// return multiple matches
// If you need both the filter and the data, use these functions then look up
// the data using the filter tables IDictionary methods.
//bool addTransactionFlowProperties;
//IInteractiveChannelInitializer[] interactiveChannelInitializers;
//this.interactiveChannelInitializers = EmptyArray<IInteractiveChannelInitializer>.ToArray(behavior.InteractiveChannelInitializers);
//this.addTransactionFlowProperties = behavior.AddTransactionFlowProperties;
//if (TD.ClientMessageInspectorAfterReceiveInvokedIsEnabled())
//{
//    TD.ClientMessageInspectorAfterReceiveInvoked(rpc.EventTraceActivity, this.messageInspectors[i].GetType().FullName);
//}
//if (TD.ClientMessageInspectorBeforeSendInvokedIsEnabled())
//{
//    TD.ClientMessageInspectorBeforeSendInvoked(rpc.EventTraceActivity, this.messageInspectors[i].GetType().FullName);
//}
//if (this.addTransactionFlowProperties)
//{
//    SendTransaction(ref rpc);
//}
// this should not be inlined, since we want to JIT the reference to System.Transactions
// only if transactions are being flowed.
//[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
//static void SendTransaction(ref ProxyRpc rpc)
//{
//    System.ServiceModel.Channels.TransactionFlowProperty.Set(Transaction.Current, rpc.Request);
//}
// did not find the right operation, will not know how 
// to invoke the method.
//        internal IRequestReplyCorrelator RequestReplyCorrelator
//        {
//            get { return this.requestReplyCorrelator; }
//        }
//if (TD.MessageInspectorAfterReceiveInvokedIsEnabled())
//{
//    TD.MessageInspectorAfterReceiveInvoked(rpc.EventTraceActivity, this.messageInspectors[i].GetType().FullName);
//}
//if (TD.MessageInspectorBeforeSendInvokedIsEnabled())
//{
//    TD.MessageInspectorBeforeSendInvoked(rpc.EventTraceActivity, this.messageInspectors[i].GetType().FullName);
//}
//if (TD.DispatchMessageStopIsEnabled())
//{
//    TD.DispatchMessageStop(rpc.EventTraceActivity);
//}
//if (DiagnosticUtility.ShouldTraceError)
//{
//    TraceUtility.TraceEvent(TraceEventType.Error, TraceCode.ServiceOperationExceptionOnReply,
//        SR.Format(SR.TraceCodeServiceOperationExceptionOnReply),
//        this, e);
//}
//if (DiagnosticUtility.ShouldTraceWarning)
//{
//    // If a service both returns null and sets RequestContext null, that
//    // means they handled it (either by calling Close or Reply manually).
//    // These traces catch accidents, where you accidentally return null,
//    // or you accidentally close the context so we can't return your message.
//    if ((rpc.Reply == null) && (context != null))
//    {
//        TraceUtility.TraceEvent(System.Diagnostics.TraceEventType.Warning,
//            TraceCode.ServiceOperationMissingReply,
//            SR.Format(SR.TraceCodeServiceOperationMissingReply, rpc.Operation.Name ?? String.Empty),
//            null, null);
//    }
//    else if ((context == null) && (rpc.Reply != null))
//    {
//        TraceUtility.TraceEvent(System.Diagnostics.TraceEventType.Warning,
//            TraceCode.ServiceOperationMissingReplyContext,
//            SR.Format(SR.TraceCodeServiceOperationMissingReplyContext, rpc.Operation.Name ?? String.Empty),
//            null, null);
//    }
//}
// We don't call ProvideFault again, since we have already passed the
// point where SFx addresses the reply, and it is reasonable for
// ProvideFault to expect that SFx will address the reply.  Instead
// we always just do 'internal server error' processing.
//if (FxTrace.Trace.IsEnd2EndActivityTracingEnabled && rpc.EventTraceActivity != null)
//{
//    rpc.Reply.Properties[EventTraceActivity.Name] = rpc.EventTraceActivity;
//}
// TODO: Make authenticationBehavior Async
// TODO: Make authorizationBehavior Async
// TaskHelpers has an extension method which enables awaitting a sync context to run continuation on it.
// This needs to happen after LockInstance--LockInstance guarantees
// in-order delivery, so we can't receive the next message until we
// have acquired the lock.
//
// This also needs to happen after BindThread based on the assumption
// that running on UI thread should guarantee in-order delivery if
// the SynchronizationContext is single threaded.
// To allow transport receive loop to get next request, the call to dispatch the current message needs to return.
// If all previous await's have completed synchronously, execution needs to be forced to continue on another thread.
// This code causes this method to continue on another thread and any calling receive pump (such as NetTcp) will
// use this thread to request the next message. It might be better to switch that so this thread continues on this
// thread and the caller has to run on a new thread.
// This catch clause forces ClearCallContext to run prior to stackwalks exiting this frame.
// Switch back to thread pool if we're using a non-default Sync Context. This only switches threads if needed.
//if (rpc.Reply != null)
//{
//    TraceUtility.MessageFlowAtMessageSent(rpc.Reply, rpc.EventTraceActivity);
//}
// Logic for knowing when to close stuff:
//
// ASSUMPTIONS:
//   Closing a stream over a message also closes the message.
//   Closing a message over a stream does not close the stream.
//     (OperationStreamProvider.ReleaseStream is no-op)
//
// This is a table of what should be disposed in what cases.
// The rows represent the type of parameter to the method and
// whether we are disposing parameters or not.  The columns
// are for the inputs vs. the outputs.  The cells contain the
// values that need to be Disposed.  M^P means that exactly
// one of the message and parameter needs to be disposed,
// since they refer to the same object.
//
//                               Request           Reply
//               Message   |     M or P      |     M or P
//     Dispose   Stream    |     P           |     M and P
//               Params    |     M and P     |     M and P
//                         |                 |
//               Message   |     none        |     none
//   NoDispose   Stream    |     none        |     M
//               Params    |     M           |     M
//
// By choosing to dispose the parameter in both of the "M or P"
// cases, the logic needed to generate this table is:
//
// CloseRequestMessage = IsParams
// CloseRequestParams  = rpc.Operation.DisposeParameters
// CloseReplyMessage   = rpc.Operation.SerializeReply
// CloseReplyParams    = rpc.Operation.DisposeParameters
//
// IsParams can be calculated based on whether the request
// message was consumed after deserializing but before calling
// the user.  This is stored as rpc.DidDeserializeRequestBody.
//
//Dispose all input/output/return parameters
// maybe ProvideFault gave a Message, but then BeforeSendReply replaced it
// in that case, we need to close the one from ProvideFault
// TODO: Add the code for the other half of InstanceContextServiceThrottle being acquired
//if (rpc.Activity != null && DiagnosticUtility.ShouldUseActivity)
//{
//    rpc.Activity.Stop();
//}
//if (FxTrace.Trace.IsEnd2EndActivityTracingEnabled && rpc.EventTraceActivity != null)
//{
//    // Propogate the ActivityId to the service operation
//    EventTraceActivityHelper.SetOnThread(rpc.EventTraceActivity);
//}
// TODO: Do we need to keep track of pending channels with the new hosting model?
//channelDispatcher.PendingChannels.Remove(rpc.Channel.Binder.Channel);
//User provided InstanceContextProvider. Call the provider to check for idle.
// awaiting the task outside the lock is safe as OpenAsync will transition the state away from Created before
// it returns an uncompleted Task.
//if (TD.GetServiceInstanceStartIsEnabled())
//{
//    TD.GetServiceInstanceStart(rpc.EventTraceActivity);
//}
//if (TD.GetServiceInstanceStopIsEnabled())
//{
//    TD.GetServiceInstanceStop(rpc.EventTraceActivity);
//}
//if (TD.CloseTimeoutIsEnabled())
//{
//    TD.CloseTimeout(e.Message);
//}
//if (TD.CloseTimeoutIsEnabled())
//{
//    TD.CloseTimeout(e.Message);
//}
//internal InvokeBeginDelegate GenerateInvokeBeginDelegate(MethodInfo method, out int inputParameterCount)
//{
//    return helper.GenerateInvokeBeginDelegate(method, out inputParameterCount);
//}
//internal InvokeEndDelegate GenerateInvokeEndDelegate(MethodInfo method, out int outputParameterCount)
//{
//    return helper.GenerateInvokeEndDelegate(method, out outputParameterCount);
//}
//public InvokeBeginDelegate GenerateInvokeBeginDelegate(MethodInfo method, out int inputParameterCount)
//{
//    ParameterInfo[] parameters = method.GetParameters();
//    var inputCount = parameters.Length;
//    inputParameterCount = inputCount;
//    InvokeBeginDelegate lambda =
//        delegate(object target, object[] inputs, AsyncCallback callback, object state)
//        {
//            object[] inputsLocal = new object[inputCount];
//            for (var i = 0; i < inputCount; i++)
//            {
//                inputsLocal[i] = inputs[i];
//            }
//            inputsLocal[inputCount] = callback;
//            inputsLocal[inputCount + 1] = state;
//            object result = method.Invoke(target, inputs);
//            return result as IAsyncResult;
//        };
//    return lambda;
//}
//public InvokeEndDelegate GenerateInvokeEndDelegate(MethodInfo method, out int outParameterCount)
//{
//    InvokeEndDelegate lambda =
//        delegate(object target, object[] outputs, IAsyncResult result)
//        {
//        }
//}
// TODO: Switch to Task based invoker
// TODO: Convert to task based continuations
//[KnownType(typeof(XPathMessageFilter))]
//[KnownType(typeof(ActionMessageFilter))]
//[KnownType(typeof(MatchAllMessageFilter))]
//[KnownType(typeof(MatchNoneMessageFilter))]
/// <summary>
/// Tests whether the filter matches the given message.
/// </summary>                
/// <summary>
/// Tests whether the filter matches the given message without examining its body.
/// Note: since this method never probes the message body, it should NOT close the message
/// If the filter probes the message body, then the filter must THROW an Exception. The filter should not return false
/// This is deliberate - we don't want to produce false positives. 
/// </summary>
//
// IMessageFilterTable<FilterData> methods
//
//
// IDictionary<MessageFilter,FilterData> methods
//   
//
// ICollection<KeyValuePair<MessageFilter,FilterData>> methods
//
// Watch for the end of a bucket
// Watch for the end of a bucket
// this optimization is only for CorrelationActionMessageFilter and ActionMessageFilter if they override CreateFilterTable to return ActionMessageFilterTable
// Watch for the end of a bucket
// this is an action message, in this case we can pass in the message itself since the filter will only read from the header
// this is a custom filter that might read from the message body, pass in the message buffer itself in this case
// Watch for the end of a bucket
// Watch for the end of a bucket
// Watch for the end of a bucket
// Watch for the end of a bucket
// Watch for the end of a bucket
// Watch for the end of a bucket
///////////////////////////////////////////////////
// Highest priority first
// Highest priority first
// TODO: Pool MessageRpc objects. These are zero cost on .NET Framework as it's a struct but passing things by ref is problematic
// when using async/await. This causes an allocation per request so pool them to remove that allocation.
//internal ServiceModelActivity Activity;
//internal TransactionMessageProperty TransactionMessageProperty;
//internal TransactedBatchContext TransactedBatchContext;
//internal TransactionRpcFacet transaction;
//internal IAspNetMessageProperty HostingProperty;
//internal MessageRpcInvokeNotification InvokeNotification;
//internal EventTraceActivity EventTraceActivity;
/*, EventTraceActivity eventTraceActivity*/)
// TODO: ChannelHandler supplied an ErrorHandler, need to supply this some other way.
//Fx.Assert(channelHandler != null, "System.ServiceModel.Dispatcher.MessageRpc.MessageRpc(), channelHandler == null");
//this.Activity = null;
//this.EventTraceActivity = eventTraceActivity;
//this.transaction = null;
//if (DiagnosticUtility.ShouldUseActivity)
//{
//    this.Activity = TraceUtility.ExtractActivity(this.Request);
//}
//if (DiagnosticUtility.ShouldUseActivity || TraceUtility.ShouldPropagateActivity)
//{
//    this.ResponseActivityId = ActivityIdHeader.ExtractActivityId(this.Request);
//}
//else
//{
//}
//if (this.EventTraceActivity == null && FxTrace.Trace.IsEnd2EndActivityTracingEnabled)
//{
//    if (this.Request != null)
//    {
//        this.EventTraceActivity = EventTraceActivityHelper.TryExtractActivity(this.Request, true);
//    }
//}
//internal TransactionRpcFacet Transaction
//{
//    get
//    {
//        if (this.transaction == null)
//        {
//            this.transaction = new TransactionRpcFacet(ref this);
//        }
//        return this.transaction;
//    }
//}
// only need to trace once (either for the failure or success case)
//if (TD.DispatchFailedIsEnabled())
//{
//    if (requestContextWasClosedSuccessfully)
//    {
//        TD.DispatchSuccessful(this.EventTraceActivity, this.Operation.Name);
//    }
//    else
//    {
//        TD.DispatchFailed(this.EventTraceActivity, this.Operation.Name);
//    }
//}
// TODO: Make async
//if (TraceUtility.MessageFlowTracingOnly)
//{
//    TraceUtility.SetActivityId(this.Request.Properties);
//    if (Guid.Empty == DiagnosticTraceBase.ActivityId)
//    {
//        Guid receivedActivityId = TraceUtility.ExtractActivityId(this.Request);
//        if (Guid.Empty != receivedActivityId)
//        {
//            DiagnosticTraceBase.ActivityId = receivedActivityId;
//        }
//    }
//}
//using (ServiceModelActivity.BoundOperation(this.Activity))
//{
// bool completed = true;
//}
// UnPause is called on the original MessageRpc to continue work on the current thread, and the copy is ignored.
// Since the copy is ignored, Decrement the BusyCount
// TODO: Do we want a way to keep track of bust count? I believe this originally drove PerformanceCounters so we might want to re-work this functionality.
// Only increment the counter on the service side.
//if (Host != null)
//{
//Host.IncrementBusyCount();
//if (AspNetEnvironment.Current.TraceIncrementBusyCountIsEnabled())
//{
//    AspNetEnvironment.Current.TraceIncrementBusyCount(SR.Format(SR.ServiceBusyCountTrace, this.Operation.Action));
//}
//}
// See comment on IncrementBusyCount
//if (Host != null)
//{
//    Host.DecrementBusyCount();
//if (AspNetEnvironment.Current.TraceDecrementBusyCountIsEnabled())
//{
//    AspNetEnvironment.Current.TraceDecrementBusyCount(SR.Format(SR.ServiceBusyCountTrace, this.Operation.Action));
//}
//}
//[Serializable]
//SystemException
//[NonSerialized]
//protected MultipleFilterMatchesException(SerializationInfo info, StreamingContext context)
//    : base(info, context)
//{
//    this.filters = null;
//}
/*isRequest*/);
/*isResponse*/);
/*isRequest*/);
/*isRequest*/);
// copy values into the actual field/properties
/*isRequest*/);
/*isRequest*/);
/*isRequest*/);
/*isRequest*/);
// copy values into the actual field/properties
/*isRequest*/);
/*isRequest*/);
// copy values from the actual field/properties
/*isRequest*/);
/*isRequest*/);
// If the response is a typed message then it must 
// me the response (as opposed to an out param).  We will
// serialize the response in the exact same way that we
// would serialize a bunch of outs (with no return value).
// make a copy of the list so that we have the actual values of the field/properties
/*isRequest*/);
/*isRequest*/);
//if (DiagnosticUtility.ShouldTraceVerbose)
//{
//    TraceUtility.TraceEvent(TraceEventType.Verbose, TraceCode.ElementIgnored, SR.SFxTraceCodeElementIgnored, new StringTraceRecord("Element", xmlReader.NamespaceURI + ":" + xmlReader.LocalName));
//}
//use innerHeader to handle versionSupported, actor/role handling etc.
/*headerValue*/, mustUnderstand, actor, relay);
/*headerValue*/, mustUnderstand, "", relay);
//Prefix needed since there may be xsi:type attribute at toplevel with qname value where ns = ""
// Needs Net Standard 1.7
//base.WriteHeaderAttributes(writer, messageVersion);
//XmlDictionaryReader nodeReader = XmlDictionaryReader.CreateDictionaryReader(new XmlNodeReader(headerValue));
//nodeReader.MoveToContent();
//writer.WriteAttributes(nodeReader, false);
// both sync and async methods are present on the contract, check the preference
//OperationBehaviorAttribute operationBehaviorAttribute = description.Behaviors.Find<OperationBehaviorAttribute>();
//if ((operationBehaviorAttribute != null) && operationBehaviorAttribute.PreferAsyncInvocation)
//{
//    dispatch.Invoker = new AsyncMethodInvoker(description.BeginMethod, description.EndMethod);
//}
//else
//{
//}
// only sync method is present on the contract
// only async method is present on the contract
//dispatch.Invoker = new AsyncMethodInvoker(description.BeginMethod, description.EndMethod);
//Always return null so we will create new InstanceContext for each message
//no-op
//By default return true if no channels are bound to this context
//no-op
// Here is the flow for a Sessionful channel
//  1. First request comes in on new channel.
//  2. ServiceChannel.InstanceContext is returned which is null.
//  3. InstanceBehavior.EnsureInstanceContext will create a new InstanceContext.
//  4. this.InitializeInstanceContext is called with the newly created InstanceContext and the channel.
//  5. If the channel is sessionful then its bound to the InstanceContext.
//  6. Bind channel to the InstanceContext.
//  7. For all further requests on the same channel, we will return ServiceChannel.InstanceContext which will be non null.
//By default return true
//no-op
// To
// Create the candidate
// Remove Candidate
//www.w3.org/2001/XMLSchema-instance";
/*isEncoded*/);
//ActionHeader ActionHeaderAugust2004
//{
//    get
//    {
//        if (actionHeaderAugust2004 == null)
//        {
//            actionHeaderAugust2004 =
//                ActionHeader.Create(this.action, AddressingVersion.WSAddressingAugust2004);
//        }
//        return actionHeaderAugust2004;
//    }
//}
//ActionHeader ReplyActionHeaderAugust2004
//{
//    get
//    {
//        if (replyActionHeaderAugust2004 == null)
//        {
//            replyActionHeaderAugust2004 =
//                ActionHeader.Create(this.replyAction, AddressingVersion.WSAddressingAugust2004);
//        }
//        return replyActionHeaderAugust2004;
//    }
//}
//if (addressing == AddressingVersion.WSAddressingAugust2004)
//{
//    return ActionHeaderAugust2004;
//}
//else
//if (addressing == AddressingVersion.WSAddressingAugust2004)
//{
//    return ReplyActionHeaderAugust2004;
//}
//else 
//schemas.microsoft.com/2003/10/Serialization/Arrays";
//if (TD.ClientFormatterDeserializeReplyStartIsEnabled())
//{
//    TD.ClientFormatterDeserializeReplyStart(rpc.EventTraceActivity);
//}
//if (TD.ClientFormatterDeserializeReplyStopIsEnabled())
//{
//    TD.ClientFormatterDeserializeReplyStop(rpc.EventTraceActivity);
//}
//if (TD.ClientParameterInspectorAfterCallInvokedIsEnabled())
//{
//    TD.ClientParameterInspectorAfterCallInvoked(rpc.EventTraceActivity, this._parameterInspectors[i].GetType().FullName);
//}
//if (TD.ClientParameterInspectorBeforeCallInvokedIsEnabled())
//{
//    TD.ClientParameterInspectorBeforeCallInvoked(rpc.EventTraceActivity, this._parameterInspectors[i].GetType().FullName);
//}
//if (TD.ClientFormatterSerializeRequestStartIsEnabled())
//{
//    TD.ClientFormatterSerializeRequestStart(rpc.EventTraceActivity);
//}
//if (TD.ClientFormatterSerializeRequestStopIsEnabled())
//{
//    TD.ClientFormatterSerializeRequestStop(rpc.EventTraceActivity);
//}
// the RealProxy infrastructure requires a default value for value types
//internal ServiceModelActivity Activity;
//internal readonly TimeoutHelper TimeoutHelper;
//EventTraceActivity eventTraceActivity;
//this.Activity = null;
//this.eventTraceActivity = null;
//internal EventTraceActivity EventTraceActivity
//{
//    get
//    {
//        if (this.eventTraceActivity == null)
//        {
//            this.eventTraceActivity = new EventTraceActivity();
//        }
//        return this.eventTraceActivity;
//    }
//    set
//    {
//        this.eventTraceActivity = value;
//    }
//}
//
// Generic struct representing ranges within buffers
//
// INCLUSIVE - the end of the range
// INCLUSIVE - the start of the range
/// <summary>
/// Our own buffer management
/// There are a few reasons why we don't reuse something in System.Collections.Generic
///  1. We want Clear() to NOT reallocate the internal array. We want it to simply set the Count = 0
///     This allows us to reuse buffers with impunity.
///  2. We want to be able to replace the internal buffer in a collection with a different one. Again,
///     this is to help with pooling
///  3. We want to be able to control how fast buffers grow. 
///  4. Does absolutely no bounds or null checking. As fast as we can make it. All checking should be done
///  by whoever wraps this. Checking is unnecessary for many internal uses where we need optimal perf.
///  5. Does more precise trimming
///  6. AND this is a struct
///
/// </summary>        
// buffer of T. Frequently larger than count
// Actual # of items
/// <summary>
/// Construct a new buffer
/// </summary>
/// <param name="capacity"></param>
/// <summary>
/// # of items
/// </summary>
/// <summary>
/// Add an element to the buffer
/// </summary>
/// <summary>
/// Add all the elements in the given buffer to this one
/// We can do this very efficiently using an Array Copy
/// </summary>
// Copy all the new elements in
/// <summary>
/// Set the count to zero but do NOT get rid of the actual buffer
/// </summary>
// Copy all the new elements in
/// <summary>
/// Reserve enough space for count elements
/// </summary>
// We want to reserve starting at a location past what is current committed. 
// No shifting needed
// reserving space within an already allocated portion of the buffer
// we'll ensure that the buffer can fit 'newCount' items, then shift by reserveCount starting at index
// Move to make room
/// <summary>
/// Reduce the buffer capacity so that its size is exactly == to the element count
/// </summary>
// PERF, astern, can this be made more efficient?  Does it need to be?
// If an item is not found, Search returns the bitwise negation of
// the index an item should inserted at;
// PERF, astern, how should we choose a new size?
// [low, high)
// Binary search is implemented here so we could look for a type that is different from the
// buffer type.  Also, the search switches to linear for 8 or fewer elements.
// [start, bound)
// Return the bitwise negation of the insertion index
// Return the bitwise negation of the insertion index
// private string _propertyName = "ManualFlowControlLimit"; // Used for eventing
// Used for eventing
// TODO: Events
//if (DiagnosticUtility.ShouldTraceWarning && !_didTraceThrottleLimit)
//{
//    _didTraceThrottleLimit = true;
//    TraceUtility.TraceEvent(
//        TraceEventType.Warning,
//        TraceCode.ManualFlowThrottleLimitReached,
//        SR.GetString(SR.TraceCodeManualFlowThrottleLimitReached,
//                     _propertyName, _owner));
//}
//Dictionary<string, string> domainNameMap;
//AuditLevel auditLevel = ServiceSecurityAuditBehavior.defaultMessageAuthenticationAuditLevel;
//AuditLogLocation auditLogLocation = ServiceSecurityAuditBehavior.defaultAuditLogLocation;
//bool suppressAuditFailure = ServiceSecurityAuditBehavior.defaultSuppressAuditFailure;
//this.auditLevel = dispatch.MessageAuthenticationAuditLevel;
//this.auditLogLocation = dispatch.SecurityAuditLogLocation;
//this.suppressAuditFailure = dispatch.SuppressAuditFailure;
// Impersonation behavior is required if 
// 1) Contract requires it or 
// 2) Contract allows it and config requires it
// a validation rule enforces that config cannot require impersonation in this case
// contract allows impersonation. Return true if config requires it.
// This requires P/Invokes to achieve on Windows. Not sure how to achieve it on Linux. For now not supporting this.
// A strategy is needed to cleanly move code which makes P/Invoke calls into a different package. One option might be
// to request support in WindowsIdentity in a future release of .NET Core and require that to use this feature.
//SecurityTraceRecordHelper.TraceImpersonationSucceeded(rpc.EventTraceActivity, rpc.Operation);
// update the impersonation succeed audit
//if (AuditLevel.Success == (this.auditLevel & AuditLevel.Success))
//{
//    SecurityAuditHelper.WriteImpersonationSuccessEvent(this.auditLogLocation,
//        this.suppressAuditFailure, rpc.Operation.Name, SecurityUtils.GetIdentityNamesFromContext(securityContext.AuthorizationContext));
//}
//SecurityTraceRecordHelper.TraceImpersonationFailed(rpc.EventTraceActivity, rpc.Operation, ex);
//
// Update the impersonation failure audit
// Copy SecurityAuthorizationBehavior.Audit level to here!!!
//
//                if (AuditLevel.Failure == (this.auditLevel & AuditLevel.Failure))
//                {
//                    try
//                    {
//                        string primaryIdentity;
//                        if (securityContext != null)
//                            primaryIdentity = SecurityUtils.GetIdentityNamesFromContext(securityContext.AuthorizationContext);
//                        else
//                            primaryIdentity = SecurityUtils.AnonymousIdentity.Name;
//                        SecurityAuditHelper.WriteImpersonationFailureEvent(this.auditLogLocation,
//                            this.suppressAuditFailure, rpc.Operation.Name, primaryIdentity, ex);
//                    }
//#pragma warning suppress 56500
//                    catch (Exception auditException)
//                    {
//                        if (Fx.IsFatal(auditException))
//                            throw;
//                        DiagnosticUtility.TraceHandledException(auditException, TraceEventType.Error);
//                    }
//                }
// SecurityContext.Anonymous
// On Desktop this code calls SECUR32.DLL!TranslateName to translate just the domain part of the downlevel name (DOMAIN\username) to a canonical name.
// It then removes the trailing slash and joines username, '@' and the canonical name to create the Upn name. It then caches the DOMAIN -> canonical mapping
// to make future lookups quicker. This is wrong and only works by happy accident of convention. Here's the breaking scenario:
// 
// An organization Example Inc. has multiple domains for different departments in the company. Two of them are ENGINEERING and FINANCE. The format of the usernames
// in the domain are first name followed by initial of last name. The AD domain names for these are engineering.example.org and finance.example.org and are in the 
// same forest. The format of the UPN account names are firstname.lastname@example.org. The engineer employee Bob Smith has a domain username of ENGINEERING\bobs but
// his UPN name is bob.smith@example.org. The implementation on Desktop will translate his domain account name to bobs@engineering.example.org which is incorrect.
//
// The incorrect implementation on Desktop allows for a small cache which makes lookups really fast because of the assumptions made which will often work. When mapping
// the domain name correctly, every account mapping would need to be cached. For now we're only caching the domain to ncname lookup and each lookup will result in a
// call to the DC to get the mapping. There are two potential improvements that can be done here.
//   1. Use a MRU cache to cache the full mapping.
//   2. Further up the call stack we actually have the user SID. It might be better to lookup the user by SID instead.
// 1) Read from cache
// 2) Not found, do expensive look up
//RootDSE"))
// No need to re-check and/or update under lock as the retrieved value will be the same each time. There's no harm
// if this is retrieved more than once.
// Retrieve the Configuration Naming Context from RootDSE
//" + configNC);
// Configure search to return ncname attribute
// Save in cache (remove a random item if cache is full)
//" + s_directoryServerName + @"/" + ncName;
// TODO: Maybe make lazy
// TODO: Wire up wasChannelThrottled
/*wasChannelThrottled*/ false, sessionIdleManager);
// TODO: Performance counters
//ServicePerformanceCountersBase servicePerformanceCounters;
//if (null != this.servicePerformanceCounters)
//{
//    this.servicePerformanceCounters.SetThrottleBase((int)ServicePerformanceCounters.PerfCounters.CallsPercentMaxCallsBase, Calls.Capacity);
//}
//if (null != this.servicePerformanceCounters)
//{
//    this.servicePerformanceCounters.SetThrottleBase((int)ServicePerformanceCounters.PerfCounters.SessionsPercentMaxSessionsBase, Sessions.Capacity);
//}
//if (null != this.servicePerformanceCounters)
//{
//    this.servicePerformanceCounters.SetThrottleBase((int)ServicePerformanceCounters.PerfCounters.InstancesPercentMaxInstancesBase, InstanceContexts.Capacity);
//}
//if (this.servicePerformanceCounters != null)
//{
//    InitializeInstancePerfCounterSettings(instanceContextsFt);
//}
//internal void SetServicePerformanceCounters(ServicePerformanceCountersBase counters)
//{
//    this.servicePerformanceCounters = counters;
//    //instance throttle is created through the behavior, set the perf counter callbacks if initialized
//    if (_instanceContexts != null)
//    {
//        InitializeInstancePerfCounterSettings(_instanceContexts);
//    }
//    //this.calls and this.sessions throttles are created by the constructor. Set the perf counter callbacks
//    InitializeCallsPerfCounterSettings();
//    InitializeSessionsPerfCounterSettings();
//}
//void InitializeInstancePerfCounterSettings(FlowThrottle instanceContextsFt)
//{
//    Fx.Assert(instanceContextsFt != null, "Expect instanceContext to be initialized");
//    Fx.Assert(this.servicePerformanceCounters != null, "expect servicePerformanceCounters to be set");
//    instanceContextsFt.SetAcquired(AcquiredInstancesToken);
//    instanceContextsFt.SetReleased(ReleasedInstancesToken);
//    instanceContextsFt.SetRatio(RatioInstancesToken);
//    this.servicePerformanceCounters.SetThrottleBase((int)ServicePerformanceCounters.PerfCounters.InstancesPercentMaxInstancesBase, instanceContextsFt.Capacity);
//}
//void InitializeCallsPerfCounterSettings()
//{
//    Fx.Assert(_calls != null, "Expect calls to be initialized");
//    Fx.Assert(this.servicePerformanceCounters != null, "expect servicePerformanceCounters to be set");
//    _calls.SetAcquired(AcquiredCallsToken);
//    _calls.SetReleased(ReleasedCallsToken);
//    _calls.SetRatio(RatioCallsToken);
//    this.servicePerformanceCounters.SetThrottleBase((int)ServicePerformanceCounters.PerfCounters.CallsPercentMaxCallsBase, _calls.Capacity);
//}
//void InitializeSessionsPerfCounterSettings()
//{
//    Fx.Assert(_sessions != null, "Expect sessions to be initialized");
//    Fx.Assert(this.servicePerformanceCounters != null, "expect servicePerformanceCounters to be set");
//    _sessions.SetAcquired(AcquiredSessionsToken);
//    _sessions.SetReleased(ReleasedSessionsToken);
//    _sessions.SetRatio(RatioSessionsToken);
//    this.servicePerformanceCounters.SetThrottleBase((int)ServicePerformanceCounters.PerfCounters.SessionsPercentMaxSessionsBase, _sessions.Capacity);
//}
//bool PrivateAcquireSessionListenerHandler(ListenerHandler listener)
//{
//    if ((_sessions != null) && (listener.Channel != null) && (listener.Channel.Throttle == null))
//    {
//        listener.Channel.Throttle = this;
//        return _sessions.Acquire(listener);
//    }
//    else
//    {
//        return true;
//    }
//}
// TODO: Lock removed. This code looks like it should be safe to execute without the lock. Need to verify.
//internal void AcquiredCallsToken()
//{
//    this.servicePerformanceCounters.IncrementThrottlePercent((int)ServicePerformanceCounters.PerfCounters.CallsPercentMaxCalls);
//}
//internal void ReleasedCallsToken()
//{
//    this.servicePerformanceCounters.DecrementThrottlePercent((int)ServicePerformanceCounters.PerfCounters.CallsPercentMaxCalls);
//}
//if (TD.ConcurrentCallsRatioIsEnabled())
//{
//    TD.ConcurrentCallsRatio(count, MaxConcurrentCalls);
//}
//internal void AcquiredInstancesToken()
//{
//    this.servicePerformanceCounters.IncrementThrottlePercent((int)ServicePerformanceCounters.PerfCounters.InstancesPercentMaxInstances);
//}
//internal void ReleasedInstancesToken()
//{
//    this.servicePerformanceCounters.DecrementThrottlePercent((int)ServicePerformanceCounters.PerfCounters.InstancesPercentMaxInstances);
//}
//if (TD.ConcurrentInstancesRatioIsEnabled())
//{
//    TD.ConcurrentInstancesRatio(count, MaxConcurrentInstances);
//}
//internal void AcquiredSessionsToken()
//{
//    this.servicePerformanceCounters.IncrementThrottlePercent((int)ServicePerformanceCounters.PerfCounters.SessionsPercentMaxSessions);
//}
//internal void ReleasedSessionsToken()
//{
//    this.servicePerformanceCounters.DecrementThrottlePercent((int)ServicePerformanceCounters.PerfCounters.SessionsPercentMaxSessions);
//}
//if (TD.ConcurrentSessionsRatioIsEnabled())
//{
//    TD.ConcurrentSessionsRatio(count, MaxConcurrentSessions);
//}
// we need to lock against the instance context for open since two different endpoints could
// share the same instance context, but different providers. So the provider lock does not guard
// the open process
//Set the IsUsercreated flag to false for singleton mode even in cases when users create their own runtime.
//Delay assigning the potentially newly created InstanceContext (till after its opened) to this.Singleton 
//to ensure that it is opened only once.
//no-op
//By default return false
//no-op
// If inner stream doesn't have sync implementation, don't continue on thread pool.
// TODO: For NetStandard 2.0, use async methods on writer
// drain
//: IStreamProvider
//Noop
// The method was duplicated from the desktop implementation of
// System.Xml.XmlDictionaryWriter.WriteValue(IStreamProvider)
// XmlDictionaryWriter has not implemented WriteBase64Async() yet.
//long beginOperation = 0;
//bool callSucceeded = false;
//bool callFaulted = false;
//EventTraceActivity eventTraceActivity = null;
//if (WcfEventSource.Instance.OperationCompletedIsEnabled() ||
//        WcfEventSource.Instance.OperationFaultedIsEnabled() ||
//        WcfEventSource.Instance.OperationFailedIsEnabled())
//{
//    beginOperation = DateTime.UtcNow.Ticks;
//    OperationContext context = OperationContext.Current;
//    if (context != null && context.IncomingMessage != null)
//    {
//        eventTraceActivity = EventTraceActivityHelper.TryExtractActivity(context.IncomingMessage);
//    }
//}
//ServiceModelActivity activity = null;
//IDisposable boundActivity = null;
//if (DiagnosticUtility.ShouldUseActivity)
//{
//    activity = ServiceModelActivity.CreateBoundedActivity(true);
//    boundActivity = activity;
//}
//else if (TraceUtility.MessageFlowTracingOnly)
//{
//    Guid activityId = TraceUtility.GetReceivedActivityId(OperationContext.Current);
//    if (activityId != Guid.Empty)
//    {
//        DiagnosticTraceBase.ActivityId = activityId;
//    }
//}
//else if (TraceUtility.ShouldPropagateActivity)
//{
//    //Message flow tracing only scenarios use a light-weight ActivityID management logic
//    Guid activityId = ActivityIdHeader.ExtractActivityId(OperationContext.Current.IncomingMessage);
//    if (activityId != Guid.Empty)
//    {
//        boundActivity = Activity.CreateActivity(activityId);
//    }
//}
//using (boundActivity)
//{
//    if (DiagnosticUtility.ShouldUseActivity)
//    {
//        ServiceModelActivity.Start(activity, SR.Format(SR.ActivityExecuteMethod, _method.DeclaringType.FullName, _method.Name), ActivityType.ExecuteUserCode);
//    }
//    if (WcfEventSource.Instance.OperationInvokedIsEnabled())
//    {
//        WcfEventSource.Instance.OperationInvoked(eventTraceActivity, MethodName, TraceUtility.GetCallerInfo(OperationContext.Current));
//    }
//callSucceeded = true;
//}
//callFaulted = true;
//if (beginOperation != 0)
//{
//    if (callSucceeded)
//    {
//        if (WcfEventSource.Instance.OperationCompletedIsEnabled())
//        {
//            WcfEventSource.Instance.OperationCompleted(eventTraceActivity, _methodName,
//                TraceUtility.GetUtcBasedDurationForTrace(beginOperation));
//        }
//    }
//    else if (callFaulted)
//    {
//        if (WcfEventSource.Instance.OperationFaultedIsEnabled())
//        {
//            WcfEventSource.Instance.OperationFaulted(eventTraceActivity, _methodName,
//                TraceUtility.GetUtcBasedDurationForTrace(beginOperation));
//        }
//    }
//    else
//    {
//        if (WcfEventSource.Instance.OperationFailedIsEnabled())
//        {
//            WcfEventSource.Instance.OperationFailed(eventTraceActivity, _methodName,
//                TraceUtility.GetUtcBasedDurationForTrace(beginOperation));
//        }
//    }
//}
// Only pass locals byref because InvokerUtil may store temporary results in the byref.
// If two threads both reference this.count, temporary results may interact.
// must set this last due to race
//bool callFailed = true;
//bool callFaulted = false;
//ServiceModelActivity activity = null;
//Activity boundOperation = null;
//AsyncMethodInvoker.GetActivityInfo(ref activity, ref boundOperation);
// This code would benefith from a rewrite to call TaskHelpers.ToApmEnd<Tuple<object, object[]>>
// When doing so make sure there is enought test coverage se PR comment at link below for a good starting point
// https://github.com/CoreWCF/CoreWCF/pull/54/files/8db6ff9ad6940a1056363defd1f6449adee56e1a#r333826132
// If invokeTask.IsFaulted we produce the 'callFaulted' behavior below.
// Any other exception will retain 'callFailed' behavior.
//callFaulted = true;
//callFailed = false;
// Rethrow inner exception as is
// Task cancellation without an exception indicates failure but we have no
// additional information to provide.  Accessing Task.Result will throw a
// TaskCanceledException.   For consistency between void Tasks and Task<T>,
// we detect and throw here.
//callFailed = false;
//if (boundOperation != null)
//{
//    ((IDisposable)boundOperation).Dispose();
//}
//ServiceModelActivity.Stop(activity);
//AsyncMethodInvoker.StopOperationInvokeTrace(callFailed, callFaulted, TaskMethod.Name);
//AsyncMethodInvoker.StopOperationInvokePerformanceCounters(callFailed, callFaulted, TaskMethod.Name);
//AsyncMethodInvoker.StartOperationInvokePerformanceCounters(taskMethod.Name);
//ServiceModelActivity activity = null;
//Activity boundActivity = null;
//AsyncMethodInvoker.CreateActivityInfo(ref activity, ref boundActivity);
//AsyncMethodInvoker.StartOperationInvokeTrace(taskMethod.Name);
//if (DiagnosticUtility.ShouldUseActivity)
//{
//    string activityName = SR.Format(SR.ActivityExecuteMethod, taskMethod.DeclaringType.FullName, taskMethod.Name);
//    ServiceModelActivity.Start(activity, activityName, ActivityType.ExecuteUserCode);
//}
// Only return once the task has completed                        
//if (boundActivity != null)
//{
//    ((IDisposable)boundActivity).Dispose();
//}
//ServiceModelActivity.Stop(activity);
// Any exception above means InvokeEnd will not be called, so complete it here.
//AsyncMethodInvoker.StopOperationInvokeTrace(callFailed, callFaulted, TaskMethod.Name);
//AsyncMethodInvoker.StopOperationInvokePerformanceCounters(callFailed, callFaulted, TaskMethod.Name);
// Only pass locals byref because InvokerUtil may store temporary results in the byref.
// If two threads both reference this.count, temporary results may interact.
// must set this last due to race
//
// IMessageFilterTable<FilterData> methods
//
//
// IDictionary<MessageFilter,FilterData> methods
//   
//
// ICollection<KeyValuePair<MessageFilter,FilterData>> methods
//
/*rootName*/, null /*rootNamespace*/, null /*xmlSerializer*/);
//try to get rootName and rootNamespace from type since root name not set explicitly
//schemas.xmlsoap.org/soap/encoding/";
//www.w3.org/2003/05/soap-encoding";
// TODO: Use overload which takes encoding once available
//, isEncoded ? GetEncoding(message.Version.Envelope) : null);
// TODO: XmlTextReader supported in .Net Standard 1.7, prohibiting DtdProcessing is important
//doc.Load(new XmlTextReader(memoryStream) { DtdProcessing = DtdProcessing.Prohibit });
//doc.Save(Console.Out);
/*mustUnderstand*/, null/*actor*/, false/*relay*/, element));
/*bufferWriter*/, headers[headerIndex], headers.GetReaderAtHeader(headerIndex));
/*
// TODO: Use overload with encoding once available
//, isEncoded ? GetEncoding(message.Version.Envelope) : null);
// all exceptions from XmlSerializer get wrapped in InvalidOperationException,
// so we must be conservative and never turn this into a fault
/*returnPart*/, messageInfo.RpcEncodedTypedMessageBodyParts, null/*returnValue*/, bodyPartValues);
// TODO: Switch to using encoding once available
//string encoding = isEncoded ? GetEncoding(version.Envelope) : null;
//, encoding);
/*returnPart*/, messageInfo.RpcEncodedTypedMessageBodyParts, bodyPartValues, isRequest);
// TODO: Use overload which takes encoding once available
//, isEncoded ? GetEncoding(version.Envelope) : null);
// all exceptions from XmlSerializer get wrapped in InvalidOperationException,
// so we must be conservative and never turn this into a fault
//assert(matchingMessageHeaderOfTAttribute != null);
//www.w3.org/2000/09/xmldsig#";
//www.w3.org/2000/09/xmldsig#enveloped-signature";
//docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd";
//www.w3.org/2001/10/xml-exc-c14n#";
//www.w3.org/2001/04/xmlenc#aes128-cbc";
//www.w3.org/2001/04/xmlenc#kw-aes128";
//www.w3.org/2001/04/xmlenc#aes192-cbc";
//www.w3.org/2001/04/xmlenc#kw-aes192";
//www.w3.org/2001/04/xmlenc#aes256-cbc";
//www.w3.org/2001/04/xmlenc#kw-aes256";
//www.w3.org/2001/04/xmlenc#des-cbc";
//www.w3.org/2000/09/xmldsig#dsa-sha1";
//www.w3.org/2001/10/xml-exc-c14n#WithComments";
//www.w3.org/2000/09/xmldsig#hmac-sha1";
//www.w3.org/2001/04/xmldsig-more#hmac-sha256";
//schemas.xmlsoap.org/ws/2005/02/sc/dk/p_sha1";
//www.w3.org/2001/04/xmlenc#ripemd160";
//www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p";
//www.w3.org/2000/09/xmldsig#rsa-sha1";
//www.w3.org/2001/04/xmldsig-more#rsa-sha256";
//www.w3.org/2001/04/xmlenc#rsa-1_5";
//www.w3.org/2000/09/xmldsig#sha1";
//www.w3.org/2001/04/xmlenc#sha256";
//www.w3.org/2001/04/xmlenc#sha512";
//www.w3.org/2001/04/xmlenc#tripledes-cbc";
//www.w3.org/2001/04/xmlenc#kw-tripledes";
//schemas.xmlsoap.org/2005/02/trust/tlsnego#TLS_Wrap";
//schemas.xmlsoap.org/2005/02/trust/spnego#GSS_Wrap";
//docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary";
//docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#HexBinary";
//docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Text";
//docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509SubjectKeyIdentifier";
//docs.oasis-open.org/wss/oasis-wss-kerberos-token-profile-1.1#GSS_Kerberosv5_AP_REQ";
//docs.oasis-open.org/wss/oasis-wss-kerberos-token-profile-1.1#GSS_Kerberosv5_AP_REQ1510";
//docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.0#SAMLAssertionID";
//docs.oasis-open.org/wss/oasis-wss-rel-token-profile-1.0.pdf#license";
//docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd";
//docs.oasis-open.org/wss/oasis-wss-kerberos-token-profile-1.1#Kerberosv5APREQSHA1";
//docs.oasis-open.org/wss/oasis-wss-soap-message-security-1.1#ThumbprintSHA1";
//docs.oasis-open.org/wss/oasis-wss-soap-message-security-1.1#EncryptedKey";
//docs.oasis-open.org/wss/oasis-wss-soap-message-security-1.1#EncryptedKeySHA1";
//docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV1.1";
//docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV2.0";
//docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLID";
//docs.oasis-open.org/wss/oasis-wss-wssecurity-secext-1.1.xsd";
//www.w3.org/2001/04/xmlenc#";
//www.w3.org/2001/04/xmlenc#Element";
//www.w3.org/2001/04/xmlenc#Content";
//schemas.xmlsoap.org/ws/2005/02/sc";
//schemas.xmlsoap.org/ws/2005/02/sc/dk";
//schemas.xmlsoap.org/ws/2005/02/sc/sct";
//schemas.xmlsoap.org/ws/2005/02/trust/RST/SCT";
//schemas.xmlsoap.org/ws/2005/02/trust/RSTR/SCT";
//schemas.xmlsoap.org/ws/2005/02/trust/RST/SCT/Renew";
//schemas.xmlsoap.org/ws/2005/02/trust/RSTR/SCT/Renew";
//schemas.xmlsoap.org/ws/2005/02/trust/RST/SCT/Cancel";
//schemas.xmlsoap.org/ws/2005/02/trust/RSTR/SCT/Cancel";
//schemas.xmlsoap.org/ws/2005/02/trust";
//schemas.xmlsoap.org/ws/2005/02/trust#BinarySecret";
//schemas.microsoft.com/net/2004/07/secext/WS-SPNego";
//schemas.microsoft.com/net/2004/07/secext/TLSNego";
//schemas.xmlsoap.org/ws/2005/02/trust/RST/Issue";
//schemas.xmlsoap.org/ws/2005/02/trust/RSTR/Issue";
//schemas.xmlsoap.org/ws/2005/02/trust/Issue";
//schemas.xmlsoap.org/ws/2005/02/trust/SymmetricKey";
//schemas.xmlsoap.org/ws/2005/02/trust/CK/PSHA1";
//schemas.xmlsoap.org/ws/2005/02/trust/Nonce";
//schemas.xmlsoap.org/ws/2005/02/trust/Renew";
//schemas.xmlsoap.org/ws/2005/02/trust/Cancel";
//schemas.xmlsoap.org/ws/2005/02/trust/PublicKey";
//schemas.xmlsoap.org/ws/2005/02/trust/spnego";
//schemas.xmlsoap.org/ws/2005/02/trust/tlsnego";
//docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue";
//docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/Issue";
//docs.oasis-open.org/ws-sx/ws-trust/200512/Issue";
//docs.oasis-open.org/ws-sx/ws-trust/200512/AsymmetricKey";
//docs.oasis-open.org/ws-sx/ws-trust/200512/SymmetricKey";
//docs.oasis-open.org/ws-sx/ws-trust/200512/Nonce";
//docs.oasis-open.org/ws-sx/ws-trust/200512/CK/PSHA1";
//docs.oasis-open.org/ws-sx/ws-trust/200512/PublicKey";
//docs.oasis-open.org/ws-sx/ws-trust/200512";
//docs.oasis-open.org/ws-sx/ws-trust/200512#BinarySecret";
//docs.oasis-open.org/ws-sx/ws-trust/200512/RSTRC/IssueFinal";
//docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Renew";
//docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/Renew";
//docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/RenewFinal";
//docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Cancel";
//docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/Cancel";
//docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/CancelFinal";
//docs.oasis-open.org/ws-sx/ws-trust/200512/Renew";
//docs.oasis-open.org/ws-sx/ws-trust/200512/Cancel";
//docs.oasis-open.org/ws-sx/ws-trust/200512/Bearer";
//schemas.xmlsoap.org/ws/2005/05/identity";
//docs.oasis-open.org/ws-sx/ws-secureconversation/200512/dk/p_sha1";
//docs.oasis-open.org/ws-sx/ws-secureconversation/200512/dk";
//docs.oasis-open.org/ws-sx/ws-secureconversation/200512/sct";
//docs.oasis-open.org/ws-sx/ws-trust/200512/RST/SCT";
//docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/SCT";
//docs.oasis-open.org/ws-sx/ws-trust/200512/RST/SCT/Renew";
//docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/SCT/Renew";
//docs.oasis-open.org/ws-sx/ws-trust/200512/RST/SCT/Cancel";
//docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/SCT/Cancel";
//docs.oasis-open.org/ws-sx/ws-secureconversation/200512";
// All subclasses are required to be thread-safe and immutable
// Self-resolving clauses such as RSA and X509 raw data should
// override CanCreateKey and return true, and implement
// CreateKey()
// mapped from a cert
// + and -  TimeSpan.TicksPerDay is to compensate the DateTime.ParseExact (to localtime) overflow.
// + and -  TimeSpan.TicksPerDay is to compensate the DateTime.ParseExact (to localtime) overflow.
// Check that Dispose() and Reset() do the same thing
// This is the workaround, Since store.Certificates returns a full collection
// of certs in store.  These are holding native resources.
// Main dictionary strings
// String constants
//docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#STR-Transform";
// Main dictionary strings
// String interning is only supported in .Net standard 1.7. Api tool says this is slow?
//this.claimType = StringUtil.OptimizeString(claimType);
//this.right = StringUtil.OptimizeString(right);
// Turn key claims
//public static Claim CreateDenyOnlyWindowsSidClaim(SecurityIdentifier sid)
//{
//    if (sid == null)
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(sid));
//    return new Claim(ClaimTypes.DenyOnlySid, sid, Rights.PossessProperty);
//}
//public static Claim CreateHashClaim(byte[] hash)
//{
//    if (hash == null)
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(hash));
//    return new Claim(ClaimTypes.Hash, SecurityUtils.CloneBuffer(hash), Rights.PossessProperty, ClaimComparer.Hash);
//}
//static IEqualityComparer<Claim> rsaComparer;
//static IEqualityComparer<Claim> upnComparer;
//static IEqualityComparer<Claim> x500DistinguishedNameComparer;
//if (rsaComparer == null)
//{
//    rsaComparer = new ClaimComparer(new RsaObjectComparer());
//}
//return rsaComparer;
//if (upnComparer == null)
//{
//    upnComparer = new ClaimComparer(new UpnObjectComparer());
//}
//return upnComparer;
//if (x500DistinguishedNameComparer == null)
//{
//    x500DistinguishedNameComparer = new ClaimComparer(new X500DistinguishedNameObjectComparer());
//}
//return x500DistinguishedNameComparer;
// we still need to review how the default equals works, this is not how Doug envisioned it.
//class RsaObjectComparer : IEqualityComparer
//{
//    bool IEqualityComparer.Equals(object obj1, object obj2)
//    {
//        if (ReferenceEquals(obj1, obj2))
//            return true;
//        RSA rsa1 = obj1 as RSA;
//        RSA rsa2 = obj2 as RSA;
//        if (rsa1 == null || rsa2 == null)
//            return false;
//        RSAParameters parm1 = rsa1.ExportParameters(false);
//        RSAParameters parm2 = rsa2.ExportParameters(false);
//        if (parm1.Modulus.Length != parm2.Modulus.Length ||
//            parm1.Exponent.Length != parm2.Exponent.Length)
//            return false;
//        for (int i = 0; i < parm1.Modulus.Length; ++i)
//        {
//            if (parm1.Modulus[i] != parm2.Modulus[i])
//                return false;
//        }
//        for (int i = 0; i < parm1.Exponent.Length; ++i)
//        {
//            if (parm1.Exponent[i] != parm2.Exponent[i])
//                return false;
//        }
//        return true;
//    }
//    int IEqualityComparer.GetHashCode(object obj)
//    {
//        RSA rsa = obj as RSA;
//        if (rsa == null)
//            return 0;
//        RSAParameters parm = rsa.ExportParameters(false);
//        return parm.Modulus.Length ^ parm.Exponent.Length;
//    }
//}
//class X500DistinguishedNameObjectComparer : IEqualityComparer
//{
//    IEqualityComparer binaryComparer;
//    public X500DistinguishedNameObjectComparer()
//    {
//        binaryComparer = new BinaryObjectComparer();
//    }
//    bool IEqualityComparer.Equals(object obj1, object obj2)
//    {
//        if (ReferenceEquals(obj1, obj2))
//            return true;
//        X500DistinguishedName dn1 = obj1 as X500DistinguishedName;
//        X500DistinguishedName dn2 = obj2 as X500DistinguishedName;
//        if (dn1 == null || dn2 == null)
//            return false;
//        // 1) Hopefully cover most cases (perf reason).
//        if (StringComparer.Ordinal.Equals(dn1.Name, dn2.Name))
//            return true;
//        // 2) Raw byte compare.  Note: we assume the rawbyte is in the same order 
//        // (default = X500DistinguishedNameFlags.Reversed). 
//        return binaryComparer.Equals(dn1.RawData, dn2.RawData);
//    }
//    int IEqualityComparer.GetHashCode(object obj)
//    {
//        X500DistinguishedName dn = obj as X500DistinguishedName;
//        if (dn == null)
//            return 0;
//        return binaryComparer.GetHashCode(dn.RawData);
//    }
//}
//class UpnObjectComparer : IEqualityComparer
//{
//    bool IEqualityComparer.Equals(object obj1, object obj2)
//    {
//        if (StringComparer.OrdinalIgnoreCase.Equals(obj1, obj2))
//            return true;
//        string upn1 = obj1 as string;
//        string upn2 = obj2 as string;
//        if (upn1 == null || upn2 == null)
//            return false;
//        SecurityIdentifier sid1;
//        if (!TryLookupSidFromName(upn1, out sid1))
//            return false;
//        // Normalize to sid
//        SecurityIdentifier sid2;
//        if (!TryLookupSidFromName(upn2, out sid2))
//            return false;
//        return sid1 == sid2;
//    }
//    int IEqualityComparer.GetHashCode(object obj)
//    {
//        string upn = obj as string;
//        if (upn == null)
//            return 0;
//        // Normalize to sid
//        SecurityIdentifier sid;
//        if (TryLookupSidFromName(upn, out sid))
//            return sid.GetHashCode();
//        return StringComparer.OrdinalIgnoreCase.GetHashCode(upn);
//    }
//    bool TryLookupSidFromName(string upn, out SecurityIdentifier sid)
//    {
//        sid = null;
//        try
//        {
//            NTAccount acct = new NTAccount(upn);
//            sid = acct.Translate(typeof(SecurityIdentifier)) as SecurityIdentifier;
//        }
//        catch (IdentityNotMappedException e)
//        {
//            DiagnosticUtility.TraceHandledException(e, TraceEventType.Information);
//        }
//        return sid != null;
//    }
//}
// Note: null string represents any.
// used in info card 
// claims.AddRange(Groups);
// Note: null string represents any.
// Not sure yet if GroupSidClaimCollections are necessary in .NET Core, but default 
// _includeWindowsGroups is true; don't throw here or we bust the default case on UWP/.NET Core
// SelfSigned?
// Ordering SubjectName, Dns, SimpleName, Email, Upn
// Note: null string represents any.
// old behavior, default for <= 4.6
// We don't have a strongly typed extension to parse Subject Alt Names, so we have to do a workaround 
// to figure out what the identifier, delimiter, and separator is by using a well-known extension
// static initializer will run before properties are accessed
// Extracted a well-known X509Extension
// Each OS has a different dNSName identifier and delimiter
// On Windows, dNSName == "DNS Name" (localizable), on Linux, dNSName == "DNS"
// e.g.,
// Windows: x509ExtensionFormattedString is: "DNS Name=not-real-subject-name, DNS Name=example.com"
// Linux:   x509ExtensionFormattedString is: "DNS:not-real-subject-name, DNS:example.com"
// Parse: <identifier><delimiter><value><separator(s)>
// Make an assumption that all characters from the the start of string to the delimiter 
// are part of the identifier
// We advance until the first character of the identifier to determine what the
// separator is. This assumes that the identifier assumption above is correct
//
// DCR 48092: PrincipalPermission authorization using certificates could cause Elevation of Privilege.
// because there could be duplicate subject name.  In order to be more unique, we use SubjectName + Thumbprint
// instead
//
//schemas.xmlsoap.org/ws/2005/05/identity";
//return SecurityUtils.CreateDefaultAuthorizationContext(authorizationPolicies);
// Issues claimsets whose conditions (if any) have been evaluated.
// TODO: Consider changing to System.Security.Claims, need to get community feedback
// Evaluates conditions (if any) against the context, may add grants to the context
// Return 'false' if for this evaluation, should be called again if claims change. (eg. not done)
// Return 'true' if no more claims will be added regardless of changes for this evaluation (eg. done).
// 'state' is good for this evaluation only. Will be null if starting again.
// Implementations should expect to be called multiple times on different threads.
// Preferably Non-Anonymous
// Preferably Non-Anonymous
// null if other overrides the property with something else
// protected methods
//schemas.microsoft.com/ws/2006/05/identitymodel/securitytokenrequirement";
// TODO: Evaluate removing this class and all usages as the full framework implementation has a lot more functionality.
/// <summary>
/// SecurityTokenSerializer is responsible for writing and reading SecurityKeyIdentifiers, SecurityKeyIdentifierClauses and SecurityTokens.
/// In order to read SecurityTokens the SecurityTokenSerializer may need to resolve token references using the SecurityTokenResolvers that get passed in.
/// The SecurityTokenSerializer is stateless
/// Exceptions: XmlException, SecurityTokenException, NotSupportedException, InvalidOperationException, ArgumentException
/// </summary>
// public methods
// protected abstract methods
// TODO: Either consider moving this back to System.IdentityModel.Selectors and/or move to ServiceModel and make async
// TODO: Consider creating platform specific package which contains windows only implementations such as NTAuthChainTrust
// Checklist
// 1) time validity of cert
// 2) in trusted people store
// 3) not in disallowed store
// The following code could be written as:
// DateTime now = DateTime.UtcNow;
// if (now > certificate.NotAfter.ToUniversalTime() || now < certificate.NotBefore.ToUniversalTime())
//
// this is because X509Certificate2.xxx doesn't return UT.  However this would be a SMALL perf hit.
// I put a DebugAssert so that this will ensure that the we are compatible with the CLR we shipped with
// Ensure NT_AUTH chain policy for certificate account mapping
//X509CertificateValidator.NTAuthChainTrust.Validate(x509Token.Certificate);
//WindowsIdentity windowsIdentity = null;
//windowsIdentity = KerberosCertificateLogon(x509Token.Certificate);
//windowsClaimSet = new WindowsClaimSet(windowsIdentity, SecurityUtils.AuthTypeCertMap, this.includeWindowsGroups, false);
// Never expire
//schemas.microsoft.com/ws/2006/05/identitymodel/tokens";
//docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV1.1";
//docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV2.0";
// Never expire
// if the cert needs to be cloned then the token owns the clone and should dispose it
// I believe this is only used in MessageSecurity
// TODO: Make internal again. I had to expose this for cross assembly usage
//SecurityContext context;
//if (Action<object>ActionItem.ShouldUseActivity ||
//    Fx.Trace.IsEnd2EndActivityTracingEnabled)
//{
//    new DefaultActionItem(callback, state, lowPriority).Schedule();
//}
//else
//{
//}
//if (this.context != null)
//{
//    ScheduleCallback(CallbackHelper.InvokeWithContextCallback);
//}
//else
//{
//}
//protected void ScheduleWithContext(SecurityContext context)
//{
//    if (context == null)
//    {
//        throw Fx.Exception.ArgumentNull("context");
//    }
//    if (isScheduled)
//    {
//        throw Fx.Exception.AsError(new InvalidOperationException(InternalSR.ActionItemIsAlreadyScheduled));
//    }
//    this.isScheduled = true;
//    this.context = context.CreateCopy();
//    ScheduleCallback(CallbackHelper.InvokeWithContextCallback);
//}
//SecurityContext ExtractContext()
//{
//    Fx.Assert(this.context != null, "Cannot bind to a null context; context should have been set by now");
//    Fx.Assert(this.isScheduled, "Context is extracted only while the object is scheduled");
//    SecurityContext result = this.context;
//    this.context = null;
//    return result;
//}
//SecurityContext context = ((ActionItem)state).ExtractContext();
//SecurityContext.Run(context, OnContextAppliedCallback, state);
//bool flowLegacyActivityId;
//Guid activityId;
//EventTraceActivity eventTraceActivity;
//if (Action<object>ActionItem.ShouldUseActivity)
//{
//    this.flowLegacyActivityId = true;
//    this.activityId = EtwDiagnosticTrace.ActivityId;
//}
//if (Fx.Trace.IsEnd2EndActivityTracingEnabled)
//{
//    this.eventTraceActivity = EventTraceActivity.GetFromThreadOrCreate();
//    if (TraceCore.ActionItemScheduledIsEnabled(Fx.Trace))
//    {
//        TraceCore.ActionItemScheduled(Fx.Trace, this.eventTraceActivity);
//    }
//}
//if (this.flowLegacyActivityId || Fx.Trace.IsEnd2EndActivityTracingEnabled)
//{
//    TraceAndInvoke();
//}
//else
//{
//}
//TODO:  Consider merging these since they go through the same codepath.
//if (this.flowLegacyActivityId)
//{
//    Guid currentActivityId = EtwDiagnosticTrace.ActivityId;
//    try
//    {
//        EtwDiagnosticTrace.ActivityId = this.activityId;
//        this.callback(this.state);
//    }
//    finally
//    {
//        EtwDiagnosticTrace.ActivityId = currentActivityId;
//    }
//}
//else
//{
//if (this.eventTraceActivity != null)
//{
//    previous = Trace.CorrelationManager.ActivityId;
//    restoreActivityId = true;
//    Trace.CorrelationManager.ActivityId = this.eventTraceActivity.ActivityId;
//    if (TraceCore.ActionItemCallbackInvokedIsEnabled(Fx.Trace))
//    {
//        TraceCore.ActionItemCallbackInvoked(Fx.Trace, this.eventTraceActivity);
//    }
//}
//Trace.CorrelationManager.ActivityId = previous;
//}
// The queue of tasks to execute, maintained for debugging purposes
// An alternative implementation would be to pass the Task directly
// to the OnTaskQueued method. Using an intermediate queue might cause
// a performance bottleneck. Profiling will be needed to determine.
// Unless this is discovered to be a problem, using an intermediate
// queue to aid in debugging.
// This class is based on the blog post https://blogs.msdn.microsoft.com/pfxteam/2012/02/11/building-async-coordination-primitives-part-1-asyncmanualresetevent/
// Disposed
// TODO: Consider making Async
// requires an explicit call to Init() by the caller
//public override IAsyncResult BeginRead(byte[] buffer, int offset, int size, AsyncCallback callback, object state)
//{
//    throw Fx.Exception.AsError(new NotSupportedException(SR.ReadNotSupported));
//}
//public override int EndRead(IAsyncResult result)
//{
//    throw Fx.Exception.AsError(new NotSupportedException(SR.ReadNotSupported));
//}
//public override IAsyncResult BeginWrite(byte[] buffer, int offset, int size, AsyncCallback callback, object state)
//{
//    Write(buffer, offset, size);
//    return new CompletedAsyncResult(callback, state);
//}
//public override void EndWrite(IAsyncResult result)
//{
//    CompletedAsyncResult.End(result);
//}
//public override void Close()
//{
//}
// Users like ServiceModel can hook this abort ICommunicationObject or handle other non-IDisposable objects
// Users like ServiceModel can hook this to wrap the AsyncQueueReader callback functionality for tracing, etc
// TODO: Create derived CancellationToken which carries original timeout with it
// queueState == QueueState.Closed
// dequeuedCallback is called as an item is dequeued from the InputQueue.  The 
// InputQueue lock is not held during the callback.  However, the user code will
// not be notified of the item being available until the callback returns.  If you
// are not sure if the callback will block for a long time, then first call 
// IOThreadScheduler.ScheduleCallback to get to a "safe" thread.
// Don't let any more items in. Differs from Close in that we keep around
// existing items in our itemQueue for possible future calls to Dequeue
// queueState == QueueState.Closed
// queueState == QueueState.Closed || queueState == QueueState.Shutdown
// This will not block, however, Dispatch() must be called later if this function
// returns true.
// Open
// Used for timeouts. The InputQueue must remove readers from its reader queue to prevent
// dispatching items to timed out readers.
//if (TraceCore.BufferPoolChangeQuotaIsEnabled(Fx.Trace))
//{
//    TraceCore.BufferPoolChangeQuota(Fx.Trace, bufferPool.BufferSize, delta);
//}
//if (TraceCore.BufferPoolAllocationIsEnabled(Fx.Trace))
//{
//    TraceCore.BufferPoolAllocation(Fx.Trace, bufferPool.BufferSize);
//}
//if (TraceCore.BufferPoolAllocationIsEnabled(Fx.Trace))
//{
//    TraceCore.BufferPoolAllocation(Fx.Trace, bufferSize);
//}
// Don't bother if another thread already has the lock
// find the "poorest" pool
// find the "richest" pool
// steal from the richest
// give to the poorest
// reset statistics
// To avoid many buffer drops during training of large objects which
// get allocated on the LOH, we use the LargeBufferPool and for 
// bufferSize < 85000, the SynchronizedPool. However if bufferSize < 85000
// and (bufferSize + array-overhead) > 85000, this would still use 
// the SynchronizedPool even though it is allocated on the LOH.
// do nothing, GC will reclaim this buffer
// Returns true if this brings the gate to the Signalled state.
// Transitions - Locked -> SignalPending | Completed before it was unlocked
//               Unlocked -> Signaled
// Returns true if this brings the gate to the Signalled state.
// Transitions - SignalPending -> Signaled | return the AsyncResult since the callback already 
//                                         | completed and provided the result on its thread
//               Locked -> Unlocked
// This is factored out to allow Signal and Unlock to be inlined.
// A simple synchronized pool would simply lock a stack and push/pop on return/take.
//
// This implementation tries to reduce locking by exploiting the case where an item
// is taken and returned by the same thread, which turns out to be common in our 
// scenarios.  
//
// Initially, all the quota is allocated to a global (non-thread-specific) pool, 
// which takes locks.  As different threads take and return values, we record their IDs, 
// and if we detect that a thread is taking and returning "enough" on the same thread, 
// then we decide to "promote" the thread.  When a thread is promoted, we decrease the 
// quota of the global pool by one, and allocate a thread-specific entry for the thread 
// to store it's value.  Once this entry is allocated, the thread can take and return 
// it's value from that entry without taking any locks.  Not only does this avoid 
// locks, but it affinitizes pooled items to a particular thread.
//
// There are a couple of additional things worth noting:
// 
// It is possible for a thread that we have reserved an entry for to exit.  This means
// we will still have a entry allocated for it, but the pooled item stored there 
// will never be used.  After a while, we could end up with a number of these, and 
// as a result we would begin to exhaust the quota of the overall pool.  To mitigate this
// case, we throw away the entire per-thread pool, and return all the quota back to 
// the global pool if we are unable to promote a thread (due to lack of space).  Then 
// the set of active threads will be re-promoted as they take and return items.
// 
// You may notice that the code does not immediately promote a thread, and does not
// immediately throw away the entire per-thread pool when it is unable to promote a 
// thread.  Instead, it uses counters (based on the number of calls to the pool) 
// and a threshold to figure out when to do these operations.  In the case where the
// pool to misconfigured to have too few items for the workload, this avoids constant 
// promoting and rebuilding of the per thread entries.
//
// You may also notice that we do not use interlocked methods when adjusting statistics.
// Since the statistics are a heuristic as to how often something is happening, they 
// do not need to be perfect.
// 
//: base(traceSourceName)
//            try
//            {
//                this.TraceSourceName = traceSourceName;
//                this.EventSourceName = string.Concat(this.TraceSourceName, " ", EventSourceVersion);
//                CreateTraceSource();
//            }
//            catch (Exception exception)
//            {
//                if (Fx.IsFatal(exception))
//                {
//                    throw;
//                }
//#pragma warning disable 618
//                EventLogger logger = new EventLogger(this.EventSourceName, null);
//                logger.LogEvent(TraceEventType.Error, TracingEventLogCategory, (uint)System.Runtime.Diagnostics.EventLogEventId.FailedToSetupTracing, false,
//                    exception.ToString());
//#pragma warning restore 618
//            }
//            try
//            {
//                CreateEtwProvider(etwProviderId);
//            }
//            catch (Exception exception)
//            {
//                if (Fx.IsFatal(exception))
//                {
//                    throw;
//                }
//                this.etwProvider = null;
//#pragma warning disable 618
//                EventLogger logger = new EventLogger(this.EventSourceName, null);
//                logger.LogEvent(TraceEventType.Error, TracingEventLogCategory, (uint)System.Runtime.Diagnostics.EventLogEventId.FailedToSetupTracing, false,
//                    exception.ToString());
//#pragma warning restore 618
//            }
//            if (this.TracingEnabled || this.EtwTracingEnabled)
//            {
//#pragma warning disable 618
//                this.AddDomainEventHandlersForCleanup();
//#pragma warning restore 618
//            }
//if (DiagnosticUtility.ShouldTraceInformation)
//    TraceUtility.TraceEvent(TraceEventType.Information, TraceCode.SecurityIdentityDeterminationFailure, SR.Format(SR.TraceCodeSecurityIdentityDeterminationFailure), new IdentityDeterminationFailureTraceRecord(epr, identityVerifier));
//if (DiagnosticUtility.ShouldTraceInformation)
//    TraceUtility.TraceEvent(TraceEventType.Information, TraceCode.SecurityIdentityDeterminationSuccess, SR.Format(SR.TraceCodeSecurityIdentityDeterminationSuccess), new IdentityDeterminationSuccessTraceRecord(epr, identity, identityVerifier));
//if (DiagnosticUtility.ShouldTraceInformation)
//    TraceUtility.TraceEvent(TraceEventType.Information, TraceCode.SecurityIdentityVerificationFailure, SR.Format(SR.TraceCodeSecurityIdentityVerificationFailure), new IdentityVerificationFailureTraceRecord(identity, authContext, identityVerifier));
// The classes in this file are used for invoking APIs that exist in System.Xml.XmlSerializer  
// via reflection. Those APIs are not supposed to be used by application developers, thus we 
// cannot add them into public contract.
//internal interface IXmlMappingTypeInnerObject
//{
//    IXmlMappingTypeWrapperObject Object { get; }
//}
//internal class XmlReflectionImporter
//{
//    private static readonly MethodInfo s_importMembersMapping;
//    private static readonly MethodInfo s_importTypeMapping;
//    private static readonly MethodInfo s_includeType;
//    private IXmlMappingTypeWrapperObject _wrapperObject;
//    public XmlReflectionImporter() : this(null)
//    {
//    }
//    public XmlReflectionImporter(string defaultNs)
//    {
//        _wrapperObject =
//            XmlMappingTypeWrapperFactory.GetWrapper(
//                XmlMappingTypesHelper.XmlReflectionImporterType, new object[] {defaultNs});
//    }
//    static XmlReflectionImporter()
//    {
//        IXmlMappingTypeWrapperObject wrapperObject =
//            XmlMappingTypeWrapperFactory.GetWrapper(
//                XmlMappingTypesHelper.XmlReflectionImporterType, new object[] {"defaultNs"});
//        Type[] types;
//        if (XmlMappingTypesHelper.XmlReflectionMemberType != null)
//        {
//            types = new Type[]
//            {
//                typeof (string),
//                typeof (string),
//                XmlMappingTypesHelper.XmlReflectionMemberType.MakeArrayType(),
//                typeof (bool),
//                typeof (bool)
//            };
//            s_importMembersMapping = wrapperObject.GetMethod("ImportMembersMapping", types);
//        }
//        else
//        {
//            // XmlMappingTypesHelper.XmlReflectionMemberType is null only at pure Net Native runtime.
//            // In that case, we don't really need to set the following method.
//            s_importMembersMapping = null;
//        }
//        types = new Type[] {typeof (Type)};
//        s_importTypeMapping = wrapperObject.GetMethod("ImportTypeMapping", types);
//        s_includeType = wrapperObject.GetMethod("IncludeType", types);
//    }
//    public XmlMembersMapping ImportMembersMapping(string mappingName, string ns, XmlReflectionMember[] members, bool hasWrapperElement, bool rpc)
//    {
//        Array membersObjects =
//            _wrapperObject.InitializeArray(XmlMappingTypesHelper.XmlReflectionMemberType, members);
//        object[] parameters = new object[] {mappingName, ns, membersObjects, hasWrapperElement, rpc};
//        object o = _wrapperObject.CallMethod(s_importMembersMapping, parameters);
//        return new XmlMembersMapping(o);
//    }
//    public XmlTypeMapping ImportTypeMapping(Type type)
//    {
//        Type[] types = new Type[] {typeof (Type)};
//        object[] parameters = new object[] {type};
//        object o = _wrapperObject.CallMethod(s_importTypeMapping, parameters);
//        return new XmlTypeMapping(o);
//    }
//    public void IncludeType(Type knownType)
//    {
//        Type[] types = new Type[] {typeof (Type)};
//        object[] parameters = new object[] {knownType};
//        _wrapperObject.CallMethod(s_includeType, parameters);
//    }
//}
//internal abstract class XmlMapping : IXmlMappingTypeInnerObject
//{
//    protected IXmlMappingTypeWrapperObject _wrapperObject;
//    private static MethodInfo s_setKey;
//    private static bool s_setKeyInitialized;
//    public XmlMapping(object thisObject)
//    {
//        this._wrapperObject = XmlMappingTypeWrapperFactory.GetWrapper(thisObject);
//    }
//    public IXmlMappingTypeWrapperObject Object => _wrapperObject;
//    public string ElementName => (string) _wrapperObject.GetProperty("ElementName");
//    public string Namespace => (string) _wrapperObject.GetProperty("Namespace");
//    public string XsdElementName => (string) _wrapperObject.GetProperty("XsdElementName");
//    private string _key;
//    internal string Key => _key;
//    public void SetKey(string key)
//    {
//        if (!s_setKeyInitialized)
//        {
//            Type[] types = new Type[] {typeof (string)};
//            s_setKey = _wrapperObject.GetMethod("SetKey", types);
//            s_setKeyInitialized = true;
//        }
//        object[] parameters = new object[] {key};
//        _wrapperObject.CallMethod(s_setKey, parameters);
//        _key = key;
//    }
//}
//internal class XmlTypeMapping : XmlMapping
//{
//    public XmlTypeMapping(object o)
//        : base(o)
//    {
//    }
//}
//internal class XmlMembersMapping : XmlMapping
//{
//    public XmlMembersMapping(object o)
//        : base(o)
//    {
//    }
//    public XmlMemberMapping this[int index]
//    {
//        get
//        {
//            object o = _wrapperObject.GetIndexerProperty(
//                XmlMappingTypesHelper.XmlMemberMappingType, index);
//            return new XmlMemberMapping(o);
//        }
//    }
//}
//internal class XmlMemberMapping
//{
//    private IXmlMappingTypeWrapperObject _wrapperObject;
//    public XmlMemberMapping(object o)
//    {
//        _wrapperObject = XmlMappingTypeWrapperFactory.GetWrapper(o);
//    }
//    public string XsdElementName => (string) _wrapperObject.GetProperty("XsdElementName");
//    public string Namespace => (string) _wrapperObject.GetProperty("Namespace");
//    public string TypeName => (string) _wrapperObject.GetProperty("TypeName");
//    public string TypeNamespace => (string) _wrapperObject.GetProperty("TypeNamespace");
//}
//internal class XmlReflectionMember : IXmlMappingTypeInnerObject
//{
//    private IXmlMappingTypeWrapperObject _wrapperObject;
//    public XmlReflectionMember()
//    {
//        _wrapperObject = XmlMappingTypeWrapperFactory.GetWrapper(XmlMappingTypesHelper.XmlReflectionMemberType);
//    }
//    public IXmlMappingTypeWrapperObject Object => _wrapperObject;
//    public string MemberName
//    {
//        get { return (string) _wrapperObject.GetProperty("MemberName"); }
//        set { _wrapperObject.SetProperty("MemberName", value); }
//    }
//    public Type MemberType
//    {
//        get { return (Type) _wrapperObject.GetProperty("MemberType"); }
//        set { _wrapperObject.SetProperty("MemberType", value); }
//    }
//    public XmlAttributes XmlAttributes
//    {
//        get { return (XmlAttributes) _wrapperObject.GetProperty("XmlAttributes"); }
//        set { _wrapperObject.SetProperty("XmlAttributes", value); }
//    }
//}
//internal class XmlMappingTypeWrapperFactory
//{
//    private static IXmlMappingTypeWrapperFactory s_instance;
//    private static IXmlMappingTypeWrapperFactory Instance
//    {
//        get
//        {
//            if (s_instance == null)
//            {
//                s_instance = new XmlMappingTypeReflectionWrapperFactory();
//            }
//            return s_instance;
//        }
//    }
//    public static IXmlMappingTypeWrapperObject GetWrapper(object innerObject)
//    {
//        return Instance.GetWrapper(innerObject);
//    }
//    public static IXmlMappingTypeWrapperObject GetWrapper(Type type)
//    {
//        return Instance.GetWrapper(type);
//    }
//    public static IXmlMappingTypeWrapperObject GetWrapper(Type type, object[] parameters)
//    {
//        return Instance.GetWrapper(type, parameters);
//    }
//}
//internal interface IXmlMappingTypeWrapperFactory
//{
//    IXmlMappingTypeWrapperObject GetWrapper(object innerObject);
//    IXmlMappingTypeWrapperObject GetWrapper(Type type);
//    IXmlMappingTypeWrapperObject GetWrapper(Type type, object[] parameters);
//}
//internal class XmlMappingTypeReflectionWrapperFactory : IXmlMappingTypeWrapperFactory
//{
//    public IXmlMappingTypeWrapperObject GetWrapper(object innerObject)
//    {
//        return new XmlMappingTypeReflectionWrapper(innerObject);
//    }
//    public IXmlMappingTypeWrapperObject GetWrapper(Type type)
//    {
//        return new XmlMappingTypeReflectionWrapper(type);
//    }
//    public IXmlMappingTypeWrapperObject GetWrapper(Type type, object[] parameters)
//    {
//        return new XmlMappingTypeReflectionWrapper(type, parameters);
//    }
//}
//internal interface IXmlMappingTypeWrapperObject
//{
//    object InnerObject { get; }
//    Type InnerObjectType { get; }
//    object GetProperty(string propertyName);
//    void SetProperty(string propertyName, object value);
//    object GetIndexerProperty(Type returnType, object parameter);
//    object CallMethod(MethodInfo method, object[] parameters);
//    MethodInfo GetMethod(string methodName, Type[] types);
//    Array InitializeArray(Type type, IXmlMappingTypeInnerObject[] objects);
//}
//internal class XmlMappingTypeReflectionWrapper : IXmlMappingTypeWrapperObject
//{
//    private object _innerObject;
//    private Type _innerObjectType;
//    public XmlMappingTypeReflectionWrapper(object innerObject)
//    {
//        _innerObject = innerObject;
//    }
//    public XmlMappingTypeReflectionWrapper(Type type)
//        : this(type, null)
//    {
//    }
//    public XmlMappingTypeReflectionWrapper(Type type, object[] parameters)
//    {
//        _innerObject = Activator.CreateInstance(type, parameters);
//    }
//    public object InnerObject => _innerObject;
//    public Type InnerObjectType
//    {
//        get
//        {
//            if (_innerObjectType == null)
//            {
//                _innerObjectType = _innerObject.GetType();
//            }
//            return _innerObjectType;
//        }
//    }
//    public object GetProperty(string propertyName)
//    {
//        PropertyInfo property = this.InnerObjectType.GetProperty(propertyName);
//        Contract.Assert(property != null, "Cannot find property: " + propertyName);
//        MethodInfo method = property.GetGetMethod(false);
//        Contract.Assert(method != null, "The property does not have Get method: " + propertyName);
//        return CallMethod(method, new object[0]);
//    }
//    public void SetProperty(string propertyName, object value)
//    {
//        PropertyInfo property = this.InnerObjectType.GetProperty(propertyName);
//        Contract.Assert(property != null, "Cannot find property: " + propertyName);
//        MethodInfo method = property.GetSetMethod(false);
//        Contract.Assert(method != null, "The property does not have Set method: " + propertyName);
//        CallMethod(method, new object[] {value});
//    }
//    public object GetIndexerProperty(Type returnType, object parameter)
//    {
//        MethodInfo method = this.InnerObjectType.GetProperty("Item", returnType).GetGetMethod(false);
//        Contract.Assert(method != null, "Cannot find the indexer property with return type: " + returnType);
//        return CallMethod(method, new object[] {parameter});
//    }
//    public MethodInfo GetMethod(string methodName, Type[] types)
//    {
//        MethodInfo method = this.InnerObjectType.GetMethod(methodName, types);
//        Contract.Assert(method != null, "Cannot find method: " + methodName);
//        return method;
//    }
//    public Array InitializeArray(Type type, IXmlMappingTypeInnerObject[] objects)
//    {
//        return XmlMappingTypesHelper.InitializeArray(type, objects);
//    }
//    public object CallMethod(MethodInfo method, object[] parameters)
//    {
//        Contract.Assert(method != null, "method");
//        object o = method.Invoke(this.InnerObject, parameters);
//        return o;
//    }
//}
//internal class XmlAttributesHelper
//{
//    internal static XmlAttributes CreateXmlAttributes(MemberInfo member)
//    {
//        return (XmlAttributes) Activator.CreateInstance(typeof (XmlAttributes), new object[] {member});
//    }
//}
//internal static class XmlMappingTypesHelper
//{
//    private static string s_xmlReflectionImporterTypeName =
//        XmlMappingTypesHelper.GetAssemblyQualifiedTypeName("System.Xml.Serialization.XmlReflectionImporter");
//    private static string s_xmlMappingTypeName =
//        XmlMappingTypesHelper.GetAssemblyQualifiedTypeName("System.Xml.Serialization.XmlMapping");
//    private static string s_xmlTypeMappingTypeName =
//        XmlMappingTypesHelper.GetAssemblyQualifiedTypeName("System.Xml.Serialization.XmlTypeMapping");
//    private static string s_xmlMembersMappingTypeName =
//        XmlMappingTypesHelper.GetAssemblyQualifiedTypeName("System.Xml.Serialization.XmlMembersMapping");
//    private static string s_xmlMemberMappingTypeName =
//        XmlMappingTypesHelper.GetAssemblyQualifiedTypeName("System.Xml.Serialization.XmlMemberMapping");
//    private static string s_xmlReflectionMemberTypeName =
//        XmlMappingTypesHelper.GetAssemblyQualifiedTypeName("System.Xml.Serialization.XmlReflectionMember");
//    private static string s_xmlSerializerAssemblyName;
//    public static Type XmlReflectionImporterType = Type.GetType(s_xmlReflectionImporterTypeName);
//    public static Type XmlMappingType = Type.GetType(s_xmlMappingTypeName);
//    public static Type XmlTypeMappingType = Type.GetType(s_xmlTypeMappingTypeName);
//    public static Type XmlMembersMappingType = Type.GetType(s_xmlMembersMappingTypeName);
//    public static Type XmlMemberMappingType = Type.GetType(s_xmlMemberMappingTypeName);
//    public static Type XmlReflectionMemberType = Type.GetType(s_xmlReflectionMemberTypeName);
//    public static Array InitializeArray(Type type, IXmlMappingTypeInnerObject[] objects)
//    {
//        Array array = Array.CreateInstance(type, objects.Length);
//        for (int i = 0; i < objects.Length; i++)
//        {
//            array.SetValue(objects[i].Object.InnerObject, i);
//        }
//        return array;
//    }
//    private static string XmlSerializerAssemblyName
//    {
//        get
//        {
//            if (s_xmlSerializerAssemblyName == null)
//            {
//                Type type = typeof (XmlSerializer);
//                string asmQualifiedName = type.AssemblyQualifiedName;
//                int index = asmQualifiedName.IndexOf(',') + 1;
//                s_xmlSerializerAssemblyName = asmQualifiedName.Substring(index);
//            }
//            return s_xmlSerializerAssemblyName;
//        }
//    }
//    private static string GetAssemblyQualifiedTypeName(string typeName)
//    {
//        return typeName + ", " + XmlSerializerAssemblyName;
//    }
//}
// This class is used to describe the message security requirements. It's only here as a placeholder
// to allow minimal changes to ported code.
// Currently always false
//contractScopeDefaultRequestProtectionLevel = contract.ProtectionLevel;
//contractScopeDefaultResponseProtectionLevel = contract.ProtectionLevel;
// Currently always false
//operationScopeDefaultRequestProtectionLevel = operation.ProtectionLevel;
//operationScopeDefaultResponseProtectionLevel = operation.ProtectionLevel;
//messageScopeDefaultProtectionLevel = message.ProtectionLevel;
// determine header protection requirements for message
// determine body protection requirements for message
// initialize the body protection level to none. all the body parts will be
// unioned to get the effective body protection level
// MessagePartDescription.HasProtectionLevel currently always false
//MessagePartDescription desc = message.Body.ReturnValue;
//bodyProtectionLevel = desc.HasProtectionLevel ? desc.ProtectionLevel : messageScopeDefaultProtectionLevel;
// determine body protection requirements for message
// MessagePartDescription.HasProtectionLevel currently always false
//ProtectionLevel partProtectionLevel = body.HasProtectionLevel ? body.ProtectionLevel : messageScopeDefaultProtectionLevel;
// add requirements for message 
//header.HasProtectionLevel currently is always false;
//ProtectionLevel p = header.HasProtectionLevel ? header.ProtectionLevel : defaultProtectionLevel;
// FaultDescription.HasProtectionLevel currently is always false
//ProtectionLevel p = fault.HasProtectionLevel ? fault.ProtectionLevel : defaultProtectionLevel;
// empty
//SecurityMessageProperty securityContextProperty = null;
//if (message.Properties != null)
//    securityContextProperty = message.Properties.Security;
//if (securityContextProperty == null || securityContextProperty.ServiceSecurityContext == null)
//    return false;
//return this.CheckAccess(identity, securityContextProperty.ServiceSecurityContext.AuthorizationContext);
// if we don't have an identity and we have differing Uris, we should use the Via
//SecurityTraceRecordHelper.TraceIdentityVerificationFailure(identity, authorizationContext, this.GetType());
// CheckAccess performs a Trace on failure, no need to do it twice
// if the incoming claim is a SID and the EndpointIdentity is UPN/SPN/DNS, try to find the SID corresponding to
// the UPN/SPN/DNS (transactions case)
// host/<machine-name> satisfies the DNS identity claim
//EventTraceActivity eventTraceActivity = null;
//if (FxTrace.Trace.IsEnd2EndActivityTracingEnabled)
//{
//    eventTraceActivity = EventTraceActivityHelper.TryExtractActivity((OperationContext.Current != null) ? OperationContext.Current.IncomingMessage : null);
//}
//SecurityTraceRecordHelper.TraceIdentityVerificationSuccess(eventTraceActivity, identity, identity.IdentityClaim, this.GetType());
// try Claim equivalence
//SecurityTraceRecordHelper.TraceIdentityVerificationSuccess(eventTraceActivity, identity, claim, this.GetType());
// Allow a Sid claim to support UPN, and SPN identities
//SecurityTraceRecordHelper.TraceIdentityVerificationSuccess(eventTraceActivity, identity, claim, this.GetType());
//if (TD.SecurityIdentityVerificationFailureIsEnabled())
//{
//    TD.SecurityIdentityVerificationFailure(eventTraceActivity);
//}
/// <summary>
/// The helper class to enable impersonation while serializing the body of the reply message.
/// </summary>
/// <summary>
/// Gets the name of the message property.
/// </summary>
/// <summary>
/// Gets the ImpersonateOnSerializingReplyMessageProperty property from a message.
/// </summary>
/// <param name="message">The message to extract the property from.</param>
/// <param name="property">An output paramter to hold the ImpersonateOnSerializingReplyMessageProperty property.</param>
/// <returns>True if the ImpersonateOnSerializingReplyMessageProperty property was found.</returns>
/// <summary>
/// Gets the ImpersonateOnSerializingReplyMessageProperty property from MessageProperties.
/// </summary>
/// <param name="properties">The MessagePropeties object.</param>
/// <param name="property">An output paramter to hold the ImpersonateOnSerializingReplyMessageProperty property.</param>
/// <returns>True if the ImpersonateOnSerializingReplyMessageProperty property was found.</returns>
/// <summary>
/// Creates a copy of the message property.
/// </summary>
/// <returns>Returns a copy of the message property.</returns>
/// <summary>
/// Executes a Func<typeparamref name="T"/> with the caller's context if impersonation is enabled on the service and sets the appropriate principal on the thread as per the service configuration.
/// </summary>
/// <param name="func">The function to execute under caller's impersonated context</param>
/// <returns>The return value from executing the func</returns>
//Runs impersonated.
//Runs impersonated.
//Runs impersonated.
// empty
// empty
// Name is an optional attribute. If not present, compare with only the namespace.
//internal string GetEncryptionKeyDerivationAlgorithm(SecurityToken token, SecureConversationVersion version)
//{
//    if (token == null)
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(token));
//    string derivationAlgorithm = SecurityUtils.GetKeyDerivationAlgorithm(version);
//    if (SecurityUtils.IsSupportedAlgorithm(derivationAlgorithm, token))
//        return derivationAlgorithm;
//    else
//        return null;
//}
//internal int GetEncryptionKeyDerivationLength(SecurityToken token, SecureConversationVersion version)
//{
//    if (token == null)
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(token));
//    string derivationAlgorithm = SecurityUtils.GetKeyDerivationAlgorithm(version);
//    if (SecurityUtils.IsSupportedAlgorithm(derivationAlgorithm, token))
//    {
//        if (this.DefaultEncryptionKeyDerivationLength % 8 != 0)
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.Psha1KeyLengthInvalid, this.DefaultEncryptionKeyDerivationLength)));
//        return this.DefaultEncryptionKeyDerivationLength / 8;
//    }
//    else
//        return 0;
//}
//internal void GetKeyWrapAlgorithm(SecurityToken token, out string keyWrapAlgorithm, out XmlDictionaryString keyWrapAlgorithmDictionaryString)
//{
//    if (token == null)
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(token));
//    if (SecurityUtils.IsSupportedAlgorithm(this.DefaultSymmetricKeyWrapAlgorithm, token))
//    {
//        keyWrapAlgorithm = this.DefaultSymmetricKeyWrapAlgorithm;
//        keyWrapAlgorithmDictionaryString = this.DefaultSymmetricKeyWrapAlgorithmDictionaryString;
//    }
//    else
//    {
//        keyWrapAlgorithm = this.DefaultAsymmetricKeyWrapAlgorithm;
//        keyWrapAlgorithmDictionaryString = this.DefaultAsymmetricKeyWrapAlgorithmDictionaryString;
//    }
//}
//internal void GetSignatureAlgorithmAndKey(SecurityToken token, out string signatureAlgorithm, out SecurityKey key, out XmlDictionaryString signatureAlgorithmDictionaryString)
//{
//    ReadOnlyCollection<SecurityKey> keys = token.SecurityKeys;
//    if (keys == null || keys.Count == 0)
//    {
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.SigningTokenHasNoKeys, token)));
//    }
//    for (int i = 0; i < keys.Count; i++)
//    {
//        if (keys[i].IsSupportedAlgorithm(this.DefaultSymmetricSignatureAlgorithm))
//        {
//            signatureAlgorithm = this.DefaultSymmetricSignatureAlgorithm;
//            signatureAlgorithmDictionaryString = this.DefaultSymmetricSignatureAlgorithmDictionaryString;
//            key = keys[i];
//            return;
//        }
//        else if (keys[i].IsSupportedAlgorithm(this.DefaultAsymmetricSignatureAlgorithm))
//        {
//            signatureAlgorithm = this.DefaultAsymmetricSignatureAlgorithm;
//            signatureAlgorithmDictionaryString = this.DefaultAsymmetricSignatureAlgorithmDictionaryString;
//            key = keys[i];
//            return;
//        }
//    }
//    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.SigningTokenHasNoKeysSupportingTheAlgorithmSuite, token, this)));
//}
//internal string GetSignatureKeyDerivationAlgorithm(SecurityToken token, SecureConversationVersion version)
//{
//    if (token == null)
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(token));
//    string derivationAlgorithm = SecurityUtils.GetKeyDerivationAlgorithm(version);
//    if (SecurityUtils.IsSupportedAlgorithm(derivationAlgorithm, token))
//        return derivationAlgorithm;
//    else
//        return null;
//}
//internal int GetSignatureKeyDerivationLength(SecurityToken token, SecureConversationVersion version)
//{
//    if (token == null)
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(token));
//    string derivationAlgorithm = SecurityUtils.GetKeyDerivationAlgorithm(version);
//    if (SecurityUtils.IsSupportedAlgorithm(derivationAlgorithm, token))
//    {
//        if (this.DefaultSignatureKeyDerivationLength % 8 != 0)
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.Psha1KeyLengthInvalid, this.DefaultSignatureKeyDerivationLength)));
//        return this.DefaultSignatureKeyDerivationLength / 8;
//    }
//    else
//        return 0;
//}
//internal void EnsureAcceptableSymmetricSignatureAlgorithm(string algorithm)
//{
//    if (!IsSymmetricSignatureAlgorithmSupported(algorithm))
//    {
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.SuiteDoesNotAcceptAlgorithm,
//            algorithm, "SymmetricSignature", this)));
//    }
//}
//internal void EnsureAcceptableSignatureKeySize(SecurityKey securityKey, SecurityToken token)
//{
//    AsymmetricSecurityKey asymmetricSecurityKey = securityKey as AsymmetricSecurityKey;
//    if (asymmetricSecurityKey != null)
//    {
//        if (!IsAsymmetricKeyLengthSupported(asymmetricSecurityKey.KeySize))
//        {
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(
//                SR.Format(SR.TokenDoesNotMeetKeySizeRequirements, this, token, asymmetricSecurityKey.KeySize)));
//        }
//    }
//    else
//    {
//        SymmetricSecurityKey symmetricSecurityKey = securityKey as SymmetricSecurityKey;
//        if (symmetricSecurityKey == null)
//        {
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.UnknownICryptoType, symmetricSecurityKey)));
//        }
//        EnsureAcceptableSignatureSymmetricKeySize(symmetricSecurityKey, token);
//    }
//}
//// Ensure acceptable signing symmetric key.
//// 1) if derived key, validate derived key against DefaultSignatureKeyDerivationLength and validate
////    source key against DefaultSymmetricKeyLength
//// 2) if not derived key, validate key against DefaultSymmetricKeyLength
//internal void EnsureAcceptableSignatureSymmetricKeySize(SymmetricSecurityKey securityKey, SecurityToken token)
//{
//    int keySize;
//    DerivedKeySecurityToken dkt = token as DerivedKeySecurityToken;
//    if (dkt != null)
//    {
//        token = dkt.TokenToDerive;
//        keySize = ((SymmetricSecurityKey)token.SecurityKeys[0]).KeySize;
//        // doing special case for derived key token signing length since
//        // the sending side doesn't honor the algorithm suite. It used the DefaultSignatureKeyDerivationLength instead
//        if (dkt.SecurityKeys[0].KeySize < this.DefaultSignatureKeyDerivationLength)
//        {
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(
//                SR.Format(SR.TokenDoesNotMeetKeySizeRequirements, this, dkt, dkt.SecurityKeys[0].KeySize)));
//        }
//    }
//    else
//    {
//        keySize = securityKey.KeySize;
//    }
//    if (!IsSymmetricKeyLengthSupported(keySize))
//    {
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(
//            SR.Format(SR.TokenDoesNotMeetKeySizeRequirements, this, token, keySize)));
//    }
//}
//// Ensure acceptable decrypting symmetric key.
//// 1) if derived key, validate derived key against DefaultEncryptionKeyDerivationLength and validate
////    source key against DefaultSymmetricKeyLength
//// 2) if not derived key, validate key against DefaultSymmetricKeyLength
//internal void EnsureAcceptableDecryptionSymmetricKeySize(SymmetricSecurityKey securityKey, SecurityToken token)
//{
//    int keySize;
//    DerivedKeySecurityToken dkt = token as DerivedKeySecurityToken;
//    if (dkt != null)
//    {
//        token = dkt.TokenToDerive;
//        keySize = ((SymmetricSecurityKey)token.SecurityKeys[0]).KeySize;
//        // doing special case for derived key token signing length since
//        // the sending side doesn't honor the algorithm suite. It used the DefaultSignatureKeyDerivationLength instead
//        if (dkt.SecurityKeys[0].KeySize < this.DefaultEncryptionKeyDerivationLength)
//        {
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(
//                SR.Format(SR.TokenDoesNotMeetKeySizeRequirements, this, dkt, dkt.SecurityKeys[0].KeySize)));
//        }
//    }
//    else
//    {
//        keySize = securityKey.KeySize;
//    }
//    if (!IsSymmetricKeyLengthSupported(keySize))
//    {
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(
//            SR.Format(SR.TokenDoesNotMeetKeySizeRequirements, this, token, keySize)));
//    }
//}
//internal void EnsureAcceptableSignatureAlgorithm(SecurityKey verificationKey, string algorithm)
//{
//    InMemorySymmetricSecurityKey symmeticKey = verificationKey as InMemorySymmetricSecurityKey;
//    if (symmeticKey != null)
//    {
//        this.EnsureAcceptableSymmetricSignatureAlgorithm(algorithm);
//    }
//    else
//    {
//        AsymmetricSecurityKey asymmetricKey = verificationKey as AsymmetricSecurityKey;
//        if (asymmetricKey == null)
//        {
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.UnknownICryptoType, verificationKey)));
//        }
//        this.EnsureAcceptableAsymmetricSignatureAlgorithm(algorithm);
//    }
//}
//internal void EnsureAcceptableAsymmetricSignatureAlgorithm(string algorithm)
//{
//    if (!IsAsymmetricSignatureAlgorithmSupported(algorithm))
//    {
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.SuiteDoesNotAcceptAlgorithm,
//            algorithm, "AsymmetricSignature", this)));
//    }
//}
//internal void EnsureAcceptableKeyWrapAlgorithm(string algorithm, bool isAsymmetric)
//{
//    if (isAsymmetric)
//    {
//        if (!IsAsymmetricKeyWrapAlgorithmSupported(algorithm))
//        {
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.SuiteDoesNotAcceptAlgorithm,
//                algorithm, "AsymmetricKeyWrap", this)));
//        }
//    }
//    else
//    {
//        if (!IsSymmetricKeyWrapAlgorithmSupported(algorithm))
//        {
//            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.SuiteDoesNotAcceptAlgorithm,
//                algorithm, "SymmetricKeyWrap", this)));
//        }
//    }
//}
//internal void EnsureAcceptableEncryptionAlgorithm(string algorithm)
//{
//    if (!IsEncryptionAlgorithmSupported(algorithm))
//    {
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.SuiteDoesNotAcceptAlgorithm,
//            algorithm, "Encryption", this)));
//    }
//}
//internal void EnsureAcceptableSignatureKeyDerivationAlgorithm(string algorithm)
//{
//    if (!IsSignatureKeyDerivationAlgorithmSupported(algorithm))
//    {
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.SuiteDoesNotAcceptAlgorithm,
//            algorithm, "SignatureKeyDerivation", this)));
//    }
//}
//internal void EnsureAcceptableEncryptionKeyDerivationAlgorithm(string algorithm)
//{
//    if (!IsEncryptionKeyDerivationAlgorithmSupported(algorithm))
//    {
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.SuiteDoesNotAcceptAlgorithm,
//            algorithm, "EncryptionKeyDerivation", this)));
//    }
//}
//internal void EnsureAcceptableDigestAlgorithm(string algorithm)
//{
//    if (!IsDigestAlgorithmSupported(algorithm))
//    {
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new MessageSecurityException(SR.Format(SR.SuiteDoesNotAcceptAlgorithm,
//            algorithm, "Digest", this)));
//    }
//}
// TODO: Resolve solution to SecurityTokenManager which lives in System.IdentityModel.Selectors not existing on .Net standard
//// This is the list of outgoing supporting tokens
//Collection<SupportingTokenSpecification> outgoingSupportingTokens;
//Collection<SupportingTokenSpecification> incomingSupportingTokens;
//SecurityTokenSpecification protectionToken;
//SecurityTokenSpecification initiatorToken;
//SecurityTokenSpecification recipientToken;
//string senderIdPrefix = "_";
//public SecurityTokenSpecification ProtectionToken
//{
//    get
//    {
//        ThrowIfDisposed();
//        return this.protectionToken;
//    }
//    set
//    {
//        ThrowIfDisposed();
//        this.protectionToken = value;
//    }
//}
//public SecurityTokenSpecification InitiatorToken
//{
//    get
//    {
//        ThrowIfDisposed();
//        return this.initiatorToken;
//    }
//    set
//    {
//        ThrowIfDisposed();
//        this.initiatorToken = value;
//    }
//}
//public SecurityTokenSpecification RecipientToken
//{
//    get
//    {
//        ThrowIfDisposed();
//        return this.recipientToken;
//    }
//    set
//    {
//        ThrowIfDisposed();
//        this.recipientToken = value;
//    }
//}
//public string SenderIdPrefix
//{
//    get
//    {
//        return this.senderIdPrefix;
//    }
//    set
//    {
//        XmlHelper.ValidateIdPrefix(value);
//        this.senderIdPrefix = value;
//    }
//}
//public bool HasIncomingSupportingTokens
//{
//    get
//    {
//        ThrowIfDisposed();
//        return ((this.incomingSupportingTokens != null) && (this.incomingSupportingTokens.Count > 0));
//    }
//}
//public Collection<SupportingTokenSpecification> IncomingSupportingTokens
//{
//    get
//    {
//        ThrowIfDisposed();
//        if (this.incomingSupportingTokens == null)
//        {
//            this.incomingSupportingTokens = new Collection<SupportingTokenSpecification>();
//        }
//        return this.incomingSupportingTokens;
//    }
//}
//public Collection<SupportingTokenSpecification> OutgoingSupportingTokens
//{
//    get
//    {
//        if (this.outgoingSupportingTokens == null)
//        {
//            this.outgoingSupportingTokens = new Collection<SupportingTokenSpecification>();
//        }
//        return this.outgoingSupportingTokens;
//    }
//}
//internal bool HasOutgoingSupportingTokens
//{
//    get
//    {
//        return ((this.outgoingSupportingTokens != null) && (this.outgoingSupportingTokens.Count > 0));
//    }
//}
//    if (this.HasOutgoingSupportingTokens)
//    {
//        for (int i = 0; i < this.outgoingSupportingTokens.Count; ++i)
//        {
//            result.OutgoingSupportingTokens.Add(this.outgoingSupportingTokens[i]);
//        }
//    }
//    if (this.HasIncomingSupportingTokens)
//    {
//        for (int i = 0; i < this.incomingSupportingTokens.Count; ++i)
//        {
//            result.IncomingSupportingTokens.Add(this.incomingSupportingTokens[i]);
//        }
//    }
//    result.externalAuthorizationPolicies = this.externalAuthorizationPolicies;
//    result.senderIdPrefix = this.senderIdPrefix;
//    result.protectionToken = this.protectionToken;
//    result.initiatorToken = this.initiatorToken;
//    result.recipientToken = this.recipientToken;
//void AddAuthorizationPolicies(SecurityTokenSpecification spec, Collection<IAuthorizationPolicy> policies)
//{
//    if (spec != null && spec.SecurityTokenPolicies != null && spec.SecurityTokenPolicies.Count > 0)
//    {
//        for (int i = 0; i < spec.SecurityTokenPolicies.Count; ++i)
//        {
//            policies.Add(spec.SecurityTokenPolicies[i]);
//        }
//    }
//}
//internal ReadOnlyCollection<IAuthorizationPolicy> GetInitiatorTokenAuthorizationPolicies()
//{
//    return GetInitiatorTokenAuthorizationPolicies(true);
//}
//internal ReadOnlyCollection<IAuthorizationPolicy> GetInitiatorTokenAuthorizationPolicies(bool includeTransportToken)
//{
//    return GetInitiatorTokenAuthorizationPolicies(includeTransportToken, null);
//}
//internal ReadOnlyCollection<IAuthorizationPolicy> GetInitiatorTokenAuthorizationPolicies(bool includeTransportToken, SecurityContextSecurityToken supportingSessionTokenToExclude)
//{
//    // fast path
//    if (!this.HasIncomingSupportingTokens)
//    {
//        if (this.transportToken != null && this.initiatorToken == null && this.protectionToken == null)
//        {
//            if (includeTransportToken && this.transportToken.SecurityTokenPolicies != null)
//            {
//                return this.transportToken.SecurityTokenPolicies;
//            }
//            else
//            {
//                return EmptyReadOnlyCollection<IAuthorizationPolicy>.Instance;
//            }
//        }
//        else if (this.transportToken == null && this.initiatorToken != null && this.protectionToken == null)
//        {
//            return this.initiatorToken.SecurityTokenPolicies ?? EmptyReadOnlyCollection<IAuthorizationPolicy>.Instance;
//        }
//        else if (this.transportToken == null && this.initiatorToken == null && this.protectionToken != null)
//        {
//            return this.protectionToken.SecurityTokenPolicies ?? EmptyReadOnlyCollection<IAuthorizationPolicy>.Instance;
//        }
//    }
//    Collection<IAuthorizationPolicy> policies = new Collection<IAuthorizationPolicy>();
//    if (includeTransportToken)
//    {
//        AddAuthorizationPolicies(this.transportToken, policies);
//    }
//    AddAuthorizationPolicies(this.initiatorToken, policies);
//    AddAuthorizationPolicies(this.protectionToken, policies);
//    if (this.HasIncomingSupportingTokens)
//    {
//        for (int i = 0; i < this.incomingSupportingTokens.Count; ++i)
//        {
//            if (supportingSessionTokenToExclude != null)
//            {
//                SecurityContextSecurityToken sct = this.incomingSupportingTokens[i].SecurityToken as SecurityContextSecurityToken;
//                if (sct != null && sct.ContextId == supportingSessionTokenToExclude.ContextId)
//                {
//                    continue;
//                }
//            }
//            SecurityTokenAttachmentMode attachmentMode = this.incomingSupportingTokens[i].SecurityTokenAttachmentMode;
//            // a safety net in case more attachment modes get added to the product without 
//            // reviewing this code.
//            if (attachmentMode == SecurityTokenAttachmentMode.Endorsing
//                || attachmentMode == SecurityTokenAttachmentMode.Signed
//                || attachmentMode == SecurityTokenAttachmentMode.SignedEncrypted
//                || attachmentMode == SecurityTokenAttachmentMode.SignedEndorsing)
//            {
//                AddAuthorizationPolicies(this.incomingSupportingTokens[i], policies);
//            }
//        }
//    }
//    return new ReadOnlyCollection<IAuthorizationPolicy>(policies);
//}
// do no-op for future V2
// S-1-5-82 is the prefix for the sid that represents the identity that IIS 7.5 Apppool thread runs under.
// Save windowsIdentity for delay lookup
// exceptions can be due to ACLs on the key etc
// No KeyUsage extension means most usages are permitted including key exchange.
// See RFC 5280 section 4.2.1.3 (Key Usage) for details. If the extension is non-critical
// then it's non-enforcing and meant as an aid in choosing the best certificate when
// there are multiple certificates to choose from. 
// One of KeyAgreement, KeyEncipherment or DigitalSignature need to be allowed depending on the cipher
// being used. See RFC 5246 section 7.4.6 for more details.
// Additionally, according to msdn docs for PFXImportCertStore, the key specification is set to AT_KEYEXCHANGE
// when the data encipherment usage is set.
// This is the workaround, Since store.Certificates returns a full collection
// of certs in store.  These are holding native resources.
// do the splitting only if there is exactly 1 \ or exactly 1 @
//protected SecurityTokenAuthenticator CreateSecureConversationTokenAuthenticator(RecipientServiceModelSecurityTokenRequirement recipientRequirement, bool preserveBootstrapTokens, out SecurityTokenResolver sctResolver)
//{
//    SecurityBindingElement securityBindingElement = recipientRequirement.SecurityBindingElement;
//    if (securityBindingElement == null)
//    {
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument(SR.Format(SR.TokenAuthenticatorRequiresSecurityBindingElement, recipientRequirement));
//    }
//    bool isCookieMode = !recipientRequirement.SupportSecurityContextCancellation;
//    LocalServiceSecuritySettings localServiceSettings = securityBindingElement.LocalServiceSettings;
//    IMessageFilterTable<EndpointAddress> endpointFilterTable = recipientRequirement.GetPropertyOrDefault<IMessageFilterTable<EndpointAddress>>(ServiceModelSecurityTokenRequirement.EndpointFilterTableProperty, null);
//    if (!isCookieMode)
//    {
//        sctResolver = new SecurityContextSecurityTokenResolver(Int32.MaxValue, false);
//        // remember this authenticator for future reference
//        SecuritySessionSecurityTokenAuthenticator authenticator = new SecuritySessionSecurityTokenAuthenticator();
//        authenticator.BootstrapSecurityBindingElement = SecurityUtils.GetIssuerSecurityBindingElement(recipientRequirement);
//        authenticator.IssuedSecurityTokenParameters = recipientRequirement.GetProperty<SecurityTokenParameters>(ServiceModelSecurityTokenRequirement.IssuedSecurityTokenParametersProperty);
//        authenticator.IssuedTokenCache = (ISecurityContextSecurityTokenCache)sctResolver;
//        authenticator.IssuerBindingContext = recipientRequirement.GetProperty<BindingContext>(ServiceModelSecurityTokenRequirement.IssuerBindingContextProperty);
//        authenticator.KeyEntropyMode = securityBindingElement.KeyEntropyMode;
//        authenticator.ListenUri = recipientRequirement.ListenUri;
//        authenticator.SecurityAlgorithmSuite = recipientRequirement.SecurityAlgorithmSuite;
//        authenticator.SessionTokenLifetime = TimeSpan.MaxValue;
//        authenticator.KeyRenewalInterval = securityBindingElement.LocalServiceSettings.SessionKeyRenewalInterval;
//        authenticator.StandardsManager = SecurityUtils.CreateSecurityStandardsManager(recipientRequirement, this);
//        authenticator.EndpointFilterTable = endpointFilterTable;
//        authenticator.MaximumConcurrentNegotiations = localServiceSettings.MaxStatefulNegotiations;
//        authenticator.NegotiationTimeout = localServiceSettings.NegotiationTimeout;
//        authenticator.PreserveBootstrapTokens = preserveBootstrapTokens;
//        return authenticator;
//    }
//    else
//    {
//        sctResolver = new SecurityContextSecurityTokenResolver(localServiceSettings.MaxCachedCookies, true, localServiceSettings.MaxClockSkew);
//        AcceleratedTokenAuthenticator authenticator = new AcceleratedTokenAuthenticator();
//        authenticator.BootstrapSecurityBindingElement = SecurityUtils.GetIssuerSecurityBindingElement(recipientRequirement);
//        authenticator.KeyEntropyMode = securityBindingElement.KeyEntropyMode;
//        authenticator.EncryptStateInServiceToken = true;
//        authenticator.IssuedSecurityTokenParameters = recipientRequirement.GetProperty<SecurityTokenParameters>(ServiceModelSecurityTokenRequirement.IssuedSecurityTokenParametersProperty);
//        authenticator.IssuedTokenCache = (ISecurityContextSecurityTokenCache)sctResolver;
//        authenticator.IssuerBindingContext = recipientRequirement.GetProperty<BindingContext>(ServiceModelSecurityTokenRequirement.IssuerBindingContextProperty);
//        authenticator.ListenUri = recipientRequirement.ListenUri;
//        authenticator.SecurityAlgorithmSuite = recipientRequirement.SecurityAlgorithmSuite;
//        authenticator.StandardsManager = SecurityUtils.CreateSecurityStandardsManager(recipientRequirement, this);
//        authenticator.SecurityStateEncoder = parent.SecureConversationAuthentication.SecurityStateEncoder;
//        authenticator.KnownTypes = parent.SecureConversationAuthentication.SecurityContextClaimTypes;
//        authenticator.PreserveBootstrapTokens = preserveBootstrapTokens;
//        // local security quotas
//        authenticator.MaximumCachedNegotiationState = localServiceSettings.MaxStatefulNegotiations;
//        authenticator.NegotiationTimeout = localServiceSettings.NegotiationTimeout;
//        authenticator.ServiceTokenLifetime = localServiceSettings.IssuedCookieLifetime;
//        authenticator.MaximumConcurrentNegotiations = localServiceSettings.MaxStatefulNegotiations;
//        // audit settings
//        authenticator.AuditLogLocation = recipientRequirement.AuditLogLocation;
//        authenticator.SuppressAuditFailure = recipientRequirement.SuppressAuditFailure;
//        authenticator.MessageAuthenticationAuditLevel = recipientRequirement.MessageAuthenticationAuditLevel;
//        authenticator.EndpointFilterTable = endpointFilterTable;
//        return authenticator;
//    }
//}
//SecurityBindingElement securityBindingElement = recipientRequirement.SecurityBindingElement;
//if (securityBindingElement == null)
//{
//    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument(SR.Format(SR.TokenAuthenticatorRequiresSecurityBindingElement, recipientRequirement));
//}
//bool isCookieMode = !recipientRequirement.SupportSecurityContextCancellation;
//LocalServiceSecuritySettings localServiceSettings = securityBindingElement.LocalServiceSettings;
//sctResolver = new SecurityContextSecurityTokenResolver(localServiceSettings.MaxCachedCookies, true);
//ExtendedProtectionPolicy extendedProtectionPolicy = null;
//recipientRequirement.TryGetProperty<ExtendedProtectionPolicy>(ServiceModelSecurityTokenRequirement.ExtendedProtectionPolicy, out extendedProtectionPolicy);
//SpnegoTokenAuthenticator authenticator = new SpnegoTokenAuthenticator();
//authenticator.ExtendedProtectionPolicy = extendedProtectionPolicy;
//authenticator.AllowUnauthenticatedCallers = parent.WindowsAuthentication.AllowAnonymousLogons;
//authenticator.ExtractGroupsForWindowsAccounts = parent.WindowsAuthentication.IncludeWindowsGroups;
//authenticator.IsClientAnonymous = false;
//authenticator.EncryptStateInServiceToken = isCookieMode;
//authenticator.IssuedSecurityTokenParameters = recipientRequirement.GetProperty<SecurityTokenParameters>(ServiceModelSecurityTokenRequirement.IssuedSecurityTokenParametersProperty);
//authenticator.IssuedTokenCache = (ISecurityContextSecurityTokenCache)sctResolver;
//authenticator.IssuerBindingContext = recipientRequirement.GetProperty<BindingContext>(ServiceModelSecurityTokenRequirement.IssuerBindingContextProperty);
//authenticator.ListenUri = recipientRequirement.ListenUri;
//authenticator.SecurityAlgorithmSuite = recipientRequirement.SecurityAlgorithmSuite;
//authenticator.StandardsManager = SecurityUtils.CreateSecurityStandardsManager(recipientRequirement, this);
//authenticator.SecurityStateEncoder = parent.SecureConversationAuthentication.SecurityStateEncoder;
//authenticator.KnownTypes = parent.SecureConversationAuthentication.SecurityContextClaimTypes;
//// if the SPNEGO is being done in mixed-mode, the nego blobs are from an anonymous client and so there size bound needs to be enforced.
//if (securityBindingElement is TransportSecurityBindingElement)
//{
//    authenticator.MaxMessageSize = SecurityUtils.GetMaxNegotiationBufferSize(authenticator.IssuerBindingContext);
//}
//// local security quotas
//authenticator.MaximumCachedNegotiationState = localServiceSettings.MaxStatefulNegotiations;
//authenticator.NegotiationTimeout = localServiceSettings.NegotiationTimeout;
//authenticator.ServiceTokenLifetime = localServiceSettings.IssuedCookieLifetime;
//authenticator.MaximumConcurrentNegotiations = localServiceSettings.MaxStatefulNegotiations;
//// audit settings
//authenticator.AuditLogLocation = recipientRequirement.AuditLogLocation;
//authenticator.SuppressAuditFailure = recipientRequirement.SuppressAuditFailure;
//authenticator.MessageAuthenticationAuditLevel = recipientRequirement.MessageAuthenticationAuditLevel;
//return authenticator;
//RecipientServiceModelSecurityTokenRequirement clientX509Requirement = new RecipientServiceModelSecurityTokenRequirement();
//clientX509Requirement.TokenType = SecurityTokenTypes.X509Certificate;
//clientX509Requirement.KeyUsage = SecurityKeyUsage.Signature;
//clientX509Requirement.ListenUri = recipientRequirement.ListenUri;
//clientX509Requirement.KeyType = SecurityKeyType.AsymmetricKey;
//clientX509Requirement.SecurityBindingElement = recipientRequirement.SecurityBindingElement;
//SecurityTokenResolver dummy;
//return this.CreateSecurityTokenAuthenticator(clientX509Requirement, out dummy);
//RecipientServiceModelSecurityTokenRequirement serverX509Requirement = new RecipientServiceModelSecurityTokenRequirement();
//serverX509Requirement.TokenType = SecurityTokenTypes.X509Certificate;
//serverX509Requirement.KeyUsage = SecurityKeyUsage.Exchange;
//serverX509Requirement.ListenUri = recipientRequirement.ListenUri;
//serverX509Requirement.KeyType = SecurityKeyType.AsymmetricKey;
//serverX509Requirement.SecurityBindingElement = recipientRequirement.SecurityBindingElement;
//return this.CreateSecurityTokenProvider(serverX509Requirement);
//SecurityBindingElement securityBindingElement = recipientRequirement.SecurityBindingElement;
//if (securityBindingElement == null)
//{
//    throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgument(SR.Format(SR.TokenAuthenticatorRequiresSecurityBindingElement, recipientRequirement));
//}
//bool isCookieMode = !recipientRequirement.SupportSecurityContextCancellation;
//LocalServiceSecuritySettings localServiceSettings = securityBindingElement.LocalServiceSettings;
//sctResolver = new SecurityContextSecurityTokenResolver(localServiceSettings.MaxCachedCookies, true);
//TlsnegoTokenAuthenticator authenticator = new TlsnegoTokenAuthenticator();
//authenticator.IsClientAnonymous = !requireClientCertificate;
//if (requireClientCertificate)
//{
//    authenticator.ClientTokenAuthenticator = this.CreateTlsnegoClientX509TokenAuthenticator(recipientRequirement);
//    authenticator.MapCertificateToWindowsAccount = this.ServiceCredentials.ClientCertificate.Authentication.MapClientCertificateToWindowsAccount;
//}
//authenticator.EncryptStateInServiceToken = isCookieMode;
//authenticator.IssuedSecurityTokenParameters = recipientRequirement.GetProperty<SecurityTokenParameters>(ServiceModelSecurityTokenRequirement.IssuedSecurityTokenParametersProperty);
//authenticator.IssuedTokenCache = (ISecurityContextSecurityTokenCache)sctResolver;
//authenticator.IssuerBindingContext = recipientRequirement.GetProperty<BindingContext>(ServiceModelSecurityTokenRequirement.IssuerBindingContextProperty);
//authenticator.ListenUri = recipientRequirement.ListenUri;
//authenticator.SecurityAlgorithmSuite = recipientRequirement.SecurityAlgorithmSuite;
//authenticator.StandardsManager = SecurityUtils.CreateSecurityStandardsManager(recipientRequirement, this);
//authenticator.SecurityStateEncoder = parent.SecureConversationAuthentication.SecurityStateEncoder;
//authenticator.KnownTypes = parent.SecureConversationAuthentication.SecurityContextClaimTypes;
//authenticator.ServerTokenProvider = CreateTlsnegoServerX509TokenProvider(recipientRequirement);
//// local security quotas
//authenticator.MaximumCachedNegotiationState = localServiceSettings.MaxStatefulNegotiations;
//authenticator.NegotiationTimeout = localServiceSettings.NegotiationTimeout;
//authenticator.ServiceTokenLifetime = localServiceSettings.IssuedCookieLifetime;
//authenticator.MaximumConcurrentNegotiations = localServiceSettings.MaxStatefulNegotiations;
//// if the TLSNEGO is being done in mixed-mode, the nego blobs are from an anonymous client and so there size bound needs to be enforced.
//if (securityBindingElement is TransportSecurityBindingElement)
//{
//    authenticator.MaxMessageSize = SecurityUtils.GetMaxNegotiationBufferSize(authenticator.IssuerBindingContext);
//}
//// audit settings
//authenticator.AuditLogLocation = recipientRequirement.AuditLogLocation;
//authenticator.SuppressAuditFailure = recipientRequirement.SuppressAuditFailure;
//authenticator.MessageAuthenticationAuditLevel = recipientRequirement.MessageAuthenticationAuditLevel;
//return authenticator;
//SamlSecurityTokenAuthenticator CreateSamlTokenAuthenticator(RecipientServiceModelSecurityTokenRequirement recipientRequirement, out SecurityTokenResolver outOfBandTokenResolver)
//{
//    if (recipientRequirement == null)
//        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof(recipientRequirement));
//    Collection<SecurityToken> outOfBandTokens = new Collection<SecurityToken>();
//    if (parent.ServiceCertificate.Certificate != null)
//    {
//        outOfBandTokens.Add(new X509SecurityToken(parent.ServiceCertificate.Certificate));
//    }
//    List<SecurityTokenAuthenticator> supportingAuthenticators = new List<SecurityTokenAuthenticator>();
//    if ((parent.IssuedTokenAuthentication.KnownCertificates != null) && (parent.IssuedTokenAuthentication.KnownCertificates.Count > 0))
//    {
//        for (int i = 0; i < parent.IssuedTokenAuthentication.KnownCertificates.Count; ++i)
//        {
//            outOfBandTokens.Add(new X509SecurityToken(parent.IssuedTokenAuthentication.KnownCertificates[i]));
//        }
//    }
//    X509CertificateValidator validator = parent.IssuedTokenAuthentication.GetCertificateValidator();
//    supportingAuthenticators.Add(new X509SecurityTokenAuthenticator(validator));
//    if (parent.IssuedTokenAuthentication.AllowUntrustedRsaIssuers)
//    {
//        supportingAuthenticators.Add(new RsaSecurityTokenAuthenticator());
//    }
//    outOfBandTokenResolver = (outOfBandTokens.Count > 0) ? SecurityTokenResolver.CreateDefaultSecurityTokenResolver(new ReadOnlyCollection<SecurityToken>(outOfBandTokens), false) : null;
//    SamlSecurityTokenAuthenticator ssta;
//    if ((recipientRequirement.SecurityBindingElement == null) || (recipientRequirement.SecurityBindingElement.LocalServiceSettings == null))
//    {
//        ssta = new SamlSecurityTokenAuthenticator(supportingAuthenticators);
//    }
//    else
//    {
//        ssta = new SamlSecurityTokenAuthenticator(supportingAuthenticators, recipientRequirement.SecurityBindingElement.LocalServiceSettings.MaxClockSkew);
//    }
//    // set audience uri restrictions
//    ssta.AudienceUriMode = parent.IssuedTokenAuthentication.AudienceUriMode;
//    IList<string> allowedAudienceUris = ssta.AllowedAudienceUris;
//    if (parent.IssuedTokenAuthentication.AllowedAudienceUris != null)
//    {
//        for (int i = 0; i < parent.IssuedTokenAuthentication.AllowedAudienceUris.Count; i++)
//            allowedAudienceUris.Add(parent.IssuedTokenAuthentication.AllowedAudienceUris[i]);
//    }
//    if (recipientRequirement.ListenUri != null)
//    {
//        allowedAudienceUris.Add(recipientRequirement.ListenUri.AbsoluteUri);
//    }
//    return ssta;
//}
// this is the uncorrelated duplex case in which the server is asking for
// an authenticator to validate its provisioned client certificate
//result = new KerberosSecurityTokenAuthenticatorWrapper(
//    new KerberosSecurityTokenAuthenticator(parent.WindowsAuthentication.IncludeWindowsGroups));
//if (parent.UserNameAuthentication.CacheLogonTokens)
//{
//    result = new WindowsUserNameCachingSecurityTokenAuthenticator(parent.UserNameAuthentication.IncludeWindowsGroups,
//        parent.UserNameAuthentication.MaxCachedLogonTokens, parent.UserNameAuthentication.CachedLogonTokenLifetime);
//}
//else
//{
//    result = new WindowsUserNameSecurityTokenAuthenticator(parent.UserNameAuthentication.IncludeWindowsGroups);
//}
//result = CreateSecureConversationTokenAuthenticator(recipientRequirement, false, out outOfBandTokenResolver);
//result = CreateSamlTokenAuthenticator(recipientRequirement, out outOfBandTokenResolver);
// if Transport Security, AuthenticationSchemes.Basic will look at parent.UserNameAuthentication settings.
// create security token provider even when basic and Anonymous are enabled.
// Ensure there are no inconsistencies when Basic and (Digest and/or Ntlm and/or Negotiate) are both enabled
// this is a request for the server's own cert for signing
// TODO: Add WindowsIdentity support here as it looks like it is doable
//return SecurityUtils.CreateWindowsIdentity();
//SecurityBindingElement securityBindingElement = ((RecipientServiceModelSecurityTokenRequirement)tokenRequirement).SecureConversationSecurityBindingElement;
//if (securityBindingElement != null)
//{
//    if (securityBindingElement == null || securityBindingElement is TransportSecurityBindingElement)
//    {
//        return null;
//    }
//    SecurityTokenParameters bootstrapProtectionParameters = (securityBindingElement is SymmetricSecurityBindingElement) ? ((SymmetricSecurityBindingElement)securityBindingElement).ProtectionTokenParameters : ((AsymmetricSecurityBindingElement)securityBindingElement).RecipientTokenParameters;
//    SecurityTokenRequirement bootstrapRequirement = new RecipientServiceModelSecurityTokenRequirement();
//    bootstrapProtectionParameters.InitializeSecurityTokenRequirement(bootstrapRequirement);
//    return GetIdentityOfSelf(bootstrapRequirement);
//}
// client side ctor
// service side ctor
// empty
// empty
/// <summary>
/// An enumeration that lists the ways of validating a certificate.
/// </summary>
/// <summary>
/// No validation of the certificate is performed. 
/// </summary>
/// <summary>
/// The certificate is valid if it is in the trusted people store.
/// </summary>
/// <summary>
/// The certificate is valid if the chain builds to a certification authority in the trusted root store.
/// </summary>
/// <summary>
/// The certificate is valid if it is in the trusted people store, or if the chain builds to a certification authority in the trusted root store.
/// </summary>
/// <summary>
/// The user must plug in a custom <c>X509CertificateValidator</c> to validate the certificate.
/// </summary>
//WebHeaderCollection webHeaderCollection;
//internal WebHeaderCollection WebHeaders
//{
//    get
//    {
//        return this.webHeaderCollection;
//    }
//    set
//    {
//        this.webHeaderCollection = value;
//    }
//}
//public AuditLogLocation AuditLogLocation
//{
//    get
//    {
//        return GetPropertyOrDefault<AuditLogLocation>(AuditLogLocationProperty, ServiceSecurityAuditBehavior.defaultAuditLogLocation);
//    }
//    set
//    {
//        this.Properties[AuditLogLocationProperty] = value;
//    }
//}
//public bool SuppressAuditFailure
//{
//    get
//    {
//        return GetPropertyOrDefault<bool>(SuppressAuditFailureProperty, ServiceSecurityAuditBehavior.defaultSuppressAuditFailure);
//    }
//    set
//    {
//        this.Properties[SuppressAuditFailureProperty] = value;
//    }
//}
//public AuditLevel MessageAuthenticationAuditLevel
//{
//    get
//    {
//        return GetPropertyOrDefault<AuditLevel>(MessageAuthenticationAuditLevelProperty, ServiceSecurityAuditBehavior.defaultMessageAuthenticationAuditLevel);
//    }
//    set
//    {
//        this.Properties[MessageAuthenticationAuditLevelProperty] = value;
//    }
//}
//schemas.microsoft.com/ws/2006/05/servicemodel/securitytokenrequirement";
// the following properties dont have top level OM properties but are part of the property bag
//public SecurityBindingElement SecurityBindingElement
//{
//    get
//    {
//        return GetPropertyOrDefault<SecurityBindingElement>(SecurityBindingElementProperty, null);
//    }
//    set
//    {
//        this.Properties[SecurityBindingElementProperty] = value;
//    }
//}
//public SecurityBindingElement SecureConversationSecurityBindingElement
//{
//    get
//    {
//        return GetPropertyOrDefault<SecurityBindingElement>(SecureConversationSecurityBindingElementProperty, null);
//    }
//    set
//    {
//        this.Properties[SecureConversationSecurityBindingElementProperty] = value;
//    }
//}
//public SecurityTokenVersion MessageSecurityVersion
//{
//    get
//    {
//        return GetPropertyOrDefault<SecurityTokenVersion>(MessageSecurityVersionProperty, null);
//    }
//    set
//    {
//        this.Properties[MessageSecurityVersionProperty] = value;
//    }
//}
//internal MessageSecurityVersion DefaultMessageSecurityVersion
//{
//    get
//    {
//        MessageSecurityVersion messageSecurityVersion;
//        return (this.TryGetProperty<MessageSecurityVersion>(DefaultMessageSecurityVersionProperty, out messageSecurityVersion)) ? messageSecurityVersion : null;
//    }
//    set
//    {
//        this.Properties[DefaultMessageSecurityVersionProperty] = (object)value;
//    }
//}
//schemas.microsoft.com/ws/2006/05/servicemodel/tokens";
// Element           => StartElement Attribute* Content EndElement
//                    | StartElement Attribute* Text // Text must be WithEndElement
//                    | Array StartElement Attribute* EndElement type MB32(Count) byte[Count * sizeof(type)]
// StartElement      => ShortElementNode Name(LocalName)
//                    | ElementNode Name(Prefix) Name(LocalName)
//                    | ShortDictionaryElementNode MB32(LocalName)
//                    | PrefixDictionaryElement[A-Z]Node MB32(LocalName)
//                    | DictionaryElementNode Name(Prefix) MB32(LocalName)
//                    | PrefixElement[A-Z]Node Name(LocalName)
// EndElement        => EndElementNode
// Content           => (Element | ArrayElement | Text | Comment)*
// Attribute         => ShortAttributeNode Name(LocalName) Text
//                    | AttributeNode Name(Prefix) Name(LocalName) Text
//                    | ShortDictionaryAttributeNode MB32(LocalName) Text
//                    | DictionaryAttributeNode Name(Prefix) MB32(LocalName) Text
//                    | ShortXmlnsAttributeNode Name(Namespace)
//                    | XmlnsAttributeNode Name(Prefix) Name(Namespace)
//                    | ShortDictionaryXmlnsAttributeNode MB32(Namespace)
//                    | DictionaryXmlnsAttributeNode Name(Prefix) MB32(Namespace)
//                    | PrefixAttribute[A-Z] Name(LocalName) Text
//                    | PrefixDictionaryAttribute[A-Z] MB32(LocalName) Text
// Text              => BinaryTextNode
//                    | CharsTextNode
//                    | EmptyTextNode
//                    | DictionaryTextNode MB32(Id)
//                    | ZeroTextNode
//                    | OneTextNode
//                    | TrueTextNode
//                    | FalseTextNode
//                    | Int8TextNode  Int8
//                    | Int16TextNode Int16
//                    | Int32TextNode Int32
//                    | Int64TextNode Int64
//                    | FloatTextNode Float
//                    | DoubleTextNode Double
//                    | DecimalTextNode Decimal
//                    | DateTimeTextNode DateTime
//                    | StartListNode Text* EndListNode // Restriction: Cannot nest ListNode
//                    | UniqueIdTextNode byte[16]       // byte[16] is a Guid (from Guid.ToBinary()) (urn:uuid:xxxx-xxxx-xxx)
//                    | GuidTextNode byte[16]           // byte[16] is a Guid (from Guid.ToBinary()) (xxxx-xxxx-xxx)
//                    | TimeSpanNode Int64
//                    | UInt64TextNode UInt64
//                    | BoolTextNode Int8
// BinaryText        => Bytes8TextNode  UInt8  byte*
//                    | Bytes16TextNode UInt16 byte*
//                    | Bytes32TextNode UInt31  byte*
// CharsText         => Chars8TextNode  UInt8  byte* // UTF8Chars
//                    | Chars16TextNode UInt16 byte*
//                    | Chars32TextNode Unt31  byte*
//                    | UnicodeChars8TextNode UInt8 char*
//                    | UnicodeChars16TextNode UInt16 char*
//                    | UnicodeChars32TextNode UInt31 char*
//                    | QNameDictionaryTextNode UInt8 MB32(LocalName) // UInt8 0-25 => 'a'-'z'
// Comment           => CommentNode Name(Text)
// Name              => MB32 byte* // Length, UTF8Chars
// MB32(x:x>=0x80)   => byte(0x80 | (x & 0x7F)) MB32(x >> 7)
// MB32(x:x<0x80)    => byte(x)
// In order to help differentiate text from binary (where someone mixes up format and implementation) we overlay binary
// nodes that are illegal to start a document with text characters that are legal to start a document.  Specifically these values are:
// ' ' = 32
// '\t' = 9
// '\n' = 10
// '\r' = 13
// '<' = 60
// The attribute nodes (MinAttribute to MaxAttribute) overlay all of these values and are invalid as the first byte of the document
// ProcessingInstruction = 0, // Reserved (Not supported)
// MinorVersion = MaxElement + 1, // Reserved (Not supported)
// Must be even 
//localhost/dummy";
//localhost/dummy";
//localhost/dummy";
//localhost/dummy";
//tempuri.org/NotTheDefaultServiceNamespace")]
//corewcf.corewcf/OddAction", ReplyAction = "corewcf://corewcf.corewcf/OddReplyAction")]
// Instance created as part of service startup to probe if type is availale in DI
// Instance not disposed as it implements IServiceBehavior and is added to service behaviors
// Instance shouldn't be created as part of service startup as type isn't available in DI
// Instance created as part of service startup as it implements IServiceBehavior
// Instance not disposed as it implements IServiceBehavior and is added to service behaviors
// Instance created as part of service startup to probe if type is available in DI
// Instance not disposed as it implements IServiceBehavior and is added to service behaviors
// Instance shouldn't be created as part of service startup to as type isn't available in DI
// Instance created as part of service startup as it implements IServiceBehavior
// Instance not disposed as it implements IServiceBehavior and is added to service behaviors
//localhost/Service.svc";
//dispatcher-session/" + Guid.NewGuid().ToString();
//dispatcher-session/" + Guid.NewGuid().ToString();
// "The event is never used"
// These are required to implement IReplyChannel
//tempuri.org/ISimpleService/Echo";
//schemas.xmlsoap.org/soap/envelope/"">
//tempuri.org/"">
// 64K to keep out of LOH
// 64K to keep out of LOH
// Only want to call Close if it is in the Opened state
// Anything not closed by this point should be aborted
//schemas.xmlsoap.org/soap/envelope/"">
//tempuri.org/"">
//schemas.xmlsoap.org/soap/envelope/""><s:Header><Action s:mustUnderstand=""1"" xmlns=""http://schemas.microsoft.com/ws/2005/05/addressing/none"">http://tempuri.org/ISimpleService/EchoResponse</Action></s:Header><s:Body><EchoResponse xmlns=""http://tempuri.org/""><EchoResult>aaaaa</EchoResult></EchoResponse></s:Body></s:Envelope>";
//tempuri.org/ISimpleXmlSerializerService/Echo";
//schemas.xmlsoap.org/soap/envelope/"">
//tempuri.org/"">
//schemas.xmlsoap.org/soap/envelope/""><s:Header><Action s:mustUnderstand=""1"" xmlns=""http://schemas.microsoft.com/ws/2005/05/addressing/none"">http://tempuri.org/ISimpleXmlSerializerService/EchoResponse</Action></s:Header><s:Body xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns:xsd=""http://www.w3.org/2001/XMLSchema""><EchoResponse xmlns=""http://tempuri.org/""><EchoResult>aaaaa</EchoResult></EchoResponse></s:Body></s:Envelope>";
//localhost:8080/basichttp";
//schemas.xmlsoap.org/soap/envelope/\"><soapenv:Body><Echo xmlns = \"http://tempuri.org/\" ><text>Hello</text></Echo></soapenv:Body></soapenv:Envelope>";
//localhost:8808/nettcp"));
// 
// The following sample, creates a basic web request to the specified endpoint, sends the SOAP request and reads the response
// 
// Prepare the raw content
// Create the web request
//tempuri.org/IEchoService/Echo");
// Append the content
// Send the request and read the response
//localhost:8808/"), 
//localhost:8080/"));
//localhost:8080/basichttp";
//schemas.xmlsoap.org/soap/envelope/\"><soapenv:Body><Echo xmlns = \"http://tempuri.org/\" ><text>Hello</text></Echo></soapenv:Body></soapenv:Envelope>";
//localhost:8808/nettcp"));
// Complex type testing
// 
// The following sample, creates a basic web request to the specified endpoint, sends the SOAP request and reads the response
// 
// Prepare the raw content
// Create the web request
//tempuri.org/IEchoService/Echo");
// Append the content
// Send the request and read the response
//localhost:8080")
