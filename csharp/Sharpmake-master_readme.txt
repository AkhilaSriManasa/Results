// Copyright (c) 2017 Ubisoft Entertainment
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
# Introduction

Sharpmake is a solution to generate mainly C++ and C# projects, file extensions like .vcxproj, .csproj, .sln, .bff (FastBuild).  It is using C# as a scripting language with the implementation in C# as well, meaning complete support in Visual Studio for debugging and Intellisense.  Sharpmake is easily usable by both C++ and C# programmers and is generating project files fast.  Using a complete programming language like C# is offering a lot of ways to scale better with big code bases.  Sharpmake has built-in support for FastBuild .bff files, easing using both FastBuild projects and normal VC++ projects.

# Fragments

One core and cool concept of Sharpmake are the fragments.  Fragments are defined with an enum like this one:

```csharp
[Fragment, Flags]
enum Optimization
{
    Debug = 0x1,
    Release = 0x2,
    Retail = 0x4
}
```

Notice that the enum is using different bits for every value.

# Targets

Fragments are used to define targets.  Targets are classes with a certain number of properties of different fragment types:

```csharp
class Target : Sharpmake.ITarget
{
    public BuildSystem BuildSystem;
    public Optimization Optimization;
    public DevEnv DevEnv;
    ...
}
```

The idea behind fragments is that they can multiply your number of targets.  You can combine the bits of fragment values to describre multiple targets easily:

```csharp
new Target(
    BuildSystem.MSBuild | BuildSystem.FastBuild, 
    Optimization.Debug | Optimization.Release | Optimization.Retail, 
    ...)
```

That target instance will represent a target list, something useful when calling AddTargets.

# Project

A project in Sharpmake is a class with a specific attribute:

```csharp
[Generate]
class MyProject : Project
{
    ...
}
```

Sharpmake supports 3 types of projects: Generate, Compile and Export.  Export is used for libraries already compiled while Generate is when the project file (.vcxproj, .csproj, etc.) will be generated.  Compile attribute is for marginal cases where a project generated outside of Sharpmake is reused in a solution (.sln) generated by Sharpmake.

That project class will be instantiated a single time.  In the constructor, you add all the targets for the project.  

```csharp
[Generate]
class MyProject : Project
{    
    public MyProject() : base(typeof(Target))
    {
        AddTargets(new Target(
            BuildSystem.MSBuild | BuildSystem.FastBuild,
            Optimization.Debug | Optimization.Release | Optimization.Retail,
            ...);
    }
}

```

If you ever wonder why these are not deduced from dependants, it is made that way to generate all projects in parallel, and result in much faster execution.  This is typically not an issue as you can add the targets in a base class.

# Configure

In the project, you have one or more Configure functions.  They take a Target, which is the input, and the Configuration, which is the output.  The function is executed for every Target added to that project.

```csharp
class MyProject : Project
{
    ...
    [Configure]
    public void Configure(Configuration conf, Target target)
    {
        if (target.Optimization == Optimation.Debug)
            conf.Defines.Add("UBI_DEBUG");
        ...
    }
```

Since the function is executed for every target, you can use simple code to choose how to configure like if/else, switch/case, functions, whatever you prefer.  This is normal C# code.

Since projects are classes, you can define a class hierarchy to represent your projects.  You can use virtual functions and overrides, can use static public functions in other classes, etc.

By default, a Configure function is for all targets, but you can limit a Configure function to a subset with specific fragment values:

```csharp
[Configure(Platform.win32 | Platform.win64)]
void ConfigureWindows(Target target, Configuration conf)
{
    ...
}
```

# Dependencies

Adding dependencies between projects is done in Configure functions.

```csharp
    [Configure]
    public void Configure(Configuration conf, Target target)
    {
        conf.AddPublicDependency<System>(target);
        conf.AddPublicDependency<Engine>(target);
        conf.AddPublicDependency<Havok>(target.ToHavokTarget());
    }
```

You call AddPublicDependency or AddPrivateDependency with the project type to depend on.  You also pass the target.  The target is typically the same, but it's possible for different projects to use different Target types.  

If the case, you call code to make the correspondence.  It can be a property, a function, whatever you prefer.

Sharpmake was designed initially for C++ needs, so it provides mechanisms to define include paths, library paths, preprocessor definitions for a project a single time.  

```csharp
    [Configure]
    public void Configure(Configuration conf, Target target)
    {
        conf.IncludePaths.Add(...);  // also for dependants
        conf.IncludePrivatePaths.Add(...);
        conf.ExportDefines.Add(...);  // for dependants
        conf.Defines.Add(...);
        ...
    }
```

There's a clear distinction in Configuration class between include paths and preprocessor definitions to compile the current project and the ones that are also necessary in dependent projects, with direct or indirect dependencies.

With distinction between public and private dependencies, it's also possible to limit if dependencies are propagated to dependants or not.


# Smart File Granularity

A project in Sharpmake doesn't mean necessarily a single project file on disk.  Files in Sharpmake are like any output and are handled automatically.

For example, if in a Configure function you have this line:

```csharp
    [Configure]
    public void Configure(Configuration conf, Target target)
    {
        conf.ProjectFileName = "[project.Name].[target.DevEnv]";
```
        

Here we can see that strings in Sharpmake supports to refer to some objects properties through reflection.  It's actually useful to use that rather than normal C# features since that way they are evaluated much later.

If this line is changed into this:

```csharp
    [Configure]
    public void Configure(Configuration conf, Target target)
    {
         conf.ProjectFileName = "[project.Name].[target.Platform].[target.DevEnv]";
```

Then Sharpmake will generate a file for each platform.  There is nothing more to do.


# Solutions

The configuration and generation of .sln files is done in a similar fashion to .vcxproj and .csproj files.  Instead of Project class, the Solution class is used:

```csharp
[Generate]
class MySolution : Solution
{    
    public MySolution() : base(typeof(Target))
    {
        AddTargets(new Target(
            BuildSystem.MSBuild | BuildSystem.FastBuild,
            Optimization.Debug | Optimization.Release | Optimization.Retail,
            ...);
    }
    [Configure]
    public void Configure(Configuration conf, Target target)
    {
        conf.AddProject<MyProject>(target);
    }
}
```

# Main

The entry point is the Main, a function called once and found in the main .sharpmake.cs file passed to Sharpmake.exe:

```csharp
static class Main
{
    [Sharpmake.Main]
    public static void SharpmakeMain(Sharpmake.Arguments arguments)
    {
        arguments.Generate<MySolution>();
    }
}
```

Sharpmake arguments can then be used to generate different things.  Sharpmake has built-in support for easy custom command line arguments as well:

```csharp
class MyArguments
{
    public bool SomeOption = false;

    [CommandLine.Option("someoption", @"Some option: ex: /someoption(<true|false>)")]
    public void CommandLineGenerateMapFile(bool value)
    {
        SomeOption = value;
    }
}

static class Main
{
    public static MyArguments Arguments = new MyArguments();

    [Sharpmake.Main]
    public static void SharpmakeMain(Sharpmake.Arguments arguments)
    {
        CommandLine.ExecuteOnObject(Arguments);
        ...
        if (Arguments.SomeOption) ...
    }
}
```
# Includes

From the main file and from any included file, you can include other Sharpmake files:

```csharp
[module: Sharpmake.Include("otherfile.sharpmake.cs")]
```

In any file it's also possible to refer to any dll:

```csharp
[module: Sharpmake.Reference("Sharpmake.ShellTools.dll")]
```

It concludes that quick overview of Sharpmake.

# Apache License

Version 2.0, January 2004

http://www.apache.org/licenses/

## TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

### 1. Definitions.

"License" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.

"Licensor" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.

"Legal Entity" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, "control" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.

"You" (or "Your") shall mean an individual or Legal Entity exercising permissions granted by this License.

"Source" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.

"Object" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.

"Work" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).

"Derivative Works" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.

"Contribution" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, "submitted" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as "Not a Contribution."

"Contributor" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.

### 2. Grant of Copyright License.
Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.

### 3. Grant of Patent License.
Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.

### 4. Redistribution.
You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:

You must give any other recipients of the Work or Derivative Works a copy of this License; and
You must cause any modified files to carry prominent notices stating that You changed the files; and
You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and
If the Work includes a "NOTICE" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. 

You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.

### 5. Submission of Contributions.
Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.

### 6. Trademarks.
This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.

### 7. Disclaimer of Warranty.
Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.

### 8. Limitation of Liability.
In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.

### 9. Accepting Warranty or Additional Liability.
While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.
# Sharpmake

[![Build status](https://ci.appveyor.com/api/projects/status/5y9eug3x9j078x6i?svg=true)](https://ci.appveyor.com/project/belkiss/sharpmake-36817)

## Introduction
Sharpmake is a generator for Visual Studio projects and solutions. It is
similar to CMake and Premake, but it is designed for **speed** and
**scale**. Sharpmake has been used at Ubisoft to generate several thousands
of *vcxproj*, *csproj* and *sln* files in a matter of seconds, and each of
these projects can support a large number of Visual Studio configurations as
well.

That makes Sharpmake ideal for the development of multi-platform games, where
the number of platforms, the different levels of optimization, the multiple
rendering APIs on PC and the level editor can quickly multiply the number of
configurations a given code base must support. Sharpmake generates all those
configurations at once, very quickly. Thus, it becomes trivial to generate
and regenerate the entire project.

Sharpmake uses C# for scripting, hence the name. That means that you can edit
your scripts in Visual Studio (or Visual Studio Code) and have a complete
IntelliSense programming experience.

Sharpmake can also generate makefiles and Xcode projects, but it is currently
only available for Windows. With .NET Core and .NET Standard though, it is
our hope that it will eventually cross the platform barrier. In the
meanwhile, you may have luck using it with Mono.

Sharpmake was developed internally at Ubisoft for Assassin's Creed 3 in 2011.
After experimenting with the other existing tools, it became clear that none
of these solutions were performant enough to generate the number of
configurations needed (at least not in a trivial way) and that a custom
generator was needed.


## Documentation
The best place for the Sharpmake documentation is the
[wiki on GitHub](https://github.com/ubisoftinc/Sharpmake/wiki). The Sharpmake
source code also comes with samples that you can study.


## Building Sharpmake
Building Sharpmake is quite straightforward. Clone the repo on GitHub, open the
solution in Visual Studio and build the solution in *Release*. The binaries
will be found in the *Sharpmake.Application/bin/Release*. You can run the
*deploy_binaries.py* script to automatically fetch the binaries and copy them
in a *Binaries* folder.


## More Platforms
Sharpmake originally had support for game consoles, but Ubisoft pulled it out
because those could not be open sourced. Sharpmake now has an extension system
that allows support for these consoles to be added back at runtime.

If you need support for these platforms and are an authorized developer, you
can contact the SDK provider to get platform extension for Sharpmake.


## Contributing

### Tests
We will only accept merge requests that pass every tests. The unit tests are
written with NUnit and the regression tests are ran by comparing the samples'
output with a reference output. You can run the *regression_tests.py* script
after having built the solution in Visual Studio to run the regression tests.

Because the regression tests just do a direct comparison with the output, it is
possible to get a false negative after having done a good change. In that case,
please update the tests so they match the output after your change. You can run
the *UpdateSamplesOutput.bat* and *UpdateSharpmakeProjects.bat* batch files to
automatically overwrite the reference output files.

Naturally, we also recommend that you put your own tests after fixing a bug or
adding a feature to help us avoid regressions.

Functional tests are generating test projects and building them to test
functionality

used toolset for functional tests:

tools\FastBuild\FBuild.exe - v0.97. http://www.fastbuild.org



### Additional Platforms
If you want to add support for an additional platform, please make sure that
the platform is open and that you are not breaking your NDA. Ubisoft has not
published platform support for most video game consoles for that exact reason.
We will not accept merge requests for new platforms that are not completely
open for development.
# Sharpmake Guidelines

We get often asked what are the suggested guidelines to use Sharpmake.  Here a few guidelines that we suggest to follow.

## Understand the two possible approach with targets

There are 2 typical ways of defining targets in Sharpmake.  The first one is use different target types for different projects.  This is mostly useful for 3rd party libraries.  It implies to make a conversion between target types:

```csharp
namespace SomeLib
{
    class Target : ITarget { ... }
    class SomeLib : Project 
    {
        SomeLib() : Project(typeof(Target)) { ... }
        ...
    }
}
namespace MyNamespace
{
    class Target : ITarget
    {
        ...
        SomeLib.Target GetSomeLibTarget() { return ...; }
    }
    [Generate]
    class MyProject : Project
    {
        [Configure]
        void Configure(Configuration conf, Target target)
        {
            ...
            conf.AddPublicDependency<SomeLib.SomeLib>(target.GetSomeLibTarget());
        }
    }
}
```

The other approach is to simply use the same target type:

```csharp
namespace MyNamespace
{
    class SomeLib : Project 
    {
        SomeLib() : Project(typeof(Target)) { ... }
        ...
    }
    class Target : ITarget
    {
        ...
    }
    [Generate]
    class MyProject : Project
    {
        [Configure]
        void Configure(Configuration conf, Target target)
        {
            ...
            conf.AddPublicDependency<SomeLib>(target);
        }
    }
}
```

Which one is better?  It depends.  Different target types are providing mainly 2 advantages:
* It can make the library .sharpmake.cs file independent and reusable in other contexts.
* The number of targets added in the library can be smaller and minimal.

Using the same target type can however end up simpler, and we've seen projects at Ubisoft minimizing different target types to simplify code.  Different target types can end up tricky to do properly if you end up with diamond dependencies; Sharpmake supports them well, it's just that the conversion on both sides of the diamond must be coherent.

## Targets are compile-time tools

Whatever the solution you use, you don't want to give different meaning to the same Target type. Keep the target type as a compile-time tool, not run-time. It means you should **not** do the following:

```csharp
class Target
{
    ...
    Target GetSomeLibTarget() { return ...; }  // same target type; this is wrong
```

The problem with the previous example, is that the following would compile while what is wanted is to make a conversion:

```csharp
    [Generate]
    class MyProject : Project
    {
        [Configure]
        void Configure(Configuration conf, Target target)
        {
            ...
            conf.AddPublicDependency<SomeLib>(target);  // target.GetSomeLibTarget intended
        }
    }
```


## Write things once

Using C# in Sharpmake is offering multiple ways to write things a single time.

### Use a class hierarchy and virtual methods

It is strongly suggested to define a class hierarchy for projects to move common definition higher in hierarchy.  

Configure methods can be virtual and one possible approach is to do something like the following:

```csharp
    [Generate]
    class MyProject : Project
    {
        [Configure]
        virtual void Configure(Configuration conf, Target target)
        {
            ...
        }
    }
    [Generate]
    class MySubProject : MyProject
    {
        override void Configure(Configuration conf, Target target)
        {
            base.Configure(conf, target);
            ...
        }
    }
```

Another approach is to use other virtual methods to configure specific parts of a Configuration:

```csharp
    [Generate]
    class MyProject : Project
    {
        [Configure]
        void Configure(Configuration conf, Target target)
        {
            ConfigureOptimization(conf, target);
            ConfigureDefines(conf, target);
        }

        virtual void ConfigureOptimization(Configuration conf, Target target) { ... }
        virtual void ConfigureDefines(Configuration conf, Target target) { ... }
    }
    [Generate]
    class MySubProject : MyProject
    {
        override void Configure(Configuration conf, Target target)
        {
            base.Configure(conf, target);
            ...
        }
    }
```

The level of granularity of these virtual methods is up to you.  It can be very small:

```csharp
        [Configure]
        void Configure(Configuration conf, Target target)
        {
            ...
            ConfigureStringPooling(conf, target);
            ...
        }
        public virtual void ConfigureStringPooling(Configuration conf, Target target)
        {
            conf.Options.Add(Sharpmake.Options.Vc.Compiler.StringPooling.Disable);
        }
```

Multiple Configure functions can also be used, and Sharpmake is offering a feature to make them specific a to subset of the targets in the project:

```csharp
[Configure(Platform.win32 | Platform.win64)]
void ConfigurePs4(Configuration conf, Target target)
{
    ...
}

[Configure(Platform.ps4)]
void ConfigurePs4(Configuration conf, Target target)
{
    ...
}
 
[Configure(Platform.durango)]
void ConfigureDurango(Configuration conf, Target target)
{
    ...
}
```

If doing multiple Configure functions, it is strongly recommanded to avoid depending on Configure methods execution order.  If you do, the attribute ```[ConfigureOrder]``` can be used.  Sharpmake is using the order of declaration in the class as much as possible, but then changing a Configure method from virtual to override with code moved in a base class can change the execution order.  Many programmers are completely surprised when simply moving code around is changing the produced result.  For these reasons it is suggested that different Configure functions work on different and independent things.

### Dependency System

The dependency system is offering tools to write things about a library a single time, making sure dependent projects get all the required preprocessor definitions, includes, etc.  It is suggested to use the dependency system to write things only once.

For example, while Sharpmake allows you to do the following:

```csharp
conf.LibraryFiles.Add("Iphlpapi.lib");
```

It might be better to take the time to define everything for that library once:

```csharp
[Sharpmake.Export]
class IPHelperAPI
{
    void Configure(Configuration conf, Target target)
    {
        ...  // configure for target .lib, needed include path and define for dependents
    }
}
```

That project can then be added as a dependency.

### Public static functions

C# public static functions can offer an easy way to write code a single time.  Suppose you have the following:

```csharp
class MyBaseProject : Project
{
    public MyBaseProject : base(typeof(Target))
    {
        AddTargets(new Target(
            Platform.win32 | Platform.win64, 
            DevEnv.vs2015,
            ...));
    }
}
```

Even if you add targets in base class, in a big code base you might add targets in multiple classes.  And when you do, there's probably something common between all these, like DevEnv version or platforms.  You can choose to call functions dedicated to these:

```csharp
class MyBaseProject : Project
{
    public MyBaseProject : base(typeof(Target))
    {
        AddTargets(new Target(
            Settings.GetDefaultPlatforms(),
            Settings.GetDefaultDevEnvs(),
            ...));
    }
}
```

You can then in a single place configure these default values:

```csharp
static class Settings
{
    Platform GetDefaultPlatforms() { return Platform.win32 | Platform.win64; }
    DevEnv GetDefaultDevEnvs() { return DevEnv.vs2015; }
}
```

Here, in a transition between 2 DevEnv versions for example, you could generate 2 versions with a single line change:

```csharp
    DevEnv GetDefaultDevEnvs() { return DevEnv.vs2015 | DevEnv.vs2017; }
```

These can be also enriched to be configured by preference files per user, but that's another topic.

## Don't destroy base classes

We've seen in the past some programmers clear completely targets added in a base class to replace them completely:

```csharp
class Perforce : CommonProject
{
    Perforce()
    {
        ClearTargets();
        AddTargets(...);
    }
```

This is something to avoid, as more of a pain to maintain.  This is typically done because these programmers ignore that Sharpmake provides a feature to keep only a subset of the targets from the base class:

```csharp
class Perforce : CommonProject
{
    Perforce()
    {
        AddFragmentMask(Mode.Tool, Optimization.Debug | Optimization.Release);
    }
```

This is much better, even if the Is-A relationship is slightly incorrect.  At least this technique is easier to maintain.  It can be used for any combinaison of fragments and can be useful to minimize multiplying the number of base classes.  Another example:

```csharp
class MyBaseProject : Project
{
    public MyBaseProject : base(typeof(Target))
    {
        AddTargets(new Target(Platform.win32 | Platform.win64, ...));
    }
}
[Generate]
class MyProject : MyBaseProject
{
    public MyProject
    {
        AddFragmentMask(Platform.win64);  // don't need win32
    }    
}
```




## Consider switch/case with exception for big fragments

Here's the Optimization fragment from Rainbow Six Siege project:

```csharp
[Fragment, Flags]
public enum Optimization
{
    Debug = 0x01,
    AiDebug = 0x02,
    AiDebugEnc = 0x04,
    Release = 0x08,
    Profile = 0x10,
    MemTagFinal = 0x20,
    QCFinal = 0x40,
    Final = 0x80,
    FinalLTO = 0x100,
}
```

This is a big enum and some entries in it are driven by per-user preferences to avoid generating them uselessly.  Nevertheless, the .sharpmake.cs code files must support all entries, and using a switch/case in C# can provide the advantage of not forgetting any entry:

```csharp
switch (target.Optimization)
{
    case Optimization.Debug:
        conf.Defines.Add("_DEBUG");
        break;
    case Optimization.FinalLTO:
    case Optimization.Profile:
    case Optimization.MemTagFinal:
    case Optimization.QCFinal:
    case Otimization.Final:
        conf.Defines.Add("NDEBUG", "UBI_FINAL");
        break;
    case Optimization.AiDebug:
    case Optimization.AiDebugEnc:
    case Optimization.Release:
        conf.Defines.Add("NDEBUG");
        break;
    default:
        throw new Error("Bad optimization type in target. {0}", this);
}
```

## Use a C# IDE like Visual Studio

Using a C# IDE with auto-complete like Visual Studio is making it easier to use and learn Sharpmake.  Sharpmake is designed to provide all compiler and linker option through options discoverable through auto-complete/Intellisense.  Using an IDE is suggested.


# Sharpmake

*This documentation is far from complete and is a work in progress. Feel free
to improve it.*



## Table of Contents
-------------------------------------------------------------------------------
* [Sharpmake](#sharpmake)  
  * [Table of Contents](#table-of-contents)  
  * [About this repository](#about-this-repository)  
  * [Introduction](#introduction)  
    * [Quick Feature Overview](#quick-feature-overview)  
      * [Powerful Scripting](#powerful-scripting)  
      * [Accessible for Many Programmers](#accessible-for-many-programmers)  
      * [Exceptional Scalability and Modularity](#exceptional-scalability-and-modularity)  
      * [Generation from Sources](#generation-from-sources)  
      * [Generate Everything Quickly](#generate-everything-quickly)  
      * [Smart Granularity and Fragments](#smart-granularity-and-fragments)  
      * [Target and Configuration Independence](#target-and-configuration-independence)  
      * [Native Blobbing Support](#native-blobbing-support)  
      * [Dependency Management and Flexible Target System](#dependency-management-and-flexible-target-system)  
      * [NDA-Protected Platform Support](#nda-protected-platform-support)  
  * [Hello World](#hello-world)  
    * [Create a C++ Source File](#create-a-c-source-file)  
    * [Create a Sharpmake File](#create-a-sharpmake-file)  
    * [Launch Sharpmake](#launch-sharpmake)  
    * [Create a Debugging Environment](#create-a-debugging-environment)  
  * [More Detailed Documentation](#more-detailed-documentation)  
    * [Main Attribute](#main-attribute)  
    * [Custom Argument Type](#custom-argument-type)  
    * [Solution](#solution)  
    * [Project](#project)  
      * [Generate Attribute](#generate-attribute)  
      * [Compile Attribute](#compile-attribute)  
      * [Export Attribute](#export-attribute)  
      * [Preprocessor Define](#preprocessor-define)  
    * [Projects and File Mapping](#projects-and-file-mapping)  
    * [Fragments](#fragments)  
    * [Configure Attribute](#configure-attribute)  
      * [Configure Call Order](#configure-call-order)  
      * [Old Configure Order](#old-configure-order)  
      * [ConfigurePriority Attribute](#configurepriority-attribute)  
      * [Enforce no Dependencies on Configure Order](#enforce-no-dependencies-on-configure-order)  
    * [Targets and Configurations](#targets-and-configurations)  
    * [Sharpmake Strings](#sharpmake-strings)  
    * [Dependencies](#dependencies)  
    * [Compiler, Linker and Other Options](#compiler-linker-and-other-options)  
      * [Per-file Options](#per-file-options)  
    * [File Including](#file-including)  
    * [Blobbing Support](#blobbing-support)  
    * [File Inclusion and Exclusion](#file-inclusion-and-exclusion)  
    * [Ordering String Values](#ordering-string-values)  
    * [Filtering Targets Added in Base Class](#filtering-targets-added-in-base-class)  
    * [Limited Dependencies](#limited-dependencies)  
    * [Preferences](#preferences)  
  * [.NET Support](#net-support)  
    * [C++/CLI Support](#ccli-support)  
    * [C# Support](#c-support)  
      * [C# *Hello, World!*](#c-hello-world)  
      * [References](#references)  
        * [Project References](#project-references)  
        * [.NET References](#net-references)  
        * [External References](#external-references)  
    * [Copy Local](#copy-local)  
    * [Build Actions](#build-actions)  
      * [Resource](#resource)  
      * [Content](#content)  
      * [None](#none)  
    * [Namespace](#namespace)  
    * [Output File Name](#output-file-name)  
    * [WebReferenceUrls](#webreferenceurls)  



## About this repository
-------------------------------------------------------------------------------
This repository has branches mirroring the Sharpmake code used by many
projects.



## Introduction
-------------------------------------------------------------------------------
Sharpmake is an Ubisoft-developped solution to generate *.vcxproj*, *.vcproj*,
*.sln*, and *.csproj* files, as well as potentially more formats. Sharpmake
was developed to generate files very quickly and allow users to easily
generate multiple solutions and projects according to project and user
preferences. It was conceived to be easy to maintain and debug. It has native
support for blobbing unity builds) and has been developed to fulfill production
needs and provide flexible control over what is generated. As far as we know,
it is better than all available open source solutions.

Sharpmake was originally developed by Eric Thiffeault on Assassin's Creed 3 in
2011 and is used on multiple projects at Ubisoft.


### Quick Feature Overview
Here's an overview of some of the features that make Sharpmake stand out.

#### Powerful Scripting
As its name hints, Sharpmake is implemented in C#. But it's not only
implemented in C#, the scripts (they can be either *.sharpmake* or
*.sharpmake.cs* files, but the official extension is the latter) are also C#
files used in a scripting way with dynamic compilation. This makes Sharpmake
very easy to debug, in addition to being very quick. It also delivers a very
powerful language to use within the scripts. The scripts use the Sharpmake API
directly, facilitating the override and expansion of the API, which is
important for sharing Sharpmake across projects. The nature of C# makes it
very easy to write everything once. Sharpmake's "include" system is also very
scaleable.

#### Accessible for Many Programmers
The use of C#, including well-known concepts like C# attributes and C#
inheritance, make Sharpmake files less intimidating. The result might be
slightly more verbose than the likes of Jamfiles, makefiles, and so on, but
the results are definitely easier to follow and use paradigms programmers know
well. The usage of .NET directly in *.sharpmake.cs* files to manipulate
strings also makes these files more accessible.

#### Exceptional Scalability and Modularity
One of the biggest strength of Sharpmake might not be obvious at first
glance: Sharpmake clearly allows encapsulation in a single and independent
file of an external library. (External dependencies are a great example of
where it may be useful.) This definition can include everything for the include
path, the library paths, the source code for different platforms, and so on.

#### Generation from Sources
Projects and solutions don't need to be in source control to be used with
Sharpmake. Sharpmake will scan specified folders for sources and provides easy
control over this behavior. For huge productions it avoids the need to merge
these files and provides an easy way to transition between different Visual
Studio versions. It also facilitates the creation of solutions optimized for
specific programmers as well as allowing programmer preferences inside
configurations.

#### Generate Everything Quickly
Sharpmake is designed to rapidly generate all the files a programmer could
potentially need in a single pass.

#### Smart Granularity and Fragments
Simply changing a solution name can automatically affect the number of .sln
files Sharpmake will generate, because a name can contain target-dependent
variables. The number of generated project and solution files is handled
intelligently by Sharpmake, making the end results very easy to maintain.

Sharpmake also presents the concept of fragments, which is what targets are
made of. Fragments will automatically affect the possible granularity that
Sharpmake will evaluate.

#### Target and Configuration Independence
If you want to use custom configuration names, the Sharpmake target system
makes this very easy. This comes in very handy when using external projects.

#### Native Blobbing Support
Sharpmake has native support for blobbing (also known as unity builds),
allowing multiple strategies to reduce compilation and iteration time as much
as possible.

#### Dependency Management and Flexible Target System
Sharpmake has dependency management to allow easy propagation of include and
library paths. Private dependencies are provided to prevent propagation.
Combined with the target system which is also extremely scalable, it lets you
mix different target types together, providing great flexibility. For example,
a software provider could define their own target types, which a program could
use with its own target type. Dependencies are made with a single target type,
but it's trivial to make correspondences between different types. The end
result is something extremely flexible and able to support huge code bases,
similar to programming in general.



## Hello World
-------------------------------------------------------------------------------
Here's a quick example to help you dive into Sharpmake.


### Create a C++ Source File
First, let's a create a *src\main.cpp* file for our sample:

```cpp
// src\main.cpp
#include <iostream>
int main(int, char**)
{
    std::cout << "Hello, World!" << endl;
}
```


### Create a Sharpmake File
Then, let's create a *hello.sharpmake.cs* file for creating an .sln and
.vcxproj for that example:

```cs
// hello.sharpmake.cs
using Sharpmake;
 
namespace HelloWorld
{
    [Sharpmake.Generate]
    public class HelloWorldProject : Project
    {
        public HelloWorldProject()
        {
            Name = "HelloWorld";
 
            AddTargets(new Target(
                    Platform.win32 | Platform.win64,
                    DevEnv.vs2008 | DevEnv.vs2010,
                    Optimization.Debug | Optimization.Release
            ));
 
            SourceRootPath = @"[project.SharpmakeCsPath]\src";
        }
 
        [Configure()]
        public void ConfigureAll(Configuration conf, Target target)
        {
            conf.ProjectFileName = "[project.Name]_[target.DevEnv]_[target.Platform]";
            conf.ProjectPath = @"[project.SharpmakeCsPath]\generated";
 
            // if not set, no precompile option will be used.
            //conf.PrecompHeader = "stdafx.h";
            //conf.PrecompSource = "stdafx.cpp";
        }
    }
 
    [Sharpmake.Generate]
    public class HelloWorldSolution : Sharpmake.Solution
    {
        public HelloWorldSolution()
        {
            Name = "HelloWorld";
 
            AddTargets(new Target(
                    Platform.win32 | Platform.win64,
                    DevEnv.vs2008 | DevEnv.vs2010,
                    Optimization.Debug | Optimization.Release
            ));
        }
 
        [Configure()]
        public void ConfigureAll(Configuration conf, Target target)
        {
            conf.SolutionFileName = "[solution.Name]_[target.DevEnv]_[target.Platform]";
            conf.SolutionPath = @"[solution.SharpmakeCsPath]\generated";
            conf.AddProject<HelloWorldProject>(target);
        }
 
        [Sharpmake.Main]
        public static void SharpmakeMain(Sharpmake.Arguments arguments)
        {
            arguments.Generate<HelloWorldSolution>();
        }
    }
}
```


### Launch Sharpmake
Run the Sharpmake executable to generate the project and solution.

```bat
Sharpmake.Application.exe "/sources(@"hello.sharpmake.cs") /verbose"
```


### Create a Debugging Environment
One advantage of Sharpmake is its ability to be naturally debugged in Visual
Studio. Here is how you can generate your own Debug Solution:

1.  Run sharpmake with the argument parameter `/generateDebugSolution`
    ```bat
       Sharpmake.Application.exe "/sources(@"hello.sharpmake.cs") /verbose /generateDebugSolution"
    ```

2.  A debug solution, *sharpmake_debugsolution.sln*, is created next to your
    sources entry point. It contains all of your sharpmake files and already
    references the sharpmake package you used to generate it. Also, its Debug
    Options are all set up for debugging.

3. Press F5!

If you want the debugger to break as soon as an an exception is raised, you
can do the following:

* *Tools > Options > Debugging > Enable Just My Code*: Checked
* *Debug > Exceptions... > Common Language Runtime Exception > Thrown*: Checked



## More Detailed Documentation
-------------------------------------------------------------------------------


### Main Attribute
Multiple attributes are usd to dictate behavior to Sharpmake. The first one is
`[Sharpmake.Main]`, which is put on the static method that will be called at
Sharpmake's launch:

```cs
[Sharpmake.Main]
public static void SharpmakeMain(Sharpmake.Arguments arguments)
{
    arguments.Generate<HelloWorldSolution>();
}
```


### Custom Argument Type
It's possible to define your own class to handle custom arguments. For
example, this is such a class from Assassin's Creed:

```cs
// class that defines custom command lines arguments
public class GameEngineArguments
{
    public bool BuildSystemHelper = true;
    public Filter Filter = Filter.None;
    public Strings ChangelistSourceFilesFilters;
    public int ChangelistNumber;
 
 
    [CommandLine.Option(
        "buildsystemhelper",
        @"Generate BuildSystemHelper helper files: ex: /buildsystemhelper(<true|false>)")]
    public void CommandLineBuildSystemHelper(bool value)
    {
        BuildSystemHelper = value;
    }
 
    [CommandLine.Option(
        "changelist",
        @"Generate project and solution for a specific changelist: ex: /changelist( 1234 , ""files.txt"")")]
    public void CommandLineChangelist(int changelistNumber, string changelistFile)
    {
        Filter = Filter.Changelist;
        ChangelistNumber = changelistNumber;
        ChangelistSourceFilesFilters = new Strings();
 
        try
        {
            FileInfo changelistFileInfo = new FileInfo(changelistFile);
            using (StreamReader projectFileStream = changelistFileInfo.OpenText())
            {
                string line = projectFileStream.ReadLine();
                while (line != null)
                {
                    if (line != string.Empty)
                    {
                        string filePath = Util.PathMakeStandard(line);
 
                        if (File.Exists(filePath))
                        {
                            ChangelistSourceFilesFilters.Add(filePath);
                        }
                        else
                        {
                            // try to find it if relative
                            string relativePath = Path.Combine(changelistFileInfo.DirectoryName, filePath);
                            if ( File.Exists(relativePath) )
                                ChangelistSourceFilesFilters.Add(new FileInfo(relativePath).FullName);
                            else
                                throw new Error("File path not found '{0}' in changelist file '{1}'", filePath, changelistFileInfo.FullName);
                        }
                    }
                    line = projectFileStream.ReadLine();
                }
            }
        }
        catch ( Exception e )
        {
            if (e is Error)
                throw e;
            else
                throw new Error("Cannot read changelist input file: {0}", changelistFile, e);
        }
    }
}
```

Then in the main:

```cs
Arguments = new GameEngineArguments();
CommandLine.ExecuteOnObject(Arguments);
```

The `CommandLine.ExecuteOnObject` will automatically search for the
`CommandLine.Option` attribute and parse options according to the
correcponding method signature.

Of course, any C# code can be executed in the `Main`, not just solution
building.


### Solution
As seen in HelloWorld, solutions are defined using a C# class with
`Sharpmake.Generate` attribute.

```cs
[Sharpmake.Generate]
public class HelloWorldSolution : Sharpmake.Solution
{
    public HelloWorldSolution()
    {
        Name = "HelloWorld";
 
        AddTargets(new Target(
                Platform.win32 | Platform.win64,
                DevEnv.vs2008 | DevEnv.vs2010,
                Optimization.Debug | Optimization.Release
        ));
    }
 
    [Configure()]
    public void ConfigureAll(Configuration conf, Target target)
    {
        conf.SolutionFileName = "[solution.Name]_[target.DevEnv]_[target.Platform]";
        conf.SolutionPath = @"[solution.SharpmakeCsPath]\generated";
        conf.AddProject<HelloWorldProject>(target);
    }
}
```

The projects are added to the solution in the `Configure` function, defined
through the `Sharpmake.Configure` attribute, as described later in this page.


### Project
As with solutions, C++ projects are defined with classes, overriding, and
inheritance being natural features in C#. Only classes with special attributes
will be considered, so it's possible to define your own base classes:

```cs
namespace GameEngine
{
    public class CommonProject : Project
    {
        // Preference for all projects here
        ...
    }
 
    [Sharpmake.Generate]
    public class MyProject : CommonProject
    {
        // Define project here
        ...
    }
}
```

#### Generate Attribute
As shown in previous examples, the `[Sharpmake.Generate]` attribute is used on
solutions and projects to indicate that they are completely generated in
Sharpmake. The attribute does not interfere with C# inheritance. Other
attributes allow for different strategies, such as `[Sharpmake.Compile]` and
`[Sharpmake.Export]` attributes. Built solutions and their added projects must
have one of these attributes: `[Sharpmake.Generate]`, `[Sharpmake.Compile]` or
`[Sharpmake.Export]`.

#### Compile Attribute
The attribute `[Sharpmake.Compile]` can be used to define projects with a
*.vcxproj* file already available. It can be useful when converting your code
base to Sharpmake, because it can support your old projects to facilitate an
incremental conversion of your projects. When defining a `[Sharpmake.Compile]`
project, you must define what is necessary for the project, it's
configurations, and the output for each.

```cs
namespace GameEngine
{
    [Sharpmake.Compile]
    public class GameLib : BaseProject
    {
        public string BasePath = @"[project.ExternPath]\gamelib";
        public string ProjectName = @"GameLib";
 
        public GameLib()
        {
            PerforceRootPath = @"[project.ExternPath]\gamelib";
        }
 
        [Configure()]
        public void Configure(Configuration conf, Target target)
        {
            string platform = (target.Platform == Platform.Win32 || target.Platform == Platform.Win64) ? "PC" : "[target.Platform]";
            conf.Name = platform + " [target.Optimization]";
            if (target.Mode == Mode.Tool)
            {
                conf.Name = "Editor [target.Optimization]";
                if (target.OutputType == OutputType.Dll)
                    conf.Name = "Editor DLL Export [target.Optimization]";
            }
 
            conf.SolutionFolder = "Extern";
 
            conf.IncludePaths.Add(@"[project.BasePath]\Sources");
 
            conf.ProjectPath = @"[project.BasePath]\Make";
            conf.ProjectFileName = "GameLib.2008";
 
            conf.TargetPath = @"[project.BasePath]\lib\vc2008\Projects\[conf.Name]";
            conf.TargetFileName = ProjectName;
 
            conf.Output = target.OutputType == OutputType.Lib ? Configuration.OutputType.Lib : Configuration.OutputType.Dll;
        }
    }
}
```

#### Export Attribute
Sharpmake has a dependency system which accepts various dependencies, not just
generated projects. The Export project type can be used to link with projects
when only the .lib files are available. For example, this is code from
Assassin's Creed to use Passenger:

```cs
namespace GameEngine
{
    [Sharpmake.Export]
    public class ExternalLib : Sharpmake.Project
    {
        public string ExternPath = Extern.Extern.ExternPath;
        public string BasePath = @"[project.ExternPath]\include\externlib";
 
        public ExternalLib()
        {
            AddTargets(new Sharpmake.Target(
                Platform.win32 | Platform.win64,
                DevEnv.vs2008 | DevEnv.vs2010,
                Optimization.Debug | Optimization.Release,
                OutputType.Dll));
        }
 
        [Configure()]
        public void Configure(Configuration conf, Target target)
        {
            conf.IncludePaths.Add(@"[project.BasePath]\include\externlib");
            conf.TargetFileName = @"gamex";
            conf.Output = Configuration.OutputType.Dll;
        }
    }
}
```

#### Preprocessor Define
It's also possible to define preprocessor macros and symbols, in both C/C++
and .NET languages:

```cs
[Configure(DotNetFramework.v4)]
public void DefineDotNet4(Configuration conf, Target target)
{
    conf.Defines.Add("DOT_NET_4");
}
 
[Configure(DotNetFramework.v4_5)]
public void DefineDotNet45(Configuration conf, Target target)
{
    conf.Defines.Add("DOT_NET_45");
}
 
[Configure(DevEnv.vs2010)]
public void DefineDevEnv2010(Configuration conf, Target target)
{
    conf.Defines.Add("DEVENV_VS2010");
}
 
[Configure(DevEnv.vs2012)]
public void DefineDevEnv2012(Configuration conf, Target target)
{
    conf.Defines.Add("DEVENV_VS2012");
}
```


### Projects and File Mapping
Something great about Sharpmake is that the number of different generated
files for the same project is implicit. The properties used to define the file
paths of projects and solutions can use variable that are dependent on
targets, and Sharpmake will automatically generate the appropriate number of
files with the appropriate targets. For example, on Assassin's Creed, multiple
solutions are used for the game engine, depending on platform, DirectX, and so
on. The definition looks like this:

```cs
namespace GameEngine
{
    public class CommonSolution : Sharpmake.Solution
    {
        [Configure()]
        public virtual void Configure(Configuration conf, Target target)
        {
            conf.SolutionPath = @"[solution.RootPath]\projects\[target.Platform]";
 
            // vs2008 is default
            if ( target.DevEnv == DevEnv.vs2008 )
                conf.SolutionFileName = @"[solution.Name].[target.Mode].[target.Platform]" + gfxAPI;
            else
                conf.SolutionFileName = @"[solution.Name].[target.Mode].[target.Platform]" + gfxAPI + ".[target.DevEnv]";
            // ...
```

But on Rainbow Six Siege, a single solution is used for the game engine,
containing all platforms:

```cs
namespace GameEngine
{
    public class CommonSolution : Sharpmake.Solution
    {
        [Configure()]
        public virtual void Configure(Configuration conf, Target target)
        {
            conf.SolutionPath = @"[solution.RootPath]\temp\sharpmake\solutions";
            conf.SolutionFileName = @"[solution.Name].[target.DevEnv]";
            // ...
```

And that is the beauty of it. Nothing other than the paths from Assassin's
Creed were changed on Rainbow Six to change the solution's granularity. From
the requested solution targets, Sharpmake will automatically deduce how many
project and solution files are needed and how many targets each of them
contain.

The same principle could be used to support even both Assassin's Creed and
Rainbow Six approaches on the same project. Suppose the time to open a
solution is influenced by the number of targets in it, and is wanted to
support both approaches: one solution for all targets and one solution per
target or target type. A simple fragment could be added to achieve that:

```cs
[Fragment, Flags]
public enum SolutionGrouping
{
    OneToRuleThemAll = 0x01,
    OnePerConfig = 0x02,
}
```

Then, the fragment is added to the main target class and is examined to
influence `ProjectFileName` and `SolutionFileName`. The binding between
solutions and projects is done implicitly through the target. The requested
target will contain just `OneToRuleThemAll | OnePerConfig` to request both,
and that's it. Two sets of solutions and project groups will be generated.


### Fragments
One of the core features and biggest strengths of Sharpmake is the use of
fragments. Fragments are what targets are made of. Every project can override
its configuration for any specific fragment value. Some fragments are defined
directly in Sharpmake while others can be defined in *.sharpmake.cs* scripts.

```cs
[Fragment, Flags]
public enum Optimization
{
    Debug       = 0x01,
    AiDebug     = 0x02,
    AiDebugEnc  = 0x04,
    Release     = 0x08,
    Profile     = 0x10,
    QCFinal     = 0x20,
    Final       = 0x40,
}
 
[Fragment, Flags]
public enum GraphicAPI
{
    DirectX9 = 0x01,
    DirectX11 = 0x02,
}
```

The 2 built-in fragments `Platform` and `DevEnv` are mandatory if you create
custom target types. Custom target types must have 2 public fields for
`Platform` and `DevEnv` types.


### Configure Attribute
As previously stated, it's possible to verride the configuration for any
fragment value. The `[Sharpmake.Configure]` attribute is passed a list of
values where the associated method should be called. For example, this code is
in the project base class of our game engine:

```cs
[Configure(Mode.Engine, Platform.win32 | Platform.win64)]
public void ModeEngineWindows(Configuration conf, Target target)
{
    conf.Defines.Add("UBI_PLATFORM_PC");
}
```

It's possible to define multiple `Configure` methods, typically giving each
one different fragment values. The name of the method is not important,
because it's really the attribute that drives `Sharpmake`.

It is not mandatory to define multiple `Configure` methods. The preceding
example is the same thing as the following:

```cs
[Configure()]
public void Configure(Configuration conf, Target target)
{
    if (Mode == Mode.Engine && (Platform == Platform.win32 || Platform == Platform.win64)
        conf.Defines.Add("UBI_PLATFORM_PC");
}
```

According to preferences, code can be done in multiple ways, with
`switch/case` being another useful tool:

```cs
[Configure()]
public void Configure(Configuration conf, Target target)
{
    // ...
    switch (target.Optimization)
    {
        case Optimization.Profile:
        case Optimization.Retail:
            conf.Defines.Add("UBI_RETAIL");
            break;
        case Optimization.Debug:
            conf.Defines.Add("UBI_DEBUG");
            break;
        case Optimization.Release:
            conf.Defines.Add("UBI_RELEASE");
            break;
    }
    // ...
}
```

Having `using Sharpmake;` in the script files also gives access to extension
methods for some enum types:

```cs
[Configure()]
public void Configure(Configuration conf, Target target)
{
    // ...
    if (target.Platform.IsMicrosoft())
        conf.Defines.Add("_LIB");
 
    if (target.Platform.IsPC())
        conf.Defines.Add(
            "WIN95",
            "VISUAL",
            "USE_DBG_MODULE",
            "CAN_SET_OPTIONS",
            "DARE_PC_STATICLIB");
    // ...
}
```

It is important to note that only configuration should be modified in
`Configure` methods, not the `Project` itself. The `Project` should only be
modified in the constructor.

#### Configure Call Order
Sharpmake is calling `Configure` methods in the order they appear within the
project or solution class. It is however strongly advised to not depend on
that behavior. Adding multiple `Configure` methods to override specific
settings is much better:

```cs
public class BaseProject : Project
{
    // ...
    [Configure()]
    public virtual void ConfigureWarningAsError(Configuration conf, Target target)
    {
        conf.Options.Add(Sharpmake.Options.Vc.General.TreatWarningAsError.Enable);
    }
    // ...
}
```
```cs
[Sharpmake.Generate]
public class Bloomberg : BaseProject
{
    // ...
    public override void ConfigureWarningAsError(Configuration conf, Target target)
    {
        // Bloomberg, please fix your warnings
    }
    // ...
}
```

#### Old Configure Order
Old versions of Sharpmake were using another `Configure` order.  It was in the
order of declarations, but sub-classes overrides would affect that order.  The
problem was that sometimes empty overrides were kept just to have the same
`Configure` order. It's possible to ask for old `Configure` order:

```cs
[Sharpmake.Main]
public static void SharpmakeMain(Sharpmake.Arguments arguments)
{
    arguments.ConfigureOrder = ConfigureOrder.Old;
    // ...
}
```

#### ConfigurePriority Attribute
Again, it is not recommended to depend on `Configure` order. If necessary, by using `[ConfigurePriority]`, you ensure that the call order is respected even if the `Configure` methods are reordered. Sharpmake will sort them in ascending priority order. (-1 before 0, 0 before 1, etc.) Any `Configure` method without `[ConfigurePriority]` will have a default priority of 0.

Redefining priority is also supported across inheritance.

Here's an example of how `ConfigurePriority` can be used when using
inheritance:

* When `ParentProject` is generated, the sequence is: `Foo`, `Bar`
* When `ChildProject` is generated, the sequence is: `FooBar`, `Bar`, `Foo`
(`Foo` and `Bar` have been reordered)

```cs
[Sharpmake.Generate]
public class ParentProject : Project
{
    ...
    [Configure()]
    [ConfigurePriority(2)]
    public virtual void Bar(Configuration conf, Target target)
    {
        Debug.Assert(executedMethodFlags.Equals(ConfigureMethod.Foo),
            "ParentProject.Bar(...) assert failed",
            "ParentProject.Bar(...) should be the second configure to be invoked in this project");
 
        executedMethodFlags |= ConfigureMethod.Bar;
    }
 
    [Configure()]
    public virtual void Foo(Configuration conf, Target target)
    {
        Debug.Assert((int)executedMethodFlags == 0,
            "ParentProject.Foo(...) assert failed",
            "ParentProject.Foo(...) should be the first configure to be invoked in this project");
 
        executedMethodFlags |= ConfigureMethod.Foo;
    }
}
 
[Sharpmake.Generate]
public class ChildProject : ParentProject
{
    ...
    [ConfigurePriority(0)]
    public override void Bar(Configuration conf, Target target)
    {
        Debug.Assert(executedMethodFlags.Equals(ConfigureMethod.FooBar),
            "ChildProject.Bar(...) assert failed",
            "ChildProject.Bar(...) should be the second configure to be invoked in this project");
 
        executedMethodFlags |= ConfigureMethod.Bar;
    }
 
    [ConfigurePriority(1)]
    public override void Foo(Configuration conf, Target target)
    {
        Debug.Assert(executedMethodFlags.Equals(ConfigureMethod.FooBar | ConfigureMethod.Bar),
            "ChildProject.Foo(...) assert failed",
            "ChildProject.Foo(...) should be the third configure to be invoked in this project");
 
        executedMethodFlags |= ConfigureMethod.Foo;
    }
 
    [Configure()]
    [ConfigurePriority(-1)]
    public void FooBar(Configuration conf, Target target)
    {
        Debug.Assert((int)executedMethodFlags == 0,
            "ChildProject.FooBar(...) assert failed",
            "ChildProject.FooBar(...) should be the first configure to be invoked in this project");
 
        executedMethodFlags |= ConfigureMethod.FooBar;
    }
}
```

#### Enforce no Dependencies on Configure Order
As said more than once already, depending on `Configure` order is a bad idea. 
Once your code is clean regarding that, Sharpmake offers a feature to validate
it is ok, perfect for SubmitAssistant or build system validations. Just add
the argument `/test("QuickConfigure")` to the command-line arguments of
Sharpmake and the exit code will be non-zero if the `ConfigureOrder` cannot be
reversed. Note that the validation will still respect usages of
`ConfigurePriority` attributes, the reversing is done for `Configure` of the
same priority.


### Targets and Configurations
Sharpmake makes a clear distinction between *targets* and *configurations*.
The classes `Project.Configuration` and `Solution.Configuration` are used to
define the configurations in *.vcxproj* and *.sln* files. The targets bind
everything together. For example, the same target can use configurations with
different names depending on the project.

```cs
namespace GameEngine
{
    [Sharpmake.Compile]
    public class GameLib : Sharpmake.Project
    {
        public string ExternPath = Extern.Extern.ExternPath;
        public string BasePath = @"libs\GameLib";
        public string ProjectName = @"GameLib";
 
        public GameLib()
            : base(typeof(Target))
        {
            AddTargets(new Target(
                GameFolder.RainbowSix,
                Platform.win32 | Platform.win64 | Platform.ps3 | Platform.x360,
                DevEnv.vs2008,
                GameEngine.Optimization.Debug | GameEngine.Optimization.Release | GameEngine.Optimization.Profile | GameEngine.Optimization.Final,
                OutputType.Lib,
                Blob.NoBlob,
                GameEngine.Mode.Engine | GameEngine.Mode.Tool));
            PerforceRootPath = @"[project.ExternPath]\Library";
        }
 
        [Configure()]
        public void Configure(Configuration conf, Target target)
        {
            conf.Name = "[target.Platform] [target.Mode]";
            // ...
```

The virtual function will be called for Engine mode if the platform is Win32
or Win64. The name of the method is of no importance. Just make it unique, as
it's really the attribute that is examined. If the method is made virtual,
there is no need to specify the attribute in sub-classes.

We can also see in previous examples why fragments are defined as flags: the
C# "`|`" operator allows multiple fragments to be combined. A single `Target`
instance can be used to actually specify multiple targets.


### Sharpmake Strings
Every string in a Sharpmake solution, project, and configuration support uses
the `[obj.Property]` or `[Property]` format to insert values from properties
inside strings. The resolving is done as late as possible, making it possible
for more global properties to refer more local ones and vice-versa.

The following objects are supported:
* **target**: Property for the current target.
* **conf**: Property for the current configuration. It can be project or solution configuration, depending on which is being generated.
* **project**: Property of the current project.
* **solution**: Property of the current solution.

The built-in property `SharpmakeCsPath` has been already used in previous
examples. Provided as both `solution.SharpmakeCsPath` and
`project.SharpmakeCsPath`, it contains the path of the *.sharpmake.cs* file
where that solution or project was defined. This property is important: it can
be used for libraries to provide *.sharpmake.cs* files inside their library
packages, referring to the rest of the package with paths relative to
`SharpmakeCsPath`.

In addition, multiple properties are added by generators when generating (for
example) .sln or .vcxproj files, such as `solutionGuid`, `projectName`,
`projectFile`, `projectGuid`, `options.*`, and so on.

Note that static properties are supported at the moment.


### Dependencies
Sharpmake has built-in support for dependencies, making it easier to generate
solutions while ensuring they have everything needed. The dependency system
makes Sharpmake very scalable by allowing the definition of include paths,
library paths, library files and more in the definition of the appropriate
library. The dependency system will make these be appropriately inherited in
dependent projects. For example, dependencies in a solution will only be added
if necessary, that is if the target is not a static library. If the target is
a static library, the dependent executable will then have the dependencies.

For inherited properties such as include paths and library paths, Sharpmake
provides the option to choose between public and private dependencies. Private
dependencies are not propagated to dependent projects, so if a project needs
an include path to compile its own source files, but its headers don't need
it, a private include path can be included.

```cs
namespace Extern
{
    [Sharpmake.Export]
    public class SomeProject : MyExternProjectBase
    {
        public string BasePath = @"[project.ExternPath]\someproject";
 
        [Configure()]
        public void Configure(Configuration conf, Target target)
        {
            conf.IncludePaths.Add(@"[project.BasePath]\include");
            conf.PrivateIncludePaths.Add(@"[project.BasePath]\private\include");
            conf.LibraryPaths.Add(@"[project.BasePath]\lib");
            conf.LibraryFiles.Add(@"someproject");
        }
    }
}
```

Then, adding dependencies is as simple as calling `AddDependency` on a
project:
```cs
class MyProject : MyBaseProject
{
    [Configure()]
    public void Configure(Configuration conf, Target target)
    {
        conf.AddPublicDependency<SomeProject>(target);
    }
}
```

As seen in previous example, dependencies themselves can be completely public,
rely on their public/private definition, or be completely private.

Something important to note in the previous example is the target argument
passed to `AddPublicDependency`. This is target object binding the two
projects together. It might not be as simple as a target. For example, you
might to be able to control which third-party library is in debug in your
debug build, or even multiple debug builds. Another use case is something
Sharpmake specifically allows: defining reusable and shareable Sharpmake
script files for specific libraries.

Inherited elements from dependencies is not limited to include paths and
libraries. Files to be copied with the executable can be specified, which is
particularly useful with DLLs, when linking with an implib instead of a
complete static library:

```cs
[Configure()]
public void Configure(Configuration conf, Target target)
{
    conf.IncludePaths.Add(@"[project.BasePath]\include");
    if (target.Platform == Platform.win32)
        conf.LibraryFiles.Add("nvtt_win32");
    else if (target.Platform == Platform.win64)
        conf.LibraryFiles.Add("nvtt_win64");
    conf.LibraryPaths.Add(@"[project.BasePath]\lib");
    if (target.Platform == Platform.win32)
        conf.TargetCopyFiles.Add(@"[project.BasePath]\nvtt_win32.dll");
    else if (target.Platform == Platform.win64)
        conf.TargetCopyFiles.Add(@"[project.BasePath]\nvtt_x64.dll");
}
```


### Compiler, Linker and Other Options
Sharpmake supports a huge number of options when generating Visual C++ project
files and solutions, most them obviously being compiler and linker options. If
a given option is not supported, it's very easy to add support for a new one.
The availability of auto-completion in script files makes using new options
very easy:

```cs
[Configure()]
public void Configure(Configuration conf, Target target)
{
    base.Configure(conf, target);
    conf.Options.Add(new Sharpmake.Options.Vc.Compiler.DisableSpecificWarnings("4996", "4530"));
    conf.Options.Add(Sharpmake.Options.Vc.Compiler.Exceptions.EnableWithSEH);
}
```

All options are passed through `conf.Options`, and their types vary between
simple types and more complex types, as in the previous example. The
`Sharpmake.Options` static class contains all available options, classified
according to the tools and platforms. Setting an option for another platform
will simply have no effect as the underlying generator will not use it. For
this reason, the previous example would work with PS3 targets, but will have
no effect.

There's not much point in enumerating all the available options. Opening
*Options.cs* is simply enough and very easy to follow. This is what it looks
like:

```cs
namespace Sharpmake
{
    static public class Options
    {
        static public class Vc
        {
            static public class General
            {
                public enum CharacterSet
                {
                    Default,
                    Unicode,
                    [Default]
                    MultiByte
                }
 
                public enum WholeProgramOptimization
                {
                    [Default]
                    Disable,
                    LinkTime,
                    Instrument,
                    Optimize,
                    Update
                }
             // ...
```

The `Default` attribute is used to clearly set the default value and quickly
identify it when reading code.

#### Per-file Options
Sharpmake doesn't have precise per-file options to specify any compiler option
for any file. This could be added, but instead Sharpmake provides specific
features to be changed with file regular expressions, which is actually more
powerful and works well enough:

```cs
[Configure()]
public void Configure(Configuration conf, Target target)
{
    conf.PrecompSourceExclude.Add(
        @"\gameengine\audio\audioframework.cpp");
    if (target.Platform.IsPC())
    {
        conf.SourceFilesCompileAsCRegex.Add(@"oggvorbis\.bulk\.cpp$");
    }
    // ...
```


### File Including

```cs
[module: Sharpmake.Include("extern.sharpmake.cs")]
```

For better scalability, Sharpmake supports file including, as some previous
examples have demonstrated. Something to note is that the includes are
necessary for Sharpmake script files to be used outside the debugging
environment. They are not used in the debugging environment, where files are
instead compiled inside a DLL. Just remember to run generation with the
command line after making heavy changes inside the debugging environment.


### Blobbing Support
Blobbing support is native in Sharpmake. Sharmake has the following built-in
fragment:

```cs
[Fragment, Flags]
public enum Blob
{
    // Blob only project, another project references the source files
    Blob = 0x01,
 
    // Normal Visual Studio project without blobbing.
    // Can be combined with Blob inside same solution.
    NoBlob = 0x02,
}
```

The fragment does a single thing, non-blob projects will be present even in
blob configurations, so that all the source is present. The rest must be done
in Sharpmake script files by setting `conf.IsBlobbed` and similar options:

```cs
[Configure(Blob.Blob)]
public virtual void ConfigureBlob(Configuration conf, Target target)
{
    conf.IsBlobbed = true;
    conf.ProjectName += "_Blob";
    conf.SolutionFolder = "Blob";
    conf.ProjectFileName += ".blob";
    conf.IncludeBlobbedSourceFiles = false;
}
```

The following properties can be used to override blobbing default behavior:
* `project.SourceFilesBlobExclude`: Files to exclude from blobs.
* `project.SourceFilesBlobExcludeRegex`: Regex to exclude files from blobs.
* `project.SourceFilesBlobExtension`: Extension of files to be put in blobs.

Work blob numbers can be set in the constructor with `BlobWorkFileCount`. The
normal blob count is automatically provided by `BlobSize`. The property
`BlobSizeOverflow` is used as a threshold to exceed that size when files are
still in the same folder. This approach makes the blobs more stable.


### File Inclusion and Exclusion
Sharpmake provides several utilities to exclude and include files easily in
projects and blobs. The possibility of using C# also comes handy.

A project typically comes with three types of properties:
* `Excludes`: Used to exclude otherwise included files from the project.
* `Includes`: Used to include otherwise excluded files from the project.
* `Filters`: Used to specify exactly what can be included in a project, for the files already included in the project.

Here's a list of available properties in the `Project` class:
* `project.SourceRootPath`: Root to get source files from.
* `project.AdditionalSourceRootPaths`: Additional paths inspected to find source files.
* `project.SourceFiles`: Source files themselves.
* `project.SourceFilesExtension`: Extensions of source files to be added to the project.
* `project.SourceFilesCompileExtension`: Extensions of source files to be compiled in the project.
* `project.SourceFilesFilters`: If specified, only files in this list can be included.
* `project.SourceFilesExclude`: Files to exclude from the project.
* `project.SourceFilesIncludeRegex`: Files matching `SourceFilesIncludeRegex` and `SourceFilesExtension` from the source directory will make `SourceFiles`.
* `project.SourceFilesFiltersRegex`: If specified, only files matching the patterns can be included.
* `project.SourceFilesExcludeRegex`: Source files that match this regex will be excluded from the build.
* `project.SourceFilesBuildExclude`: Source files to exclude from the build from `SourceFiles`.
* `project.ResourceFiles`: Resource files themselves.
* `project.ResourceFilesExtension`: Extension to add resource files automatically from `SourceRootPath`.

Additionally the following are available in the configuration:
* `conf.SourceFilesBuildExclude`: Files to exclude from the project.
* `conf.SourceFilesBuildExcludeRegex`: Patterns to exclude files from the project.
* `conf.PrecompSourceExclude`: Files not using the precompiled header.
* `conf.PrecompSourceExcludeExtension`: Patterns to specify files not using the precompiled header.

Using C# can also provide interesting flexibility. For example, this is code
from the project base class on Osborn in `Configure()`, forcing suffixes like
*_win32.cpp* and folders like */xenon/somefile.cpp* to be excluded from some
configurations automatically:

```cs
var excludedFileSuffixes = new List<string>();
var excludedFolders = new List<string>();
if (target.Platform != Platform.X360)
{
    excludedFileSuffixes.Add("xenon");
    excludedFolders.Add("xenon");
}
if (target.Platform != Platform.Ps3)
{
    excludedFileSuffixes.Add("ps3");
    excludedFolders.Add("ps3");
}
if (target.Platform != Platform.win32)
{
    excludedFileSuffixes.Add("win32");
    excludedFolders.Add("win32");
}
if (target.Platform != Platform.win64)
{
    excludedFileSuffixes.Add("win64");
    excludedFolders.Add("win64");
}
conf.SourceFilesBuildExcludeRegex.Add(@"\.*_(" + string.Join("|", excludedFileSuffixes.ToArray()) + @")\.cpp$");
conf.SourceFilesBuildExcludeRegex.Add(@"\.*\\(" + string.Join("|", excludedFolders.ToArray()) + @")\\");
```


### Ordering String Values
Sharpmake sorts include paths, library paths and libraries, making things more
deterministic and readable, especially considering Sharpmake is fully
multi-threaded using a thread pool. However, it is likely to sometime need to
enforce some order for these things. To fulfill that needs, some Sharpmake
fields are using the `OrderableStrings` type instead of `Strings`, allowing to
optionally supply an integer prevalent in sorting. By default, the integer
value is 0. Negative values will be put first and positive values last. For
example the following can be specified to make these 2 include paths first
after the sort:

```cs
conf.IncludePaths.Add(@"[project.RootPath]\gameengine\audio", -2);
conf.IncludePaths.Add(@"[project.RootPath]\gameengine\renderer", -1);
```

Any integer value can used. For libraries, some are deduced from the
`TargetFilePath`:

```cs
[Sharpmake.Export]
public class SomeProject : Sharpmake.Project
{
    // ...

    [Configure()]
    public void Configure(Configuration conf, Target target)
    {

        // ...

        conf.TargetFileOrderNumber = 1000;  // Put the project last, it has compiled STL symbols that will clash with good ones from game engine.
    }

    // ...

}
```


### Filtering Targets Added in Base Class
It's common to make a base class for projects where targets are added. Instead
of calling the base class constructor differently, it is also possible to call
`AddFragmentMask` instead to filter the targets that should be used:

```cs
[Sharpmake.Generate]
public class LevelEditor : CommonProject
{

    // ...

    public LevelEditor()
    {
        // only in toolmode
        AddFragmentMask(Mode.Tool);

        // ...

    }

    // ...

}
```


### Limited Dependencies
By default, Sharpmake will make sure a project inherits from a dependency
everything needed to use it: other dependencies, used libraries, used include
paths, etc. In some extreme rare situations where this behavior is not wanted,
it is possible to specify exactly what to inherit from a dependency.

The `DependencySetting` enum contains flags for different use cases to specify
precisely what is wanted:

```cs
// InheritFromDependenciesDependencies to get all files to copy
conf.AddPrivateDependency<GameEngineDll>(target, DependencySetting.OnlyDependencyInSolution | DependencySetting.InheritFromDependenciesDependencies);
```

In the specific case of a static library with prebuild event that **must** be
executed before it's inclusion in subsequent project, use
`DependencySetting.ForcedDependencyInSolution`. Otherwise, it is recommended
to use the default option to optimize the compilation process:

```cs
conf.AddPublicDependency<StaticLibraryWithPrebuildEvent>(target, DependencySetting.ForcedDependencyInSolution);
```


### Preferences
Sharpmake has natural support for user preferences. Currently, a per-user
preference file, a *user.sharpmake.cs* file feature, has been developed for
Assassin's Creed, but the feature has been developed completely in
*.sharpmake.cs* files. In the future, we should investigate moving that
feature directly into to Sharpmake, at least as an option.

Already, features like Perforce integration are completely optional. Many
preferences turn out to be pipeline-specific. Like other solutions generating
everything offline and not submitting to Perforce, it allows user preferences
to affect the content of generated Visual C++ project files and solutions. In
the case of solutions, preferences are more likely to influence the number of
solutions generated, by creating solution files dedicated to programmer
targets. For projects, preferences are more likely to affect compiler
optimizations and Perforce integration.



## .NET Support
-------------------------------------------------------------------------------
In addition to generating C++ projects, Sharpmake also supports project
generation for C# and C++/CLI.


### C++/CLI Support
To use C++/CLI, instead of setting the `OutputType` to `Exe`, `Lib` or `Dll`,
use the .NET versions:

```cs
public override void ConfigureAll(Configuration conf, Target target)
{
    base.ConfigureAll(conf, target);
    conf.Output = Configuration.OutputType.DotNetConsoleApp;
}
```

The enumeration of all project types can be found in
*Project.Configuration.cs* in Sharpmake's source code, and looks like this:

```cs
public enum OutputType
{
    Exe,
    Lib,
    Dll,
    DotNetConsoleApp,
    DotNetClassLibrary,
    DotNetWindowsApp,
    None,
}
```


### C# Support
To use the C# version of Sharpmake, use the `CSharpProject` and
`CSharpSolution` base classes when writing your Sharpmake scripts.

> **Tip**: To help having the correct project folder structure, create a new `Project`
>          and then write your sharpmake file.

> **Warning**: To permit retro-compatibility, these classes are derived from
>              their C++ equivalent. That is the reason why `CSharpProject`s
>              have fields like `Blobs`, even though C# projects have no need
>              for blobbing.

#### C# *Hello, World!*

1. Create the *Hello, World!* project.

Create a C# source file with some "Hello, World!" code in it for our sample.

```cs
using System;
 
namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

2. Create the Sharpmake script.

Create the project generation script. Let's call it *hello.sharpmake.cs*. It
will create the solution and the project for this example.

```cs
using Sharpmake;
 
namespace CSharpHelloWorld
{
    [Sharpmake.Generate]
    public class HelloWorld : CSharpProject
    {
        public HelloWorld()
        {
            RootPath = @"[project.SharpmakeCsPath]\codebase\";
 
            AddTargets(new Target(
            Platform.anycpu,
            DevEnv.vs2010,
            Optimization.Debug | Optimization.Release,
            OutputType.Dll,
            DotNetFramework.v4));
 
            // This Path will be used to get all SourceFiles in this Folder and all subFolders
            SourceRootPath = @"[project.RootPath]\[project.Name]\source";
        }
        [Configure()]
        public virtual void ConfigureAll(Configuration conf, Target target)
        {
            conf.ProjectFileName = "[project.Name].[target.DevEnv].[target.Framework]";
            conf.ProjectPath = @"[project.RootPath]\[project.Name]";
        }
    }
 
    [Sharpmake.Generate]
    public class HelloWorldSolution : CSharpSolution
    {
        public HelloWorldSolution()
        {
            AddTargets(new Target(
                Platform.anycpu,
                DevEnv.vs2010,
                Optimization.Debug | Optimization.Release,
                OutputType.Dll,
                DotNetFramework.v4));
        }
 
        [Configure()]
        public void ConfigureAll(Configuration conf, Target target)
        {
            conf.SolutionFileName = string.Format("{0}.{1}.{2}", Name, "[target.DevEnv]", "[target.Framework]");
 
            conf.SolutionPath = @"[solution.SharpmakeCsPath]\codebase\";
 
            conf.AddProject<HelloWorld>(target);
        }
 
        [Sharpmake.Main]
        public static void SharpmakeMain(Sharpmake.Arguments arguments)
        {
            arguments.Generate<HelloWorldSolution>();
        }
    }
}
```

3. [Launch Sharpmake](#launch-sharpmake) as you would normally do for a C++
   project.

#### References
##### Project References
Adding project references works just like it does with C++ projects, with the
`Configuration.AddPrivateDependency<...>(target)` and
`Configuration.AddPublicDependency<...>(target)` methods.

```cs
public override void ConfigureAll(Configuration conf, Target target)
{

    //...

    conf.AddPrivateDependency<Libraries.Ubisoft_Core>(target);

    //...

}
```

##### .NET References
.NET references refers to any reference that you would add with the
*Project->Add Reference* command in Visual Studio, using the .NET tab.

![Visual Studio's Add .NET Reference Dialog](docs/img/AddDotNetRef.png)

```cs
public override void ConfigureAll(Configuration conf, Target target)
{

    //...

    conf.ReferencesByName.AddRange(new Strings(
        "System",
        "System.Core",
        "System.Xml.Linq",
        "System.Data.DataSetExtensions",
        "System.Data",
        "System.Xml"));

    //...

}
```

> **Careful**: In Visual Studio, new projects come with default references:
>    * System
>    * System.Core
>    * System.Data
>    * System.Data.DataSetExtensions
>    * System.Xml
>    * System.Xml.Linq
>
> On the other hand, when Sharpmake generates a .NET project, it will *not*
> put these references unless you tell it to, so you must specify those
> references if you need them.

##### External References
![Visual Studio's Add External Reference Dialog](/docs/img/AddExternalReference.png)

When there is a need for an external reference, use the
`configuration.AddReferenceByPath(@"path")` method.

```cs
[Configure()]
public override void ConfigureAll(Configuration conf, Target target)
{

    //...

    conf.ReferencesByPath.Add(@"[project.RootPath]\external\Divelements\SandDock for WPF\Divelements.SandDock.dll");

    //...

}
```


### Copy Local
`CopyLocal` can be defined per Reference Type using the
`Project.DependenciesCopyLocal` field.

The field represents the combination of `Project.DependenciesCopyLocalTypes`
flags.

```cs
[Flags]
public enum DependenciesCopyLocalTypes
{
    None = 0x00,
    ProjectReferences = 0x01,
    DotNetReferences = 0x02,
    ExternalReferences = 0x04,
}
```

The default settings for each type of reference are as follows:

| Reference Type      | Default value |
|---------------------|---------------|
| Project references  | `true`        |
| .NET references     | `false`       |
| External references | `true`        |

Example:

```cs
public AppsProject()
{
    //Making sure we have ProjectReferences and Externals for apps to run in outputFolder
    DependenciesCopyLocal = DependenciesCopyLocal |
        (DependenciesCopyLocalTypes.ProjectReferences | DependenciesCopyLocalTypes.ExternalReferences);
}
```


### Build Actions
![Visual Studio File Properties](/docs/img/ResourceBuildAction.png)
In Sharpmake most of the Action Builds are generated by the extension and the
path of files. For example, source files will have Compile Build Action, XAML
files will have *Page Build Action*.

Some Build Actions can't be determined only with those parameters, build
actions such as [Resource](#resource), [Content](#content) and [None](#none)
need either a path or extension match to identify the right file association.

#### Resource
Files with this build action will end in the assembly or executable.

By default, files in `"[project.RootPath]\Resources\"` are associated with
this build action. Use the `CSharpProject.ResourcesPath` field to change the
ResourcesRoot folder.

```cs
public class ProjectName : CSharpProject
{
     public ProjectName()
     {

         //...

         ResourcesPath = @"[project.RootPath]\images\";

         //...

     }
}
```

In addition to the resources folder it is also possible to use the file
extension as in C++ with the Project
([File Inclusion and Exclusion](#file-inclusion-and-exclusion)).

> **Warning**: Files embedded in the *.resx* file must not be added to
>              resource file list since it will create a copy in the output
>              assembly.

#### Content
Files with this build action will end in the output folder.

By default, files in `"[project.RootPath]\Content\"` have this build
action. Use the `CSharpProject.ContentPath` field to change the `ContentRoot`
folder.

```cs
public class ProjectName : CSharpProject
{
     public ProjectName()
     {

         //...

         ContentPath = @"[project.RootPath]\HtmlReferences\";

         //...

     }
}
```

It is also possible to add additional content files, with or without the
*Always Copy*, by using the `CSharpProject.AdditionalContent` and
`CSharpProject.AdditionalContentAlwaysCopy` properties. For example:

```cs
[Sharpmake.Generate]
class ExampleAdditionalContent : LibrariesProject
{
    public ExampleAdditionalContent()
    {

        // ...

        AdditionalContent.Add("additional-content-default-copy.txt");
        AdditionalContentAlwaysCopy.Add("additional-content-always-copy.txt");

        // ...

    }

    // ...

}
```

#### None
Files with this build action will not be copied to the output folder. Files
using the extensions listed below have this build action by default.

| Extension     | File type                                 |
|---------------|-------------------------------------------|
| *.config*     | C# project XML configuration files.       |
| *.settings*   | .NET setting definition file.             |
| *.map*        | Debugging maps.                           |
| *.wsdl*       | Web service description language.         |
| *.datasource* | WCF service reference file.               |
| *.cd*         | Microsoft Visual Studio class diagram.    |
| *.doc*        | Microsoft Word document. (Legacy format.) |
| *.docx*       | Microsoft Word document.                  |

You can associate new file extensions to the *None* build action using the
`CSharpProject.NoneExtension`.

```cs
public class ProjectName : CSharpProject
{
     public ProjectName()
     {

         //...

         NoneExtension.Add(".xlsx"); //adding Excel files to the project for developers

         //...

     }

     // ...

}
```


### Namespace
In case the project's name does not match the desired default namespace, you
can assign the correct one with the `CSharpProject.RootNamespace`.

```cs
[Sharpmake.Generate]
class Ubisoft_Core : ExternalProject
{
    public Ubisoft_Core()
    {
        Name = "Ubisoft.Core";
        RootNamespace = "Ubisoft";

        //...

    }

    // ...

}
```


### Output File Name
In case where the project name isn't the same as the output file name wanted,
change the value of `CSharpProject.AssemblyName`.

```cs
[Sharpmake.Generate]
class Ubisoft_Core_Interop : ExternalProject
{
    public Ubisoft_Core_Interop()
    {

        //...

        Name = "Ubisoft.Core";
        AssemblyName = "Ubisoft.Core.Interop";

        //...

    }

    // ...

}
```


### WebReferenceUrls
![Visual Studio Web References](/docs/img/WebReferences.png)

To add a Web reference to the project, create a new
`Sharpmake.WebReferenceUrl` instance and add it to the
`CSharpProject.WebReferenceUrls` list.

```cs
[Sharpmake.Generate]
class Ubisoft_Confluence : LibrariesProject
{
    public Ubisoft_Confluence()
    {
        Name = "Ubisoft.Confluence";
 
        WebReferenceUrls.Add(
            new WebReferenceUrl
            {
                Name = @"...an-url...",
                UrlBehavior = "Dynamic",
                RelPath = @"Web References\atlassian.confluence\",
                UpdateFromURL = @"...an-url...",
                CachedAppSettingsObjectName = "Settings",
                CachedSettingsPropName = "prop_map"
            });
    }

    //...

}
```
# Why Sharpmake?

In 2011, after evaluation of different solutions like Premake and CMake, the team of Assassin's Creed 3 decided to develop Sharpmake, a solution to generate .vcproj and .sln files.  Here's the list of needs from 2011:

> Needs:
> * Easy to add a new lib, should take no more than 5 min. We planned to split engine in many pieces so this point is the very important.
> * Way to define only once project options and reuse it.
> * Include file from directory, no need to merge project anymore
> * Only one tool for all platforms
> * Solution generation support
> * Custom target generation: to minimize project file size, assassin2.vcprog is 311000 line long... probably making VS to lag. Ex: AI programmers should be able to generate only project they work on (win tool release, x360 engine release) that’s it.
> * Separate settings file for all projects including third party. Ex: havoc setting contains export include, lib, path, etc.
> * Easy to debug
> * Easy to edit, no needs to know the knots of the system to change it.
> * Vs2010 support
> * Have common share section for general settings.
> 
> Nice to have:
> * Generate blob projects as well. Chisel will only need to move edit file to work blob.
> * Support many platform in the same project ( x32, x64, x360 and ps3 )
> * Support for C# solutions (and projects?)
> * Generate project for a sub set of files to use from SubmitAssistant.

After an evaluation of Premake and CMake (remember it was in their state in 2011), the conclusion was that developping Sharpmake was worth it on Assassin's Creed.

Premake and CMake have been used for years at Ubisoft and over the years different productions and products inside Ubisoft switched from them to Sharpmake.  This is typically not imposed at all, since Ubisoft is extremely bottom-up; it's even the opposite, for a lot of projects, using something external can be considered better (since maintained by more people).  For productions, Sharpmake became the natural choice for multiple reasons:
* Support for consoles, even those unannounced to public.
* Support to generate FastBuild .bff files.
* Most libraries already have .sharpmake.cs files made on another project.
* Fast generation.
* C# .csproj support.  Support for mixing with .vcxproj in same generated .sln.
* Both C++ and C# programmers are confortable editing .sharpmake.cs files.
* Intellisence and debugging for .sharpmake.cs files.

At the beginning of 2017, serious discussions were made inside Ubisoft to finally make Sharpmake open-source.  While legal discussions were made, a few developers improved Sharpmake to isolate platform implementation in single .dll files, easing isolation of platforms under NDA.  On September 22th 2017, Sharpmake was finally pushed on Github.

The reason we made Sharpmake open-source is because we still believe it is superior for our needs than any other open-source alternative.  That may not be always the case in the future, so we decided it would be better to let Sharpmake compete with alternatives outside Ubisoft.  The same way FastBuild was adopted outside Ubisoft after being mentionned at CppCon 2014, we think Sharpmake could be interesting outside Ubisoft as well, so it was presented in a lightning talk at CppCon 2017.

Sharpmake is shining with big C++ code bases that may be using C# and FastBuild and may be targetting video game consoles.  This is the context for many projects inside the game industry and we are curious to see how interesting it will make it outside Ubisoft.
========================================================================
    DYNAMIC LINK LIBRARY : CLRCPPProj Project Overview
========================================================================

AppWizard has created this CLRCPPProj DLL for you.  

This file contains a summary of what you will find in each of the files that
make up your CLRCPPProj application.

CLRCPPProj.vcxproj
    This is the main project file for VC++ projects generated using an Application Wizard. 
    It contains information about the version of Visual C++ that generated the file, and 
    information about the platforms, configurations, and project features selected with the
    Application Wizard.

CLRCPPProj.vcxproj.filters
    This is the filters file for VC++ projects generated using an Application Wizard. 
    It contains information about the association between the files in your project 
    and the filters. This association is used in the IDE to show grouping of files with
    similar extensions under a specific node (for e.g. ".cpp" files are associated with the
    "Source Files" filter).

CLRCPPProj.cpp
    This is the main DLL source file.

CLRCPPProj.h
    This file contains a class declaration.

AssemblyInfo.cpp
	Contains custom attributes for modifying assembly metadata.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" to indicate parts of the source code you
should add to or customize.

/////////////////////////////////////////////////////////////////////////////
Platforms
=========


Open Platforms
--------------
Sharpmake ships with the platform extension *Sharpmake.CommonPlatforms.dll*.
This is a .NET class library that contains everything you need to generate
Visual Studio solutions for C++, C#, and C++/CLI code for Windows. Sharpmake
also has support for generating Xcode and GNU Make-based projects for Mac and
Linux.


NDA Platforms
-------------
Sharpmake was originally designed with built-in support for generating
solutions for video game consoles, which are platforms under strict NDA and
private SDKs. In order release Sharpmake to the open-source community, we had
to strip support for those NDA platforms out of the code base and create an
extension mechanism that allows Ubisoft developers to plug these platforms
back in to compile code that depend on it.

We have pulled the code out simply to comply with our NDA. If you are an
authorized developper outside of Ubisoft and would like to try Sharpmake to
generate projects for one of the platforms listed below, please contact one of
the Sharpmake maintainers on the GitHub repository at
https://github.com/UbisoftInc/Sharpmake

* Sony PlayStation 3
* Sony PlayStation 4
* Microsoft Xbox 360
* Microsoft Xbox One
* Nintendo Wii
* Nintendo WiiU
* Nintendo Switch
* nVidia Shield


Platform References
-------------------
Platforms are shipped as ordinary .NET class libraries that are referenced into
Sharpmake script. Because scripts are standalone though, there is no csproj to
add that reference to. Instead, you specify a platform reference with the
`Sharpmake.Reference` module attribute:
```cs
    [module: Reference("<path-of-your-platform>.dll")]
```

Sharpmake will look for DLL files in the executable's directory, although a
relative path from the executable should work.

Please note that *Sharpmake.CommonPlatforms.dll* is always referenced, so
putting `[module: Reference("Sharpmake.CommonPlatforms.dll")]` in your scripts
is redundant.

There is no problem referencing platforms directly from scripts. The platform
system is designed to isolate Sharpmake itself from the platforms, not the
scripts.
