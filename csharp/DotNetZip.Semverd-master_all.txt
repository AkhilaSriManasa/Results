Software Licenses that apply to the DotNetZip library and tools

As DotNetZip includes work derived from other projects, you are required to comply with the terms and conditions for each of them. These licenses include BSD, Apache, and zlib.

To use the software, you must accept the licenses. If you do not accept the licenses, do not use the software.

Original intellectual property in DotNetZip is provided under the Ms-PL:
    
    Copyright (c) 2006 - 2011 Dino Chiesa 
    Copyright (c) 2006, 2007, 2008, 2009 Dino Chiesa and Microsoft Corporation. 
    
    Microsoft Public License (Ms-PL)
    
    This license governs use of the accompanying software, the DotNetZip library ("the software"). If you use the software, you accept this license. If you do not accept the license, do not use the software.
    
    1. Definitions
    
    The terms "reproduce," "reproduction," "derivative works," and "distribution" have the same meaning here as under U.S. copyright law.
    
    A "contribution" is the original software, or any additions or changes to the software.
    
    A "contributor" is any person that distributes its contribution under this license.
    
    "Licensed patents" are a contributor's patent claims that read directly on its contribution.
    
    2. Grant of Rights
    
    (A) Copyright Grant- Subject to the terms of this license, including the license conditions and limitations in section 3, each contributor grants you a non-exclusive, worldwide, royalty-free copyright license to reproduce its contribution, prepare derivative works of its contribution, and distribute its contribution or any derivative works that you create.
    
    (B) Patent Grant- Subject to the terms of this license, including the license conditions and limitations in section 3, each contributor grants you a non-exclusive, worldwide, royalty-free license under its licensed patents to make, have made, use, sell, offer for sale, import, and/or otherwise dispose of its contribution in the software or derivative works of the contribution in the software.
    
    3. Conditions and Limitations
    
    (A) No Trademark License- This license does not grant you rights to use any contributors' name, logo, or trademarks.
    
    (B) If you bring a patent claim against any contributor over patents that you claim are infringed by the software, your patent license from such contributor to the software ends automatically.
    
    (C) If you distribute any portion of the software, you must retain all copyright, patent, trademark, and attribution notices that are present in the software.
    
    (D) If you distribute any portion of the software in source code form, you may do so only under this license by including a complete copy of this license with your distribution. If you distribute any portion of the software in compiled or object code form, you may only do so under a license that complies with this license.
    
    (E) The software is licensed "as-is." You bear the risk of using it. The contributors give no express warranties, guarantees or conditions. You may have additional consumer rights under your local laws which this license cannot change. To the extent permitted under your local laws, the contributors exclude the implied warranties of merchantability, fitness for a particular purpose and non-infringement. 

--------------------------------------------------------------

The managed ZLIB code included in Ionic.Zlib.dll and Ionic.Zip.dll is derived from jzlib.

jzlib ( https://github.com/ymnk/jzlib ) is provided under a BSD-style (3 clause)

    Copyright (c) 2000,2001,2002,2003 ymnk, JCraft, Inc.

    Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    1.	Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    2.	Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
    3.	The names of the authors may not be used to endorse or promote products derived from this software without specific prior written permission.
    THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT, INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

--------------------------------------------------------------

The jzlib library, itself, is a re-implementation of ZLIB v1.1.3 in pure Java.

zlib is provided under the zlib license:

    Copyright (C) 1995-2004 Jean-loup Gailly and Mark Adler
    The ZLIB software is provided 'as-is', without any express or implied warranty.  In no event will the authors be held liable for any damages arising from the use of this software.
    Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:
    1.	The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required. 
    2.	Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software. 
    3.	This notice may not be removed or altered from any source distribution.
      Jean-loup Gailly      jloup@gzip.org   Mark Adler      madler@alumni.caltech.edu

--------------------------------------------------------------

The managed BZIP2 code included in Ionic.BZip2.dll and Ionic.Zip.dll is modified code, based on Java code in the Apache commons compress library.

Apache Commons Compress ( http://commons.apache.org/proper/commons-compress/ ) is provided under the Apache 2 license:
    Apache Commons Compress
    Copyright 2002-2014 The Apache Software Foundation

    Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements.  See the NOTICE file distributed with this work for additional information regarding copyright ownership.  The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.  You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the specific language governing permissions and limitations under the License.

Many thanks to Julian Seward for the original C implementation of BZip2 ( http://www.bzip.org/ ).





Introducing the DotNetZip Library and Tools
-------------------------------------------

## Maintainers wanted – ping @haf to talk

DotNetZip is the name of an open-source project that delivers a .NET
library for handling ZIP files, and some associated tools.

 - The library allows .NET programmers to build applications
   that read, create and modify ZIP files.

 - The tools are .NET programs that rely on the library, and can be used
   by anyone on any Windows machine to build or extract ZIP files.


## How to build?

`bundle && rake`

CI: https://ci.appveyor.com/project/haf/dotnetzip-semverd

Why DotNetZip?
---------------------------------

The Microsoft .NET Framework base class library lacks a good set of
built-in classes for creating and reading ZIP files, and Windows itself
lacks full-powered built-in ZIP tools.  DotNetZip fills those needs.

There are other ZIP libraries available, but some of them have licenses
that may be unfriendly, some of them are too hard to use or not powerful
enough, and some of them are too expensive (not free).  DotNetZip
provides one more alternative. The goals for this alternative:

 - easy to adopt - low cost (Free), and a friendly license
 - fully-featured
 - good performance - in speed and compression
 - easy to use.



DotNetZip background
---------------------------------

Many people seem to think, incorrectly, that the classes in the
System.IO.Compression namespace, like GZipStream or DeflateStream, can
create or read zip files. Not true.

The System.IO.Compression namespace, available starting with .NET v2.0
for the desktop Framework and v3.5 for the Compact Framework, includes
base class libraries supporting compression within streams - both the
Deflate and Gzip formats are supported. But these classes are not
directly useful for creating compressed ZIP archives.  GZIP is not
ZIP. Deflate is not ZIP.  The GZipStream in System.IO.Compression is
able to read and write GZIP streams, but that is not the same as reading
or writing a zip file.  Also, these classes deliver poor compression in
practice, especially with binary data, or previously-compressed data.


Yes, it is possible to read and write zip files, using the classes in
the .NET Framework.

  - You can do it with the System.IO.Packaging.ZipPackage class, added
    in .NET v3.0. Actually this class lets you create a package file,
    which is a zipfile with a particular internal structure. It includes
    a manifest and some other things.  But the interface is odd and
    confusing if all you want is a regular-old ZIP file.  Also, the
    classes in this namespace do not provide control for things like
    passwords, comments, AES encryption, ZIP64, Unicode, and so on.

  - You can also create and read zip files with the J# runtime. This
    also has its drawbacks.  First, J# is going out of support, or may
    be out of support now.  Second, the J# runtime is huge, and you have
    to swallow the whole thing, even if all you want is zip file
    capability.  Also, the J# runtime is based on the java.util.zip
    classes from Java v1.4, dating from 1998.  The runtime hasn't been
    updated in years and still includes bugs in zip file handling. It
    lacks support for AES, for ZIP64, and Unicode.  It is not accessible
    from COM. Finally, the zip classes in the J# runtime are decidedly
    un-dotnet.  There's no support for events, or enumerators to let you
    do things like For Each in VB, or foreach in C#. The interface is
    clunky. It does not feel like a .NET class library, because it isn't
    a .NET class library.  So for all those reasons, J# isn't ideal.

  - You can also rely on P/Invoke to the shell32.dll, and the
    ShellClass. This works in a limited fashion. The drawbacks here: it
    isn't documented.  It isn't a very intuitive or powerful programming
    interface.  There are no events, so embedding it into a Winforms app
    with a progress bar would be difficult.  Again it lacks an easy way
    to use or access many ZIP features, like encryption or ZIP64 or
    self-extracting archives.  Also, the shell32.dll is designed for use
    within Windows Explorer, and presumes a user interface.  In fact in
    some cases, calling into this DLL to perform a ZIP extraction can
    display a dialog box, so it may not be suitable for use within
    server or "headless" applications.


There are other libraries out there than do zip files for .NET.  But
there are compromises with each one.  Some are commercial and expensive.
Some are slow.  Some are complicated to use.  Some of these options lack
features.  Some of them have more than one of these drawbacks.

DotNetZip provides another option.  It's a very simple-to-use class
library that provides good ZIP file support.  Using this library, you
can write .NET applications that read and write zip-format files,
including files with passwords, Unicode filenames, ZIP64, AES
encryption, and comments.  The library also supports self-extracting
archives.  It is well documented and provides good performance.

Though DotNetZip is implemented in .NET and was originally intended to
provide a managed-code library for ZIP files, you can now use it library
from any COM environment, including Javascript, VBScript, VB6, VBA, PHP,
Perl, and others.  Using DotNetZip, you could generate an AES-encrypted
zip file from within the code of a macro running in MS-Excel, for example.

DotNetZip works with applications running on PCs with Windows.  There is a
version of this library available for the .NET Compact Framework, too.

I have not tested DotNetZip for use with Mono, but I've heard reports
that people use the binary releases with Mono successfully, without
change.


License
--------

This software is open source. It is released under the Microsoft Public
License of October 2006.  The use of the "Microsoft Public License" does
not mean it is licensed by Microsoft.  See the License.txt file for
details.

DotNetZip is derived in part from ZLIB, the C-language library by Mark
Adler and Jean-loup Gailly .  See the License.ZLIB.txt file included in
the DotNetZip download for details.



What is DotNetZip?  and How is it packaged?
---------------------------------------------

DotNetZip is primarily a managed library for dealing with ZIP files.

It is packaged as a DLL that your application must reference:
Ionic.Zip.dll.  In the "developer's kit" package, there is
documentation, code examples, and debug versions of the DLL.

The ZIP library depends on a set of supporting classes for doing
compression and decompression; these are exposed in other namespaces.

The classes in the ZIP library reside in these namespaces:

   namespace     interesting classes
   ------------------------------------------------------------
   Ionic.Zip     ZipFile, ZipEntry, ZipOutputStream, and
                 ZipInputStream.

   Ionic.Zlib    DeflateStream, GZipStream, ZlibStream

   Ionic.BZip2   BZip2InputStream, BZip2OutputStream

   Ionic.Crc     CRC32


If you want only ZLIB (raw compression and decompression, RFC 1950,
1951, and 1952), the ZLIB classes are packaged independently, in
Ionic.Zlib.dll.  Likewise, if you want to do BZIP2 compression, outside
the scope of a zip file, you can use the Ionic.BZip2.dll assembly.

If you want ZIP, or both ZIP and ZLIB, then your application should
depend soly on Ionic.Zip.dll; this assembly includes a superset of the
classes in Ionic.Zlib.dll and Ionic.BZip2.dll.

For each DLL, there is a version for the regular .NET Framework and
another for the Compact Framework.

DotNetZip also includes command-line and GUI tools for manipulating zip
files; these can be helpful to developers when building applications
that create or manipulate zip files. They also can be helpful as
end-user tools.

There are other downloads for DotNetZip - the source package, the
runtime-only package (DLLs and no helpfile or tools), the
documentation-only package, etc.




Using the Zip Class Library: The Basics
----------------------------------------

The examples here provide just the basics.

There are many other examples available: some are included in the source
package, some in the class reference documentation in the help file, and
others on the web.  Those examples provide many illustrate how to read
and write zip files, taking advantage of all the various features of zip
files exposed by the library.  For a full set of examples, your best bet
is to see the documentation. Here's a basic primer:

The main type you will use to fiddle with zip files is the ZipFile
class. Full name: Ionic.Zip.ZipFile.  You use this to create, read, or
update zip files.  There is also a ZipOutputStream class, which offers a
Stream metaphor, for those who want it. You should choose one or the
other for your application.

The simplest way to create a ZIP file in C# looks like this:

      using(ZipFile zip= new ZipFile())
      {
        zip.AddFile(filename);
        zip.Save(NameOfZipFileTocreate);
      }


Or in VB.NET, like this:

     Using zip As ZipFile = New ZipFile
         zip.AddFile(filename)
         zip.Save("MyZipFile.zip")
     End Using


The using clause is important; don't leave it out.


The simplest way to Extract all the entries from a zipfile looks
like this:

      using (ZipFile zip = ZipFile.Read(NameOfExistingZipFile))
      {
        zip.ExtractAll(args[1]);
      }

But you could also do something like this:

      using (ZipFile zip = ZipFile.Read(NameOfExistingZipFile))
      {
        foreach (ZipEntry e in zip)
        {
          e.Extract();
        }
      }


Or in VB, extraction would be like this:
     Using zip As ZipFile = ZipFile.Read(NameOfExistingZipFile)
         zip.ExtractAll
     End Using

Or this:
     Using zip As ZipFile = ZipFile.Read(NameOfExistingZipFile)
        Dim e As ZipEntry
        For Each e In zip
            e.Extract
        Next
     End Using


That covers the basics.

Notice that a using clause is always employed. DOn't forget this.  Don't
leave it off.  If you don't understand what it is, don't just skip it.
It's important.

There are a number of other options for using the class library.  For
example, you can read zip archives from streams, or you can create
(write) zip archives to streams, or you can extract into streams.  You
can apply passwords for weak encryption.  You can specify a code page
for the filenames and metadata of entries in an archive.  You can rename
entries in archives, and you can add or remove entries from archives.
You can set up save and read progress events. You can do LINQ queries on
the Entries collection.  Check the documentation for complete
information, or use Visual Studio's intellisense to explore some of the
properties and methods on the ZipFile class.

Another type you will use is ZipEntry. This represents a single entry -
either a file or a directory - within a ZipFile.  To add an entry to a
zip file, you call one of the AddEntry (or AddFile) methods on the
ZipFile class.  You never directly instantiate a ZipEntry type.  The
AddEntry/AddFile returns a ZipEntry type; you can then modify the
properties of the entry within the zip file, using that object.

For example, the following code adds a file as an entry into a ZipFile,
then renames the entry within the zip file:

      using(ZipFile zip= new ZipFile())
      {
        ZipEntry e = zip.AddFile(filename);
        e.FileName = "RenamedFile.txt";
        zip.Save(NameOfZipFileTocreate);
      }

Extracting a zip file that was created in this way will produce a file
called "RenamedFile.txt", regardless of the name of the file originally
added to the ZipFile.


As an alternative to using ZipFile type to create a zip file, you can
use the ZipOutputStream type to create zip files .  To do so, wrap it
around a stream, and write to it.

      using (var fs = File.Create(filename))
      {
        using(var s = new ZipOutputStream(fs))
        {
          s.PutNextEntry("entry1.txt");
          byte[] buffer = Encoding.ASCII.GetBytes("This is the content for entry #1.");
          s.Write(buffer, 0, buffer.Length);
        }
      }

Unlike the ZipFile class, the ZipOutputStream class can only create zip
files. It cannot read or update zip files.

If you want to read zip files using a streaming metaphor, you can use
ZipInputStream.  Think of ZipInputStream and ZipOutputStream as
alternatives to using ZipFile to manipulate zip files. The former is for
reading zip files; the latter is for writing them.



About Directory Paths
---------------------------------

One important note: the ZipFile.AddXxx methods add the file or
directory you specify, including the directory.  In other words,
logic like this:
    ZipFile zip = new ZipFile();
    zip.AddFile("c:\\a\\b\\c\\Hello.doc");
    zip.Save();

...will produce a zip archive that contains a single entry, or file, and
that file is stored with the relative directory information.  When you
extract that file from the zip, either using this Zip library or winzip
or the built-in zip support in Windows, or some other package, all those
directories will be created, and the file will be written into that
directory hierarchy.  At extraction time, if you were to extract that
file into a directory like c:\documents, then resulting file would be
named c:\documents\a\b\c\Hello.doc .

This is by design.

If you don't want that directory information in your archive,
then you need to use the overload of the AddFile() method that
allows you to explicitly specify the directory used for the entry
within the archive:

    zip.AddFile("c:\\a\\b\\c\\Hello.doc", "files");
    zip.Save();

This will create an archive with an entry called "files\Hello.doc",
which contains the contents of the on-disk file located at
c:\a\b\c\Hello.doc .

If you extract that file into a directory e:\documents, then the
resulting file will be called e:\documents\files\Hello.doc .

If you want no directory at all, specify "" (the empty string).
Specifying null (Nothing in VB) will include all the directory hierarchy
in the filename, as in the orginal case.




Pre-requisites to run Applications that use DotNetZip
-----------------------------------------------------

To run desktop applications that depend on DotNetZip:
 .NET Framework 4.0 or later





In more detail: The Zip Class Library
----------------------------------------------

The Zip class library is packaged as Ionic.Zip.DLL for the regular .NET
Framework and Ionic.Zip.CF.dll for the Compact Framework.  The Zip
library allows applications to create, read, and update zip files.

This library uses the DeflateStream class to compress file data,
and extends it to support reading and writing of the metadata -
the header, CRC, and other optional data - defined or required
by the zip format spec.

The key object in the class library is the ZipFile class.  Some of the
important methods on it:

      - AddItem - adds a file or a directory to a zip archive
      - AddDirectory - adds a directory to a zip archive
      - AddFile - adds a file to a zip archive
      - AddFiles - adds a set of files to a zip archive
      - Extract - extract a single element from a zip file
      - Read - static methods to read in an existing zipfile, for
               later extraction
      - Save - save a zipfile to disk

There is also a supporting class, called ZipEntry.  Applications can
enumerate the entries in a ZipFile, via ZipEntry.  There are other
supporting classes as well.  Typically, 80% of apps will use just the
ZipFile class, and will not need to directly interact with these other
classes. But they are there if you need them.

If you want to create or read zip files, the Ionic.Zip.DLL assembly is
the one you want.

When building applications that do zip stuff, you need to add a reference to
the Ionic.Zip.dll in Visual Studio, or specify Ionic.Zip.dll with the
/R flag on the CSC.exe or VB.exe compiler line.




In more detail: The Zlib Class Library
-----------------------------------------

The Zlib class library is packaged as Ionic.Zlib.DLL for the regular .NET
Framework and Ionic.Zlib.CF.dll for the Compact Framework.  The ZLIB
library does compression and decompression according to IETF RFC's 1950 (ZLIB),
1951 (Deflate), and 1952 (GZIP).

See http://www.ietf.org/rfc/rfc1950.txt
    http://www.ietf.org/rfc/rfc1951.txt
 and  http://www.ietf.org/rfc/rfc1952.txt


The key classes are:

  ZlibCodec - a class for Zlib (RFC1950/1951/1952) encoding and decoding.
        This low-level class does deflation and inflation on buffers.

  DeflateStream - patterned after the DeflateStream in
        System.IO.Compression, this class supports compression
        levels and other options.

  GZipStream - patterned after the GZipStream in
        System.IO.Compression, this class supports compression
        levels and other options.

  ZlibStream - similar to the GZipStream in
        System.IO.Compression, this class generates or consumes raw ZLIB
        streams.


If you want to simply compress (deflate) raw block or stream data, this
library is the thing you want.

When building applications that do zlib things, you need to add a reference to
the Ionic.Zlib.dll in Visual Studio, or specify Ionic.Zlib.dll with the
/R flag on the CSC.exe or VB.exe compiler line.

NB: If your application does both Zlib and Zip stuff, you need only add
a reference to Ionic.Zip.dll.  Ionic.Zip.dll includes all the capability
in Ionic.Zlib.dll.  Ionic.Zip.dll is a superset.



In more detail: The BZip2 Class Library
-----------------------------------------

The BZip2 class library is packaged as Ionic.BZip2.DLL for the regular .NET
Framework and Ionic.BZip2.CF.dll for the Compact Framework.  The BZip2
library does compression according to the bzip2 format created by
Julian Seward.
See http://en.wikipedia.org/wiki/Bzip2

NB: If your application does a combination of BZip2, Zlib and Zip stuff,
you need only add a reference to Ionic.Zip.dll.  Ionic.Zip.dll includes
all the capability in Ionic.Zlib.dll and Ionic.BZip2.dll.  Ionic.Zip.dll
is a superset.

If you try to link to more than one of these, you will get compiler
warnings about "duplicate types".



Namespace changes for DotNetZip
-----------------------------------------

The namespace for the DotNetZip classes is Ionic.Zip.
Classes are like:
  Ionic.Zip.ZipFile
  Ionic.Zip.ZipEntry
  Ionic.Zip.ZipException
  etc

(check the .chm file for the full list)

For the versions prior to v1.7, the namespace DotNetZip was Ionic.Utils.Zip.
The classes were like so:
  Ionic.Utils.Zip.ZipFile
  Ionic.Utils.Zip.ZipEntry
  etc

If you have code that depends on an older version of the library, with
classes in the Ionic.Utils.Zip namespace), a simple namespace
replacement will allow your code to compile against the new version of
the library.


In addition to the Zip capability, DotNetZip includes capability (new
for v1.7).  For Zlib, the classes are like this:
  Ionic.Zlib.DeflateStream
  Ionic.Zlib.ZlibStream
  Ionic.Zlib.ZlibCodec
  ...

(again, check the .chm file for the full list)

For v1.9.1.6, the CRC class moved from the Ionic.Zlib namespace to the
Ionic.Crc namespace.




Dependencies
---------------------------------

Originally, this library was designed to depend upon the built-in
System.IO.Compression.DeflateStream class for the compression.  This
proved to be less than satisfactory because the built-in compression
library did not support compression levels and also was not available on
.NET CF 2.0.

As of v1.7, the library includes a managed code version of zlib, the
library that produces RFC1950 and RFC1951 compressed streams.  Within
that version of zlib, there is also a DeflateStream class which is
similar to the built-in System.IO.Compression.DeflateStream, but more
flexible, and often more effective as well.




The Documentation
--------------------------------------------

There is a single set of developer reference documentation for all of
the DotNetZip library features, including Zip and Zlib stuff.  It is
packaged in two ways: As a .chm file, and as a Help Viewer 1.0 resource.
The latter is the new format suitable for viewing within VS2010.

If you only use the Zlib stuff, then you should focus on the doc in the
Ionic.Zlib namespace.  Likewise BZip2.  If you are building apps for
mobile devices running the Compact Framework, then ignore the pieces
that deal with SaveSelfExtractor() and AES.

Consult the help file for more specifics here.

In some cases, upon opening the .chm file for DotNetZip, the help
items tree loads, but the contents are empty. You may see an error:
"This program cannot display the webpage."  or, "Address is invalid."
If this happens, it's likely that you've encountered a problem with Windows
protection of files downloaded from less trusted locations. To work around
this, within Windows Explorer, right-click on the CHM file, select properties,
and Unblock it, using the button in lower part of properties window.

The help is also packaged in a format that you can integrate into Visual
Studio 2008, or Visual Studio 2010.  VS2008 requires MS Help 2.0, while
VS2010 requires a different, newer format, sometimes called MS Help 3,
and sometimes (confusingly) called "MS Help Viewer 1.0 format".

The DotNetZip "devkit" download includes help in all these formats.



The Zip Format
---------------------------------
The zip format is described by PKWare, at
  http://www.pkware.com/business_and_developers/developer/popups/appnote.txt

Every valid zipfile conforms to this specification.  For example, the
spec says that for each compressed file contained in the zip archive,
the zipfile contains a byte array of compressed data.  (The byte array
is something the DeflateStream class can produce directly.)  But the
zipfile also contains header and "directory" information - you might
call this "metadata".  In other words, the zipfile must contain a list
of all the compressed files in the archive. The zipfile also contains
CRC checksums, and can also contain comments, and other optional
attributes for each file.  These are things the DeflateStream class -
either the one included in the .NET Framework Class Library, or the one
embedded in this library - does not read or write.

Managing the metadata in a zip file is most of what DotNetZip does.


Which DLL to use?
--------------------------------
The binary releases of DotNetZip include multiple distinct DLLs or
assemblies.  Which one should you use?

The likely answer is:  use Ionic.Zip.dll.

That's the mainstream library, the full library, and it includes all the
capability.  If you have particular requirements, like you want a
smaller library, or you want to exclude the Self-Extracting stuff, or
you only want the ZLIB capability, then you may want to choose a
different assembly.

Here's a summary of the options.


Usage scenario                                 Reference this DLL
------------------------------------------------------------------
reading or writing Zip files                   Ionic.Zip.dll

raw block or stream compression, ZLIB, GZIP,   Ionic.Zlib.dll
   or DEFLATE

raw block or stream compression, BZIP2         Ionic.BZip2.dll

both raw compression as well as reading        Ionic.Zip.dll
   or writing Zip files

reading or writing Zip files, using desktop    Ionic.Zip.Reduced.dll
  .NET framework but never creating a
  self-extracting archive


Never reference both Ionic.Zlib.dll and Ionic.Zip.dll, or both
Ionic.BZip2.dll and Ionic.Zip.dll in the same application.  If your
application does both Zlib and Zip stuff, you need only add a reference
to Ionic.Zip.dll.  Ionic.Zip.dll includes all the capability in
Ionic.Zlib.dll and Ionic.BZip2.dll You always need to reference only a
single Ionic DLL, regardless whether you use Zlib or BZip2 or Zip or
some combination.




Self-Extracting Archive support
--------------------------------

The Self-Extracting Archive (SFX) support in the library allows you to
create a self-extracting zip archive.  An SFX is both a standard EXE
file *and* a ZIP file.  The exe contains boilerplate program logic to
unzip the embedded zip file.  When the user executes the SFX runs, the
boilerplate application logic just reads the zip content and
then unzips itself. You can open an SFX in WinZip and other zip tools,
as well, if you want to view it.

Running the SFX (unpacking from the SFX) requires the .NET Framework
installed on the machine, but does not require the DotNetZip library.

There are two versions of the SFX - one that presents a GUI form, and
another that runs as a console (command line) application.

NB: Creation of SFX is not supported in the Compact Framework version of
the library.

Also, there is no way, currently, to produce an SFX file that can run on
the .NET Compact Framework.




The Reduced ZIP library
--------------------------------

The full DotNetZip library is currently about 400k in size.  The SFX
(Self-Extracting Archive) support is responsible for more than half the
total size of the library.  Some deployments may wish to omit the SFX
support in order to get a smaller DLL. For that you can rely on the
Ionic.Zip.Reduced.dll.  It provides everything the normal library does,
except the SaveSelfExtractor() method on the ZipFile class.

For size comparisons...these approximate figures are for v1.9.1.6 of the
library:


#### Desktop Framework:
```
  assembly              ~size   comment
  -------------------------------------------------------
  Ionic.Zlib.dll         100k   {Deflate,GZip,Zlib}Stream and ZlibCodec

  Ionic.BZip2.dll         57k   BZip2{Input,Output}Stream

  Ionic.Zip.dll          460k   includes ZLIB and BZIP2 compression,
                                SFX, selector logic, WinZIP AES encryption,
                                and the ComHelper class

  Ionic.Zip.Reduced.dll  250k   includes everything in the main ZIP
                                library except SFX. (ability to save
                                Self-extracting archives)
```








Support
--------------------------------------------

There is no official support for this library.  I try to make a good
effort to answer questions and monitor the work items raised on the
project portal at:

    http://DotNetZip.codeplex.com.





About Intellectual Property
---------------------------------

I am no lawyer, but before using this library in your app, it
may be worth reviewing the various licenses.

The specification for the zip format, which PKWARE owns, includes a
paragraph that reads:

  PKWARE is committed to the interoperability and advancement of the
  .ZIP format.  PKWARE offers a free license for certain technological
  aspects described above under certain restrictions and conditions.
  However, the use or implementation in a product of certain technological
  aspects set forth in the current APPNOTE, including those with regard to
  strong encryption or patching, requires a license from PKWARE.  Please
  contact PKWARE with regard to acquiring a license.

Contact pkware at:  zipformat@pkware.com

This library does not do strong encryption as described by PKWare, nor
does it do patching.  But again... I am no lawyer.


This library uses a ZLIB implementation that is based on a conversion of
the jzlib project http://www.jcraft.com/jzlib/.  The license and
disclaimer required by the jzlib source license is referenced in the
relevant source files of DotNetZip, specifically in the sources for the
Zlib module.

This library uses a BZip2 implementation that is based on a conversion
of the bzip2 implementation in the Apache Commons compression library.
The Apache license is referenced in the relevant source files of
DotNetZip, specifically in the sources for the BZip2 module.




Limitations
---------------------------------

There are a few limitations to this library:

 It does not do strong encryption.

 The GUI tool for creating zips is functional but basic. This isn't a limitation
 of the library per se.

 ...and, I'm sure, many others

But it is a good basic library for reading and writing zipfiles
in .NET applications.




Building the Library
============================================

This section is mostly interesting to developers who will work on or
view the source code of DotNetZip, to extend or re-purpose it.  If you
only plan to use DotNetZip in applications of your own, you probably
don't need to concern yourself with the information that follows.





Pre-requisites to build DotNetZip
---------------------------------

.NET Framework 4.0 SDK or later
  -or-
Visual Studio 2010 or later

  -and-

ILMerge - a tool from Microsoft that combines
multiple managed assemblies into a single DLL or image.  It is in
similar in some respects to the lib tool in C toolkits.

You can get it here:
  http://www.microsoft.com/downloads/details.aspx?familyid=22914587-b4ad-4eae-87cf-b14ae6a939b0&displaylang=en





Building DotNetZip with the .NET SDK
-------------------------------------

To build the library using the .NET Framework SDK v4.0,

1. extract the contents of the source zip into a new directory.

2. be sure the .NET 4.0 SDK and runtime directories are on your
   path.

3. Modify the .csproj files in Zip and ZLIB and BZip2 to eliminate
   mention of the Ionic.pfx and Ionic.snk files.

   The various DLLs (Zip Partial, ZLIB, etc.) are signed with my private
   key.  You will want to remove the mention of the private key in the
   project files. I cannot distribute my private key, so don't ask me!
   That would be silly.  So you have to modify the project in order to
   build without the key.


4. open a CMD prompt and CD to the DotNetZip directory.


5. msbuild

   Be sure you are using the .NET 3.5 version of MSBuild.
   This builds the "Debug" version of the library.  To build the
   "Release" version, do this:

   msbuild /t:Release


6. to clean and rebuild, do
   msbuild /t:clean
   msbuild


7. There are two setup directories, which contain the projects necessary
   to build the MSI file.  Unfortunately msbuild does not include
   support for building setup projects (vdproj).  You need Visual Studio
   to build the setup directories.

   I am in the process of converting these from .vdproj to .wixproj, so
   they can be built from the command line using msbuild. .




Building DotNetZip with Visual Studio
-------------------------------------

To build DotNetZip using Visual Studio 2010,

1. Open the DotNetZip.sln file in VS2010.

2. If necessary, Remove the dependencies on Ionic.pfx and Ionic.snk.

   (References to these will have already been removed from the zipped
   source distributions, but if you get your source from the TFS server,
   then you will have to remove references to the keyfiles manually)

   The various DLLs (Zip, ZLIB, etc.) are signed with my (Dino
   Chiesa's) private key.  I do not distribute that key for anyone
   else's use.  If you build the DotNetZip library from source, You will
   want to remove the mention of the private key in the project files. I
   will not distribute my private key, that would be silly.  So don't
   ask me!

3. Press F6 to build everything.




The Project Structure and Build approach
----------------------------------------------------

The function here is grouped into three basic sets: Zip,
ZLIB/Deflate/GZIP, and BZip2.  The Zip group is a superset of the ZLIB
and BZIP2 groups.

Each group of functionality is packaged into various assemblies, one
assembly per "platform".  The platforms supported are: .NET (Desktop).

There is also a special "Zip Reduced" library, available only on the
Desktop platform; it is a reduced-function version of the regular
Desktop Framework zip library. It provides an option of using a smaller
library for those zip-handling applications that don't produce
Self-extracting archives.

In a previous guise, DotNetZip relied on the ILMerge tool to combine
distinct DLLs into a single package.  This is no longer the case.

Because the ZIP projects include the ZLIB and BZIP2 function, the
appropriate source modules for the ZLIB and Bzip2 are "linked" into each
of the ZIP projects (Desktop).




Regarding the missing Ionic.pfx and Ionic.snk files
-------------------------------------------------------------------------

The binary DLLs shipped in the codeplex project are signed by me, Dino
Chiesa.  This provides a "strong name" for the assembly, which itself
provides some assurance as to the integrity of the library, and also
allows it to be run within restricted sites, like apps running inside
web hosters.

For more on strong names, see this article:
http://msdn.microsoft.com/en-gb/magazine/cc163583.aspx

Signing is done automatically at build time in the Visual Studio project or in
the msbuild build.  There
is a .pfx file that holds the crypto stuff for signing the assembly, and
that pfx file is itself protected by a password. There is also an
Ionic.snk file which is referenced by the project, but which I do not
distribute.

People opening the project ask me: what's the password to this .pfx
file?  Where's the .snk file?

Here's the problem; those files contain my private key. if I give
everyone the password to the PFX file or the .snk file, then anyone can
go and build a modified Ionic.Zip.dll, and sign it with my key, and
apply any version number they like.  This means there could be multiple
distinct assemblies with the same signature.  This is obviously not
good.

Since I don't release the ability to sign DLLs with my key, the DLL
signed with my key is guaranteed to be produced by me only, which is in
fact the exact intent of code signing in .NET.

If anyone wants to modify the project and re-compile it, they have a
couple options:

  - sign the assembly themselves, using their own key.
  - produce a modified, unsigned assembly

In either case it is not the same as the assembly I am shipping,
therefore it should not be signed with the same key.

All clear?

As for those options above, here is some more detail:

  1. If you want a strong-named assembly, then create your own PFX file
     and .snk file and modify the appropriate projects to use those new
     files.

  2. If you don't need a strong-named assembly, then remove all the
     signing from the various projects.

In either case, you will need to modify the "Zip", BZip, and the "Zlib"
projects.




Building the Documentation
--------------------------------------------

The documentation files are built using the Sandcastle Helpfile Builder
tool, also available on CodePlex at http://www.codeplex.com/SHFB .  It
is built from in-code xml documentation, augmented with some additional
out-of-band html documentation.

If you want to build the help files yourself, you will need to have
Sandcastle from May 2008 (or later, I guess), and SHFB, from February
2009.  Both are free tools available from http://codeplex.com .  I think
you can get a package download of both of these by installing v1.9.3.0
of SHFB .

The helpfile projects are:

  HtmlHelp1.shfbproj - to build the .chm file
  MSHelp2.shfbproj - to build the MS Help 2.0 content
  HelpViewer.shfbproj - to build the MS Help Viewer 1.0 content

  (The MSHelp2 project is broken at the moment.)

To build the documentation in any of these formats, first build the "zip
Full DLL" project in the source (Ionic.Zip.dll), then run:

  msbuild   HtmlHelp1.shfbproj

    -or-

  msbuild   HelpViewer.shfbproj


The Help Viewer 1.0 content can be viewed in the help viewer that is
integrated into VS 2010, or in an alternative viewer, such as
H3Viewer.exe.  See http://mshcmigrate.helpmvp.com/viewer .




Examples
--------------------------------------------

The source solution also includes a number of example applications
showing how to use the DotNetZip library and all its features - creating
ZIPs, using Unicode, passwords, comments, streams, and so on.  Most of
these will be built when you build the solution.  Some of them do not -
you will need to build them independently.



Tests
--------------------------------------------

There are two source projects in the VS Solution that contain Unit
Tests: one for the zlib library, one for the bzip2 library, and another
for the Zip library.  If you develop any new tests for DotNetZip, I'd be
glad to look at them.






Origins
============================================

This library is mostly original code.

There is a GPL-licensed library called SharpZipLib that writes zip
files, it can be found at
http://www.sharpdevelop.net/OpenSource/SharpZipLib/Default.aspx

This library is not based on SharpZipLib.

I think there may be a Zip library shipped as part of the Mono
project.  This library is also not based on that.

Now that the Java class library is open source, there is at least one
open-source Java implementation for zip.  This implementation is not
based on a port of Sun's JDK code.

There is a zlib.net project from ComponentAce.com.  This library is not
based on that code.

This library is all new code, written by me, with these exceptions:

 -  the CRC32 class - see above for credit.
 -  the zlib library - see above for credit.
 -  the bzip2 compressor - see above for credit.


[Info-ZIP note, 20040528:  this file is based on PKWARE's appnote.txt of
 15 February 1996, taking into account PKWARE's revised appnote.txt
 version 6.2.0 of 26 April 2004.  It has been unofficially corrected
 and extended by Info-ZIP without explicit permission by PKWARE.
 Although Info-ZIP believes the information to be accurate and complete,
 it is provided under a disclaimer similar to the PKWARE disclaimer below,
 differing only in the substitution of "Info-ZIP" for "PKWARE".  In other
 words, use this information at your own risk, but we think it's correct.

 Specification info from PKWARE that was obviously wrong has been corrected
 silently (e.g. missing structure fields, wrong numbers).
 As of PKZIPW 2.50, two new incompatibilities have been introduced by PKWARE;
 they are noted below.  Note that the "NTFS tag" conflict is currently not
 real; PKZIPW 2.50 actually tags NTFS files as having come from a FAT
 file system, too.]

File:    APPNOTE.TXT - .ZIP File Format Specification
Version: 6.2.0 - NOTIFICATION OF CHANGE
Revised: 04/26/2004 [2004-05-28 Info-ZIP]
Copyright (c) 1989 - 2004 PKWARE Inc., All Rights Reserved.

I. Purpose
----------

This specification is intended to define a cross-platform,
interoperable file format.  Since its first publication
in 1989, PKWARE has remained committed to ensuring the
interoperability of the .ZIP file format through this
specification.  We trust that all .ZIP compatible vendors
and application developers that have adopted this format
will share and support this commitment.


II. Disclaimer
--------------

Although PKWARE will attempt to supply current and accurate
information relating to its file formats, algorithms, and the
subject programs, the possibility of error or omission can not
be eliminated. PKWARE therefore expressly disclaims any warranty
that the information contained in the associated materials relating
to the subject programs and/or the format of the files created or
accessed by the subject programs and/or the algorithms used by
the subject programs, or any other matter, is current, correct or
accurate as delivered.  Any risk of damage due to any possible
inaccurate information is assumed by the user of the information.
Furthermore, the information relating to the subject programs
and/or the file formats created or accessed by the subject
programs and/or the algorithms used by the subject programs is
subject to change without notice.

If the version of this file is marked as a NOTIFICATION OF CHANGE,
the content defines an Early Feature Specification (EFS) change
to the .ZIP file format that may be subject to modification prior
to publication of the Final Feature Specification (FFS).  This
document may also contain information on Planned Feature
Specifications (PFS) defining recognized future extensions.


III. Change Log
---------------

Version       Change Description                      Date
-------       ------------------                     ----------
5.2           -Single Password Symmetric Encryption  06/02/2003
               storage

6.1.0         -Smart Card compatibility              01/20/2004
              -Documentation on certificate storage

6.2.0         -Introduction of Central Directory     04/26/2004
               Encryption for encrypting metadata
              -Added OS/X to Version Made By values


IV. General Format of a .ZIP file
---------------------------------

  Files stored in arbitrary order.  Large .ZIP files can span multiple
  diskette media or be split into user-defined segment sizes.  [The
  minimum user-defined segment size for a split .ZIP file is 64K.
  (removed by PKWare 2003-06-01)]

  Overall .ZIP file format:

    [local file header 1]
    [file data 1]
    [data descriptor 1]
    .
    .
    .
    [local file header n]
    [file data n]
    [data descriptor n]
    [archive decryption header] (EFS)
    [archive extra data record] (EFS)
    [central directory]
    [zip64 end of central directory record]
    [zip64 end of central directory locator]
    [end of central directory record]


  A.  Local file header:

        local file header signature     4 bytes  (0x04034b50)
        version needed to extract       2 bytes
        general purpose bit flag        2 bytes
        compression method              2 bytes
        last mod file time              2 bytes
        last mod file date              2 bytes
        crc-32                          4 bytes
        compressed size                 4 bytes
        uncompressed size               4 bytes
        file name length                2 bytes
        extra field length              2 bytes

        file name (variable size)
        extra field (variable size)


  B.  File data

      Immediately following the local header for a file
      is the compressed or stored data for the file.
      The series of [local file header][file data][data
      descriptor] repeats for each file in the .ZIP archive.


  C.  Data descriptor:

      [Info-ZIP discrepancy:
       The Info-ZIP zip program starts the data descriptor with a 4-byte
       PK-style signature.  Despite the specification, none of the PKWARE
       programs supports the data descriptor.  PKZIP 4.0 -fix function
       (and PKZIPFIX 2.04) ignores the data descriptor info even when bit 3
       of the general purpose bit flag is set.
        data descriptor signature       4 bytes  (0x08074b50)
      ]
        crc-32                          4 bytes
        compressed size                 4 bytes
        uncompressed size               4 bytes

      This descriptor exists only if bit 3 of the general
      purpose bit flag is set (see below).  It is byte aligned
      and immediately follows the last byte of compressed data.
      This descriptor is used only when it was not possible to
      seek in the output .ZIP file, e.g., when the output .ZIP file
      was standard output or a non seekable device.  For Zip64 format
      archives, the compressed and uncompressed sizes are 8 bytes each.


  D.  Archive decryption header:  (EFS)

      The Archive Decryption Header is introduced in version 6.2
      of the ZIP format specification.  This record exists in support
      of the Central Directory Encryption Feature implemented as part of
      the Strong Encryption Specification as described in this document.
      When the Central Directory Structure is encrypted, this decryption
      header will precede the encrypted data segment.  The encrypted
      data segment will consist of the Archive extra data record (if
      present) and the encrypted Central Directory Structure data.
      The format of this data record is identical to the Decryption
      header record preceding compressed file data.  If the central
      directory structure is encrypted, the location of the start of
      this data record is determined using the Start of Central Directory
      field in the Zip64 End of Central Directory record.  Refer to the
      section on the Strong Encryption Specification for information
      on the fields used in the Archive Decryption Header record.


  E.  Archive extra data record: (EFS)

        archive extra data signature    4 bytes  (0x08064b50)
        extra field length              4 bytes
        extra field data                (variable size)

      The Archive Extra Data Record is introduced in version 6.2
      of the ZIP format specification.  This record exists in support
      of the Central Directory Encryption Feature implemented as part of
      the Strong Encryption Specification as described in this document.
      When present, this record immediately precedes the central
      directory data structure.  The size of this data record will be
      included in the Size of the Central Directory field in the
      End of Central Directory record.  If the central directory structure
      is compressed, but not encrypted, the location of the start of
      this data record is determined using the Start of Central Directory
      field in the Zip64 End of Central Directory record.


  F.  Central directory structure:

      [file header 1]
      .
      .
      .
      [file header n]
      [digital signature]

      File header:

        central file header signature   4 bytes  (0x02014b50)
        version made by                 2 bytes
        version needed to extract       2 bytes
        general purpose bit flag        2 bytes
        compression method              2 bytes
        last mod file time              2 bytes
        last mod file date              2 bytes
        crc-32                          4 bytes
        compressed size                 4 bytes
        uncompressed size               4 bytes
        file name length                2 bytes
        extra field length              2 bytes
        file comment length             2 bytes
        disk number start               2 bytes
        internal file attributes        2 bytes
        external file attributes        4 bytes
        relative offset of local header 4 bytes

        file name (variable size)
        extra field (variable size)
        file comment (variable size)

      Digital signature:

        header signature                4 bytes  (0x05054b50)
        size of data                    2 bytes
        signature data (variable size)

      With the introduction of the Central Directory Encryption
      feature in version 6.2 of this specification, the Central
      Directory Structure may be stored both compressed and encrypted.
      Although not required, it is assumed when encrypting the
      Central Directory Structure, that it will be compressed
      for greater storage efficiency.  Information on the
      Central Directory Encryption feature can be found in the section
      describing the Strong Encryption Specification. The Digital
      Signature record will be neither compressed nor encrypted.


  G.  Zip64 end of central directory record

        zip64 end of central dir
        signature                       4 bytes  (0x06064b50)
        size of zip64 end of central
        directory record                8 bytes
        version made by                 2 bytes
        version needed to extract       2 bytes
        number of this disk             4 bytes
        number of the disk with the
        start of the central directory  4 bytes
        total number of entries in the
        central directory on this disk  8 bytes
        total number of entries in the
        central directory               8 bytes
        size of the central directory   8 bytes
        offset of start of central
        directory with respect to
        the starting disk number        8 bytes
        zip64 extensible data sector    (variable size)

        The above record structure defines Version 1 of the
        Zip64 end of central directory record. Version 1 was
        implemented in versions of this specification preceding
        6.2 in support of the ZIP64(tm) large file feature. The
        introduction of the Central Directory Encryption feature
        implemented in version 6.2 as part of the Strong Encryption
        Specification defines Version 2 of this record structure.
        Refer to the section describing the Strong Encryption
        Specification for details on the version 2 format for
        this record.


  H.  Zip64 end of central directory locator

        zip64 end of central dir locator
        signature                       4 bytes  (0x07064b50)
        number of the disk with the
        start of the zip64 end of
        central directory               4 bytes
        relative offset of the zip64
        end of central directory record 8 bytes
        total number of disks           4 bytes


  I.  End of central directory record:

        end of central dir signature    4 bytes  (0x06054b50)
        number of this disk             2 bytes
        number of the disk with the
        start of the central directory  2 bytes
        total number of entries in the
        central directory on this disk  2 bytes
        total number of entries in
        the central directory           2 bytes
        size of the central directory   4 bytes
        offset of start of central
        directory with respect to
        the starting disk number        4 bytes
        .ZIP file comment length        2 bytes
        .ZIP file comment       (variable size)


  J.  Explanation of fields:

      version made by (2 bytes)

          [PKWARE describes "OS made by" now (since 1998) as follows:
          The upper byte indicates the compatibility of the file
          attribute information.  If the external file attributes
          are compatible with MS-DOS and can be read by PKZIP for
          DOS version 2.04g then this value will be zero.  If these
          attributes are not compatible, then this value will
          identify the host system on which the attributes are
          compatible.]
          The upper byte indicates the host system (OS) for the
          file.  Software can use this information to determine
          the line record format for text files etc.  The current
          mappings are:

          0 - FAT file system (DOS, OS/2, NT)      + PKWARE 2.50+ VFAT, NTFS
          1 - Amiga
          2 - OpenVMS
          3 - Unix
          4 - VM/CMS
          5 - Atari ST
          6 - HPFS file system (OS/2, NT 3.x)
          7 - Macintosh
          8 - Z-System
          9 - CP/M
          ---------------------------------------------------------------------
               PKWARE assignment             | Info-ZIP assignment
          -----------------------------------|---------------------------------
          10 - Windows NTFS                  | TOPS-20
               (since PKZIPW 2.50, but       | (assigned Oct-1992,
                not used by any PKWARE prog) |  no longer used)
          11 - MVS                           | NTFS file system (WinNT)
                                             | (actively used by Info-ZIP's
                                             |  Zip for NT since Sep-1993)
          12 - VSE                           | SMS/QDOS
          ---------------------------------------------------------------------
          13 - Acorn RISC OS
          14 - VFAT file system (Win95, NT)     [Info-ZIP reservation, unused]
          15 - MVS [PKWARE describes this assignment as "alternate MVS"]
          16 - BeOS (BeBox or PowerMac)
          17 - Tandem
          18 - OS/400 (IBM)                  | THEOS
          19 - OS/X (Darwin)
          20 thru 29 - unused
          30 - AtheOS/Syllable
          31 thru 255 - unused

          The lower byte indicates the ZIP specification version
          (the version of this document) supported by the software
          used to encode the file.  The value/10 indicates the major
          version number, and the value mod 10 is the minor version
          number.

      version needed to extract (2 bytes)

          The minimum supported ZIP specification version needed to
          extract the file, mapped as above.  This value is based on
          the specific format features a ZIP program must support to
          be able to extract the file.  If multiple features are
          applied to a file, the minimum version should be set to the
          feature having the highest value. New features or feature
          changes affecting the published format specification will be
          implemented using higher version numbers than the last
          published value to avoid conflict.

          Current minimum feature versions are as defined below:

          1.0 - Default value
          1.1 - File is a volume label
          2.0 - File is a folder (directory)
          2.0 - File is compressed using Deflate compression
          2.0 - File is encrypted using traditional PKWARE encryption
          2.1 - File is compressed using Deflate64(tm)
          2.5 - File is compressed using PKWARE DCL Implode
          2.7 - File is a patch data set
          4.5 - File uses ZIP64 format extensions
          4.6 - File is compressed using BZIP2 compression*
          5.0 - File is encrypted using DES
          5.0 - File is encrypted using 3DES
          5.0 - File is encrypted using original RC2 encryption
          5.0 - File is encrypted using RC4 encryption
          5.1 - File is encrypted using AES encryption
          5.1 - File is encrypted using corrected RC2 encryption**
          5.2 - File is encrypted using corrected RC2-64 encryption**
          6.1 - File is encrypted using non-OAEP key wrapping***
          6.2 - Central directory encryption


          * Early 7.x (pre-7.2) versions of PKZIP incorrectly set the
          version needed to extract for BZIP2 compression to be 50
          when it should have been 46.

          ** Refer to the section on Strong Encryption Specification
          for additional information regarding RC2 corrections.

          *** Certificate encryption using non-OAEP key wrapping is the
          intended mode of operation for all versions beginning with 6.1.
          Support for OAEP key wrapping should only be used for
          backward compatibility when sending ZIP files to be opened by
          versions of PKZIP older than 6.1 (5.0 or 6.0).

          When using ZIP64 extensions, the corresponding value in the
          Zip64 end of central directory record should also be set.
          This field currently supports only the value 45 to indicate
          ZIP64 extensions are present.

      general purpose bit flag: (2 bytes)

          Bit 0: If set, indicates that the file is encrypted.

          (For Method 6 - Imploding)
          Bit 1: If the compression method used was type 6,
                 Imploding, then this bit, if set, indicates
                 an 8K sliding dictionary was used.  If clear,
                 then a 4K sliding dictionary was used.
          Bit 2: If the compression method used was type 6,
                 Imploding, then this bit, if set, indicates
                 3 Shannon-Fano trees were used to encode the
                 sliding dictionary output.  If clear, then 2
                 Shannon-Fano trees were used.

          (For Methods 8 and 9 - Deflating)
          Bit 2  Bit 1
            0      0    Normal (-en) compression option was used.
            0      1    Maximum (-exx/-ex) compression option was used.
            1      0    Fast (-ef) compression option was used.
            1      1    Super Fast (-es) compression option was used.

          Note:  Bits 1 and 2 are undefined if the compression
                 method is any other.

          Bit 3: If this bit is set, the fields crc-32, compressed
                 size and uncompressed size are set to zero in the
                 local header.  The correct values are put in the
                 data descriptor immediately following the compressed
                 data.  (Note: PKZIP version 2.04g for DOS only
                 recognizes this bit for method 8 compression, newer
                 versions of PKZIP recognize this bit for any
                 compression method.)
                [Info-ZIP note: This bit was introduced by PKZIP 2.04 for
                 DOS. In general, this feature can only be reliably used
                 together with compression methods that allow intrinsic
                 detection of the "end-of-compressed-data" condition. From
                 the set of compression methods described in this Zip archive
                 specification, only "deflate" and "bzip2" fulfill this
                 requirement.
                 Especially, the method STORED does not work!
                 The Info-ZIP tools recognize this bit regardless of the
                 compression method; but, they rely on correctly set
                 "compressed size" information in the central directory entry.]

          Bit 4: Reserved for use with method 8, for enhanced
                 deflating.

          Bit 5: If this bit is set, this indicates that the file is
                 compressed patched data.  (Note: Requires PKZIP
                 version 2.70 or greater)

          Bit 6: Strong encryption.  If this bit is set, you should
                 set the version needed to extract value to at least
                 50 and you must also set bit 0.  If AES encryption
                 is used, the version needed to extract value must
                 be at least 51.

          Bit 7: Currently unused.

          Bit 8: Currently unused.

          Bit 9: Currently unused.

          Bit 10: Currently unused.

          Bit 11: Currently unused.

          Bit 12: Reserved by PKWARE for enhanced compression.

          Bit 13: Used when encrypting the Central Directory to indicate
                  selected data values in the Local Header are masked to
                  hide their actual values.  See the section describing
                  the Strong Encryption Specification for details.

          Bit 14: Reserved by PKWARE.

          Bit 15: Reserved by PKWARE.

      compression method: (2 bytes)

          (see accompanying documentation for algorithm
          descriptions)

          0 - The file is stored (no compression)
          1 - The file is Shrunk
          2 - The file is Reduced with compression factor 1
          3 - The file is Reduced with compression factor 2
          4 - The file is Reduced with compression factor 3
          5 - The file is Reduced with compression factor 4
          6 - The file is Imploded
          7 - Reserved for Tokenizing compression algorithm
          8 - The file is Deflated
          9 - Enhanced Deflating using Deflate64(tm)
         10 - PKWARE Data Compression Library Imploding
         11 - Reserved by PKWARE
         12 - File is compressed using BZIP2 algorithm

      date and time fields: (2 bytes each)

          The date and time are encoded in standard MS-DOS format.
          If input came from standard input, the date and time are
          those at which compression was started for this data.
          If encrypting the central directory and general purpose bit
          flag 13 is set indicating masking, the value stored in the
          Local Header will be zero.

      CRC-32: (4 bytes)

          The CRC-32 algorithm was generously contributed by
          David Schwaderer and can be found in his excellent
          book "C Programmers Guide to NetBIOS" published by
          Howard W. Sams & Co. Inc.  The 'magic number' for
          the CRC is 0xdebb20e3.  The proper CRC pre and post
          conditioning is used, meaning that the CRC register
          is pre-conditioned with all ones (a starting value
          of 0xffffffff) and the value is post-conditioned by
          taking the one's complement of the CRC residual.
          If bit 3 of the general purpose flag is set, this
          field is set to zero in the local header and the correct
          value is put in the data descriptor and in the central
          directory.  If encrypting the central directory and general
          purpose bit flag 13 is set indicating masking, the value
          stored in the Local Header will be zero.

      compressed size: (4 bytes)
      uncompressed size: (4 bytes)

          The size of the file compressed and uncompressed,
          respectively.  If bit 3 of the general purpose bit flag
          is set, these fields are set to zero in the local header
          and the correct values are put in the data descriptor and
          in the central directory.  If an archive is in zip64 format
          and the value in this field is 0xFFFFFFFF, the size will be
          in the corresponding 8 byte zip64 extended information
          extra field.  If encrypting the central directory and general
          purpose bit flag 13 is set indicating masking, the value stored
          for the uncompressed size in the Local Header will be zero.

      file name length: (2 bytes)
      extra field length: (2 bytes)
      file comment length: (2 bytes)

          The length of the file name, extra field, and comment
          fields respectively.  The combined length of any
          directory record and these three fields should not
          generally exceed 65,535 bytes.  If input came from standard
          input, the file name length is set to zero.

         [Info-ZIP note:
          This feature is not yet supported by any PKWARE version of ZIP
          (at least not in PKZIP for DOS and PKZIP for Windows/WinNT).
          The Info-ZIP programs handle standard input differently:
          If input came from standard input, the filename is set to "-"
          (length one).]


      disk number start: (2 bytes)

          The number of the disk on which this file begins.  If an
          archive is in zip64 format and the value in this field is
          0xFFFF, the size will be in the corresponding 4 byte zip64
          extended information extra field.

      internal file attributes: (2 bytes)

          Bits 1 and 2 are reserved for use by PKWARE.

          The lowest bit of this field indicates, if set, that
          the file is apparently an ASCII or text file.  If not
          set, that the file apparently contains binary data.
          The remaining bits are unused in version 1.0.

          The 0x0002 bit of this field indicates, if set, that a
          4 byte variable record length control field precedes each
          logical record indicating the length of the record. This
          flag is independent of text control characters, and if used
          in conjunction with text data, includes any control
          characters in the total length of the record. This value is
          provided for mainframe data transfer support.

      external file attributes: (4 bytes)

          The mapping of the external attributes is
          host-system dependent (see 'version made by').  For
          MS-DOS, the low order byte is the MS-DOS directory
          attribute byte.  If input came from standard input, this
          field is set to zero.

      relative offset of local header: (4 bytes)

          This is the offset from the start of the first disk on
          which this file appears, to where the local header should
          be found.  If an archive is in zip64 format and the value
          in this field is 0xFFFFFFFF, the size will be in the
          corresponding 8 byte zip64 extended information extra field.

      file name: (Variable)

          The name of the file, with optional relative path.
          The path stored should not contain a drive or
          device letter, or a leading slash.  All slashes
          should be forward slashes '/' as opposed to
          backwards slashes '\' for compatibility with Amiga
          and Unix file systems etc.  If input came from standard
          input, there is no file name field.  If encrypting
          the central directory and general purpose bit flag 13 is set
          indicating masking, the file name stored in the Local Header
          will not be the actual file name.  A masking value consisting
          of a unique hexadecimal value will be stored.  This value will
          be sequentially incremented for each file in the archive.  See
          the section on the Strong Encryption Specification for details
          on retrieving the encrypted file name.
         [Info-ZIP discrepancy:
          If input came from standard input, the file name is set
          to "-" (without the quotes).
          As far as we know, the PKWARE specification for "input from
          stdin" is not supported by PKZIP/PKUNZIP for DOS, OS/2, Windows
          Windows NT.]

      extra field: (Variable)

          This is for expansion.  If additional information
          needs to be stored for special needs or for specific
          platforms, it should be stored here.  Earlier versions
          of the software can then safely skip this file, and
          find the next file or header.  This field will be 0
          length in version 1.0.

          In order to allow different programs and different types
          of information to be stored in the 'extra' field in .ZIP
          files, the following structure should be used for all
          programs storing data in this field:

          header1+data1 + header2+data2 . . .

          Each header should consist of:

            Header ID - 2 bytes
            Data Size - 2 bytes

          Note: all fields stored in Intel low-byte/high-byte order.

          The Header ID field indicates the type of data that is in
          the following data block.

          Header ID's of 0 thru 31 are reserved for use by PKWARE.
          The remaining ID's can be used by third party vendors for
          proprietary usage.

          The current Header ID mappings defined by PKWARE are:

          0x0001        ZIP64 extended information extra field
          0x0007        AV Info
          0x0008        Reserved for future Unicode file name data (PFS)
          0x0009        OS/2 extended attributes      (also Info-ZIP)
          0x000a        NTFS (Win9x/WinNT FileTimes)
          0x000c        OpenVMS                       (also Info-ZIP)
          0x000d        Unix
          0x000e        Reserved for file stream and fork descriptors
          0x000f        Patch Descriptor
          0x0014        PKCS#7 Store for X.509 Certificates
          0x0015        X.509 Certificate ID and Signature for
                        individual file
          0x0016        X.509 Certificate ID for Central Directory
          0x0017        Strong Encryption Header
          0x0018        Record Management Controls
          0x0019        PKCS#7 Encryption Recipient Certificate List
          0x0065        IBM S/390 (Z390), AS/400 (I400) attributes
                        - uncompressed
          0x0066        Reserved for IBM S/390 (Z390), AS/400 (I400)
                        attributes - compressed

          The Header ID mappings defined by Info-ZIP and third parties are:

          0x07c8        Info-ZIP Macintosh (old, J. Lee)
          0x2605        ZipIt Macintosh (first version)
          0x2705        ZipIt Macintosh v 1.3.5 and newer (w/o full filename)
          0x2805        ZipIt Macintosh 1.3.5+
          0x334d        Info-ZIP Macintosh (new, D. Haase's 'Mac3' field)
          0x4154        Tandem NSK
          0x4341        Acorn/SparkFS (David Pilling)
          0x4453        Windows NT security descriptor (binary ACL)
          0x4704        VM/CMS
          0x470f        MVS
          0x4854        Theos, old inofficial port
          0x4b46        FWKCS MD5 (see below)
          0x4c41        OS/2 access control list (text ACL)
          0x4d49        Info-ZIP OpenVMS (obsolete)
          0x4d63        Macintosh SmartZIP, by Macro Bambini
          0x4f4c        Xceed original location extra field
          0x5356        AOS/VS (binary ACL)
          0x5455        extended timestamp
          0x554e        Xceed unicode extra field
          0x5855        Info-ZIP Unix (original; also OS/2, NT, etc.)
          0x6542        BeOS (BeBox, PowerMac, etc.)
          0x6854        Theos
          0x7441        AtheOS (AtheOS/Syllable attributes)
          0x756e        ASi Unix
          0x7855        Info-ZIP Unix (new)
          0xfb4a        SMS/QDOS

          Detailed descriptions of Extra Fields defined by third
          party mappings will be documented as information on
          these data structures is made available to PKWARE.
          PKWARE does not guarantee the accuracy of any published
          third party data.

          The Data Size field indicates the size of the following
          data block. Programs can use this value to skip to the
          next header block, passing over any data blocks that are
          not of interest.

          Note: As stated above, the size of the entire .ZIP file
                header, including the file name, comment, and extra
                field should not exceed 64K in size.

          In case two different programs should appropriate the same
          Header ID value, it is strongly recommended that each
          program place a unique signature of at least two bytes in
          size (and preferably 4 bytes or bigger) at the start of
          each data area.  Every program should verify that its
          unique signature is present, in addition to the Header ID
          value being correct, before assuming that it is a block of
          known type.

          In the following descriptions, note that "Short" means two bytes,
          "Long" means four bytes, and "Long-Long" means eight bytes,
          regardless of their native sizes.  Unless specifically noted, all
          integer fields should be interpreted as unsigned (non-negative)
          numbers.


         -ZIP64 Extended Information Extra Field (0x0001):
          ===============================================

          The following is the layout of the ZIP64 extended
          information "extra" block. If one of the size or
          offset fields in the Local or Central directory
          record is too small to hold the required data,
          a ZIP64 extended information record is created.
          The order of the fields in the ZIP64 extended
          information record is fixed, but the fields will
          only appear if the corresponding Local or Central
          directory record field is set to 0xFFFF or 0xFFFFFFFF.

          Note: all fields stored in Intel low-byte/high-byte order.

          Value      Size       Description
          -----      ----       -----------
  (ZIP64) 0x0001     2 bytes    Tag for this "extra" block type
          Size       2 bytes    Size of this "extra" block
          Original
          Size       8 bytes    Original uncompressed file size
          Compressed
          Size       8 bytes    Size of compressed data
          Relative Header
          Offset     8 bytes    Offset of local header record
          Disk Start
          Number     4 bytes    Number of the disk on which
                                this file starts

          This entry in the Local header must include BOTH original
          and compressed file sizes.


         -OS/2 Extended Attributes Extra Field (0x0009):
          =============================================

          The following is the layout of the OS/2 extended attributes "extra"
          block.  (Last Revision 19960922)

          Note: all fields stored in Intel low-byte/high-byte order.

          Local-header version:

          Value         Size        Description
          -----         ----        -----------
  (OS/2)  0x0009        Short       tag for this extra block type
          TSize         Short       total data size for this block
          BSize         Long        uncompressed EA data size
          CType         Short       compression type
          EACRC         Long        CRC value for uncompressed EA data
          (var.)        variable    compressed EA data

          Central-header version:

          Value         Size        Description
          -----         ----        -----------
  (OS/2)  0x0009        Short       tag for this extra block type
          TSize         Short       total data size for this block (4)
          BSize         Long        size of uncompressed local EA data

          The value of CType is interpreted according to the "compression
          method" section above; i.e., 0 for stored, 8 for deflated, etc.

          The OS/2 extended attribute structure (FEA2LIST) is
          compressed and then stored in its entirety within this
          structure.  There will only ever be one "block" of data in
          the variable-length field.


         -OS/2 Access Control List Extra Field:
          ====================================

          The following is the layout of the OS/2 ACL extra block.
          (Last Revision 19960922)

          Local-header version:

          Value         Size        Description
          -----         ----        -----------
  (ACL)   0x4c41        Short       tag for this extra block type ("AL")
          TSize         Short       total data size for this block
          BSize         Long        uncompressed ACL data size
          CType         Short       compression type
          EACRC         Long        CRC value for uncompressed ACL data
          (var.)        variable    compressed ACL data

          Central-header version:

          Value         Size        Description
          -----         ----        -----------
  (ACL)   0x4c41        Short       tag for this extra block type ("AL")
          TSize         Short       total data size for this block (4)
          BSize         Long        size of uncompressed local ACL data

          The value of CType is interpreted according to the "compression
          method" section above; i.e., 0 for stored, 8 for deflated, etc.

          The uncompressed ACL data consist of a text header of the form
          "ACL1:%hX,%hd\n", where the first field is the OS/2 ACCINFO acc_attr
          member and the second is acc_count, followed by acc_count strings
          of the form "%s,%hx\n", where the first field is acl_ugname (user
          group name) and the second acl_access.  This block type will be
          extended for other operating systems as needed.


         -Windows NT Security Descriptor Extra Field (0x4453):
          ===================================================

          The following is the layout of the NT Security Descriptor (another
          type of ACL) extra block.  (Last Revision 19960922)

          Local-header version:

          Value         Size        Description
          -----         ----        -----------
  (SD)    0x4453        Short       tag for this extra block type ("SD")
          TSize         Short       total data size for this block
          BSize         Long        uncompressed SD data size
          Version       Byte        version of uncompressed SD data format
          CType         Short       compression type
          EACRC         Long        CRC value for uncompressed SD data
          (var.)        variable    compressed SD data

          Central-header version:

          Value         Size        Description
          -----         ----        -----------
  (SD)    0x4453        Short       tag for this extra block type ("SD")
          TSize         Short       total data size for this block (4)
          BSize         Long        size of uncompressed local SD data

          The value of CType is interpreted according to the "compression
          method" section above; i.e., 0 for stored, 8 for deflated, etc.
          Version specifies how the compressed data are to be interpreted
          and allows for future expansion of this extra field type.  Currently
          only version 0 is defined.

          For version 0, the compressed data are to be interpreted as a single
          valid Windows NT SECURITY_DESCRIPTOR data structure, in self-relative
          format.


         -PKWARE Win95/WinNT Extra Field (0x000a):
          =======================================

          The following description covers PKWARE's "NTFS" attributes
          "extra" block, introduced with the release of PKZIP 2.50 for
          Windows. (Last Revision 20001118)

          (Note: At this time the Mtime, Atime and Ctime values may
          be used on any WIN32 system.)
         [Info-ZIP note: In the current implementations, this field has
          a fixed total data size of 32 bytes and is only stored as local
          extra field.]

          Value         Size        Description
          -----         ----        -----------
  (NTFS)  0x000a        Short       Tag for this "extra" block type
          TSize         Short       Total Data Size for this block
          Reserved      Long        for future use
          Tag1          Short       NTFS attribute tag value #1
          Size1         Short       Size of attribute #1, in bytes
          (var.)        SubSize1    Attribute #1 data
          .
          .
          .
          TagN          Short       NTFS attribute tag value #N
          SizeN         Short       Size of attribute #N, in bytes
          (var.)        SubSizeN    Attribute #N data

          For NTFS, values for Tag1 through TagN are as follows:
          (currently only one set of attributes is defined for NTFS)

          Tag        Size       Description
          -----      ----       -----------
          0x0001     2 bytes    Tag for attribute #1
          Size1      2 bytes    Size of attribute #1, in bytes (24)
          Mtime      8 bytes    64-bit NTFS file last modification time
          Atime      8 bytes    64-bit NTFS file last access time
          Ctime      8 bytes    64-bit NTFS file creation time

          The total length for this block is 28 bytes, resulting in a
          fixed size value of 32 for the TSize field of the NTFS block.

          The NTFS filetimes are 64-bit unsigned integers, stored in Intel
          (least significant byte first) byte order. They determine the
          number of 1.0E-07 seconds (1/10th microseconds!) past WinNT "epoch",
          which is "01-Jan-1601 00:00:00 UTC".


         -PKWARE OpenVMS Extra Field (0x000c):
          ===================================

          The following is the layout of PKWARE's OpenVMS attributes
          "extra" block.  (Last Revision 12/17/91)

          Note: all fields stored in Intel low-byte/high-byte order.

          Value         Size        Description
          -----         ----        -----------
  (VMS)   0x000c        Short       Tag for this "extra" block type
          TSize         Short       Total Data Size for this block
          CRC           Long        32-bit CRC for remainder of the block
          Tag1          Short       OpenVMS attribute tag value #1
          Size1         Short       Size of attribute #1, in bytes
          (var.)        Size1       Attribute #1 data
          .
          .
          .
          TagN          Short       OpenVMS attribute tage value #N
          SizeN         Short       Size of attribute #N, in bytes
          (var.)        SizeN       Attribute #N data

          Rules:

          1. There will be one or more of attributes present, which
             will each be preceded by the above TagX & SizeX values.
             These values are identical to the ATR$C_XXXX and
             ATR$S_XXXX constants which are defined in ATR.H under
             OpenVMS C.  Neither of these values will ever be zero.

          2. No word alignment or padding is performed.

          3. A well-behaved PKZIP/OpenVMS program should never produce
             more than one sub-block with the same TagX value.  Also,
             there will never be more than one "extra" block of type
             0x000c in a particular directory record.


         -Info-ZIP VMS Extra Field:
          ========================

          The following is the layout of Info-ZIP's VMS attributes extra
          block for VAX or Alpha AXP.  The local-header and central-header
          versions are identical.  (Last Revision 19960922)

          Value         Size        Description
          -----         ----        -----------
  (VMS2)  0x4d49        Short       tag for this extra block type ("JM")
          TSize         Short       total data size for this block
          ID            Long        block ID
          Flags         Short       info bytes
          BSize         Short       uncompressed block size
          Reserved      Long        (reserved)
          (var.)        variable    compressed VMS file-attributes block

          The block ID is one of the following unterminated strings:

                "VFAB"          struct FAB
                "VALL"          struct XABALL
                "VFHC"          struct XABFHC
                "VDAT"          struct XABDAT
                "VRDT"          struct XABRDT
                "VPRO"          struct XABPRO
                "VKEY"          struct XABKEY
                "VMSV"          version (e.g., "V6.1"; truncated at hyphen)
                "VNAM"          reserved

          The lower three bits of Flags indicate the compression method.  The
          currently defined methods are:

                0       stored (not compressed)
                1       simple "RLE"
                2       deflated

          The "RLE" method simply replaces zero-valued bytes with zero-valued
          bits and non-zero-valued bytes with a "1" bit followed by the byte
          value.

          The variable-length compressed data contains only the data corre-
          sponding to the indicated structure or string.  Typically multiple
          VMS2 extra fields are present (each with a unique block type).


         -Info-ZIP Macintosh Extra Field:
          ==============================

          The following is the layout of the (old) Info-ZIP resource-fork extra
          block for Macintosh.  The local-header and central-header versions
          are identical.  (Last Revision 19960922)

          Value         Size        Description
          -----         ----        -----------
  (Mac)   0x07c8        Short       tag for this extra block type
          TSize         Short       total data size for this block
          "JLEE"        beLong      extra-field signature
          FInfo         16 bytes    Macintosh FInfo structure
          CrDat         beLong      HParamBlockRec fileParam.ioFlCrDat
          MdDat         beLong      HParamBlockRec fileParam.ioFlMdDat
          Flags         beLong      info bits
          DirID         beLong      HParamBlockRec fileParam.ioDirID
          VolName       28 bytes    volume name (optional)

          All fields but the first two are in native Macintosh format
          (big-endian Motorola order, not little-endian Intel).  The least
          significant bit of Flags is 1 if the file is a data fork, 0 other-
          wise.  In addition, if this extra field is present, the filename
          has an extra 'd' or 'r' appended to indicate data fork or resource
          fork.  The 28-byte VolName field may be omitted.


         -ZipIt Macintosh Extra Field (long):
          ==================================

          The following is the layout of the ZipIt extra block for Macintosh.
          The local-header and central-header versions are identical.
          (Last Revision 19970130)

          Value         Size        Description
          -----         ----        -----------
  (Mac2)  0x2605        Short       tag for this extra block type
          TSize         Short       total data size for this block
          "ZPIT"        beLong      extra-field signature
          FnLen         Byte        length of FileName
          FileName      variable    full Macintosh filename
          FileType      Byte[4]     four-byte Mac file type string
          Creator       Byte[4]     four-byte Mac creator string


         -ZipIt Macintosh Extra Field (short, for files):
          ==============================================

          The following is the layout of a shortened variant of the
          ZipIt extra block for Macintosh (without "full name" entry).
          This variant is used by ZipIt 1.3.5 and newer for entries of
          files (not directories) that do not have a MacBinary encoded
          file.  The local-header and central-header versions are identical.
          (Last Revision 20030602)

          Value         Size        Description
          -----         ----        -----------
  (Mac2b) 0x2705        Short       tag for this extra block type
          TSize         Short       total data size for this block (min. 12)
          "ZPIT"        beLong      extra-field signature
          FileType      Byte[4]     four-byte Mac file type string
          Creator       Byte[4]     four-byte Mac creator string
          fdFlags       beShort     attributes from FInfo.frFlags,
                                    may be omitted
          0x0000        beShort     reserved, may be omitted


         -ZipIt Macintosh Extra Field (short, for directories):
          ====================================================

          The following is the layout of a shortened variant of the
          ZipIt extra block for Macintosh used only for directory
          entries. This variant is used by ZipIt 1.3.5 and newer to
          save some optional Mac-specific information about directories.
          The local-header and central-header versions are identical.

          Value         Size        Description
          -----         ----        -----------
  (Mac2c) 0x2805        Short       tag for this extra block type
          TSize         Short       total data size for this block (12)
          "ZPIT"        beLong      extra-field signature
          frFlags       beShort     attributes from DInfo.frFlags, may
                                    be omitted
          View          beShort     ZipIt view flag, may be omitted


          The View field specifies ZipIt-internal settings as follows:

          Bits of the Flags:
              bit 0           if set, the folder is shown expanded (open)
                              when the archive contents are viewed in ZipIt.
              bits 1-15       reserved, zero;


         -Info-ZIP Macintosh Extra Field (new):
          ====================================

          The following is the layout of the (new) Info-ZIP extra
          block for Macintosh, designed by Dirk Haase.
          All values are in little-endian.
          (Last Revision 19981005)

          Local-header version:

          Value         Size        Description
          -----         ----        -----------
  (Mac3)  0x334d        Short       tag for this extra block type ("M3")
          TSize         Short       total data size for this block
          BSize         Long        uncompressed finder attribute data size
          Flags         Short       info bits
          fdType        Byte[4]     Type of the File (4-byte string)
          fdCreator     Byte[4]     Creator of the File (4-byte string)
          (CType)       Short       compression type
          (CRC)         Long        CRC value for uncompressed MacOS data
          Attribs       variable    finder attribute data (see below)


          Central-header version:

          Value         Size        Description
          -----         ----        -----------
  (Mac3)  0x334d        Short       tag for this extra block type ("M3")
          TSize         Short       total data size for this block
          BSize         Long        uncompressed finder attribute data size
          Flags         Short       info bits
          fdType        Byte[4]     Type of the File (4-byte string)
          fdCreator     Byte[4]     Creator of the File (4-byte string)

          The third bit of Flags in both headers indicates whether
          the LOCAL extra field is uncompressed (and therefore whether CType
          and CRC are omitted):

          Bits of the Flags:
              bit 0           if set, file is a data fork; otherwise unset
              bit 1           if set, filename will be not changed
              bit 2           if set, Attribs is uncompressed (no CType, CRC)
              bit 3           if set, date and times are in 64 bit
                              if zero date and times are in 32 bit.
              bit 4           if set, timezone offsets fields for the native
                              Mac times are omitted (UTC support deactivated)
              bits 5-15       reserved;


          Attributes:

          Attribs is a Mac-specific block of data in little-endian format with
          the following structure (if compressed, uncompress it first):

          Value         Size        Description
          -----         ----        -----------
          fdFlags       Short       Finder Flags
          fdLocation.v  Short       Finder Icon Location
          fdLocation.h  Short       Finder Icon Location
          fdFldr        Short       Folder containing file

          FXInfo        16 bytes    Macintosh FXInfo structure
            FXInfo-Structure:
                fdIconID        Short
                fdUnused[3]     Short       unused but reserved 6 bytes
                fdScript        Byte        Script flag and number
                fdXFlags        Byte        More flag bits
                fdComment       Short       Comment ID
                fdPutAway       Long        Home Dir ID

          FVersNum      Byte        file version number
                                    may be not used by MacOS
          ACUser        Byte        directory access rights

          FlCrDat       ULong       date and time of creation
          FlMdDat       ULong       date and time of last modification
          FlBkDat       ULong       date and time of last backup
            These time numbers are original Mac FileTime values (local time!).
            Currently, date-time width is 32-bit, but future version may
            support be 64-bit times (see flags)

          CrGMTOffs     Long(signed!)   difference "local Creat. time - UTC"
          MdGMTOffs     Long(signed!)   difference "local Modif. time - UTC"
          BkGMTOffs     Long(signed!)   difference "local Backup time - UTC"
            These "local time - UTC" differences (stored in seconds) may be
            used to support timestamp adjustment after inter-timezone transfer.
            These fields are optional; bit 4 of the flags word controls their
            presence.

          Charset       Short       TextEncodingBase (Charset)
                                    valid for the following two fields

          FullPath      variable    Path of the current file.
                                    Zero terminated string (C-String)
                                    Currently coded in the native Charset.

          Comment       variable    Finder Comment of the current file.
                                    Zero terminated string (C-String)
                                    Currently coded in the native Charset.


         -SmartZIP Macintosh Extra Field:
          ====================================

          The following is the layout of the SmartZIP extra
          block for Macintosh, designed by Marco Bambini.

          Local-header version:

          Value         Size        Description
          -----         ----        -----------
          0x4d63        Short       tag for this extra block type ("cM")
          TSize         Short       total data size for this block (64)
          "dZip"        beLong      extra-field signature
          fdType        Byte[4]     Type of the File (4-byte string)
          fdCreator     Byte[4]     Creator of the File (4-byte string)
          fdFlags       beShort     Finder Flags
          fdLocation.v  beShort     Finder Icon Location
          fdLocation.h  beShort     Finder Icon Location
          fdFldr        beShort     Folder containing file
          CrDat         beLong      HParamBlockRec fileParam.ioFlCrDat
          MdDat         beLong      HParamBlockRec fileParam.ioFlMdDat
          frScroll.v    Byte        vertical pos. of folder's scroll bar
          fdScript      Byte        Script flag and number
          frScroll.h    Byte        horizontal pos. of folder's scroll bar
          fdXFlags      Byte        More flag bits
          FileName      Byte[32]    full Macintosh filename (pascal string)

          All fields but the first two are in native Macintosh format
          (big-endian Motorola order, not little-endian Intel).
          The extra field size is fixed to 64 bytes.
          The local-header and central-header versions are identical.


         -Acorn SparkFS Extra Field:
          =========================

          The following is the layout of David Pilling's SparkFS extra block
          for Acorn RISC OS.  The local-header and central-header versions are
          identical.  (Last Revision 19960922)

          Value         Size        Description
          -----         ----        -----------
  (Acorn) 0x4341        Short       tag for this extra block type ("AC")
          TSize         Short       total data size for this block (20)
          "ARC0"        Long        extra-field signature
          LoadAddr      Long        load address or file type
          ExecAddr      Long        exec address
          Attr          Long        file permissions
          Zero          Long        reserved; always zero

          The following bits of Attr are associated with the given file
          permissions:

                bit 0           user-writable ('W')
                bit 1           user-readable ('R')
                bit 2           reserved
                bit 3           locked ('L')
                bit 4           publicly writable ('w')
                bit 5           publicly readable ('r')
                bit 6           reserved
                bit 7           reserved


         -VM/CMS Extra Field:
          ==================

          The following is the layout of the file-attributes extra block for
          VM/CMS.  The local-header and central-header versions are
          identical.  (Last Revision 19960922)

          Value         Size        Description
          -----         ----        -----------
 (VM/CMS) 0x4704        Short       tag for this extra block type
          TSize         Short       total data size for this block
          flData        variable    file attributes data

          flData is an uncompressed fldata_t struct.


         -MVS Extra Field:
          ===============

          The following is the layout of the file-attributes extra block for
          MVS.  The local-header and central-header versions are identical.
          (Last Revision 19960922)

          Value         Size        Description
          -----         ----        -----------
  (MVS)   0x470f        Short       tag for this extra block type
          TSize         Short       total data size for this block
          flData        variable    file attributes data

          flData is an uncompressed fldata_t struct.


         -PKWARE Unix Extra Field (0x000d):
          ================================

          The following is the layout of PKWARE's Unix "extra" block.
          It was introduced with the release of PKZIP for Unix 2.50.
          Note: all fields are stored in Intel low-byte/high-byte order.
          (Last Revision 19980901)

          This field has a minimum data size of 12 bytes and is only stored
          as local extra field.

          Value         Size        Description
          -----         ----        -----------
 (Unix0)  0x000d        Short       Tag for this "extra" block type
          TSize         Short       Total Data Size for this block
          AcTime        Long        time of last access (UTC/GMT)
          ModTime       Long        time of last modification (UTC/GMT)
          UID           Short       Unix user ID
          GID           Short       Unix group ID
          (var)         variable    Variable length data field

          The variable length data field will contain file type
          specific data.  Currently the only values allowed are
          the original "linked to" file names for hard or symbolic
          links, and the major and minor device node numbers for
          character and block device nodes.  Since device nodes
          cannot be either symbolic or hard links, only one set of
          variable length data is stored.  Link files will have the
          name of the original file stored.  This name is NOT NULL
          terminated.  Its size can be determined by checking TSize -
          12.  Device entries will have eight bytes stored as two 4
          byte entries (in little-endian format).  The first entry
          will be the major device number, and the second the minor
          device number.

         [Info-ZIP note: The fixed part of this field has the same layout as
          Info-ZIP's abandoned "Unix1 timestamps & owner ID info" extra field;
          only the two tag bytes are different.]


         -PATCH Descriptor Extra Field (0x000f):
          =====================================

          The following is the layout of the Patch Descriptor "extra"
          block.

          Note: all fields stored in Intel low-byte/high-byte order.

          Value         Size        Description
          -----         ----        -----------
  (Patch) 0x000f        Short       Tag for this "extra" block type
          TSize         Short       Size of the total "extra" block
          Version       Short       Version of the descriptor
          Flags         Long        Actions and reactions (see below)
          OldSize       Long        Size of the file about to be patched
          OldCRC        Long        32-bit CRC of the file about to be patched
          NewSize       Long        Size of the resulting file
          NewCRC        Long        32-bit CRC of the resulting file


          Actions and reactions

          Bits          Description
          ----          ----------------
          0             Use for auto detection
          1             Treat as a self-patch
          2-3           RESERVED
          4-5           Action (see below)
          6-7           RESERVED
          8-9           Reaction (see below) to absent file
          10-11         Reaction (see below) to newer file
          12-13         Reaction (see below) to unknown file
          14-15         RESERVED
          16-31         RESERVED

          Actions

          Action       Value
          ------       -----
          none         0
          add          1
          delete       2
          patch        3

          Reactions

          Reaction     Value
          --------     -----
          ask          0
          skip         1
          ignore       2
          fail         3

          Patch support is provided by PKPatchMaker(tm) technology and is
          covered under U.S. Patents and Patents Pending.


         -PKCS#7 Store for X.509 Certificates (0x0014):
          ============================================

          This field contains information about each of the certificates
          files may be signed with.  When the Central Directory Encryption
          feature is enabled for a ZIP file, this record will appear in
          the Archive Extra Data Record, otherwise it will appear in the
          first central directory record and will be ignored in any
          other record.

          Note: all fields stored in Intel low-byte/high-byte order.

          Value     Size     Description
          -----     ----     -----------
  (Store) 0x0014    2 bytes  Tag for this "extra" block type
          TSize     2 bytes  Size of the store data
          SData     TSize    Data about the store

          SData
          Value     Size        Description
          -----     ----        -----------
          Version   2 bytes     Version number, 0x0001 for now
          StoreD    (variable)  Actual store data

          The StoreD member is suitable for passing as the pbData
          member of a CRYPT_DATA_BLOB to the CertOpenStore() function
          in Microsoft's CryptoAPI.  The SSize member above will be
          cbData + 6, where cbData is the cbData member of the same
          CRYPT_DATA_BLOB.  The encoding type to pass to
          CertOpenStore() should be
          PKCS_7_ANS_ENCODING | X509_ASN_ENCODING.


         -X.509 Certificate ID and Signature for individual file (0x0015):
          ===============================================================

          This field contains the information about which certificate in
          the PKCS#7 store was used to sign a particular file.  It also
          contains the signature data.  This field can appear multiple
          times, but can only appear once per certificate.

          Note: all fields stored in Intel low-byte/high-byte order.

          Value         Size        Description
          -----         ----        -----------
  (CID)   0x0015        2 bytes     Tag for this "extra" block type
          CSize         2 bytes     Size of Method
          Method        (variable)

          Method
          Value         Size        Description
          -----         ----        -----------
          Version       2 bytes     Version number, for now 0x0001
          AlgID         2 bytes     Algorithm ID used for signing
          IDSize        2 bytes     Size of Certificate ID data
          CertID        (variable)  Certificate ID data
          SigSize       2 bytes     Size of Signature data
          Sig           (variable)  Signature data

          CertID
          Value         Size        Description
          -----         ----        -----------
          Size1         4 bytes     Size of CertID, should be (IDSize - 4)
          Size1         4 bytes     A bug in version one causes this value
                                    to appear twice.
          IssSize       4 bytes     Issuer data size
          Issuer        (variable)  Issuer data
          SerSize       4 bytes     Serial Number size
          Serial        (variable)  Serial Number data

          The Issuer and IssSize members are suitable for creating a
          CRYPT_DATA_BLOB to be the Issuer member of a CERT_INFO
          struct. The Serial and SerSize members would be the
          SerialNumber member of the same CERT_INFO struct.  This
          struct would be used to find the certificate in the store
          the file was signed with.  Those structures are from the MS
          CryptoAPI.

          Sig and SigSize are the actual signature data and size
          generated by signing the file with the MS CryptoAPI using a
          hash created with the given AlgID.


         -X.509 Certificate ID and Signature for central directory (0x0016):
          =================================================================

          This field contains the information about which certificate in
          the PKCS#7 store was used to sign the central directory structure.
          When the Central Directory Encryption feature is enabled for a
          ZIP file, this record will appear in the Archive Extra Data Record,
          otherwise it will appear in the first central directory record,
          along with the store.  The data structure is the
          same as the CID, except that SigSize will be 0, and there
          will be no Sig member.

          This field is also kept after the last central directory
          record, as the signature data (ID 0x05054b50, it looks like
          a central directory record of a different type).  This
          second copy of the data is the Signature Data member of the
          record, and will have a SigSize that is non-zero, and will
          have Sig data.

          Note: all fields stored in Intel low-byte/high-byte order.

          Value     Size     Description
          -----     ----     -----------
  (CDID)  0x0016    2 bytes  Tag for this "extra" block type
          TSize     2 bytes  Size of data that follows
          TData     TSize    Data


         -Strong Encryption Header (0x0017) (EFS):
          ===============================

          Value     Size     Description
          -----     ----     -----------
          0x0017    2 bytes  Tag for this "extra" block type
          TSize     2 bytes  Size of data that follows
          Format    2 bytes  Format definition for this record
          AlgID     2 bytes  Encryption algorithm identifier
          Bitlen    2 bytes  Bit length of encryption key
          Flags     2 bytes  Processing flags
          CertData  TSize-8  Certificate decryption extra field data
                             (refer to the explanation for CertData
                              in the section describing the
                              Certificate Processing Method under
                              the Strong Encryption Specification)


         -Record Management Controls (0x0018):
          ===================================

          Value     Size     Description
          -----     ----     -----------
(Rec-CTL) 0x0018    2 bytes  Tag for this "extra" block type
          CSize     2 bytes  Size of total extra block data
          Tag1      2 bytes  Record control attribute 1
          Size1     2 bytes  Size of attribute 1, in bytes
          Data1     Size1    Attribute 1 data
            .
            .
            .
          TagN      2 bytes  Record control attribute N
          SizeN     2 bytes  Size of attribute N, in bytes
          DataN     SizeN    Attribute N data


         -PKCS#7 Encryption Recipient Certificate List (0x0019): (EFS)
          =====================================================

          This field contains the information about each of the certificates
          that files may be encrypted with. This field should only appear
          in the archive extra data record. This field is not required and
          serves only to aide archive modifications by preserving public
          encryption data. Individual security requirements may dictate
          that this data be omitted to deter information exposure.

          Note: all fields stored in Intel low-byte/high-byte order.

          Value     Size     Description
          -----     ----     -----------
 (CStore) 0x0019    2 bytes  Tag for this "extra" block type
          TSize     2 bytes  Size of the store data
          TData     TSize    Data about the store

          TData:

          Value     Size     Description
          -----     ----     -----------
          Version   2 bytes  Format version number - must 0x0001 at this time
          CStore    (var)    PKCS#7 data blob


         -MVS Extra Field (PKWARE, 0x0065):
          ================================

          The following is the layout of the MVS "extra" block.
          Note: Some fields are stored in Big Endian format.
          All text is in EBCDIC format unless otherwise specified.

          Value       Size          Description
          -----       ----          -----------
  (MVS)   0x0065      2 bytes       Tag for this "extra" block type
          TSize       2 bytes       Size for the following data block
          ID          4 bytes       EBCDIC "Z390" 0xE9F3F9F0 or
                                    "T4MV" for TargetFour
          (var)       TSize-4       Attribute data


         -OS/400 Extra Field (0x0065):
          ===========================

          The following is the layout of the OS/400 "extra" block.
          Note: Some fields are stored in Big Endian format.
          All text is in EBCDIC format unless otherwise specified.

          Value       Size          Description
          -----       ----          -----------
  (OS400) 0x0065      2 bytes       Tag for this "extra" block type
          TSize       2 bytes       Size for the following data block
          ID          4 bytes       EBCDIC "I400" 0xC9F4F0F0 or
                                    "T4MV" for TargetFour
          (var)       TSize-4       Attribute data


         -Extended Timestamp Extra Field:
          ==============================

          The following is the layout of the extended-timestamp extra block.
          (Last Revision 19970118)

          Local-header version:

          Value         Size        Description
          -----         ----        -----------
  (time)  0x5455        Short       tag for this extra block type ("UT")
          TSize         Short       total data size for this block
          Flags         Byte        info bits
          (ModTime)     Long        time of last modification (UTC/GMT)
          (AcTime)      Long        time of last access (UTC/GMT)
          (CrTime)      Long        time of original creation (UTC/GMT)

          Central-header version:

          Value         Size        Description
          -----         ----        -----------
  (time)  0x5455        Short       tag for this extra block type ("UT")
          TSize         Short       total data size for this block
          Flags         Byte        info bits (refers to local header!)
          (ModTime)     Long        time of last modification (UTC/GMT)

          The central-header extra field contains the modification time only,
          or no timestamp at all.  TSize is used to flag its presence or
          absence.  But note:

              If "Flags" indicates that Modtime is present in the local header
              field, it MUST be present in the central header field, too!
              This correspondence is required because the modification time
              value may be used to support trans-timezone freshening and
              updating operations with zip archives.

          The time values are in standard Unix signed-long format, indicating
          the number of seconds since 1 January 1970 00:00:00.  The times
          are relative to Coordinated Universal Time (UTC), also sometimes
          referred to as Greenwich Mean Time (GMT).  To convert to local time,
          the software must know the local timezone offset from UTC/GMT.

          The lower three bits of Flags in both headers indicate which time-
          stamps are present in the LOCAL extra field:

                bit 0           if set, modification time is present
                bit 1           if set, access time is present
                bit 2           if set, creation time is present
                bits 3-7        reserved for additional timestamps; not set

          Those times that are present will appear in the order indicated, but
          any combination of times may be omitted.  (Creation time may be
          present without access time, for example.)  TSize should equal
          (1 + 4*(number of set bits in Flags)), as the block is currently
          defined.  Other timestamps may be added in the future.


         -Info-ZIP Unix Extra Field (type 1):
          ==================================

          The following is the layout of the old Info-ZIP extra block for
          Unix.  It has been replaced by the extended-timestamp extra block
          (0x5455) and the Unix type 2 extra block (0x7855).
          (Last Revision 19970118)

          Local-header version:

          Value         Size        Description
          -----         ----        -----------
  (Unix1) 0x5855        Short       tag for this extra block type ("UX")
          TSize         Short       total data size for this block
          AcTime        Long        time of last access (UTC/GMT)
          ModTime       Long        time of last modification (UTC/GMT)
          UID           Short       Unix user ID (optional)
          GID           Short       Unix group ID (optional)

          Central-header version:

          Value         Size        Description
          -----         ----        -----------
  (Unix1) 0x5855        Short       tag for this extra block type ("UX")
          TSize         Short       total data size for this block
          AcTime        Long        time of last access (GMT/UTC)
          ModTime       Long        time of last modification (GMT/UTC)

          The file access and modification times are in standard Unix signed-
          long format, indicating the number of seconds since 1 January 1970
          00:00:00.  The times are relative to Coordinated Universal Time
          (UTC), also sometimes referred to as Greenwich Mean Time (GMT).  To
          convert to local time, the software must know the local timezone
          offset from UTC/GMT.  The modification time may be used by non-Unix
          systems to support inter-timezone freshening and updating of zip
          archives.

          The local-header extra block may optionally contain UID and GID
          info for the file.  The local-header TSize value is the only
          indication of this.  Note that Unix UIDs and GIDs are usually
          specific to a particular machine, and they generally require root
          access to restore.

          This extra field type is obsolete, but it has been in use since
          mid-1994.  Therefore future archiving software should continue to
          support it.  Some guidelines:

              An archive member should either contain the old "Unix1"
              extra field block or the new extra field types "time" and/or
              "Unix2".

              If both the old "Unix1" block type and one or both of the new
              block types "time" and "Unix2" are found, the "Unix1" block
              should be considered invalid and ignored.

              Unarchiving software should recognize both old and new extra
              field block types, but the info from new types overrides the
              old "Unix1" field.

              Archiving software should recognize "Unix1" extra fields for
              timestamp comparison but never create it for updated, freshened
              or new archive members.  When copying existing members to a new
              archive, any "Unix1" extra field blocks should be converted to
              the new "time" and/or "Unix2" types.


         -Info-ZIP Unix Extra Field (type 2):
          ==================================

          The following is the layout of the new Info-ZIP extra block for
          Unix.  (Last Revision 19960922)

          Local-header version:

          Value         Size        Description
          -----         ----        -----------
  (Unix2) 0x7855        Short       tag for this extra block type ("Ux")
          TSize         Short       total data size for this block (4)
          UID           Short       Unix user ID
          GID           Short       Unix group ID

          Central-header version:

          Value         Size        Description
          -----         ----        -----------
  (Unix2) 0x7855        Short       tag for this extra block type ("Ux")
          TSize         Short       total data size for this block (0)

          The data size of the central-header version is zero; it is used
          solely as a flag that UID/GID info is present in the local-header
          extra field.  If additional fields are ever added to the local
          version, the central version may be extended to indicate this.

          Note that Unix UIDs and GIDs are usually specific to a particular
          machine, and they generally require root access to restore.


         -ASi Unix Extra Field:
          ====================

          The following is the layout of the ASi extra block for Unix.  The
          local-header and central-header versions are identical.
          (Last Revision 19960916)

          Value         Size        Description
          -----         ----        -----------
  (Unix3) 0x756e        Short       tag for this extra block type ("nu")
          TSize         Short       total data size for this block
          CRC           Long        CRC-32 of the remaining data
          Mode          Short       file permissions
          SizDev        Long        symlink'd size OR major/minor dev num
          UID           Short       user ID
          GID           Short       group ID
          (var.)        variable    symbolic link filename

          Mode is the standard Unix st_mode field from struct stat, containing
          user/group/other permissions, setuid/setgid and symlink info, etc.

          If Mode indicates that this file is a symbolic link, SizDev is the
          size of the file to which the link points.  Otherwise, if the file
          is a device, SizDev contains the standard Unix st_rdev field from
          struct stat (includes the major and minor numbers of the device).
          SizDev is undefined in other cases.

          If Mode indicates that the file is a symbolic link, the final field
          will be the name of the file to which the link points.  The file-
          name length can be inferred from TSize.

          [Note that TSize may incorrectly refer to the data size not counting
           the CRC; i.e., it may be four bytes too small.]


         -BeOS Extra Field:
          ================

          The following is the layout of the file-attributes extra block for
          BeOS.  (Last Revision 19970531)

          Local-header version:

          Value         Size        Description
          -----         ----        -----------
  (BeOS)  0x6542        Short       tag for this extra block type ("Be")
          TSize         Short       total data size for this block
          BSize         Long        uncompressed file attribute data size
          Flags         Byte        info bits
          (CType)       Short       compression type
          (CRC)         Long        CRC value for uncompressed file attribs
          Attribs       variable    file attribute data

          Central-header version:

          Value         Size        Description
          -----         ----        -----------
  (BeOS)  0x6542        Short       tag for this extra block type ("Be")
          TSize         Short       total data size for this block (5)
          BSize         Long        size of uncompr. local EF block data
          Flags         Byte        info bits

          The least significant bit of Flags in both headers indicates whether
          the LOCAL extra field is uncompressed (and therefore whether CType
          and CRC are omitted):

                bit 0           if set, Attribs is uncompressed (no CType, CRC)
                bits 1-7        reserved; if set, assume error or unknown data

          Currently the only supported compression types are deflated (type 8)
          and stored (type 0); the latter is not used by Info-ZIP's Zip but is
          supported by UnZip.

          Attribs is a BeOS-specific block of data in big-endian format with
          the following structure (if compressed, uncompress it first):

              Value     Size        Description
              -----     ----        -----------
              Name      variable    attribute name (null-terminated string)
              Type      Long        attribute type (32-bit unsigned integer)
              Size      Long Long   data size for this sub-block (64 bits)
              Data      variable    attribute data

          The attribute structure is repeated for every attribute.  The Data
          field may contain anything--text, flags, bitmaps, etc.


         -AtheOS Extra Field:
          ==================

          The following is the layout of the file-attributes extra block for
          AtheOS.  This field is a very close spin-off from the BeOS e.f.
          The only differences are:
           - a new extra field signature
           - numeric field in the attributes data are stored in little-endian
             format ("i386" was initial hardware for AtheOS)
          (Last Revision 20040908)

          Local-header version:

          Value         Size        Description
          -----         ----        -----------
 (AtheOS) 0x7441        Short       tag for this extra block type ("At")
          TSize         Short       total data size for this block
          BSize         Long        uncompressed file attribute data size
          Flags         Byte        info bits
          (CType)       Short       compression type
          (CRC)         Long        CRC value for uncompressed file attribs
          Attribs       variable    file attribute data

          Central-header version:

          Value         Size        Description
          -----         ----        -----------
 (AtheOS) 0x7441        Short       tag for this extra block type ("At")
          TSize         Short       total data size for this block (5)
          BSize         Long        size of uncompr. local EF block data
          Flags         Byte        info bits

          The least significant bit of Flags in both headers indicates whether
          the LOCAL extra field is uncompressed (and therefore whether CType
          and CRC are omitted):

                bit 0           if set, Attribs is uncompressed (no CType, CRC)
                bits 1-7        reserved; if set, assume error or unknown data

          Currently the only supported compression types are deflated (type 8)
          and stored (type 0); the latter is not used by Info-ZIP's Zip but is
          supported by UnZip.

          Attribs is a AtheOS-specific block of data in little-endian format
          with the following structure (if compressed, uncompress it first):

              Value     Size        Description
              -----     ----        -----------
              Name      variable    attribute name (null-terminated string)
              Type      Long        attribute type (32-bit unsigned integer)
              Size      Long Long   data size for this sub-block (64 bits)
              Data      variable    attribute data

          The attribute structure is repeated for every attribute.  The Data
          field may contain anything--text, flags, bitmaps, etc.


         -SMS/QDOS Extra Field:
          ====================

          The following is the layout of the file-attributes extra block for
          SMS/QDOS.  The local-header and central-header versions are identical.
          (Last Revision 19960929)

          Value         Size        Description
          -----         ----        -----------
  (QDOS)  0xfb4a        Short       tag for this extra block type
          TSize         Short       total data size for this block
          LongID        Long        extra-field signature
          (ExtraID)     Long        additional signature/flag bytes
          QDirect       64 bytes    qdirect structure

          LongID may be "QZHD" or "QDOS".  In the latter case, ExtraID will
          be present.  Its first three bytes are "02\0"; the last byte is
          currently undefined.

          QDirect contains the file's uncompressed directory info (qdirect
          struct).  Its elements are in native (big-endian) format:

          d_length      beLong          file length
          d_access      byte            file access type
          d_type        byte            file type
          d_datalen     beLong          data length
          d_reserved    beLong          unused
          d_szname      beShort         size of filename
          d_name        36 bytes        filename
          d_update      beLong          time of last update
          d_refdate     beLong          file version number
          d_backup      beLong          time of last backup (archive date)


         -AOS/VS Extra Field:
          ==================

          The following is the layout of the extra block for Data General
          AOS/VS.  The local-header and central-header versions are identical.
          (Last Revision 19961125)

          Value         Size        Description
          -----         ----        -----------
  (AOSVS) 0x5356        Short       tag for this extra block type ("VS")
          TSize         Short       total data size for this block
          "FCI\0"       Long        extra-field signature
          Version       Byte        version of AOS/VS extra block (10 = 1.0)
          Fstat         variable    fstat packet
          AclBuf        variable    raw ACL data ($MXACL bytes)

          Fstat contains the file's uncompressed fstat packet, which is one of
          the following:

                normal fstat packet             (P_FSTAT struct)
                DIR/CPD fstat packet            (P_FSTAT_DIR struct)
                unit (device) fstat packet      (P_FSTAT_UNIT struct)
                IPC file fstat packet           (P_FSTAT_IPC struct)

          AclBuf contains the raw ACL data; its length is $MXACL.


         -Tandem NSK Extra Field:
          ======================

          The following is the layout of the file-attributes extra block for
          Tandem NSK.  The local-header and central-header versions are
          identical.  (Last Revision 19981221)

          Value         Size        Description
          -----         ----        -----------
  (TA)    0x4154        Short       tag for this extra block type ("TA")
          TSize         Short       total data size for this block (20)
          NSKattrs      20 Bytes    NSK attributes


         -THEOS Extra Field:
          =================

          The following is the layout of the file-attributes extra block for
          Theos.  The local-header and central-header versions are identical.
          (Last Revision 19990206)

          Value         Size        Description
          -----         ----        -----------
  (Theos) 0x6854        Short       'Th' signature
          size          Short       size of extra block
          flags         Byte        reserved for future use
          filesize      Long        file size
          fileorg       Byte        type of file (see below)
          keylen        Short       key length for indexed and keyed files,
                                    data segment size for 16 bits programs
          reclen        Short       record length for indexed,keyed and direct,
                                    text segment size for 16 bits programs
          filegrow      Byte        growing factor for indexed,keyed and direct
          protect       Byte        protections (see below)
          reserved      Short       reserved for future use

            File types
            ==========

            0x80  library (keyed access list of files)
            0x40  directory
            0x10  stream file
            0x08  direct file
            0x04  keyed file
            0x02  indexed file
            0x0e  reserved
            0x01  16 bits real mode program (obsolete)
            0x21  16 bits protected mode program
            0x41  32 bits protected mode program

            Protection codes
            ================

            User protection
            ---------------
            0x01  non readable
            0x02  non writable
            0x04  non executable
            0x08  non erasable

            Other protection
            ----------------
            0x10  non readable
            0x20  non writable
            0x40  non executable Theos before 4.0
            0x40  modified Theos 4.x
            0x80  not hidden


         -THEOS old inofficial Extra Field:
          ================================

          The following is the layout of an inoffical former version of a
          Theos file-attributes extra blocks.  This layout was never published
          and is no longer created. However, UnZip can optionally support it
          when compiling with the option flag OLD_THEOS_EXTRA defined.
          Both the local-header and central-header versions are identical.
          (Last Revision 19990206)

          Value         Size        Description
          -----         ----        -----------
  (THS0)  0x4854        Short       'TH' signature
          size          Short       size of extra block
          flags         Short       reserved for future use
          filesize      Long        file size
          reclen        Short       record length for indexed,keyed and direct,
                                    text segment size for 16 bits programs
          keylen        Short       key length for indexed and keyed files,
                                    data segment size for 16 bits programs
          filegrow      Byte        growing factor for indexed,keyed and direct
          reserved      3 Bytes     reserved for future use


         -FWKCS MD5 Extra Field (0x4b46):
          ==============================

          The FWKCS Contents_Signature System, used in automatically
          identifying files independent of filename, optionally adds
          and uses an extra field to support the rapid creation of
          an enhanced contents_signature.
          There is no local-header version; the following applies
          only to the central header.  (Last Revision 19961207)

          Central-header version:

          Value         Size        Description
          -----         ----        -----------
  (MD5)   0x4b46        Short       tag for this extra block type ("FK")
          TSize         Short       total data size for this block (19)
          "MD5"         3 bytes     extra-field signature
          MD5hash       16 bytes    128-bit MD5 hash of uncompressed data
                                    (low byte first)

          When FWKCS revises a .ZIP file central directory to add
          this extra field for a file, it also replaces the
          central directory entry for that file's uncompressed
          file length with a measured value.

          FWKCS provides an option to strip this extra field, if
          present, from a .ZIP file central directory. In adding
          this extra field, FWKCS preserves .ZIP file Authenticity
          Verification; if stripping this extra field, FWKCS
          preserves all versions of AV through PKZIP version 2.04g.

          FWKCS, and FWKCS Contents_Signature System, are
          trademarks of Frederick W. Kantor.

          (1) R. Rivest, RFC1321.TXT, MIT Laboratory for Computer
              Science and RSA Data Security, Inc., April 1992.
              ll.76-77: "The MD5 algorithm is being placed in the
              public domain for review and possible adoption as a
              standard."


      file comment: (Variable)

          The comment for this file.

      number of this disk: (2 bytes)

          The number of this disk, which contains central
          directory end record.  If an archive is in zip64 format
          and the value in this field is 0xFFFF, the size will
          be in the corresponding 4 byte zip64 end of central
          directory field.

      number of the disk with the start of the central directory: (2 bytes)

          The number of the disk on which the central
          directory starts.  If an archive is in zip64 format
          and the value in this field is 0xFFFF, the size will
          be in the corresponding 4 byte zip64 end of central
          directory field.

      total number of entries in the central dir on this disk: (2 bytes)

          The number of central directory entries on this disk.
          If an archive is in zip64 format and the value in
          this field is 0xFFFF, the size will be in the
          corresponding 8 byte zip64 end of central
          directory field.

      total number of entries in the central dir: (2 bytes)

          The total number of files in the .ZIP file.  If an
          archive is in zip64 format and the value in this field
          is 0xFFFF, the size will be in the corresponding 8 byte
          zip64 end of central directory field.

      size of the central directory: (4 bytes)

          The size (in bytes) of the entire central directory.
          If an archive is in zip64 format and the value in
          this field is 0xFFFFFFFF, the size will be in the
          corresponding 8 byte zip64 end of central
          directory field.

      offset of start of central directory with respect to
      the starting disk number:  (4 bytes)

          Offset of the start of the central directory on the
          disk on which the central directory starts.  If an
          archive is in zip64 format and the value in this
          field is 0xFFFFFFFF, the size will be in the
          corresponding 8 byte zip64 end of central
          directory field.

      .ZIP file comment length: (2 bytes)

          The length of the comment for this .ZIP file.

      .ZIP file comment: (Variable)

          The comment for this .ZIP file.  ZIP file comment data
          is stored unsecured.  No encryption or data authentication
          is applied to this area at this time.  Confidential information
          should not be stored in this section.

      zip64 extensible data sector    (variable size)

          (currently reserved for use by PKWARE)


  K.  General notes:

      1)  All fields unless otherwise noted are unsigned and stored
          in Intel low-byte:high-byte, low-word:high-word order.

      2)  String fields are not null terminated, since the
          length is given explicitly.

      3)  Local headers should not span disk boundaries.  Also, even
          though the central directory can span disk boundaries, no
          single record in the central directory should be split
          across disks.

      4)  The entries in the central directory may not necessarily
          be in the same order that files appear in the .ZIP file.

      5)  Spanned/Split archives created using PKZIP for Windows
          (V2.50 or greater), PKZIP Command Line (V2.50 or greater),
          or PKZIP Explorer will include a special spanning
          signature as the first 4 bytes of the first segment of
          the archive.  This signature (0x08074b50) will be
          followed immediately by the local header signature for
          the first file in the archive.  A special spanning
          marker may also appear in spanned/split archives if the
          spanning or splitting process starts but only requires
          one segment.  In this case the 0x08074b50 signature
          will be replaced with the temporary spanning marker
          signature of 0x30304b50.  Spanned/split archives
          created with this special signature are compatible with
          all versions of PKZIP from PKWARE.  Split archives can
          only be uncompressed by other versions of PKZIP that
          know how to create a split archive.

      6)  If one of the fields in the end of central directory
          record is too small to hold required data, the field
          should be set to -1 (0xFFFF or 0xFFFFFFFF) and the
          Zip64 format record should be created.

      7)  The end of central directory record and the
          Zip64 end of central directory locator record must
          reside on the same disk when splitting or spanning
          an archive.

V. UnShrinking - Method 1
-------------------------

Shrinking is a Dynamic Ziv-Lempel-Welch compression algorithm
with partial clearing.  The initial code size is 9 bits, and
the maximum code size is 13 bits.  Shrinking differs from
conventional Dynamic Ziv-Lempel-Welch implementations in several
respects:

1)  The code size is controlled by the compressor, and is not
    automatically increased when codes larger than the current
    code size are created (but not necessarily used).  When
    the decompressor encounters the code sequence 256
    (decimal) followed by 1, it should increase the code size
    read from the input stream to the next bit size.  No
    blocking of the codes is performed, so the next code at
    the increased size should be read from the input stream
    immediately after where the previous code at the smaller
    bit size was read.  Again, the decompressor should not
    increase the code size used until the sequence 256,1 is
    encountered.

2)  When the table becomes full, total clearing is not
    performed.  Rather, when the compressor emits the code
    sequence 256,2 (decimal), the decompressor should clear
    all leaf nodes from the Ziv-Lempel tree, and continue to
    use the current code size.  The nodes that are cleared
    from the Ziv-Lempel tree are then re-used, with the lowest
    code value re-used first, and the highest code value
    re-used last.  The compressor can emit the sequence 256,2
    at any time.


VI. Expanding - Methods 2-5
---------------------------

The Reducing algorithm is actually a combination of two
distinct algorithms.  The first algorithm compresses repeated
byte sequences, and the second algorithm takes the compressed
stream from the first algorithm and applies a probabilistic
compression method.

The probabilistic compression stores an array of 'follower
sets' S(j), for j=0 to 255, corresponding to each possible
ASCII character.  Each set contains between 0 and 32
characters, to be denoted as S(j)[0],...,S(j)[m], where m<32.
The sets are stored at the beginning of the data area for a
Reduced file, in reverse order, with S(255) first, and S(0)
last.

The sets are encoded as { N(j), S(j)[0],...,S(j)[N(j)-1] },
where N(j) is the size of set S(j).  N(j) can be 0, in which
case the follower set for S(j) is empty.  Each N(j) value is
encoded in 6 bits, followed by N(j) eight bit character values
corresponding to S(j)[0] to S(j)[N(j)-1] respectively.  If
N(j) is 0, then no values for S(j) are stored, and the value
for N(j-1) immediately follows.

Immediately after the follower sets, is the compressed data
stream.  The compressed data stream can be interpreted for the
probabilistic decompression as follows:


let Last-Character <- 0.
loop until done
    if the follower set S(Last-Character) is empty then
        read 8 bits from the input stream, and copy this
        value to the output stream.
    otherwise if the follower set S(Last-Character) is non-empty then
        read 1 bit from the input stream.
        if this bit is not zero then
            read 8 bits from the input stream, and copy this
            value to the output stream.
        otherwise if this bit is zero then
            read B(N(Last-Character)) bits from the input
            stream, and assign this value to I.
            Copy the value of S(Last-Character)[I] to the
            output stream.

    assign the last value placed on the output stream to
    Last-Character.
end loop


B(N(j)) is defined as the minimal number of bits required to
encode the value N(j)-1.


The decompressed stream from above can then be expanded to
re-create the original file as follows:


let State <- 0.

loop until done
    read 8 bits from the input stream into C.
    case State of
        0:  if C is not equal to DLE (144 decimal) then
                copy C to the output stream.
            otherwise if C is equal to DLE then
                let State <- 1.

        1:  if C is non-zero then
                let V <- C.
                let Len <- L(V)
                let State <- F(Len).
            otherwise if C is zero then
                copy the value 144 (decimal) to the output stream.
                let State <- 0

        2:  let Len <- Len + C
            let State <- 3.

        3:  move backwards D(V,C) bytes in the output stream
            (if this position is before the start of the output
            stream, then assume that all the data before the
            start of the output stream is filled with zeros).
            copy Len+3 bytes from this position to the output stream.
            let State <- 0.
    end case
end loop


The functions F,L, and D are dependent on the 'compression
factor', 1 through 4, and are defined as follows:

For compression factor 1:
    L(X) equals the lower 7 bits of X.
    F(X) equals 2 if X equals 127 otherwise F(X) equals 3.
    D(X,Y) equals the (upper 1 bit of X) * 256 + Y + 1.
For compression factor 2:
    L(X) equals the lower 6 bits of X.
    F(X) equals 2 if X equals 63 otherwise F(X) equals 3.
    D(X,Y) equals the (upper 2 bits of X) * 256 + Y + 1.
For compression factor 3:
    L(X) equals the lower 5 bits of X.
    F(X) equals 2 if X equals 31 otherwise F(X) equals 3.
    D(X,Y) equals the (upper 3 bits of X) * 256 + Y + 1.
For compression factor 4:
    L(X) equals the lower 4 bits of X.
    F(X) equals 2 if X equals 15 otherwise F(X) equals 3.
    D(X,Y) equals the (upper 4 bits of X) * 256 + Y + 1.


VII. Imploding - Method 6
-------------------------

The Imploding algorithm is actually a combination of two distinct
algorithms.  The first algorithm compresses repeated byte
sequences using a sliding dictionary.  The second algorithm is
used to compress the encoding of the sliding dictionary output,
using multiple Shannon-Fano trees.

The Imploding algorithm can use a 4K or 8K sliding dictionary
size. The dictionary size used can be determined by bit 1 in the
general purpose flag word; a 0 bit indicates a 4K dictionary
while a 1 bit indicates an 8K dictionary.

The Shannon-Fano trees are stored at the start of the compressed
file. The number of trees stored is defined by bit 2 in the
general purpose flag word; a 0 bit indicates two trees stored, a
1 bit indicates three trees are stored.  If 3 trees are stored,
the first Shannon-Fano tree represents the encoding of the
Literal characters, the second tree represents the encoding of
the Length information, the third represents the encoding of the
Distance information.  When 2 Shannon-Fano trees are stored, the
Length tree is stored first, followed by the Distance tree.

The Literal Shannon-Fano tree, if present is used to represent
the entire ASCII character set, and contains 256 values.  This
tree is used to compress any data not compressed by the sliding
dictionary algorithm.  When this tree is present, the Minimum
Match Length for the sliding dictionary is 3.  If this tree is
not present, the Minimum Match Length is 2.

The Length Shannon-Fano tree is used to compress the Length part
of the (length,distance) pairs from the sliding dictionary
output.  The Length tree contains 64 values, ranging from the
Minimum Match Length, to 63 plus the Minimum Match Length.

The Distance Shannon-Fano tree is used to compress the Distance
part of the (length,distance) pairs from the sliding dictionary
output. The Distance tree contains 64 values, ranging from 0 to
63, representing the upper 6 bits of the distance value.  The
distance values themselves will be between 0 and the sliding
dictionary size, either 4K or 8K.

The Shannon-Fano trees themselves are stored in a compressed
format. The first byte of the tree data represents the number of
bytes of data representing the (compressed) Shannon-Fano tree
minus 1.  The remaining bytes represent the Shannon-Fano tree
data encoded as:

    High 4 bits: Number of values at this bit length + 1. (1 - 16)
    Low  4 bits: Bit Length needed to represent value + 1. (1 - 16)

The Shannon-Fano codes can be constructed from the bit lengths
using the following algorithm:

1)  Sort the Bit Lengths in ascending order, while retaining the
    order of the original lengths stored in the file.

2)  Generate the Shannon-Fano trees:

    Code <- 0
    CodeIncrement <- 0
    LastBitLength <- 0
    i <- number of Shannon-Fano codes - 1   (either 255 or 63)

    loop while i >= 0
        Code = Code + CodeIncrement
        if BitLength(i) <> LastBitLength then
            LastBitLength=BitLength(i)
            CodeIncrement = 1 shifted left (16 - LastBitLength)
        ShannonCode(i) = Code
        i <- i - 1
    end loop


3)  Reverse the order of all the bits in the above ShannonCode()
    vector, so that the most significant bit becomes the least
    significant bit.  For example, the value 0x1234 (hex) would
    become 0x2C48 (hex).

4)  Restore the order of Shannon-Fano codes as originally stored
    within the file.

Example:

    This example will show the encoding of a Shannon-Fano tree
    of size 8.  Notice that the actual Shannon-Fano trees used
    for Imploding are either 64 or 256 entries in size.

Example:   0x02, 0x42, 0x01, 0x13

    The first byte indicates 3 values in this table.  Decoding the
    bytes:
            0x42 = 5 codes of 3 bits long
            0x01 = 1 code  of 2 bits long
            0x13 = 2 codes of 4 bits long

    This would generate the original bit length array of:
    (3, 3, 3, 3, 3, 2, 4, 4)

    There are 8 codes in this table for the values 0 thru 7.  Using
    the algorithm to obtain the Shannon-Fano codes produces:

                                  Reversed     Order     Original
Val  Sorted   Constructed Code      Value     Restored    Length
---  ------   -----------------   --------    --------    ------
0:     2      1100000000000000        11       101          3
1:     3      1010000000000000       101       001          3
2:     3      1000000000000000       001       110          3
3:     3      0110000000000000       110       010          3
4:     3      0100000000000000       010       100          3
5:     3      0010000000000000       100        11          2
6:     4      0001000000000000      1000      1000          4
7:     4      0000000000000000      0000      0000          4


The values in the Val, Order Restored and Original Length columns
now represent the Shannon-Fano encoding tree that can be used for
decoding the Shannon-Fano encoded data.  How to parse the
variable length Shannon-Fano values from the data stream is beyond
the scope of this document.  (See the references listed at the end of
this document for more information.)  However, traditional decoding
schemes used for Huffman variable length decoding, such as the
Greenlaw algorithm, can be successfully applied.

The compressed data stream begins immediately after the
compressed Shannon-Fano data.  The compressed data stream can be
interpreted as follows:

loop until done
    read 1 bit from input stream.

    if this bit is non-zero then       (encoded data is literal data)
        if Literal Shannon-Fano tree is present
            read and decode character using Literal Shannon-Fano tree.
        otherwise
            read 8 bits from input stream.
        copy character to the output stream.
    otherwise              (encoded data is sliding dictionary match)
        if 8K dictionary size
            read 7 bits for offset Distance (lower 7 bits of offset).
        otherwise
            read 6 bits for offset Distance (lower 6 bits of offset).

        using the Distance Shannon-Fano tree, read and decode the
          upper 6 bits of the Distance value.

        using the Length Shannon-Fano tree, read and decode
          the Length value.

        Length <- Length + Minimum Match Length

        if Length = 63 + Minimum Match Length
            read 8 bits from the input stream,
            add this value to Length.

        move backwards Distance+1 bytes in the output stream, and
        copy Length characters from this position to the output
        stream.  (if this position is before the start of the output
        stream, then assume that all the data before the start of
        the output stream is filled with zeros).
end loop

VIII. Tokenizing - Method 7
---------------------------

This method is not used by PKZIP.

IX. Deflating - Method 8
------------------------

The Deflate algorithm is similar to the Implode algorithm using
a sliding dictionary of up to 32K with secondary compression
from Huffman/Shannon-Fano codes.

The compressed data is stored in blocks with a header describing
the block and the Huffman codes used in the data block.  The header
format is as follows:

   Bit 0: Last Block bit     This bit is set to 1 if this is the last
                             compressed block in the data.
   Bits 1-2: Block type
      00 (0) - Block is stored - All stored data is byte aligned.
               Skip bits until next byte, then next word = block
               length, followed by the ones compliment of the block
               length word. Remaining data in block is the stored
               data.

      01 (1) - Use fixed Huffman codes for literal and distance codes.
               Lit Code    Bits             Dist Code   Bits
               ---------   ----             ---------   ----
                 0 - 143    8                 0 - 31      5
               144 - 255    9
               256 - 279    7
               280 - 287    8

               Literal codes 286-287 and distance codes 30-31 are
               never used but participate in the huffman construction.

      10 (2) - Dynamic Huffman codes.  (See expanding Huffman codes)

      11 (3) - Reserved - Flag a "Error in compressed data" if seen.

Expanding Huffman Codes
-----------------------
If the data block is stored with dynamic Huffman codes, the Huffman
codes are sent in the following compressed format:

   5 Bits: # of Literal codes sent - 257 (257 - 286)
           All other codes are never sent.
   5 Bits: # of Dist codes - 1           (1 - 32)
   4 Bits: # of Bit Length codes - 4     (4 - 19)

The Huffman codes are sent as bit lengths and the codes are built as
described in the implode algorithm.  The bit lengths themselves are
compressed with Huffman codes.  There are 19 bit length codes:

   0 - 15: Represent bit lengths of 0 - 15
       16: Copy the previous bit length 3 - 6 times.
           The next 2 bits indicate repeat length (0 = 3, ... ,3 = 6)
              Example:  Codes 8, 16 (+2 bits 11), 16 (+2 bits 10) will
                        expand to 12 bit lengths of 8 (1 + 6 + 5)
       17: Repeat a bit length of 0 for 3 - 10 times. (3 bits of length)
       18: Repeat a bit length of 0 for 11 - 138 times (7 bits of length)

The lengths of the bit length codes are sent packed 3 bits per value
(0 - 7) in the following order:

   16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15

The Huffman codes should be built as described in the Implode algorithm
except codes are assigned starting at the shortest bit length, i.e. the
shortest code should be all 0's rather than all 1's.  Also, codes with
a bit length of zero do not participate in the tree construction.  The
codes are then used to decode the bit lengths for the literal and
distance tables.

The bit lengths for the literal tables are sent first with the number
of entries sent described by the 5 bits sent earlier.  There are up
to 286 literal characters; the first 256 represent the respective 8
bit character, code 256 represents the End-Of-Block code, the remaining
29 codes represent copy lengths of 3 thru 258.  There are up to 30
distance codes representing distances from 1 thru 32k as described
below.

                             Length Codes
                             ------------
      Extra             Extra              Extra              Extra
 Code Bits Length  Code Bits Lengths  Code Bits Lengths  Code Bits Length(s)
 ---- ---- ------  ---- ---- -------  ---- ---- -------  ---- ---- ---------
  257   0     3     265   1   11,12    273   3   35-42    281   5  131-162
  258   0     4     266   1   13,14    274   3   43-50    282   5  163-194
  259   0     5     267   1   15,16    275   3   51-58    283   5  195-226
  260   0     6     268   1   17,18    276   3   59-66    284   5  227-258
  261   0     7     269   2   19-22    277   4   67-82    285   0    258
  262   0     8     270   2   23-26    278   4   83-98
  263   0     9     271   2   27-30    279   4   99-114
  264   0    10     272   2   31-34    280   4  115-130

                            Distance Codes
                            --------------
      Extra           Extra             Extra               Extra
 Code Bits Dist  Code Bits  Dist   Code Bits Distance  Code Bits Distance
 ---- ---- ----  ---- ---- ------  ---- ---- --------  ---- ---- --------
   0   0    1      8   3   17-24    16    7  257-384    24   11  4097-6144
   1   0    2      9   3   25-32    17    7  385-512    25   11  6145-8192
   2   0    3     10   4   33-48    18    8  513-768    26   12  8193-12288
   3   0    4     11   4   49-64    19    8  769-1024   27   12 12289-16384
   4   1   5,6    12   5   65-96    20    9 1025-1536   28   13 16385-24576
   5   1   7,8    13   5   97-128   21    9 1537-2048   29   13 24577-32768
   6   2   9-12   14   6  129-192   22   10 2049-3072
   7   2  13-16   15   6  193-256   23   10 3073-4096

The compressed data stream begins immediately after the
compressed header data.  The compressed data stream can be
interpreted as follows:

do
   read header from input stream.

   if stored block
      skip bits until byte aligned
      read count and 1's compliment of count
      copy count bytes data block
   otherwise
      loop until end of block code sent
         decode literal character from input stream
         if literal < 256
            copy character to the output stream
         otherwise
            if literal = end of block
               break from loop
            otherwise
               decode distance from input stream

               move backwards distance bytes in the output stream, and
               copy length characters from this position to the output
               stream.
      end loop
while not last block

if data descriptor exists
   skip bits until byte aligned
   check data descriptor signature
   read crc and sizes
endif

X. Enhanced Deflating - Method 9
--------------------------------

The Enhanced Deflating algorithm is similar to Deflate but
uses a sliding dictionary of up to 64K. Deflate64(tm) is supported
by the Deflate extractor.

[This description is inofficial.  It has been deduced by Info-ZIP from
close inspection of PKZIP 4.x Deflate64(tm) compressed output.]

The Deflate64 algorithm is almost identical to the normal Deflate algorithm.
Differences are:

- The sliding window size is 64k.

- The previously unused distance codes 30 and 31 are now used to describe
  match distances from 32k-48k and 48k-64k.
         Extra
    Code Bits Distance
    ---- ---- -----------
     ..   ..      ...
     29   13  24577-32768
     30   14  32769-49152
     31   14  49153-65536

- The semantics of the "maximum match length" code #258 has been changed to
  allow the specification of arbitrary large match lengths (up to 64k).
         Extra
    Code Bits Lengths
    ---- ---- ------
     ...  ..    ...
     284   5  227-258
     285  16  3-65538

Whereas the first two modifications fit into the framework of Deflate,
this last change breaks compatibility with Deflate method 8. Thus, a
Deflate64 decompressor cannot decode normal deflated data.

XI. BZIP2 - Method 12
---------------------

BZIP2 is an open-source data compression algorithm developed by
Julian Seward.  Information and source code for this algorithm
can be found on the internet.


XII. Traditional PKWARE Encryption
----------------------------------

The following information discusses the decryption steps
required to support traditional PKWARE encryption.  This
form of encryption is considered weak by today's standards
and its use is recommended only for situations with
low security needs or for compatibility with older .ZIP
applications.

XIII. Decryption
----------------

The encryption used in PKZIP was generously supplied by Roger
Schlafly.  PKWARE is grateful to Mr. Schlafly for his expert
help and advice in the field of data encryption.

PKZIP encrypts the compressed data stream.  Encrypted files must
be decrypted before they can be extracted.

Each encrypted file has an extra 12 bytes stored at the start of
the data area defining the encryption header for that file.  The
encryption header is originally set to random values, and then
itself encrypted, using three, 32-bit keys.  The key values are
initialized using the supplied encryption password.  After each byte
is encrypted, the keys are then updated using pseudo-random number
generation techniques in combination with the same CRC-32 algorithm
used in PKZIP and described elsewhere in this document.

The following is the basic steps required to decrypt a file:

1) Initialize the three 32-bit keys with the password.
2) Read and decrypt the 12-byte encryption header, further
   initializing the encryption keys.
3) Read and decrypt the compressed data stream using the
   encryption keys.


Step 1 - Initializing the encryption keys
-----------------------------------------

Key(0) <- 305419896
Key(1) <- 591751049
Key(2) <- 878082192

loop for i <- 0 to length(password)-1
    update_keys(password(i))
end loop


Where update_keys() is defined as:


update_keys(char):
  Key(0) <- crc32(key(0),char)
  Key(1) <- Key(1) + (Key(0) & 000000ffH)
  Key(1) <- Key(1) * 134775813 + 1
  Key(2) <- crc32(key(2),key(1) >> 24)
end update_keys


Where crc32(old_crc,char) is a routine that given a CRC value and a
character, returns an updated CRC value after applying the CRC-32
algorithm described elsewhere in this document.


Step 2 - Decrypting the encryption header
-----------------------------------------

The purpose of this step is to further initialize the encryption
keys, based on random data, to render a plaintext attack on the
data ineffective.


Read the 12-byte encryption header into Buffer, in locations
Buffer(0) thru Buffer(11).

loop for i <- 0 to 11
    C <- buffer(i) ^ decrypt_byte()
    update_keys(C)
    buffer(i) <- C
end loop


Where decrypt_byte() is defined as:


unsigned char decrypt_byte()
    local unsigned short temp
    temp <- Key(2) | 2
    decrypt_byte <- (temp * (temp ^ 1)) >> 8
end decrypt_byte


After the header is decrypted,  the last 1 or 2 bytes in Buffer
should be the high-order word/byte of the CRC for the file being
decrypted, stored in Intel low-byte/high-byte order, or the high-order
byte of the file time if bit 3 of the general purpose bit flag is set.
Versions of PKZIP prior to 2.0 used a 2 byte CRC check; a 1 byte CRC check is
used on versions after 2.0.  This can be used to test if the password
supplied is correct or not.


Step 3 - Decrypting the compressed data stream
----------------------------------------------

The compressed data stream can be decrypted as follows:


loop until done
    read a character into C
    Temp <- C ^ decrypt_byte()
    update_keys(temp)
    output Temp
end loop


XIV. Strong Encryption Specification (EFS)
------------------------------------------

Version 5.x of this specification introduced support for strong
encryption algorithms.  These algorithms can be used with either
a password or an X.509v3 digital certificate to encrypt each file.
This format specification supports either password or certificate
based encryption to meet the security needs of today, to enable
interoperability between users within both PKI and non-PKI
environments, and to ensure interoperability between different
computing platforms that are running a ZIP program.

Password based encryption is the most common form of encryption
people are familiar with.  However, inherent weaknesses with
passwords (e.g. susceptibility to dictionary/brute force attack)
as well as password management and support issues make certificate
based encryption a more secure and scalable option.  Industry
efforts and support are defining and moving towards more advanced
security solutions built around X.509v3 digital certificates and
Public Key Infrastructures(PKI) because of the greater scalability,
administrative options, and more robust security over traditional
password-based encryption.

Most standard encryption algorithms are supported with this
specification. Reference implementations for many of these
algorithms are available from either commercial or open source
distributors.  Readily available cryptographic toolkits make
implementation of the encryption features straight-forward.
This document is not intended to provide a treatise on data
encryption principles or theory.  Its purpose is to document the
data structures required for implementing interoperable data
encryption within the .ZIP format.  It is strongly recommended that
you have a good understanding of data encryption before reading
further.

The algorithms introduced in Version 5.0 of this specification
include:

    RC2 40 bit, 64 bit, and 128 bit
    RC4 40 bit, 64 bit, and 128 bit
    DES
    3DES 112 bit and 168 bit

Version 5.1 adds support for the following:

    AES 128 bit, 192 bit, and 256 bit

Version 6.1 introduces encryption data changes to support
interoperability with SmartCard and USB Token certificate storage
methods which do not support the OAEP strengthening standard.

Version 6.2 introduces support for encrypting metadata by compressing
and encrypting the central directory data structure to reduce information
leakage.   Information leakage can occur in legacy ZIP applications
through exposure of information about a file even though that file is
stored encrypted.  The information exposed consists of file
characteristics stored within the records and fields defined by this
specification.  This includes data such as a files name, its original
size, timestamp and CRC32 value.

Central Directory Encryption provides greater protection against
information leakage by encrypting the Central Directory structure and
by masking key values that are replicated in the unencrypted Local
Header.   ZIP compatible programs that cannot interpret an encrypted
Central Directory structure cannot rely on the data in the corresponding
Local Header for decompression information.

Extra Field records that may contain information about a file that should
not be exposed should not be stored in the Local Header and should only
be written to the Central Directory where they can be encrypted.  This
design currently does not support streaming.  Information in the End of
Central Directory record, the ZIP64 End of Central Directory Locator,
and the ZIP64 End of Central Directory record are not encrypted.  Access
to view data on files within a ZIP file with an encrypted Central Directory
requires the appropriate password or private key for decryption prior to
viewing any files, or any information about the files, in the archive.

Older ZIP compatible programs not familiar with the Central Directory
Encryption feature will no longer be able to recognize the Central
Directory and may assume the ZIP file is corrupt.  Programs that
attempt streaming access using Local Headers will see invalid
information for each file.  Central Directory Encryption need not be
used for every ZIP file.  Its use is recommended for greater security.
ZIP files not using Central Directory Encryption should operate as
in the past.

The details of the strong encryption specification for certificates
remain under development as design and testing issues are worked out
for the range of algorithms, encryption methods, certificate processing
and cross-platform support necessary to meet the advanced security needs
of .ZIP file users today and in the future.

This feature specification is intended to support basic encryption needs
of today, such as password support.  However this specification is also
designed to lay the foundation for future advanced security needs.

Encryption provides data confidentiality and privacy.  It is
recommended that you combine X.509 digital signing with encryption
to add authentication and non-repudiation.


Single Password Symmetric Encryption Method:
-------------------------------------------

The Single Password Symmetric Encryption Method using strong
encryption algorithms operates similarly to the traditional
PKWARE encryption defined in this format.  Additional data
structures are added to support the processing needs of the
strong algorithms.

The Strong Encryption data structures are:

1. General Purpose Bits - Bits 0 and 6 of the General Purpose bit
flag in both local and central header records.  Both bits set
indicates strong encryption.  Bit 13, when set indicates the Central
Directory is encrypted and that selected fields in the Local Header
are masked to hide their actual value.


2. Extra Field 0x0017 in central header only.

     Fields to consider in this record are:

     Format - the data format identifier for this record.  The only
     value allowed at this time is the integer value 2.

     AlgId - integer identifier of the encryption algorithm from the
     following range

         0x6601 - DES
         0x6602 - RC2 (version needed to extract < 5.2)
         0x6603 - 3DES 168
         0x6609 - 3DES 112
         0x660E - AES 128
         0x660F - AES 192
         0x6610 - AES 256
         0x6702 - RC2 (version needed to extract >= 5.2)
         0x6801 - RC4
         0xFFFF - Unknown algorithm

     Bitlen - Explicit bit length of key

          40
          56
          64
         112
         128
         168
         192
         256

     Flags - Processing flags needed for decryption

         0x0001 - Password is required to decrypt
         0x0002 - Certificates only
         0x0003 - Password or certificate required to decrypt

         Values > 0x0003 reserved for certificate processing


3. Decryption header record preceeding compressed file data.

         -Decryption Header:

          Value     Size     Description
          -----     ----     -----------
          IVSize    2 bytes  Size of initialization vector (IV)
          IVData    IVSize   Initialization vector for this file
          Size      4 bytes  Size of remaining decryption header data
          Format    2 bytes  Format definition for this record
          AlgID     2 bytes  Encryption algorithm identifier
          Bitlen    2 bytes  Bit length of encryption key
          Flags     2 bytes  Processing flags
          ErdSize   2 bytes  Size of Encrypted Random Data
          ErdData   ErdSize  Encrypted Random Data
          Reserved1 4 bytes  Reserved certificate processing data
          Reserved2 (var)    Reserved for certificate processing data
          VSize     2 bytes  Size of password validation data
          VData     VSize-4  Password validation data
          VCRC32    4 bytes  Standard ZIP CRC32 of password validation data

     IVData - The size of the IV should match the algorithm block size.
              The IVData can be completely random data.  If the size of
              the randomly generated data does not match the block size
              it should be complemented with zero's or truncated as
              necessary.  If IVSize is 0, then IV = CRC32 + Uncompressed
              File Size (as a 64 bit little-endian, unsigned integer value).

     Format - the data format identifier for this record.  The only
     value allowed at this time is the integer value 3.

     AlgId - integer identifier of the encryption algorithm from the
     following range

         0x6601 - DES
         0x6602 - RC2 (version needed to extract < 5.2)
         0x6603 - 3DES 168
         0x6609 - 3DES 112
         0x660E - AES 128
         0x660F - AES 192
         0x6610 - AES 256
         0x6702 - RC2 (version needed to extract >= 5.2)
         0x6801 - RC4
         0xFFFF - Unknown algorithm

     Bitlen - Explicit bit length of key

          40
          56
          64
         112
         128
         168
         192
         256

     Flags - Processing flags needed for decryption

         0x0001 - Password is required to decrypt
         0x0002 - Certificates only
         0x0003 - Password or certificate required to decrypt

         Values > 0x0003 reserved for certificate processing

     ErdData - Encrypted random data is used to generate a file
               session key for encrypting each file.  SHA1 is
               used to calculate hash data used to derive keys.
               File session keys are derived from a master session
               key generated from the user-supplied password.
               If the Flags field in the decryption header contains
               the value 0x4000, then the ErdData field must be
               decrypted using 3DES.

     Reserved1 - Reserved for certificate processing, if value is
               zero, then Reserved2 data is absent.  See the explanation
               under the Certificate Processing Method for details on
               this data structure.

     Reserved2 - If present, the size of the Reserved2 data structure
               is located by skipping the first 4 bytes of this field
               and using the next 2 bytes as the remaining size.  See
               the explanation under the Certificate Processing Method
               for details on this data structure.

     VSize - This size value will always include the 4 bytes of the
             VCRC32 data and will be greater than 4 bytes.

     VData - Random data for password validation.  This data is VSize
             in length and VSize must be a multiple of the encryption
             block size.  VCRC32 is a checksum value of VData.
             VData and VCRC32 are stored encrypted and start the
             stream of encrypted data for a file.

4. Single Password Central Directory Encryption

Central Directory Encryption is achieved within the .ZIP format by
encrypting the Central Directory structure.  This encapsulates the metadata
most often used for processing .ZIP files.  Additional metadata is stored for
redundancy in the Local Header for each file.  The process of concealing
metadata by encrypting the Central Directory does not protect the data within
the Local Header.  To avoid information leakage from the exposed metadata
in the Local Header, the fields containing information about a file are masked.

Local Header:

Masking replaces the true content of the fields for a file in the Local
Header with false information.  When masked, the Local Header is not
suitable for streaming access and the options for data recovery of damaged
archives is reduced.  Extra Data fields that may contain confidential
data should not be stored within the Local Header.  The value set into
the Version needed to extract field should be the correct value needed to
extract the file without regard to Central Directory Encryption. The fields
within the Local Header targeted for masking when the Central Directory is
encrypted are:

        Field Name                     Mask Value
        ------------------             ---------------------------
        compression method              0
        last mod file time              0
        last mod file date              0
        crc-32                          0
        compressed size                 0
        uncompressed size               0
        file name (variable size)       Base 16 value from the
                                        range 1 - FFFFFFFFFFFFFFFF
                                        represented as a string whose
                                        size will be set into the
                                        file name length field

The Base 16 value assigned as a masked file name is simply a sequentially
incremented value for each file starting with 1 for the first file.
Modifications to a ZIP file may cause different values to be stored for
each file.  For compatibility, the file name field in the Local Header
should never be left blank.  As of Version 6.2 of this specification,
the Compression Method and Compressed Size fields are not yet masked.

Encrypting the Central Directory:

Encryption of the Central Directory does not include encryption of the
Central Directory Signature data, the ZIP64 End of Central Directory
record, the ZIP64 End of Central Directory Locator, or the End
of Central Directory record.  The ZIP file comment data is never
encrypted.

Before encrypting the Central Directory, it may optionally be compressed.
Compression is not required, but for storage efficiency it is assumed
this structure will be compressed before encrypting.  Similarly, this
specification supports compressing the Central Directory without
requiring that it also be encrypted.  Early implementations of this
feature will assume the encryption method applied to files matches the
encryption applied to the Central Directory.

Encryption of the Central Directory is done in a manner similar to
that of file encryption.  The encrypted data is preceded by a
decryption header.  The decryption header is known as the Archive
Decryption Header.  The fields of this record are identical to
the decryption header preceding each encrypted file.  The location
of the Archive Decryption Header is determined by the value in the
Start of the Central Directory field in the ZIP64 End of Central
Directory record.  When the Central Directory is encrypted, the
ZIP64 End of Central Directory record will always be present.

The layout of the ZIP64 End of Central Directory record for all
versions starting with 6.2 of this specification will follow the
Version 2 format.  The Version 2 format is as follows:

The first 48 bytes will remain identical to that of Version 1.
The record signature for both Version 1 and Version 2 will be
0x06064b50.  Immediately following the 48th byte, which identifies
the end of the field known as the Offset of Start of Central
Directory With Respect to the Starting Disk Number will begin the
new fields defining Version 2 of this record.

New fields for Version 2:

Note: all fields stored in Intel low-byte/high-byte order.

          Value                 Size       Description
          -----                 ----       -----------
          Compression Method    2 bytes    Method used to compress the
                                           Central Directory
          Compressed Size       8 bytes    Size of the compressed data
          Original   Size       8 bytes    Original uncompressed size
          AlgId                 2 bytes    Encryption algorithm ID
          BitLen                2 bytes    Encryption key length
          Flags                 2 bytes    Encryption flags
          HashID                2 bytes    Hash algorithm identifier
          Hash Length           2 bytes    Length of hash data
          Hash Data             (variable) Hash data

The Compression Method accepts the same range of values as the
corresponding field in the Central Header.

The Compressed Size and Original Size values will not include the
data of the Central Directory Signature which is compressed or
encrypted.

The AlgId, BitLen, and Flags fields accept the same range of values
the corresponding fields within the 0x0017 record.

Hash ID identifies the algorithm used to hash the Central Directory
data.  This data does not have to be hashed, in which case the
values for both the HashID and Hash Length will be 0.  Possible
values for HashID are:

      Value         Algorithm
     ------         ---------
     0x0000          none
     0x0001          CRC32
     0x8003          MD5
     0x8004          SHA1

When the Central Directory data is signed, the same hash algorithm
used to hash the Central Directory for signing should be used.
This is recommended for processing efficiency, however, it is
permissible for any of the above algorithms to be used independent
of the signing process.

The Hash Data will contain the hash data for the Central Directory.
The length of this data will vary depending on the algorithm used.

The Version Needed to Extract should be set to 62.

The value for the Total Number of Entries on the Current Disk will
be 0.  These records will no longer support random access when
encrypting the Central Directory.

When the Central Directory is compressed and/or encrypted, the
End of Central Directory record will store the value 0xFFFFFFFF
as the value for the Total Number of Entries in the Central
Directory.  The value stored in the Total Number of Entries in
the Central Directory on this Disk field will be 0.  The actual
values will be stored in the equivalent fields of the ZIP64
End of Central Directory record.

Decrypting and decompressing the Central Directory is accomplished
in the same manner as decrypting and decompressing a file.


5. Useful Tips

Strong Encryption is always applied to a file after compression. The
block oriented algorithms all operate in Cypher Block Chaining (CBC)
mode.  The block size used for AES encryption is 16.  All other block
algorithms use a block size of 8.  Two ID's are defined for RC2 to
account for a discrepancy found in the implementation of the RC2
algorithm in the cryptographic library on Windows XP SP1 and all
earlier versions of Windows.

A pseudo-code representation of the encryption process is as follows:

Password = GetUserPassword()
RD  = Random()
ERD = Encrypt(RD,DeriveKey(SHA1(Password)))
For Each File
    IV = Random()
    VData = Random()
    FileSessionKey = DeriveKey(SHA1(IV + RD))
    Encrypt(VData + VCRC32 + FileData,FileSessionKey)
Done

The function names and parameter requirements will depend on
the choice of the cryptographic toolkit selected.  Almost any
toolkit supporting the reference implementations for each
algorithm can be used.  The RSA BSAFE(r), OpenSSL, and Microsoft
CryptoAPI libraries are all known to work well.


Certificate Processing Method:
-----------------------------

The Certificate Processing Method for ZIP file encryption remains
under development.  The information provided here serves as a guide
to those interested in certificate-based data decryption.  This
information may be subject to change in future versions of this
specification and is subject to change without notice.

OAEP Processing with Certificate-based Encryption:

Versions of PKZIP available during this development phase of the
certificate processing method may set a value of 61 into the
version needed to extract field for a file.  This indicates that
non-OAEP key wrapping is used.  This affects certificate encryption
only, and password encryption functions should not be affected by
this value.  This means values of 61 may be found on files encrypted
with certificates only, or on files encrypted with both password
encryption and certificate encryption.  Files encrypted with both
methods can safely be decrypted using the password methods documented.

OAEP stands for Optimal Asymmetric Encryption Padding.  It is a
strengthening technique used for small encoded items such as decryption
keys.  This is commonly applied in cryptographic key-wrapping techniques
and is supported by PKCS #1.  Versions 5.0 and 6.0 of this specification
were designed to support OAEP key-wrapping for certificate-based
decryption keys for additional security.

Support for private keys stored on Smart Cards or Tokens introduced
a conflict with this OAEP logic.  Most card and token products do
not support the additional strengthening applied to OAEP key-wrapped
data.  In order to resolve this conflict, versions 6.1 and above of this
specification will no longer support OAEP when encrypting using
digital certificates.

Certificate Processing Data Fields:

The Certificate Processing Method of this specification defines the
following additional data fields:


1. Certificate Flag Values

Additional processing flags that can be present in the Flags field of both
the 0x0017 field of the central directory Extra Field and the Decryption
header record preceding compressed file data are:

         0x0007 - reserved for future use
         0x000F - reserved for future use
         0x0100 - Indicates non-OAEP key wrapping was used.  If this
                  this field is set, the version needed to extract must
                  be at least 61.  This means OAEP key wrapping is not
                  used when generating a Master Session Key using
                  ErdData.
         0x4000 - ErdData must be decrypted using 3DES-168, otherwise use the
                  same algorithm used for encrypting the file contents.
         0x8000 - reserved for future use


2. CertData - Extra Field 0x0017 record certificate data structure

The data structure used to store certificate data within the section
of the Extra Field defined by the CertData field of the 0x0017
record are as shown:

          Value     Size     Description
          -----     ----     -----------
          RCount    4 bytes  Number of recipients.
          HashAlg   2 bytes  Hash algorithm identifier
          HSize     2 bytes  Hash size
          SRList    (var)    Simple list of recipients hashed public keys


     RCount    This defines the number intended recipients whose
               public keys were used for encryption.  This identifies
               the number of elements in the SRList.

     HashAlg   This defines the hash algorithm used to calculate
               the public key hash of each public key used
               for encryption. This field currently supports
               only the following value for SHA-1

               0x8004 - SHA1

     HSize     This defines the size of a hashed public key.

     SRList    This is a variable length list of the hashed
               public keys for each intended recipient.  Each
               element in this list is HSize.  The total size of
               SRList is determined using RCount * HSize.


3. Reserved1 - Certificate Decryption Header Reserved1 Data:

          Value     Size     Description
          -----     ----     -----------
          RCount    4 bytes  Number of recipients.

     RCount    This defines the number intended recipients whose
               public keys were used for encryption.  This defines
               the number of elements in the REList field defined below.


4. Reserved2 - Certificate Decryption Header Reserved2 Data Structures:


          Value     Size     Description
          -----     ----     -----------
          HashAlg   2 bytes  Hash algorithm identifier
          HSize     2 bytes  Hash size
          REList    (var)    List of recipient data elements


     HashAlg   This defines the hash algorithm used to calculate
               the public key hash of each public key used
               for encryption. This field currently supports
               only the following value for SHA-1

               0x8004 - SHA1

     HSize     This defines the size of a hashed public key
               defined in REHData.

     REList    This is a variable length of list of recipient data.
               Each element in this list consists of a Recipient
               Element data structure as follows:


    Recipient Element (REList) Data Structure:

          Value     Size     Description
          -----     ----     -----------
          RESize    2 bytes  Size of REHData + REKData
          REHData   HSize    Hash of recipients public key
          REKData   (var)    Simple key blob


     RESize    This defines the size of an individual REList
               element.  This value is the combined size of the
               REHData field + REKData field.  REHData is defined by
               HSize.  REKData is variable and can be calculated
               for each REList element using RESize and HSize.

     REHData   Hashed public key for this recipient.

     REKData   Simple Key Blob.  The format of this data structure
               is identical to that defined in the Microsoft
               CryptoAPI and generated using the CryptExportKey()
               function.  The version of the Simple Key Blob
               supported at this time is 0x02 as defined by
               Microsoft.

5. Certificate Processing - Central Directory Encryption:

Central Directory Encryption using Digital Certificates will
operate in a manner similar to that of Single Password Central
Directory Encryption.  This record will only be present when there
is data to place into it.  Currently, data is placed into this
record when digital certificates are used for either encrypting
or signing the files within a ZIP file.  When only password
encryption is used with no certificate encryption or digital
signing, this record is not currently needed. When present, this
record will appear before the start of the actual Central Directory
data structure and will be located immediately after the Archive
Decryption Header if the Central Directory is encrypted.

The Archive Extra Data record will be used to store the following
information.  Additional data may be added in future versions.

Extra Data Fields:

0x0014 - PKCS#7 Store for X.509 Certificates
0x0016 - X.509 Certificate ID and Signature for central directory
0x0019 - PKCS#7 Encryption Recipient Certificate List

The 0x0014 and 0x0016 Extra Data records that otherwise would be
located in the first record of the Central Directory for digital
certificate processing. When encrypting or compressing the Central
Directory, the 0x0014 and 0x0016 records must be located in the
Archive Extra Data record and they should not remain in the first
Central Directory record.  The Archive Extra Data record will also
be used to store the 0x0019 data.

When present, the size of the Archive Extra Data record will be
included in the size of the Central Directory.  The data of the
Archive Extra Data record will also be compressed and encrypted
along with the Central Directory data structure.

6. Certificate Processing Differences:

The Certificate Processing Method of encryption differs from the
Single Password Symmetric Encryption Method as follows.  Instead
of using a user-defined password to generate a master session key,
cryptographically random data is used.  The key material is then
wrapped using standard key-wrapping techniques.  This key material
is wrapped using the public key of each recipient that will need
to decrypt the file using their corresponding private key.

This specification currently assumes digital certificates will follow
the X.509 V3 format for 1024 bit and higher RSA format digital
certificates.  Implementation of this Certificate Processing Method
requires supporting logic for key access and management.  This logic
is outside the scope of this specification.


License Agreement:
-----------------

The features set forth in this Section XIV (the "Strong Encryption
Specification") are covered by a pending patent application. Portions of
this Strong Encryption technology are available for use at no charge
under the following terms and conditions.

1. License Grant.

   a. NOTICE TO USER. PLEASE READ THIS ENTIRE SECTION XIV OF THE
   APPNOTE (THE "AGREEMENT") CAREFULLY. BY USING ALL OR ANY PORTION OF THE
   LICENSED TECHNOLOGY, YOU ACCEPT ALL THE TERMS AND CONDITIONS OF THIS
   AGREEMENT AND YOU AGREE THAT THIS AGREEMENT IS ENFORCEABLE LIKE ANY
   WRITTEN NEGOTIATED AGREEMENT SIGNED BY YOU. IF YOU DO NOT AGREE, DO NOT
   USE THE LICENSED TECHNOLOGY.

   b. Definitions.

      i. "Licensed Technology" shall mean that proprietary technology now or
      hereafter owned or controlled by PKWare, Inc. ("PKWARE") or any
      subsidiary or affiliate  that covers or is necessary to be used to give
      software the ability to a) extract and decrypt data from zip files
      encrypted using any methods of data encryption and key processing which
      are published in this APPNOTE or any prior APPNOTE, as supplemented by
      any Additional Compatibility Information; and b) encrypt file contents
      as part of .ZIP file processing using only the Single Password Symmetric
      Encryption Method as published in this APPNOTE or any prior APPNOTE, as
      supplemented by any Additional Compatibility Information.  For purposes
      of this AGREEMENT, "Additional Compatibility Information" means, with
      regard to any method of data encryption and key processing published in
      this or any prior APPNOTE, any corrections, additions, or clarifications
      to the information in such APPNOTE that are required in order to give
      software the ability to successfully extract and decrypt zip files (or,
      but solely in the case of the Single Password Symmetric Encryption Method,
      to successfully encrypt zip files) in a manner interoperable with the
      actual implementation of such method in any PKWARE product that is
      documented or publicly described by PKWARE as being able to create, or
      to extract and decrypt, zip files using that method.

      ii. "Licensed Products" shall mean any products you produce that
      incorporate the Licensed Technology.

   c. License to Licensed Technology.

   PKWARE hereby grants to you a non-exclusive license to use the Licensed
   Technology for the purpose of manufacturing, offering, selling and using
   Licensed Products, which license shall extend to permit the practice of all
   claims in any patent or patent application (collectively, "Patents") now or
   hereafter owned or controlled by PKWARE in any jurisdiction in the world
   that are infringed by implementation of the Licensed Technology.  You have
   the right to sublicense rights you receive under the terms of this AGREEMENT
   for the purpose of allowing sublicensee to manufacture, offer, sell and use
   products that incorporate all or a portion of any of your Licensed Products,
   but if you do, you agree to i) impose the same restrictions on any such
   sublicensee as these terms impose on you and ii) notify the sublicensee,
   by means chosen by you in your unfettered discretion, including a notice on
   your web site, of the terms of this AGREEMENT and make available to each
   sublicensee the full text of this APPNOTE.   Further, PKWARE hereby grants to
   you a non-exclusive right to reproduce and distribute, in any form, copies of
   this APPNOTE, without modification.  Notwithstanding anything to the contrary
   in this AGREEMENT, you have the right to sublicense the rights, without any of
   the restrictions described above or elsewhere in this AGREEMENT, to use, offer
   to sell and sell Licensed Technology as incorporated in executable object code
   or byte code forms of your Licensed Products.  Any sublicense to use the
   Licensed Technology incorporated in a Licensed Product granted by you shall
   survive the termination of this AGREEMENT for any reason.  PKWARE warrants that
   this license shall continue to encumber the Licensed Technology regardless of
   changes in ownership of the Licensed Technology.

   d. Proprietary Notices.

      i. With respect to any Licensed Product that is distributed by you either
      in source code form or in the form of an object code library of externally
      callable functions that has been designed by you for incorporation into third
      party products, you agree to include, in the source code, or in the case of
      an object code library, in accompanying documentation, a notice using the
      words "patent pending" until a patent is issued to PKWARE covering any
      portion of the Licensed Technology or PKWARE provides notice, by means
      chosen by PKWARE in its unfettered discretion, that it no longer has any
      patent pending covering any portion of the Licensed Technology.  With respect
      to any Licensed Product, upon your becoming aware that at least one patent has
      been granted covering the Licensed Technology, you agree to include in any
      revisions made by you to the documentation (or any source code distributed
      by you) the words "Pat. No.", or "Patent Number" and the patent number or
      numbers of the applicable patent or patents.  PKWARE shall, from time to time,
      inform you of the patent number or numbers of the patents covering the
      Licensed Technology, by means chosen by PKWARE in its unfettered discretion,
      including a notice on its web site.  It shall be a violation of the terms of
      this AGREEMENT for you to sell Licensed Products without complying with the
      foregoing marking provisions.

      ii. You acknowledge that the terms of this AGREEMENT do not grant you any
      license or other right to use any PKWARE trademark in connection with the sale,
      offering for sale, distribution and delivery of the Licensed Products, or in
      connection with the advertising, promotion and offering of the Licensed Products.
      You acknowledge PKWARE's ownership of the PKZIP trademark and all other marks
      owned by PKWARE.

   e. Covenant of Compliance and Remedies.

   To the extent that you have elected to implement portions of the Licensed
   Technology, you agree to use reasonable diligence to comply with those portions
   of this Section XIV, as modified or supplemented by Additional Compatibility
   Information available to you, describing the portions of the Licensed Technology
   that you have elected to implement.  Upon reasonable request by PKWARE, you will
   provide written notice to PKWARE identifying which version of this APPNOTE you
   have relied upon for your implementation of any specified Licensed Product.

   If any substantial non-compliance with the terms of this AGREEMENT is determined
   to exist, you will make such changes as necessary to bring your Licensed Products
   into substantial compliance with the terms of this AGREEMENT.  If, within sixty
   days of receipt of notice that a Licensed Product fails to comply with the terms
   of this AGREEMENT, you fail to make such changes as necessary to bring your
   Licensed Products into compliance with the terms of this AGREEMENT, PKWARE may
   terminate your rights under this AGREEMENT.  PKWARE does not waive and expressly
   reserves the right to pursue any and all additional remedies that are or may
   become available to PKWARE.

   f. Warranty and Indemnification Regarding Exportation.

   You realize and acknowledge that, as between yourself and PKWARE, you are fully
   responsible for compliance with the import and export laws and regulations of
   any country in or to which you import or export any Licensed Products, and you
   agree to hold PKWARE harmless from any claim of violation of any such import
   or export laws.

   g. Patent Infringement.

   You agree that you will not bring or threaten to bring any action against PKWARE
   for infringement of the claims of any patent owned or controlled by you solely
   as a result of PKWARE's own implementation of the Licensed Technology.  As its
   exclusive remedy for your breach of the foregoing agreement, PKWARE reserves
   the right to suspend or terminate all rights granted under the terms of this
   AGREEMENT if you bring or threaten to bring any such action against PKWARE,
   effective immediately upon delivery of written notice of suspension or
   termination to you.

   h. Governing Law.

   The license granted in this AGREEMENT shall be governed by and construed under
   the laws of the State of Wisconsin and the United States.

   i. Revisions and Notice.

   The license granted in this APPNOTE is irrevocable, except as expressly set
   forth above.  You agree and understand that any changes which PKWARE determines
   to make to this APPNOTE shall be posted at the same location as the current
   APPNOTE or at a location which will be identified by means chosen by PKWARE,
   including a notice on its web site, and shall be available for adoption by you
   immediately upon such posting, or at such other time as PKWARE shall determine.
   Any changes to the terms of the license published in a subsequent version of
   this AGREEMENT shall be binding upon you only with respect to your products
   that (i) incorporate any Licensed Technology (as defined in the subsequent
   AGREEMENT) that is not otherwise included in the definition of Licensed
   Technology under this AGREEMENT, or (ii) that you expressly identify are to
   be licensed under the subsequent AGREEMENT, which identification shall be by
   written notice with reference to the APPNOTE (version and release date or other
   unique identifier) in which the subsequent AGREEMENT is published.  PKWARE
   agrees to identify each change to this APPNOTE by using a unique version and
   release date identifier or other unique identifier.

   j. Warranty by PKWARE

   PKWare, Inc. warrants that it has the right to grant the license hereunder.

XV. Change Process
------------------

In order for the .ZIP file format to remain a viable definition, this
specification should be considered as open for periodic review and
revision.  Although this format was originally designed with a
certain level of extensibility, not all changes in technology
(present or future) were or will be necessarily considered in its
design.  If your application requires new definitions to the
extensible sections in this format, or if you would like to
submit new data structures, please forward your request to
zipformat@pkware.com.  All submissions will be reviewed by the
ZIP File Specification Committee for possible inclusion into
future versions of this specification.  Periodic revisions
to this specification will be published to ensure interoperability.
We encourage comments and feedback that may help improve clarity
or content.


XVI. Acknowledgements
---------------------

In addition to the above mentioned contributors to PKZIP and PKUNZIP,
I would like to extend special thanks to Robert Mahoney for suggesting
the extension .ZIP for this software.


XVII. References
----------------

    Fiala, Edward R., and Greene, Daniel H., "Data compression with
       finite windows",  Communications of the ACM, Volume 32, Number 4,
       April 1989, pages 490-505.

    Held, Gilbert, "Data Compression, Techniques and Applications,
       Hardware and Software Considerations", John Wiley & Sons, 1987.

    Huffman, D.A., "A method for the construction of minimum-redundancy
       codes", Proceedings of the IRE, Volume 40, Number 9, September 1952,
       pages 1098-1101.

    Nelson, Mark, "LZW Data Compression", Dr. Dobbs Journal, Volume 14,
       Number 10, October 1989, pages 29-37.

    Nelson, Mark, "The Data Compression Book",  M&T Books, 1991.

    Storer, James A., "Data Compression, Methods and Theory",
       Computer Science Press, 1988

    Welch, Terry, "A Technique for High-Performance Data Compression",
       IEEE Computer, Volume 17, Number 6, June 1984, pages 8-19.

    Ziv, J. and Lempel, A., "A universal algorithm for sequential data
       compression", Communications of the ACM, Volume 30, Number 6,
       June 1987, pages 520-540.

    Ziv, J. and Lempel, A., "Compression of individual sequences via
       variable-rate coding", IEEE Transactions on Information Theory,
       Volume 24, Number 5, September 1978, pages 530-536.
File:    APPNOTE.TXT - .ZIP File Format Specification
Version: 6.3.2
Revised: September 28, 2007
Copyright (c) 1989 - 2007 PKWARE Inc., All Rights Reserved.

The use of certain technological aspects disclosed in the current
APPNOTE is available pursuant to the below section entitled
"Incorporating PKWARE Proprietary Technology into Your Product".

I. Purpose
----------

This specification is intended to define a cross-platform,
interoperable file storage and transfer format.  Since its
first publication in 1989, PKWARE has remained committed to
ensuring the interoperability of the .ZIP file format through
publication and maintenance of this specification.  We trust that
all .ZIP compatible vendors and application developers that have
adopted and benefited from this format will share and support
this commitment to interoperability.

II. Contacting PKWARE
---------------------

     PKWARE, Inc.
     648 N. Plankinton Avenue, Suite 220
     Milwaukee, WI 53203
     +1-414-289-9788
     +1-414-289-9789 FAX
     zipformat@pkware.com

III. Disclaimer
---------------

Although PKWARE will attempt to supply current and accurate
information relating to its file formats, algorithms, and the
subject programs, the possibility of error or omission cannot
be eliminated. PKWARE therefore expressly disclaims any warranty
that the information contained in the associated materials relating
to the subject programs and/or the format of the files created or
accessed by the subject programs and/or the algorithms used by
the subject programs, or any other matter, is current, correct or
accurate as delivered.  Any risk of damage due to any possible
inaccurate information is assumed by the user of the information.
Furthermore, the information relating to the subject programs
and/or the file formats created or accessed by the subject
programs and/or the algorithms used by the subject programs is
subject to change without notice.

If the version of this file is marked as a NOTIFICATION OF CHANGE,
the content defines an Early Feature Specification (EFS) change
to the .ZIP file format that may be subject to modification prior
to publication of the Final Feature Specification (FFS).  This
document may also contain information on Planned Feature
Specifications (PFS) defining recognized future extensions.

IV. Change Log
--------------

Version       Change Description                        Date
-------       ------------------                       ----------
5.2           -Single Password Symmetric Encryption    06/02/2003
               storage

6.1.0         -Smartcard compatibility                 01/20/2004
              -Documentation on certificate storage

6.2.0         -Introduction of Central Directory       04/26/2004
               Encryption for encrypting metadata
              -Added OS/X to Version Made By values

6.2.1         -Added Extra Field placeholder for       04/01/2005
               POSZIP using ID 0x4690

              -Clarified size field on
               "zip64 end of central directory record"

6.2.2         -Documented Final Feature Specification  01/06/2006
               for Strong Encryption

              -Clarifications and typographical
               corrections

6.3.0         -Added tape positioning storage          09/29/2006
               parameters

              -Expanded list of supported hash algorithms

              -Expanded list of supported compression
               algorithms

              -Expanded list of supported encryption
               algorithms

              -Added option for Unicode filename
               storage

              -Clarifications for consistent use
               of Data Descriptor records

              -Added additional "Extra Field"
               definitions

6.3.1         -Corrected standard hash values for      04/11/2007
               SHA-256/384/512

6.3.2         -Added compression method 97             09/28/2007

              -Documented InfoZIP "Extra Field"
               values for UTF-8 file name and
               file comment storage

V. General Format of a .ZIP file
--------------------------------

  Files stored in arbitrary order.  Large .ZIP files can span multiple
  volumes or be split into user-defined segment sizes. All values
  are stored in little-endian byte order unless otherwise specified.

  Overall .ZIP file format:

    [local file header 1]
    [file data 1]
    [data descriptor 1]
    .
    .
    .
    [local file header n]
    [file data n]
    [data descriptor n]
    [archive decryption header]
    [archive extra data record]
    [central directory]
    [zip64 end of central directory record]
    [zip64 end of central directory locator]
    [end of central directory record]


  A.  Local file header:

        local file header signature     4 bytes  (0x04034b50)
        version needed to extract       2 bytes
        general purpose bit flag        2 bytes
        compression method              2 bytes
        last mod file time              2 bytes
        last mod file date              2 bytes
        crc-32                          4 bytes
        compressed size                 4 bytes
        uncompressed size               4 bytes
        file name length                2 bytes
        extra field length              2 bytes

        file name (variable size)
        extra field (variable size)

  B.  File data

      Immediately following the local header for a file
      is the compressed or stored data for the file.
      The series of [local file header][file data][data
      descriptor] repeats for each file in the .ZIP archive.

  C.  Data descriptor:

        crc-32                          4 bytes
        compressed size                 4 bytes
        uncompressed size               4 bytes

      This descriptor exists only if bit 3 of the general
      purpose bit flag is set (see below).  It is byte aligned
      and immediately follows the last byte of compressed data.
      This descriptor is used only when it was not possible to
      seek in the output .ZIP file, e.g., when the output .ZIP file
      was standard output or a non-seekable device.  For ZIP64(tm) format
      archives, the compressed and uncompressed sizes are 8 bytes each.

      When compressing files, compressed and uncompressed sizes
      should be stored in ZIP64 format (as 8 byte values) when a
      files size exceeds 0xFFFFFFFF.   However ZIP64 format may be
      used regardless of the size of a file.  When extracting, if
      the zip64 extended information extra field is present for
      the file the compressed and uncompressed sizes will be 8
      byte values.

      Although not originally assigned a signature, the value
      0x08074b50 has commonly been adopted as a signature value
      for the data descriptor record.  Implementers should be
      aware that ZIP files may be encountered with or without this
      signature marking data descriptors and should account for
      either case when reading ZIP files to ensure compatibility.
      When writing ZIP files, it is recommended to include the
      signature value marking the data descriptor record.  When
      the signature is used, the fields currently defined for
      the data descriptor record will immediately follow the
      signature.

      An extensible data descriptor will be released in a future
      version of this APPNOTE.  This new record is intended to
      resolve conflicts with the use of this record going forward,
      and to provide better support for streamed file processing.

      When the Central Directory Encryption method is used, the data
      descriptor record is not required, but may be used.  If present,
      and bit 3 of the general purpose bit field is set to indicate
      its presence, the values in fields of the data descriptor
      record should be set to binary zeros.

  D.  Archive decryption header:

      The Archive Decryption Header is introduced in version 6.2
      of the ZIP format specification.  This record exists in support
      of the Central Directory Encryption Feature implemented as part of
      the Strong Encryption Specification as described in this document.
      When the Central Directory Structure is encrypted, this decryption
      header will precede the encrypted data segment.  The encrypted
      data segment will consist of the Archive extra data record (if
      present) and the encrypted Central Directory Structure data.
      The format of this data record is identical to the Decryption
      header record preceding compressed file data.  If the central
      directory structure is encrypted, the location of the start of
      this data record is determined using the Start of Central Directory
      field in the Zip64 End of Central Directory record.  Refer to the
      section on the Strong Encryption Specification for information
      on the fields used in the Archive Decryption Header record.


  E.  Archive extra data record:

        archive extra data signature    4 bytes  (0x08064b50)
        extra field length              4 bytes
        extra field data                (variable size)

      The Archive Extra Data Record is introduced in version 6.2
      of the ZIP format specification.  This record exists in support
      of the Central Directory Encryption Feature implemented as part of
      the Strong Encryption Specification as described in this document.
      When present, this record immediately precedes the central
      directory data structure.  The size of this data record will be
      included in the Size of the Central Directory field in the
      End of Central Directory record.  If the central directory structure
      is compressed, but not encrypted, the location of the start of
      this data record is determined using the Start of Central Directory
      field in the Zip64 End of Central Directory record.


  F.  Central directory structure:

      [file header 1]
      .
      .
      .
      [file header n]
      [digital signature]

      File header:

        central file header signature   4 bytes  (0x02014b50)
        version made by                 2 bytes
        version needed to extract       2 bytes
        general purpose bit flag        2 bytes
        compression method              2 bytes
        last mod file time              2 bytes
        last mod file date              2 bytes
        crc-32                          4 bytes
        compressed size                 4 bytes
        uncompressed size               4 bytes
        file name length                2 bytes
        extra field length              2 bytes
        file comment length             2 bytes
        disk number start               2 bytes
        internal file attributes        2 bytes
        external file attributes        4 bytes
        relative offset of local header 4 bytes

        file name (variable size)
        extra field (variable size)
        file comment (variable size)

      Digital signature:

        header signature                4 bytes  (0x05054b50)
        size of data                    2 bytes
        signature data (variable size)

      With the introduction of the Central Directory Encryption
      feature in version 6.2 of this specification, the Central
      Directory Structure may be stored both compressed and encrypted.
      Although not required, it is assumed when encrypting the
      Central Directory Structure, that it will be compressed
      for greater storage efficiency.  Information on the
      Central Directory Encryption feature can be found in the section
      describing the Strong Encryption Specification. The Digital
      Signature record will be neither compressed nor encrypted.

  G.  Zip64 end of central directory record

        zip64 end of central dir
        signature                       4 bytes  (0x06064b50)
        size of zip64 end of central
        directory record                8 bytes
        version made by                 2 bytes
        version needed to extract       2 bytes
        number of this disk             4 bytes
        number of the disk with the
        start of the central directory  4 bytes
        total number of entries in the
        central directory on this disk  8 bytes
        total number of entries in the
        central directory               8 bytes
        size of the central directory   8 bytes
        offset of start of central
        directory with respect to
        the starting disk number        8 bytes
        zip64 extensible data sector    (variable size)

        The value stored into the "size of zip64 end of central
        directory record" should be the size of the remaining
        record and should not include the leading 12 bytes.

        Size = SizeOfFixedFields + SizeOfVariableData - 12.

        The above record structure defines Version 1 of the
        zip64 end of central directory record. Version 1 was
        implemented in versions of this specification preceding
        6.2 in support of the ZIP64 large file feature. The
        introduction of the Central Directory Encryption feature
        implemented in version 6.2 as part of the Strong Encryption
        Specification defines Version 2 of this record structure.
        Refer to the section describing the Strong Encryption
        Specification for details on the version 2 format for
        this record.

        Special purpose data may reside in the zip64 extensible data
        sector field following either a V1 or V2 version of this
        record.  To ensure identification of this special purpose data
        it must include an identifying header block consisting of the
        following:

           Header ID  -  2 bytes
           Data Size  -  4 bytes

        The Header ID field indicates the type of data that is in the
        data block that follows.

        Data Size identifies the number of bytes that follow for this
        data block type.

        Multiple special purpose data blocks may be present, but each
        must be preceded by a Header ID and Data Size field.  Current
        mappings of Header ID values supported in this field are as
        defined in APPENDIX C.

  H.  Zip64 end of central directory locator

        zip64 end of central dir locator
        signature                       4 bytes  (0x07064b50)
        number of the disk with the
        start of the zip64 end of
        central directory               4 bytes
        relative offset of the zip64
        end of central directory record 8 bytes
        total number of disks           4 bytes

  I.  End of central directory record:

        end of central dir signature    4 bytes  (0x06054b50)
        number of this disk             2 bytes
        number of the disk with the
        start of the central directory  2 bytes
        total number of entries in the
        central directory on this disk  2 bytes
        total number of entries in
        the central directory           2 bytes
        size of the central directory   4 bytes
        offset of start of central
        directory with respect to
        the starting disk number        4 bytes
        .ZIP file comment length        2 bytes
        .ZIP file comment       (variable size)

  J.  Explanation of fields:

      version made by (2 bytes)

          The upper byte indicates the compatibility of the file
          attribute information.  If the external file attributes
          are compatible with MS-DOS and can be read by PKZIP for
          DOS version 2.04g then this value will be zero.  If these
          attributes are not compatible, then this value will
          identify the host system on which the attributes are
          compatible.  Software can use this information to determine
          the line record format for text files etc.  The current
          mappings are:

          0 - MS-DOS and OS/2 (FAT / VFAT / FAT32 file systems)
          1 - Amiga                     2 - OpenVMS
          3 - UNIX                      4 - VM/CMS
          5 - Atari ST                  6 - OS/2 H.P.F.S.
          7 - Macintosh                 8 - Z-System
          9 - CP/M                     10 - Windows NTFS
         11 - MVS (OS/390 - Z/OS)      12 - VSE
         13 - Acorn Risc               14 - VFAT
         15 - alternate MVS            16 - BeOS
         17 - Tandem                   18 - OS/400
         19 - OS/X (Darwin)            20 thru 255 - unused

          The lower byte indicates the ZIP specification version
          (the version of this document) supported by the software
          used to encode the file.  The value/10 indicates the major
          version number, and the value mod 10 is the minor version
          number.

      version needed to extract (2 bytes)

          The minimum supported ZIP specification version needed to
          extract the file, mapped as above.  This value is based on
          the specific format features a ZIP program must support to
          be able to extract the file.  If multiple features are
          applied to a file, the minimum version should be set to the
          feature having the highest value. New features or feature
          changes affecting the published format specification will be
          implemented using higher version numbers than the last
          published value to avoid conflict.

          Current minimum feature versions are as defined below:

          1.0 - Default value
          1.1 - File is a volume label
          2.0 - File is a folder (directory)
          2.0 - File is compressed using Deflate compression
          2.0 - File is encrypted using traditional PKWARE encryption
          2.1 - File is compressed using Deflate64(tm)
          2.5 - File is compressed using PKWARE DCL Implode
          2.7 - File is a patch data set
          4.5 - File uses ZIP64 format extensions
          4.6 - File is compressed using BZIP2 compression*
          5.0 - File is encrypted using DES
          5.0 - File is encrypted using 3DES
          5.0 - File is encrypted using original RC2 encryption
          5.0 - File is encrypted using RC4 encryption
          5.1 - File is encrypted using AES encryption
          5.1 - File is encrypted using corrected RC2 encryption**
          5.2 - File is encrypted using corrected RC2-64 encryption**
          6.1 - File is encrypted using non-OAEP key wrapping***
          6.2 - Central directory encryption
          6.3 - File is compressed using LZMA
          6.3 - File is compressed using PPMd+
          6.3 - File is encrypted using Blowfish
          6.3 - File is encrypted using Twofish


          * Early 7.x (pre-7.2) versions of PKZIP incorrectly set the
          version needed to extract for BZIP2 compression to be 50
          when it should have been 46.

          ** Refer to the section on Strong Encryption Specification
          for additional information regarding RC2 corrections.

          *** Certificate encryption using non-OAEP key wrapping is the
          intended mode of operation for all versions beginning with 6.1.
          Support for OAEP key wrapping should only be used for
          backward compatibility when sending ZIP files to be opened by
          versions of PKZIP older than 6.1 (5.0 or 6.0).

          + Files compressed using PPMd should set the version
          needed to extract field to 6.3, however, not all ZIP
          programs enforce this and may be unable to decompress
          data files compressed using PPMd if this value is set.

          When using ZIP64 extensions, the corresponding value in the
          zip64 end of central directory record should also be set.
          This field should be set appropriately to indicate whether
          Version 1 or Version 2 format is in use.

      general purpose bit flag: (2 bytes)

          Bit 0: If set, indicates that the file is encrypted.

          (For Method 6 - Imploding)
          Bit 1: If the compression method used was type 6,
                 Imploding, then this bit, if set, indicates
                 an 8K sliding dictionary was used.  If clear,
                 then a 4K sliding dictionary was used.
          Bit 2: If the compression method used was type 6,
                 Imploding, then this bit, if set, indicates
                 3 Shannon-Fano trees were used to encode the
                 sliding dictionary output.  If clear, then 2
                 Shannon-Fano trees were used.

          (For Methods 8 and 9 - Deflating)
          Bit 2  Bit 1
            0      0    Normal (-en) compression option was used.
            0      1    Maximum (-exx/-ex) compression option was used.
            1      0    Fast (-ef) compression option was used.
            1      1    Super Fast (-es) compression option was used.

          (For Method 14 - LZMA)
          Bit 1: If the compression method used was type 14,
                 LZMA, then this bit, if set, indicates
                 an end-of-stream (EOS) marker is used to
                 mark the end of the compressed data stream.
                 If clear, then an EOS marker is not present
                 and the compressed data size must be known
                 to extract.

          Note:  Bits 1 and 2 are undefined if the compression
                 method is any other.

          Bit 3: If this bit is set, the fields crc-32, compressed
                 size and uncompressed size are set to zero in the
                 local header.  The correct values are put in the
                 data descriptor immediately following the compressed
                 data.  (Note: PKZIP version 2.04g for DOS only
                 recognizes this bit for method 8 compression, newer
                 versions of PKZIP recognize this bit for any
                 compression method.)

          Bit 4: Reserved for use with method 8, for enhanced
                 deflating.

          Bit 5: If this bit is set, this indicates that the file is
                 compressed patched data.  (Note: Requires PKZIP
                 version 2.70 or greater)

          Bit 6: Strong encryption.  If this bit is set, you should
                 set the version needed to extract value to at least
                 50 and you must also set bit 0.  If AES encryption
                 is used, the version needed to extract value must
                 be at least 51.

          Bit 7: Currently unused.

          Bit 8: Currently unused.

          Bit 9: Currently unused.

          Bit 10: Currently unused.

          Bit 11: Language encoding flag (EFS).  If this bit is set,
                  the filename and comment fields for this file
                  must be encoded using UTF-8. (see APPENDIX D)

          Bit 12: Reserved by PKWARE for enhanced compression.

          Bit 13: Used when encrypting the Central Directory to indicate
                  selected data values in the Local Header are masked to
                  hide their actual values.  See the section describing
                  the Strong Encryption Specification for details.

          Bit 14: Reserved by PKWARE.

          Bit 15: Reserved by PKWARE.

      compression method: (2 bytes)

          (see accompanying documentation for algorithm
          descriptions)

          0 - The file is stored (no compression)
          1 - The file is Shrunk
          2 - The file is Reduced with compression factor 1
          3 - The file is Reduced with compression factor 2
          4 - The file is Reduced with compression factor 3
          5 - The file is Reduced with compression factor 4
          6 - The file is Imploded
          7 - Reserved for Tokenizing compression algorithm
          8 - The file is Deflated
          9 - Enhanced Deflating using Deflate64(tm)
         10 - PKWARE Data Compression Library Imploding (old IBM TERSE)
         11 - Reserved by PKWARE
         12 - File is compressed using BZIP2 algorithm
         13 - Reserved by PKWARE
         14 - LZMA (EFS)
         15 - Reserved by PKWARE
         16 - Reserved by PKWARE
         17 - Reserved by PKWARE
         18 - File is compressed using IBM TERSE (new)
         19 - IBM LZ77 z Architecture (PFS)
         97 - WavPack compressed data
         98 - PPMd version I, Rev 1

      date and time fields: (2 bytes each)

          The date and time are encoded in standard MS-DOS format.
          If input came from standard input, the date and time are
          those at which compression was started for this data.
          If encrypting the central directory and general purpose bit
          flag 13 is set indicating masking, the value stored in the
          Local Header will be zero.

      CRC-32: (4 bytes)

          The CRC-32 algorithm was generously contributed by
          David Schwaderer and can be found in his excellent
          book "C Programmers Guide to NetBIOS" published by
          Howard W. Sams & Co. Inc.  The 'magic number' for
          the CRC is 0xdebb20e3.  The proper CRC pre and post
          conditioning is used, meaning that the CRC register
          is pre-conditioned with all ones (a starting value
          of 0xffffffff) and the value is post-conditioned by
          taking the one's complement of the CRC residual.
          If bit 3 of the general purpose flag is set, this
          field is set to zero in the local header and the correct
          value is put in the data descriptor and in the central
          directory. When encrypting the central directory, if the
          local header is not in ZIP64 format and general purpose
          bit flag 13 is set indicating masking, the value stored
          in the Local Header will be zero.

      compressed size: (4 bytes)
      uncompressed size: (4 bytes)

          The size of the file compressed and uncompressed,
          respectively.  When a decryption header is present it will
          be placed in front of the file data and the value of the
          compressed file size will include the bytes of the decryption
          header.  If bit 3 of the general purpose bit flag is set,
          these fields are set to zero in the local header and the
          correct values are put in the data descriptor and
          in the central directory.  If an archive is in ZIP64 format
          and the value in this field is 0xFFFFFFFF, the size will be
          in the corresponding 8 byte ZIP64 extended information
          extra field.  When encrypting the central directory, if the
          local header is not in ZIP64 format and general purpose bit
          flag 13 is set indicating masking, the value stored for the
          uncompressed size in the Local Header will be zero.

      file name length: (2 bytes)
      extra field length: (2 bytes)
      file comment length: (2 bytes)

          The length of the file name, extra field, and comment
          fields respectively.  The combined length of any
          directory record and these three fields should not
          generally exceed 65,535 bytes.  If input came from standard
          input, the file name length is set to zero.

      disk number start: (2 bytes)

          The number of the disk on which this file begins.  If an
          archive is in ZIP64 format and the value in this field is
          0xFFFF, the size will be in the corresponding 4 byte zip64
          extended information extra field.

      internal file attributes: (2 bytes)

          Bits 1 and 2 are reserved for use by PKWARE.

          The lowest bit of this field indicates, if set, that
          the file is apparently an ASCII or text file.  If not
          set, that the file apparently contains binary data.
          The remaining bits are unused in version 1.0.

          The 0x0002 bit of this field indicates, if set, that a
          4 byte variable record length control field precedes each
          logical record indicating the length of the record. The
          record length control field is stored in little-endian byte
          order.  This flag is independent of text control characters,
          and if used in conjunction with text data, includes any
          control characters in the total length of the record. This
          value is provided for mainframe data transfer support.

      external file attributes: (4 bytes)

          The mapping of the external attributes is
          host-system dependent (see 'version made by').  For
          MS-DOS, the low order byte is the MS-DOS directory
          attribute byte.  If input came from standard input, this
          field is set to zero.

      relative offset of local header: (4 bytes)

          This is the offset from the start of the first disk on
          which this file appears, to where the local header should
          be found.  If an archive is in ZIP64 format and the value
          in this field is 0xFFFFFFFF, the size will be in the
          corresponding 8 byte zip64 extended information extra field.

      file name: (Variable)

          The name of the file, with optional relative path.
          The path stored should not contain a drive or
          device letter, or a leading slash.  All slashes
          should be forward slashes '/' as opposed to
          backwards slashes '\' for compatibility with Amiga
          and UNIX file systems etc.  If input came from standard
          input, there is no file name field.  If encrypting
          the central directory and general purpose bit flag 13 is set
          indicating masking, the file name stored in the Local Header
          will not be the actual file name.  A masking value consisting
          of a unique hexadecimal value will be stored.  This value will
          be sequentially incremented for each file in the archive. See
          the section on the Strong Encryption Specification for details
          on retrieving the encrypted file name.

      extra field: (Variable)

          This is for expansion.  If additional information
          needs to be stored for special needs or for specific
          platforms, it should be stored here.  Earlier versions
          of the software can then safely skip this file, and
          find the next file or header.  This field will be 0
          length in version 1.0.

          In order to allow different programs and different types
          of information to be stored in the 'extra' field in .ZIP
          files, the following structure should be used for all
          programs storing data in this field:

          header1+data1 + header2+data2 . . .

          Each header should consist of:

            Header ID - 2 bytes
            Data Size - 2 bytes

          Note: all fields stored in Intel low-byte/high-byte order.

          The Header ID field indicates the type of data that is in
          the following data block.

          Header ID's of 0 thru 31 are reserved for use by PKWARE.
          The remaining ID's can be used by third party vendors for
          proprietary usage.

          The current Header ID mappings defined by PKWARE are:

          0x0001        Zip64 extended information extra field
          0x0007        AV Info
          0x0008        Reserved for extended language encoding data (PFS)
                        (see APPENDIX D)
          0x0009        OS/2
          0x000a        NTFS
          0x000c        OpenVMS
          0x000d        UNIX
          0x000e        Reserved for file stream and fork descriptors
          0x000f        Patch Descriptor
          0x0014        PKCS#7 Store for X.509 Certificates
          0x0015        X.509 Certificate ID and Signature for
                        individual file
          0x0016        X.509 Certificate ID for Central Directory
          0x0017        Strong Encryption Header
          0x0018        Record Management Controls
          0x0019        PKCS#7 Encryption Recipient Certificate List
          0x0065        IBM S/390 (Z390), AS/400 (I400) attributes
                        - uncompressed
          0x0066        Reserved for IBM S/390 (Z390), AS/400 (I400)
                        attributes - compressed
          0x4690        POSZIP 4690 (reserved)

          Third party mappings commonly used are:


          0x07c8        Macintosh
          0x2605        ZipIt Macintosh
          0x2705        ZipIt Macintosh 1.3.5+
          0x2805        ZipIt Macintosh 1.3.5+
          0x334d        Info-ZIP Macintosh
          0x4341        Acorn/SparkFS
          0x4453        Windows NT security descriptor (binary ACL)
          0x4704        VM/CMS
          0x470f        MVS
          0x4b46        FWKCS MD5 (see below)
          0x4c41        OS/2 access control list (text ACL)
          0x4d49        Info-ZIP OpenVMS
          0x4f4c        Xceed original location extra field
          0x5356        AOS/VS (ACL)
          0x5455        extended timestamp
          0x554e        Xceed unicode extra field
          0x5855        Info-ZIP UNIX (original, also OS/2, NT, etc)
          0x6375        Info-ZIP Unicode Comment Extra Field
          0x6542        BeOS/BeBox
          0x7075        Info-ZIP Unicode Path Extra Field
          0x756e        ASi UNIX
          0x7855        Info-ZIP UNIX (new)
          0xa220        Microsoft Open Packaging Growth Hint
          0xfd4a        SMS/QDOS

          Detailed descriptions of Extra Fields defined by third
          party mappings will be documented as information on
          these data structures is made available to PKWARE.
          PKWARE does not guarantee the accuracy of any published
          third party data.

          The Data Size field indicates the size of the following
          data block. Programs can use this value to skip to the
          next header block, passing over any data blocks that are
          not of interest.

          Note: As stated above, the size of the entire .ZIP file
                header, including the file name, comment, and extra
                field should not exceed 64K in size.

          In case two different programs should appropriate the same
          Header ID value, it is strongly recommended that each
          program place a unique signature of at least two bytes in
          size (and preferably 4 bytes or bigger) at the start of
          each data area.  Every program should verify that its
          unique signature is present, in addition to the Header ID
          value being correct, before assuming that it is a block of
          known type.

         -Zip64 Extended Information Extra Field (0x0001):

          The following is the layout of the zip64 extended
          information "extra" block. If one of the size or
          offset fields in the Local or Central directory
          record is too small to hold the required data,
          a Zip64 extended information record is created.
          The order of the fields in the zip64 extended
          information record is fixed, but the fields will
          only appear if the corresponding Local or Central
          directory record field is set to 0xFFFF or 0xFFFFFFFF.

          Note: all fields stored in Intel low-byte/high-byte order.

          Value      Size       Description
          -----      ----       -----------
  (ZIP64) 0x0001     2 bytes    Tag for this "extra" block type
          Size       2 bytes    Size of this "extra" block
          Original
          Size       8 bytes    Original uncompressed file size
          Compressed
          Size       8 bytes    Size of compressed data
          Relative Header
          Offset     8 bytes    Offset of local header record
          Disk Start
          Number     4 bytes    Number of the disk on which
                                this file starts

          This entry in the Local header must include BOTH original
          and compressed file size fields. If encrypting the
          central directory and bit 13 of the general purpose bit
          flag is set indicating masking, the value stored in the
          Local Header for the original file size will be zero.


         -OS/2 Extra Field (0x0009):

          The following is the layout of the OS/2 attributes "extra"
          block.  (Last Revision  09/05/95)

          Note: all fields stored in Intel low-byte/high-byte order.

          Value       Size          Description
          -----       ----          -----------
  (OS/2)  0x0009      2 bytes       Tag for this "extra" block type
          TSize       2 bytes       Size for the following data block
          BSize       4 bytes       Uncompressed Block Size
          CType       2 bytes       Compression type
          EACRC       4 bytes       CRC value for uncompress block
          (var)       variable      Compressed block

          The OS/2 extended attribute structure (FEA2LIST) is
          compressed and then stored in it's entirety within this
          structure.  There will only ever be one "block" of data in
          VarFields[].

         -NTFS Extra Field (0x000a):

          The following is the layout of the NTFS attributes
          "extra" block. (Note: At this time the Mtime, Atime
          and Ctime values may be used on any WIN32 system.)

          Note: all fields stored in Intel low-byte/high-byte order.

          Value      Size       Description
          -----      ----       -----------
  (NTFS)  0x000a     2 bytes    Tag for this "extra" block type
          TSize      2 bytes    Size of the total "extra" block
          Reserved   4 bytes    Reserved for future use
          Tag1       2 bytes    NTFS attribute tag value #1
          Size1      2 bytes    Size of attribute #1, in bytes
          (var.)     Size1      Attribute #1 data
          .
          .
          .
          TagN       2 bytes    NTFS attribute tag value #N
          SizeN      2 bytes    Size of attribute #N, in bytes
          (var.)     SizeN      Attribute #N data

          For NTFS, values for Tag1 through TagN are as follows:
          (currently only one set of attributes is defined for NTFS)

          Tag        Size       Description
          -----      ----       -----------
          0x0001     2 bytes    Tag for attribute #1
          Size1      2 bytes    Size of attribute #1, in bytes
          Mtime      8 bytes    File last modification time
          Atime      8 bytes    File last access time
          Ctime      8 bytes    File creation time

         -OpenVMS Extra Field (0x000c):

          The following is the layout of the OpenVMS attributes
          "extra" block.

          Note: all fields stored in Intel low-byte/high-byte order.

          Value      Size       Description
          -----      ----       -----------
  (VMS)   0x000c     2 bytes    Tag for this "extra" block type
          TSize      2 bytes    Size of the total "extra" block
          CRC        4 bytes    32-bit CRC for remainder of the block
          Tag1       2 bytes    OpenVMS attribute tag value #1
          Size1      2 bytes    Size of attribute #1, in bytes
          (var.)     Size1      Attribute #1 data
          .
          .
          .
          TagN       2 bytes    OpenVMS attribute tag value #N
          SizeN      2 bytes    Size of attribute #N, in bytes
          (var.)     SizeN      Attribute #N data

          Rules:

          1. There will be one or more of attributes present, which
             will each be preceded by the above TagX & SizeX values.
             These values are identical to the ATR$C_XXXX and
             ATR$S_XXXX constants which are defined in ATR.H under
             OpenVMS C.  Neither of these values will ever be zero.

          2. No word alignment or padding is performed.

          3. A well-behaved PKZIP/OpenVMS program should never produce
             more than one sub-block with the same TagX value.  Also,
             there will never be more than one "extra" block of type
             0x000c in a particular directory record.

         -UNIX Extra Field (0x000d):

          The following is the layout of the UNIX "extra" block.
          Note: all fields are stored in Intel low-byte/high-byte
          order.

          Value       Size          Description
          -----       ----          -----------
  (UNIX)  0x000d      2 bytes       Tag for this "extra" block type
          TSize       2 bytes       Size for the following data block
          Atime       4 bytes       File last access time
          Mtime       4 bytes       File last modification time
          Uid         2 bytes       File user ID
          Gid         2 bytes       File group ID
          (var)       variable      Variable length data field

          The variable length data field will contain file type
          specific data.  Currently the only values allowed are
          the original "linked to" file names for hard or symbolic
          links, and the major and minor device node numbers for
          character and block device nodes.  Since device nodes
          cannot be either symbolic or hard links, only one set of
          variable length data is stored.  Link files will have the
          name of the original file stored.  This name is NOT NULL
          terminated.  Its size can be determined by checking TSize -
          12.  Device entries will have eight bytes stored as two 4
          byte entries (in little endian format).  The first entry
          will be the major device number, and the second the minor
          device number.

         -PATCH Descriptor Extra Field (0x000f):

          The following is the layout of the Patch Descriptor "extra"
          block.

          Note: all fields stored in Intel low-byte/high-byte order.

          Value     Size     Description
          -----     ----     -----------
  (Patch) 0x000f    2 bytes  Tag for this "extra" block type
          TSize     2 bytes  Size of the total "extra" block
          Version   2 bytes  Version of the descriptor
          Flags     4 bytes  Actions and reactions (see below)
          OldSize   4 bytes  Size of the file about to be patched
          OldCRC    4 bytes  32-bit CRC of the file to be patched
          NewSize   4 bytes  Size of the resulting file
          NewCRC    4 bytes  32-bit CRC of the resulting file

          Actions and reactions

          Bits          Description
          ----          ----------------
          0             Use for auto detection
          1             Treat as a self-patch
          2-3           RESERVED
          4-5           Action (see below)
          6-7           RESERVED
          8-9           Reaction (see below) to absent file
          10-11         Reaction (see below) to newer file
          12-13         Reaction (see below) to unknown file
          14-15         RESERVED
          16-31         RESERVED

          Actions

          Action       Value
          ------       -----
          none         0
          add          1
          delete       2
          patch        3

          Reactions

          Reaction     Value
          --------     -----
          ask          0
          skip         1
          ignore       2
          fail         3

          Patch support is provided by PKPatchMaker(tm) technology and is
          covered under U.S. Patents and Patents Pending. The use or
          implementation in a product of certain technological aspects set
          forth in the current APPNOTE, including those with regard to
          strong encryption, patching, or extended tape operations requires
          a license from PKWARE.  Please contact PKWARE with regard to
          acquiring a license.

         -PKCS#7 Store for X.509 Certificates (0x0014):

          This field contains information about each of the certificates
          files may be signed with. When the Central Directory Encryption
          feature is enabled for a ZIP file, this record will appear in
          the Archive Extra Data Record, otherwise it will appear in the
          first central directory record and will be ignored in any
          other record.

          Note: all fields stored in Intel low-byte/high-byte order.

          Value     Size     Description
          -----     ----     -----------
  (Store) 0x0014    2 bytes  Tag for this "extra" block type
          TSize     2 bytes  Size of the store data
          TData     TSize    Data about the store


         -X.509 Certificate ID and Signature for individual file (0x0015):

          This field contains the information about which certificate in
          the PKCS#7 store was used to sign a particular file. It also
          contains the signature data. This field can appear multiple
          times, but can only appear once per certificate.

          Note: all fields stored in Intel low-byte/high-byte order.

          Value     Size     Description
          -----     ----     -----------
  (CID)   0x0015    2 bytes  Tag for this "extra" block type
          TSize     2 bytes  Size of data that follows
          TData     TSize    Signature Data

         -X.509 Certificate ID and Signature for central directory (0x0016):

          This field contains the information about which certificate in
          the PKCS#7 store was used to sign the central directory structure.
          When the Central Directory Encryption feature is enabled for a
          ZIP file, this record will appear in the Archive Extra Data Record,
          otherwise it will appear in the first central directory record.

          Note: all fields stored in Intel low-byte/high-byte order.

          Value     Size     Description
          -----     ----     -----------
  (CDID)  0x0016    2 bytes  Tag for this "extra" block type
          TSize     2 bytes  Size of data that follows
          TData     TSize    Data

         -Strong Encryption Header (0x0017):

          Value     Size     Description
          -----     ----     -----------
          0x0017    2 bytes  Tag for this "extra" block type
          TSize     2 bytes  Size of data that follows
          Format    2 bytes  Format definition for this record
          AlgID     2 bytes  Encryption algorithm identifier
          Bitlen    2 bytes  Bit length of encryption key
          Flags     2 bytes  Processing flags
          CertData  TSize-8  Certificate decryption extra field data
                             (refer to the explanation for CertData
                              in the section describing the
                              Certificate Processing Method under
                              the Strong Encryption Specification)


         -Record Management Controls (0x0018):

          Value     Size     Description
          -----     ----     -----------
(Rec-CTL) 0x0018    2 bytes  Tag for this "extra" block type
          CSize     2 bytes  Size of total extra block data
          Tag1      2 bytes  Record control attribute 1
          Size1     2 bytes  Size of attribute 1, in bytes
          Data1     Size1    Attribute 1 data
            .
            .
            .
          TagN      2 bytes  Record control attribute N
          SizeN     2 bytes  Size of attribute N, in bytes
          DataN     SizeN    Attribute N data


         -PKCS#7 Encryption Recipient Certificate List (0x0019):

          This field contains information about each of the certificates
          used in encryption processing and it can be used to identify who is
          allowed to decrypt encrypted files.  This field should only appear
          in the archive extra data record. This field is not required and
          serves only to aide archive modifications by preserving public
          encryption key data. Individual security requirements may dictate
          that this data be omitted to deter information exposure.

          Note: all fields stored in Intel low-byte/high-byte order.

          Value     Size     Description
          -----     ----     -----------
 (CStore) 0x0019    2 bytes  Tag for this "extra" block type
          TSize     2 bytes  Size of the store data
          TData     TSize    Data about the store

          TData:

          Value     Size     Description
          -----     ----     -----------
          Version   2 bytes  Format version number - must 0x0001 at this time
          CStore    (var)    PKCS#7 data blob


         -MVS Extra Field (0x0065):

          The following is the layout of the MVS "extra" block.
          Note: Some fields are stored in Big Endian format.
          All text is in EBCDIC format unless otherwise specified.

          Value       Size          Description
          -----       ----          -----------
  (MVS)   0x0065      2 bytes       Tag for this "extra" block type
          TSize       2 bytes       Size for the following data block
          ID          4 bytes       EBCDIC "Z390" 0xE9F3F9F0 or
                                    "T4MV" for TargetFour
          (var)       TSize-4       Attribute data (see APPENDIX B)


         -OS/400 Extra Field (0x0065):

          The following is the layout of the OS/400 "extra" block.
          Note: Some fields are stored in Big Endian format.
          All text is in EBCDIC format unless otherwise specified.

          Value       Size          Description
          -----       ----          -----------
  (OS400) 0x0065      2 bytes       Tag for this "extra" block type
          TSize       2 bytes       Size for the following data block
          ID          4 bytes       EBCDIC "I400" 0xC9F4F0F0 or
                                    "T4MV" for TargetFour
          (var)       TSize-4       Attribute data (see APPENDIX A)


          Third-party Mappings:

         -ZipIt Macintosh Extra Field (long) (0x2605):

          The following is the layout of the ZipIt extra block
          for Macintosh. The local-header and central-header versions
          are identical. This block must be present if the file is
          stored MacBinary-encoded and it should not be used if the file
          is not stored MacBinary-encoded.

          Value         Size        Description
          -----         ----        -----------
  (Mac2)  0x2605        Short       tag for this extra block type
          TSize         Short       total data size for this block
          "ZPIT"        beLong      extra-field signature
          FnLen         Byte        length of FileName
          FileName      variable    full Macintosh filename
          FileType      Byte[4]     four-byte Mac file type string
          Creator       Byte[4]     four-byte Mac creator string


         -ZipIt Macintosh Extra Field (short, for files) (0x2705):

          The following is the layout of a shortened variant of the
          ZipIt extra block for Macintosh (without "full name" entry).
          This variant is used by ZipIt 1.3.5 and newer for entries of
          files (not directories) that do not have a MacBinary encoded
          file. The local-header and central-header versions are identical.

          Value         Size        Description
          -----         ----        -----------
  (Mac2b) 0x2705        Short       tag for this extra block type
          TSize         Short       total data size for this block (12)
          "ZPIT"        beLong      extra-field signature
          FileType      Byte[4]     four-byte Mac file type string
          Creator       Byte[4]     four-byte Mac creator string
          fdFlags       beShort     attributes from FInfo.frFlags,
                                    may be omitted
          0x0000        beShort     reserved, may be omitted


         -ZipIt Macintosh Extra Field (short, for directories) (0x2805):

          The following is the layout of a shortened variant of the
          ZipIt extra block for Macintosh used only for directory
          entries. This variant is used by ZipIt 1.3.5 and newer to
          save some optional Mac-specific information about directories.
          The local-header and central-header versions are identical.

          Value         Size        Description
          -----         ----        -----------
  (Mac2c) 0x2805        Short       tag for this extra block type
          TSize         Short       total data size for this block (12)
          "ZPIT"        beLong      extra-field signature
          frFlags       beShort     attributes from DInfo.frFlags, may
                                    be omitted
          View          beShort     ZipIt view flag, may be omitted


          The View field specifies ZipIt-internal settings as follows:

          Bits of the Flags:
              bit 0           if set, the folder is shown expanded (open)
                              when the archive contents are viewed in ZipIt.
              bits 1-15       reserved, zero;


         -FWKCS MD5 Extra Field (0x4b46):

          The FWKCS Contents_Signature System, used in
          automatically identifying files independent of file name,
          optionally adds and uses an extra field to support the
          rapid creation of an enhanced contents_signature:

              Header ID = 0x4b46
              Data Size = 0x0013
              Preface   = 'M','D','5'
              followed by 16 bytes containing the uncompressed file's
              128_bit MD5 hash(1), low byte first.

          When FWKCS revises a .ZIP file central directory to add
          this extra field for a file, it also replaces the
          central directory entry for that file's uncompressed
          file length with a measured value.

          FWKCS provides an option to strip this extra field, if
          present, from a .ZIP file central directory. In adding
          this extra field, FWKCS preserves .ZIP file Authenticity
          Verification; if stripping this extra field, FWKCS
          preserves all versions of AV through PKZIP version 2.04g.

          FWKCS, and FWKCS Contents_Signature System, are
          trademarks of Frederick W. Kantor.

          (1) R. Rivest, RFC1321.TXT, MIT Laboratory for Computer
              Science and RSA Data Security, Inc., April 1992.
              ll.76-77: "The MD5 algorithm is being placed in the
              public domain for review and possible adoption as a
              standard."


         -Info-ZIP Unicode Comment Extra Field (0x6375):

          Stores the UTF-8 version of the file comment as stored in the
          central directory header. (Last Revision 20070912)

          Value         Size        Description
          -----         ----        -----------
   (UCom) 0x6375        Short       tag for this extra block type ("uc")
          TSize         Short       total data size for this block
          Version       1 byte      version of this extra field, currently 1
          ComCRC32      4 bytes     Comment Field CRC32 Checksum
          UnicodeCom    Variable    UTF-8 version of the entry comment

          Currently Version is set to the number 1.  If there is a need
          to change this field, the version will be incremented.  Changes
          may not be backward compatible so this extra field should not be
          used if the version is not recognized.

          The ComCRC32 is the standard zip CRC32 checksum of the File Comment
          field in the central directory header.  This is used to verify that
          the comment field has not changed since the Unicode Comment extra field
          was created.  This can happen if a utility changes the File Comment
          field but does not update the UTF-8 Comment extra field.  If the CRC
          check fails, this Unicode Comment extra field should be ignored and
          the File Comment field in the header should be used instead.

          The UnicodeCom field is the UTF-8 version of the File Comment field
          in the header.  As UnicodeCom is defined to be UTF-8, no UTF-8 byte
          order mark (BOM) is used.  The length of this field is determined by
          subtracting the size of the previous fields from TSize.  If both the
          File Name and Comment fields are UTF-8, the new General Purpose Bit
          Flag, bit 11 (Language encoding flag (EFS)), can be used to indicate
          both the header File Name and Comment fields are UTF-8 and, in this
          case, the Unicode Path and Unicode Comment extra fields are not
          needed and should not be created.  Note that, for backward
          compatibility, bit 11 should only be used if the native character set
          of the paths and comments being zipped up are already in UTF-8. It is
          expected that the same file comment storage method, either general
          purpose bit 11 or extra fields, be used in both the Local and Central
          Directory Header for a file.


         -Info-ZIP Unicode Path Extra Field (0x7075):

          Stores the UTF-8 version of the file name field as stored in the
          local header and central directory header. (Last Revision 20070912)

          Value         Size        Description
          -----         ----        -----------
  (UPath) 0x7075        Short       tag for this extra block type ("up")
          TSize         Short       total data size for this block
          Version       1 byte      version of this extra field, currently 1
          NameCRC32     4 bytes     File Name Field CRC32 Checksum
          UnicodeName   Variable    UTF-8 version of the entry File Name

          Currently Version is set to the number 1.  If there is a need
          to change this field, the version will be incremented.  Changes
          may not be backward compatible so this extra field should not be
          used if the version is not recognized.

          The NameCRC32 is the standard zip CRC32 checksum of the File Name
          field in the header.  This is used to verify that the header
          File Name field has not changed since the Unicode Path extra field
          was created.  This can happen if a utility renames the File Name but
          does not update the UTF-8 path extra field.  If the CRC check fails,
          this UTF-8 Path Extra Field should be ignored and the File Name field
          in the header should be used instead.

          The UnicodeName is the UTF-8 version of the contents of the File Name
          field in the header.  As UnicodeName is defined to be UTF-8, no UTF-8
          byte order mark (BOM) is used.  The length of this field is determined
          by subtracting the size of the previous fields from TSize.  If both
          the File Name and Comment fields are UTF-8, the new General Purpose
          Bit Flag, bit 11 (Language encoding flag (EFS)), can be used to
          indicate that both the header File Name and Comment fields are UTF-8
          and, in this case, the Unicode Path and Unicode Comment extra fields
          are not needed and should not be created.  Note that, for backward
          compatibility, bit 11 should only be used if the native character set
          of the paths and comments being zipped up are already in UTF-8. It is
          expected that the same file name storage method, either general
          purpose bit 11 or extra fields, be used in both the Local and Central
          Directory Header for a file.


        -Microsoft Open Packaging Growth Hint (0xa220):

          Value         Size        Description
          -----         ----        -----------
          0xa220        Short       tag for this extra block type
          TSize         Short       size of Sig + PadVal + Padding
          Sig           Short       verification signature (A028)
          PadVal        Short       Initial padding value
          Padding       variable    filled with NULL characters


      file comment: (Variable)

          The comment for this file.

      number of this disk: (2 bytes)

          The number of this disk, which contains central
          directory end record. If an archive is in ZIP64 format
          and the value in this field is 0xFFFF, the size will
          be in the corresponding 4 byte zip64 end of central
          directory field.


      number of the disk with the start of the central
      directory: (2 bytes)

          The number of the disk on which the central
          directory starts. If an archive is in ZIP64 format
          and the value in this field is 0xFFFF, the size will
          be in the corresponding 4 byte zip64 end of central
          directory field.

      total number of entries in the central dir on
      this disk: (2 bytes)

          The number of central directory entries on this disk.
          If an archive is in ZIP64 format and the value in
          this field is 0xFFFF, the size will be in the
          corresponding 8 byte zip64 end of central
          directory field.

      total number of entries in the central dir: (2 bytes)

          The total number of files in the .ZIP file. If an
          archive is in ZIP64 format and the value in this field
          is 0xFFFF, the size will be in the corresponding 8 byte
          zip64 end of central directory field.

      size of the central directory: (4 bytes)

          The size (in bytes) of the entire central directory.
          If an archive is in ZIP64 format and the value in
          this field is 0xFFFFFFFF, the size will be in the
          corresponding 8 byte zip64 end of central
          directory field.

      offset of start of central directory with respect to
      the starting disk number:  (4 bytes)

          Offset of the start of the central directory on the
          disk on which the central directory starts. If an
          archive is in ZIP64 format and the value in this
          field is 0xFFFFFFFF, the size will be in the
          corresponding 8 byte zip64 end of central
          directory field.

      .ZIP file comment length: (2 bytes)

          The length of the comment for this .ZIP file.

      .ZIP file comment: (Variable)

          The comment for this .ZIP file.  ZIP file comment data
          is stored unsecured.  No encryption or data authentication
          is applied to this area at this time.  Confidential information
          should not be stored in this section.

      zip64 extensible data sector    (variable size)

          (currently reserved for use by PKWARE)


  K.  Splitting and Spanning ZIP files

          Spanning is the process of segmenting a ZIP file across
          multiple removable media. This support has typically only
          been provided for DOS formatted floppy diskettes.

          File splitting is a newer derivative of spanning.
          Splitting follows the same segmentation process as
          spanning, however, it does not require writing each
          segment to a unique removable medium and instead supports
          placing all pieces onto local or non-removable locations
          such as file systems, local drives, folders, etc...

          A key difference between spanned and split ZIP files is
          that all pieces of a spanned ZIP file have the same name.
          Since each piece is written to a separate volume, no name
          collisions occur and each segment can reuse the original
          .ZIP file name given to the archive.

          Sequence ordering for DOS spanned archives uses the DOS
          volume label to determine segment numbers.  Volume labels
          for each segment are written using the form PKBACK#xxx,
          where xxx is the segment number written as a decimal
          value from 001 - nnn.

          Split ZIP files are typically written to the same location
          and are subject to name collisions if the spanned name
          format is used since each segment will reside on the same
          drive. To avoid name collisions, split archives are named
          as follows.

          Segment 1   = filename.z01
          Segment n-1 = filename.z(n-1)
          Segment n   = filename.zip

          The .ZIP extension is used on the last segment to support
          quickly reading the central directory.  The segment number
          n should be a decimal value.

          Spanned ZIP files may be PKSFX Self-extracting ZIP files.
          PKSFX files may also be split, however, in this case
          the first segment must be named filename.exe.  The first
          segment of a split PKSFX archive must be large enough to
          include the entire executable program.

          Capacities for split archives are as follows.

          Maximum number of segments = 4,294,967,295 - 1
          Maximum .ZIP segment size = 4,294,967,295 bytes
          Minimum segment size = 64K
          Maximum PKSFX segment size = 2,147,483,647 bytes

          Segment sizes may be different however by convention, all
          segment sizes should be the same with the exception of the
          last, which may be smaller.  Local and central directory
          header records must never be split across a segment boundary.
          When writing a header record, if the number of bytes remaining
          within a segment is less than the size of the header record,
          end the current segment and write the header at the start
          of the next segment.  The central directory may span segment
          boundaries, but no single record in the central directory
          should be split across segments.

          Spanned/Split archives created using PKZIP for Windows
          (V2.50 or greater), PKZIP Command Line (V2.50 or greater),
          or PKZIP Explorer will include a special spanning
          signature as the first 4 bytes of the first segment of
          the archive.  This signature (0x08074b50) will be
          followed immediately by the local header signature for
          the first file in the archive.

          A special spanning marker may also appear in spanned/split
          archives if the spanning or splitting process starts but
          only requires one segment.  In this case the 0x08074b50
          signature will be replaced with the temporary spanning
          marker signature of 0x30304b50.  Split archives can
          only be uncompressed by other versions of PKZIP that
          know how to create a split archive.

          The signature value 0x08074b50 is also used by some
          ZIP implementations as a marker for the Data Descriptor
          record.  Conflict in this alternate assignment can be
          avoided by ensuring the position of the signature
          within the ZIP file to determine the use for which it
          is intended.

  L.  General notes:

      1)  All fields unless otherwise noted are unsigned and stored
          in Intel low-byte:high-byte, low-word:high-word order.

      2)  String fields are not null terminated, since the
          length is given explicitly.

      3)  The entries in the central directory may not necessarily
          be in the same order that files appear in the .ZIP file.

      4)  If one of the fields in the end of central directory
          record is too small to hold required data, the field
          should be set to -1 (0xFFFF or 0xFFFFFFFF) and the
          ZIP64 format record should be created.

      5)  The end of central directory record and the
          Zip64 end of central directory locator record must
          reside on the same disk when splitting or spanning
          an archive.

VI. Explanation of compression methods
--------------------------------------

UnShrinking - Method 1
----------------------

Shrinking is a Dynamic Ziv-Lempel-Welch compression algorithm
with partial clearing.  The initial code size is 9 bits, and
the maximum code size is 13 bits.  Shrinking differs from
conventional Dynamic Ziv-Lempel-Welch implementations in several
respects:

1)  The code size is controlled by the compressor, and is not
    automatically increased when codes larger than the current
    code size are created (but not necessarily used).  When
    the decompressor encounters the code sequence 256
    (decimal) followed by 1, it should increase the code size
    read from the input stream to the next bit size.  No
    blocking of the codes is performed, so the next code at
    the increased size should be read from the input stream
    immediately after where the previous code at the smaller
    bit size was read.  Again, the decompressor should not
    increase the code size used until the sequence 256,1 is
    encountered.

2)  When the table becomes full, total clearing is not
    performed.  Rather, when the compressor emits the code
    sequence 256,2 (decimal), the decompressor should clear
    all leaf nodes from the Ziv-Lempel tree, and continue to
    use the current code size.  The nodes that are cleared
    from the Ziv-Lempel tree are then re-used, with the lowest
    code value re-used first, and the highest code value
    re-used last.  The compressor can emit the sequence 256,2
    at any time.

Expanding - Methods 2-5
-----------------------

The Reducing algorithm is actually a combination of two
distinct algorithms.  The first algorithm compresses repeated
byte sequences, and the second algorithm takes the compressed
stream from the first algorithm and applies a probabilistic
compression method.

The probabilistic compression stores an array of 'follower
sets' S(j), for j=0 to 255, corresponding to each possible
ASCII character.  Each set contains between 0 and 32
characters, to be denoted as S(j)[0],...,S(j)[m], where m<32.
The sets are stored at the beginning of the data area for a
Reduced file, in reverse order, with S(255) first, and S(0)
last.

The sets are encoded as { N(j), S(j)[0],...,S(j)[N(j)-1] },
where N(j) is the size of set S(j).  N(j) can be 0, in which
case the follower set for S(j) is empty.  Each N(j) value is
encoded in 6 bits, followed by N(j) eight bit character values
corresponding to S(j)[0] to S(j)[N(j)-1] respectively.  If
N(j) is 0, then no values for S(j) are stored, and the value
for N(j-1) immediately follows.

Immediately after the follower sets, is the compressed data
stream.  The compressed data stream can be interpreted for the
probabilistic decompression as follows:

let Last-Character <- 0.
loop until done
    if the follower set S(Last-Character) is empty then
        read 8 bits from the input stream, and copy this
        value to the output stream.
    otherwise if the follower set S(Last-Character) is non-empty then
        read 1 bit from the input stream.
        if this bit is not zero then
            read 8 bits from the input stream, and copy this
            value to the output stream.
        otherwise if this bit is zero then
            read B(N(Last-Character)) bits from the input
            stream, and assign this value to I.
            Copy the value of S(Last-Character)[I] to the
            output stream.

    assign the last value placed on the output stream to
    Last-Character.
end loop

B(N(j)) is defined as the minimal number of bits required to
encode the value N(j)-1.

The decompressed stream from above can then be expanded to
re-create the original file as follows:

let State <- 0.

loop until done
    read 8 bits from the input stream into C.
    case State of
        0:  if C is not equal to DLE (144 decimal) then
                copy C to the output stream.
            otherwise if C is equal to DLE then
                let State <- 1.

        1:  if C is non-zero then
                let V <- C.
                let Len <- L(V)
                let State <- F(Len).
            otherwise if C is zero then
                copy the value 144 (decimal) to the output stream.
                let State <- 0

        2:  let Len <- Len + C
            let State <- 3.

        3:  move backwards D(V,C) bytes in the output stream
            (if this position is before the start of the output
            stream, then assume that all the data before the
            start of the output stream is filled with zeros).
            copy Len+3 bytes from this position to the output stream.
            let State <- 0.
    end case
end loop

The functions F,L, and D are dependent on the 'compression
factor', 1 through 4, and are defined as follows:

For compression factor 1:
    L(X) equals the lower 7 bits of X.
    F(X) equals 2 if X equals 127 otherwise F(X) equals 3.
    D(X,Y) equals the (upper 1 bit of X) * 256 + Y + 1.
For compression factor 2:
    L(X) equals the lower 6 bits of X.
    F(X) equals 2 if X equals 63 otherwise F(X) equals 3.
    D(X,Y) equals the (upper 2 bits of X) * 256 + Y + 1.
For compression factor 3:
    L(X) equals the lower 5 bits of X.
    F(X) equals 2 if X equals 31 otherwise F(X) equals 3.
    D(X,Y) equals the (upper 3 bits of X) * 256 + Y + 1.
For compression factor 4:
    L(X) equals the lower 4 bits of X.
    F(X) equals 2 if X equals 15 otherwise F(X) equals 3.
    D(X,Y) equals the (upper 4 bits of X) * 256 + Y + 1.

Imploding - Method 6
--------------------

The Imploding algorithm is actually a combination of two distinct
algorithms.  The first algorithm compresses repeated byte
sequences using a sliding dictionary.  The second algorithm is
used to compress the encoding of the sliding dictionary output,
using multiple Shannon-Fano trees.

The Imploding algorithm can use a 4K or 8K sliding dictionary
size. The dictionary size used can be determined by bit 1 in the
general purpose flag word; a 0 bit indicates a 4K dictionary
while a 1 bit indicates an 8K dictionary.

The Shannon-Fano trees are stored at the start of the compressed
file. The number of trees stored is defined by bit 2 in the
general purpose flag word; a 0 bit indicates two trees stored, a
1 bit indicates three trees are stored.  If 3 trees are stored,
the first Shannon-Fano tree represents the encoding of the
Literal characters, the second tree represents the encoding of
the Length information, the third represents the encoding of the
Distance information.  When 2 Shannon-Fano trees are stored, the
Length tree is stored first, followed by the Distance tree.

The Literal Shannon-Fano tree, if present is used to represent
the entire ASCII character set, and contains 256 values.  This
tree is used to compress any data not compressed by the sliding
dictionary algorithm.  When this tree is present, the Minimum
Match Length for the sliding dictionary is 3.  If this tree is
not present, the Minimum Match Length is 2.

The Length Shannon-Fano tree is used to compress the Length part
of the (length,distance) pairs from the sliding dictionary
output.  The Length tree contains 64 values, ranging from the
Minimum Match Length, to 63 plus the Minimum Match Length.

The Distance Shannon-Fano tree is used to compress the Distance
part of the (length,distance) pairs from the sliding dictionary
output. The Distance tree contains 64 values, ranging from 0 to
63, representing the upper 6 bits of the distance value.  The
distance values themselves will be between 0 and the sliding
dictionary size, either 4K or 8K.

The Shannon-Fano trees themselves are stored in a compressed
format. The first byte of the tree data represents the number of
bytes of data representing the (compressed) Shannon-Fano tree
minus 1.  The remaining bytes represent the Shannon-Fano tree
data encoded as:

    High 4 bits: Number of values at this bit length + 1. (1 - 16)
    Low  4 bits: Bit Length needed to represent value + 1. (1 - 16)

The Shannon-Fano codes can be constructed from the bit lengths
using the following algorithm:

1)  Sort the Bit Lengths in ascending order, while retaining the
    order of the original lengths stored in the file.

2)  Generate the Shannon-Fano trees:

    Code <- 0
    CodeIncrement <- 0
    LastBitLength <- 0
    i <- number of Shannon-Fano codes - 1   (either 255 or 63)

    loop while i >= 0
        Code = Code + CodeIncrement
        if BitLength(i) <> LastBitLength then
            LastBitLength=BitLength(i)
            CodeIncrement = 1 shifted left (16 - LastBitLength)
        ShannonCode(i) = Code
        i <- i - 1
    end loop

3)  Reverse the order of all the bits in the above ShannonCode()
    vector, so that the most significant bit becomes the least
    significant bit.  For example, the value 0x1234 (hex) would
    become 0x2C48 (hex).

4)  Restore the order of Shannon-Fano codes as originally stored
    within the file.

Example:

    This example will show the encoding of a Shannon-Fano tree
    of size 8.  Notice that the actual Shannon-Fano trees used
    for Imploding are either 64 or 256 entries in size.

Example:   0x02, 0x42, 0x01, 0x13

    The first byte indicates 3 values in this table.  Decoding the
    bytes:
            0x42 = 5 codes of 3 bits long
            0x01 = 1 code  of 2 bits long
            0x13 = 2 codes of 4 bits long

    This would generate the original bit length array of:
    (3, 3, 3, 3, 3, 2, 4, 4)

    There are 8 codes in this table for the values 0 thru 7.  Using
    the algorithm to obtain the Shannon-Fano codes produces:

                                  Reversed     Order     Original
Val  Sorted   Constructed Code      Value     Restored    Length
---  ------   -----------------   --------    --------    ------
0:     2      1100000000000000        11       101          3
1:     3      1010000000000000       101       001          3
2:     3      1000000000000000       001       110          3
3:     3      0110000000000000       110       010          3
4:     3      0100000000000000       010       100          3
5:     3      0010000000000000       100        11          2
6:     4      0001000000000000      1000      1000          4
7:     4      0000000000000000      0000      0000          4

The values in the Val, Order Restored and Original Length columns
now represent the Shannon-Fano encoding tree that can be used for
decoding the Shannon-Fano encoded data.  How to parse the
variable length Shannon-Fano values from the data stream is beyond
the scope of this document.  (See the references listed at the end of
this document for more information.)  However, traditional decoding
schemes used for Huffman variable length decoding, such as the
Greenlaw algorithm, can be successfully applied.

The compressed data stream begins immediately after the
compressed Shannon-Fano data.  The compressed data stream can be
interpreted as follows:

loop until done
    read 1 bit from input stream.

    if this bit is non-zero then       (encoded data is literal data)
        if Literal Shannon-Fano tree is present
            read and decode character using Literal Shannon-Fano tree.
        otherwise
            read 8 bits from input stream.
        copy character to the output stream.
    otherwise              (encoded data is sliding dictionary match)
        if 8K dictionary size
            read 7 bits for offset Distance (lower 7 bits of offset).
        otherwise
            read 6 bits for offset Distance (lower 6 bits of offset).

        using the Distance Shannon-Fano tree, read and decode the
          upper 6 bits of the Distance value.

        using the Length Shannon-Fano tree, read and decode
          the Length value.

        Length <- Length + Minimum Match Length

        if Length = 63 + Minimum Match Length
            read 8 bits from the input stream,
            add this value to Length.

        move backwards Distance+1 bytes in the output stream, and
        copy Length characters from this position to the output
        stream.  (if this position is before the start of the output
        stream, then assume that all the data before the start of
        the output stream is filled with zeros).
end loop

Tokenizing - Method 7
---------------------

This method is not used by PKZIP.

Deflating - Method 8
--------------------

The Deflate algorithm is similar to the Implode algorithm using
a sliding dictionary of up to 32K with secondary compression
from Huffman/Shannon-Fano codes.

The compressed data is stored in blocks with a header describing
the block and the Huffman codes used in the data block.  The header
format is as follows:

   Bit 0: Last Block bit     This bit is set to 1 if this is the last
                             compressed block in the data.
   Bits 1-2: Block type
      00 (0) - Block is stored - All stored data is byte aligned.
               Skip bits until next byte, then next word = block
               length, followed by the ones compliment of the block
               length word. Remaining data in block is the stored
               data.

      01 (1) - Use fixed Huffman codes for literal and distance codes.
               Lit Code    Bits             Dist Code   Bits
               ---------   ----             ---------   ----
                 0 - 143    8                 0 - 31      5
               144 - 255    9
               256 - 279    7
               280 - 287    8

               Literal codes 286-287 and distance codes 30-31 are
               never used but participate in the huffman construction.

      10 (2) - Dynamic Huffman codes.  (See expanding Huffman codes)

      11 (3) - Reserved - Flag a "Error in compressed data" if seen.

Expanding Huffman Codes
-----------------------
If the data block is stored with dynamic Huffman codes, the Huffman
codes are sent in the following compressed format:

   5 Bits: # of Literal codes sent - 256 (256 - 286)
           All other codes are never sent.
   5 Bits: # of Dist codes - 1           (1 - 32)
   4 Bits: # of Bit Length codes - 3     (3 - 19)

The Huffman codes are sent as bit lengths and the codes are built as
described in the implode algorithm.  The bit lengths themselves are
compressed with Huffman codes.  There are 19 bit length codes:

   0 - 15: Represent bit lengths of 0 - 15
       16: Copy the previous bit length 3 - 6 times.
           The next 2 bits indicate repeat length (0 = 3, ... ,3 = 6)
              Example:  Codes 8, 16 (+2 bits 11), 16 (+2 bits 10) will
                        expand to 12 bit lengths of 8 (1 + 6 + 5)
       17: Repeat a bit length of 0 for 3 - 10 times. (3 bits of length)
       18: Repeat a bit length of 0 for 11 - 138 times (7 bits of length)

The lengths of the bit length codes are sent packed 3 bits per value
(0 - 7) in the following order:

   16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15

The Huffman codes should be built as described in the Implode algorithm
except codes are assigned starting at the shortest bit length, i.e. the
shortest code should be all 0's rather than all 1's.  Also, codes with
a bit length of zero do not participate in the tree construction.  The
codes are then used to decode the bit lengths for the literal and
distance tables.

The bit lengths for the literal tables are sent first with the number
of entries sent described by the 5 bits sent earlier.  There are up
to 286 literal characters; the first 256 represent the respective 8
bit character, code 256 represents the End-Of-Block code, the remaining
29 codes represent copy lengths of 3 thru 258.  There are up to 30
distance codes representing distances from 1 thru 32k as described
below.

                             Length Codes
                             ------------
      Extra             Extra              Extra              Extra
 Code Bits Length  Code Bits Lengths  Code Bits Lengths  Code Bits Length(s)
 ---- ---- ------  ---- ---- -------  ---- ---- -------  ---- ---- ---------
  257   0     3     265   1   11,12    273   3   35-42    281   5  131-162
  258   0     4     266   1   13,14    274   3   43-50    282   5  163-194
  259   0     5     267   1   15,16    275   3   51-58    283   5  195-226
  260   0     6     268   1   17,18    276   3   59-66    284   5  227-257
  261   0     7     269   2   19-22    277   4   67-82    285   0    258
  262   0     8     270   2   23-26    278   4   83-98
  263   0     9     271   2   27-30    279   4   99-114
  264   0    10     272   2   31-34    280   4  115-130

                            Distance Codes
                            --------------
      Extra           Extra             Extra               Extra
 Code Bits Dist  Code Bits  Dist   Code Bits Distance  Code Bits Distance
 ---- ---- ----  ---- ---- ------  ---- ---- --------  ---- ---- --------
   0   0    1      8   3   17-24    16    7  257-384    24   11  4097-6144
   1   0    2      9   3   25-32    17    7  385-512    25   11  6145-8192
   2   0    3     10   4   33-48    18    8  513-768    26   12  8193-12288
   3   0    4     11   4   49-64    19    8  769-1024   27   12 12289-16384
   4   1   5,6    12   5   65-96    20    9 1025-1536   28   13 16385-24576
   5   1   7,8    13   5   97-128   21    9 1537-2048   29   13 24577-32768
   6   2   9-12   14   6  129-192   22   10 2049-3072
   7   2  13-16   15   6  193-256   23   10 3073-4096

The compressed data stream begins immediately after the
compressed header data.  The compressed data stream can be
interpreted as follows:

do
   read header from input stream.

   if stored block
      skip bits until byte aligned
      read count and 1's compliment of count
      copy count bytes data block
   otherwise
      loop until end of block code sent
         decode literal character from input stream
         if literal < 256
            copy character to the output stream
         otherwise
            if literal = end of block
               break from loop
            otherwise
               decode distance from input stream

               move backwards distance bytes in the output stream, and
               copy length characters from this position to the output
               stream.
      end loop
while not last block

if data descriptor exists
   skip bits until byte aligned
   read crc and sizes
endif

Enhanced Deflating - Method 9
-----------------------------

The Enhanced Deflating algorithm is similar to Deflate but
uses a sliding dictionary of up to 64K. Deflate64(tm) is supported
by the Deflate extractor.

BZIP2 - Method 12
-----------------

BZIP2 is an open-source data compression algorithm developed by
Julian Seward.  Information and source code for this algorithm
can be found on the internet.

LZMA - Method 14 (EFS)
----------------------

LZMA is a block-oriented, general purpose data compression algorithm
developed and maintained by Igor Pavlov.  It is a derivative of LZ77
that utilizes Markov chains and a range coder.  Information and
source code for this algorithm can be found on the internet.  Consult
with the author of this algorithm for information on terms or
restrictions on use.

Support for LZMA within the ZIP format is defined as follows:

The Compression method field within the ZIP Local and Central
Header records will be set to the value 14 to indicate data was
compressed using LZMA.

The Version needed to extract field within the ZIP Local and
Central Header records will be set to 6.3 to indicate the
minimum ZIP format version supporting this feature.

File data compressed using the LZMA algorithm must be placed
immediately following the Local Header for the file.  If a
standard ZIP encryption header is required, it will follow
the Local Header and will precede the LZMA compressed file
data segment.  The location of LZMA compressed data segment
within the ZIP format will be as shown:

    [local header file 1]
    [encryption header file 1]
    [LZMA compressed data segment for file 1]
    [data descriptor 1]
    [local header file 2]

The encryption header and data descriptor records may
be conditionally present.  The LZMA Compressed Data Segment
will consist of an LZMA Properties Header followed by the
LZMA Compressed Data as shown:

    [LZMA properties header for file 1]
    [LZMA compressed data for file 1]

The LZMA Compressed Data will be stored as provided by the
LZMA compression library.  Compressed size, uncompressed
size and other file characteristics about the file being
compressed must be stored in standard ZIP storage format.

The LZMA Properties Header will store specific data required to
decompress the LZMA compressed Data.  This data is set by the
LZMA compression engine using the function WriteCoderProperties()
as documented within the LZMA SDK.

Storage fields for the property information within the LZMA
Properties Header are as follows:

     LZMA Version Information 2 bytes
     LZMA Properties Size 2 bytes
     LZMA Properties Data variable, defined by "LZMA Properties Size"

LZMA Version Information - this field identifies which version of
     the LZMA SDK was used to compress a file.  The first byte will
     store the major version number of the LZMA SDK and the second
     byte will store the minor number.

LZMA Properties Size - this field defines the size of the remaining
     property data.  Typically this size should be determined by the
     version of the SDK.  This size field is included as a convenience
     and to help avoid any ambiguity should it arise in the future due
     to changes in this compression algorithm.

LZMA Property Data - this variable sized field records the required
     values for the decompressor as defined by the LZMA SDK.  The
     data stored in this field should be obtained using the
     WriteCoderProperties() in the version of the SDK defined by
     the "LZMA Version Information" field.

The layout of the "LZMA Properties Data" field is a function of the
LZMA compression algorithm.  It is possible that this layout may be
changed by the author over time.  The data layout in version 4.32
of the LZMA SDK defines a 5 byte array that uses 4 bytes to store
the dictionary size in little-endian order. This is preceded by a
single packed byte as the first element of the array that contains
the following fields:

     PosStateBits
     LiteralPosStateBits
     LiteralContextBits

Refer to the LZMA documentation for a more detailed explanation of
these fields.

Data compressed with method 14, LZMA, may include an end-of-stream
(EOS) marker ending the compressed data stream.  This marker is not
required, but its use is highly recommended to facilitate processing
and implementers should include the EOS marker whenever possible.
When the EOS marker is used, general purpose bit 1 must be set.  If
general purpose bit 1 is not set, the EOS marker is not present.

WavPack - Method 97
-------------------

Information describing the use of compression method 97 is
provided by WinZIP International, LLC.  This method relies on the
open source WavPack audio compression utility developed by David Bryant.
Information on WavPack is available at www.wavpack.com.  Please consult
with the author of this algorithm for information on terms and
restrictions on use.

WavPack data for a file begins immediately after the end of the
local header data.  This data is the output from WavPack compression
routines.  Within the ZIP file, the use of WavPack compression is
indicated by setting the compression method field to a value of 97
in both the local header and the central directory header.  The Version
needed to extract and version made by fields use the same values as are
used for data compressed using the Deflate algorithm.

An implementation note for storing digital sample data when using
WavPack compression within ZIP files is that all of the bytes of
the sample data should be compressed.  This includes any unused
bits up to the byte boundary.  An example is a 2 byte sample that
uses only 12 bits for the sample data with 4 unused bits.  If only
12 bits are passed as the sample size to the WavPack routines, the 4
unused bits will be set to 0 on extraction regardless of their original
state.  To avoid this, the full 16 bits of the sample data size
should be provided.

PPMd - Method 98
----------------

PPMd is a data compression algorithm developed by Dmitry Shkarin
which includes a carryless rangecoder developed by Dmitry Subbotin.
This algorithm is based on predictive phrase matching on multiple
order contexts.  Information and source code for this algorithm
can be found on the internet. Consult with the author of this
algorithm for information on terms or restrictions on use.

Support for PPMd within the ZIP format currently is provided only
for version I, revision 1 of the algorithm.  Storage requirements
for using this algorithm are as follows:

Parameters needed to control the algorithm are stored in the two
bytes immediately preceding the compressed data.  These bytes are
used to store the following fields:

Model order - sets the maximum model order, default is 8, possible
              values are from 2 to 16 inclusive

Sub-allocator size - sets the size of sub-allocator in MB, default is 50,
            possible values are from 1MB to 256MB inclusive

Model restoration method - sets the method used to restart context
            model at memory insufficiency, values are:

            0 - restarts model from scratch - default
            1 - cut off model - decreases performance by as much as 2x
            2 - freeze context tree - not recommended

An example for packing these fields into the 2 byte storage field is
illustrated below.  These values are stored in Intel low-byte/high-byte
order.

wPPMd = (Model order - 1) +
        ((Sub-allocator size - 1) << 4) +
        (Model restoration method << 12)


VII. Traditional PKWARE Encryption
----------------------------------

The following information discusses the decryption steps
required to support traditional PKWARE encryption.  This
form of encryption is considered weak by today's standards
and its use is recommended only for situations with
low security needs or for compatibility with older .ZIP
applications.

Decryption
----------

PKWARE is grateful to Mr. Roger Schlafly for his expert contribution
towards the development of PKWARE's traditional encryption.

PKZIP encrypts the compressed data stream.  Encrypted files must
be decrypted before they can be extracted.

Each encrypted file has an extra 12 bytes stored at the start of
the data area defining the encryption header for that file.  The
encryption header is originally set to random values, and then
itself encrypted, using three, 32-bit keys.  The key values are
initialized using the supplied encryption password.  After each byte
is encrypted, the keys are then updated using pseudo-random number
generation techniques in combination with the same CRC-32 algorithm
used in PKZIP and described elsewhere in this document.

The following is the basic steps required to decrypt a file:

1) Initialize the three 32-bit keys with the password.
2) Read and decrypt the 12-byte encryption header, further
   initializing the encryption keys.
3) Read and decrypt the compressed data stream using the
   encryption keys.

Step 1 - Initializing the encryption keys
-----------------------------------------

Key(0) <- 305419896
Key(1) <- 591751049
Key(2) <- 878082192

loop for i <- 0 to length(password)-1
    update_keys(password(i))
end loop

Where update_keys() is defined as:

update_keys(char):
  Key(0) <- crc32(key(0),char)
  Key(1) <- Key(1) + (Key(0) & 000000ffH)
  Key(1) <- Key(1) * 134775813 + 1
  Key(2) <- crc32(key(2),key(1) >> 24)
end update_keys

Where crc32(old_crc,char) is a routine that given a CRC value and a
character, returns an updated CRC value after applying the CRC-32
algorithm described elsewhere in this document.

Step 2 - Decrypting the encryption header
-----------------------------------------

The purpose of this step is to further initialize the encryption
keys, based on random data, to render a plaintext attack on the
data ineffective.

Read the 12-byte encryption header into Buffer, in locations
Buffer(0) thru Buffer(11).

loop for i <- 0 to 11
    C <- buffer(i) ^ decrypt_byte()
    update_keys(C)
    buffer(i) <- C
end loop

Where decrypt_byte() is defined as:

unsigned char decrypt_byte()
    local unsigned short temp
    temp <- Key(2) | 2
    decrypt_byte <- (temp * (temp ^ 1)) >> 8
end decrypt_byte

After the header is decrypted,  the last 1 or 2 bytes in Buffer
should be the high-order word/byte of the CRC for the file being
decrypted, stored in Intel low-byte/high-byte order.  Versions of
PKZIP prior to 2.0 used a 2 byte CRC check; a 1 byte CRC check is
used on versions after 2.0.  This can be used to test if the password
supplied is correct or not.

Step 3 - Decrypting the compressed data stream
----------------------------------------------

The compressed data stream can be decrypted as follows:

loop until done
    read a character into C
    Temp <- C ^ decrypt_byte()
    update_keys(temp)
    output Temp
end loop


VIII. Strong Encryption Specification
-------------------------------------

The Strong Encryption technology defined in this specification is
covered under a pending patent application. The use or implementation
in a product of certain technological aspects set forth in the current
APPNOTE, including those with regard to strong encryption, patching,
or extended tape operations requires a license from PKWARE. Portions
of this Strong Encryption technology are available for use at no charge.
Contact PKWARE for licensing terms and conditions. Refer to section II
of this APPNOTE (Contacting PKWARE) for information on how to
contact PKWARE.

Version 5.x of this specification introduced support for strong
encryption algorithms.  These algorithms can be used with either
a password or an X.509v3 digital certificate to encrypt each file.
This format specification supports either password or certificate
based encryption to meet the security needs of today, to enable
interoperability between users within both PKI and non-PKI
environments, and to ensure interoperability between different
computing platforms that are running a ZIP program.

Password based encryption is the most common form of encryption
people are familiar with.  However, inherent weaknesses with
passwords (e.g. susceptibility to dictionary/brute force attack)
as well as password management and support issues make certificate
based encryption a more secure and scalable option.  Industry
efforts and support are defining and moving towards more advanced
security solutions built around X.509v3 digital certificates and
Public Key Infrastructures(PKI) because of the greater scalability,
administrative options, and more robust security over traditional
password based encryption.

Most standard encryption algorithms are supported with this
specification. Reference implementations for many of these
algorithms are available from either commercial or open source
distributors.  Readily available cryptographic toolkits make
implementation of the encryption features straight-forward.
This document is not intended to provide a treatise on data
encryption principles or theory.  Its purpose is to document the
data structures required for implementing interoperable data
encryption within the .ZIP format.  It is strongly recommended that
you have a good understanding of data encryption before reading
further.

The algorithms introduced in Version 5.0 of this specification
include:

    RC2 40 bit, 64 bit, and 128 bit
    RC4 40 bit, 64 bit, and 128 bit
    DES
    3DES 112 bit and 168 bit

Version 5.1 adds support for the following:

    AES 128 bit, 192 bit, and 256 bit


Version 6.1 introduces encryption data changes to support
interoperability with Smartcard and USB Token certificate storage
methods which do not support the OAEP strengthening standard.

Version 6.2 introduces support for encrypting metadata by compressing
and encrypting the central directory data structure to reduce information
leakage.   Information leakage can occur in legacy ZIP applications
through exposure of information about a file even though that file is
stored encrypted.  The information exposed consists of file
characteristics stored within the records and fields defined by this
specification.  This includes data such as a files name, its original
size, timestamp and CRC32 value.

Version 6.3 introduces support for encrypting data using the Blowfish
and Twofish algorithms.  These are symmetric block ciphers developed
by Bruce Schneier.  Blowfish supports using a variable length key from
32 to 448 bits.  Block size is 64 bits.  Implementations should use 16
rounds and the only mode supported within ZIP files is CBC. Twofish
supports key sizes 128, 192 and 256 bits.  Block size is 128 bits.
Implementations should use 16 rounds and the only mode supported within
ZIP files is CBC.  Information and source code for both Blowfish and
Twofish algorithms can be found on the internet.  Consult with the author
of these algorithms for information on terms or restrictions on use.

Central Directory Encryption provides greater protection against
information leakage by encrypting the Central Directory structure and
by masking key values that are replicated in the unencrypted Local
Header.   ZIP compatible programs that cannot interpret an encrypted
Central Directory structure cannot rely on the data in the corresponding
Local Header for decompression information.

Extra Field records that may contain information about a file that should
not be exposed should not be stored in the Local Header and should only
be written to the Central Directory where they can be encrypted.  This
design currently does not support streaming.  Information in the End of
Central Directory record, the Zip64 End of Central Directory Locator,
and the Zip64 End of Central Directory records are not encrypted.  Access
to view data on files within a ZIP file with an encrypted Central Directory
requires the appropriate password or private key for decryption prior to
viewing any files, or any information about the files, in the archive.

Older ZIP compatible programs not familiar with the Central Directory
Encryption feature will no longer be able to recognize the Central
Directory and may assume the ZIP file is corrupt.  Programs that
attempt streaming access using Local Headers will see invalid
information for each file.  Central Directory Encryption need not be
used for every ZIP file.  Its use is recommended for greater security.
ZIP files not using Central Directory Encryption should operate as
in the past.

This strong encryption feature specification is intended to provide for
scalable, cross-platform encryption needs ranging from simple password
encryption to authenticated public/private key encryption.

Encryption provides data confidentiality and privacy.  It is
recommended that you combine X.509 digital signing with encryption
to add authentication and non-repudiation.


Single Password Symmetric Encryption Method:
-------------------------------------------

The Single Password Symmetric Encryption Method using strong
encryption algorithms operates similarly to the traditional
PKWARE encryption defined in this format.  Additional data
structures are added to support the processing needs of the
strong algorithms.

The Strong Encryption data structures are:

1. General Purpose Bits - Bits 0 and 6 of the General Purpose bit
flag in both local and central header records.  Both bits set
indicates strong encryption.  Bit 13, when set indicates the Central
Directory is encrypted and that selected fields in the Local Header
are masked to hide their actual value.


2. Extra Field 0x0017 in central header only.

     Fields to consider in this record are:

     Format - the data format identifier for this record.  The only
     value allowed at this time is the integer value 2.

     AlgId - integer identifier of the encryption algorithm from the
     following range

         0x6601 - DES
         0x6602 - RC2 (version needed to extract < 5.2)
         0x6603 - 3DES 168
         0x6609 - 3DES 112
         0x660E - AES 128
         0x660F - AES 192
         0x6610 - AES 256
         0x6702 - RC2 (version needed to extract >= 5.2)
         0x6720 - Blowfish
         0x6721 - Twofish
         0x6801 - RC4
         0xFFFF - Unknown algorithm

     Bitlen - Explicit bit length of key

         32 - 448 bits

     Flags - Processing flags needed for decryption

         0x0001 - Password is required to decrypt
         0x0002 - Certificates only
         0x0003 - Password or certificate required to decrypt

         Values > 0x0003 reserved for certificate processing


3. Decryption header record preceding compressed file data.

         -Decryption Header:

          Value     Size     Description
          -----     ----     -----------
          IVSize    2 bytes  Size of initialization vector (IV)
          IVData    IVSize   Initialization vector for this file
          Size      4 bytes  Size of remaining decryption header data
          Format    2 bytes  Format definition for this record
          AlgID     2 bytes  Encryption algorithm identifier
          Bitlen    2 bytes  Bit length of encryption key
          Flags     2 bytes  Processing flags
          ErdSize   2 bytes  Size of Encrypted Random Data
          ErdData   ErdSize  Encrypted Random Data
          Reserved1 4 bytes  Reserved certificate processing data
          Reserved2 (var)    Reserved for certificate processing data
          VSize     2 bytes  Size of password validation data
          VData     VSize-4  Password validation data
          VCRC32    4 bytes  Standard ZIP CRC32 of password validation data

     IVData - The size of the IV should match the algorithm block size.
              The IVData can be completely random data.  If the size of
              the randomly generated data does not match the block size
              it should be complemented with zero's or truncated as
              necessary.  If IVSize is 0,then IV = CRC32 + Uncompressed
              File Size (as a 64 bit little-endian, unsigned integer value).

     Format - the data format identifier for this record.  The only
     value allowed at this time is the integer value 3.

     AlgId - integer identifier of the encryption algorithm from the
     following range

         0x6601 - DES
         0x6602 - RC2 (version needed to extract < 5.2)
         0x6603 - 3DES 168
         0x6609 - 3DES 112
         0x660E - AES 128
         0x660F - AES 192
         0x6610 - AES 256
         0x6702 - RC2 (version needed to extract >= 5.2)
         0x6720 - Blowfish
         0x6721 - Twofish
         0x6801 - RC4
         0xFFFF - Unknown algorithm

     Bitlen - Explicit bit length of key

         32 - 448 bits

     Flags - Processing flags needed for decryption

         0x0001 - Password is required to decrypt
         0x0002 - Certificates only
         0x0003 - Password or certificate required to decrypt

         Values > 0x0003 reserved for certificate processing

     ErdData - Encrypted random data is used to store random data that
               is used to generate a file session key for encrypting
               each file.  SHA1 is used to calculate hash data used to
               derive keys.  File session keys are derived from a master
               session key generated from the user-supplied password.
               If the Flags field in the decryption header contains
               the value 0x4000, then the ErdData field must be
               decrypted using 3DES. If the value 0x4000 is not set,
               then the ErdData field must be decrypted using AlgId.


     Reserved1 - Reserved for certificate processing, if value is
               zero, then Reserved2 data is absent.  See the explanation
               under the Certificate Processing Method for details on
               this data structure.

     Reserved2 - If present, the size of the Reserved2 data structure
               is located by skipping the first 4 bytes of this field
               and using the next 2 bytes as the remaining size.  See
               the explanation under the Certificate Processing Method
               for details on this data structure.

     VSize - This size value will always include the 4 bytes of the
             VCRC32 data and will be greater than 4 bytes.

     VData - Random data for password validation.  This data is VSize
             in length and VSize must be a multiple of the encryption
             block size.  VCRC32 is a checksum value of VData.
             VData and VCRC32 are stored encrypted and start the
             stream of encrypted data for a file.


4. Useful Tips

Strong Encryption is always applied to a file after compression. The
block oriented algorithms all operate in Cypher Block Chaining (CBC)
mode.  The block size used for AES encryption is 16.  All other block
algorithms use a block size of 8.  Two ID's are defined for RC2 to
account for a discrepancy found in the implementation of the RC2
algorithm in the cryptographic library on Windows XP SP1 and all
earlier versions of Windows.  It is recommended that zero length files
not be encrypted, however programs should be prepared to extract them
if they are found within a ZIP file.

A pseudo-code representation of the encryption process is as follows:

Password = GetUserPassword()
MasterSessionKey = DeriveKey(SHA1(Password))
RD = CryptographicStrengthRandomData()
For Each File
   IV = CryptographicStrengthRandomData()
   VData = CryptographicStrengthRandomData()
   VCRC32 = CRC32(VData)
   FileSessionKey = DeriveKey(SHA1(IV + RD)
   ErdData = Encrypt(RD,MasterSessionKey,IV)
   Encrypt(VData + VCRC32 + FileData, FileSessionKey,IV)
Done

The function names and parameter requirements will depend on
the choice of the cryptographic toolkit selected.  Almost any
toolkit supporting the reference implementations for each
algorithm can be used.  The RSA BSAFE(r), OpenSSL, and Microsoft
CryptoAPI libraries are all known to work well.


Single Password - Central Directory Encryption:
-----------------------------------------------

Central Directory Encryption is achieved within the .ZIP format by
encrypting the Central Directory structure.  This encapsulates the metadata
most often used for processing .ZIP files.  Additional metadata is stored for
redundancy in the Local Header for each file.  The process of concealing
metadata by encrypting the Central Directory does not protect the data within
the Local Header.  To avoid information leakage from the exposed metadata
in the Local Header, the fields containing information about a file are masked.

Local Header:

Masking replaces the true content of the fields for a file in the Local
Header with false information.  When masked, the Local Header is not
suitable for streaming access and the options for data recovery of damaged
archives is reduced.  Extra Data fields that may contain confidential
data should not be stored within the Local Header.  The value set into
the Version needed to extract field should be the correct value needed to
extract the file without regard to Central Directory Encryption. The fields
within the Local Header targeted for masking when the Central Directory is
encrypted are:

        Field Name                     Mask Value
        ------------------             ---------------------------
        compression method              0
        last mod file time              0
        last mod file date              0
        crc-32                          0
        compressed size                 0
        uncompressed size               0
        file name (variable size)       Base 16 value from the
                                        range 1 - 0xFFFFFFFFFFFFFFFF
                                        represented as a string whose
                                        size will be set into the
                                        file name length field

The Base 16 value assigned as a masked file name is simply a sequentially
incremented value for each file starting with 1 for the first file.
Modifications to a ZIP file may cause different values to be stored for
each file.  For compatibility, the file name field in the Local Header
should never be left blank.  As of Version 6.2 of this specification,
the Compression Method and Compressed Size fields are not yet masked.
Fields having a value of 0xFFFF or 0xFFFFFFFF for the ZIP64 format
should not be masked.

Encrypting the Central Directory:

Encryption of the Central Directory does not include encryption of the
Central Directory Signature data, the Zip64 End of Central Directory
record, the Zip64 End of Central Directory Locator, or the End
of Central Directory record.  The ZIP file comment data is never
encrypted.

Before encrypting the Central Directory, it may optionally be compressed.
Compression is not required, but for storage efficiency it is assumed
this structure will be compressed before encrypting.  Similarly, this
specification supports compressing the Central Directory without
requiring that it also be encrypted.  Early implementations of this
feature will assume the encryption method applied to files matches the
encryption applied to the Central Directory.

Encryption of the Central Directory is done in a manner similar to
that of file encryption.  The encrypted data is preceded by a
decryption header.  The decryption header is known as the Archive
Decryption Header.  The fields of this record are identical to
the decryption header preceding each encrypted file.  The location
of the Archive Decryption Header is determined by the value in the
Start of the Central Directory field in the Zip64 End of Central
Directory record.  When the Central Directory is encrypted, the
Zip64 End of Central Directory record will always be present.

The layout of the Zip64 End of Central Directory record for all
versions starting with 6.2 of this specification will follow the
Version 2 format.  The Version 2 format is as follows:

The leading fixed size fields within the Version 1 format for this
record remain unchanged.  The record signature for both Version 1
and Version 2 will be 0x06064b50.  Immediately following the last
byte of the field known as the Offset of Start of Central
Directory With Respect to the Starting Disk Number will begin the
new fields defining Version 2 of this record.

New fields for Version 2:

Note: all fields stored in Intel low-byte/high-byte order.

          Value                 Size       Description
          -----                 ----       -----------
          Compression Method    2 bytes    Method used to compress the
                                           Central Directory
          Compressed Size       8 bytes    Size of the compressed data
          Original   Size       8 bytes    Original uncompressed size
          AlgId                 2 bytes    Encryption algorithm ID
          BitLen                2 bytes    Encryption key length
          Flags                 2 bytes    Encryption flags
          HashID                2 bytes    Hash algorithm identifier
          Hash Length           2 bytes    Length of hash data
          Hash Data             (variable) Hash data

The Compression Method accepts the same range of values as the
corresponding field in the Central Header.

The Compressed Size and Original Size values will not include the
data of the Central Directory Signature which is compressed or
encrypted.

The AlgId, BitLen, and Flags fields accept the same range of values
the corresponding fields within the 0x0017 record.

Hash ID identifies the algorithm used to hash the Central Directory
data.  This data does not have to be hashed, in which case the
values for both the HashID and Hash Length will be 0.  Possible
values for HashID are:

      Value         Algorithm
     ------         ---------
     0x0000          none
     0x0001          CRC32
     0x8003          MD5
     0x8004          SHA1
     0x8007          RIPEMD160
     0x800C          SHA256
     0x800D          SHA384
     0x800E          SHA512

When the Central Directory data is signed, the same hash algorithm
used to hash the Central Directory for signing should be used.
This is recommended for processing efficiency, however, it is
permissible for any of the above algorithms to be used independent
of the signing process.

The Hash Data will contain the hash data for the Central Directory.
The length of this data will vary depending on the algorithm used.

The Version Needed to Extract should be set to 62.

The value for the Total Number of Entries on the Current Disk will
be 0.  These records will no longer support random access when
encrypting the Central Directory.

When the Central Directory is compressed and/or encrypted, the
End of Central Directory record will store the value 0xFFFFFFFF
as the value for the Total Number of Entries in the Central
Directory.  The value stored in the Total Number of Entries in
the Central Directory on this Disk field will be 0.  The actual
values will be stored in the equivalent fields of the Zip64
End of Central Directory record.

Decrypting and decompressing the Central Directory is accomplished
in the same manner as decrypting and decompressing a file.

Certificate Processing Method:
-----------------------------

The Certificate Processing Method of for ZIP file encryption
defines the following additional data fields:

1. Certificate Flag Values

Additional processing flags that can be present in the Flags field of both
the 0x0017 field of the central directory Extra Field and the Decryption
header record preceding compressed file data are:

         0x0007 - reserved for future use
         0x000F - reserved for future use
         0x0100 - Indicates non-OAEP key wrapping was used.  If this
                  this field is set, the version needed to extract must
                  be at least 61.  This means OAEP key wrapping is not
                  used when generating a Master Session Key using
                  ErdData.
         0x4000 - ErdData must be decrypted using 3DES-168, otherwise use the
                  same algorithm used for encrypting the file contents.
         0x8000 - reserved for future use


2. CertData - Extra Field 0x0017 record certificate data structure

The data structure used to store certificate data within the section
of the Extra Field defined by the CertData field of the 0x0017
record are as shown:

          Value     Size     Description
          -----     ----     -----------
          RCount    4 bytes  Number of recipients.
          HashAlg   2 bytes  Hash algorithm identifier
          HSize     2 bytes  Hash size
          SRList    (var)    Simple list of recipients hashed public keys


     RCount    This defines the number intended recipients whose
               public keys were used for encryption.  This identifies
               the number of elements in the SRList.

     HashAlg   This defines the hash algorithm used to calculate
               the public key hash of each public key used
               for encryption. This field currently supports
               only the following value for SHA-1

               0x8004 - SHA1

     HSize     This defines the size of a hashed public key.

     SRList    This is a variable length list of the hashed
               public keys for each intended recipient.  Each
               element in this list is HSize.  The total size of
               SRList is determined using RCount * HSize.


3. Reserved1 - Certificate Decryption Header Reserved1 Data:

          Value     Size     Description
          -----     ----     -----------
          RCount    4 bytes  Number of recipients.

     RCount    This defines the number intended recipients whose
               public keys were used for encryption.  This defines
               the number of elements in the REList field defined below.


4. Reserved2 - Certificate Decryption Header Reserved2 Data Structures:


          Value     Size     Description
          -----     ----     -----------
          HashAlg   2 bytes  Hash algorithm identifier
          HSize     2 bytes  Hash size
          REList    (var)    List of recipient data elements


     HashAlg   This defines the hash algorithm used to calculate
               the public key hash of each public key used
               for encryption. This field currently supports
               only the following value for SHA-1

               0x8004 - SHA1

     HSize     This defines the size of a hashed public key
               defined in REHData.

     REList    This is a variable length of list of recipient data.
               Each element in this list consists of a Recipient
               Element data structure as follows:


    Recipient Element (REList) Data Structure:

          Value     Size     Description
          -----     ----     -----------
          RESize    2 bytes  Size of REHData + REKData
          REHData   HSize    Hash of recipients public key
          REKData   (var)    Simple key blob


     RESize    This defines the size of an individual REList
               element.  This value is the combined size of the
               REHData field + REKData field.  REHData is defined by
               HSize.  REKData is variable and can be calculated
               for each REList element using RESize and HSize.

     REHData   Hashed public key for this recipient.

     REKData   Simple Key Blob.  The format of this data structure
               is identical to that defined in the Microsoft
               CryptoAPI and generated using the CryptExportKey()
               function.  The version of the Simple Key Blob
               supported at this time is 0x02 as defined by
               Microsoft.

Certificate Processing - Central Directory Encryption:
------------------------------------------------------

Central Directory Encryption using Digital Certificates will
operate in a manner similar to that of Single Password Central
Directory Encryption.  This record will only be present when there
is data to place into it.  Currently, data is placed into this
record when digital certificates are used for either encrypting
or signing the files within a ZIP file.  When only password
encryption is used with no certificate encryption or digital
signing, this record is not currently needed. When present, this
record will appear before the start of the actual Central Directory
data structure and will be located immediately after the Archive
Decryption Header if the Central Directory is encrypted.

The Archive Extra Data record will be used to store the following
information.  Additional data may be added in future versions.

Extra Data Fields:

0x0014 - PKCS#7 Store for X.509 Certificates
0x0016 - X.509 Certificate ID and Signature for central directory
0x0019 - PKCS#7 Encryption Recipient Certificate List

The 0x0014 and 0x0016 Extra Data records that otherwise would be
located in the first record of the Central Directory for digital
certificate processing. When encrypting or compressing the Central
Directory, the 0x0014 and 0x0016 records must be located in the
Archive Extra Data record and they should not remain in the first
Central Directory record.  The Archive Extra Data record will also
be used to store the 0x0019 data.

When present, the size of the Archive Extra Data record will be
included in the size of the Central Directory.  The data of the
Archive Extra Data record will also be compressed and encrypted
along with the Central Directory data structure.

Certificate Processing Differences:

The Certificate Processing Method of encryption differs from the
Single Password Symmetric Encryption Method as follows.  Instead
of using a user-defined password to generate a master session key,
cryptographically random data is used.  The key material is then
wrapped using standard key-wrapping techniques.  This key material
is wrapped using the public key of each recipient that will need
to decrypt the file using their corresponding private key.

This specification currently assumes digital certificates will follow
the X.509 V3 format for 1024 bit and higher RSA format digital
certificates.  Implementation of this Certificate Processing Method
requires supporting logic for key access and management.  This logic
is outside the scope of this specification.

OAEP Processing with Certificate-based Encryption:

OAEP stands for Optimal Asymmetric Encryption Padding.  It is a
strengthening technique used for small encoded items such as decryption
keys.  This is commonly applied in cryptographic key-wrapping techniques
and is supported by PKCS #1.  Versions 5.0 and 6.0 of this specification
were designed to support OAEP key-wrapping for certificate-based
decryption keys for additional security.

Support for private keys stored on Smartcards or Tokens introduced
a conflict with this OAEP logic.  Most card and token products do
not support the additional strengthening applied to OAEP key-wrapped
data.  In order to resolve this conflict, versions 6.1 and above of this
specification will no longer support OAEP when encrypting using
digital certificates.

Versions of PKZIP available during initial development of the
certificate processing method set a value of 61 into the
version needed to extract field for a file.  This indicates that
non-OAEP key wrapping is used.  This affects certificate encryption
only, and password encryption functions should not be affected by
this value.  This means values of 61 may be found on files encrypted
with certificates only, or on files encrypted with both password
encryption and certificate encryption.  Files encrypted with both
methods can safely be decrypted using the password methods documented.

IX. Change Process
------------------

In order for the .ZIP file format to remain a viable definition, this
specification should be considered as open for periodic review and
revision.  Although this format was originally designed with a
certain level of extensibility, not all changes in technology
(present or future) were or will be necessarily considered in its
design.  If your application requires new definitions to the
extensible sections in this format, or if you would like to
submit new data structures, please forward your request to
zipformat@pkware.com.  All submissions will be reviewed by the
ZIP File Specification Committee for possible inclusion into
future versions of this specification.  Periodic revisions
to this specification will be published to ensure interoperability.
We encourage comments and feedback that may help improve clarity
or content.

X. Incorporating PKWARE Proprietary Technology into Your Product
----------------------------------------------------------------

PKWARE is committed to the interoperability and advancement of the
.ZIP format.  PKWARE offers a free license for certain technological
aspects described above under certain restrictions and conditions.
However, the use or implementation in a product of certain technological
aspects set forth in the current APPNOTE, including those with regard to
strong encryption, patching, or extended tape operations requires a
license from PKWARE.  Please contact PKWARE with regard to acquiring
a license.

XI. Acknowledgements
---------------------

In addition to the above mentioned contributors to PKZIP and PKUNZIP,
I would like to extend special thanks to Robert Mahoney for suggesting
the extension .ZIP for this software.

XII. References
---------------

    Fiala, Edward R., and Greene, Daniel H., "Data compression with
       finite windows",  Communications of the ACM, Volume 32, Number 4,
       April 1989, pages 490-505.

    Held, Gilbert, "Data Compression, Techniques and Applications,
       Hardware and Software Considerations", John Wiley & Sons, 1987.

    Huffman, D.A., "A method for the construction of minimum-redundancy
       codes", Proceedings of the IRE, Volume 40, Number 9, September 1952,
       pages 1098-1101.

    Nelson, Mark, "LZW Data Compression", Dr. Dobbs Journal, Volume 14,
       Number 10, October 1989, pages 29-37.

    Nelson, Mark, "The Data Compression Book",  M&T Books, 1991.

    Storer, James A., "Data Compression, Methods and Theory",
       Computer Science Press, 1988

    Welch, Terry, "A Technique for High-Performance Data Compression",
       IEEE Computer, Volume 17, Number 6, June 1984, pages 8-19.

    Ziv, J. and Lempel, A., "A universal algorithm for sequential data
       compression", Communications of the ACM, Volume 30, Number 6,
       June 1987, pages 520-540.

    Ziv, J. and Lempel, A., "Compression of individual sequences via
       variable-rate coding", IEEE Transactions on Information Theory,
       Volume 24, Number 5, September 1978, pages 530-536.


APPENDIX A - AS/400 Extra Field (0x0065) Attribute Definitions
--------------------------------------------------------------

Field Definition Structure:

   a. field length including length             2 bytes
   b. field code                                2 bytes
   c. data                                      x bytes

Field Code  Description
   4001     Source type i.e. CLP etc
   4002     The text description of the library
   4003     The text description of the file
   4004     The text description of the member
   4005     x'F0' or 0 is PF-DTA,  x'F1' or 1 is PF_SRC
   4007     Database Type Code                  1 byte
   4008     Database file and fields definition
   4009     GZIP file type                      2 bytes
   400B     IFS code page                       2 bytes
   400C     IFS Creation Time                   4 bytes
   400D     IFS Access Time                     4 bytes
   400E     IFS Modification time               4 bytes
   005C     Length of the records in the file   2 bytes
   0068     GZIP two words                      8 bytes

APPENDIX B - z/OS Extra Field (0x0065) Attribute Definitions
------------------------------------------------------------

Field Definition Structure:

   a. field length including length             2 bytes
   b. field code                                2 bytes
   c. data                                      x bytes

Field Code  Description
   0001     File Type                           2 bytes
   0002     NonVSAM Record Format               1 byte
   0003     Reserved
   0004     NonVSAM Block Size                  2 bytes Big Endian
   0005     Primary Space Allocation            3 bytes Big Endian
   0006     Secondary Space Allocation          3 bytes Big Endian
   0007     Space Allocation Type1 byte flag
   0008     Modification Date                   Retired with PKZIP 5.0 +
   0009     Expiration Date                     Retired with PKZIP 5.0 +
   000A     PDS Directory Block Allocation      3 bytes Big Endian binary value
   000B     NonVSAM Volume List                 variable
   000C     UNIT Reference                      Retired with PKZIP 5.0 +
   000D     DF/SMS Management Class             8 bytes EBCDIC Text Value
   000E     DF/SMS Storage Class                8 bytes EBCDIC Text Value
   000F     DF/SMS Data Class                   8 bytes EBCDIC Text Value
   0010     PDS/PDSE Member Info.               30 bytes
   0011     VSAM sub-filetype                   2 bytes
   0012     VSAM LRECL                          13 bytes EBCDIC "(num_avg num_max)"
   0013     VSAM Cluster Name                   Retired with PKZIP 5.0 +
   0014     VSAM KSDS Key Information           13 bytes EBCDIC "(num_length num_position)"
   0015     VSAM Average LRECL                  5 bytes EBCDIC num_value padded with blanks
   0016     VSAM Maximum LRECL                  5 bytes EBCDIC num_value padded with blanks
   0017     VSAM KSDS Key Length                5 bytes EBCDIC num_value padded with blanks
   0018     VSAM KSDS Key Position              5 bytes EBCDIC num_value padded with blanks
   0019     VSAM Data Name                      1-44 bytes EBCDIC text string
   001A     VSAM KSDS Index Name                1-44 bytes EBCDIC text string
   001B     VSAM Catalog Name                   1-44 bytes EBCDIC text string
   001C     VSAM Data Space Type                9 bytes EBCDIC text string
   001D     VSAM Data Space Primary             9 bytes EBCDIC num_value left-justified
   001E     VSAM Data Space Secondary           9 bytes EBCDIC num_value left-justified
   001F     VSAM Data Volume List               variable EBCDIC text list of 6-character Volume IDs
   0020     VSAM Data Buffer Space              8 bytes EBCDIC num_value left-justified
   0021     VSAM Data CISIZE                    5 bytes EBCDIC num_value left-justified
   0022     VSAM Erase Flag                     1 byte flag
   0023     VSAM Free CI %                      3 bytes EBCDIC num_value left-justified
   0024     VSAM Free CA %                      3 bytes EBCDIC num_value left-justified
   0025     VSAM Index Volume List              variable EBCDIC text list of 6-character Volume IDs
   0026     VSAM Ordered Flag                   1 byte flag
   0027     VSAM REUSE Flag                     1 byte flag
   0028     VSAM SPANNED Flag                   1 byte flag
   0029     VSAM Recovery Flag                  1 byte flag
   002A     VSAM  WRITECHK  Flag                1 byte flag
   002B     VSAM Cluster/Data SHROPTS           3 bytes EBCDIC "n,y"
   002C     VSAM Index SHROPTS                  3 bytes EBCDIC "n,y"
   002D     VSAM Index Space Type               9 bytes EBCDIC text string
   002E     VSAM Index Space Primary            9 bytes EBCDIC num_value left-justified
   002F     VSAM Index Space Secondary          9 bytes EBCDIC num_value left-justified
   0030     VSAM Index CISIZE                   5 bytes EBCDIC num_value left-justified
   0031     VSAM Index IMBED                    1 byte flag
   0032     VSAM Index Ordered Flag             1 byte flag
   0033     VSAM REPLICATE Flag                 1 byte flag
   0034     VSAM Index REUSE Flag               1 byte flag
   0035     VSAM Index WRITECHK Flag            1 byte flag Retired with PKZIP 5.0 +
   0036     VSAM Owner                          8 bytes EBCDIC text string
   0037     VSAM Index Owner                    8 bytes EBCDIC text string
   0038     Reserved
   0039     Reserved
   003A     Reserved
   003B     Reserved
   003C     Reserved
   003D     Reserved
   003E     Reserved
   003F     Reserved
   0040     Reserved
   0041     Reserved
   0042     Reserved
   0043     Reserved
   0044     Reserved
   0045     Reserved
   0046     Reserved
   0047     Reserved
   0048     Reserved
   0049     Reserved
   004A     Reserved
   004B     Reserved
   004C     Reserved
   004D     Reserved
   004E     Reserved
   004F     Reserved
   0050     Reserved
   0051     Reserved
   0052     Reserved
   0053     Reserved
   0054     Reserved
   0055     Reserved
   0056     Reserved
   0057     Reserved
   0058     PDS/PDSE Member TTR Info.           6 bytes  Big Endian
   0059     PDS 1st LMOD Text TTR               3 bytes  Big Endian
   005A     PDS LMOD EP Rec #                   4 bytes  Big Endian
   005B     Reserved
   005C     Max Length of records               2 bytes  Big Endian
   005D     PDSE Flag                           1 byte flag
   005E     Reserved
   005F     Reserved
   0060     Reserved
   0061     Reserved
   0062     Reserved
   0063     Reserved
   0064     Reserved
   0065     Last Date Referenced                4 bytes  Packed Hex "yyyymmdd"
   0066     Date Created                        4 bytes  Packed Hex "yyyymmdd"
   0068     GZIP two words                      8 bytes
   0071     Extended NOTE Location              12 bytes Big Endian
   0072     Archive device UNIT                 6 bytes  EBCDIC
   0073     Archive 1st Volume                  6 bytes  EBCDIC
   0074     Archive 1st VOL File Seq#           2 bytes  Binary

APPENDIX C - Zip64 Extensible Data Sector Mappings (EFS)
--------------------------------------------------------

          -Z390   Extra Field:

          The following is the general layout of the attributes for the
          ZIP 64 "extra" block for extended tape operations. Portions of
          this extended tape processing technology is covered under a
          pending patent application. The use or implementation in a
          product of certain technological aspects set forth in the
          current APPNOTE, including those with regard to strong encryption,
          patching or extended tape operations, requires a license from
          PKWARE.  Please contact PKWARE with regard to acquiring a license.


          Note: some fields stored in Big Endian format.  All text is
	  in EBCDIC format unless otherwise specified.

          Value       Size          Description
          -----       ----          -----------
  (Z390)  0x0065      2 bytes       Tag for this "extra" block type
          Size        4 bytes       Size for the following data block
          Tag         4 bytes       EBCDIC "Z390"
          Length71    2 bytes       Big Endian
          Subcode71   2 bytes       Enote type code
          FMEPos      1 byte
          Length72    2 bytes       Big Endian
          Subcode72   2 bytes       Unit type code
          Unit        1 byte        Unit
          Length73    2 bytes       Big Endian
          Subcode73   2 bytes       Volume1 type code
          FirstVol    1 byte        Volume
          Length74    2 bytes       Big Endian
          Subcode74   2 bytes       FirstVol file sequence
          FileSeq     2 bytes       Sequence

APPENDIX D - Language Encoding (EFS)
------------------------------------

The ZIP format has historically supported only the original IBM PC character
encoding set, commonly referred to as IBM Code Page 437.  This limits storing
file name characters to only those within the original MS-DOS range of values
and does not properly support file names in other character encodings, or
languages. To address this limitation, this specification will support the
following change.

If general purpose bit 11 is unset, the file name and comment should conform
to the original ZIP character encoding.  If general purpose bit 11 is set, the
filename and comment must support The Unicode Standard, Version 4.1.0 or
greater using the character encoding form defined by the UTF-8 storage
specification.  The Unicode Standard is published by the The Unicode
Consortium (www.unicode.org).  UTF-8 encoded data stored within ZIP files
is expected to not include a byte order mark (BOM).

Applications may choose to supplement this file name storage through the use
of the 0x0008 Extra Field.  Storage for this optional field is currently
undefined, however it will be used to allow storing extended information
on source or target encoding that may further assist applications with file
name, or file content encoding tasks.  Please contact PKWARE with any
requirements on how this field should be used.

The 0x0008 Extra Field storage may be used with either setting for general
purpose bit 11.  Examples of the intended usage for this field is to store
whether "modified-UTF-8" (JAVA) is used, or UTF-8-MAC.  Similarly, other
commonly used character encoding (code page) designations can be indicated
through this field.  Formalized values for use of the 0x0008 record remain
undefined at this time.  The definition for the layout of the 0x0008 field
will be published when available.  Use of the 0x0008 Extra Field provides
for storing data within a ZIP file in an encoding other than IBM Code
Page 437 or UTF-8.

General purpose bit 11 will not imply any encoding of file content or
password.  Values defining character encoding for file content or
password must be stored within the 0x0008 Extended Language Encoding
Extra Field.

Ed Gordon of the Info-ZIP group has defined a pair of "extra field" records
that can be used to store UTF-8 file name and file comment fields.  These
records can be used for cases when the general purpose bit 11 method
for storing UTF-8 data in the standard file name and comment fields is
not desirable.  A common case for this alternate method is if backward
compatibility with older programs is required.

Definitions for the record structure of these fields are included above
in the section on 3rd party mappings for "extra field" records.  These
records are identified by Header ID's 0x6375 (Info-ZIP Unicode Comment
Extra Field) and 0x7075 (Info-ZIP Unicode Path Extra Field).

The choice of which storage method to use when writing a ZIP file is left
to the implementation.  Developers should expect that a ZIP file may
contain either method and should provide support for reading data in
either format. Use of general purpose bit 11 reduces storage requirements
for file name data by not requiring additional "extra field" data for
each file, but can result in older ZIP programs not being able to extract
files.  Use of the 0x6375 and 0x7075 records will result in a ZIP file
that should always be readable by older ZIP programs, but requires more
storage per file to write file name and/or file comment fields.





The managed BZIP2 code included in Ionic.BZip2.dll and Ionic.Zip.dll is
modified code, based on the bzip2 code in the Apache commons compress
library.

The original BZip2 was created by Julian Seward, and is licensed under
the BSD license.

The following license applies to the Apache code:
-----------------------------------------------------------------------

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
{\rtf1\adeflang1025\ansi\ansicpg1252\uc1\adeff0\deff0\stshfdbch0\stshfloch31506\stshfhich31506\stshfbi31506\deflang1033\deflangfe1033\themelang1033\themelangfe0\themelangcs0{\fonttbl{\f0\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f34\fbidi \froman\fcharset0\fprq2{\*\panose 02040503050406030204}Cambria Math;}
{\f37\fbidi \fswiss\fcharset0\fprq2{\*\panose 020f0502020204030204}Calibri;}{\flomajor\f31500\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\fdbmajor\f31501\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\fhimajor\f31502\fbidi \froman\fcharset0\fprq2{\*\panose 02040503050406030204}Cambria;}
{\fbimajor\f31503\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\flominor\f31504\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\fdbminor\f31505\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\fhiminor\f31506\fbidi \fswiss\fcharset0\fprq2{\*\panose 020f0502020204030204}Calibri;}
{\fbiminor\f31507\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f39\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\f40\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}
{\f42\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\f43\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\f44\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f45\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}
{\f46\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\f47\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\f379\fbidi \froman\fcharset238\fprq2 Cambria Math CE;}{\f380\fbidi \froman\fcharset204\fprq2 Cambria Math Cyr;}
{\f382\fbidi \froman\fcharset161\fprq2 Cambria Math Greek;}{\f383\fbidi \froman\fcharset162\fprq2 Cambria Math Tur;}{\f386\fbidi \froman\fcharset186\fprq2 Cambria Math Baltic;}{\f387\fbidi \froman\fcharset163\fprq2 Cambria Math (Vietnamese);}
{\f409\fbidi \fswiss\fcharset238\fprq2 Calibri CE;}{\f410\fbidi \fswiss\fcharset204\fprq2 Calibri Cyr;}{\f412\fbidi \fswiss\fcharset161\fprq2 Calibri Greek;}{\f413\fbidi \fswiss\fcharset162\fprq2 Calibri Tur;}
{\f416\fbidi \fswiss\fcharset186\fprq2 Calibri Baltic;}{\f417\fbidi \fswiss\fcharset163\fprq2 Calibri (Vietnamese);}{\flomajor\f31508\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}
{\flomajor\f31509\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}{\flomajor\f31511\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\flomajor\f31512\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}
{\flomajor\f31513\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\flomajor\f31514\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\flomajor\f31515\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}
{\flomajor\f31516\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\fdbmajor\f31518\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\fdbmajor\f31519\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}
{\fdbmajor\f31521\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\fdbmajor\f31522\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\fdbmajor\f31523\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}
{\fdbmajor\f31524\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\fdbmajor\f31525\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\fdbmajor\f31526\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}
{\fhimajor\f31528\fbidi \froman\fcharset238\fprq2 Cambria CE;}{\fhimajor\f31529\fbidi \froman\fcharset204\fprq2 Cambria Cyr;}{\fhimajor\f31531\fbidi \froman\fcharset161\fprq2 Cambria Greek;}{\fhimajor\f31532\fbidi \froman\fcharset162\fprq2 Cambria Tur;}
{\fhimajor\f31535\fbidi \froman\fcharset186\fprq2 Cambria Baltic;}{\fhimajor\f31536\fbidi \froman\fcharset163\fprq2 Cambria (Vietnamese);}{\fbimajor\f31538\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}
{\fbimajor\f31539\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}{\fbimajor\f31541\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\fbimajor\f31542\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}
{\fbimajor\f31543\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\fbimajor\f31544\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\fbimajor\f31545\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}
{\fbimajor\f31546\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\flominor\f31548\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\flominor\f31549\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}
{\flominor\f31551\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\flominor\f31552\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\flominor\f31553\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}
{\flominor\f31554\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\flominor\f31555\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\flominor\f31556\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}
{\fdbminor\f31558\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\fdbminor\f31559\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}{\fdbminor\f31561\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}
{\fdbminor\f31562\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\fdbminor\f31563\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\fdbminor\f31564\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}
{\fdbminor\f31565\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\fdbminor\f31566\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\fhiminor\f31568\fbidi \fswiss\fcharset238\fprq2 Calibri CE;}
{\fhiminor\f31569\fbidi \fswiss\fcharset204\fprq2 Calibri Cyr;}{\fhiminor\f31571\fbidi \fswiss\fcharset161\fprq2 Calibri Greek;}{\fhiminor\f31572\fbidi \fswiss\fcharset162\fprq2 Calibri Tur;}
{\fhiminor\f31575\fbidi \fswiss\fcharset186\fprq2 Calibri Baltic;}{\fhiminor\f31576\fbidi \fswiss\fcharset163\fprq2 Calibri (Vietnamese);}{\fbiminor\f31578\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}
{\fbiminor\f31579\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}{\fbiminor\f31581\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\fbiminor\f31582\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}
{\fbiminor\f31583\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\fbiminor\f31584\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\fbiminor\f31585\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}
{\fbiminor\f31586\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;
\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;
\chyperlink\ctint255\cshade255\red0\green0\blue255;}{\*\defchp \f31506\fs22 }{\*\defpap \ql \li0\ri0\sa200\sl276\slmult1\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 }\noqfpromote {\stylesheet{\ql \li0\ri0\sa200\sl276\slmult1
\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af0\afs22\alang1025 \ltrch\fcs0 \f31506\fs22\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 \sqformat \spriority0 \styrsid2831265 Normal;}{\*\cs10 \additive 
\ssemihidden \sunhideused \spriority1 Default Paragraph Font;}{\*
\ts11\tsrowd\trftsWidthB3\trpaddl108\trpaddr108\trpaddfl3\trpaddft3\trpaddfb3\trpaddfr3\trcbpat1\trcfpat1\tblind0\tblindtype3\tsvertalt\tsbrdrt\tsbrdrl\tsbrdrb\tsbrdrr\tsbrdrdgl\tsbrdrdgr\tsbrdrh\tsbrdrv \ql \li0\ri0\sa200\sl276\slmult1
\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af31506\afs22\alang1025 \ltrch\fcs0 \f31506\fs22\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext11 \ssemihidden \sunhideused Normal Table;}{
\s15\ql \li720\ri0\sa200\sl276\slmult1\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin720\itap0\contextualspace \rtlch\fcs1 \af0\afs22\alang1025 \ltrch\fcs0 \f31506\fs22\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 
\sbasedon0 \snext15 \sqformat \spriority34 \styrsid12654801 List Paragraph;}{\*\cs16 \additive \rtlch\fcs1 \af0 \ltrch\fcs0 \ul\cf17 \sbasedon10 \sunhideused \styrsid12654801 Hyperlink;}}{\*\listtable{\list\listtemplateid-444059256\listhybrid{\listlevel
\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698703\'02\'00.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fi-360\li720\lin720 }{\listlevel\levelnfc4\levelnfcn4\leveljc0
\leveljcn0\levelfollow0\levelstartat1\lvltentative\levelspace360\levelindent0{\leveltext\leveltemplateid67698713\'02\'01.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fi-360\li1440\lin1440 }{\listlevel\levelnfc2\levelnfcn2\leveljc2\leveljcn2
\levelfollow0\levelstartat1\lvltentative\levelspace360\levelindent0{\leveltext\leveltemplateid67698715\'02\'02.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fi-180\li2160\lin2160 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0
\levelstartat1\lvltentative\levelspace360\levelindent0{\leveltext\leveltemplateid67698703\'02\'03.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fi-360\li2880\lin2880 }{\listlevel\levelnfc4\levelnfcn4\leveljc0\leveljcn0\levelfollow0\levelstartat1
\lvltentative\levelspace360\levelindent0{\leveltext\leveltemplateid67698713\'02\'04.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fi-360\li3600\lin3600 }{\listlevel\levelnfc2\levelnfcn2\leveljc2\leveljcn2\levelfollow0\levelstartat1\lvltentative
\levelspace360\levelindent0{\leveltext\leveltemplateid67698715\'02\'05.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fi-180\li4320\lin4320 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\lvltentative\levelspace360
\levelindent0{\leveltext\leveltemplateid67698703\'02\'06.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fi-360\li5040\lin5040 }{\listlevel\levelnfc4\levelnfcn4\leveljc0\leveljcn0\levelfollow0\levelstartat1\lvltentative\levelspace360\levelindent0
{\leveltext\leveltemplateid67698713\'02\'07.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fi-360\li5760\lin5760 }{\listlevel\levelnfc2\levelnfcn2\leveljc2\leveljcn2\levelfollow0\levelstartat1\lvltentative\levelspace360\levelindent0{\leveltext
\leveltemplateid67698715\'02\'08.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fi-180\li6480\lin6480 }{\listname ;}\listid137696069}{\list\listtemplateid1444199352\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0
\levelstartat1\levelspace360\levelindent0{\leveltext\leveltemplateid67698703\'02\'00.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fi-360\li720\lin720 }{\listlevel\levelnfc4\levelnfcn4\leveljc0\leveljcn0\levelfollow0\levelstartat1\lvltentative
\levelspace360\levelindent0{\leveltext\leveltemplateid67698713\'02\'01.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fi-360\li1440\lin1440 }{\listlevel\levelnfc2\levelnfcn2\leveljc2\leveljcn2\levelfollow0\levelstartat1\lvltentative\levelspace360
\levelindent0{\leveltext\leveltemplateid67698715\'02\'02.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fi-180\li2160\lin2160 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\lvltentative\levelspace360\levelindent0
{\leveltext\leveltemplateid67698703\'02\'03.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fi-360\li2880\lin2880 }{\listlevel\levelnfc4\levelnfcn4\leveljc0\leveljcn0\levelfollow0\levelstartat1\lvltentative\levelspace360\levelindent0{\leveltext
\leveltemplateid67698713\'02\'04.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fi-360\li3600\lin3600 }{\listlevel\levelnfc2\levelnfcn2\leveljc2\leveljcn2\levelfollow0\levelstartat1\lvltentative\levelspace360\levelindent0{\leveltext
\leveltemplateid67698715\'02\'05.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fi-180\li4320\lin4320 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\lvltentative\levelspace360\levelindent0{\leveltext
\leveltemplateid67698703\'02\'06.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fi-360\li5040\lin5040 }{\listlevel\levelnfc4\levelnfcn4\leveljc0\leveljcn0\levelfollow0\levelstartat1\lvltentative\levelspace360\levelindent0{\leveltext
\leveltemplateid67698713\'02\'07.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fi-360\li5760\lin5760 }{\listlevel\levelnfc2\levelnfcn2\leveljc2\leveljcn2\levelfollow0\levelstartat1\lvltentative\levelspace360\levelindent0{\leveltext
\leveltemplateid67698715\'02\'08.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fi-180\li6480\lin6480 }{\listname ;}\listid333995038}{\list\listtemplateid-2077955012\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0
\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid67698703\'02\'00.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fbias0 \fi-360\li720\lin720 }{\listlevel\levelnfc4\levelnfcn4\leveljc0\leveljcn0\levelfollow0\levelstartat1\lvltentative
\levelspace0\levelindent0{\leveltext\leveltemplateid67698713\'02\'01.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fi-360\li1440\lin1440 }{\listlevel\levelnfc2\levelnfcn2\leveljc2\leveljcn2\levelfollow0\levelstartat1\lvltentative\levelspace0
\levelindent0{\leveltext\leveltemplateid67698715\'02\'02.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fi-180\li2160\lin2160 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\lvltentative\levelspace0\levelindent0
{\leveltext\leveltemplateid67698703\'02\'03.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fi-360\li2880\lin2880 }{\listlevel\levelnfc4\levelnfcn4\leveljc0\leveljcn0\levelfollow0\levelstartat1\lvltentative\levelspace0\levelindent0{\leveltext
\leveltemplateid67698713\'02\'04.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fi-360\li3600\lin3600 }{\listlevel\levelnfc2\levelnfcn2\leveljc2\leveljcn2\levelfollow0\levelstartat1\lvltentative\levelspace0\levelindent0{\leveltext
\leveltemplateid67698715\'02\'05.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fi-180\li4320\lin4320 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\lvltentative\levelspace0\levelindent0{\leveltext
\leveltemplateid67698703\'02\'06.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fi-360\li5040\lin5040 }{\listlevel\levelnfc4\levelnfcn4\leveljc0\leveljcn0\levelfollow0\levelstartat1\lvltentative\levelspace0\levelindent0{\leveltext
\leveltemplateid67698713\'02\'07.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fi-360\li5760\lin5760 }{\listlevel\levelnfc2\levelnfcn2\leveljc2\leveljcn2\levelfollow0\levelstartat1\lvltentative\levelspace0\levelindent0{\leveltext
\leveltemplateid67698715\'02\'08.;}{\levelnumbers\'01;}\rtlch\fcs1 \af0 \ltrch\fcs0 \fi-180\li6480\lin6480 }{\listname ;}\listid1091706244}}{\*\listoverridetable{\listoverride\listid137696069\listoverridecount0\ls1}{\listoverride\listid1091706244
\listoverridecount0\ls2}{\listoverride\listid333995038\listoverridecount0\ls3}}{\*\rsidtbl \rsid1395907\rsid1599071\rsid1639370\rsid2831265\rsid2840296\rsid4537929\rsid5062432\rsid5376635\rsid6358681\rsid6962690\rsid7287725\rsid7959479\rsid8155306
\rsid8258241\rsid10224083\rsid11415624\rsid11736570\rsid12266757\rsid12654801\rsid12911876\rsid13976247\rsid14944920}{\mmathPr\mmathFont34\mbrkBin0\mbrkBinSub0\msmallFrac0\mdispDef1\mlMargin0\mrMargin0\mdefJc1\mwrapIndent1440\mintLim0\mnaryLim1}{\info
{\author Dino Chiesa}{\operator Dino}{\creatim\yr2008\mo7\dy3\hr11\min53}{\revtim\yr2011\mo7\dy27\hr10\min34}{\version10}{\edmins30}{\nofpages3}{\nofwords979}{\nofchars5585}{\*\company Microsoft}{\nofcharsws6551}{\vern49273}}{\*\xmlnstbl {\xmlns1 http://s
chemas.microsoft.com/office/word/2003/wordml}}\paperw12240\paperh15840\margl1440\margr1440\margt1440\margb1440\gutter0\ltrsect 
\widowctrl\ftnbj\aenddoc\trackmoves0\trackformatting1\donotembedsysfont1\relyonvml0\donotembedlingdata0\grfdocevents0\validatexml1\showplaceholdtext0\ignoremixedcontent0\saveinvalidxml0\showxmlerrors1\noxlattoyen
\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\formshade\horzdoc\dgmargin\dghspace180\dgvspace180\dghorigin1440\dgvorigin1440\dghshow1\dgvshow1
\jexpand\viewkind1\viewscale110\pgbrdrhead\pgbrdrfoot\splytwnine\ftnlytwnine\htmautsp\nolnhtadjtbl\useltbaln\alntblind\lytcalctblwd\lyttblrtgr\lnbrkrule\nobrkwrptbl\snaptogridincell\allowfieldendsel\wrppunct
\asianbrkrule\rsidroot8258241\newtblstyruls\nogrowautofit\usenormstyforlist\noindnmbrts\felnbrelev\nocxsptable\indrlsweleven\noafcnsttbl\afelev\utinl\hwelev\spltpgpar\notcvasp\notbrkcnstfrctbl\notvatxbx\krnprsnet\cachedcolbal \nouicompat \fet0
{\*\wgrffmtfilter 2450}\nofeaturethrottle1\ilfomacatclnup0\ltrpar \sectd \ltrsect\linex0\endnhere\sectlinegrid360\sectdefaultcl\sectrsid2831265\sftnbj {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl2
\pnucltr\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang {\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl6
\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang 
{\pntxtb (}{\pntxta )}}\pard\plain \ltrpar\ql \li0\ri0\sa200\sl276\slmult1\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid8258241 \rtlch\fcs1 \af0\afs22\alang1025 \ltrch\fcs0 
\f31506\fs22\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \af0\afs28 \ltrch\fcs0 \fs28\insrsid12654801 Software }{\rtlch\fcs1 \af0\afs28 \ltrch\fcs0 \fs28\insrsid12654801\charrsid12654801 Licenses }{\rtlch\fcs1 \af0\afs28 \ltrch\fcs0 
\fs28\insrsid12654801 that apply to DotNetZip}{\rtlch\fcs1 \af0\afs28 \ltrch\fcs0 \fs28\insrsid12654801\charrsid12654801 
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid12654801\charrsid12654801 This software,}{\rtlch\fcs1 \af0 \ltrch\fcs0 \b\i\insrsid12654801  t}{\rtlch\fcs1 \af0 \ltrch\fcs0 \b\i\insrsid12654801\charrsid12654801 he}{\rtlch\fcs1 \af0 \ltrch\fcs0 
\b\i\insrsid8258241\charrsid12654801  DotNetZip}{\rtlch\fcs1 \af0 \ltrch\fcs0 \b\i\insrsid8258241\charrsid5376635  library}{\rtlch\fcs1 \af0 \ltrch\fcs0 \b\i\insrsid12911876  and tools}{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid8258241  }{\rtlch\fcs1 \af0 
\ltrch\fcs0 \insrsid12654801 is provided for your use under several }{\rtlch\fcs1 \af0 \ltrch\fcs0 \i\insrsid12654801\charrsid12654801 licenses}{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid8258241 . }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid12654801 
 One license applies to DotNetZip, and }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid7287725 several}{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid12654801  other licenses apply to work that DotNetZip derives from. To }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid8258241 
use the software, you }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid12654801 must accept the}{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid8258241  license}{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid12654801 s}{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid8258241 
. If you do not accept the license}{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid7287725 s}{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid8258241 , do not use the software.
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid12654801 The following license, the }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid12654801\charrsid12654801 Microsoft Public License (Ms-PL)}{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid12654801 ,}{\rtlch\fcs1 \af0 \ltrch\fcs0 
\insrsid12654801\charrsid12654801  }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid12654801 applies to the original intellectual property in DotNetZip: }{\rtlch\fcs1 \af0\afs28 \ltrch\fcs0 \fs28\insrsid12654801\charrsid12654801 
\par }\pard \ltrpar\ql \li360\ri0\sa80\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0\pararsid1639370 {\rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \fs18\insrsid8258241\charrsid1639370 1. Definitions
\par }\pard \ltrpar\ql \li720\ri0\sa120\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin720\itap0\pararsid1639370 {\rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \fs18\insrsid8258241\charrsid1639370 
The terms "reproduce," "reproduction," "derivative works," and "distribution" have the same meaning here as under U.S. copyright law.
\par A "contribution" is the original software, or any additions or changes to the software.
\par A "contributor" is any person that distributes its contribution under this license.
\par "Licensed patents" are a contributor's patent claims that read directly on its contribution.
\par }\pard \ltrpar\ql \li360\ri0\sa80\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0\pararsid1639370 {\rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \fs18\insrsid8258241\charrsid1639370 2. Grant of Rights
\par }\pard \ltrpar\ql \li720\ri0\sa80\sl276\slmult1\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin720\itap0\pararsid1639370 {\rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \fs18\insrsid8258241\charrsid1639370 (A
) Copyright Grant- Subject to the terms of this license, including the license conditions and limitations in section 3, each contributor grants you a non-exclusive, worldwide, royalty-free copyright license to reproduce its contribution, prepare derivativ
e works of its contribution, and distribute its contribution or any derivative works that you create.
\par (B) Patent Grant- Subject to the terms of this license, including the license conditions and limitations in section 3, each contributor grants you a non-ex
clusive, worldwide, royalty-free license under its licensed patents to make, have made, use, sell, offer for sale, import, and/or otherwise dispose of its contribution in the software or derivative works of th}{\rtlch\fcs1 \af0\afs18 \ltrch\fcs0 
\fs18\insrsid1639370\charrsid1639370 e contribution in the software.}{\rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \fs18\insrsid8258241\charrsid1639370 
\par }\pard \ltrpar\ql \li360\ri0\sa80\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0\pararsid1639370 {\rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \fs18\insrsid8258241\charrsid1639370 3. Conditions and Limitations
\par }\pard \ltrpar\ql \li720\ri0\sa80\sl276\slmult1\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin720\itap0\pararsid1639370 {\rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \fs18\insrsid8258241\charrsid1639370 (A) No Trademark License}{\rtlch\fcs1 
\af0\afs18 \ltrch\fcs0 \fs18\insrsid11736570\charrsid1639370  }{\rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \fs18\insrsid8258241\charrsid1639370 - This license does not grant you rights to use any contributor}{\rtlch\fcs1 \af0\afs18 \ltrch\fcs0 
\fs18\insrsid5376635\charrsid1639370 \rquote s}{\rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \fs18\insrsid8258241\charrsid1639370  name, logo, or trademarks.
\par (B) If you bring a patent claim against any contributor over patents that you claim are infringed by the software, your patent license from such contributor to the software ends automatically.
\par (C) If you distribute any portion of the software, you must retain all copyright, patent, trademark, and attribution notices that are present in the software.
\par (D) If you distribute any p
ortion of the software in source code form, you may do so only under this license by including a complete copy of this license with your distribution. If you distribute any portion of the software in compiled or object code form, you may only do so under 
a license that complies with this license.
\par (E) The software is licensed "as-is." You bear the risk of using it. The contributors give no express warranties, guarantees or conditions. You may have additional consumer rights under your local laws which this l
icense cannot change. To the extent permitted under your local laws, the contributors exclude the implied warranties of merchantability, fitness for a particular purpose and non-infringement.}{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid8258241  
\par }{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid14944920 
\par }\pard \ltrpar\ql \li0\ri0\sa200\sl276\slmult1\widctlpar\brdrt\brdrs\brdrw10\brsp20 \wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid12654801 {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid12654801 
\par }\pard \ltrpar\ql \li0\ri0\sa200\sl276\slmult1\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid12654801 {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid12654801 The managed ZLIB code included in Ionic.Zlib.dll and Ionic.Zi
p.dll is derived from the jzlib, which is Copyright (c) 2000,2001,2002,2003 ymnk, JCraft, Inc., and is licensed under the following terms: 
\par }\pard \ltrpar\ql \li360\ri0\sa200\sl276\slmult1\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0\pararsid12654801 {\rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \fs18\insrsid12654801\charrsid14944920 
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
\par {\listtext\pard\plain\ltrpar \s15 \rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \f31506\fs18\insrsid12654801\charrsid14944920 \hich\af31506\dbch\af0\loch\f31506 1.\tab}}\pard\plain \ltrpar\s15\ql \fi-360\li1080\ri0\sa200\sl276\slmult1
\widctlpar\wrapdefault\aspalpha\aspnum\faauto\ls2\adjustright\rin0\lin1080\itap0\pararsid12654801\contextualspace \rtlch\fcs1 \af0\afs22\alang1025 \ltrch\fcs0 \f31506\fs22\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \af0\afs18 
\ltrch\fcs0 \fs18\insrsid12654801\charrsid14944920 Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
\par {\listtext\pard\plain\ltrpar \s15 \rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \f31506\fs18\insrsid12654801\charrsid14944920 \hich\af31506\dbch\af0\loch\f31506 2.\tab}Redistributions in binary form must reproduce the above copyright notice, this list of conditions 
and the following disclaimer in the documentation and/or other materials provided with the distribution.
\par {\listtext\pard\plain\ltrpar \s15 \rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \f31506\fs18\insrsid12654801\charrsid14944920 \hich\af31506\dbch\af0\loch\f31506 3.\tab}}\pard \ltrpar\s15\ql \fi-360\li1080\ri0\sa200\sl276\slmult1
\widctlpar\wrapdefault\aspalpha\aspnum\faauto\ls2\adjustright\rin0\lin1080\itap0\pararsid11415624\contextualspace {\rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \fs18\insrsid12654801\charrsid14944920 
The names of the authors may not be used to endorse or promote products derived from this software without specific prior written permission.
\par }\pard\plain \ltrpar\ql \li360\ri0\sa200\sl276\slmult1\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin360\itap0\pararsid12654801 \rtlch\fcs1 \af0\afs22\alang1025 \ltrch\fcs0 \f31506\fs22\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 
{\rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \fs18\insrsid12654801\charrsid12654801 THIS S
OFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT, INC. OR ANY CONTRIBUTORS TO THIS
 
SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
\par }\pard \ltrpar\ql \li0\ri0\sa200\sl276\slmult1\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid12654801 {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid12654801 
\par }\pard \ltrpar\ql \li0\ri0\sa200\sl276\slmult1\widctlpar\brdrt\brdrs\brdrw10\brsp20 \wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid12654801 {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid12654801 
\par }\pard \ltrpar\ql \li0\ri0\sa200\sl276\slmult1\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid12654801 {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid12654801 The jzlib library, itself, is based
 on the C-language ZLIB library, v1.1.3.  The following notice and license applies to zlib:
\par }\pard \ltrpar\ql \li720\ri0\sa200\sl276\slmult1\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin720\itap0\pararsid12654801 {\rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \fs18\insrsid12654801\charrsid14944920 
ZLIB is Copyright (C) 1995-2004 Jean-loup Gailly and Mark Adler
\par The ZLIB software is provided 'as-is', without any express or implied warranty.  In no event will the authors be held liable for any damages arising from the use of this software.
\par Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:
\par {\listtext\pard\plain\ltrpar \s15 \rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \f31506\fs18\insrsid12654801\charrsid14944920 \hich\af31506\dbch\af0\loch\f31506 1.\tab}}\pard\plain \ltrpar\s15\ql \fi-360\li1440\ri0\sa200\sl276\slmult1
\widctlpar\wrapdefault\aspalpha\aspnum\faauto\ls3\adjustright\rin0\lin1440\itap0\pararsid12654801\contextualspace \rtlch\fcs1 \af0\afs22\alang1025 \ltrch\fcs0 \f31506\fs22\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \af0\afs18 
\ltrch\fcs0 \fs18\insrsid12654801\charrsid14944920 
The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required. 
\par {\listtext\pard\plain\ltrpar \s15 \rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \f31506\fs18\insrsid12654801\charrsid14944920 \hich\af31506\dbch\af0\loch\f31506 2.\tab}
Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software. 
\par {\listtext\pard\plain\ltrpar \s15 \rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \f31506\fs18\insrsid12654801\charrsid14944920 \hich\af31506\dbch\af0\loch\f31506 3.\tab}This notice may not be removed or altered from any source distribution.
\par }\pard\plain \ltrpar\ql \li720\ri0\sa200\sl276\slmult1\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin720\itap0\pararsid12654801 \rtlch\fcs1 \af0\afs22\alang1025 \ltrch\fcs0 \f31506\fs22\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 
{\rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \fs18\insrsid12654801\charrsid14944920   Jean-loup Gailly }{\rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \fs18\insrsid6962690\charrsid14944920      }{\rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \fs18\insrsid12654801\charrsid14944920 
jloup@gzip.org\line   Mark Adler}{\rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \fs18\insrsid6962690\charrsid14944920      }{\rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \fs18\insrsid12654801\charrsid14944920  madler@alumni.caltech.edu}{\rtlch\fcs1 \af0 \ltrch\fcs0 
\insrsid12654801 
\par }\pard \ltrpar\ql \li0\ri0\sa200\sl276\slmult1\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid4537929 {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4537929 
\par }\pard \ltrpar\ql \li0\ri0\sa200\sl276\slmult1\widctlpar\brdrt\brdrs\brdrw10\brsp20 \wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid4537929 {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4537929 
\par }\pard \ltrpar\ql \li0\ri0\sa200\sl276\slmult1\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid4537929 {\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4537929 
The managed BZIP2 code included in Ionic.BZip2.dll and Ionic.Zip.dll is modified code, based on the bzip2 code in the Apache commons compress library.
\par The original BZip2 was created by Julian Seward, and is licensed under the BSD license.
\par The following license applies to the Apache code:}{\rtlch\fcs1 \af0 \ltrch\fcs0 \insrsid4537929 
\par }\pard \ltrpar\ql \li720\ri0\sa200\sl276\slmult1\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin720\itap0\pararsid4537929 {\rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \fs18\insrsid4537929\charrsid4537929 
Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements.  See the NOTICE file distributed with this work for additional information regarding copyright ownership.  The ASF lice
nses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.  You may obtain a copy of the License at
\par http://www.}{\rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \fs18\insrsid4537929 apache.org/licenses/LICENSE-2.0}{\rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \fs18\insrsid4537929\charrsid4537929 
\par Unless required by applicabl
e law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the specific language governing permissions and limitat
ions under the License.}{\rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \fs18\insrsid4537929 
\par }{\rtlch\fcs1 \af0\afs18 \ltrch\fcs0 \fs18\insrsid7287725\charrsid4537929 
\par }{\*\themedata 504b030414000600080000002100e9de0fbfff0000001c020000130000005b436f6e74656e745f54797065735d2e786d6cac91cb4ec3301045f748fc83e52d4a
9cb2400825e982c78ec7a27cc0c8992416c9d8b2a755fbf74cd25442a820166c2cd933f79e3be372bd1f07b5c3989ca74aaff2422b24eb1b475da5df374fd9ad
5689811a183c61a50f98f4babebc2837878049899a52a57be670674cb23d8e90721f90a4d2fa3802cb35762680fd800ecd7551dc18eb899138e3c943d7e503b6
b01d583deee5f99824e290b4ba3f364eac4a430883b3c092d4eca8f946c916422ecab927f52ea42b89a1cd59c254f919b0e85e6535d135a8de20f20b8c12c3b0
0c895fcf6720192de6bf3b9e89ecdbd6596cbcdd8eb28e7c365ecc4ec1ff1460f53fe813d3cc7f5b7f020000ffff0300504b030414000600080000002100a5d6
a7e7c0000000360100000b0000005f72656c732f2e72656c73848fcf6ac3300c87ef85bd83d17d51d2c31825762fa590432fa37d00e1287f68221bdb1bebdb4f
c7060abb0884a4eff7a93dfeae8bf9e194e720169aaa06c3e2433fcb68e1763dbf7f82c985a4a725085b787086a37bdbb55fbc50d1a33ccd311ba548b6309512
0f88d94fbc52ae4264d1c910d24a45db3462247fa791715fd71f989e19e0364cd3f51652d73760ae8fa8c9ffb3c330cc9e4fc17faf2ce545046e37944c69e462
a1a82fe353bd90a865aad41ed0b5b8f9d6fd010000ffff0300504b0304140006000800000021006b799616830000008a0000001c0000007468656d652f746865
6d652f7468656d654d616e616765722e786d6c0ccc4d0ac3201040e17da17790d93763bb284562b2cbaebbf600439c1a41c7a0d29fdbd7e5e38337cedf14d59b
4b0d592c9c070d8a65cd2e88b7f07c2ca71ba8da481cc52c6ce1c715e6e97818c9b48d13df49c873517d23d59085adb5dd20d6b52bd521ef2cdd5eb9246a3d8b
4757e8d3f729e245eb2b260a0238fd010000ffff0300504b03041400060008000000210096b5ade296060000501b0000160000007468656d652f7468656d652f
7468656d65312e786d6cec594f6fdb3614bf0fd87720746f6327761a07758ad8b19b2d4d1bc46e871e698996d850a240d2497d1bdae38001c3ba618715d86d87
615b8116d8a5fb34d93a6c1dd0afb0475292c5585e9236d88aad3e2412f9e3fbff1e1fa9abd7eec70c1d1221294fda5efd72cd4324f1794093b0eddd1ef62fad
79482a9c0498f184b4bd2991deb58df7dfbb8ad755446282607d22d771db8b944ad79796a40fc3585ee62949606ecc458c15bc8a702910f808e8c66c69b9565b
5d8a314d3c94e018c8de1a8fa94fd05093f43672e23d06af89927ac06762a049136785c10607758d9053d965021d62d6f6804fc08f86e4bef210c352c144dbab
999fb7b4717509af678b985ab0b6b4ae6f7ed9ba6c4170b06c788a705430adf71bad2b5b057d03606a1ed7ebf5babd7a41cf00b0ef83a6569632cd467faddec9
699640f6719e76b7d6ac355c7c89feca9cccad4ea7d36c65b258a206641f1b73f8b5da6a6373d9c11b90c537e7f08dce66b7bbeae00dc8e257e7f0fd2badd586
8b37a088d1e4600ead1ddaef67d40bc898b3ed4af81ac0d76a197c86826828a24bb318f3442d8ab518dfe3a20f000d6458d104a9694ac6d88728eee2782428d6
0cf03ac1a5193be4cbb921cd0b495fd054b5bd0f530c1931a3f7eaf9f7af9e3f45c70f9e1d3ff8e9f8e1c3e3073f5a42ceaa6d9c84e5552fbffdeccfc71fa33f
9e7ef3f2d117d57859c6fffac327bffcfc793510d26726ce8b2f9ffcf6ecc98baf3efdfdbb4715f04d814765f890c644a29be408edf3181433567125272371be
15c308d3f28acd249438c19a4b05fd9e8a1cf4cd296699771c393ac4b5e01d01e5a30a787d72cf1178108989a2159c77a2d801ee72ce3a5c545a6147f32a9979
3849c26ae66252c6ed637c58c5bb8b13c7bfbd490a75330f4b47f16e441c31f7184e140e494214d273fc80900aedee52ead87597fa824b3e56e82e451d4c2b4d
32a423279a668bb6690c7e9956e90cfe766cb37b077538abd27a8b1cba48c80acc2a841f12e698f13a9e281c57911ce298950d7e03aba84ac8c154f8655c4f2a
f074481847bd804859b5e696007d4b4edfc150b12addbecba6b18b148a1e54d1bc81392f23b7f84137c2715a851dd0242a633f900710a218ed715505dfe56e86
e877f0034e16bafb0e258ebb4faf06b769e888340b103d3311da9750aa9d0a1cd3e4efca31a3508f6d0c5c5c398602f8e2ebc71591f5b616e24dd893aa3261fb
44f95d843b5974bb5c04f4edafb95b7892ec1108f3f98de75dc97d5772bdff7cc95d94cf672db4b3da0a6557f70db629362d72bcb0431e53c6066acac80d699a
6409fb44d08741bdce9c0e4971624a2378cceaba830b05366b90e0ea23aaa241845368b0eb9e2612ca8c742851ca251ceccc70256d8d87265dd96361531f186c
3d9058edf2c00eafe8e1fc5c509031bb4d680e9f39a3154de0accc56ae644441edd76156d7429d995bdd88664a9dc3ad50197c38af1a0c16d684060441db0256
5e85f3b9660d0713cc48a0ed6ef7dedc2dc60b17e92219e180643ed27acffba86e9c94c78ab90980d8a9f0913ee49d62b512b79626fb06dccee2a432bbc60276
b9f7dec44b7904cfbca4f3f6443ab2a49c9c2c41476dafd55c6e7ac8c769db1bc399161ee314bc2e75cf8759081743be1236ec4f4d6693e5336fb672c5dc24a8
c33585b5fb9cc24e1d4885545b58463634cc5416022cd19cacfccb4d30eb45296023fd35a458598360f8d7a4003bbaae25e331f155d9d9a5116d3bfb9a95523e
51440ca2e0088dd844ec6370bf0e55d027a012ae264c45d02f708fa6ad6da6dce29c255df9f6cae0ec38666984b372ab5334cf640b37795cc860de4ae2816e95
b21be5ceaf8a49f90b52a51cc6ff3355f47e0237052b81f6800fd7b802239daf6d8f0b1571a8426944fdbe80c6c1d40e8816b88b8569082ab84c36ff0539d4ff
6dce591a26ade1c0a7f669880485fd484582903d284b26fa4e2156cff62e4b9265844c4495c495a9157b440e091bea1ab8aaf7760f4510eaa69a6465c0e04ec6
9ffb9e65d028d44d4e39df9c1a52ecbd3607fee9cec7263328e5d661d3d0e4f62f44acd855ed7ab33cdf7bcb8ae889599bd5c8b3029895b6825696f6af29c239
b75a5bb1e6345e6ee6c28117e73586c1a2214ae1be07e93fb0ff51e133fb65426fa843be0fb515c187064d0cc206a2fa926d3c902e907670048d931db4c1a449
59d366ad93b65abe595f70a75bf03d616c2dd959fc7d4e6317cd99cbcec9c58b34766661c7d6766ca1a9c1b327531486c6f941c638c67cd22a7f75e2a37be0e8
2db8df9f30254d30c1372581a1f51c983c80e4b71ccdd28dbf000000ffff0300504b0304140006000800000021000dd1909fb60000001b010000270000007468
656d652f7468656d652f5f72656c732f7468656d654d616e616765722e786d6c2e72656c73848f4d0ac2301484f78277086f6fd3ba109126dd88d0add40384e4
350d363f2451eced0dae2c082e8761be9969bb979dc9136332de3168aa1a083ae995719ac16db8ec8e4052164e89d93b64b060828e6f37ed1567914b284d2624
52282e3198720e274a939cd08a54f980ae38a38f56e422a3a641c8bbd048f7757da0f19b017cc524bd62107bd5001996509affb3fd381a89672f1f165dfe5141
73d9850528a2c6cce0239baa4c04ca5bbabac4df000000ffff0300504b01022d0014000600080000002100e9de0fbfff0000001c020000130000000000000000
0000000000000000005b436f6e74656e745f54797065735d2e786d6c504b01022d0014000600080000002100a5d6a7e7c0000000360100000b00000000000000
000000000000300100005f72656c732f2e72656c73504b01022d00140006000800000021006b799616830000008a0000001c0000000000000000000000000019
0200007468656d652f7468656d652f7468656d654d616e616765722e786d6c504b01022d001400060008000000210096b5ade296060000501b00001600000000
000000000000000000d60200007468656d652f7468656d652f7468656d65312e786d6c504b01022d00140006000800000021000dd1909fb60000001b01000027
00000000000000000000000000a00900007468656d652f7468656d652f5f72656c732f7468656d654d616e616765722e786d6c2e72656c73504b050600000000050005005d0100009b0a00000000}
{\*\colorschememapping 3c3f786d6c2076657273696f6e3d22312e302220656e636f64696e673d225554462d3822207374616e64616c6f6e653d22796573223f3e0d0a3c613a636c724d
617020786d6c6e733a613d22687474703a2f2f736368656d61732e6f70656e786d6c666f726d6174732e6f72672f64726177696e676d6c2f323030362f6d6169
6e22206267313d226c743122207478313d22646b3122206267323d226c743222207478323d22646b322220616363656e74313d22616363656e74312220616363
656e74323d22616363656e74322220616363656e74333d22616363656e74332220616363656e74343d22616363656e74342220616363656e74353d22616363656e74352220616363656e74363d22616363656e74362220686c696e6b3d22686c696e6b2220666f6c486c696e6b3d22666f6c486c696e6b222f3e}
{\*\latentstyles\lsdstimax267\lsdlockeddef0\lsdsemihiddendef1\lsdunhideuseddef1\lsdqformatdef0\lsdprioritydef99{\lsdlockedexcept \lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority0 \lsdlocked0 Normal;
\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority9 \lsdlocked0 heading 1;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 2;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 3;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 4;
\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 5;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 6;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 7;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 8;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 9;
\lsdpriority39 \lsdlocked0 toc 1;\lsdpriority39 \lsdlocked0 toc 2;\lsdpriority39 \lsdlocked0 toc 3;\lsdpriority39 \lsdlocked0 toc 4;\lsdpriority39 \lsdlocked0 toc 5;\lsdpriority39 \lsdlocked0 toc 6;\lsdpriority39 \lsdlocked0 toc 7;
\lsdpriority39 \lsdlocked0 toc 8;\lsdpriority39 \lsdlocked0 toc 9;\lsdqformat1 \lsdpriority35 \lsdlocked0 caption;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority10 \lsdlocked0 Title;\lsdpriority1 \lsdlocked0 Default Paragraph Font;
\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority11 \lsdlocked0 Subtitle;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority22 \lsdlocked0 Strong;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority20 \lsdlocked0 Emphasis;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority59 \lsdlocked0 Table Grid;\lsdunhideused0 \lsdlocked0 Placeholder Text;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority1 \lsdlocked0 No Spacing;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading;\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List;\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List;\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List;\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid;\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading Accent 1;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 1;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1 Accent 1;\lsdunhideused0 \lsdlocked0 Revision;
\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority34 \lsdlocked0 List Paragraph;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority29 \lsdlocked0 Quote;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority30 \lsdlocked0 Intense Quote;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2 Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 1;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading Accent 1;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading Accent 2;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 2;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1 Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2 Accent 2;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 2;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List Accent 2;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List Accent 3;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 3;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1 Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2 Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 3;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List Accent 3;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid Accent 3;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid Accent 4;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1 Accent 4;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2 Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 4;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading Accent 4;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading Accent 5;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 5;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1 Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2 Accent 5;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 5;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List Accent 5;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List Accent 6;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 6;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1 Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2 Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 6;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List Accent 6;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid Accent 6;
\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority19 \lsdlocked0 Subtle Emphasis;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority21 \lsdlocked0 Intense Emphasis;
\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority31 \lsdlocked0 Subtle Reference;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority32 \lsdlocked0 Intense Reference;
\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority33 \lsdlocked0 Book Title;\lsdpriority37 \lsdlocked0 Bibliography;\lsdqformat1 \lsdpriority39 \lsdlocked0 TOC Heading;}}{\*\datastore 010500000200000018000000
4d73786d6c322e534158584d4c5265616465722e362e3000000000000000000000060000
d0cf11e0a1b11ae1000000000000000000000000000000003e000300feff090006000000000000000000000001000000010000000000000000100000feffffff00000000feffffff0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
fffffffffffffffffdfffffffeffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffff52006f006f007400200045006e00740072007900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016000500ffffffffffffffffffffffff0c6ad98892f1d411a65f0040963251e5000000000000000000000000c0f9
b4436a4ccc01feffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffff0000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffff000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000105000000000000}}{\rtf1\adeflang1025\ansi\ansicpg1252\uc1\adeff31507\deff0\stshfdbch0\stshfloch31506\stshfhich31506\stshfbi31506\deflang1033\deflangfe1033\themelang1033\themelangfe0\themelangcs0{\fonttbl{\f0\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f34\fbidi \froman\fcharset0\fprq2{\*\panose 02040503050406030204}Cambria Math;}
{\f37\fbidi \fswiss\fcharset0\fprq2{\*\panose 020f0502020204030204}Calibri;}{\flomajor\f31500\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\fdbmajor\f31501\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\fhimajor\f31502\fbidi \froman\fcharset0\fprq2{\*\panose 02040503050406030204}Cambria;}
{\fbimajor\f31503\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\flominor\f31504\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\fdbminor\f31505\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\fhiminor\f31506\fbidi \fswiss\fcharset0\fprq2{\*\panose 020f0502020204030204}Calibri;}
{\fbiminor\f31507\fbidi \froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f39\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\f40\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}
{\f42\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\f43\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\f44\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f45\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}
{\f46\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\f47\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\f379\fbidi \froman\fcharset238\fprq2 Cambria Math CE;}{\f380\fbidi \froman\fcharset204\fprq2 Cambria Math Cyr;}
{\f382\fbidi \froman\fcharset161\fprq2 Cambria Math Greek;}{\f383\fbidi \froman\fcharset162\fprq2 Cambria Math Tur;}{\f386\fbidi \froman\fcharset186\fprq2 Cambria Math Baltic;}{\f409\fbidi \fswiss\fcharset238\fprq2 Calibri CE;}
{\f410\fbidi \fswiss\fcharset204\fprq2 Calibri Cyr;}{\f412\fbidi \fswiss\fcharset161\fprq2 Calibri Greek;}{\f413\fbidi \fswiss\fcharset162\fprq2 Calibri Tur;}{\f416\fbidi \fswiss\fcharset186\fprq2 Calibri Baltic;}
{\flomajor\f31508\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\flomajor\f31509\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}{\flomajor\f31511\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}
{\flomajor\f31512\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\flomajor\f31513\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\flomajor\f31514\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}
{\flomajor\f31515\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\flomajor\f31516\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\fdbmajor\f31518\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}
{\fdbmajor\f31519\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}{\fdbmajor\f31521\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\fdbmajor\f31522\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}
{\fdbmajor\f31523\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\fdbmajor\f31524\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\fdbmajor\f31525\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}
{\fdbmajor\f31526\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\fhimajor\f31528\fbidi \froman\fcharset238\fprq2 Cambria CE;}{\fhimajor\f31529\fbidi \froman\fcharset204\fprq2 Cambria Cyr;}
{\fhimajor\f31531\fbidi \froman\fcharset161\fprq2 Cambria Greek;}{\fhimajor\f31532\fbidi \froman\fcharset162\fprq2 Cambria Tur;}{\fhimajor\f31535\fbidi \froman\fcharset186\fprq2 Cambria Baltic;}
{\fbimajor\f31538\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\fbimajor\f31539\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}{\fbimajor\f31541\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}
{\fbimajor\f31542\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\fbimajor\f31543\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\fbimajor\f31544\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}
{\fbimajor\f31545\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\fbimajor\f31546\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\flominor\f31548\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}
{\flominor\f31549\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}{\flominor\f31551\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\flominor\f31552\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}
{\flominor\f31553\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\flominor\f31554\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\flominor\f31555\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}
{\flominor\f31556\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\fdbminor\f31558\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\fdbminor\f31559\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}
{\fdbminor\f31561\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\fdbminor\f31562\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\fdbminor\f31563\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}
{\fdbminor\f31564\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\fdbminor\f31565\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\fdbminor\f31566\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}
{\fhiminor\f31568\fbidi \fswiss\fcharset238\fprq2 Calibri CE;}{\fhiminor\f31569\fbidi \fswiss\fcharset204\fprq2 Calibri Cyr;}{\fhiminor\f31571\fbidi \fswiss\fcharset161\fprq2 Calibri Greek;}{\fhiminor\f31572\fbidi \fswiss\fcharset162\fprq2 Calibri Tur;}
{\fhiminor\f31575\fbidi \fswiss\fcharset186\fprq2 Calibri Baltic;}{\fbiminor\f31578\fbidi \froman\fcharset238\fprq2 Times New Roman CE;}{\fbiminor\f31579\fbidi \froman\fcharset204\fprq2 Times New Roman Cyr;}
{\fbiminor\f31581\fbidi \froman\fcharset161\fprq2 Times New Roman Greek;}{\fbiminor\f31582\fbidi \froman\fcharset162\fprq2 Times New Roman Tur;}{\fbiminor\f31583\fbidi \froman\fcharset177\fprq2 Times New Roman (Hebrew);}
{\fbiminor\f31584\fbidi \froman\fcharset178\fprq2 Times New Roman (Arabic);}{\fbiminor\f31585\fbidi \froman\fcharset186\fprq2 Times New Roman Baltic;}{\fbiminor\f31586\fbidi \froman\fcharset163\fprq2 Times New Roman (Vietnamese);}}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;
\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\*\defchp \f31506\fs22 }{\*\defpap \ql \li0\ri0\sa200\sl276\slmult1
\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 }\noqfpromote {\stylesheet{\ql \li0\ri0\sa200\sl276\slmult1\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af31507\afs22\alang1025 
\ltrch\fcs0 \f31506\fs22\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 \sqformat \spriority0 \styrsid2831265 Normal;}{\*\cs10 \additive \ssemihidden \sunhideused \spriority1 Default Paragraph Font;}{\*
\ts11\tsrowd\trftsWidthB3\trpaddl108\trpaddr108\trpaddfl3\trpaddft3\trpaddfb3\trpaddfr3\trcbpat1\trcfpat1\tblind0\tblindtype3\tscellwidthfts0\tsvertalt\tsbrdrt\tsbrdrl\tsbrdrb\tsbrdrr\tsbrdrdgl\tsbrdrdgr\tsbrdrh\tsbrdrv \ql \li0\ri0\sa200\sl276\slmult1
\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \rtlch\fcs1 \af31506\afs22\alang1025 \ltrch\fcs0 \f31506\fs22\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext11 \ssemihidden \sunhideused \sqformat Normal Table;}}
{\*\rsidtbl \rsid1395907\rsid1599071\rsid2831265\rsid2840296\rsid5062432\rsid5376635\rsid6358681\rsid8155306\rsid8258241\rsid10224083\rsid11736570\rsid12266757\rsid12911876\rsid13976247}{\mmathPr\mmathFont34\mbrkBin0\mbrkBinSub0\msmallFrac0\mdispDef1
\mlMargin0\mrMargin0\mdefJc1\mwrapIndent1440\mintLim0\mnaryLim1}{\info{\author Dino Chiesa}{\operator Dino}{\creatim\yr2008\mo7\dy3\hr11\min53}{\revtim\yr2009\mo6\dy26\hr21\min16}{\version4}{\edmins5}{\nofpages2}{\nofwords409}{\nofchars2233}
{\*\company Microsoft}{\nofcharsws2637}{\vern32771}}{\*\xmlnstbl {\xmlns1 http://schemas.microsoft.com/office/word/2003/wordml}}\paperw12240\paperh15840\margl1440\margr1440\margt1440\margb1440\gutter0\ltrsect 
\widowctrl\ftnbj\aenddoc\trackmoves1\trackformatting1\donotembedsysfont1\relyonvml0\donotembedlingdata0\grfdocevents0\validatexml1\showplaceholdtext0\ignoremixedcontent0\saveinvalidxml0\showxmlerrors1\noxlattoyen
\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\formshade\horzdoc\dgmargin\dghspace180\dgvspace180\dghorigin1440\dgvorigin1440\dghshow1\dgvshow1
\jexpand\viewkind1\viewscale110\pgbrdrhead\pgbrdrfoot\splytwnine\ftnlytwnine\htmautsp\nolnhtadjtbl\useltbaln\alntblind\lytcalctblwd\lyttblrtgr\lnbrkrule\nobrkwrptbl\snaptogridincell\allowfieldendsel\wrppunct
\asianbrkrule\rsidroot8258241\newtblstyruls\nogrowautofit\usenormstyforlist\noindnmbrts\felnbrelev\nocxsptable\indrlsweleven\noafcnsttbl\afelev\utinl\hwelev\spltpgpar\notcvasp\notbrkcnstfrctbl\notvatxbx\krnprsnet\cachedcolbal \nouicompat \fet0
{\*\wgrffmtfilter 2450}\nofeaturethrottle1\ilfomacatclnup0\ltrpar \sectd \ltrsect\linex0\endnhere\sectlinegrid360\sectdefaultcl\sectrsid2831265\sftnbj {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl2
\pnucltr\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang {\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl6
\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang 
{\pntxtb (}{\pntxta )}}\pard\plain \ltrpar\ql \li0\ri0\sa200\sl276\slmult1\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid8258241 \rtlch\fcs1 \af31507\afs22\alang1025 \ltrch\fcs0 
\f31506\fs22\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\rtlch\fcs1 \af31507\afs28 \ltrch\fcs0 \fs28\insrsid8258241\charrsid5376635 Microsoft Public License (Ms-PL)
\par }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \insrsid8258241 This license governs use of }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \b\i\insrsid8258241\charrsid5376635 the DotNetZip library}{\rtlch\fcs1 \af31507 \ltrch\fcs0 \b\i\insrsid12911876  and tools}{\rtlch\fcs1 
\af31507 \ltrch\fcs0 \insrsid8258241  ("the software"). If you use the software, you accept this license. If you do not accept the license, do not use the software.
\par 1. Definitions
\par }\pard \ltrpar\ql \li720\ri0\sa200\sl276\slmult1\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin720\itap0\pararsid11736570 {\rtlch\fcs1 \af31507 \ltrch\fcs0 \insrsid8258241 
The terms "reproduce," "reproduction," "derivative works," and "distribution" have the same meaning here as under U.S. copyright law.
\par A "contribution" is the original software, or any additions or changes to the software.
\par A "contributor" is any person that distributes its contribution under this license.
\par "Licensed patents" are a contributor's patent claims that read directly on its contribution.
\par }\pard \ltrpar\ql \li0\ri0\sa200\sl276\slmult1\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid8258241 {\rtlch\fcs1 \af31507 \ltrch\fcs0 \insrsid8258241 2. Grant of Rights
\par }\pard \ltrpar\ql \li720\ri0\sa200\sl276\slmult1\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin720\itap0\pararsid11736570 {\rtlch\fcs1 \af31507 \ltrch\fcs0 \insrsid8258241 
(A) Copyright Grant- Subject to the terms of this license, including the license conditions and limitations in section 3, each contributor grants you a non-exclusive, worldwide, royalty-free copyright license
 to reproduce its contribution, prepare derivative works of its contribution, and distribute its contribution or any derivative works that you create.
\par (B) Patent Grant- Subject to the terms of this license, including the license conditions and limitations 
in section 3, each contributor grants you a non-exclusive, worldwide, royalty-free license under its licensed patents to make, have made, use, sell, offer for sale, import, and/or otherwise dispose of its contribution in the software or derivative works o
f the contribution in the software.
\par }\pard \ltrpar\ql \li0\ri0\sa200\sl276\slmult1\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid8258241 {\rtlch\fcs1 \af31507 \ltrch\fcs0 \insrsid8258241 
\par 3. Conditions and Limitations
\par }\pard \ltrpar\ql \li720\ri0\sa200\sl276\slmult1\widctlpar\wrapdefault\aspalpha\aspnum\faauto\adjustright\rin0\lin720\itap0\pararsid11736570 {\rtlch\fcs1 \af31507 \ltrch\fcs0 \insrsid8258241 (A) No Trademark License}{\rtlch\fcs1 \af31507 \ltrch\fcs0 
\insrsid11736570  }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \insrsid8258241 - This license does not grant you rights to use any contributor}{\rtlch\fcs1 \af31507 \ltrch\fcs0 \insrsid5376635 \rquote s}{\rtlch\fcs1 \af31507 \ltrch\fcs0 \insrsid8258241 
 name, logo, or trademarks.
\par (B) If you bring a patent claim against any contributor over patents that you claim are infringed by the software, your patent license from such contributor to the software ends automatically.
\par (C) If you distribute any portion of the software, you must retain all copyright, patent, trademark, and attribution notices that are present in the software.
\par (D) If you distribute any portion of the software in source code form, you may do so only under this license by including a complete copy of this license with your distribution. If you distribute any portion of the software in compi
led or object code form, you may only do so under a license that complies with this license.
\par (E) The software is licensed "as-is." You bear the risk of using it. The contributors give no express warranties, guarantees or conditions. You may have additional
 consumer rights under your local laws which this license cannot change. To the extent permitted under your local laws, the contributors exclude the implied warranties of merchantability, fitness for a particular purpose and non-infringement. 
\par }{\rtlch\fcs1 \af31507 \ltrch\fcs0 \insrsid1599071 
\par }{\*\themedata 504b030414000600080000002100828abc13fa0000001c020000130000005b436f6e74656e745f54797065735d2e786d6cac91cb6ac3301045f785fe83d0b6d8
72ba28a5d8cea249777d2cd20f18e4b12d6a8f843409c9df77ecb850ba082d74231062ce997b55ae8fe3a00e1893f354e9555e6885647de3a8abf4fbee29bbd7
2a3150038327acf409935ed7d757e5ee14302999a654e99e393c18936c8f23a4dc072479697d1c81e51a3b13c07e4087e6b628ee8cf5c4489cf1c4d075f92a0b
44d7a07a83c82f308ac7b0a0f0fbf90c2480980b58abc733615aa2d210c2e02cb04430076a7ee833dfb6ce62e3ed7e14693e8317d8cd0433bf5c60f53fea2fe7
065bd80facb647e9e25c7fc421fd2ddb526b2e9373fed4bb902e182e97b7b461e6bfad3f010000ffff0300504b030414000600080000002100a5d6a7e7c00000
00360100000b0000005f72656c732f2e72656c73848fcf6ac3300c87ef85bd83d17d51d2c31825762fa590432fa37d00e1287f68221bdb1bebdb4fc7060abb08
84a4eff7a93dfeae8bf9e194e720169aaa06c3e2433fcb68e1763dbf7f82c985a4a725085b787086a37bdbb55fbc50d1a33ccd311ba548b63095120f88d94fbc
52ae4264d1c910d24a45db3462247fa791715fd71f989e19e0364cd3f51652d73760ae8fa8c9ffb3c330cc9e4fc17faf2ce545046e37944c69e462a1a82fe353
bd90a865aad41ed0b5b8f9d6fd010000ffff0300504b0304140006000800000021006b799616830000008a0000001c0000007468656d652f7468656d652f7468
656d654d616e616765722e786d6c0ccc4d0ac3201040e17da17790d93763bb284562b2cbaebbf600439c1a41c7a0d29fdbd7e5e38337cedf14d59b4b0d592c9c
070d8a65cd2e88b7f07c2ca71ba8da481cc52c6ce1c715e6e97818c9b48d13df49c873517d23d59085adb5dd20d6b52bd521ef2cdd5eb9246a3d8b4757e8d3f7
29e245eb2b260a0238fd010000ffff0300504b03041400060008000000210096b5ade296060000501b0000160000007468656d652f7468656d652f7468656d65
312e786d6cec594f6fdb3614bf0fd87720746f6327761a07758ad8b19b2d4d1bc46e871e698996d850a240d2497d1bdae38001c3ba618715d86d87615b8116d8
a5fb34d93a6c1dd0afb0475292c5585e9236d88aad3e2412f9e3fbff1e1fa9abd7eec70c1d1221294fda5efd72cd4324f1794093b0eddd1ef62fad79482a9c04
98f184b4bd2991deb58df7dfbb8ad755446282607d22d771db8b944ad79796a40fc3585ee62949606ecc458c15bc8a702910f808e8c66c69b9565b5d8a314d3c
94e018c8de1a8fa94fd05093f43672e23d06af89927ac06762a049136785c10607758d9053d965021d62d6f6804fc08f86e4bef210c352c144dbab999fb7b471
7509af678b985ab0b6b4ae6f7ed9ba6c4170b06c788a705430adf71bad2b5b057d03606a1ed7ebf5babd7a41cf00b0ef83a6569632cd467faddec9699640f671
9e76b7d6ac355c7c89feca9cccad4ea7d36c65b258a206641f1b73f8b5da6a6373d9c11b90c537e7f08dce66b7bbeae00dc8e257e7f0fd2badd5868b37a088d1
e4600ead1ddaef67d40bc898b3ed4af81ac0d76a197c86826828a24bb318f3442d8ab518dfe3a20f000d6458d104a9694ac6d88728eee2782428d60cf03ac1a5
193be4cbb921cd0b495fd054b5bd0f530c1931a3f7eaf9f7af9e3f45c70f9e1d3ff8e9f8e1c3e3073f5a42ceaa6d9c84e5552fbffdeccfc71fa33f9e7ef3f2d1
17d57859c6fffac327bffcfc793510d26726ce8b2f9ffcf6ecc98baf3efdfdbb4715f04d814765f890c644a29be408edf3181433567125272371be15c308d3f2
8acd249438c19a4b05fd9e8a1cf4cd296699771c393ac4b5e01d01e5a30a787d72cf1178108989a2159c77a2d801ee72ce3a5c545a6147f32a99793849c26ae6
6252c6ed637c58c5bb8b13c7bfbd490a75330f4b47f16e441c31f7184e140e494214d273fc80900aedee52ead87597fa824b3e56e82e451d4c2b4d32a423279a
668bb6690c7e9956e90cfe766cb37b077538abd27a8b1cba48c80acc2a841f12e698f13a9e281c57911ce298950d7e03aba84ac8c154f8655c4f2af074481847
bd804859b5e696007d4b4edfc150b12addbecba6b18b148a1e54d1bc81392f23b7f84137c2715a851dd0242a633f900710a218ed715505dfe56e86e877f0034e
16bafb0e258ebb4faf06b769e888340b103d3311da9750aa9d0a1cd3e4efca31a3508f6d0c5c5c398602f8e2ebc71591f5b616e24dd893aa3261fb44f95d843b
5974bb5c04f4edafb95b7892ec1108f3f98de75dc97d5772bdff7cc95d94cf672db4b3da0a6557f70db629362d72bcb0431e53c6066acac80d699a6409fb44d0
8741bdce9c0e4971624a2378cceaba830b05366b90e0ea23aaa241845368b0eb9e2612ca8c742851ca251ceccc70256d8d87265dd96361531f186c3d9058edf2
c00eafe8e1fc5c509031bb4d680e9f39a3154de0accc56ae644441edd76156d7429d995bdd88664a9dc3ad50197c38af1a0c16d684060441db02565e85f3b966
0d0713cc48a0ed6ef7dedc2dc60b17e92219e180643ed27acffba86e9c94c78ab90980d8a9f0913ee49d62b512b79626fb06dccee2a432bbc60276b9f7dec44b
7904cfbca4f3f6443ab2a49c9c2c41476dafd55c6e7ac8c769db1bc399161ee314bc2e75cf8759081743be1236ec4f4d6693e5336fb672c5dc24a8c33585b5fb
9cc24e1d4885545b58463634cc5416022cd19cacfccb4d30eb45296023fd35a458598360f8d7a4003bbaae25e331f155d9d9a5116d3bfb9a95523e51440ca2e0
088dd844ec6370bf0e55d027a012ae264c45d02f708fa6ad6da6dce29c255df9f6cae0ec38666984b372ab5334cf640b37795cc860de4ae2816e95b21be5ceaf
8a49f90b52a51cc6ff3355f47e0237052b81f6800fd7b802239daf6d8f0b1571a8426944fdbe80c6c1d40e8816b88b8569082ab84c36ff0539d4ff6dce591a26
ade1c0a7f669880485fd484582903d284b26fa4e2156cff62e4b9265844c4495c495a9157b440e091bea1ab8aaf7760f4510eaa69a6465c0e04ec69ffb9e65d0
28d44d4e39df9c1a52ecbd3607fee9cec7263328e5d661d3d0e4f62f44acd855ed7ab33cdf7bcb8ae889599bd5c8b3029895b6825696f6af29c239b75a5bb1e6
345e6ee6c28117e73586c1a2214ae1be07e93fb0ff51e133fb65426fa843be0fb515c187064d0cc206a2fa926d3c902e907670048d931db4c1a44959d366ad93
b65abe595f70a75bf03d616c2dd959fc7d4e6317cd99cbcec9c58b34766661c7d6766ca1a9c1b327531486c6f941c638c67cd22a7f75e2a37be0e82db8df9f30
254d30c1372581a1f51c983c80e4b71ccdd28dbf000000ffff0300504b0304140006000800000021000dd1909fb60000001b010000270000007468656d652f74
68656d652f5f72656c732f7468656d654d616e616765722e786d6c2e72656c73848f4d0ac2301484f78277086f6fd3ba109126dd88d0add40384e4350d363f24
51eced0dae2c082e8761be9969bb979dc9136332de3168aa1a083ae995719ac16db8ec8e4052164e89d93b64b060828e6f37ed1567914b284d262452282e3198
720e274a939cd08a54f980ae38a38f56e422a3a641c8bbd048f7757da0f19b017cc524bd62107bd5001996509affb3fd381a89672f1f165dfe514173d9850528
a2c6cce0239baa4c04ca5bbabac4df000000ffff0300504b01022d0014000600080000002100828abc13fa0000001c0200001300000000000000000000000000
000000005b436f6e74656e745f54797065735d2e786d6c504b01022d0014000600080000002100a5d6a7e7c0000000360100000b000000000000000000000000
002b0100005f72656c732f2e72656c73504b01022d00140006000800000021006b799616830000008a0000001c00000000000000000000000000140200007468
656d652f7468656d652f7468656d654d616e616765722e786d6c504b01022d001400060008000000210096b5ade296060000501b000016000000000000000000
00000000d10200007468656d652f7468656d652f7468656d65312e786d6c504b01022d00140006000800000021000dd1909fb60000001b010000270000000000
00000000000000009b0900007468656d652f7468656d652f5f72656c732f7468656d654d616e616765722e786d6c2e72656c73504b050600000000050005005d010000960a00000000}
{\*\colorschememapping 3c3f786d6c2076657273696f6e3d22312e302220656e636f64696e673d225554462d3822207374616e64616c6f6e653d22796573223f3e0d0a3c613a636c724d
617020786d6c6e733a613d22687474703a2f2f736368656d61732e6f70656e786d6c666f726d6174732e6f72672f64726177696e676d6c2f323030362f6d6169
6e22206267313d226c743122207478313d22646b3122206267323d226c743222207478323d22646b322220616363656e74313d22616363656e74312220616363
656e74323d22616363656e74322220616363656e74333d22616363656e74332220616363656e74343d22616363656e74342220616363656e74353d22616363656e74352220616363656e74363d22616363656e74362220686c696e6b3d22686c696e6b2220666f6c486c696e6b3d22666f6c486c696e6b222f3e}
{\*\latentstyles\lsdstimax267\lsdlockeddef0\lsdsemihiddendef1\lsdunhideuseddef1\lsdqformatdef0\lsdprioritydef99{\lsdlockedexcept \lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority0 \lsdlocked0 Normal;
\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority9 \lsdlocked0 heading 1;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 2;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 3;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 4;
\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 5;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 6;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 7;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 8;\lsdqformat1 \lsdpriority9 \lsdlocked0 heading 9;
\lsdpriority39 \lsdlocked0 toc 1;\lsdpriority39 \lsdlocked0 toc 2;\lsdpriority39 \lsdlocked0 toc 3;\lsdpriority39 \lsdlocked0 toc 4;\lsdpriority39 \lsdlocked0 toc 5;\lsdpriority39 \lsdlocked0 toc 6;\lsdpriority39 \lsdlocked0 toc 7;
\lsdpriority39 \lsdlocked0 toc 8;\lsdpriority39 \lsdlocked0 toc 9;\lsdqformat1 \lsdpriority35 \lsdlocked0 caption;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority10 \lsdlocked0 Title;\lsdpriority1 \lsdlocked0 Default Paragraph Font;
\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority11 \lsdlocked0 Subtitle;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority22 \lsdlocked0 Strong;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority20 \lsdlocked0 Emphasis;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority59 \lsdlocked0 Table Grid;\lsdunhideused0 \lsdlocked0 Placeholder Text;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority1 \lsdlocked0 No Spacing;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading;\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List;\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List;\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List;\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid;\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading Accent 1;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 1;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1 Accent 1;\lsdunhideused0 \lsdlocked0 Revision;
\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority34 \lsdlocked0 List Paragraph;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority29 \lsdlocked0 Quote;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority30 \lsdlocked0 Intense Quote;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2 Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 1;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading Accent 1;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid Accent 1;\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading Accent 2;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 2;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1 Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2 Accent 2;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 2;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List Accent 2;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid Accent 2;\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List Accent 3;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 3;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1 Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2 Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 3;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List Accent 3;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List Accent 3;\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid Accent 3;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid Accent 4;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1 Accent 4;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2 Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 4;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading Accent 4;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid Accent 4;\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading Accent 5;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 5;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1 Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2 Accent 5;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 5;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List Accent 5;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid Accent 5;\lsdsemihidden0 \lsdunhideused0 \lsdpriority60 \lsdlocked0 Light Shading Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority61 \lsdlocked0 Light List Accent 6;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority62 \lsdlocked0 Light Grid Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority63 \lsdlocked0 Medium Shading 1 Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority64 \lsdlocked0 Medium Shading 2 Accent 6;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority65 \lsdlocked0 Medium List 1 Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority66 \lsdlocked0 Medium List 2 Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority67 \lsdlocked0 Medium Grid 1 Accent 6;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority68 \lsdlocked0 Medium Grid 2 Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority69 \lsdlocked0 Medium Grid 3 Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority70 \lsdlocked0 Dark List Accent 6;
\lsdsemihidden0 \lsdunhideused0 \lsdpriority71 \lsdlocked0 Colorful Shading Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority72 \lsdlocked0 Colorful List Accent 6;\lsdsemihidden0 \lsdunhideused0 \lsdpriority73 \lsdlocked0 Colorful Grid Accent 6;
\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority19 \lsdlocked0 Subtle Emphasis;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority21 \lsdlocked0 Intense Emphasis;
\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority31 \lsdlocked0 Subtle Reference;\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority32 \lsdlocked0 Intense Reference;
\lsdsemihidden0 \lsdunhideused0 \lsdqformat1 \lsdpriority33 \lsdlocked0 Book Title;\lsdpriority37 \lsdlocked0 Bibliography;\lsdqformat1 \lsdpriority39 \lsdlocked0 TOC Heading;}}{\*\datastore 010500000200000018000000
4d73786d6c322e534158584d4c5265616465722e352e3000000000000000000000060000
d0cf11e0a1b11ae1000000000000000000000000000000003e000300feff090006000000000000000000000001000000010000000000000000100000feffffff00000000feffffff0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
fffffffffffffffffdfffffffeffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffff52006f006f007400200045006e00740072007900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016000500ffffffffffffffffffffffffec69d9888b8b3d4c859eaf6cd158be0f000000000000000000000000c0fd
57f4c4f6c901feffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffff0000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffff000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000105000000000000}}
The following licenses govern use of the accompanying software, the
DotNetZip library ("the software"). If you use the software, you accept
these licenses. If you do not accept the license, do not use the software.

The managed ZLIB code included in Ionic.Zlib.dll and Ionic.Zip.dll is
modified code, based on jzlib.



The following notice applies to jzlib:
-----------------------------------------------------------------------

Copyright (c) 2000,2001,2002,2003 ymnk, JCraft,Inc. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in
the documentation and/or other materials provided with the distribution.

3. The names of the authors may not be used to endorse or promote products
derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

-----------------------------------------------------------------------

jzlib is based on zlib-1.1.3.

The following notice applies to zlib:

-----------------------------------------------------------------------

Copyright (C) 1995-2004 Jean-loup Gailly and Mark Adler

  The ZLIB software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly jloup@gzip.org
  Mark Adler madler@alumni.caltech.edu


-----------------------------------------------------------------------
Apache Commons Compress
Copyright 2002-2010 The Apache Software Foundation

This product includes software developed by
The Apache Software Foundation (http://www.apache.org/).
Tue, 27 Oct 2009  00:46

This application shows how to open and read a zip file, and display the
contents in a Windows Forms TreeView. 

The app is written in VB.
This file contains test strings to be stuffed into entries in zip files.  Each line will be placed into a separate file.  
Note: The file must end in a newline.
﻿过去一周，业界可谓是大事连连，2009 JavaOne大会和谷歌开发者日大会相继举行，微软正式推出新搜索引擎品牌Bing，受到业界极大关注。当然最火热的还是智能手机领域，本周又有三家重头公司宣布对手机市场进行开拓和布局。
Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Integer vulputate, nibh non rhoncus euismod, erat odio pellentesque lacus, sit amet convallis mi augue et odio. Phasellus cursus urna facilisis quam. Suspendisse nec metus et sapien scelerisque euismod. Nullam molestie sem quis nisl. Fusce pellentesque, ante sed semper egestas, sem nulla vestibulum nulla, quis sollicitudin leo lorem elementum wisi. Aliquam vestibulum nonummy orci. Sed in dolor sed enim ullamcorper accumsan. Duis vel nibh. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos hymenaeos. Sed faucibus, enim sit amet venenatis laoreet, nisl elit posuere est, ut sollicitudin tortor velit ut ipsum. Aliquam erat volutpat. Phasellus tincidunt vehicula eros. Curabitur vitae erat.
¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ
Cyrillic - А Б В Г Д Є Ж Ѕ З И І К Л М Н О П Р
Greek - Ελληνικό αλφάβητο
Images, layout descriptions, binary blobs and string dictionaries can be included 
in your application as resource files.  Various Android APIs are designed to 
operate on the resource IDs instead of dealing with images, strings or binary blobs 
directly.

For example, a sample Android app that contains a user interface layout (main.axml),
an internationalization string table (strings.xml) and some icons (drawable-XXX/icon.png) 
would keep its resources in the "Resources" directory of the application:

Resources/
    drawable/
        icon.png

    layout/
        main.axml

    values/
        strings.xml

In order to get the build system to recognize Android resources, set the build action to
"AndroidResource".  The native Android APIs do not operate directly with filenames, but 
instead operate on resource IDs.  When you compile an Android application that uses resources, 
the build system will package the resources for distribution and generate a class called "R" 
(this is an Android convention) that contains the tokens for each one of the resources 
included. For example, for the above Resources layout, this is what the R class would expose:

public class R {
    public class drawable {
        public const int icon = 0x123;
    }

    public class layout {
        public const int main = 0x456;
    }

    public class strings {
        public const int first_string = 0xabc;
        public const int second_string = 0xbcd;
    }
}

You would then use R.drawable.icon to reference the drawable/icon.png file, or R.layout.main 
to reference the layout/main.axml file, or R.strings.first_string to reference the first 
string in the dictionary file values/strings.xml.The ZLIB library, available as Ionic.Zlib.dll or as part of DotNetZip,
is a ported-then-modified version of jzlib.  The following applies to jzlib:

JZlib 0.0.* were released under the GNU LGPL license.  Later, we have switched
over to a BSD-style license.

------------------------------------------------------------------------------
Copyright (c) 2000,2001,2002,2003 ymnk, JCraft,Inc. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice,
     this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the distribution.

  3. The names of the authors may not be used to endorse or promote products
     derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
The ZLIB library, available as Ionic.Zlib.dll or as part of DotNetZip,
is a ported-then-modified version of jzlib, which itself is based on
zlib-1.1.3, the well-known C-language compression library.

The following notice applies to zlib:

-----------------------------------------------------------------------

Copyright (C) 1995-2004 Jean-loup Gailly and Mark Adler

  The ZLIB software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly jloup@gzip.org
  Mark Adler madler@alumni.caltech.edu


-----------------------------------------------------------------------
// CreateWithProgress.cpp
//
// Example: creating a zip file, with progress events, from C++.
//
// This code is part of DotNetZip.
//
//
// Last saved: <2010-June-01 10:32:21>
//
// CreateZipFile.cpp
//
// Example: creating a zip file from C++.
//
// This code is part of DotNetZip.
//
//
// Last saved: <2010-June-01 10:32:15>
//
//zip->~ZipFile();
// BitWriter.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2011 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// Last Saved: <2011-July-25 18:57:31>
//
// ------------------------------------------------------------------
//
// This module defines the BitWriter class, which writes bits at a time
// to an output stream. It's used by the BZip2Compressor class, and by
// the BZip2OutputStream class and its parallel variant,
// ParallelBZip2OutputStream.
//
// ------------------------------------------------------------------
//
// Design notes:
//
// BZip2 employs byte-shredding in its data format - rather than
// aligning all data items in a compressed .bz2 file on byte barriers,
// the BZip2 format uses portions of bytes to represent independent
// pieces of information. This "shredding" starts with the first
// "randomised" bit - just 12 bytes or so into a bz2 file or stream. But
// the approach is used extensively in bzip2 files - sometimes 5 bits
// are used, sometimes 24 or 3 bits, sometimes just 1 bit, and so on.
// It's not possible to send this information directly to a stream in
// this form; Streams in .NET accept byte-oriented input.  Therefore,
// when actually writing a bz2 file, the output data must be organized
// into a byte-aligned format before being written to the output stream.
//
// This BitWriter class provides the byte-shredding necessary for BZip2
// output. Think of this class as an Adapter that enables Bit-oriented
// output to a standard byte-oriented .NET stream. This class writes
// data out to the captive output stream only after the data bits have
// been accumulated and aligned. For example, suppose that during
// operation, the BZip2 compressor emits 5 bits, then 24 bits, then 32
// bits.  When the first 5 bits are sent to the BitWriter, nothing is
// written to the output stream; instead these 5 bits are simply stored
// in the internal accumulator.  When the next 24 bits are written, the
// first 3 bits are gathered with the accumulated bits. The resulting
// 5+3 constitutes an entire byte; the BitWriter then actually writes
// that byte to the output stream. This leaves 21 bits. BitWriter writes
// 2 more whole bytes (16 more bits), in 8-bit chunks, leaving 5 in the
// accumulator. BitWriter then follows the same procedure with the 32
// new bits. And so on.
//
// A quick tour of the implementation:
//
// The accumulator is a uint - so it can accumulate at most 4 bytes of
// information. In practice because of the design of this class, it
// never accumulates more than 3 bytes.
//
// The Flush() method emits all whole bytes available. After calling
// Flush(), there may be between 0-7 bits yet to be emitted into the
// output stream.
//
// FinishAndPad() emits all data, including the last partial byte and
// any necessary padding. In effect, it establishes a byte-alignment
// barrier. To support bzip2, FinishAndPad() should be called only once
// for a bz2 file, after the last bit of data has been written through
// this adapter.  Other binary file formats may use byte-alignment at
// various points within the file, and FinishAndPad() would support that
// scenario.
//
// The internal fn Reset() is used to reset the state of the adapter;
// this class is used by BZip2Compressor, instances of which get re-used
// by multiple distinct threads, for different blocks of data.
//
/// <summary>
///   Delivers the remaining bits, left-aligned, in a byte.
/// </summary>
/// <remarks>
///   <para>
///     This is valid only if NumRemainingBits is less than 8;
///     in other words it is valid only after a call to Flush().
///   </para>
/// </remarks>
/// <summary>
///   Reset the BitWriter.
/// </summary>
/// <remarks>
///   <para>
///     This is useful when the BitWriter writes into a MemoryStream, and
///     is used by a BZip2Compressor, which itself is re-used for multiple
///     distinct data blocks.
///   </para>
/// </remarks>
/// <summary>
///   Write some number of bits from the given value, into the output.
/// </summary>
/// <remarks>
///   <para>
///     The nbits value should be a max of 25, for safety. For performance
///     reasons, this method does not check!
///   </para>
/// </remarks>
// Console.WriteLine("WriteBits({0}, 0x{1:X2}) => {2:X8} n({3})",
//                   nbits, value, accumulator, nAccumulatedBits);
// Console.ReadLine();
// At this point the accumulator may contain up to 31 bits waiting for
// output.
/// <summary>
///   Write a full 8-bit byte into the output.
/// </summary>
/// <summary>
///   Write four 8-bit bytes into the output.
/// </summary>
/// <summary>
///   Write all available byte-aligned bytes.
/// </summary>
/// <remarks>
///   <para>
///     This method writes no new output, but flushes any accumulated
///     bits. At completion, the accumulator may contain up to 7
///     bits.
///   </para>
///   <para>
///     This is necessary when re-assembling output from N independent
///     compressors, one for each of N blocks. The output of any
///     particular compressor will in general have some fragment of a byte
///     remaining. This fragment needs to be accumulated into the
///     parent BZip2OutputStream.
///   </para>
/// </remarks>
/// <summary>
///   Writes all available bytes, and emits padding for the final byte as
///   necessary. This must be the last method invoked on an instance of
///   BitWriter.
/// </summary>
// BZip2Compressor.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2011 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// Last Saved: <2011-July-28 06:17:22>
//
// ------------------------------------------------------------------
//
// This module defines the BZip2Compressor class, which is a
// BZIP2-compressing encoder.  It is used internally in the BZIP2
// library, by the BZip2OutputStream class and its parallel variant,
// ParallelBZip2OutputStream. This code was originally based on Apache
// commons source code, and significantly modified.  The license below
// applies to the original Apache code and to this modified variant.
//
// ------------------------------------------------------------------
/*
//www.apache.org/licenses/LICENSE-2.0
/*
//
// Design notes:
//
// This class performs BZip2 compression. It is derived from the
// BZip2OutputStream from the Apache commons source code, but is
// significantly modified from that code. While the Apache class is a
// stream that compresses, this particular class simply performs
// compression.  It follows a Manager pattern. It manages an internal
// buffer for uncompressed data; callers place data into the buffer
// using the Fill() method. This class then compresses the data and
// writes the compressed form out, via the CompressAndWrite() method.
// Because BZip2 uses byte-shredding, this class relies on a BitWriter,
// and not a .NET Stream, to emit its output.  (*Think of the BitWriter
// class as an Adapter that enables Bit-oriented output to a standard
// byte-oriented .NET stream.)
//
// This class exists to support the two distinct output streams that
// perform BZip2 compression: BZip2OutputStream and
// ParallelBZip2OutputStream. These streams rely on BZip2Compressor to
// provide the encoder/compression logic.  This code has been derived
// from the bzip2 output stream in the Apache commons library; it has
// been significantly modified from that form, in order to provide a
// single compressor that could support both types of streams.
//
// In a bz2 file or stream, there is never any bit padding except for 0..7
// bits in the final byte in the file. Successive compressed blocks in a
// .bz2 file are not byte-aligned.
//
//
// flymake: csc.exe /t:module BZip2InputStream.cs BZip2OutputStream.cs Rand.cs BCRC32.cs @@FILE@@
// 0...9
// index into the block of the last char processed
/*
/**
/// <summary>
///   BZip2Compressor writes its compressed data out via a BitWriter. This
///   is necessary because BZip2 does byte shredding.
/// </summary>
// 20 provides a margin of slop (not to say "Safety"). The maximum
// size of an encoded run in the output block is 5 bytes, so really, 5
// bytes ought to do, but this is a margin of slop found in the
// original bzip code. Not sure if important for decoding
// (decompressing).  So we'll leave the slop.
// initBlock();
//bw.Reset();  xxx? want this?  no no no
/// <summary>
///   The number of uncompressed bytes being held in the buffer.
/// </summary>
/// <remarks>
///   <para>
///     I am thinking this may be useful in a Stream that uses this
///     compressor class. In the Close() method on the stream it could
///     check this value to see if anything has been written at all.  You
///     may think the stream could easily track the number of bytes it
///     wrote, which would eliminate the need for this. But, there is the
///     case where the stream writes a complete block, and it is full, and
///     then writes no more. In that case the stream may want to check.
///   </para>
/// </remarks>
/// <summary>
///   Accept new bytes into the compressor data buffer
/// </summary>
/// <remarks>
///   <para>
///     This method does the first-level (cheap) run-length encoding, and
///     stores the encoded data into the rle block.
///   </para>
/// </remarks>
// We're full, I tell you!
// do run-length-encoding until block is full
/// <summary>
///   Process one input byte into the block.
/// </summary>
///
/// <remarks>
///   <para>
///     To "process" the byte means to do the run-length encoding.
///     There are 3 possible return values:
///
///        0 - the byte was not written, in other words, not
///            encoded into the block. This happens when the
///            byte b would require the start of a new run, and
///            the block has no more room for new runs.
///
///        1 - the byte was written, and the block is not full.
///
///        2 - the byte was written, and the block is full.
///
///   </para>
/// </remarks>
/// <returns>0 if the byte was not written, non-zero if written.</returns>
// there is no current run in progress
// this byte is the same as the current run in progress
// not full
// This byte requires a new run.
// Put the prior run into the Run-length-encoded block,
// and try to start a new run.
// returning 0 implies the block is full, and the byte was not written.
// start a new run
/// <summary>
///   Append one run to the output block.
/// </summary>
///
/// <remarks>
///   <para>
///     This compressor does run-length-encoding before BWT and etc. This
///     method simply appends a run to the output block. The append always
///     succeeds. The return value indicates whether the block is full:
///     false (not full) implies that at least one additional run could be
///     processed.
///   </para>
/// </remarks>
/// <returns>true if the block is now full; otherwise false.</returns>
/* add_pair_to_block ( EState* s ) */
// sanity check only - because of the check done at the
// bottom of this method, and the logic in write0(), this
// should never ever happen.
// NB: the index used here into block is always (last+2).  This is
// because last is -1 based - the initial value is -1, a flag value
// used to indicate that nothing has yet been written into the
// block. The endBlock() fn tests for -1 to detect empty blocks. Also,
// the first byte of block is used, during sorting, to hold block[last
// +1], which is the final byte value that had been written into the
// rle block. For those two reasons, the base offset from last is
// always +2.
// is full?
/// <summary>
///   Compress the data that has been placed (Run-length-encoded) into the
///   block. The compressed data goes into the CompressedBytes array.
/// </summary>
/// <remarks>
///   <para>
///     Side effects: 1.  fills the CompressedBytes array.  2. sets the
///     AvailableBytesOut property.
///   </para>
/// </remarks>
// endBlock
// Console.WriteLine("  BZip2Compressor:CompressAndWrite (r={0} bcrc={1:X8})",
//                   runs, this.crc.Crc32Result);
// has any data been written?
// no data; nothing to compress
/* sort the block and establish posn of original string */
/*
/* Now a single bit indicating randomisation. */
/* Finally, block's contents proper. */
// handle 16 bit signed numbers
// Set up the 2-byte frequency table
/*
// Complete the initial radix sort:
/*
/*
/*
// Step 1:
/*
// Step 2:
// Now scan this big bucket so as to synthesise the
// sorted order for small buckets [t, ss] for all t != ss.
// Step 3:
/*
// assert (this.origPtr != -1) : this.origPtr;
/**
// Following block contains unrolled code which could be shortened by
// coding it in additional loops.
// HP:
// copy
// for (int a;
// (j > mj) && mainGtU((a = fmap[j - h]) + d, vd,
// block, quadrant, lastShadow);
// j -= h) {
// fmap[j] = a;
// }
//
// unrolled version:
// start inline mainGTU
// following could be done in a loop, but
// unrolled it for performance:
// while x > 0
// HAMMER
// end inline mainGTU
/**
// make maps
/* Decide how many coding tables to use */
// assert (this.nMTF > 0) : this.nMTF;
/* Generate an initial set of coding tables */
/*
/* Compute MTF values for the selectors. */
/* Assign actual codes for the tables. */
/* Transmit the mapping table. */
/* Now the selectors. */
/* Now the coding tables. */
/* And finally, the block data proper */
/*
/* Set group start & end marks. */
/*
// unrolled version of the else-block
/*
/*
/*
// assert (nGroups < 8) : nGroups;
// assert (maxLen <= 20) : maxLen;
// assert (minLen >= 1) : minLen;
/* 10 */
/* 11 */
// with blockSize 900k
// 256 byte
// 256 byte
// 1032 byte
// 18002 byte
// 18002 byte
// 256 byte
// byte
// byte
// 24 byte
// 12 byte
// byte
// 6 byte
// 16 byte
// 4000 byte
// 4000 byte
// 4000 byte
// 1024 byte
// 1024 byte
// 256 byte
// 1040 byte
// 2064 byte
// 2064 byte
// 262148 byte
// ------------
// 333408 byte
// 900021 byte
// 3600000 byte
// 3600000 byte
// ------------
// 8433529 byte
// ============
/**
// BZip2InputStream.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2011 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// Last Saved: <2011-July-31 11:57:32>
//
// ------------------------------------------------------------------
//
// This module defines the BZip2InputStream class, which is a decompressing
// stream that handles BZIP2. This code is derived from Apache commons source code.
// The license below applies to the original Apache code.
//
// ------------------------------------------------------------------
/*
//www.apache.org/licenses/LICENSE-2.0
/*
// compile: msbuild
// not: csc.exe /t:library /debug+ /out:Ionic.BZip2.dll BZip2InputStream.cs BCRC32.cs Rand.cs
/// <summary>
///   A read-only decorator stream that performs BZip2 decompression on Read.
/// </summary>
/* for undoing the Burrows-Wheeler transform */
// blockSize100k: 0 .. 9.
//
// This var name is a misnomer. The actual block size is 100000
// * blockSize100k. (not 100k * blocksize100k)
/// <summary>
///   Compressor State
/// </summary>
// Variables used by setup* methods exclusively
/// <summary>
///   Create a BZip2InputStream, wrapping it around the given input Stream.
/// </summary>
/// <remarks>
///   <para>
///     The input stream will be closed when the BZip2InputStream is closed.
///   </para>
/// </remarks>
/// <param name='input'>The stream from which to read compressed data</param>
/// <summary>
///   Create a BZip2InputStream with the given stream, and
///   specifying whether to leave the wrapped stream open when
///   the BZip2InputStream is closed.
/// </summary>
/// <param name='input'>The stream from which to read compressed data</param>
/// <param name='leaveOpen'>
///   Whether to leave the input stream open, when the BZip2InputStream closes.
/// </param>
///
/// <example>
///
///   This example reads a bzip2-compressed file, decompresses it,
///   and writes the decompressed data into a newly created file.
///
///   <code>
///   var fname = "logfile.log.bz2";
///   using (var fs = File.OpenRead(fname))
///   {
///       using (var decompressor = new Ionic.BZip2.BZip2InputStream(fs))
///       {
///           var outFname = fname + ".decompressed";
///           using (var output = File.Create(outFname))
///           {
///               byte[] buffer = new byte[2048];
///               int n;
///               while ((n = decompressor.Read(buffer, 0, buffer.Length)) > 0)
///               {
///                   output.Write(buffer, 0, n);
///               }
///           }
///       }
///   }
///   </code>
/// </example>
/// <summary>
///   Read data from the stream.
/// </summary>
///
/// <remarks>
///   <para>
///     To decompress a BZip2 data stream, create a <c>BZip2InputStream</c>,
///     providing a stream that reads compressed data.  Then call Read() on
///     that <c>BZip2InputStream</c>, and the data read will be decompressed
///     as you read.
///   </para>
///
///   <para>
///     A <c>BZip2InputStream</c> can be used only for <c>Read()</c>, not for <c>Write()</c>.
///   </para>
/// </remarks>
///
/// <param name="buffer">The buffer into which the read data should be placed.</param>
/// <param name="offset">the offset within that data array to put the first byte read.</param>
/// <param name="count">the number of bytes to read.</param>
/// <returns>the number of bytes actually read</returns>
/// <summary>
///   Read a single byte from the stream.
/// </summary>
/// <returns>the byte read from the stream, or -1 if EOF</returns>
/// <summary>
/// Indicates whether the stream can be read.
/// </summary>
/// <remarks>
/// The return value depends on whether the captive stream supports reading.
/// </remarks>
/// <summary>
/// Indicates whether the stream supports Seek operations.
/// </summary>
/// <remarks>
/// Always returns false.
/// </remarks>
/// <summary>
/// Indicates whether the stream can be written.
/// </summary>
/// <remarks>
/// The return value depends on whether the captive stream supports writing.
/// </remarks>
/// <summary>
/// Flush the stream.
/// </summary>
/// <summary>
/// Reading this property always throws a <see cref="NotImplementedException"/>.
/// </summary>
/// <summary>
/// The position of the stream pointer.
/// </summary>
///
/// <remarks>
///   Setting this property always throws a <see
///   cref="NotImplementedException"/>. Reading will return the
///   total number of uncompressed bytes read in.
/// </remarks>
/// <summary>
/// Calling this method always throws a <see cref="NotImplementedException"/>.
/// </summary>
/// <param name="offset">this is irrelevant, since it will always throw!</param>
/// <param name="origin">this is irrelevant, since it will always throw!</param>
/// <returns>irrelevant!</returns>
/// <summary>
/// Calling this method always throws a <see cref="NotImplementedException"/>.
/// </summary>
/// <param name="value">this is irrelevant, since it will always throw!</param>
/// <summary>
///   Calling this method always throws a <see cref="NotImplementedException"/>.
/// </summary>
/// <param name='buffer'>this parameter is never used</param>
/// <param name='offset'>this parameter is never used</param>
/// <param name='count'>this parameter is never used</param>
/// <summary>
///   Dispose the stream.
/// </summary>
/// <param name="disposing">
///   indicates whether the Dispose method was invoked by user code.
/// </param>
// end of file
// Console.WriteLine(" stored block CRC     : {0:X8}", this.storedBlockCRC);
// Lazily allocate data
// currBlockNo++;
// A bad CRC is considered a fatal error.
// make next blocks readable without error
// (repair feature, not yet documented, not tested)
// this.computedCombinedCRC = (this.storedCombinedCRC << 1)
//     | (this.storedCombinedCRC >> 31);
// this.computedCombinedCRC ^= this.storedBlockCRC;
// Console.WriteLine(" combined CRC (before): {0:X8}", this.computedCombinedCRC);
// Console.WriteLine(" computed block  CRC  : {0:X8}", this.computedBlockCRC);
// Console.WriteLine(" combined CRC (after) : {0:X8}", this.computedCombinedCRC);
// Console.WriteLine();
/// <summary>
///   Close the stream.
/// </summary>
/// <summary>
///   Read n bits from input, right justifying the result.
/// </summary>
/// <remarks>
///   <para>
///     For example, if you read 1 bit, the result is either 0
///     or 1.
///   </para>
/// </remarks>
/// <param name ="n">
///   The number of bits to read, always between 1 and 32.
/// </param>
// Console.WriteLine("R {0:X2}", thech);
// private bool bsGetBit()
// {
//     int bsLiveShadow = this.bsLive;
//     int bsBuffShadow = this.bsBuff;
//
//     if (bsLiveShadow < 1)
//     {
//         int thech = this.input.ReadByte();
//
//         if (thech < 0)
//         {
//             throw new IOException("unexpected end of stream");
//         }
//
//         bsBuffShadow = (bsBuffShadow << 8) | thech;
//         bsLiveShadow += 8;
//         this.bsBuff = bsBuffShadow;
//     }
//
//     this.bsLive = bsLiveShadow - 1;
//     return ((bsBuffShadow >> (bsLiveShadow - 1)) & 1) != 0;
// }
/**
//byte[] selector = s.selector;
/* Receive the mapping table */
/* Now the selectors */
/* Undo the MTF values for the selectors. */
// nearly all times v is zero, 4 in most other cases
/* Now the coding tables */
// finally create the Huffman tables
/**
/*
// Inlined:
// int zvec = GetBits(zn);
/*
// Inlined:
// int zvec = GetBits(zn);
//       xxxx
/* Check: unzftab entries in range. */
/* Actually generate cftab. */
/* Check: cftab entries in range. */
/* Check: cftab entries non-descending. */
/* not a valid 8-bit byte value?, and not EOF */
// (with blockSize 900k)
// 256 byte
// 18002 byte
// 18002 byte
/**
// ---------------
// 60798 byte
// 3600000 byte
// 900000 byte
// ---------------
// 4560782 byte
// ===============
// 1024 byte
// 24 byte
// 1028 byte
// 512 byte
// 6 byte
/**
// tt.length should always be >= length, but theoretically
// it can happen, if the compressor mixed small and large
// blocks. Normally only the last block will be smaller
// than others.
// /**
/**
//  *
//  * @param signature
//  *            the bytes to check
//  * @param length
//  *            the number of bytes to check
//  * @return true, if this stream is a bzip2 compressed stream, false otherwise
//  *
//  * @since Apache Commons Compress 1.1
//  */
// public static boolean MatchesSig(byte[] signature)
// {
//     if ((signature.Length < 3) ||
//         (signature[0] != 'B') ||
//         (signature[1] != 'Z') ||
//         (signature[2] != 'h'))
//         return false;
//
//     return true;
// }
/*
//#define Trace
// BZip2OutputStream.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2011 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// Last Saved: <2011-August-02 16:44:11>
//
// ------------------------------------------------------------------
//
// This module defines the BZip2OutputStream class, which is a
// compressing stream that handles BZIP2. This code may have been
// derived in part from Apache commons source code. The license below
// applies to the original Apache code.
//
// ------------------------------------------------------------------
// flymake: csc.exe /t:module BZip2InputStream.cs BZip2Compressor.cs Rand.cs BCRC32.cs @@FILE@@
/*
//www.apache.org/licenses/LICENSE-2.0
// Design Notes:
//
// This class follows the classic Decorator pattern: it is a Stream that
// wraps itself around a Stream, and in doing so provides bzip2
// compression as callers Write into it.
//
// BZip2 is a straightforward data format: there are 4 magic bytes at
// the top of the file, followed by 1 or more compressed blocks. There
// is a small "magic byte" trailer after all compressed blocks. This
// class emits the magic bytes for the header and trailer, and relies on
// a BZip2Compressor to generate each of the compressed data blocks.
//
// BZip2 does byte-shredding - it uses partial fractions of bytes to
// represent independent pieces of information. This class relies on the
// BitWriter to adapt the bit-oriented BZip2 output to the byte-oriented
// model of the .NET Stream class.
//
// ----
//
// Regarding the Apache code base: Most of the code in this particular
// class is related to stream operations, and is my own code. It largely
// does not rely on any code obtained from Apache commons. If you
// compare this code with the Apache commons BZip2OutputStream, you will
// see very little code that is common, except for the
// nearly-boilerplate structure that is common to all subtypes of
// System.IO.Stream. There may be some small remnants of code in this
// module derived from the Apache stuff, which is why I left the license
// in here. Most of the Apache commons compressor magic has been ported
// into the BZip2Compressor class.
//
/// <summary>
///   A write-only decorator stream that compresses data as it is
///   written using the BZip2 algorithm.
/// </summary>
// 0...9
/// <summary>
///   Constructs a new <c>BZip2OutputStream</c>, that sends its
///   compressed output to the given output stream.
/// </summary>
///
/// <param name='output'>
///   The destination stream, to which compressed output will be sent.
/// </param>
///
/// <example>
///
///   This example reads a file, then compresses it with bzip2 file,
///   and writes the compressed data into a newly created file.
///
///   <code>
///   var fname = "logfile.log";
///   using (var fs = File.OpenRead(fname))
///   {
///       var outFname = fname + ".bz2";
///       using (var output = File.Create(outFname))
///       {
///           using (var compressor = new Ionic.BZip2.BZip2OutputStream(output))
///           {
///               byte[] buffer = new byte[2048];
///               int n;
///               while ((n = fs.Read(buffer, 0, buffer.Length)) > 0)
///               {
///                   compressor.Write(buffer, 0, n);
///               }
///           }
///       }
///   }
///   </code>
/// </example>
/// <summary>
///   Constructs a new <c>BZip2OutputStream</c> with specified blocksize.
/// </summary>
/// <param name = "output">the destination stream.</param>
/// <param name = "blockSize">
///   The blockSize in units of 100000 bytes.
///   The valid range is 1..9.
/// </param>
/// <summary>
///   Constructs a new <c>BZip2OutputStream</c>.
/// </summary>
///   <param name = "output">the destination stream.</param>
/// <param name = "leaveOpen">
///   whether to leave the captive stream open upon closing this stream.
/// </param>
/// <summary>
///   Constructs a new <c>BZip2OutputStream</c> with specified blocksize,
///   and explicitly specifies whether to leave the wrapped stream open.
/// </summary>
///
/// <param name = "output">the destination stream.</param>
/// <param name = "blockSize">
///   The blockSize in units of 100000 bytes.
///   The valid range is 1..9.
/// </param>
/// <param name = "leaveOpen">
///   whether to leave the captive stream open upon closing this stream.
/// </param>
/// <summary>
///   Close the stream.
/// </summary>
/// <remarks>
///   <para>
///     This may or may not close the underlying stream.  Check the
///     constructors that accept a bool value.
///   </para>
/// </remarks>
/// <summary>
///   Flush the stream.
/// </summary>
// not necessary to shred the initial magic bytes
// A magic 48-bit number, 0x177245385090, to indicate the end
// of the last block. (sqrt(pi), if you want to know)
// must shred
// Console.WriteLine("BZip2:Finish");
/// <summary>
///   The blocksize parameter specified at construction time.
/// </summary>
/// <summary>
///   Write data to the stream.
/// </summary>
/// <remarks>
///
/// <para>
///   Use the <c>BZip2OutputStream</c> to compress data while writing:
///   create a <c>BZip2OutputStream</c> with a writable output stream.
///   Then call <c>Write()</c> on that <c>BZip2OutputStream</c>, providing
///   uncompressed data as input.  The data sent to the output stream will
///   be the compressed form of the input data.
/// </para>
///
/// <para>
///   A <c>BZip2OutputStream</c> can be used only for <c>Write()</c> not for <c>Read()</c>.
/// </para>
///
/// </remarks>
///
/// <param name="buffer">The buffer holding data to write to the stream.</param>
/// <param name="offset">the offset within that data array to find the first byte to write.</param>
/// <param name="count">the number of bytes to write.</param>
// nothing to do
// The compressor data block is full.  Compress and
// write out the compressed data, then reset the
// compressor and continue.
// and now any remaining bits
/// <summary>
/// Indicates whether the stream can be read.
/// </summary>
/// <remarks>
/// The return value is always false.
/// </remarks>
/// <summary>
/// Indicates whether the stream supports Seek operations.
/// </summary>
/// <remarks>
/// Always returns false.
/// </remarks>
/// <summary>
/// Indicates whether the stream can be written.
/// </summary>
/// <remarks>
/// The return value should always be true, unless and until the
/// object is disposed and closed.
/// </remarks>
/// <summary>
/// Reading this property always throws a <see cref="NotImplementedException"/>.
/// </summary>
/// <summary>
/// The position of the stream pointer.
/// </summary>
///
/// <remarks>
///   Setting this property always throws a <see
///   cref="NotImplementedException"/>. Reading will return the
///   total number of uncompressed bytes written through.
/// </remarks>
/// <summary>
/// Calling this method always throws a <see cref="NotImplementedException"/>.
/// </summary>
/// <param name="offset">this is irrelevant, since it will always throw!</param>
/// <param name="origin">this is irrelevant, since it will always throw!</param>
/// <returns>irrelevant!</returns>
/// <summary>
/// Calling this method always throws a <see cref="NotImplementedException"/>.
/// </summary>
/// <param name="value">this is irrelevant, since it will always throw!</param>
/// <summary>
///   Calling this method always throws a <see cref="NotImplementedException"/>.
/// </summary>
/// <param name='buffer'>this parameter is never used</param>
/// <param name='offset'>this parameter is never used</param>
/// <param name='count'>this parameter is never used</param>
/// <returns>never returns anything; always throws</returns>
// used only when Trace is defined
//lock(outputLock)
//#define Trace
// ParallelBZip2OutputStream.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2011 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// Last Saved: <2011-August-02 16:44:24>
//
// ------------------------------------------------------------------
//
// This module defines the ParallelBZip2OutputStream class, which is a
// BZip2 compressing stream. This code was derived in part from Apache
// commons source code. The license below applies to the original Apache
// code.
//
// ------------------------------------------------------------------
// flymake: csc.exe /t:module BZip2InputStream.cs BZip2Compressor.cs Rand.cs BCRC32.cs @@FILE@@
/*
//www.apache.org/licenses/LICENSE-2.0
// Design Notes:
//
// This class follows the classic Decorator pattern: it is a Stream that
// wraps itself around a Stream, and in doing so provides bzip2
// compression as callers Write into it.  It is exactly the same in
// outward function as the BZip2OutputStream, except that this class can
// perform compression using multiple independent threads. Because of
// that, and because of the CPU-intensive nature of BZip2 compression,
// this class can perform significantly better (in terms of wall-click
// time) than the single-threaded variant, at the expense of memory and
// CPU utilization.
//
// BZip2 is a straightforward data format: there are 4 magic bytes at
// the top of the file, followed by 1 or more compressed blocks. There
// is a small "magic byte" trailer after all compressed blocks.
//
// In concept parallelizing BZip2 is simple: do the CPU-intensive
// compression for each block in a separate thread, then emit the
// compressed output, in order, to the output stream. Each block can be
// compressed independently, so a block is the natural candidate for the
// parcel of work that can be passed to an independent worker thread.
//
// The design approach used here is simple: within the Write() method of
// the stream, fill a block.  When the block is full, pass it to a
// background worker thread for compression.  When the compressor thread
// completes its work, the main thread (the application thread that
// calls Write()) can send the compressed data to the output stream,
// being careful to respect the order of the compressed blocks.
//
// The challenge of ordering the compressed data is a solved and
// well-understood problem - it is the same approach here as DotNetZip
// uses in the ParallelDeflateOutputStream. It is a map/reduce approach
// in design intent.
//
// One new twist for BZip2 is that the compressor output is not
// byte-aligned. In other words the final output of a compressed block
// will in general be a number of bits that is not a multiple of
// 8. Therefore, combining the ordered results of the N compressor
// threads requires additional byte-shredding by the parent
// stream. Hence this stream uses a BitWriter to adapt bit-oriented
// BZip2 output to the byte-oriented .NET Stream.
//
// The approach used here creates N instances of the BZip2Compressor
// type, where N is governed by the number of cores (cpus) and limited
// by the MaxWorkers property exposed by this class. Each
// BZip2Compressor instance gets its own MemoryStream, to which it
// writes its data, via a BitWriter.
//
// along with the bit accumulator described above. The MemoryStream
// would gather the byte-aligned compressed output of the compressor.
// When reducing the output of the various workers, this class must
// again do the byte-shredding thing. The data from the compressors is
// therefore shredded twice: once when being placed into the
// MemoryStream, and again when emitted into the final output stream
// that this class decorates. This is an unfortunate and seemingly
// unavoidable inefficiency. Two rounds of byte-shredding will use more
// CPU than we'd like, but I haven't imagined a way to avoid it.
//
// The BZip2Compressor is designed to write directly into the parent
// stream's accumulator (BitWriter) when possible, and write into a
// distinct BitWriter when necessary.  The former can be used in a
// single-thread scenario, while the latter is required in a
// multi-thread scenario.
//
// ----
//
// Regarding the Apache code base: Most of the code in this particular
// class is related to stream operations and thread synchronization, and
// is my own code. It largely does not rely on any code obtained from
// Apache commons. If you compare this code with the Apache commons
// BZip2OutputStream, you will see very little code that is common,
// except for the nearly-boilerplate structure that is common to all
// subtypes of System.IO.Stream. There may be some small remnants of
// code in this module derived from the Apache stuff, which is why I
// left the license in here. Most of the Apache commons compressor magic
// has been ported into the BZip2Compressor class.
//
// compressed data gets written to a MemoryStream
/// <summary>
///   A write-only decorator stream that compresses data as it is
///   written using the BZip2 algorithm. This stream compresses by
///   block using multiple threads.
/// </summary>
/// <para>
///   This class performs BZIP2 compression through writing.  For
///   more information on the BZIP2 algorithm, see
///   <see href="http://en.wikipedia.org/wiki/BZIP2"/>.
/// </para>
///
/// <para>
///   This class is similar to <see cref="Ionic.BZip2.BZip2OutputStream"/>,
///   except that this implementation uses an approach that employs multiple
///   worker threads to perform the compression.  On a multi-cpu or multi-core
///   computer, the performance of this class can be significantly higher than
///   the single-threaded BZip2OutputStream, particularly for larger streams.
///   How large?  Anything over 10mb is a good candidate for parallel
///   compression.
/// </para>
///
/// <para>
///   The tradeoff is that this class uses more memory and more CPU than the
///   vanilla <c>BZip2OutputStream</c>. Also, for small files, the
///   <c>ParallelBZip2OutputStream</c> can be much slower than the vanilla
///   <c>BZip2OutputStream</c>, because of the overhead associated to using the
///   thread pool.
/// </para>
///
/// <seealso cref="Ionic.BZip2.BZip2OutputStream" />
// for exceptions
// for multi-thread output
// 0...9
/// <summary>
///   Constructs a new <c>ParallelBZip2OutputStream</c>, that sends its
///   compressed output to the given output stream.
/// </summary>
///
/// <param name='output'>
///   The destination stream, to which compressed output will be sent.
/// </param>
///
/// <example>
///
///   This example reads a file, then compresses it with bzip2 file,
///   and writes the compressed data into a newly created file.
///
///   <code>
///   var fname = "logfile.log";
///   using (var fs = File.OpenRead(fname))
///   {
///       var outFname = fname + ".bz2";
///       using (var output = File.Create(outFname))
///       {
///           using (var compressor = new Ionic.BZip2.ParallelBZip2OutputStream(output))
///           {
///               byte[] buffer = new byte[2048];
///               int n;
///               while ((n = fs.Read(buffer, 0, buffer.Length)) > 0)
///               {
///                   compressor.Write(buffer, 0, n);
///               }
///           }
///       }
///   }
///   </code>
/// </example>
/// <summary>
///   Constructs a new <c>ParallelBZip2OutputStream</c> with specified blocksize.
/// </summary>
/// <param name = "output">the destination stream.</param>
/// <param name = "blockSize">
///   The blockSize in units of 100000 bytes.
///   The valid range is 1..9.
/// </param>
/// <summary>
///   Constructs a new <c>ParallelBZip2OutputStream</c>.
/// </summary>
///   <param name = "output">the destination stream.</param>
/// <param name = "leaveOpen">
///   whether to leave the captive stream open upon closing this stream.
/// </param>
/// <summary>
///   Constructs a new <c>ParallelBZip2OutputStream</c> with specified blocksize,
///   and explicitly specifies whether to leave the wrapped stream open.
/// </summary>
///
/// <param name = "output">the destination stream.</param>
/// <param name = "blockSize">
///   The blockSize in units of 100000 bytes.
///   The valid range is 1..9.
/// </param>
/// <param name = "leaveOpen">
///   whether to leave the captive stream open upon closing this stream.
/// </param>
// default
/// <summary>
///   The maximum number of concurrent compression worker threads to use.
/// </summary>
///
/// <remarks>
/// <para>
///   This property sets an upper limit on the number of concurrent worker
///   threads to employ for compression. The implementation of this stream
///   employs multiple threads from the .NET thread pool, via <see
///   cref="System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback)">
///   ThreadPool.QueueUserWorkItem()</see>, to compress the incoming data by
///   block.  As each block of data is compressed, this stream re-orders the
///   compressed blocks and writes them to the output stream.
/// </para>
///
/// <para>
///   A higher number of workers enables a higher degree of
///   parallelism, which tends to increase the speed of compression on
///   multi-cpu computers.  On the other hand, a higher number of buffer
///   pairs also implies a larger memory consumption, more active worker
///   threads, and a higher cpu utilization for any compression. This
///   property enables the application to limit its memory consumption and
///   CPU utilization behavior depending on requirements.
/// </para>
///
/// <para>
///   By default, DotNetZip allocates 4 workers per CPU core, subject to the
///   upper limit specified in this property. For example, suppose the
///   application sets this property to 16.  Then, on a machine with 2
///   cores, DotNetZip will use 8 workers; that number does not exceed the
///   upper limit specified by this property, so the actual number of
///   workers used will be 4 * 2 = 8.  On a machine with 4 cores, DotNetZip
///   will use 16 workers; again, the limit does not apply. On a machine
///   with 8 cores, DotNetZip will use 16 workers, because of the limit.
/// </para>
///
/// <para>
///   For each compression "worker thread" that occurs in parallel, there is
///   up to 2mb of memory allocated, for buffering and processing. The
///   actual number depends on the <see cref="BlockSize"/> property.
/// </para>
///
/// <para>
///   CPU utilization will also go up with additional workers, because a
///   larger number of buffer pairs allows a larger number of background
///   threads to compress in parallel. If you find that parallel
///   compression is consuming too much memory or CPU, you can adjust this
///   value downward.
/// </para>
///
/// <para>
///   The default value is 16. Different values may deliver better or
///   worse results, depending on your priorities and the dynamic
///   performance characteristics of your storage and compute resources.
/// </para>
///
/// <para>
///   The application can set this value at any time, but it is effective
///   only before the first call to Write(), which is when the buffers are
///   allocated.
/// </para>
/// </remarks>
/// <summary>
///   Close the stream.
/// </summary>
/// <remarks>
///   <para>
///     This may or may not close the underlying stream.  Check the
///     constructors that accept a bool value.
///   </para>
/// </remarks>
// compress and write whatever is ready
// get a new buffer next Write()
/// <summary>
///   Flush the stream.
/// </summary>
// not necessary to shred the initial magic bytes
// A magic 48-bit number, 0x177245385090, to indicate the end
// of the last block. (sqrt(pi), if you want to know)
// must shred
/// <summary>
///   The blocksize parameter specified at construction time.
/// </summary>
/// <summary>
///   Write data to the stream.
/// </summary>
/// <remarks>
///
/// <para>
///   Use the <c>ParallelBZip2OutputStream</c> to compress data while
///   writing: create a <c>ParallelBZip2OutputStream</c> with a writable
///   output stream.  Then call <c>Write()</c> on that
///   <c>ParallelBZip2OutputStream</c>, providing uncompressed data as
///   input.  The data sent to the output stream will be the compressed
///   form of the input data.
/// </para>
///
/// <para>
///   A <c>ParallelBZip2OutputStream</c> can be used only for
///   <c>Write()</c> not for <c>Read()</c>.
/// </para>
///
/// </remarks>
///
/// <param name="buffer">The buffer holding data to write to the stream.</param>
/// <param name="offset">the offset within that data array to find the first byte to write.</param>
/// <param name="count">the number of bytes to write.</param>
// This method does this:
//   0. handles any pending exceptions
//   1. write any buffers that are ready to be written
//   2. fills a compressor buffer; when full, flip state to 'Filled',
//   3. if more data to be written,  goto step 1
// dispense any exceptions that occurred on the BG threads
// nothing to do
// Want to do this on first Write, first session, and not in the
// constructor.  Must allow the MaxWorkers to change after
// construction, but before first Write().
// may need to make buffers available
// get a compressor to fill
// No compressors available to fill, so... need to emit
// compressed buffers.
// will get a new buffer next time
// When combining parallel compression with a ZipSegmentedStream, it's
// possible for the ZSS to throw from within this method.  In that
// case, Close/Dispose will be called on this stream, if this stream
// is employed within a using or try/finally pair as required. But
// this stream is unaware of the pending exception, so the Close()
// method invokes this method AGAIN. This can lead to a deadlock.
// Therefore, failfast if re-entering.
// out of order. requeue and try again.
// We went around the list once.
// None of the items in the list is the one we want.
// Now wait for a compressor to signal again.
// write the data to the output
// not bw2.FinishAndPad()!
// cannot dump bytes!!
// ms.WriteTo(this.output);
//
// must do byte shredding:
// diagnostics only
// and now any remaining bits
// don't wait next time through
// compress and one buffer
// compress and write to the compressor's MemoryStream
// expose the exception to the main thread
/// <summary>
/// Indicates whether the stream can be read.
/// </summary>
/// <remarks>
/// The return value is always false.
/// </remarks>
/// <summary>
/// Indicates whether the stream supports Seek operations.
/// </summary>
/// <remarks>
/// Always returns false.
/// </remarks>
/// <summary>
/// Indicates whether the stream can be written.
/// </summary>
/// <remarks>
/// The return value depends on whether the captive stream supports writing.
/// </remarks>
/// <summary>
/// Reading this property always throws a <see cref="NotImplementedException"/>.
/// </summary>
/// <summary>
/// The position of the stream pointer.
/// </summary>
///
/// <remarks>
///   Setting this property always throws a <see
///   cref="NotImplementedException"/>. Reading will return the
///   total number of uncompressed bytes written through.
/// </remarks>
/// <summary>
/// The total number of bytes written out by the stream.
/// </summary>
/// <remarks>
/// This value is meaningful only after a call to Close().
/// </remarks>
/// <summary>
/// Calling this method always throws a <see cref="NotImplementedException"/>.
/// </summary>
/// <param name="offset">this is irrelevant, since it will always throw!</param>
/// <param name="origin">this is irrelevant, since it will always throw!</param>
/// <returns>irrelevant!</returns>
/// <summary>
/// Calling this method always throws a <see cref="NotImplementedException"/>.
/// </summary>
/// <param name="value">this is irrelevant, since it will always throw!</param>
/// <summary>
/// Calling this method always throws a <see cref="NotImplementedException"/>.
/// </summary>
/// <param name='buffer'>this parameter is never used</param>
/// <param name='offset'>this parameter is never used</param>
/// <param name='count'>this parameter is never used</param>
/// <returns>never returns anything; always throws</returns>
// used only when Trace is defined
// Rand.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2011 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// Last Saved: <2011-July-31 15:09:16>
//
// ------------------------------------------------------------------
//
// This module defines a helper class for the BZip2 classes. This code
// is derived from the original BZip2 source code.
//
// ------------------------------------------------------------------
/// <summary>
///   Returns the "random" number at a specific index.
/// </summary>
/// <param name='i'>the index</param>
/// <returns>the random number</returns>
/// <summary>
/// Summary description for UnitTest1
/// </summary>
/// <summary>
///Gets or sets the test context which provides
///information about and functionality for the current test run.
///</summary>
//
// You can use the following additional attributes as you write your tests:
//
// Use ClassInitialize to run code before running the first test in the class
// [ClassInitialize()]
// public static void MyClassInitialize(TestContext testContext) { }
//
// Use ClassCleanup to run code after all tests in a class have run
// [ClassCleanup()]
// public static void MyClassCleanup() { }
//
// Use TestInitialize to run code before running each test
// [TestInitialize()]
// public void MyTestInitialize() { }
//
// Use TestCleanup to run code after each test has run
// [TestCleanup()]
// public void MyTestCleanup() { }
//
// Use TestInitialize to run code before running each test
// Use TestCleanup to run code after each test has run
// turn off any ReadOnly attributes
// use an backoff interval before retry
// don't traverse reparse points
// recurse
// clear ReadOnly and System attributes
// Microsoft.VisualStudio.TestTools.UnitTesting
// must read at least one of the stderr or stdout asynchronously,
// to avoid deadlock
//output = CleanWzzipOut(output); // just in case
// fill the file with text data, selecting one word at a time
// pick a word at random
// 60*1000 = 1min
// 60*1000 = 1min
// select a random text string
// number of iters
// emit many many lines into a text file:
// compress into bz2
// just for the sake of disk space economy:
// empty stream
// CRC32.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2011 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// Last Saved: <2011-August-02 18:25:54>
//
// ------------------------------------------------------------------
//
// This module defines the CRC32 class, which can do the CRC32 algorithm, using
// arbitrary starting polynomials, and bit reversal. The bit reversal is what
// distinguishes this CRC-32 used in BZip2 from the CRC-32 that is used in PKZIP
// files, or GZIP files. This class does both.
//
// ------------------------------------------------------------------
/// <summary>
///   Computes a CRC-32. The CRC-32 algorithm is parameterized - you
///   can set the polynomial and enable or disable bit
///   reversal. This can be used for GZIP, BZip2, or ZIP.
/// </summary>
/// <remarks>
///   This type is used internally by DotNetZip; it is generally not used
///   directly by applications wishing to create, read, or manipulate zip
///   archive files.
/// </remarks>
/// <summary>
///   Indicates the total number of bytes applied to the CRC.
/// </summary>
/// <summary>
/// Indicates the current CRC for all blocks slurped in.
/// </summary>
/// <summary>
/// Returns the CRC32 for the specified stream.
/// </summary>
/// <param name="input">The stream over which to calculate the CRC32</param>
/// <returns>the CRC32 calculation</returns>
/// <summary>
/// Returns the CRC32 for the specified stream, and writes the input into the
/// output stream.
/// </summary>
/// <param name="input">The stream over which to calculate the CRC32</param>
/// <param name="output">The stream into which to deflate the input</param>
/// <returns>the CRC32 calculation</returns>
/// <summary>
///   Get the CRC32 for the given (word,byte) combo.  This is a
///   computation defined by PKzip for PKZIP 2.0 (weak) encryption.
/// </summary>
/// <param name="W">The word to start with.</param>
/// <param name="B">The byte to combine it with.</param>
/// <returns>The CRC-ized result.</returns>
/// <summary>
/// Update the value for the running CRC32 using the given block of bytes.
/// This is useful when using the CRC32() class in a Stream.
/// </summary>
/// <param name="block">block of bytes to slurp</param>
/// <param name="offset">starting point in the block</param>
/// <param name="count">how many bytes within the block to slurp</param>
// bzip algorithm
/// <summary>
///   Process one byte in the CRC.
/// </summary>
/// <param name = "b">the byte to include into the CRC .  </param>
/// <summary>
///   Process a run of N identical bytes into the CRC.
/// </summary>
/// <remarks>
///   <para>
///     This method serves as an optimization for updating the CRC when a
///     run of identical bytes is found. Rather than passing in a buffer of
///     length n, containing all identical bytes b, this method accepts the
///     byte value and the length of the (virtual) buffer - the length of
///     the run.
///   </para>
/// </remarks>
/// <param name = "b">the byte to include into the CRC.  </param>
/// <param name = "n">the number of times that byte should be repeated. </param>
/// <summary>
///   Combines the given CRC32 value with the current running total.
/// </summary>
/// <remarks>
///   This is useful when using a divide-and-conquer approach to
///   calculating a CRC.  Multiple threads can each calculate a
///   CRC32 on a segment of the data, and then combine the
///   individual CRC32 values at the end.
/// </remarks>
/// <param name="crc">the crc value to be combined with this one</param>
/// <param name="length">the length of data the CRC value was calculated on</param>
// even-power-of-two zeros operator
// odd-power-of-two zeros operator
// put operator for one zero bit in odd
// the CRC-32 polynomial
// put operator for two zero bits in even
// put operator for four zero bits in odd
// apply len2 zeros to crc1 (first square will put the operator for one
// zero byte, eight zero bits, in even)
// apply zeros operator for this bit of len2
// another iteration of the loop with odd and even swapped
//return (int) crc1;
/// <summary>
///   Create an instance of the CRC32 class using the default settings: no
///   bit reversal, and a polynomial of 0xEDB88320.
/// </summary>
/// <summary>
///   Create an instance of the CRC32 class, specifying whether to reverse
///   data bits or not.
/// </summary>
/// <param name='reverseBits'>
///   specify true if the instance should reverse data bits.
/// </param>
/// <remarks>
///   <para>
///     In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
///     want a CRC32 with compatibility with BZip2, you should pass true
///     here. In the CRC-32 used by GZIP and PKZIP, the bits are not
///     reversed; Therefore if you want a CRC32 with compatibility with
///     those, you should pass false.
///   </para>
/// </remarks>
/// <summary>
///   Create an instance of the CRC32 class, specifying the polynomial and
///   whether to reverse data bits or not.
/// </summary>
/// <param name='polynomial'>
///   The polynomial to use for the CRC, expressed in the reversed (LSB)
///   format: the highest ordered bit in the polynomial value is the
///   coefficient of the 0th power; the second-highest order bit is the
///   coefficient of the 1 power, and so on. Expressed this way, the
///   polynomial for the CRC-32C used in IEEE 802.3, is 0xEDB88320.
/// </param>
/// <param name='reverseBits'>
///   specify true if the instance should reverse data bits.
/// </param>
///
/// <remarks>
///   <para>
///     In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
///     want a CRC32 with compatibility with BZip2, you should pass true
///     here for the <c>reverseBits</c> parameter. In the CRC-32 used by
///     GZIP and PKZIP, the bits are not reversed; Therefore if you want a
///     CRC32 with compatibility with those, you should pass false for the
///     <c>reverseBits</c> parameter.
///   </para>
/// </remarks>
/// <summary>
///   Reset the CRC-32 class - clear the CRC "remainder register."
/// </summary>
/// <remarks>
///   <para>
///     Use this when employing a single instance of this class to compute
///     multiple, distinct CRCs on multiple, distinct data blocks.
///   </para>
/// </remarks>
// private member vars
/// <summary>
/// A Stream that calculates a CRC32 (a checksum) on all bytes read,
/// or on all bytes written.
/// </summary>
///
/// <remarks>
/// <para>
/// This class can be used to verify the CRC of a ZipEntry when
/// reading from a stream, or to calculate a CRC when writing to a
/// stream.  The stream should be used to either read, or write, but
/// not both.  If you intermix reads and writes, the results are not
/// defined.
/// </para>
///
/// <para>
/// This class is intended primarily for use internally by the
/// DotNetZip library.
/// </para>
/// </remarks>
/// <summary>
/// The default constructor.
/// </summary>
/// <remarks>
///   <para>
///     Instances returned from this constructor will leave the underlying
///     stream open upon Close().  The stream uses the default CRC32
///     algorithm, which implies a polynomial of 0xEDB88320.
///   </para>
/// </remarks>
/// <param name="stream">The underlying stream</param>
/// <summary>
///   The constructor allows the caller to specify how to handle the
///   underlying stream at close.
/// </summary>
/// <remarks>
///   <para>
///     The stream uses the default CRC32 algorithm, which implies a
///     polynomial of 0xEDB88320.
///   </para>
/// </remarks>
/// <param name="stream">The underlying stream</param>
/// <param name="leaveOpen">true to leave the underlying stream
/// open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
/// <summary>
///   A constructor allowing the specification of the length of the stream
///   to read.
/// </summary>
/// <remarks>
///   <para>
///     The stream uses the default CRC32 algorithm, which implies a
///     polynomial of 0xEDB88320.
///   </para>
///   <para>
///     Instances returned from this constructor will leave the underlying
///     stream open upon Close().
///   </para>
/// </remarks>
/// <param name="stream">The underlying stream</param>
/// <param name="length">The length of the stream to slurp</param>
/// <summary>
///   A constructor allowing the specification of the length of the stream
///   to read, as well as whether to keep the underlying stream open upon
///   Close().
/// </summary>
/// <remarks>
///   <para>
///     The stream uses the default CRC32 algorithm, which implies a
///     polynomial of 0xEDB88320.
///   </para>
/// </remarks>
/// <param name="stream">The underlying stream</param>
/// <param name="length">The length of the stream to slurp</param>
/// <param name="leaveOpen">true to leave the underlying stream
/// open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
/// <summary>
///   A constructor allowing the specification of the length of the stream
///   to read, as well as whether to keep the underlying stream open upon
///   Close(), and the CRC32 instance to use.
/// </summary>
/// <remarks>
///   <para>
///     The stream uses the specified CRC32 instance, which allows the
///     application to specify how the CRC gets calculated.
///   </para>
/// </remarks>
/// <param name="stream">The underlying stream</param>
/// <param name="length">The length of the stream to slurp</param>
/// <param name="leaveOpen">true to leave the underlying stream
/// open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
/// <param name="crc32">the CRC32 instance to use to calculate the CRC32</param>
// This ctor is private - no validation except null is done here.
// This is to allow the use
// of a (specific) negative value for the _lengthLimit, to indicate that there
// is no length set.  So we validate the length limit in those ctors that use an
// explicit param, otherwise we don't validate, because it could be our special
// value.
/// <summary>
///   Gets the total number of bytes run through the CRC32 calculator.
/// </summary>
///
/// <remarks>
///   This is either the total number of bytes read, or the total number of
///   bytes written, depending on the direction of this stream.
/// </remarks>
/// <summary>
///   Provides the current CRC for all blocks slurped in.
/// </summary>
/// <remarks>
///   <para>
///     The running total of the CRC is kept as data is written or read
///     through the stream.  read this property after all reads or writes to
///     get an accurate CRC for the entire stream.
///   </para>
/// </remarks>
/// <summary>
///   Indicates whether the underlying stream will be left open when the
///   <c>CrcCalculatorStream</c> is Closed.
/// </summary>
/// <remarks>
///   <para>
///     Set this at any point before calling <see cref="Close()"/>.
///   </para>
/// </remarks>
/// <summary>
/// Read from the stream
/// </summary>
/// <param name="buffer">the buffer to read</param>
/// <param name="offset">the offset at which to start</param>
/// <param name="count">the number of bytes to read</param>
/// <returns>the number of bytes actually read</returns>
// Need to limit the # of bytes returned, if the stream is intended to have
// a definite length.  This is especially useful when returning a stream for
// the uncompressed data directly to the application.  The app won't
// necessarily read only the UncompressedSize number of bytes.  For example
// wrapping the stream returned from OpenReader() into a StreadReader() and
// calling ReadToEnd() on it, We can "over-read" the zip data and get a
// corrupt string.  The length limits that, prevents that problem.
// EOF
/// <summary>
/// Write to the stream.
/// </summary>
/// <param name="buffer">the buffer from which to write</param>
/// <param name="offset">the offset at which to start writing</param>
/// <param name="count">the number of bytes to write</param>
/// <summary>
/// Indicates whether the stream supports reading.
/// </summary>
/// <summary>
///   Indicates whether the stream supports seeking.
/// </summary>
/// <remarks>
///   <para>
///     Always returns false.
///   </para>
/// </remarks>
/// <summary>
/// Indicates whether the stream supports writing.
/// </summary>
/// <summary>
/// Flush the stream.
/// </summary>
/// <summary>
///   Returns the length of the underlying stream.
/// </summary>
/// <summary>
///   The getter for this property returns the total bytes read.
///   If you use the setter, it will throw
/// <see cref="NotSupportedException"/>.
/// </summary>
/// <summary>
/// Seeking is not supported on this stream. This method always throws
/// <see cref="NotSupportedException"/>
/// </summary>
/// <param name="offset">N/A</param>
/// <param name="origin">N/A</param>
/// <returns>N/A</returns>
/// <summary>
/// This method always throws
/// <see cref="NotSupportedException"/>
/// </summary>
/// <param name="value">N/A</param>
/// <summary>
/// Closes the stream.
/// </summary>
// CreateZip.cs
// 
// ----------------------------------------------------------------------
// Copyright (c) 2006, 2007, 2008 Microsoft Corporation.  All rights reserved.
//
// This example is released under the Microsoft Permissive License of
// October 2006.  See the license.txt file accompanying this release for 
// full details. 
//
// ----------------------------------------------------------------------
//
// This simplistic utility gets a list of all the files in the specified directory,
// and zips them into a single archive.  This utility does not recurse through
// the directory tree.
//
// compile with:
//     csc /debug+ /target:exe /R:Ionic.Utils.Zip.dll /out:CreateZip.exe CreateZip.cs 
//
//
// Wed, 29 Mar 2006  14:36
//
// note: this does not recurse directories! 
// This is just a sample, provided to illustrate the DotNetZip interface.  
// This logic does not recurse through sub-directories.
// If you are zipping up a directory, you may want to see the AddDirectory() method, 
// which operates recursively. 
// ReadZip.cs
//
// ----------------------------------------------------------------------
// Copyright (c) 2006-2009 Microsoft Corporation.  All rights reserved.
//
// This example is released under the Microsoft Public License .
// See the license.txt file accompanying this release for
// full details.
//
// ----------------------------------------------------------------------
//
// This simple example utility simply reads a zip archive and extracts
// all elements in it, to the specified target directory.
//
// compile with:
//     csc /target:exe /r:Ionic.Zip.dll /out:ReadZip.exe ReadZip.cs
//
// Wed, 29 Mar 2006  14:36
//
// Specifying Console.Out here causes diagnostic msgs to be sent to the Console
// In a WinForms or WPF or Web app, you could specify nothing, or an alternate
// TextWriter to capture diagnostic messages.
// This call to ExtractAll() assumes:
//   - none of the entries are password-protected.
//   - want to extract all entries to current working directory
//   - none of the files in the zip already exist in the directory;
//     if they do, the method will throw.
// QuickZip.cs
// ------------------------------------------------------------------
//
// A simple app that creates a zip file, zipping up a files and
// directories specified on the command line.  This application needs to
// be run from the console, in order to specify arguments, but it is
// also a winforms app.
//
// It correctly does the multi-threading to allow smooth UI update.
//
// compile it with:
//      c:\.net3.5\csc.exe /t:exe /debug:full /optimize- /R:System.dll /R:Ionic.Zip.dll
//                                /out:QuickZip.exe QuickZip.cs
//
// last saved:
// Time-stamp: <2010-March-16 14:11:42>
// ------------------------------------------------------------------
//
// Copyright (c) 2010 by Dino Chiesa
// All rights reserved!
//
// Licensed under the Microsoft Public License.
// see http://www.opensource.org/licenses/ms-pl.html
//
// ------------------------------------------------------------------
//using System.Reflection;
// Form, Label, ProgressBar
// ZipFile, ZipEntry
// BackgroundWorker
// DllImport
// open a new window so we can write to it.
// For info on running long-running tasks in response to button clicks,
// in  VB.NET WinForms, see
// http://msdn.microsoft.com/en-us/library/ms951089.aspx
//Console.WriteLine("pb max {0}", e.EntriesTotal);
//Console.WriteLine("entry {0}", e.CurrentEntry.FileName);
// ms to keep form open after completion
// Fields
// ZipDir.cs
// 
// ----------------------------------------------------------------------
// Copyright (c) 2006, 2007, 2008 Microsoft Corporation.  All rights reserved.
//
// This example is released under the Microsoft Permissive License of
// October 2006.  See the license.txt file accompanying this release for 
// full details. 
//
// ----------------------------------------------------------------------
//
// This utility zips up a single directory specified on the command line.
// It is like a specialized ZipIt tool (See ZipIt.cs).
//
// compile with:
//     csc /debug+ /target:exe /r:Zip.dll /out:ZipDir.exe ZipDir.cs 
//
// Wed, 29 Mar 2006  14:36
//
// recurses subdirectories
// ' full path
// Returns the TreeNode for a given name 
/// <summary>
/// Required designer variable.
/// </summary>
/// <summary>
/// Clean up any resources being used.
/// </summary>
/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
/// <summary>
/// Required method for Designer support - do not modify
/// the contents of this method with the code editor.
/// </summary>
// 
// treeView1
// 
// 
// textBox1
// 
// 
// button1
// 
// 
// Form1
// 
/// <summary>
/// The main entry point for the application.
/// </summary>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.225
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
/// <summary>
///   A strongly-typed resource class, for looking up localized strings, etc.
/// </summary>
// This class was auto-generated by the StronglyTypedResourceBuilder
// class via a tool like ResGen or Visual Studio.
// To add or remove a member, edit your .ResX file then rerun ResGen
// with the /str option, or rebuild your VS project.
/// <summary>
///   Returns the cached ResourceManager instance used by this class.
/// </summary>
/// <summary>
///   Overrides the current thread's CurrentUICulture property for all
///   resource lookups using this strongly typed resource class.
/// </summary>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.225
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
//#define Trace
// ParallelGZipOutputStream.cs
// ------------------------------------------------------------------
//
// A GzipStream that does compression only, and only in output. It uses a
// divide-and-conquer approach with multiple threads to exploit multiple
// CPUs for the DEFLATE computation.
//
// Last Saved: <2011-July-11 14:36:48>
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2011 by Dino Chiesa
// All rights reserved!
//
// ------------------------------------------------------------------
//
// compile: c:\.net4.0\csc.exe /t:module /R:Ionic.Zip.dll @@ORIG@@
// flymake: c:\.net4.0\csc.exe /t:module /R:Ionic.Zip.dll @@FILE@@
//
// alloc 5 bytes overhead for every block (margin of safety= 2)
/// <summary>
///   A class for compressing and decompressing streams using the
///   Deflate algorithm with multiple threads.
/// </summary>
///
/// <remarks>
/// <para>
///   This class is for compression only, and that can be only
///   through writing.
/// </para>
///
/// <para>
///   For more information on the Deflate algorithm, see IETF RFC 1952,
///   "GZIP file format specification version 4.3" http://tools.ietf.org/html/rfc1952
/// </para>
///
/// <para>
///   This class is similar to <see
///   cref="System.IO.Compression.GzipStream"/>, except that this
///   implementation uses an approach that employs multiple worker threads
///   to perform the compression.  On a multi-cpu or multi-core computer,
///   the performance of this class can be significantly higher than the
///   single-threaded DeflateStream, particularly for larger streams.  How
///   large?  In my experience, Anything over 10mb is a good candidate for parallel
///   compression.
/// </para>
///
/// <para>
///   The tradeoff is that this class uses more memory and more CPU than the
///   vanilla DeflateStream, and also is slightly less efficient as a compressor. For
///   large files the size of the compressed data stream can be less than 1%
///   larger than the size of a compressed data stream from the vanialla
///   DeflateStream.  For smaller files the difference can be larger.  The
///   difference will also be larger if you set the BufferSize to be lower
///   than the default value.  Your mileage may vary. Finally, for small
///   files, the ParallelGZipOutputStream can be much slower than the vanilla
///   DeflateStream, because of the overhead of using the thread pool.
/// </para>
///
/// </remarks>
/// <seealso cref="Ionic.Zlib.DeflateStream" />
// protects _pendingException
// This bitfield is used only when Trace is defined.
//private TraceBits _DesiredTrace = TraceBits.All;
/// <summary>
/// Create a ParallelGZipOutputStream.
/// </summary>
/// <remarks>
///
/// <para>
///   This stream compresses data written into it via the DEFLATE
///   algorithm (see RFC 1951), and writes out the compressed byte stream.
/// </para>
///
/// <para>
///   The instance will use the default compression level, the default
///   buffer sizes and the default number of threads and buffers per
///   thread.
/// </para>
///
/// <para>
///   This class is similar to <see cref="Ionic.Zlib.DeflateStream"/>,
///   except that this implementation uses an approach that employs
///   multiple worker threads to perform the DEFLATE.  On a multi-cpu or
///   multi-core computer, the performance of this class can be
///   significantly higher than the single-threaded DeflateStream,
///   particularly for larger streams.  How large?  Anything over 10mb is
///   a good candidate for parallel compression.
/// </para>
///
/// </remarks>
///
/// <example>
///
/// This example shows how to use a ParallelGZipOutputStream to compress
/// data.  It reads a file, compresses it, and writes the compressed data to
/// a second, output file.
///
/// <code>
/// byte[] buffer = new byte[WORKING_BUFFER_SIZE];
/// int n= -1;
/// String outputFile = fileToCompress + ".compressed";
/// using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
/// {
///     using (var raw = System.IO.File.Create(outputFile))
///     {
///         using (Stream compressor = new ParallelGZipOutputStream(raw))
///         {
///             while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
///             {
///                 compressor.Write(buffer, 0, n);
///             }
///         }
///     }
/// }
/// </code>
/// <code lang="VB">
/// Dim buffer As Byte() = New Byte(4096) {}
/// Dim n As Integer = -1
/// Dim outputFile As String = (fileToCompress &amp; ".compressed")
/// Using input As Stream = File.OpenRead(fileToCompress)
///     Using raw As FileStream = File.Create(outputFile)
///         Using compressor As Stream = New ParallelGZipOutputStream(raw)
///             Do While (n &lt;&gt; 0)
///                 If (n &gt; 0) Then
///                     compressor.Write(buffer, 0, n)
///                 End If
///                 n = input.Read(buffer, 0, buffer.Length)
///             Loop
///         End Using
///     End Using
/// End Using
/// </code>
/// </example>
/// <param name="stream">The stream to which compressed data will be written.</param>
/// <summary>
///   Create a ParallelDeflateOutputStream using the specified CompressionLevel.
/// </summary>
/// <remarks>
///   See the <see cref="ParallelDeflateOutputStream(System.IO.Stream)"/>
///   constructor for example code.
/// </remarks>
/// <param name="stream">The stream to which compressed data will be written.</param>
/// <param name="level">A tuning knob to trade speed for effectiveness.</param>
/// <summary>
/// Create a ParallelDeflateOutputStream and specify whether to leave the captive stream open
/// when the ParallelDeflateOutputStream is closed.
/// </summary>
/// <remarks>
///   See the <see cref="ParallelDeflateOutputStream(System.IO.Stream)"/>
///   constructor for example code.
/// </remarks>
/// <param name="stream">The stream to which compressed data will be written.</param>
/// <param name="leaveOpen">
///    true if the application would like the stream to remain open after inflation/deflation.
/// </param>
/// <summary>
/// Create a ParallelDeflateOutputStream and specify whether to leave the captive stream open
/// when the ParallelDeflateOutputStream is closed.
/// </summary>
/// <remarks>
///   See the <see cref="ParallelDeflateOutputStream(System.IO.Stream)"/>
///   constructor for example code.
/// </remarks>
/// <param name="stream">The stream to which compressed data will be written.</param>
/// <param name="level">A tuning knob to trade speed for effectiveness.</param>
/// <param name="leaveOpen">
///    true if the application would like the stream to remain open after inflation/deflation.
/// </param>
/// <summary>
/// Create a ParallelDeflateOutputStream using the specified
/// CompressionLevel and CompressionStrategy, and specifying whether to
/// leave the captive stream open when the ParallelDeflateOutputStream is
/// closed.
/// </summary>
/// <remarks>
///   See the <see cref="ParallelDeflateOutputStream(System.IO.Stream)"/>
///   constructor for example code.
/// </remarks>
/// <param name="stream">The stream to which compressed data will be written.</param>
/// <param name="level">A tuning knob to trade speed for effectiveness.</param>
/// <param name="strategy">
///   By tweaking this parameter, you may be able to optimize the compression for
///   data with particular characteristics.
/// </param>
/// <param name="leaveOpen">
///    true if the application would like the stream to remain open after inflation/deflation.
/// </param>
// default
/// <summary>
///   The ZLIB strategy to be used during compression.
/// </summary>
///
/// <summary>
/// The number of buffers to use.
/// </summary>
///
/// <remarks>
/// <para>
///   This property sets the number of memory buffers to create. This
///   sets an upper limit on the amount of memory the stream can use,
///   and also the degree of parallelism the stream can employ.
/// </para>
///
/// <para>
///   The divide-and-conquer approach taken by this class assumes a
///   single thread from the application will call Write().  There
///   will be multiple Tasks that then compress (DEFLATE) the data
///   written into the stream. The application's thread aggregates
///   those results and emits the compressed output.
/// </para>
///
/// <para>
///   The default value is 4.  Different values may deliver better or
///   worse results, depending on the dynamic performance
///   characteristics of your storage and compute resources. If you
///   have more than 2 CPUs, or more than 3gb memory, you probably
///   want to increase this value.
/// </para>
///
/// <para>
///   The total amount of storage space allocated for buffering will
///   be (M*S*2), where M is the multiple (this property), S is the
///   size of each buffer (<see cref="BufferSize"/>). There are 2
///   buffers used by the compressor, one for input and one for
///   output. If you retain the default values for Buckets (4), and
///   BufferSize (64k), then the ParallelDeflateOutputStream will use
///   512kb of buffer memory in total.
/// </para>
///
/// <para>
///   The application can set this value at any time, but it is effective
///   only before the first call to Write(), which is when the buffers are
///   allocated.
/// </para>
/// </remarks>
/// <summary>
///   The size of the buffers used by the compressor threads.
/// </summary>
/// <remarks>
///
/// <para>
///   The default buffer size is 128k. The application can set
///   this value at any time, but it is effective only before
///   the first Write().
/// </para>
///
/// <para>
///   Larger buffer sizes implies larger memory consumption but allows
///   more efficient compression. Using smaller buffer sizes consumes less
///   memory but result in less effective compression.  For example, using
///   the default buffer size of 128k, the compression delivered is within
///   1% of the compression delivered by the single-threaded <see
///   cref="Ionic.Zlib.DeflateStream"/>.  On the other hand, using a
///   BufferSize of 8k can result in a compressed data stream that is 5%
///   larger than that delivered by the single-threaded
///   <c>DeflateStream</c>.  Excessively small buffer sizes can also cause
///   the speed of the ParallelDeflateOutputStream to drop, because of
///   larger thread scheduling overhead dealing with many many small
///   buffers.
/// </para>
///
/// <para>
///   The total amount of storage space allocated for buffering will be
///   (n*M*S*2), where n is the number of CPUs, M is the multiple (<see
///   cref="BuffersPerCore"/>), S is the size of each buffer (this
///   property), and there are 2 buffers used by the compressor, one for
///   input and one for output. For example, if your machine has a total
///   of 4 cores, and if you set <see cref="BuffersPerCore"/> to 3, and
///   you keep the default buffer size of 128k, then the
///   <c>ParallelDeflateOutputStream</c> will use 3mb of buffer memory in
///   total.
/// </para>
///
/// </remarks>
/// <summary>
/// The CRC32 for the pre-compressed data that was written through the stream.
/// </summary>
/// <remarks>
/// This value is meaningful only after a call to Close().
/// </remarks>
/// <summary>
/// The total number of uncompressed bytes processed by the ParallelGZipOutputStream.
/// </summary>
/// <remarks>
/// This value is meaningful only after a call to Close().
/// </remarks>
/// <summary>
///   The comment on the GZIP stream.
/// </summary>
///
/// <remarks>
/// <para>
///   The GZIP format allows for each file to optionally have an associated
///   comment stored with the file.  The comment is encoded with the ISO-8859-1
///   code page.  To include a comment in a GZIP stream you create, set this
///   property before calling <c>Write()</c> for the first time on the
///   <c>ParallelGZipOutputStream</c>.
/// </para>
///
/// </remarks>
/// <summary>
///   The FileName for the GZIP stream.
/// </summary>
///
/// <remarks>
///
/// <para>
///   The GZIP format optionally allows each compressed file to embed an
///   associated filename. This property holds that value.  Set this
///   property before calling <c>Write()</c> the first time on the
///   <c>ParallelGZipOutputStream</c>.  The actual filename is encoded
///   into the GZIP bytestream with the ISO-8859-1 code page, according
///   to RFC 1952. It is the application's responsibility to insure that
///   the FileName can be encoded and decoded correctly with this code
///   page.
/// </para>
///
/// <para>
///   The value of this property is merely written into the GZIP output.
///   There is nothing in this class that verifies that the value you
///   set here is consistent with any filesystem file the compressed
///   data eventually written to, if any.
/// </para>
/// </remarks>
/// <summary>
///   The last modified time for the GZIP stream.
/// </summary>
///
/// <remarks>
///   GZIP allows the storage of a last modified time with each GZIP entry.
///   When compressing data, you must set this before the first call to
///   <c>Write()</c>, in order for it to be written to the output stream.
/// </remarks>
// The collection has been completed.
// Some other thread has called CompleteAdding()
// after this thread passed the
// IsCompleted check.
// compress one buffer
// expose the exception to the main thread
// Start one perpetual compressor task per bucket.
// for diagnostic purposes only
// ID
// compression method
// flag
// mtime
// xflg
// this field is totally useless
// OS
// 0xFF == unspecified
// extra field length - only if FEXTRA is set, which it is not.
//header[i++]= 0;
//header[i++]= 0;
// filename
// terminate
// comment
// terminate
// bytes written
// When combining parallel deflation with a ZipSegmentedStream, it's
// possible for the ZSS to throw from within this method.  In that
// case, Close/Dispose will be called on this stream, if this stream
// is employed within a using or try/finally pair as required. But
// this stream is unaware of the pending exception, so the Close()
// method invokes this method AGAIN.  This can lead to a deadlock.
// Therefore, failfast if re-entering.
// not the needed ordinal, so requeue and try again.
// We went around the list once.
// None of the items in the list is the one we want.
// Now wait for a compressor to signal.
// don't wait next time through
/// <summary>
///   Write data to the stream.
/// </summary>
///
/// <remarks>
///
/// <para>
///   To use the ParallelGZipOutputStream to compress data, create a
///   ParallelGZipOutputStream, passing a writable output stream.
///   Then call Write() on that ParallelGZipOutputStream, providing
///   uncompressed data as input. The data sent to the output stream
///   will be the compressed form of the data written into the stream.
/// </para>
///
/// <para>
///   To decompress data, use the <see cref="Ionic.Zlib.DeflateStream"/> class.
///   Any RFC-1951
/// </para>
///
/// </remarks>
/// <param name="buffer">The buffer holding data to write to the stream.</param>
/// <param name="offset">the offset within that data array to find the first byte to write.</param>
/// <param name="count">the number of bytes to write.</param>
// dispense any exception that occurred on the BG threads
// NOP
// may need to make buffers available
// use current, or get a buffer to fill
// no available buffers, so... need to emit
// compressed buffers.
// TODO: consider rollover?
// copy from the provided buffer to our workitem, starting at
// the tail end of whatever data we might have in there currently.
// will get a new buffer next time
// until no more to write
// After writing a series of compressed buffers, each one closed
// with Flush.Sync, we now write the final one as Flush.Finish,
// and then stop.
// Emit the GZIP trailer: CRC32 and  size mod 2^32
// post the current partial buffer to the _toCompress queue
// get a new buffer next Write()
//_toWrite.CompleteAdding(); // cannot do because of sifting
/// <summary>
///   Flush the stream.
/// </summary>
/// <summary>
///   Close the stream.
/// </summary>
/// <remarks>
///   <para>
///     The application must call Close() on this stream to guarantee
///     that all of the data written in has been compressed, and the
///     compressed data has been written out.
///   </para>
///   <para>
///     Close() is called implicitly when this stream is used within
///     a using clause.
///   </para>
/// </remarks>
/// <summary>Dispose the object</summary>
/// <remarks>
///   <para>
///     Because ParallelDeflateOutputStream is IDisposable, the
///     application must call this method when finished using the instance.
///   </para>
///   <para>
///     This method is generally called implicitly upon exit from
///     a <c>using</c> scope in C# (<c>Using</c> in VB).
///   </para>
/// </remarks>
/// <summary>The Dispose method</summary>
// dispose managed resources
// step 1: deflate the buffer
// step 2: flush (sync)
// used only when Trace is defined
// enter _EmitPending
// begin to write out
// done writing out
// writer skipping a workitem
// All Emit flags
// constructor/disposer
// Close/Reset
// thread synchronization
// instance settings
// compress task
// filling buffers, when caller invokes Write()
// upon entry to Write()
// on _toFill.Take()
/// <summary>
/// Indicates whether the stream supports Seek operations.
/// </summary>
/// <remarks>
/// Always returns false.
/// </remarks>
/// <summary>
/// Indicates whether the stream supports Read operations.
/// </summary>
/// <remarks>
/// Always returns false.
/// </remarks>
/// <summary>
/// Indicates whether the stream supports Write operations.
/// </summary>
/// <remarks>
/// Returns true if the provided stream is writable.
/// </remarks>
/// <summary>
/// Reading this property always throws a NotSupportedException.
/// </summary>
/// <summary>
///   Writing this property always throws a NotSupportedException.
///   On Read, the value is the number of bytes written so far to the
///   output.
/// </summary>
/// <seealso cref="TotalBytesProcessed" />
/// <summary>
/// This method always throws a NotSupportedException.
/// </summary>
/// <summary>
/// This method always throws a NotSupportedException.
/// </summary>
/// <summary>
/// This method always throws a NotSupportedException.
/// </summary>
// QuickCompress.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2011 by Dino Chiesa
// All rights reserved!
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// Purpose: Demonstrate compression and decompression with the easy
// helper methods in the Ionic.Zlib namespace.
//
// ------------------------------------------------------------------
//
// to allow fast ngen
/// <summary>
///   Holds the results of the compression.
/// </summary>
/// <remarks>
///   <para>
///     Compression algorithms can be measured two ways: size of the
///     result, and the time required to compress.  This small class
///     just holds the measured result for a particular compression
///     algorithm.
///   </para>
/// </remarks>
/// <summary>
///   Perform one trial, measuring the effectiveness and speed
///   of compression.
/// </summary>
///
/// <param name='label'>the label for the trial</param>
///
/// <param name='compressor'>a function that accepts a string,
/// and returns a byte array representing the compressed
/// form</param>
///
/// <param name='decompressor'>a function that accepts a byte
/// array, and decompresses it, returning a string. </param>
///
/// <param name='s'>the string to compress and decompress</param>
///
/// <param name='nCycles'>the number of cycles to time</param>
///
/// <returns>the CompressionTrialResult describing the trial results</returns>
///
/// <remarks>
/// </remarks>
// verify that the compression decompresses correctly
// compress the same thing 1000 times, and measure the time
// do the compression:
// now let's do some timed trials
// All these classes use the same underlying algorithm - DEFLATE -
// which means they all produce compressed forms that are roughly the
// same size. The difference between them is only in the metadata
// surrounding the raw compressed streams, and the level of integrity
// checking they provide. For example, during compression, the
// GzipStream internally calculates an Alder checksum on the data;
// during decompression, it verifies that checksum, as an integrity
// check. The other classes don't do this. Therefore the GZipStream
// will always take slightly longer in compression and decompression
// than the others, and will produce compressed streams that are
// slightly larger.  The results will show that.
// Test deflate() with preset dictionary
// Test deflate() with full flush
// force an error in first compressed block // dinoch 
/* Because of incorrect adler32 */
// Test deflate() with large buffers and dynamic change of compression level
// At this point, bufferToCompress is all zeroes, so it should compress
// very well:
// Feed in already compressed data and switch to no compression:
// why? - for fun
// Insert data into bufferToCompress, and Switch back to compressing mode:
// upon inflating, we overwrite the decompressedBytes buffer repeatedly
// ZlibDeflateInflate.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009 by Dino Chiesa
// All rights reserved!
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License. 
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// Purpose: Demonstrate compression and decompression with the ZlibCodec
// class, which is part of the Ionic.Zlib namespace.
// 
// ------------------------------------------------------------------
//
// HashAlgorithm
// to allow fast ngen
// If you want a ZLIB stream, set this to true.  If you want
// a bare DEFLATE stream, set this to false.
// If you have a ZLIB stream, set this to true.  If you have
// a bare DEFLATE stream, set this to false.
// ZlibDeflateInflate.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2011 by Dino Chiesa
// All rights reserved!
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// Purpose: Demonstrate compression and decompression with the ZlibStream
// class, which is part of the Ionic.Zlib namespace.
//
// ------------------------------------------------------------------
//
// to allow fast ngen
/// <summary>
/// Converts a string to a MemoryStream.
/// </summary>
/// <summary>
/// Converts a MemoryStream to a string. Makes some assumptions about the content of the stream.
/// </summary>
/// <param name="s"></param>
/// <returns></returns>
// first, compress:
// at this point, msSinkCompressed contains the compressed bytes
// now, decompress:
// at this point, msSinkDecompressed contains the decompressed bytes
// This call to ExtractAll() assumes:
//   - none of the entries are password-protected.
//   - want to extract all entries to current working directory
//   - none of the files in the zip already exist in the directory;
//     if they do, the method will throw.
// BZip2.cs
//
// ----------------------------------------------------------------------
// Copyright (c) 2011 Dino Chiesa.  All rights reserved.
//
// This example is released under the Microsoft Permissive License of
// October 2006.  See the license.txt file accompanying this release for
// full details.
//
// ----------------------------------------------------------------------
//
// This utility creates a compresses the file specified on the command line,
// using BZip2, creating a new file, with the .bz2 suffix. Or, if the
// file specified on the command-line has a .bz2 suffix, this utility
// decompresses it, restoring the original file.
//
// compile with:
//     csc /debug+ /target:exe /r:Ionic.Zip.dll /out:BZip2.exe BZip2.cs
//
// Sat, 23 Jul 2011  22:32
//
//dotnetzip.codeplex.com for info.\n"+
//cleanupCompleted.WaitOne();
// prevent the process from exiting until cleanup is done:
// ConvertZipToSfx.cs
// ------------------------------------------------------------------
//
// This is a command-line tool that creates a self-extracting Zip archive, given a
// standard zip archive.
// It requires the .NET Framework 4.0 on the target machine in order to run.
//
//
// The Visual Studio Project is a little weird.  There are code files that ARE NOT compiled
// during a normal build of the VS Solution.  They are marked as embedded resources.  These
// are the various "boilerplate" modules that are used in the self-extractor. These modules are:
//   WinFormsSelfExtractorStub.cs
//   WinFormsSelfExtractorStub.Designer.cs
//   CommandLineSelfExtractorStub.cs
//   PasswordDialog.cs
//   PasswordDialog.Designer.cs
//   ZipContentsDialog.cs
//   ZipContentsDialog.Designer.cs
//   FolderBrowserDialogEx.cs
//
// At design time, if you want to modify the way the GUI looks, you have to mark those modules
// to have a "compile" build action.  Then tweak em, test, etc.  Then again mark them as
// "Embedded resource".
//
//
// Author: Dinoch
// built on host: DINOCH-2
//
// ------------------------------------------------------------------
//
// Copyright (c) 2008 by Dino Chiesa
// All rights reserved!
//
//
// ------------------------------------------------------------------
// positional args
// GZip.cs
//
// ----------------------------------------------------------------------
// Copyright (c) 2011 Dino Chiesa.  All rights reserved.
//
// This example is released under the Microsoft Permissive License of
// October 2006.  See the license.txt file accompanying this release for
// full details.
//
// ----------------------------------------------------------------------
//
// This utility creates a compresses the file specified on the command line,
// using GZip, creating a new file, with the .gz suffix. Or, if the
// file specified on the command-line has a .gz suffix, this utility
// decompresses it, restoring the original file.
//
// compile with:
//     csc /debug+ /target:exe /r:Ionic.Zip.dll /out:GZip.exe GZip.cs
//
// Sat, 23 Jul 2011  22:32
//
//dotnetzip.codeplex.com for info.\n"+
//cleanupCompleted.WaitOne();
// prevent the process from exiting until cleanup is done:
// UnZip.cs
//
// ----------------------------------------------------------------------
// Copyright (c) 2006, 2007, 2008 Microsoft Corporation.  All rights reserved.
//
// This example is released under the Microsoft Public License .
// See the license.txt file accompanying this release for
// full details.
//
// ----------------------------------------------------------------------
//
// This command-line utility unzips a zipfile into the specified directory,
// or lists the entries in a zipfile without unzipping.
//
// compile with:
//     csc /target:exe /r:Ionic.Zip.dll /out:UnZip.exe UnZip.cs
//
// created
// Wed, 29 Mar 2006  14:36
//
// because the comments and filenames on zip entries may be UTF-8
//System.Console.OutputEncoding = new System.Text.UTF8Encoding();
//if (wantQuiet) Usage();
// positional args
// extract specified entries
// find the entry
// extract all, or list, or test
// The logic here does almost the same thing as the ExtractAll() method
// on the ZipFile class.  But in this case we *could* have control over
// it, for example only extract files of a certain type, or whose names
// matched a certain pattern, or whose lastmodified times fit a certain
// condition, or use a different password for each entry, etc.  We can
// also display status for each entry, as here.
// foreach
// else (extract all)
// end using(), the underlying file is closed.
// Extensions.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009 Dino Chiesa
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License. 
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// Form.DragDrop.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009 Dino Chiesa
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License. 
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// Form.State.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2011 Dino Chiesa
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
/// This app uses the windows registry to store config data for itself.
///     - creates a registry key for this DotNetZip Winforms app, if one does not exist
///     - stores and retrieves the most recent settings.
///     - this is done on a per user basis. (HKEY_CURRENT_USER)
// get the MRU list of selection expressions
// set the geometry of the form
// Starting a window minimized is confusing...
//this.WindowState = (FormWindowState)p[4];
// skip it
// the selection completion list
// store the size of the form
// RestoreBounds is the size of the window prior to last minimize action.
// But the form may have been resized since then!
// mmm....minimax
// A ListView that allows edit of subitems (items in columns beyond 0)
// From http://www.codeproject.com/KB/list/ListViewCellEditors.aspx .
// disable compile-time warning: "XXX is never is assigned and will always have its default value"
///	<summary>
///	Inherited ListView to allow in-place editing of subitems
///	</summary>
/// <summary>
/// MessageHeader for WM_NOTIFY
/// </summary>
// ListView messages
// Windows Messages that will abort editing
///	<summary>
///	Required designer variable.
///	</summary>
// This	call is	required by	the	Windows.Forms Form Designer.
///	<summary>
///	Clean up any resources being used.
///	</summary>
///	<summary>
///	Required method	for	Designer support - do not modify 
///	the	contents of	this method	with the code editor.
///	</summary>
/// <summary>
/// Is a double click required to start editing a cell?
/// </summary>
/// <summary>
/// Retrieve the order in which columns appear
/// </summary>
/// <returns>Current display order of column indices</returns>
// Something went wrong
/// <summary>
/// Find ListViewItem and SubItem Index at position (x,y)
/// </summary>
/// <param name="x">relative to ListView</param>
/// <param name="y">relative to ListView</param>
/// <param name="item">Item at position (x,y)</param>
/// <returns>SubItem index</returns>
/// <summary>
/// Get bounds for a SubItem
/// </summary>
/// <param name="Item">Target ListViewItem</param>
/// <param name="SubItem">Target SubItem index</param>
/// <returns>Bounds of SubItem (relative to ListView)</returns>
// Look	for	WM_VSCROLL,WM_HSCROLL or WM_SIZE messages.
// Look for WM_NOTIFY of events that might also change the
// editor's position/size: Column reordering or resizing
///<summary>
/// Fire SubItemClicked
///</summary>
///<param name="p">Point of click/doubleclick</param>
// The control performing the actual editing
// The LVI being edited
// The SubItem being edited
/// <summary>
/// Begin in-place editing of given cell
/// </summary>
/// <param name="c">Control used as cell editor</param>
/// <param name="Item">ListViewItem to edit</param>
/// <param name="SubItem">SubItem index to edit</param>
// Left edge of SubItem not visible - adjust rectangle position and width
// Right edge of SubItem not visible - adjust rectangle width
// Subitem bounds are relative to the location of the ListView!
// In case the editing control and the listview are on different parents,
// account for different origins
// Position and show editor
// cell editor losing focus
/// <summary>
/// Accept or discard current value of cell editor control
/// </summary>
/// <param name="AcceptChanges">Use the _editingControl's Text as new SubItem text or discard changes?</param>
// The item being edited
// The subitem index being edited
// Use editControl text if changes are accepted
// or the original subitem's text, if changes are discarded
// Cancel?
/// <summary>
/// Event Handler for SubItem events
/// </summary>
/// <summary>
/// Event Handler for SubItemEndEditing events
/// </summary>
/// <summary>
/// Event Args for SubItemClicked event
/// </summary>
/// <summary>
/// Event Args for SubItemEndEditingClicked event
/// </summary>
/// <summary>
/// The main entry point for the application.
/// </summary>
// ZipForm.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2011 Dino Chiesa
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// first run only
// help/about tab
// This constructor works to load zips from the command line.
// It also works to allow "open With..." from Windows Explorer.
// in ZipForm.DragDrop.cs
// set autocomplete on a few textboxes
// The listview2 is a ListViewEx control, an extension of
// System.Windows.Forms.ListView that allows editing of subitems using arbitrary
// controls.  You can have a textbox, a datepicker, or other controls.
// I want the user to be able to modify the directory-in-archive value in the
// list, which is why ListViewEx is interesting.
// I also want a checkbox associated to each list item, but I don't want the
// checkbox attached to the first subitem, as it normally is in a ListView. So I
// put an empty string as the main ListView item (subitem #0), and then the
// filename and directory-in-archive value in the 2nd and 3rd columns (subitems 1
// and 2).  This way, the checkbox gets its own column.
// Next twist is I want the checkbox label to be uneditable, which is easy
// by just installing a  listView2_BeforeLabelEdit method and always cancelling
// it. (e.CancelEdit = true).
// And then there is a "master checkbox" at the column header that indicates
// whether the state of all checkboxes in the list is the same. With the "check
// change" of any item in the list I want to see if the master should be checked
// or unchecked.
// The final thing is I want the checkbox for each item to change state only if I
// click on the checkbox itself, rather than "anywhere in the item row".
//this.comboSplit.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
// select the first item:
// select the first item:
// select the first item:
// also set the encoding usage
// select the first item:
// select the 2nd item, "Default":
// select the first item:
// select the first item:
// select DEFLATE:
// check for existence of the zip file:
// check for a valid zip file name:
//EncodingUsage = ZipOption.Always,
// just reset to "none"
//this.listView2.Items.ToList();
// I want the values in the combobox to be right-aligned.
//this.progressBar1.Invoke(new ProgressBarSetup(this.SetProgressBars), new object[] { count });
// will be set later, for each entry.
// use a different name in the archive if appropriate
// reset the progress bar for the entry:
// Sleep here just to show the progress bar, when the number of files is small,
// or when all done.
// You may not want this for actual use!
// more than 75 entries, don't sleep at all.
// reset
// downcast is safe here because we have shifted e.BytesTransferred
//NewStyle = false,
// Do not start zipping while editing a textbox
// in listView2.
// intelligently change the name of the thing to create
// It's an SFX, swap out ZIP and insert EXE
// enable/disable other dependent UI elements
// intelligently change the name of the thing to create
// It's a regular ZIP, so swap out EXE and insert ZIP
// enable/disable other dependent UI elements
//this.tbPassword.Enabled = (this.comboBox3.SelectedItem.ToString() != "None");
// DEFLATE
//tbPassword.Text = "";
// pop a dialog to ask where to extract
// Configure the "select folder" dialog box
//_folderName = tbDirName.Text;
//_folderName = (System.IO.Directory.Exists(_folderName)) ? _folderName : "";
//NewStyle = false,
// actually extract the files
// this set for Zipping
// this for Extract
// remember the successful selection strings
// escape ExtractWithPassword loop
// cancel all
// Retry here in the case of bad password.
// loop around, ask for password again
// done with this entry
// while
// else (encryption)
// foreach
// using
// ask for password in a loop until user enters a proper one,
// or clicks skip or cancel.
// cancel
// Recycle the progress bars the cancel button, and the status textbox.
// An alternative way to accomplish a similar thing is to visually place
// the progress bars OFF the tabs.
// swap the comboBox for Encoding to the selected panel
// swap the comboBox for Encoding to the selected panel
// prevent switching TABs if working
// Create an instance of the ColHeader class.
// Set the ascending property to sort in the opposite order.
// Get the number of items in the list.
// Turn off display while data is repoplulated.
// Populate an ArrayList with a SortWrapper of each list item.
// Clear the list, and repopulate with the sorted items.
// Turn display back on.
/// <summary>
///   Reads the contents of the stream into a byte array.
/// </summary>
/// <remarks>
///   <para>
///     Like File.ReadAllBytes(), but for a stream.
///   </para>
/// </remarks>
/// <param name="stream">The stream to read.</param>
/// <returns>A byte array containing the contents of the stream.</returns>
/// <exception cref="NotSupportedException">The stream does not support reading.</exception>
/// <exception cref="ObjectDisposedException">Methods were called after the stream was closed.</exception>
/// <exception cref="System.IO.IOException">An I/O error occurs.</exception>
// select the page that opens zip files.
//this.tabPage1.Select();
// Get the data.
// allow drop of one file on listView1, drop multiple files on listView2.
//A file is being dragged and it can be copied so provide feedback to the user.
// The data can only be dropped if it is a file list and it can be copied.
// Get the data.
// The data is an array of file paths.
// If it is a single file and ends in .zip, then we know how to open it
// and display the contents.
// If it is more than one file, then we don't know what to do with it.
// The data can only be dropped if it is a file list and it can be copied.
// Get the data.
// first subitem is the local filename  on disk
// next subitem is the directory name to use in the archive
//subitem.Text = String.IsNullOrEmpty(_lastDirectory) ? this.tbDirectoryInArchive.Text : _lastDirectory;
// additional subitem (to be added): new filename in archive, if any
//this.AcceptButton = null;
// Prevent editing the 0th column - it's the checkbox.  We want the checkbox
// label to remain "".
//this.textBox1.Focus(); // to get the RETURN key?  no. this did not work.
//this.AcceptButton = this.btnZipUp;
//this.listView2.Select();
// this.listView2.AutoResizeColumns(ColumnHeaderAutoResizeStyle.HeaderSize);
//this.listView2.EndEditing(true);
// do file selection, add each item into the list box
// first subitem is the filename
// second subitem is the directory name in the archive.
// third subitem is the filename in the archive, if ay
// remember the successful selection strings
//_disableMasterChecking = false;
// After removing all the checked items, all items  are now unchecked.
// We can set the mast checkbox to unchecked.  But, we have to protect
// against infinite recursion.
// prevent infinite recursion.
// if we have a mixed state, then it happened programmatically
// change state of ALL items
// prevent infinite recursion
// lvi is null when the checkchange comes from a non-mouse event, like when
// a new item is being added to the list.
// ix is 0 when the checkbox is the thing that was tickled with the mouse.
// Revert the checkChange if it was due to a mouse click on a subitem other than the 0th one.
// The Checked property has already been changed (in ListView.WndProc?); we need to undo it.
// In order to avoid an endless recursion, set the disable flag, first.
// check the state of all the items
// never let the use edit the label associated to the main listview item,
// the label on the item checkbox.
// The ColHeader class is a ColumnHeader object with an
// added property for determining an ascending or descending sort.
// True specifies an ascending order, false specifies a descending order.
// An instance of the SortWrapper class is created for
// each item and added to the ArrayList for sorting.
// A SortWrapper requires the item and the index of the clicked column.
// Text property for getting the text of an item.
// Implementation of the IComparer
// Constructor requires the sort order;
// true if ascending, otherwise descending.
// Implemnentation of the IComparer:Compare
// method for comparing two objects.
// Constructor requires the sort order;
// true if ascending, otherwise descending.
// Implementation of the IComparer:Compare
// method for comparing two objects.
// lop off one char for %
// usage:
//
//  hrt= new HiResTimer();
//  hrt.Start();
//     ... do work ...
//  hrt.Stop();
//  System.Console.WriteLine("elapsed time: {0:N4}", hrt.Seconds);
//
/// <summary>
/// Required designer variable.
/// </summary>
/// <summary>
/// Clean up any resources being used.
/// </summary>
/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
/// <summary>
/// Required method for Designer support - do not modify
/// the contents of this method with the code editor.
/// </summary>
//
// tbDirectoryToZip
//
//
// tbZipToCreate
//
//
// btnZipupDirBrowse
//
//
// btnZipUp
//
//
// btnCancel
//
//
// progressBar1
//
//
// progressBar2
//
//
// label1
//
//
// label2
//
//
// label3
//
//
// label4
//
//
// label5
//
//
// label6
//
//
// label7
//
//
// label8
//
//
// label9
//
//
// label22
//
//
// comboEncoding
//
//
// tbComment
//
//
// lblStatus
//
//
// comboCompLevel
//
//
// comboEncryption
//
//
// tbPassword
//
//
// chkHidePassword
//
//
// listView1
//
//
// btnOpenZip
//
//
// tabControl1
//
//
// tabPage1
//
//
// label20
//
//
// label19
//
//
// comboExistingFileAction
//
//
// tbSelectionToExtract
//
//
// label13
//
//
// chkOpenExplorer
//
//
// btnExtractDirBrowse
//
//
// tbExtractDir
//
//
// label11
//
//
// label10
//
//
// btnExtract
//
//
// btnReadZipBrowse
//
//
// tbZipToOpen
//
//
// tabPage2
//
//
// groupBox2
//
//
// label21
//
//
// comboEncodingUsage
//
//
// label18
//
//
// chkRemoveFiles
//
//
// label17
//
//
// comboSplit
//
//
// chkUnixTime
//
//
// chkWindowsTime
//
//
// label16
//
//
// tbExeOnUnpack
//
//
// label15
//
//
// tbDefaultExtractDirectory
//
//
// comboZip64
//
//
// comboCompMethod
//
//
// comboFlavor
//
//
// btnCreateZipBrowse
//
//
// groupBox1
//
//
// chkRecurse
//
//
// chkTraverseJunctions
//
//
// tbDirectoryInArchive
//
//
// button1
//
//
// label14
//
//
// tbSelectionToZip
//
//
// label12
//
//
// checkBox1
//
//
// btnClearItemsToZip
//
//
// textBox1
//
//
// listView2
//
//
// chCheckbox
//
//
// columnHeader1
//
//
// columnHeader2
//
//
// columnHeader3
//
//
// tabPage3
//
//
// richTextBox1
//
//
// pictureBox1
//
//
// ZipForm
//
//private System.Windows.Forms.ListViewEx listView2;
//this.listView2 = new System.Windows.Forms.ListView();
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.225
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
/// <summary>
///   A strongly-typed resource class, for looking up localized strings, etc.
/// </summary>
// This class was auto-generated by the StronglyTypedResourceBuilder
// class via a tool like ResGen or Visual Studio.
// To add or remove a member, edit your .ResX file then rerun ResGen
// with the /str option, or rebuild your VS project.
/// <summary>
///   Returns the cached ResourceManager instance used by this class.
/// </summary>
/// <summary>
///   Overrides the current thread's CurrentUICulture property for all
///   resource lookups using this strongly typed resource class.
/// </summary>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.225
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// ZipIt.cs
//
// ----------------------------------------------------------------------
// Copyright (c) 2006-2011 Dino Chiesa.  All rights reserved.
//
// This example is released under the Microsoft Permissive License of
// October 2006.  See the license.txt file accompanying this release for
// full details.
//
// ----------------------------------------------------------------------
//
// This utility zips up a set of files and directories specified on the command line.
//
// compile with:
//     csc /debug+ /target:exe /r:Ionic.Zip.dll /out:ZipIt.exe ZipIt.cs
//
// Fri, 23 Feb 2007  11:51
//
// Ask the user what he wants to do
//cleanupCompleted.WaitOne();
// prevent the process from exiting until cleanup is done:
// Because the comments and filenames on zip entries may be UTF-8
// System.Console.OutputEncoding = new System.Text.UTF8Encoding();
// read/update an existing zip, or create a new one.
// Console.WriteLine("spec({0})", args[i]);
// Console.WriteLine("dir({0})", directoryOnDisk);
// Console.WriteLine("dirInArc({0})", entryDirectoryPathInArchive);
// Console.WriteLine("recurse({0})", recurseDirectories);
//                                 if (entryComment != null)
//                                 {
//                                     e.Comment = entryComment;
//                                     entryComment = null;
//                                 }
// for the next entry
// UpdateItem will add Files or Dirs,
// recurses subdirectories
// newest
// oldest
//dotnetzip.codeplex.com/WorkItem/View.aspx?WorkItemId=7246");
// ZipFile.saveSelfExtractor.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2008-2011 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-August-10 19:22:46>
//
// ------------------------------------------------------------------
//
// This is a the source module that implements the stuff for saving to a
// self-extracting Zip archive.
//
// ZipFile is set up as a "partial class" - defined in multiple .cs source modules.
// This is one of the source modules for the ZipFile class.
//
// Here's the design: The self-extracting zip file is just a regular managed EXE
// file, with embedded resources.  The managed code logic instantiates a ZipFile, and
// then extracts each entry.  The embedded resources include the zip archive content,
// as well as the Zip library itself.  The latter is required so that self-extracting
// can work on any machine, whether or not it has the DotNetZip library installed on
// it.
//
// What we need to do is create the animal I just described, within a method on the
// ZipFile class.  This source module provides that capability. The method is
// SaveSelfExtractor().
//
// The way the method works: it uses the programmatic interface to the csc.exe
// compiler, Microsoft.CSharp.CSharpCodeProvider, to compile "boilerplate"
// extraction logic into a new assembly.  As part of that compile, we embed within
// that assembly the zip archive itself, as well as the Zip library.
//
// Therefore we need to first save to a temporary zip file, then produce the exe.
//
// There are a few twists.
//
// The Visual Studio Project structure is a little weird.  There are code files
// that ARE NOT compiled during a normal build of the VS Solution.  They are
// marked as embedded resources.  These are the various "boilerplate" modules that
// are used in the self-extractor. These modules are: WinFormsSelfExtractorStub.cs
// WinFormsSelfExtractorStub.Designer.cs CommandLineSelfExtractorStub.cs
// PasswordDialog.cs PasswordDialog.Designer.cs
//
// At design time, if you want to modify the way the GUI looks, you have to
// mark those modules to have a "compile" build action.  Then tweak em, test,
// etc.  Then again mark them as "Embedded resource".
//
// ------------------------------------------------------------------
/// <summary>
/// An enum that provides the different self-extractor flavors
/// </summary>
/// <summary>
/// A self-extracting zip archive that runs from the console or
/// command line.
/// </summary>
/// <summary>
/// A self-extracting zip archive that presents a graphical user
/// interface when it is executed.
/// </summary>
/// <summary>
/// The options for generating a self-extracting archive.
/// </summary>
/// <summary>
///   The type of SFX to create.
/// </summary>
/// <summary>
///   The command to run after extraction.
/// </summary>
///
/// <remarks>
/// <para>
///   This is optional. Leave it empty (<c>null</c> in C# or <c>Nothing</c> in
///   VB) to run no command after extraction.
/// </para>
///
/// <para>
///   If it is non-empty, the SFX will execute the command specified in this
///   string on the user's machine, and using the extract directory as the
///   working directory for the process, after unpacking the archive. The
///   program to execute can include a path, if you like. If you want to execute
///   a program that accepts arguments, specify the program name, followed by a
///   space, and then the arguments for the program, each separated by a space,
///   just as you would on a normal command line. Example: <c>program.exe arg1
///   arg2</c>.  The string prior to the first space will be taken as the
///   program name, and the string following the first space specifies the
///   arguments to the program.
/// </para>
///
/// <para>
///   If you want to execute a program that has a space in the name or path of
///   the file, surround the program name in double-quotes. The first character
///   of the command line should be a double-quote character, and there must be
///   a matching double-quote following the end of the program file name. Any
///   optional arguments to the program follow that, separated by
///   spaces. Example: <c>"c:\project files\program name.exe" arg1 arg2</c>.
/// </para>
///
/// <para>
///   If the flavor of the SFX is <c>SelfExtractorFlavor.ConsoleApplication</c>,
///   then the SFX starts a new process, using this string as the post-extract
///   command line.  The SFX waits for the process to exit.  The exit code of
///   the post-extract command line is returned as the exit code of the
///   command-line self-extractor exe. A non-zero exit code is typically used to
///   indicated a failure by the program. In the case of an SFX, a non-zero exit
///   code may indicate a failure during extraction, OR, it may indicate a
///   failure of the run-after-extract program if specified, OR, it may indicate
///   the run-after-extract program could not be fuond. There is no way to
///   distinguish these conditions from the calling shell, aside from parsing
///   the output of the SFX. If you have Quiet set to <c>true</c>, you may not
///   see error messages, if a problem occurs.
/// </para>
///
/// <para>
///   If the flavor of the SFX is
///   <c>SelfExtractorFlavor.WinFormsApplication</c>, then the SFX starts a new
///   process, using this string as the post-extract command line, and using the
///   extract directory as the working directory for the process. The SFX does
///   not wait for the command to complete, and does not check the exit code of
///   the program. If the run-after-extract program cannot be fuond, a message
///   box is displayed indicating that fact.
/// </para>
///
/// <para>
///   You can specify environment variables within this string, with a format like
///   <c>%NAME%</c>. The value of these variables will be expanded at the time
///   the SFX is run. Example: <c>%WINDIR%\system32\xcopy.exe</c> may expand at
///   runtime to <c>c:\Windows\System32\xcopy.exe</c>.
/// </para>
///
/// <para>
///   By combining this with the <c>RemoveUnpackedFilesAfterExecute</c>
///   flag, you can create an SFX that extracts itself, runs a file that
///   was extracted, then deletes all the files that were extracted. If
///   you want it to run "invisibly" then set <c>Flavor</c> to
///   <c>SelfExtractorFlavor.ConsoleApplication</c>, and set <c>Quiet</c>
///   to true.  The user running such an EXE will see a console window
///   appear, then disappear quickly.  You may also want to specify the
///   default extract location, with <c>DefaultExtractDirectory</c>.
/// </para>
///
/// <para>
///   If you set <c>Flavor</c> to
///   <c>SelfExtractorFlavor.WinFormsApplication</c>, and set <c>Quiet</c> to
///   true, then a GUI with progressbars is displayed, but it is
///   "non-interactive" - it accepts no input from the user.  Instead the SFX
///   just automatically unpacks and exits.
/// </para>
///
/// </remarks>
/// <summary>
///   The default extract directory the user will see when
///   running the self-extracting archive.
/// </summary>
///
/// <remarks>
/// <para>
///   Passing null (or Nothing in VB) here will cause the Self Extractor to use
///   the the user's personal directory (<see
///   cref="Environment.SpecialFolder.Personal"/>) for the default extract
///   location.
/// </para>
///
/// <para>
///   This is only a default location.  The actual extract location will be
///   settable on the command line when the SFX is executed.
/// </para>
///
/// <para>
///   You can specify environment variables within this string,
///   with <c>%NAME%</c>. The value of these variables will be
///   expanded at the time the SFX is run. Example:
///   <c>%USERPROFILE%\Documents\unpack</c> may expand at runtime to
///   <c>c:\users\melvin\Documents\unpack</c>.
/// </para>
/// </remarks>
/// <summary>
///   The name of an .ico file in the filesystem to use for the application icon
///   for the generated SFX.
/// </summary>
///
/// <remarks>
/// <para>
///   Normally, DotNetZip will embed an "zipped folder" icon into the generated
///   SFX.  If you prefer to use a different icon, you can specify it here. It
///   should be a .ico file.  This file is passed as the <c>/win32icon</c>
///   option to the csc.exe compiler when constructing the SFX file.
/// </para>
/// </remarks>
///
/// <summary>
///   Whether the ConsoleApplication SFX will be quiet during extraction.
/// </summary>
///
/// <remarks>
/// <para>
///   This option affects the way the generated SFX runs. By default it is
///   false.  When you set it to true,...
/// </para>
///
/// <list type="table">
///   <listheader>
///     <term>Flavor</term>
///     <description>Behavior</description>
///   </listheader>
///
/// <item>
///   <term><c>ConsoleApplication</c></term>
///   <description><para>no messages will be emitted during successful
///     operation.</para> <para> Double-clicking the SFX in Windows
///     Explorer or as an attachment in an email will cause a console
///     window to appear briefly, before it disappears. If you run the
///     ConsoleApplication SFX from the cmd.exe prompt, it runs as a
///     normal console app; by default, because it is quiet, it displays
///     no messages to the console.  If you pass the -v+ command line
///     argument to the Console SFX when you run it, you will get verbose
///     messages to the console. </para>
///   </description>
/// </item>
///
/// <item>
///   <term><c>WinFormsApplication</c></term>
///   <description>the SFX extracts automatically when the application
///        is launched, with no additional user input.
///   </description>
/// </item>
///
/// </list>
///
/// <para>
///   When you set it to false,...
/// </para>
///
/// <list type="table">
///   <listheader>
///     <term>Flavor</term>
///     <description>Behavior</description>
///   </listheader>
///
/// <item>
///   <term><c>ConsoleApplication</c></term>
///   <description><para>the extractor will emit a
///     message to the console for each entry extracted.</para>
///     <para>
///       When double-clicking to launch the SFX, the console window will
///       remain, and the SFX will emit a message for each file as it
///       extracts. The messages fly by quickly, they won't be easily
///       readable, unless the extracted files are fairly large.
///     </para>
///   </description>
/// </item>
///
/// <item>
///   <term><c>WinFormsApplication</c></term>
///   <description>the SFX presents a forms UI and allows the user to select
///     options before extracting.
///   </description>
/// </item>
///
/// </list>
///
/// </remarks>
/// <summary>
///   Specify what the self-extractor will do when extracting an entry
///   would overwrite an existing file.
/// </summary>
/// <remarks>
/// <para>
///   The default behavvior is to Throw.
/// </para>
/// </remarks>
/// <summary>
///   Whether to remove the files that have been unpacked, after executing the
///   PostExtractCommandLine.
/// </summary>
///
/// <remarks>
/// <para>
///   If true, and if there is a <see
///   cref="SelfExtractorSaveOptions.PostExtractCommandLine">
///   PostExtractCommandLine</see>, and if the command runs successfully,
///   then the files that the SFX unpacked will be removed, afterwards.  If
///   the command does not complete successfully (non-zero return code),
///   that is interpreted as a failure, and the extracted files will not be
///   removed.
/// </para>
///
/// <para>
///   Setting this flag, and setting <c>Flavor</c> to
///   <c>SelfExtractorFlavor.ConsoleApplication</c>, and setting <c>Quiet</c> to
///   true, results in an SFX that extracts itself, runs a file that was
///   extracted, then deletes all the files that were extracted, with no
///   intervention by the user.  You may also want to specify the default
///   extract location, with <c>DefaultExtractDirectory</c>.
/// </para>
///
/// </remarks>
/// <summary>
///   The file version number to embed into the generated EXE. It will show up, for
///   example, during a mouseover in Windows Explorer.
/// </summary>
///
/// <summary>
///   The product version to embed into the generated EXE. It will show up, for
///   example, during a mouseover in Windows Explorer.
/// </summary>
///
/// <remarks>
///   You can use any arbitrary string, but a human-readable version number is
///   recommended. For example "v1.2 alpha" or "v4.2 RC2".  If you specify nothing,
///   then there is no product version embedded into the EXE.
/// </remarks>
///
/// <summary>
///   The copyright notice, if any, to embed into the generated EXE.
/// </summary>
///
/// <remarks>
///   It will show up, for example, while viewing properties of the file in
///   Windows Explorer.  You can use any arbitrary string, but typically you
///   want something like "Copyright � Dino Chiesa 2011".
/// </remarks>
///
/// <summary>
///   The description to embed into the generated EXE.
/// </summary>
///
/// <remarks>
///   Use any arbitrary string.  This text will be displayed during a
///   mouseover in Windows Explorer.  If you specify nothing, then the string
///   "DotNetZip SFX Archive" is embedded into the EXE as the description.
/// </remarks>
///
/// <summary>
///   The product name to embed into the generated EXE.
/// </summary>
///
/// <remarks>
///   Use any arbitrary string. This text will be displayed
///   while viewing properties of the EXE file in
///   Windows Explorer.
/// </remarks>
///
/// <summary>
///   The title to display in the Window of a GUI SFX, while it extracts.
/// </summary>
///
/// <remarks>
///   <para>
///     By default the title show in the GUI window of a self-extractor
///     is "DotNetZip Self-extractor (http://DotNetZip.codeplex.com/)".
///     You can change that by setting this property before saving the SFX.
///   </para>
///
///   <para>
///     This property has an effect only when producing a Self-extractor
///     of flavor <c>SelfExtractorFlavor.WinFormsApplication</c>.
///   </para>
/// </remarks>
///
// workitem 12608
/// <summary>
///   Additional options for the csc.exe compiler, when producing the SFX
///   EXE.
/// </summary>
/// <exclude/>
/// <summary>
///   Version of the csc.exe compiler, if not specified then the default version
///   will be used.
/// </summary>
/// <exclude/>
// .Designer.cs?
//.Designer.cs"
//.Designer.cs"
//string _defaultExtractLocation;
//string _postExtractCmdLine;
//         string _SetDefaultLocationCode =
//         "namespace Ionic.Zip { public partial class WinFormsSelfExtractorStub { partial void _SetDefaultExtractLocation() {" +
//         " txtExtractDirectory.Text = \"@@VALUE\"; } }}";
/// <summary>
/// Saves the ZipFile instance to a self-extracting zip archive.
/// </summary>
///
/// <remarks>
///
/// <para>
/// The generated exe image will execute on any machine that has the .NET
/// Framework 4.0 installed on it.  The generated exe image is also a
/// valid ZIP file, readable with DotNetZip or another Zip library or tool
/// such as WinZip.
/// </para>
///
/// <para>
/// There are two "flavors" of self-extracting archive.  The
/// <c>WinFormsApplication</c> version will pop up a GUI and allow the
/// user to select a target directory into which to extract. There's also
/// a checkbox allowing the user to specify to overwrite existing files,
/// and another checkbox to allow the user to request that Explorer be
/// opened to see the extracted files after extraction.  The other flavor
/// is <c>ConsoleApplication</c>.  A self-extractor generated with that
/// flavor setting will run from the command line. It accepts command-line
/// options to set the overwrite behavior, and to specify the target
/// extraction directory.
/// </para>
///
/// <para>
/// There are a few temporary files created during the saving to a
/// self-extracting zip.  These files are created in the directory pointed
/// to by <see cref="ZipFile.TempFileFolder"/>, which defaults to <see
/// cref="System.IO.Path.GetTempPath"/>.  These temporary files are
/// removed upon successful completion of this method.
/// </para>
///
/// <para>
/// When a user runs the WinForms SFX, the user's personal directory (<see
/// cref="Environment.SpecialFolder.Personal">Environment.SpecialFolder.Personal</see>)
/// will be used as the default extract location.  If you want to set the
/// default extract location, you should use the other overload of
/// <c>SaveSelfExtractor()</c>/ The user who runs the SFX will have the
/// opportunity to change the extract directory before extracting. When
/// the user runs the Command-Line SFX, the user must explicitly specify
/// the directory to which to extract.  The .NET Framework 4.0 is required
/// on the computer when the self-extracting archive is run.
/// </para>
///
/// <para>
/// NB: This method is not available in the "Reduced" DotNetZip library.
/// </para>
///
/// </remarks>
///
/// <example>
/// <code>
/// string DirectoryPath = "c:\\Documents\\Project7";
/// using (ZipFile zip = new ZipFile())
/// {
///     zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath));
///     zip.Comment = "This will be embedded into a self-extracting console-based exe";
///     zip.SaveSelfExtractor("archive.exe", SelfExtractorFlavor.ConsoleApplication);
/// }
/// </code>
/// <code lang="VB">
/// Dim DirectoryPath As String = "c:\Documents\Project7"
/// Using zip As New ZipFile()
///     zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath))
///     zip.Comment = "This will be embedded into a self-extracting console-based exe"
///     zip.SaveSelfExtractor("archive.exe", SelfExtractorFlavor.ConsoleApplication)
/// End Using
/// </code>
/// </example>
///
/// <param name="exeToGenerate">
///   a pathname, possibly fully qualified, to be created. Typically it
///   will end in an .exe extension.</param>
/// <param name="flavor">
///   Indicates whether a Winforms or Console self-extractor is
///   desired. </param>
/// <summary>
///   Saves the ZipFile instance to a self-extracting zip archive, using
///   the specified save options.
/// </summary>
///
/// <remarks>
/// <para>
///   This method saves a self extracting archive, using the specified save
///   options. These options include the flavor of the SFX, the default extract
///   directory, the icon file, and so on.  See the documentation
///   for <see cref="SaveSelfExtractor(string , SelfExtractorFlavor)"/> for more
///   details.
/// </para>
///
/// <para>
///   The user who runs the SFX will have the opportunity to change the extract
///   directory before extracting. If at the time of extraction, the specified
///   directory does not exist, the SFX will create the directory before
///   extracting the files.
/// </para>
///
/// </remarks>
///
/// <example>
///   This example saves a WinForms-based self-extracting archive EXE that
///   will use c:\ExtractHere as the default extract location. The C# code
///   shows syntax for .NET 3.0, which uses an object initializer for
///   the SelfExtractorOptions object.
/// <code>
/// string DirectoryPath = "c:\\Documents\\Project7";
/// using (ZipFile zip = new ZipFile())
/// {
///     zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath));
///     zip.Comment = "This will be embedded into a self-extracting WinForms-based exe";
///     var options = new SelfExtractorOptions
///     {
///       Flavor = SelfExtractorFlavor.WinFormsApplication,
///       DefaultExtractDirectory = "%USERPROFILE%\\ExtractHere",
///       PostExtractCommandLine = ExeToRunAfterExtract,
///       SfxExeWindowTitle = "My Custom Window Title",
///       RemoveUnpackedFilesAfterExecute = true
///     };
///     zip.SaveSelfExtractor("archive.exe", options);
/// }
/// </code>
/// <code lang="VB">
/// Dim DirectoryPath As String = "c:\Documents\Project7"
/// Using zip As New ZipFile()
///     zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath))
///     zip.Comment = "This will be embedded into a self-extracting console-based exe"
///     Dim options As New SelfExtractorOptions()
///     options.Flavor = SelfExtractorFlavor.WinFormsApplication
///     options.DefaultExtractDirectory = "%USERPROFILE%\\ExtractHere"
///     options.PostExtractCommandLine = ExeToRunAfterExtract
///     options.SfxExeWindowTitle = "My Custom Window Title"
///     options.RemoveUnpackedFilesAfterExecute = True
///     zip.SaveSelfExtractor("archive.exe", options)
/// End Using
/// </code>
/// </example>
///
/// <param name="exeToGenerate">The name of the EXE to generate.</param>
/// <param name="options">provides the options for creating the
/// Self-extracting archive.</param>
// Save an SFX that is both an EXE and a ZIP.
// Check for the case where we are re-saving a zip archive
// that was originally instantiated with a stream.  In that case,
// the _name will be null. If so, we set _writestream to null,
// which insures that we'll cons up a new WriteStream (with a filesystem
// file backing it) in the Save() method.
// workitem 10553
// get the Ionic.Zip assembly
// sanity check; should never happen
// This is the list of referenced assemblies.  Ionic.Zip is
// needed here.  Also if it is the winforms (gui) extractor, we
// need other referenced assemblies, like
// System.Windows.Forms.dll, etc.
// Use this to concatenate all the source code resources into a
// single module.
// In case there are compiler errors later, we allocate a source
// file name now. If errors are detected, we'll spool the source
// code as well as the errors (in comments) into that filename,
// and throw an exception with the filename.  Makes it easier to
// diagnose.  This should be rare; most errors happen only
// during devlpmt of DotNetZip itself, but there are rare
// occasions when they occur in other cases.
// // debugging: enumerate the resources in this assembly
// Console.WriteLine("Resources in this assembly:");
// foreach (string rsrc in a2.GetManifestResourceNames())
//   {
//     Console.WriteLine(rsrc);
//   }
// Console.WriteLine();
// all the source code is embedded in the DLL as a zip file.
// // debugging: enumerate the files in the embedded zip
// Console.WriteLine("Entries in the embbedded zip:");
// foreach (ZipEntry entry in zip)
//   {
//     Console.WriteLine(entry.FileName);
//   }
// Console.WriteLine();
// Use the ico file that is embedded into the Ionic.Zip
// DLL itself.  To do this we must unpack the icon to
// the filesystem, in order to specify it on the cmdline
// of csc.exe.  This method will remove the unpacked
// file later.
// Must not extract a readonly file - it will be impossible to
// delete later.
// add the file into the target assembly as an embedded resource
// add the Ionic.Utils.Zip DLL as an embedded resource
// file header
// " + Path.GetFileName(sourceFile) + "\n")
// --------------------------------------------\n//\n")
// This SFX source file was generated by DotNetZip ")
//         at ")
//\n// --------------------------------------------\n\n\n");
// assembly attributes
// workitem
// Set the default extract location if it is available
// remove double-quotes and replace slash with double-slash.
// This, because the value is going to be embedded into a
// cs file as a quoted string, and it needs to be escaped.
// for debugging only
// first, the source we compiled
// now, append the compile errors
// ------------------------------------------------------------------\n");
// Errors during compilation: \n//\n");
//   {0}({1},{2}): {3} {4}: {5}\n//\n",
// 0
// 1
// 2
// 3
// 4
// 5
// Now, copy the resulting EXE image to the _writestream.
// Because this stub exe is being saved first, the effect will be to
// concatenate the exe and the zip data together.
// workitem 13475
// The candidate path does not exist as a file or directory.
// It can now be created, as a file or directory.
// CommandLineSelfExtractorStub.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2008-2011 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-June-18 20:58:45>
//
// ------------------------------------------------------------------
//
// This is a the source module that implements the stub of a
// command-line self-extracting Zip archive - the code included in all
// command-line SFX files.  This code is included as a resource into the
// DotNetZip DLL, and then is compiled at runtime when a SFX is saved.
//
// ------------------------------------------------------------------
// include the using statements inside the namespace declaration,
// because source code will be concatenated together before
// compilation.
// cannot include the following line, because of our use of
// the AssemblyResolver event.
//Ionic.Zip.ExtractExistingFileAction Overwrite;
// Attention: it isn't possible, with the design of this class as it is
// now, to have a member variable of a type from the Ionic.Zip assembly.
// The class design registers an assembly resolver, but apparently NOT in
// time to allow the assembly to be used in private instance variables.
// What is going on here?
// The PostUnpackCmdLine is initialized to a particular value, then
// we test to see if it begins with the first two chars of that value,
// and ends with the last part of the value.  Why?
// Here's the thing.  In order to insure the code is right, this module has
// to compile as it is, as a standalone module.  But then, inside
// DotNetZip, when generating an SFX, we do a text.Replace on the source
// code, potentially replacing @@POST_UNPACK_CMD_LINE with an actual value.
// The test here checks to see if it has been set.
// ctor
// ctor
//WantOverwrite = ExtractExistingFileAction.OverwriteSilently;
//WantOverwrite = ExtractExistingFileAction.DoNotOverwrite;
// cwd
// workitem 8988
// if the first char is NOT a double-quote, then just split the line
// the first char is double-quote.  Need to verify that there's another one.
// no double-quote - FAIL
// if the double-quote is the last char, then just return an array of ONE string
// no space following the double-quote - FAIL
// there's definitely another double quote, followed by a space
// go to next non-space char
// super defensive
// workitem 7978
//System.Diagnostics.Debugger.Break();
// There way this works:  the EXE is a ZIP file.  So
// read from the location of the assembly, in other words the path to the exe.
// workitem 7067
// potentially execute the embedded command
// workitem 8925
//DotNetZip.codeplex.com/");
// suppress
// Hide my own console window if there is no parent console
// (which means, it was launched rom explorer).
// If there was an error, and this is a new console, and
// we're still displaying the console, then do a
// ReadLine.  This gives the user a chance to read the
// window error messages before dismissing.
//Console.WriteLine("rc({0})  wantPause({1}) verbose({2})", rc, wantPause, me.Verbose);
// FolderBrowserDialogEx.cs
//
// A replacement for the builtin System.Windows.Forms.FolderBrowserDialog class.
// This one includes an edit box, and also displays the full path in the edit box. 
//
// based on code from http://support.microsoft.com/default.aspx?scid=kb;[LN];306285 
// 
// 20 Feb 2009
//
// ========================================================================================
// Example usage:
// 
// string _folderName = "c:\\dinoch";
// private void button1_Click(object sender, EventArgs e)
// {
//     _folderName = (System.IO.Directory.Exists(_folderName)) ? _folderName : "";
//     var dlg1 = new Ionic.Utils.FolderBrowserDialogEx
//     {
//         Description = "Select a folder for the extracted files:",
//         ShowNewFolderButton = true,
//         ShowEditBox = true,
//         //NewStyle = false,
//         SelectedPath = _folderName,
//         ShowFullPathInEditBox= false,
//     };
//     dlg1.RootFolder = System.Environment.SpecialFolder.MyComputer;
// 
//     var result = dlg1.ShowDialog();
// 
//     if (result == DialogResult.OK)
//     {
//         _folderName = dlg1.SelectedPath;
//         this.label1.Text = "The folder selected was: ";
//         this.label2.Text = _folderName;
//     }
// }
//
//[Designer("System.Windows.Forms.Design.FolderBrowserDialogDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"), DefaultEvent("HelpRequest"), SRDescription("DescriptionFolderBrowserDialog"), DefaultProperty("SelectedPath")]
// Fields
// Events
//[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
// ctor
// Factory Methods
// avoid MBRO comppiler warning when passing _rootFolderLocation as a ref:
// avoid MBRO comppiler warning when passing _rootFolderLocation as a ref:
// Helpers
// messages FROM the folder browser
// messages TO the folder browser
// get handle to the Edit box inside the Folder Browser Dialog
// we're browsing for a printer or computer, enable the OK button unconditionally.
// whether to enable the OK button or not. (if file is valid)
// Maybe set the Edit Box text to the Full Folder path
//_uiFlags = 0;
// Properties
//[SRDescription("FolderBrowserDialogDescription"), SRCategory("CatFolderBrowsing"), Browsable(true), DefaultValue(""), Localizable(true)]
/// <summary>
/// This description appears near the top of the dialog box, providing direction to the user.
/// </summary>
//[Localizable(false), SRCategory("CatFolderBrowsing"), SRDescription("FolderBrowserDialogRootFolder"), TypeConverter(typeof(SpecialFolderEnumConverter)), Browsable(true), DefaultValue(0)]
//[Browsable(true), SRDescription("FolderBrowserDialogSelectedPath"), SRCategory("CatFolderBrowsing"), DefaultValue(""), Editor("System.Windows.Forms.Design.SelectedPathEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(UITypeEditor)), Localizable(true)]
/// <summary>
/// Set or get the selected path.  
/// </summary>
//[SRDescription("FolderBrowserDialogShowNewFolderButton"), Localizable(false), Browsable(true), DefaultValue(true), SRCategory("CatFolderBrowsing")]
/// <summary>
/// Enable or disable the "New Folder" button in the browser dialog.
/// </summary>
/// <summary>
/// Show an "edit box" in the folder browser.
/// </summary>
/// <remarks>
/// The "edit box" normally shows the name of the selected folder.  
/// The user may also type a pathname directly into the edit box.  
/// </remarks>
/// <seealso cref="ShowFullPathInEditBox"/>
/// <summary>
/// Set whether to use the New Folder Browser dialog style.
/// </summary>
/// <remarks>
/// The new style is resizable and includes a "New Folder" button.
/// </remarks>
/// <summary>
/// Show the full path in the edit box as the user selects it. 
/// </summary>
/// <remarks>
/// This works only if ShowEditBox is also set to true. 
/// </remarks>
//public static extern IntPtr FindWindowEx(IntPtr hwndParent, IntPtr hwndChildAfter, string lpszClass, string lpszWindow);
//public static extern IntPtr FindWindowEx(HandleRef hwndParent, HandleRef hwndChildAfter, string lpszClass, string lpszWindow);
// Methods
// PasswordDialog.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009 Dino Chiesa
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License. 
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
/// <summary>
/// Required designer variable.
/// </summary>
/// <summary>
/// Clean up any resources being used.
/// </summary>
/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
/// <summary>
/// Required method for Designer support - do not modify
/// the contents of this method with the code editor.
/// </summary>
// 
// button1
// 
// 
// textBox1
// 
// 
// prompt
// 
// 
// btnCancel
// 
// 
// button2
// 
// 
// PasswordDialog
// 
// WinFormsSelfExtractorStub.cs
// ------------------------------------------------------------------
//
// Copyright (c)  2008, 2009 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-July-30 15:48:47>
//
// ------------------------------------------------------------------
//
// Implements the "stub" of a WinForms self-extracting Zip archive. This
// code is included in all GUI SFX files.  It is included as a resource
// into the DotNetZip DLL, and then is compiled at runtime when a SFX is
// saved.  This code runs when the SFX is run.
//
// ------------------------------------------------------------------
// The using statements must be inside the namespace scope, because when the SFX is being
// generated, this module gets concatenated with other source code and then compiled.
// ThreadPool, WaitCallback
// Design Note:
// What follows may look odd.  The textbox is set to a particular value.
// Then the value is tested, and if the value begins with the first part
// of the string and ends with the last part, and if it does, then we
// change the value.  When would that not get replaced?
//
// Well, here's the thing.  This module has to compile as it is, as a
// standalone sample.  But then, inside DotNetZip, when generating an SFX,
// we do a text.Replace on @@EXTRACTLOCATION and insert a different value.
// So the effect is, with a straight compile, the value gets
// SpecialFolder.Personal.  If you replace @@EXTRACTLOCATION with
// something else, it stays and does not get replaced.
// workitem 8893
// See the design note in _SetDefaultExtractLocation() for
// an explanation of what is going on here.
// If there is nothing set for the CMD to execute after unpack, then
// disable all the UI associated to that bit.
// workitem 8925
// adjust the position of all the remaining UI
//MoveDown(this.chk_Overwrite, delta);
// finally, adjust the size of the form
// Add the size to the txtComment, because it is anchored to the bottom.
// When we shrink the size of the form, the txtComment shrinks also.
// No need for that.
// workitem 8925
// there is a comment line.  Do we also want to remove files after executing it?
// why would this ever fail?  Not sure.
// This is important to resolve the Ionic.Zip.dll inside the extractor.
// super defensive
// workitem 7978
// adjust the position of all the remaining UI
// finally, adjust the size of the form
// workitem 8925
//dlg1.NewStyle = false;
//dlg1.RootFolder = System.Environment.SpecialFolder.MyComputer;
// Show the FolderBrowserDialog.
// disable most of the UI:
// workitem 8925
//System.Threading.Thread _workerThread = new System.Threading.Thread(this.DoExtract);
//_workerThread.Name = "Zip Extractor thread";
//_workerThread.Start(null);
// zip has already been set, when opening the exe.
// The file exists, but the user did not ask for overwrite.
// escape ExtractWithPassword loop
// cancel all
// Retry here in the case of bad password.
// loop around, ask for password again
// The file exists, but the user did not ask for overwrite.
// catch
// while
// else (encryption)
// foreach
// optionally provide a status report
// optionally open explorer
// optionally execute a command
// else, nothing.
// quit if this is non-interactive
// workitem 8925
// workitem 8925
// Process is IDisposable
// reset the progress bar for the entry:
// reset
// will be set later, for each entry.
// workitem 7067
// ask for password in a loop until user enters a proper one,
// or clicks skip or cancel.
// cancel
// workitem 6413
// workitem 8988
// if the first char is NOT a double-quote, then just split the line
// the first char is double-quote.  Need to verify that there's another one.
// no double-quote - FAIL
// if the double-quote is the last char, then just return an array of ONE string
// no space following the double-quote - FAIL
// there's definitely another double quote, followed by a space
// go to next non-space char
/// <summary>
/// Required designer variable.
/// </summary>
/// <summary>
/// Clean up any resources being used.
/// </summary>
/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
//
// label1
//
//
// tbMessage
//
//
// btnOK
//
//
// UnzipStatusReport
//
/// <summary>
/// The main entry point for the application.
/// </summary>
// For Debugging
//                 if ( !AttachConsole(-1) )  // Attach to a parent process console
//                     AllocConsole(); // Alloc a new console
/// <summary>
/// Required designer variable.
/// </summary>
/// <summary>
/// Clean up any resources being used.
/// </summary>
/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
/// <summary>
/// Required method for Designer support - do not modify
/// the contents of this method with the code editor.
/// </summary>
//
// btnExtract
//
//
// btnCancel
//
//
// txtExtractDirectory
//
//
// lblExtractDir
//
//
// btnDirBrowse
//
//
// chk_OpenExplorer
//
//
// chk_ExeAfterUnpack
//
//
// txtPostUnpackCmdLine
//
//
// chk_Remove
//
//
// lblComment
//
//
// txtComment
//
//
// btnContents
//
//
// progressBar1
//
//
// progressBar2
//
//
// lblStatus
//
//
// comboExistingFileAction
//
//
// label1
//
//
// WinFormsSelfExtractorStub
//
// ZipContentsDialog.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009 Dino Chiesa
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License. 
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// adjust size of the entire form
// plus a fudge factor
//aggWidth += this.listView1.Columns[this.listView1.Columns.Count - 1].Width / 2 + this.listView1.Location.X * 4;
// Create an instance of the ColHeader class.
// Set the ascending property to sort in the opposite order.
// Get the number of items in the list.
// Turn off display while data is repoplulated.
// Populate an ArrayList with a SortWrapper of each list item.
// Clear the list, and repopulate with the sorted items.
// Turn display back on.
// The ColHeader class is a ColumnHeader object with an
// added property for determining an ascending or descending sort.
// True specifies an ascending order, false specifies a descending order.
// An instance of the SortWrapper class is created for
// each item and added to the ArrayList for sorting.
// A SortWrapper requires the item and the index of the clicked column.
// Text property for getting the text of an item.
// Implementation of the IComparer
// Constructor requires the sort order;
// true if ascending, otherwise descending.
// Implemnentation of the IComparer:Compare
// method for comparing two objects.
// Constructor requires the sort order;
// true if ascending, otherwise descending.
// Implemnentation of the IComparer:Compare
// method for comparing two objects.
/// <summary>
/// Required designer variable.
/// </summary>
/// <summary>
/// Clean up any resources being used.
/// </summary>
/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
/// <summary>
/// Required method for Designer support - do not modify
/// the contents of this method with the code editor.
/// </summary>
// 
// listView1
// 
// 
// button1
// 
// 
// ZipContentsDialog
// 
// BasicTests.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2011 Dino Chiesa
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-July-26 11:39:21>
//
// ------------------------------------------------------------------
//
// This module defines basic unit tests for DotNetZip.
//
// ------------------------------------------------------------------
/// <summary>
/// Summary description for UnitTest1
/// </summary>
// select the name of the zip file
// create a bunch of files
// Create the zip archive
//zip.StatusMessageTextWriter = System.Console.Out;
// Verify the number of files in the zip
// Create the zip archive
// Verify the number of files in the zip
// now, verify that we have not downcased the filenames
// select the name of the zip file
// Create the zip archive
// add n files
// select files at random
// Verify the number of files in the zip
// add progressively more files to the fodder directory
// select the name of the zip file
// select the name of the zip file
// Create the zip archive
// Verify the number of files in the zip
// select the name of the zip file
// create a bunch of files
// Create the zip archive
// Verify the number of files in the zip
// select the name of the zip file
// Create the zip archive
// Verify the number of files in the zip
// extract to a stream
// use the parameterized ctor
// Verify the number of files in the zip
// select the name of the zip file
// workitem 7685
// Verify the number of files in the zip
//zip.StatusMessageTextWriter = System.Console.Out;
// Verify the number of files in the zip
// Verify the number of files in the zip
// extract to a stream
// check if stream is kept open after extracting the file
//int subdirCount = _rnd.Next(3) + 2;
//int filecount = _rnd.Next(2) + 2;
// add all the subdirectories into a new zip
// validate all the checksums
// if it is a file....
// verify the checksum of the file is correct
// now, update some of the existing files
//var t1 = Path.GetFileName(dirToZip);
// add some new content
//String[] dirs = Directory.GetDirectories(dirToZip);
//foreach (String d in dirs)
//{
//    string dir = Path.Combine(Path.GetFileName(dirToZip), Path.GetFileName(d));
//    //string root = Path.Combine("zipthis", Path.GetFileName(d));
//    zip3.UpdateDirectory(dir, "zipthis");
//}
// validate all the checksums again
// verify the checksum of the file is correct
// one empty file
// a few files per subdir
//TestContext.WriteLine("");
// verify that the entries in the zip are in the top level directory!!
//Assert.IsFalse(e.FileName.StartsWith("dir"),
//       String.Format("The Zip entry '{0}' is not rooted in top level directory.", e.FileName));
// check the filename:
//RE.Match m0 = RE.Regex.Match(e.FileName, fnameRegex[k]);
// Assert.IsTrue(m0 != null, "No match");
// Assert.AreEqual<int>(m0.Groups.Count, 2,
//    String.Format("In cycle {0}, Matching {1} against {2}, Wrong number of matches ({3})",
//        k, e.FileName, fnameRegex[k], m0.Groups.Count));
// Each trial provides a directory name into which to add
// files, and a regex, used for verification after the zip
// is created, to match the names on any added entries.
// sometimes zero
// verify that the entries in the zip are in the top level directory!!
// from small numbers of files to larger numbers of files
// Verify the files are in the zip
// from small numbers of files to larger numbers of files
// Verify the files are in the zip
// verify the isText setting
//string dirToZip = Path.GetFileName(TopLevelDir);
// seek to the beginning
// create the files
// now extract the files and verify their contents
// verify the content of the updated file.
// create the files
// Create the zip file
// Verify the files are in the zip
// now extract the files into memory streams, checking only the length of the file.
// select the name of the zip file
// create the subdirectory
// create the files
// Create the zip file
// Verify the files are in the zip
// now extract the files into memory streams, checking only the length of the file.
// We do 4 combinations:  case-sensitive on or off, and filename conversion on or off.
//zip.StatusMessageTextWriter = System.Console.Out;
// use the local filename (not fully qualified)
//make last comment exceed comment limit -> comment should get truncated
//don't check lorem ipsum comment
//int fileCount = _rnd.Next(13) + 23;
// try Kind = unspecified, local, and UTC
// use the local filename (not fully qualified)
// NB: comparing two DateTime variables will return "not
// equal" if they are not of the same "Kind", even if they
// represent the same point in time.  To counteract that,
// we compare using UniversalTime.
// now verify that the LastMod time on the filesystem file is set correctly
//Assert.AreEqual<DateTime>(t, ActualFilesystemLastMod,
//int fileCount = _rnd.Next(13) + 23;
// use the local filename (not fully qualified)
// now verify that the attributes are set
// correctly in the filesystem
// Here, we build a list of combinations of FileAttributes
// to try.  We cannot simply do an exhaustive combination
// because (a) not all combinations are valid, and (b) if
// you SetAttributes(file,Compressed) (also with Encrypted,
// ReparsePoint) it does not "work."  So those attributes
// must be excluded.
// use the local filename (not fully qualified)
// now verify that the attributes are set correctly in the filesystem
// timeout in ms.  240s = 4 mins
//maxFiles = Math.Min(maxFiles, 15);
// There WERE some weird files on my system that cause this
// test to fail!  the GetLastWrite() method returns the
// "wrong" time - does not agree with what is shown in
// Explorer or in a cmd.exe dir output.  So I exclude those
// files here.  (This is no longer a problem?)
//|| filename.EndsWith(".cer")
//|| filename.EndsWith(".msrcincident")
//|| filename == "MSCERTS.ini"
// surround this in a try...catch so as to avoid grabbing a file that is open by someone else, or has disappeared
// Rounding to nearest even second was necessary when DotNetZip did
// not process NTFS times in the NTFS Extra field. Since v1.8.0.5,
// this is no longer the case.
//
// var tm = TestUtilities.RoundToEvenSecond(lastWrite);
// hop out of the try block if the file is from TODAY.  (heuristic
// to avoid currently open files)
// create the zip file
// unpack the zip, and verify contents
// verify that the LastMod time on the filesystem file is set correctly
// get the delta as an absolute value:
// The time delta can be at most, 1 second.
// verify the checksum of the file is correct
// If I read a time from a file with GetLastWriteTime() (etc), I need
// to adjust it for display in the .NET environment.
// set the name of the zip file to create
//var key = Path.Combine("A", filename);
// validate all the checksums
// verify the checksum of the file is correct
// create an empty file
// Variance.Level
//return TestUtilities.GenerateRandomAsciiString(9);
//return "Alphabet";
// Create a zip file, then re-save it with changes in compression methods,
// compression levels, and/or encryption.  The methods/levels, cryptos are
// for original and re-saved values. This tests whether we can update a zip
// entry with changes in those properties.
//TestContext.WriteLine("  crypto: '{0}'  '{1}'", crypto[0]??"-NONE-", passwords[1]??"-NONE-");
// first, create a zip file
// check that the zip was constructed as expected
// modify some properties (CompressionLevel, CompressionMethod, and/or Encryption) on each entry
// Check that the zip was modified as expected
// now extract the items and verify checksums
// extract
// Check that re-saving a zip, after modifying properties on
// each entry, actually does what we want.
// Compatibility.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2011 Dino Chiesa .
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-August-05 18:32:33>
//
// ------------------------------------------------------------------
//
// This module defines the tests for compatibility for DotNetZip.  The
// idea is to verify that DotNetZip can read the zip files produced by
// other tools, and that other tools can read the output produced
// by DotNetZip. The tools and libraries tested are:
//  - WinZip
//  - 7zip
//  - Infozip (unzip 6.0, zip 3.0)
//  - Perl's IO::Compress
//  - zipfldr.dll (via script)
//  - the Visual Studio DLL
//  - MS-Word
//
// ------------------------------------------------------------------
/// <summary>
/// Summary description for Compatibility
/// </summary>
// get the path to the DotNetZip DLL
// register it for COM interop
// unregister the DLL for COM interop
// check existence of script and script engine
// check times
// In some cases - specifically when the file lastmod time
// is on the other side of a DST event - extracting with the
// shell gets a time on the extracted file that is 1 hour
// off the expected value. This doesn't happen when WinZip
// or DotNetZip is used for extraction - only when using the
// shell extension.  In those cases we can allow for the
// extra hour.
// 1 hour
// 1 second for unix
// default 0.01s  for NTFS
// 2 seconds for DOS times
// try to read a bogus zip archive
//Directory.SetCurrentDirectory(TopLevelDir);
// get a set of files to zip up
// create and fill the directories
// Create the zip archive
//Directory.SetCurrentDirectory(TopLevelDir);
//zip.StatusMessageTextWriter = System.Console.Out;
// Verify the number of files in the zip
// run the unzip script
// check the files in the extract dir
// verify the file times
// get a set of files to zip up
// create and fill the directories
// Create the zip archive
//Directory.SetCurrentDirectory(TopLevelDir);
// Want to test the library when saving to non-seekable output streams.  Like
// stdout or ASPNET's Response.OutputStream.  This simulates it.
// Verify the number of files in the zip
// run the unzip script
// check the files in the extract dir
// 2s threshold for DOS times
// get a set of files to zip up
// create and fill the directories
// Create the zip archive
//zip.StatusMessageTextWriter = System.Console.Out;
// Verify the number of files in the zip
// run the unzip script
// check the files in the extract dir
// verify the file times
// create and fill the directories
// Create the zip archive
// Verify the number of files in the zip
// run the unzip script
// check the files in the extract dir
// !!
// I think the file times get messed up using the Shell to unzip.
// !!
// verify the file times
// create and fill the directories
// Create the zip archive
//zip1.StatusMessageTextWriter = Console.Out;
// Verify the number of files in the zip
// run the unzip script
// check the files in the extract dir
//Directory.SetCurrentDirectory(TopLevelDir);
// Create the zip archive via script
// Verify the number of files in the zip
// unzip
// check the files in the extract dir
// remove those with spaces in the names.  The ShellApp (zipfldr.dll) doesn't
// deal with these files very well.  Or something.
// Create the zip archive via script
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// DEBUGGING!
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Verify the number of files in the zip
// unzip
// check the files in the extract dir
//Directory.SetCurrentDirectory(TopLevelDir);
// Verify the number of files in the zip
// unzip
// check the files in the extract dir
// visual Studio's ZIP library doesn't bother with times...
//VerifyNtfsTimes(extractDir, filesToZip);
// timeout in ms.
// Create the zip archive
//Directory.SetCurrentDirectory(TopLevelDir);
// Verify the number of files in the zip
// unzip
// check the files in the extract dir
// visual Studio's ZIP library doesn't bother with times...
//VerifyNtfsTimes(Path.Combine(extractDir, "files"), filesToZip);
// run the COM script to create the ZIP archive
// Verify the number of files in the zip
// unzip
//Directory.SetCurrentDirectory(TopLevelDir);
// check the files in the extract dir
// construct the directories
//string ExtractDir = Path.Combine(TopLevelDir, "extract");
// Create the zip archive
//Directory.SetCurrentDirectory(TopLevelDir);
// Verify the number of files in the zip
// run the COM script to unzip the ZIP archive
// check the files in the extract dir
// create and fill the directories
// Create the zip archive
//Directory.SetCurrentDirectory(TopLevelDir);
// Verify the number of files in the zip
// run the COM script to check the ZIP archive
// create and fill the directories
// Create the zip archive
//Directory.SetCurrentDirectory(TopLevelDir);
// Verify the number of files in the zip
// run the COM script to check and test-extract the ZIP archive
//Directory.SetCurrentDirectory(TopLevelDir);
// run the COM script to check the (not) ZIP archive
// create and fill the directories
// first case - all entries have same password - should pass the check.
// second case - last entry uses a different password - should fail the check.
// Create the zip archive
//zip1.Password = password;
// Verify the number of files in the zip
// not good for passwords used on the command line with cmd line tools!!
// return TestUtilities.GenerateRandomPassword();
//return "Alphabet";
// crypto.Length
// Cannot do WinZipAES encryption - not supported by InfoZip
// Create the zip archive
// create and fill the directories
// infozip usage:
// zip.exe zipfile.zip -r <directory>
// zip.exe zipfile.zip  <list of files>
// Create the zip archive via Infozip.exe
// zip.exe zipfile.zip -r <directory>
// zip.exe zipfile.zip  <list of files>
// delay a bit between file creation and check/unzip
// Verify the number of files in the zip
// run the COM script to unzip the ZIP archive
// check the files in the extract dir
// create and fill the directories
// infozip usage:
// zip.exe zipfile.zip -r -P <password>  <directory>
// Create the zip archive via Infozip.exe
// delay a bit between file creation and check/unzip
// Verify the number of files in the zip
// extract
// check the files in the extract dir
// in kb
// Create the zip archive via Infozip.exe
// warning [256k/256k.zip]: zipfile claims to be last disk of a
// multi-part archive; attempting to process anyway, assuming
// all parts have been concatenated together in order.  Expect
// "errors" and warnings...true multi-part support doesn't exist
// yet (coming soon).
// in kb
//Directory.SetCurrentDirectory(TopLevelDir);
// Create the zip archive via DotNetZip
// extract using InfoZip
//Directory.SetCurrentDirectory(TopLevelDir);
// Create the zip archive via DotNetZip
// extract using InfoZip
// pass 1 for one regular zero length file.
// pass 2 for zero-length file with WinZip encryption (which does not actually
// get applied)
// pass 3 for PKZip encryption (ditto)
// create an empty file
// Create the zip archive
// Verify the number of files in the zip
// now, extract the zip. Possibly need a password.
// eg, unzip.exe -P <passwd> test.zip  -d  <extractdir>
// create a zip with perl:
// create and fill the directories
// Create the zip archive via 7z.exe
// Verify the number of files in the zip
// run the COM script to unzip the ZIP archive
// check the files in the extract dir
// create and fill the directories
// Create the zip archive via 7z.exe
//Directory.SetCurrentDirectory(TopLevelDir);
// Verify the number of files in the zip
// unzip
//Directory.SetCurrentDirectory(TopLevelDir);
// check the files in the extract dir
// create and fill the directories
// Create the zip archive with DotNetZip
//Directory.SetCurrentDirectory(TopLevelDir);
// Verify the number of files in the zip
// unpack the zip archive via 7z.exe
// check the files in the extract dir
// Create the zip archive with DotNetZip
//Directory.SetCurrentDirectory(TopLevelDir);
// Verify the number of files in the zip
// unpack the zip archive via 7z.exe
// check the files in the extract dir
//CreateFilesAndChecksums(subdir, 2, 32, out filesToZip, out checksums);
// debugging
// marker file
// using (File.Create(Path.Combine(TopLevelDir, "DotNetZip-" + ZipFile.LibraryVersion.ToString()))) ;
//string password = "0123456789ABCDEF";
// Create the zip archive with DotNetZip
//Directory.SetCurrentDirectory(TopLevelDir);
// Want to test the library when saving to non-seekable output streams.  Like
// stdout or ASPNET's Response.OutputStream.  This simulates it.
// Verify the number of files in the zip
// unpack the zip archive via 7z.exe
// check the files in the extract dir
//Directory.SetCurrentDirectory(TopLevelDir);
// create and fill the directories
// Create the zip archive with DotNetZip
//Directory.SetCurrentDirectory(TopLevelDir);
// Verify the number of files in the zip
// unpack the zip archive via 7z.exe
// check the files in the extract dir
// unzip with DotNetZip
//Directory.SetCurrentDirectory(TopLevelDir);
// Unsupported compression method
// Unsupported compression method
// Unsupported compression method
// Unsupported compression method
// options:
// -sPassword
// -ep - PPMd compression.
// -el - LZMA compression
// -eb - bzip2 compression
// -ee - "enhanced" compression.
// -en - normal compression.
// -ef - fast compression.
// -es - superfast compression.
// -ez - select best method at runtime. Requires WinZip12 to extract.
// empty string = default
// delay between file creation and zip creation
// exec wzzip.exe to create the zip file
// unzip with DotNetZip
// check the files in the extract dir
// verify the file times.
// in ms, 60 * 1000 = 1min
// create and fill the directories
//string subdir = "files";
// Create the zip archive
// Verify the number of files in the zip
// now, extract the zip
// eg, wzunzip.exe -d test.zip  <extractdir>
// check the files in the extract dir
// verify the file times
// pass 1 for one regular zero length file.
// pass 2 for zero-length file with WinZip encryption (which does not actually
// get applied)
// pass 3 for PKZip encryption (ditto)
// create an empty file
// Create the zip archive
// Verify the number of files in the zip
// now, test the zip. Possibly need a password.
// eg, wzunzip.exe -t test.zip  <extractdir>
//Directory.SetCurrentDirectory(TopLevelDir);
// create a bunch of files
// Create the zip archive
// Verify the number of files in the zip
// now, test the zip
// eg, wzunzip.exe -t test.zip  <extractdir>
// extract the zip
// eg, wzunzip.exe -d -yx -sPassword  test.zip  <extractdir>
// create a bunch of files
// Want to test the library when saving to non-seekable
// output streams.  Like stdout or ASPNET's
// Response.OutputStream.  This simulates it.
// Create the zip archive
// Verify the number of files in the zip
// now, test the zip
// eg, wzunzip.exe -t test.zip
// extract the zip
// eg, wzunzip.exe -d -yx -sPassword  test.zip  <extractdir>
// check the files in the extract dir
// create and fill the directories
// Create the zip archive
// Verify the number of files in the zip
// now, extract the zip
// eg, wzunzip.exe -d test.zip  [<extractdir>]
// -d = restore folder structure
// -yx = restore extended timestamps to extracted files
// check the files in the extract dir
// verify the file times
// Now, Create the zip archive with DotNetZip
// Verify the number of files in the zip
// verify that the output states that the compression method
// used for each entry was BZIP2...
// examine and unpack the zip archive via WinZip
// first, examine the zip entry metadata:
// Not all of the files will be bzipped. Some of the files
// may be "stored" because they are incompressible. This
// should be the exception, though.
// now, extract the zip
// eg, wzunzip.exe -d test.zip  <extractdir>
// check the files in the extract dir
// BZip2 uses work buffers of 900k (ish). When compressing files that
// can be Run-length-encoded into a buffer smaller than 900k, only one
// "block" is used in the compressed output. Multiple blocks get
// emitted with input files that cannot be run-length encoded into
// 900k (ish). This test verifies that everything works correctly when
// compressing larger files that require multiple blocks in the
// compressed output. (At one point there was a problem combining CRCs
// from multiple blocks.)
// Now, Create the zip archive with DotNetZip
// Verify the number of files in the zip
// examine and unpack the zip archive via WinZip
// first, examine the zip entry metadata:
// verify that the output states that the compression method
// used for each entry was BZIP2...
// now, extract the zip
// eg, wzunzip.exe -d test.zip  <extractdir>
// set R and S attributes on the first file
// set H attribute on the second file
// Now, Create the zip archive with DotNetZip
// Verify the number of files in the zip
// examine and unpack the zip archive via WinZip
// first, examine the zip entry metadata:
// example: Filename: folder5\Test8.txt
// now, extract the zip
// eg, wzunzip.exe -d test.zip  <extractdir>
// check the files in the extract dir
// verify the file times
// C:\Users\dinoch\AppData\Local\Temp
// randomly select a candidate
// too large
// too small
// If it's on the other side of DST,
//   or
// there are zero or one on *this side*
//   or
// we can still reach the "other side" quota.
/* gulp! */ }
// ErrorTests.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2011 Dino Chiesa .
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-July-28 12:58:36>
//
// ------------------------------------------------------------------
//
// This module defines some "error tests" - tests that the expected
// errors or exceptions occur in DotNetZip under exceptional conditions.
// These conditions include corrupted zip files, bad input, and so on.
//
// ------------------------------------------------------------------
//using Ionic.Zip;
/// <summary>
/// Summary description for ErrorTests
/// </summary>
// randomly choose whether to overwrite or not
// Extract twice: the first time should succeed.
// The second, should fail, because of a failed file overwrite.
// Unless flavor==3, in which case we overwrite silently.
// not an error test
// not an error test
// this is a test of the test!
// try reading the invalid zipfile - this must fail.
// try reading an empty, extant file as a zip file
// the list of filenames to add to the zip
// mixing ZipEntry.Extract and ZipInputStream is a no-no!!
// Use ZipEntry.Extract with ZipInputStream.
// This must fail.
// mixing OpenReader and ZipInputStream is a no-no!!
// Use OpenReader with ZipInputStream.
// This must fail.
// Add an entry to the zipfile, then try saving to a directory.
// This must fail.
// fail
// create the subdirectory
// create the files
// add an entry to the zipfile, then try saving, never having specified a filename. This should fail.
// FAIL: don't know where to save!
// should never reach this
// add a directory to the zipfile, then try
// extracting, without a Save. This should fail.
// FAIL: has not been saved
// should never reach this
// add a directory to the zipfile, then try
// extracting, without a Save. This should fail.
// FAIL: has not been saved
// should never reach this
// FAIL
// should fail
// now corrupt the zip archive
// not sure which exception - could be one of several.
// the list of filenames to add to the zip
// passwords to use for those entries
// create the zipfile, adding the files
// read the corrupted zip - this should fail in some way
// not sure which exception - could be one of several.
// the list of filenames to add to the zip
// create the zipfile, adding the files
// now corrupt the zip archive
// read the corrupted zip - this should fail in some way
// lock the file
// should trigger a read error,
// which should be skipped. Result will be
// a zero-entry zip file.
// select the name of the zip file
// create the subdirectory
// create a bunch of files
// Create the zip archive
// this should fail - adding the same file twice
// verify the correct exception is being thrown
// create a zip file with no entries
// open and lock
// ExtendedTests.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2008-2011 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-August-06 17:04:31>
//
// ------------------------------------------------------------------
//
// This module defines some extended tests for DotNetZip.  It gets into
// advanced features - file selection, encryption, and more.
//
// ------------------------------------------------------------------
/// <summary>
/// Summary description for ExtendedTests
/// </summary>
// UTF-8 is the default, but I want to be explicit here.
// Verify that the parallel compress option works properly
// with BZip2.
// Get the unzip.exe tool:
// two passes: once for regular, once for parallel compress
// Now, Create the zip archive with DotNetZip
// Verify the number of files in the zip
// examine and unpack the zip archive via DNZ tools.
// Get info on the zip file:
// Verify that the output states that the compression method
// used for each entry was BZIP2...
// Extract the zip.  eg, unzip.exe test.zip -d  <extractdir>
// Verify the count of extracted files
// verify the time required for parallel compression is lower.
// Verify the files are in the zip
// Verify the files are in the zip
// must retrieve with a trailing slash.
// read the zip and retrieve the dir entries again
// now specify dir names with backslash
// select a single file from the list
// insert the selected file into the zip, and also rename it
// conditionally save
// remove the original file
// select another file from the list, making sure it is not the same file
// insert that other file and rename it
// add entries to a zipfile.
// use a password.(possibly null)
// update an entry in the zipfile.  For this pass, don't use a password.
// add entries to a zipfile.
// use a password.(possibly null)
// add each string using the given encoding
// Verify the number of files in the zip
//zip2[entryName].Password = Passwords[b];  // should not be necessary
// create an arbitrary directory name, add it to the zip archive
// create an arbitrary directory name, add it to the zip archive
// nested directories
// synthetic cancellation
// dircount
// filecount
// filesize
// don't cancel this Save
// create a zip file
// update the zip file
// don't cancel this Extract
// don't cancel this Extract
// extract using the entry from the enumerator
// extract using the filename indexer
// multi-thread extract
// randomly choose whether to overwrite or not
//Path.Combine(SourceDir, "AppNote.txt")
// m is the number of files to lock
// k is the type of locking.  0 == whole file, 1 == range lock
// Writing the info as a single block puts everything on the
// same line, makes it unreadable.  So we split the strings on
// newline boundaries and write them individually.
// hold the lock for a specified period of time
// This will lock the file for 3 seconds, then release it.
// The goal is to test whether the retry actually succeeds.
// 2 sets of 2 cycles: first set is warmup, 2nd is timed.
// Actually they're both timed but times for the 2nd set
// overwrite the times for the 1st set.
// Within a set, the first run is non-parallel, 2nd is timed parallel.
// disable parallel deflate
// threshold for parallel deflating
// not reached
// timeout in ms.  30000 = 30s
// else nothing
// Two trials, one with sorted output, and the other with non-sorted output.
// I need the randomness in the first part, to force the sort.
// IonicTestClass.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-July-26 10:04:54>
//
// ------------------------------------------------------------------
//
// This module defines the base class for DotNetZip test classes.
//
// ------------------------------------------------------------------
/// <summary>
///Gets or sets the test context which provides
///information about and functionality for the current test run.
///</summary>
//
// You can use the following additional attributes as you write your tests:
//
// Use ClassInitialize to run code before running the first test in the class
//
// Use ClassCleanup to run code after all tests in a class have run
// [ClassCleanup()]
// public static void MyClassCleanup() { }
//
// Use TestInitialize to run code before running each test
// Use TestCleanup to run code after each test has run
// The CWD of the monitoring process is the CurrentDir,
// therefore this test must shut down the monitoring process
// FIRST, to allow the deletion of the directory.
// Microsoft.VisualStudio.TestTools.UnitTesting
// ??
// kickoff
// basic verification of the zip file - can it be extracted?
// The extraction tool will verify checksums and passwords, as appropriate
// emit output, as desired
// create a bunch of files
// get checksums for each one
// create a bunch of files
// midnight
// get checksums for each one
// LongRunning.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2011 Dino Chiesa
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-June-19 21:51:30>
//
// ------------------------------------------------------------------
//
// This module some long-running unit tests for DotNetZip: tests for
// saving very large numbers of files, very large (multi-GB) files, and so on.
//
// ------------------------------------------------------------------
/// <summary>
/// Summary description for LongRunning
/// </summary>
// start the visible progress monitor
// sizes and numbers of files/directories to create
// used in LNSF_AddProgress
// for good measure
// clean up for this cycle
//_txrx.Send(String.Format("pb1 max {0}", e.EntriesTotal));
//_txrx.Send("pb2 max 1");
// This test checks the Int64 limits in progress events (Save + Extract)
// this will take about a minute
// 512k
// 128k
// remove the large file before extracting
// NonSeekableOutputStream.cs
// ------------------------------------------------------------------
//
// Need a non-seekable output stream to test ZIP construction.
//
// ------------------------------------------------------------------
//
// Copyright (c) 2009 by Dino Chiesa
// All rights reserved!
//
// ------------------------------------------------------------------
// PasswordTests.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2008-2011 Dino Chiesa .
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// Last Saved: <2011-August-06 11:23:57>
//
// ------------------------------------------------------------------
//
// This module provides tests for password features.
//
// ------------------------------------------------------------------
//int sz = 1000;
// Create the zip archive
// Verify that unsetting the Encryption property after
// setting a Password results in no encryption being used.
// This method tests ZipOutputStream.
// Verify that unsetting the Encryption property after
// setting a Password results in no encryption being used.
// This method tests ZipFile.
// In this case, the password is "correct" but the decrypted
// header does not match the CRC. Therefore the library
// should fail this password.  I don't know how the zip was
// constructed but I suspect a broken library.
// will throw if wrong password
// now try to extract
// pick a random entry to extract
// perform two passes: first with correct password to extract the
// file.  2nd with incorrect password to see if the file is
// deleted.
// only swallow exceptions on the first go-round
// Progress.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009 Dino Chiesa and Microsoft Corporation.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2010-January-21 11:14:35>
//
// ------------------------------------------------------------------
//
// This module defines the tests for progress events in DotNetZip.
//
// ------------------------------------------------------------------
/// <summary>
/// Summary description for Compatibility
/// </summary>
// this should be fine
// RandomTextGenerator.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009 Dino Chiesa
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-July-13 16:37:19>
//
// ------------------------------------------------------------------
//
// This module defines a class that generates random byte sequences
//
// ------------------------------------------------------------------
/// <summary>The Dispose method</summary>
// RandomTextGenerator.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009 Dino Chiesa
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-July-13 16:37:19>
//
// ------------------------------------------------------------------
//
// This module defines a class that generates random text sequences
// using a Markov chain.
//
// ------------------------------------------------------------------
// "Through the Looking Glass", by Lewis Carroll (~181k)
//www.gutenberg.org/files/12/12.txt",
// Decl of Independence (~16k)
//www.gutenberg.org/files/16780/16780.txt",
// Decl of Independence, alternative source
//www.constitution.org/usdeclar.txt",
// Section 552a of the US code - on privacy for individuals
//www.opm.gov/feddata/usc552a.txt",
// The Naval War of 1812, by Theodore Roosevelt (968k)
//www.gutenberg.org/dirs/etext05/7trnv10.txt",
// On Prayer and the Contemplative Life, by Thomas Aquinas (440k)
//www.gutenberg.org/files/22295/22295.txt",
// IETF RFC 1951 - the DEFLATE format
//www.ietf.org/rfc/rfc1951.txt",
// pkware's appnote
//www.pkware.com/documents/casestudies/APPNOTE.TXT",
/// <summary>
/// Implements a simple Markov chain for text.
/// </summary>
///
/// <remarks>
/// Uses a Markov chain starting with some base texts to produce
/// random natural-ish text. This implementation is based on Pike's
/// perl implementation, see
/// http://cm.bell-labs.com/cm/cs/tpop/markov.pl
/// </remarks>
// newline
/// <summary>
/// Generates random text with a minimum character length.
/// </summary>
///
/// <param name="minimumLength">
/// The minimum length of text, in characters, to produce.
/// </param>
/// <summary>
/// Generates random text with a minimum character length.
/// </summary>
///
/// <remarks>
/// The first sentence will start with the given start word.
/// </remarks>
///
/// <param name="minimumLength">
/// The minimum length of text, in characters, to produce.
/// </param>
/// <param name="start">
/// The word to start with. If this word does not exist in the
/// seed text, the generation will fail.
/// </param>
/// <seealso cref="GenerateText(int)"/>
/// <seealso cref="GenerateWords(int)"/>
/// <seealso cref="GenerateWords(string, int)"/>
/// <summary>
/// Generate random text with a minimum number of words.
/// </summary>
///
/// <remarks>
/// The first sentence will start with the given start word.
/// </remarks>
///
/// <param name="minimumWords">
/// The minimum number of words of text to produce.
/// </param>
/// <param name="start">
/// The word to start with. If this word does not exist in the
/// seed text, the generation will fail.
/// </param>
/// <seealso cref="GenerateText(int)"/>
/// <seealso cref="GenerateText(string, int)"/>
/// <seealso cref="GenerateWords(int)"/>
/// <summary>
/// Generate random text with a minimum number of words.
/// </summary>
///
/// <param name="minimumWords">
/// The minimum number of words of text to produce.
/// </param>
/// <seealso cref="GenerateText(int)"/>
/// <seealso cref="GenerateWords(string, int)"/>
// About the stop criteria:
// we keep going til we reach the specified number of words or chars, with the added
// proviso that we have to complete the in-flight sentence when the limit is reached.
// capitalize
// words that end sentences get a newline
/// <summary>
///   for diagnostic purposes only
/// </summary>
/// <summary>The Dispose method</summary>
// Selector.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2010 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-August-06 17:57:24>
//
// ------------------------------------------------------------------
//
// This module defines tests for the File and Entry Selection stuff in
// DotNetZip.
//
// ------------------------------------------------------------------
/// <summary>
/// Summary description for Selector
/// </summary>
// [ClassCleanup()]
// public static void MyClassCleanup()
// {
//     CleanDirectory(fodderDirectory, null);
// }
// Some of the files are marked as ReadOnly/System, and
// before deleting the dir we must strip those attrs.
// must do ReadOnly bit first - to allow setting other bits.
// Delete the directory with delay and retry.
// Sometimes I have a console window in the directory
// and I want it to not give up so easily.
/// <summary>
///   Checks a fodder directory to see if suitable.
/// </summary>
/// <param name='dir'>the directory to check</param>
///
/// <returns>
///   true if the directory contains a goodly number of fodder files.
/// </returns>
// Arriving here means no good fodder directories exist.
// Create one.
// Before creating the directory for the current run, Remove old directories.
// For some reason the test cleanup code tends to leave these directories??
// remember this directory so we can restore later
// get the base directory for tests:
// select the size
// exactly
// randomly select the format of the file name
// binary or text
// maybe backdate ctime
// maybe backdate mtime
// maybe backdate atime
// set the creation time to "a long time ago" on 1/14th of the files
// julianna
// maybe move to a subdir
// mark some of the files as hidden, system, readonly, etc
// restore the cwd
//String filename = null;
/// =======================================================
/// Now, select entries from that ZIP
// now, verify that we have not downcased the filenames
// now, verify that we have not downcased the filenames
// fully qualified
// now, verify that we have not downcased entry.FileName
// Select Entries
//var selection1 = zip2.SelectEntries("name = *.txt");
//Directory.SetCurrentDirectory(TopLevelDir);
// all of the files should have been modified either
// after midnight today, or before.
// some nonzero (high) number of files should have been
// created in the past twenty days.
// a nonzero number should be marked as having been
// created more than 3 years ago.
// None of the files should have been created
// more than 20 years ago
// Some number of the files should have been created
// more than three days ago
// summing all those created more than three days ago,
// with those created in the last three days, should be all entries.
// some number should have been accessed in the past 2 days
// those accessed *exactly* at midnight yesterday, plus
// those NOT = all entries
// those marked as last accessed more than 20 days ago == empty set
//Directory.SetCurrentDirectory(TopLevelDir);
// workitem 9174: test ExtractSelectedEntries using a directoryPathInArchive
// first, get the list of directories used by all entries
// with or without trailing slash
// Directory.SetCurrentDirectory(TopLevelDir);
//int count1, count2;
// select binary or text
// none of the entries should match this:
// all of the entries should match this:
// try an compound criterion with XOR
// factor out the XOR
// take the negation of the XOR criterion
//Directory.SetCurrentDirectory(TopLevelDir);
//int count1, count2;
//Directory.SetCurrentDirectory(TopLevelDir);
//int count1, count2;
//Directory.SetCurrentDirectory(TopLevelDir);
//int count1, count2;
//Directory.SetCurrentDirectory(TopLevelDir);
//int subdirCount = _rnd.Next(3) + 2;
// I don't actually verify the checksums in this method...
//int filecount = _rnd.Next(2) + 2;
// add all the subdirectories into a new zip
// add all of those subdirectories (A, B, C...) into the root in the zip archive
//Directory.SetCurrentDirectory(TopLevelDir);
//int subdirCount = _rnd.Next(3) + 2;
// I don't actually verify the checksums in this method...
//int filecount = _rnd.Next(2) + 2;
// add all the subdirectories into a new zip
// add all of those subdirectories (A, B, C...) into the root in the zip archive
//Directory.SetCurrentDirectory(TopLevelDir);
// this testmethod does not extract files, or verify checksums ...
// just want to verify that selection of entries works in nested directories as
// well as
// workitem 8245
//Directory.SetCurrentDirectory(TopLevelDir);
// workitem 8245
//Directory.SetCurrentDirectory(TopLevelDir);
// workitem 9176
//Directory.SetCurrentDirectory(TopLevelDir);
// workitem 10153:
//
// When calling AddSelectedFiles(String,String,String,bool), and when the
// actual filesystem path uses mixed case, but the specified directoryOnDisk
// argument is downcased, AND when the filename contains a ~ (weird, I
// know), verify that the path replacement works as advertised, and entries
// are rooted in the directoryInArchive specified path.
// must use ToLower to force case mismatch
// create a zip file using those files
// list all the entries
// now select some of the entries
// Try different formats of the selection string - with
// and without quotes, with fwd slashes and back
// slashes.
// backslash to fwdslash
// remove single quotes
// fwdslash to backslash
// SelfExtractor.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009, 2011 Dino Chiesa .
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-June-18 21:12:09>
//
// ------------------------------------------------------------------
//
// This module defines the tests for the self-extracting archive capability
// within DotNetZip: creating, reading, updating, and running SFX's.
//
// ------------------------------------------------------------------
/// <summary>
/// Summary description for Self extracting archives (SFX)
/// </summary>
//string extractDir = String.Format("extract{0}", j);
// create a file and compute the checksum
// create the SFX
// verify count
// create another file
// update the SFX
// verify count
// read the SFX
//string extractDir = String.Format("extract{0}", j);
//TestContext.WriteLine("     Checksums match ({0}).\n", actualCheckString);
// run the SFX
// overwrite
// verify the unpacked files?
// now, compare the output in unpackDir with the original
// verify the checksum of each file matches with its brother
// workitem 12608
// run the self-extracting EXE we just created
// now, compare the output in TargetDirectory with the original
// verify the checksum of each file matches with its brother
// set the return code in the app
// Here's a set of SFX tests with post-extract EXEs.
// We vary these parameters:
//  - exe exists or not - 2 trials each test.
//  - exe name has spaces or not
//  - winforms or not
//  - whether to run the exe or just compile
//  - whether to append args or not
//  - force noninteractive or not (only for Winforms flavor, to allow automated tests)
// runPostExtract
// quiet
// forceNoninteractive
// wantArgs
// runPostExtract
// quiet
// forceNoninteractive
// wantArgs
// runPostExtract
// quiet
// forceNoninteractive
// wantArgs
// This test case just tests the generation (compilation) of
// the SFX.  It is included because the interactive winforms
// SFX is not performed on automated test runs.
// runPostExtract
// quiet
// forceNoninteractive
// wantArgs
// runPostExtract
// quiet
// forceNoninteractive
// wantArgs
// runPostExtract
// quiet
// forceNoninteractive
// wantArgs
// runPostExtract
// quiet
// forceNoninteractive
// wantArgs
// ------------------------------------------------------------------ //
// runPostExtract
// quiet
// forceNoninteractive
// wantArgs
// runPostExtract
// quiet
// forceNoninteractive
// wantArgs
// runPostExtract
// quiet
// forceNoninteractive
// wantArgs
// This test case just tests the generation (compilation) of
// the SFX.  It is included because the interactive winforms
// SFX is not performed on automated test runs.
// run the SFX?
// quiet
// forceNoninteractive
// wantArgs
// actually run the program
// quiet
// forceNoninteractive
// wantArgs
// actually run the program
// quiet
// forceNoninteractive
// wantArgs
// actually run the program
// quiet
// forceNoninteractive
// wantArgs
//int entriesAdded = 0;
//String filename = null;
// If WinForms and want forceNoninteractive, have the post-extract-exe return 0,
// else, select a random number.
// Path.GetFileName(subdir));
// In the case of k==0, this exe does not exist.  It will result in
// a return code of 5.  In k == 1, the exe exists and will succeed.
// Run the generated Self-extractor, conditionally.
//
// We always run, unless specifically asked not to, OR if it's a
// winforms app and we want it to be noninteractive and there's no
// EXE to run.  If we try running a non-existent app, it will pop an
// error message, hence user interaction, which we need to avoid for
// the automated test.
// false;
// The exit code is returned only if it's a console SFX.
// The program actually runs if k != 0
// The file to execute should not have been found, hence rc==5.
// The file to execute should have returned a specific code.
// create a file to zip
// add an entry to the zipfile, then try saving to a directory. this should fail
// create another file
// update the SFX, save to a zip format
// FAIL
// pass 1 to run SFX and verify files are present;
// pass 2 to run SFX and verify that it deletes files after extracting.
// 2 passes: one for no cmd line overload, one with overload of -r+/-r-
// 2 passes: with RemoveUnpackedFiles set or unset
// override the option set at time of zip.SaveSfx()
// invoke the SFX
// verify that the files are extracted, and match
// verify that no files exist in the extract directory
// SplitArchives.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2011 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-July-14 11:07:00>
//
// ------------------------------------------------------------------
//
// This module defines tests for split (or 'spanned') archives.
//
// ------------------------------------------------------------------
// define REMOTE_FILESYSTEM in order to use a remote filesystem for storage of
// the ZIP64 large archive (which can beb huge). Leave it undefined to simply
// use the local TEMP directory.
//#define REMOTE_FILESYSTEM
/// <summary>
/// Summary description for ErrorTests
/// </summary>
// // If you want to see the diskNumber for each entry,
// // uncomment the following:
// TestContext.WriteLine("Checking info...");
// sw = new StringWriter();
// //string extractDir = String.Format("ex{0}", m);
// using (var zip = ZipFile.Read(zipFileToCreate))
// {
//     zip.StatusMessageTextWriter = sw;
//     foreach (string s in zip.Info.Split('\r','\n'))
//     {
//         Console.WriteLine("{0}", s);
//     }
//
//     // unnecessary - BasicVerify does this
//     //foreach (var e in zip)
//     //e.Extract(extractDir);
// }
// TestContext.WriteLine("{0}", sw.ToString());
// also verify checksums
// for performance, don't update the progress monitor every time.
// segmentSize32Bit: 4 * 1024 * 1024);
// segmentSize32Bit: 80 * 1024 * 1024);
// There was a claim that large archives (around or above
// 1gb) did not work well with archive splitting.  This test
// covers that case.
// This file will "cache" the randomly generated text, so we
// don't have to generate more than once. You know, for
// speed.
// int sizeBase =   20 * 1024 * 1024;
// int sizeRandom = 1 * 1024 * 1024;
// int numFiles = 3;
// int sizeBase =   320 * 1024 * 1024;
// int sizeRandom = 20 * 1024 * 1024 ;
// int numFiles = 5;
// There are a bunch of Action<T>'s here.  This test method originally
// used ZipFile.AddEntry overload that accepts an opener/closer pair.
// It conjured content for the files out of a RandomTextGenerator
// stream.  This worked, but was very very slow. So I took a new
// approach to use a WriteDelegate, and still contrive the data, but
// cache it for entries after the first one. This makes things go much
// faster.
//
// But, when using the WriteDelegate, the SaveProgress events of
// flavor ZipProgressEventType.Saving_EntryBytesRead do not get
// called. Therefore the progress updates are done from within the
// WriteDelegate itself. The SaveProgress events for SavingStarted,
// BeforeWriteEntry, and AfterWriteEntry do get called.  As a result
// this method uses 2 delegates: one for writing and one for the
// SaveProgress events.
// use a cahce file as the content.  The entry
// name will vary but we'll get the content for
// each entry from the a single cache file.
// Make the file slightly shorter with each
// successive entry, - just to shake things
// up a little.  Also seek forward a little.
// input = new Ionic.Zip.Tests.Utilities.RandomTextInputStream((int)sz);
// cache = File.Create(cacheFile);
// for performance, don't update the
// progress monitor every time.
// case ZipProgressEventType.Saving_EntryBytesRead:
// if (!_pb2Set)
// {
//     _txrx.Send(String.Format("pb 2 max {0}", e1.TotalBytesToTransfer));
//     _pb2Set = true;
// }
// _txrx.Send(String.Format("status Saving entry {0}/{1} {2} :: {3}/{4}mb {5:N0}%",
//                          numSaving, totalToSave,
//                          e1.CurrentEntry.FileName,
//                          e1.BytesTransferred/(1024*1024), e1.TotalBytesToTransfer/(1024*1024),
//                          ((double)e1.BytesTransferred) / (0.01 * e1.TotalBytesToTransfer)));
// string msg = String.Format("pb 2 value {0}", e1.BytesTransferred);
// _txrx.Send(msg);
// break;
// build a large zip file out of thin air
/// <summary>
///   Finds or creates and fills a cache directory of fodder files.
/// </summary>
/// <returns>the name of the cache directory</returns>
// upon reaching here, no directories exist that contain suitable
// fodder for these tests.  Create the directory, and a few
// fodder files.
// to protect against stuck file locks
// Three passes:
// pass 1: save as regular, then resave as segmented.
// pass 2: save as segmented, then resave as regular.
// pass 3: save as segmented, then resave as another segmented archive.
// for various segment sizes
// to protect against stuck file locks
// Save as segmented, then read/extract with winzip unzip
// for various segment sizes.
// to protect against stuck file locks
// Save as segmented, then read/extract with winzip unzip
// for various segment sizes.
// to protect against stuck file locks
// Save as segmented, then read/extract with winzip unzip
// for various segment sizes.
// with WinZip, must produce a segmented zip in two
// steps: first create the regular zip, then split it.
// step 1: create the regular zip
// step 2: split the existing zip
// "wzzip -ys[size] archivetosplit.zip nameofparts "
//nameOfParts
// to protect against stuck file locks
// Save as segmented, then read/extract with winzip unzip
// for various segment sizes.
// Streams.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2011 Dino Chiesa
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// Last Saved: <2011-July-28 07:33:02>
//
// ------------------------------------------------------------------
//
// This module defines tests for Streams interfaces into DotNetZip, that
// DotNetZip can write to streams, read from streams, ZipOutputStream,
// ZipInputStream, etc.
//
// ------------------------------------------------------------------
/// <summary>
/// Summary description for StreamsTests
/// </summary>
//int entriesAdded = 0;
//String filename = null;
// Verify the files are in the zip
// now extract the files and verify their contents
// try once with Password set on ZipFile,
// another with password on the entry, and
// a third time with password passed into the OpenReader() method.
//zip.Write(new byte[1], 0, 0);
// zero length files
// conditionally use a non-seekable output stream
// At one stage, using ZipOutputStream with Encryption and a
// non-seekable output stream did not work.  DotNetZip was changed to be
// smarter, so that works now. This test verifies that combination
// of stuff.
//int fileCount = _rnd.Next(146) + 5536;
// 2 stages: Write, Count, Verify
// make it a directory
// only a few entries are non-empty
// basic verify. The output is really large, so we pass emitOutput=false .
//output.PutNextEntry("entry1.txt");
// this will be a directory
// a zero length entry
// zero length
// this should fail
// this will be a directory
// this will be zero length
// this will be zero length
// this will be zero length
// this will be zero length
// this will be zero length
// conditionally use a non-seekable output stream
//_txrx.Send("status saving started...");
//_txrx.Send(String.Format("status Compressing {0}", e.CurrentEntry.FileName));
//                     _txrx.Send(String.Format("status Saving entry {0}/{1} :: {2} :: {3}/{4}mb {5:N0}%",
//                                              _numSaving, _totalToSave,
//                                              e.CurrentEntry.FileName,
//                                              e.BytesTransferred/(1024*1024), e.TotalBytesToTransfer/(1024*1024),
//                                              ((double)e.BytesTransferred) / (0.01 * e.TotalBytesToTransfer)));
//System.Threading.Thread.Sleep(40);
//_txrx.Send("status Save completed");
// Two passes: first to call UpdateEntry() when no prior entry exists.
// Second to call UpdateEntry when a prior entry exists.
// verify checksum here?
// in ms.  30*60*100 == 30min
// Test memory growth over many many cycles.
// There was a leak in the ParallelDeflateOutputStream, where
// the PDOS was not being GC'd.  This test checks for that.
//
// If the error is present, this test will either timeout or
// throw an InsufficientMemoryException (or whatever).  The
// timeout occurs because GC begins to get verrrrry
// sloooooow.  IF the error is not present, this test will
// complete successfully, in about 20 minutes.
//
// fill a couple memory streams with random text
//s.Close();
//zip.SaveProgress += streams_SaveProgress;
//int _sizeBase      = 1024 * 256;
//int _sizeRange     = 256 * 12;
//int nFiles         = 2;
//int c = i;
// I wanna do 2 cycles if there is compression, so I can compare MT
// vs 1T compression.  The first cycle will ALWAYS use the threaded
// compression, the 2nd will NEVER use it.  If
// CompressionLevel==None, then just do one cycle.
//
// Also, I use Stopwatch to time the compression, and compare.
// In light of that, I wanna do one warmup, and then one timed
// trial (for t==0..2).  But here again, if CompressionLevel==None, then I
// don't want to do a timing comparison, so I don't need 2 trials.
// Therefore, in that case, the "warmup" is the only trial I want to do.
// So when k==1 and Compression==None, do no cycles at all.
//
// never
// always
// maybe "None"
//if (t==0)
// parallel is not always faster!
// zero length files
// mixed
// Create the zip archive via 7z.exe
// Verify the number of files in the zip
// extract the files
// create the directory
// create the file
// we don't set the timestamps or attributes
// on the file/directory.
// winzip does not include the base path in the filename;
// 7zip does.
// Verify the number of files extracted
// zero length files
// mixed
// Create the zip archive via WinZip.exe
// Verify the number of files in the zip
// extract the files
// create the directory
// create the file
// we don't set the timestamps or attributes
// on the file/directory.
// Verify the number of files extracted
// zero length files
// mixed = some zero and some not
// Create the zip archive
// Verify the number of files in the zip
// extract the files
// set password if necessary
// create the directory
// emit the file
// Verify the number of files extracted
// page that generates a zip file.
// read/extract the generated zip
// compare checksums
// Three cycles - three different ways to vary compression
// create the directory
// create the file
// TestUtilities.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2011 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-August-11 07:54:52>
//
// ------------------------------------------------------------------
//
// This module defines some utility classes used by the unit tests for
// DotNetZip.
//
// ------------------------------------------------------------------
// turn off any ReadOnly attributes
// use an backoff interval before retry
// don't traverse reparse points
// recurse
// clear ReadOnly and System attributes
//return (((pathname[1] == ':') && (pathname[2] == '\\')) ? pathname.Substring(3) : pathname)
//    .Replace('\\', '/');
// round to nearest second:
//if (source.Millisecond >= 500) dtRounded = dtRounded.AddSeconds(1);
/// <summary>
///   count occurrences of sample in string s.
/// </summary>
// fill the file with text data, selecting large blocks at a time
// fill the file with text data, selecting one word at a time
// pick a word at random
// fill the file by repeatedly writing out the same line
// fill with binary data
//string nameOfFileToCreate = GenerateUniquePathname(extension, ContainingDirectory);
// create an empty file
//string fileToCreate = GenerateUniquePathname(extension, ContainingDirectory);
// this file/path does not exist.  It can now be created, as
// file or directory.
// delta == 65 means uppercase
// delta == 97 means lowercase
// to randomly set dircount, filecount, and filesize
// start the progress monitor
//this.Exec(progressMonitorTool, String.Format("-channel {0}", progressChannel), false);
// Must read at least one of the stderr or stdout asynchronously,
// to avoid deadlock. I choose to read stderr.
// just in case
/// <summary>
///   The WinZip command-line tools emit dots and backspaces in the output.
///   For a large zip file, the output can be 1mb or more, of which 99% is
///   dots and backspaces. This method trims them from the output, making it
///   suitable for printing into the TestContext output.
/// </summary>
// wzzip.exe can generate long sequences of dots, followed by long
// sequences of backspaces.  Don't want to replace two backspaces
// with the empty string, so replace a sequence of a non-backspace
// char followed by backspace with the empty string.  Do it in
// cycles to handle those long sequences.
// Capitalize
// TrimPunctuation
// UnicodeTests.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2008-2011 Dino Chiesa .
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// Last Saved: <2011-July-06 19:29:37>
//
// ------------------------------------------------------------------
//
// This module defines the tests for the Unicode features in DotNetZip.
//
// ------------------------------------------------------------------
/// <summary>
/// Summary description for UnicodeTests
/// </summary>
// create the subdirectory
// create a bunch of files
// create a zipfile twice, once using Unicode, once without
// select the name of the zip file
// use the local filename (not fully qualified)
// Verify the number of files in the zip
// verify the filenames are (or are not) unicode
// according to the spec,
// unicode is not supported on the zip archive comment!
// But this library won't enforce that.
// We will leave it up to the application.
// Assert.AreNotEqual<String>(origComment, zip2.Comment);
// keep this at index==0
// Chinese
// Japanese
// greek
// portugese + Chinese
//??
// Russian
// I don't know what language this is
// create the subdirectory
// create a bunch of files in that subdir
// Using those files create a zipfile 4 times:
// cycle 0 - UseUnicodeAsNecessary
// cycle 1 - Nothing
// cycle 2 - AlternateEncoding = UTF8, AlternateEncodingUsage = Always
// cycle 3 - AlternateEncoding = UTF8, AlternateEncodingUsage = AsNecessary
// do nothing
// Verify the number of files in the zip
// using those files create a zipfile twice.  First cycle uses Unicode,
// 2nd cycle does not.
// select the name of the zip file
// create using ZOS
// with no path
// Verify the number of files in the zip
// two passes: one that uses the old "useUnicodeAsNecessary" property,
// and the second that uses the newer property.
// Verify that the filenames do, or do not, match the
// names that were added.  They will match if unicode
// was used (j!=1) or if the filename used was the first
// in the formats list (k==0).
// not all codepages will yield legal filenames for a given filenameFormat
// insert other trials here.??
// create the subdirectory
// create a bunch of files
// three cases: one for old-style
// ProvisionalAlternateEncoding, one for "AsNecessary"
// and one for "Always"
// select the name of the zip file
// use the local filename (not fully qualified)
// verify the filenames are (or are not) unicode
// three trials: one for old-style
// ProvisionalAlternateEncoding, one for "AsNecessary"
// and one for "Always"
// pass 1 - create it
// pass 2 - read and update it
// pass 3 - verify the filenames, again
// Chinese characters
// three trials: one for old-style
// ProvisionalAlternateEncoding, one for "AsNecessary"
// and one for "Always"
// create an arbitrary directory name, add it to the zip archive
// UpdateTests.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2011 Dino Chiesa
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-August-05 16:52:59>
//
// ------------------------------------------------------------------
//
// This module defines tests for updating zip files via DotNetZip.
//
// ------------------------------------------------------------------
/// <summary>
/// Summary description for UnitTest1
/// </summary>
// Now create a new subdirectory and add that one
// this will add entries into the existing zip file
// create the files
//int numFilesToCreate = 2;
//TestUtilities.CreateAndFillFileText(filename, 500);
// Verify the correct number of files are in the zip
// test extract (and implicitly check CRCs, passwords, etc)
// modify the metadata for an entry
// Verify the correct number of files are in the zip
// test extract (and implicitly check CRCs, passwords, etc)
// select the name of the zip file
// create the subdirectory
// create the files
// Add the files to the zip, save the zip
// 31 days * number of entries
// Verify the files are in the zip
// selectively remove a few files in the zip archive
// We cannot remove the entry from the list, within the context of
// an enumeration of said list.
// So we add the doomed entry to a list to be removed
// later.
// pass 1: mark the entries for removal
// pass 2: actually remove the entry.
// Verify the correct number of files are in the zip
// verify that all entries in the archive are within the threshold
// select the name of the zip file
// create the subdirectory
// create a bunch of files, fill them with content
// Add the files to the zip, save the zip
// Verify the files are in the zip
// selectively remove a few files in the zip archive
// select a new, uniquely named file to create
// add this file to the list
// extract all files, verify none should have been removed,
// and verify the contents of those that remain
// verify the content of the updated file.
// Verify the files are in the zip
// Two passes:  in pass 1, simply rename the file;
// in pass 2, rename it so that it has a directory.
// This shouldn't matter, but we test it anyway.
// Add the files to the zip, save the zip
// Verify the number of files in the zip
// selectively rename a few files in the zip archive
// Extract all the files, verify that none have been removed,
// and verify the names of the entries.
// select the name of the zip file
// create the subdirectory
// create a bunch of files
//int numFilesToCreate = _rnd.Next(15) + 18;
// Add the files to the zip, save the zip
// Verify the files are in the zip
// update the comments for a few files in the zip archive
// Extract all files, verify that none have been removed,
// and verify the contents of those that remain.
// verify the content of the updated file.
// Verify the files are in the zip
// select the name of the zip file
// create the subdirectory
// create a bunch of files
// Add the files to the zip, save the zip.
// in pass 2, remove one file, then save again.
// conditionally remove a single entry, on the 2nd trial
// Verify the files are in the zip
// selectively remove a few files in the zip archive
// select a new, uniquely named file to create
// add this file to the list
// extract all files, verify none should have been removed,
// and verify the contents of those that remain
// verify the content of the updated file.
// Verify the files are in the zip
// select the name of the zip file
// create the subdirectory
// create the files
// Add the files to the zip, save the zip
// Verify the files are in the zip
// selectively remove a few files in the zip archive
// select a new, uniquely named file to create
// add this file to the list
// remove the file from the zip archive
// extract all files, verify none should have been removed,
// and verify the contents of those that remain
// verify the content of the updated file.
// Verify the files are in the zip
// select the name of the zip file
// create the subdirectory
// create the files
// Add the files to the zip, save the zip
// Verify the files are in the zip
// remove all the entries from the zip archive
// Verify the files are in the zip
// select the name of the zip file
// create the subdirectory
// create the files
// Create the zip file
// Verify the files are in the zip
// Create a bunch of new files...
// select a new, uniquely named file to create
// create a new file, and fill that new file with text data
// add each one of those new files in the zip archive
// Verify the number of files in the zip
// now extract the newly-added files and verify their contents
// verify the content of the updated file.
// extract all the other files and verify their contents
// verify the content of the updated file.
// select the name of the zip file
// create the subdirectory
// create a bunch of files
// Create the zip file
// Verify the files are in the zip
// create another subdirectory
// create a bunch more files
// Update those files in the zip file
// Verify the number of files in the zip
// now extract the files and verify their contents
// verify the content of the updated file.
// select the name of the zip file
// Create the zip file
// select the name of the zip file
// select the name of the zip file
// select the name of the zip file
//Attention: the source stream can't be disposed, as its needed to read not edited entries on the next save
// select the name of the zip file
//Attention: the source stream can't be disposed, as its needed to read not edited entries on the next save
// select the name of the zip file
// create the subdirectory
// create a bunch of files
// Create the zip archive
// Verify the number of files in the zip
// Create a bunch of new files...
// select a new, uniquely named file to create
// create a new file, and fill that new file with text data
// add each one of those new files in the zip archive using a password
// Verify the number of files in the zip
// now extract the newly-added files and verify their contents
// verify the content of the updated file.
// extract all the other files and verify their contents
// verify the content of the updated file.
// select the name of the zip file
// create the subdirectory
// create a bunch of files
// Add the files to the zip, save the zip
// Verify the number of files in the zip
// Create a bunch of new files...
//int numToUpdate = _rnd.Next(numFilesToCreate - 4);
// select a new, uniquely named file to create
// create a new file, and fill that new file with text data
// add each one of those new files in the zip archive using a password
// Verify the number of files in the zip
// now extract the newly-added files and verify their contents
// verify the content of the updated file.
// extract all the other files and verify their contents
// verify the content of the updated file.
// select the name of the zip file
// create the subdirectory
// create the files
// create the zip archive
// Verify the number of files in the zip
// create another subdirectory
// Create a bunch of new files, in that new subdirectory
// select a new, uniquely named file to create
// create a new file, and fill that new file with text data
// update those files in the zip archive
// extract those files and verify their contents
// verify the content of the updated file.
// extract all the other files and verify their contents
// verify the content of the updated file.
// select the name of the zip file
// create the subdirectory
// create the files
// create the zip archive
// Verify the number of files in the zip
// create another subdirectory
// Create a bunch of new files, in that new subdirectory
// select a new, uniquely named file to create
// create a new file, and fill that new file with text data
// update those files in the zip archive
// Verify the number of files in the zip
// update those files AGAIN in the zip archive
// extract the updated files and verify their contents
// verify the content of the updated file.
// extract all the other files and verify their contents
// verify the content of the updated file.
// select the name of the zip file
// create the subdirectory
// create a bunch of files
// Create the zip archive
// Verify the number of files in the zip
// create another subdirectory
// Create a bunch of new files, in that new subdirectory
// select a new, uniquely named file to create
// create a new file, and fill that new file with text data
// update those files in the zip archive
// extract those files and verify their contents
// verify the content of the updated file.
// extract all the other files and verify their contents
// verify the content of the updated file.
// select the name of the zip file
// create the subdirectory
// create a bunch of files
// create the zip archive, add those files to it
// no password used here.
// Verify the files are in the zip
// create another subdirectory
// Create a bunch of new files, in that new subdirectory
// select a new, uniquely named file to create
// create the new file, and fill that new file with text data
// update those files in the zip archive
// extract those files and verify their contents
// verify the content of the updated file.
// extract all the other files and verify their contents
// verify the content of the updated file.
// select the name of the zip file
// create the subdirectory
// create a bunch of files
// create the zip archive
// Verify the files are in the zip
// create another subdirectory
// Create a bunch of new files, in that new subdirectory
// select a new, uniquely named file to create
// create a new file, and fill that new file with text data
// update those files in the zip archive
// extract those files and verify their contents
// verify the content of the updated file.
// extract all the other files and verify their contents
// use original password
// verify the content of the updated file.
// select the name of the zip file
// create the subdirectory
// create the files
// Add the files to the zip, save the zip
// create and file a new file with text data
// Try to again add that file in the zip archive. This
// should fail.
// Try Adding a file again.  THIS SHOULD THROW.
//PART1 - Add directory and save
//PART2 - Rename paths (not related to XX directory from above) and save
// select the name of the zip file
// create a subst drive
// remove the virt drive
// WinZipAesTests.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009 Dino Chiesa and Microsoft Corporation.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-July-13 21:25:38>
//
// ------------------------------------------------------------------
//
// This module defines the tests of the WinZIP AES Encryption capability
// of DotNetZip.
//
// ------------------------------------------------------------------
/// <summary>
/// Summary description for WinZipAesTests
/// </summary>
//string password = TestUtilities.GenerateRandomPassword();
// seems to be a race condition?  sometimes?
// Want to test the library when saving to non-seekable output streams.  Like
// stdout or ASPNET's Response.OutputStream.  This simulates it.
// With no password, we expect no encryption in the output.
// validate all the checksums
// verify the checksum of the file is correct
// create a bunch of zero-length files
// This had better not be too long a list, otherwise the cmd
// line length limit will be exceeded.  To avoid that, could
// use directory names, but.... for now let's just hope.
// get a set of files to zip up
// This method generates files, then zips them up using WinZip, then tries
// to unzip using DotNetZip. It is parameterized to test both success and
// failure cases. If pwFlavor is zero, then it uses the correct password to
// unzip, and everything should work.  If pwFlavor is non-zero then it uses
// some incorrect password, either null or a bogus string, and generates a failure.
// get a set of files to zip up
// extract all the files
//zip2.Password = password;
// validate all the checksums
// verify the checksum of the file is correct
// Using a blank password, eh?
// Just what exactly is this *supposed* to do?
//
// validate all the checksums
// verify the checksum of the file is correct
// make a few text files
// create the zip: add some files, and Save() it
// remove a file and re-Save
// Verify the files are in the zip
//MemoryStream zippedStream = new MemoryStream();
// This zipfile has some zero-length entries. Previously
// DotNetZip was throwing a spurious MAC mismatch error on
// those zero-length entries.
// Update the zip file
// this should succeed
// Zip64Tests.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2011 Dino Chiesa
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-July-10 20:31:24>
//
// ------------------------------------------------------------------
//
// This module defines the tests for the ZIP64 capability within DotNetZip.  These
// tests can take a long time to run, as the files can be quite large - 10g or
// more. Merely generating the content for these tests can take an hour.  Most tests
// in the DotNetZip test suite are self-standing - they generate the content they
// need, and then remove it after completion, either success or failure. With ZIP64,
// because content creation is expensive, for update operations this module uses a
// cache of large zip files.  See _CreateHugeZipfiles().  The method looks for
// large files in a well-known location on the filesystem, in fodderDir.
//
// ------------------------------------------------------------------
// Keep this huge zip file around, because it takes so much
// time to create it. But Delete the directory if one of the files no
// longer exists.
//File.Delete(_HugeZipFile);
/// <summary>
///   Create 2 large zip64 zip files - one from DNZ, one from WinZip.  Each
///   test that updates a zip file should use both. There are slight
///   differences between a zip from DNZ and one from WinZip, specifically
///   regarding metadata. These differences should be inconsequential for
///   updates of zips, and that is what some of the zip64 tests seek to
///   verify.
/// </summary>
// lock in case more than one test calls this at a time.
// STEP 1:
// look for existing directories, and re-use the large zip files
// there, if it exists, and if it is large enough.
// first pass to check if any dirs, have both files,
// second pass to check if any dirs have one file plus fodder files.
// check for fodder files
// found both large zips, so use them.
// on pass 2, take 1st dir with at least one zip
// remember the current directory so we can restore later
// CurrentDir is the dir that holds the test temp directory (or directorIES)
// create the dir if it does not exist
// create a huge ZIP64 archive with a true 64-bit offset.
//Directory.SetCurrentDirectory(testDir);
// create a directory with some files in it, to zip
// These params define the size range for the large, random text
// files that are created below. Creating files this size takes
// about 1 minute per file
//_sizeBase =   0x160000;
//_sizeRandom = 0x200000;
// in case it was missed
// Add links to a few very large files into the same directory.  We
// do this because creating such large files from nothing would take
// a very very long time.
// again
// create a zip file, using WinZip
// This will take 50 minutes or so, no progress updates possible.
// in case it was missed
// wzzip.exe will create a zip64 file automatically, as necessary.
// There is no explicit switch required.
// switches:
//   -a   add
//   -r   recurse
//   -p   store folder names
//   -yx  store extended timestamps
// Create a zip file using DotNetZip
// This will take 50 minutes or so.
// pb1 and pb2 will be set in the {Add,Save}Progress handlers
// used in Zip64_SaveProgress
// use large buffer to speed up save for large files:
// Delete the fodder dir only if we have both zips.
// This is helpful when modifying or editing this method.
// With repeated runs you don't have to re-create all the data
// each time.
// restore the cwd:
// enough
// ??
//int entries = 2;
// just in case it was missed
// just in case it was missed
// large buffer better for large files
// 65536 * 8 = 512k
// 60*60*1000 = 1hr
// this should take about an hour
// this should take a little less than an hour
// 60*60*1000 = 1hr
// this should take about an hour
// this should take a little less than an hour
// pb 0: numUpdates + before+after verify steps
// make sure the zip is larger than the 4.2gb size
// this usually takes 10-12 minutes
// create another folder with a single file in it
// update the zip with that new folder+file
// will take a long time for large files
// 65536 * 8 = 512k
// for subsequent updates
// emit status into the log if available
// make sure the zip is larger than the 4.2gb size
// this will throw if the command has a non-zero exit code.
// in milliseconds.
// may take a long time
// make sure the zip is larger than the 4.2gb size
// Examine and unpack the zip archive via WinZip
// first, examine the zip entry metadata:
// It takes some time to create a large file. And we need
// a bunch of them.
// randomly select binary or text
// first file is 2x larger
// 60*60*1000 == 1 hr
// This TestMethod tests if DNZ can read a huge (>4.2gb) zip64 file
// created by winzip.
//Directory.SetCurrentDirectory(TopLevelDir);
// create a zip archive via WinZip
// Add one file at a time, invoking wzzip.exe for each. After it
// completes, delete the just-added file. This allows coarse-grained
// status updates in the progress window.  Not sure about the exact
// impact on disk space, or execution time; my observation is that the
// time-cost to add one entry increases, as the zip file gets
// larger. Each successive cycle takes a little longer.  It's tolerable
// I guess.  A tradeoff to get visual progress feedback.
// Create one additional small text file and add it to the zip.  For
// this test, it must be added last, at the end of the ZIP file.
// make sure the zip is larger than the 4.2gb size
// Now use DotNetZip to extract the large zip file to the bit bucket.
// 60*60*1000 = 1 hr
// Not really a test.  This thing just sets up the big zip file.
// usually takes about an hour
// Steps in this test: 4
// create a very large file
// This takes a few minutes...
// make sure it is larger than 4.2gb
// 65536 * 8 = 512k
// Emitting a zip file with > 65534 entries requires the use of ZIP64 in
// the central directory.
//int numTotalEntries = _rnd.Next(461)+6534;
//int numTotalEntries = _rnd.Next(46)+653;
// 3 stages: AddEntry, Save, Verify
// save space when saving the file:
// add files:
// verify the zip by unpacking.
// 60*60*1000 = 1 hr
// Should take 2.5 hrs when creating the huge files, about 1 hr when the
// files already exist.
// 60*60*1000 = 1 hr
// Should take 2.5 hrs when creating the huge files, about 1 hr when the
// files already exist.
// Test whether opening a huge zip64 file and then re-saving, allows the
// file to remain valid.  Must use a huge zip64 file over 4gb in order
// to verify this, and at least one entry must be > 4gb uncompressed.
// Want to check that UseZip64WhenSaving is automatically selected as
// appropriate.
// start the progress monitor
// make sure the zip is larger than the 4.2gb size
// According to workitem 9214, the comment must be modified
// on an entry that is larger than 4gb (uncompressed).
// Check that here.
// Verify the zip is correct, can be extracted.
// This will take some time for a large zip.
// (+1 to _numFilesToExtract for the directory)
// _testTitle is used in Zip64{Save,Extract}Progress
// update the zip with one small change: a new comment on
// the biggest entry.
// required: the option must be set automatically and intelligently
// according to workitem 9214, the comment must be modified
// on an entry that is larger than 4gb (uncompressed)
// redundant with the check above, but so what?
// can take an hour or more
// finally, verify that the modified comment is correct.
// check that the z64 option is set automatically and intelligently
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// aapt resource value: 0x7f020001
// aapt resource value: 0x7f020000
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
// The following GUID is for the ID of the typelib if this project is exposed to COM
// ComHelper.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-June-13 17:04:06>
//
// ------------------------------------------------------------------
//
// This module defines a COM Helper class.
//
// Created: Tue, 08 Sep 2009  22:03
//
/// <summary>
/// This class exposes a set of COM-accessible wrappers for static
/// methods available on the ZipFile class.  You don't need this
/// class unless you are using DotNetZip from a COM environment.
/// </summary>
/// <summary>
///  A wrapper for <see cref="ZipFile.IsZipFile(string)">ZipFile.IsZipFile(string)</see>
/// </summary>
/// <param name="filename">The filename to of the zip file to check.</param>
/// <returns>true if the file contains a valid zip file.</returns>
/// <summary>
///  A wrapper for <see cref="ZipFile.IsZipFile(string, bool)">ZipFile.IsZipFile(string, bool)</see>
/// </summary>
/// <remarks>
/// We cannot use "overloaded" Method names in COM interop.
/// So, here, we use a unique name.
/// </remarks>
/// <param name="filename">The filename to of the zip file to check.</param>
/// <returns>true if the file contains a valid zip file.</returns>
/// <summary>
///  A wrapper for <see cref="ZipFile.CheckZip(string)">ZipFile.CheckZip(string)</see>
/// </summary>
/// <param name="filename">The filename to of the zip file to check.</param>
///
/// <returns>true if the named zip file checks OK. Otherwise, false. </returns>
/// <summary>
///  A COM-friendly wrapper for the static method <see cref="ZipFile.CheckZipPassword(string,string)"/>.
/// </summary>
///
/// <param name="filename">The filename to of the zip file to check.</param>
///
/// <param name="password">The password to check.</param>
///
/// <returns>true if the named zip file checks OK. Otherwise, false. </returns>
/// <summary>
///  A wrapper for <see cref="ZipFile.FixZipDirectory(string)">ZipFile.FixZipDirectory(string)</see>
/// </summary>
/// <param name="filename">The filename to of the zip file to fix.</param>
/// <summary>
///  A wrapper for <see cref="ZipFile.LibraryVersion">ZipFile.LibraryVersion</see>
/// </summary>
/// <returns>
///  the version number on the DotNetZip assembly, formatted as a string.
/// </returns>
// EncryptionAlgorithm.cs
// ------------------------------------------------------------------
//
// Copyright (c)  2009 Dino Chiesa
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License. 
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs): 
// Time-stamp: <2009-October-21 17:24:45>
//
// ------------------------------------------------------------------
//
// This module defines the EncryptionAgorithm enum
//
// 
// ------------------------------------------------------------------
/// <summary>
/// An enum that provides the various encryption algorithms supported by this
/// library.
/// </summary>
///
/// <remarks>
///
/// <para>
///   <c>PkzipWeak</c> implies the use of Zip 2.0 encryption, which is known to be
///   weak and subvertible.
/// </para>
///
/// <para>
///   A note on interoperability: Values of <c>PkzipWeak</c> and <c>None</c> are
///   specified in <see
///   href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's zip
///   specification</see>, and are considered to be "standard".  Zip archives
///   produced using these options will be interoperable with many other zip tools
///   and libraries, including Windows Explorer.
/// </para>
///
/// <para>
///   Values of <c>WinZipAes128</c> and <c>WinZipAes256</c> are not part of the Zip
///   specification, but rather imply the use of a vendor-specific extension from
///   WinZip. If you want to produce interoperable Zip archives, do not use these
///   values.  For example, if you produce a zip archive using WinZipAes256, you
///   will be able to open it in Windows Explorer on Windows XP and Vista, but you
///   will not be able to extract entries; trying this will lead to an "unspecified
///   error". For this reason, some people have said that a zip archive that uses
///   WinZip's AES encryption is not actually a zip archive at all.  A zip archive
///   produced this way will be readable with the WinZip tool (Version 11 and
///   beyond).
/// </para>
///
/// <para>
///   There are other third-party tools and libraries, both commercial and
///   otherwise, that support WinZip's AES encryption. These will be able to read
///   AES-encrypted zip archives produced by DotNetZip, and conversely applications
///   that use DotNetZip to read zip archives will be able to read AES-encrypted
///   archives produced by those tools or libraries.  Consult the documentation for
///   those other tools and libraries to find out if WinZip's AES encryption is
///   supported.
/// </para>
///
/// <para>
///   In case you care: According to <see
///   href="http://www.winzip.com/aes_info.htm">the WinZip specification</see>, the
///   actual AES key used is derived from the <see cref="ZipEntry.Password"/> via an
///   algorithm that complies with <see
///   href="http://www.ietf.org/rfc/rfc2898.txt">RFC 2898</see>, using an iteration
///   count of 1000.  The algorithm is sometimes referred to as PBKDF2, which stands
///   for "Password Based Key Derivation Function #2".
/// </para>
///
/// <para>
///   A word about password strength and length: The AES encryption technology is
///   very good, but any system is only as secure as the weakest link.  If you want
///   to secure your data, be sure to use a password that is hard to guess.  To make
///   it harder to guess (increase its "entropy"), you should make it longer.  If
///   you use normal characters from an ASCII keyboard, a password of length 20 will
///   be strong enough that it will be impossible to guess.  For more information on
///   that, I'd encourage you to read <see
///   href="http://www.redkestrel.co.uk/Articles/RandomPasswordStrength.html">this
///   article.</see>
/// </para>
///
/// </remarks>
/// <summary>
/// No encryption at all.
/// </summary>
/// <summary>
/// Traditional or Classic pkzip encryption.
/// </summary>
/// <summary>
/// WinZip AES encryption (128 key bits).
/// </summary>
/// <summary>
/// WinZip AES encryption (256 key bits).
/// </summary>
/// <summary>
/// An encryption algorithm that is not supported by DotNetZip.
/// </summary>
// others... not implemented (yet?)
// Events.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2006, 2007, 2008, 2009 Dino Chiesa and Microsoft Corporation.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-August-06 12:26:24>
//
// ------------------------------------------------------------------
//
// This module defines events used by the ZipFile class.
//
//
/// <summary>
///   Delegate in which the application writes the <c>ZipEntry</c> content for the named entry.
/// </summary>
///
/// <param name="entryName">The name of the entry that must be written.</param>
/// <param name="stream">The stream to which the entry data should be written.</param>
///
/// <remarks>
///   When you add an entry and specify a <c>WriteDelegate</c>, via <see
///   cref="Ionic.Zip.ZipFile.AddEntry(string, WriteDelegate)"/>, the application
///   code provides the logic that writes the entry data directly into the zip file.
/// </remarks>
///
/// <example>
///
/// This example shows how to define a WriteDelegate that obtains a DataSet, and then
/// writes the XML for the DataSet into the zip archive.  There's no need to
/// save the XML to a disk file first.
///
/// <code lang="C#">
/// private void WriteEntry (String filename, Stream output)
/// {
///     DataSet ds1 = ObtainDataSet();
///     ds1.WriteXml(output);
/// }
///
/// private void Run()
/// {
///     using (var zip = new ZipFile())
///     {
///         zip.AddEntry(zipEntryName, WriteEntry);
///         zip.Save(zipFileName);
///     }
/// }
/// </code>
///
/// <code lang="vb">
/// Private Sub WriteEntry (ByVal filename As String, ByVal output As Stream)
///     DataSet ds1 = ObtainDataSet()
///     ds1.WriteXml(stream)
/// End Sub
///
/// Public Sub Run()
///     Using zip = New ZipFile
///         zip.AddEntry(zipEntryName, New WriteDelegate(AddressOf WriteEntry))
///         zip.Save(zipFileName)
///     End Using
/// End Sub
/// </code>
/// </example>
/// <seealso cref="Ionic.Zip.ZipFile.AddEntry(string, WriteDelegate)"/>
/// <summary>
///   Delegate in which the application opens the stream, just-in-time, for the named entry.
/// </summary>
///
/// <param name="entryName">
/// The name of the ZipEntry that the application should open the stream for.
/// </param>
///
/// <remarks>
///   When you add an entry via <see cref="Ionic.Zip.ZipFile.AddEntry(string,
///   OpenDelegate, CloseDelegate)"/>, the application code provides the logic that
///   opens and closes the stream for the given ZipEntry.
/// </remarks>
///
/// <seealso cref="Ionic.Zip.ZipFile.AddEntry(string, OpenDelegate, CloseDelegate)"/>
/// <summary>
///   Delegate in which the application closes the stream, just-in-time, for the named entry.
/// </summary>
///
/// <param name="entryName">
/// The name of the ZipEntry that the application should close the stream for.
/// </param>
///
/// <param name="stream">The stream to be closed.</param>
///
/// <remarks>
///   When you add an entry via <see cref="Ionic.Zip.ZipFile.AddEntry(string,
///   OpenDelegate, CloseDelegate)"/>, the application code provides the logic that
///   opens and closes the stream for the given ZipEntry.
/// </remarks>
///
/// <seealso cref="Ionic.Zip.ZipFile.AddEntry(string, OpenDelegate, CloseDelegate)"/>
/// <summary>
///   Delegate for the callback by which the application tells the
///   library the CompressionLevel to use for a file.
/// </summary>
///
/// <remarks>
/// <para>
///   Using this callback, the application can, for example, specify that
///   previously-compressed files (.mp3, .png, .docx, etc) should use a
///   <c>CompressionLevel</c> of <c>None</c>, or can set the compression level based
///   on any other factor.
/// </para>
/// </remarks>
/// <seealso cref="Ionic.Zip.ZipFile.SetCompression"/>
/// <summary>
///   In an EventArgs type, indicates which sort of progress event is being
///   reported.
/// </summary>
/// <remarks>
///   There are events for reading, events for saving, and events for
///   extracting. This enumeration allows a single EventArgs type to be sued to
///   describe one of multiple subevents. For example, a SaveProgress event is
///   invoked before, after, and during the saving of a single entry.  The value
///   of an enum with this type, specifies which event is being triggered.  The
///   same applies to Extraction, Reading and Adding events.
/// </remarks>
/// <summary>
/// Indicates that a Add() operation has started.
/// </summary>
/// <summary>
/// Indicates that an individual entry in the archive has been added.
/// </summary>
/// <summary>
/// Indicates that a Add() operation has completed.
/// </summary>
/// <summary>
/// Indicates that a Read() operation has started.
/// </summary>
/// <summary>
/// Indicates that an individual entry in the archive is about to be read.
/// </summary>
/// <summary>
/// Indicates that an individual entry in the archive has just been read.
/// </summary>
/// <summary>
/// Indicates that a Read() operation has completed.
/// </summary>
/// <summary>
/// The given event reports the number of bytes read so far
/// during a Read() operation.
/// </summary>
/// <summary>
/// Indicates that a Save() operation has started.
/// </summary>
/// <summary>
/// Indicates that an individual entry in the archive is about to be written.
/// </summary>
/// <summary>
/// Indicates that an individual entry in the archive has just been saved.
/// </summary>
/// <summary>
/// Indicates that a Save() operation has completed.
/// </summary>
/// <summary>
/// Indicates that the zip archive has been created in a
/// temporary location during a Save() operation.
/// </summary>
/// <summary>
/// Indicates that the temporary file is about to be renamed to the final archive
/// name during a Save() operation.
/// </summary>
/// <summary>
/// Indicates that the temporary file is has just been renamed to the final archive
/// name during a Save() operation.
/// </summary>
/// <summary>
/// Indicates that the self-extracting archive has been compiled
/// during a Save() operation.
/// </summary>
/// <summary>
/// The given event is reporting the number of source bytes that have run through the compressor so far
/// during a Save() operation.
/// </summary>
/// <summary>
/// Indicates that an entry is about to be extracted.
/// </summary>
/// <summary>
/// Indicates that an entry has just been extracted.
/// </summary>
/// <summary>
///   Indicates that extraction of an entry would overwrite an existing
///   filesystem file. You must use
///   <see cref="ExtractExistingFileAction.InvokeExtractProgressEvent">
///   ExtractExistingFileAction.InvokeExtractProgressEvent</see> in the call
///   to <c>ZipEntry.Extract()</c> in order to receive this event.
/// </summary>
/// <summary>
///   The given event is reporting the number of bytes written so far for
///   the current entry during an Extract() operation.
/// </summary>
/// <summary>
/// Indicates that an ExtractAll operation is about to begin.
/// </summary>
/// <summary>
/// Indicates that an ExtractAll operation has completed.
/// </summary>
/// <summary>
/// Indicates that an error has occurred while saving a zip file.
/// This generally means the file cannot be opened, because it has been
/// removed, or because it is locked by another process.  It can also
/// mean that the file cannot be Read, because of a range lock conflict.
/// </summary>
/// <summary>
/// Provides information about the progress of a save, read, or extract operation.
/// This is a base class; you will probably use one of the classes derived from this one.
/// </summary>
/// <summary>
/// The total number of entries to be saved or extracted.
/// </summary>
/// <summary>
/// The name of the last entry saved or extracted.
/// </summary>
/// <summary>
/// In an event handler, set this to cancel the save or extract
/// operation that is in progress.
/// </summary>
/// <summary>
/// The type of event being reported.
/// </summary>
/// <summary>
/// Returns the archive name associated to this event.
/// </summary>
/// <summary>
/// The number of bytes read or written so far for this entry.
/// </summary>
/// <summary>
/// Total number of bytes that will be read or written for this entry.
/// This number will be -1 if the value cannot be determined.
/// </summary>
/// <summary>
/// Provides information about the progress of a Read operation.
/// </summary>
/// <summary>
/// Provides information about the progress of a Add operation.
/// </summary>
/// <summary>
/// Provides information about the progress of a save operation.
/// </summary>
/// <summary>
/// Constructor for the SaveProgressEventArgs.
/// </summary>
/// <param name="archiveName">the name of the zip archive.</param>
/// <param name="before">whether this is before saving the entry, or after</param>
/// <param name="entriesTotal">The total number of entries in the zip archive.</param>
/// <param name="entriesSaved">Number of entries that have been saved.</param>
/// <param name="entry">The entry involved in the event.</param>
/// <summary>
/// Number of entries saved so far.
/// </summary>
/// <summary>
/// Provides information about the progress of the extract operation.
/// </summary>
/// <summary>
/// Constructor for the ExtractProgressEventArgs.
/// </summary>
/// <param name="archiveName">the name of the zip archive.</param>
/// <param name="before">whether this is before saving the entry, or after</param>
/// <param name="entriesTotal">The total number of entries in the zip archive.</param>
/// <param name="entriesExtracted">Number of entries that have been extracted.</param>
/// <param name="entry">The entry involved in the event.</param>
/// <param name="extractLocation">The location to which entries are extracted.</param>
/// <summary>
/// Number of entries extracted so far.  This is set only if the
/// EventType is Extracting_BeforeExtractEntry or Extracting_AfterExtractEntry, and
/// the Extract() is occurring witin the scope of a call to ExtractAll().
/// </summary>
/// <summary>
/// Returns the extraction target location, a filesystem path.
/// </summary>
/// <summary>
/// Provides information about the an error that occurred while zipping.
/// </summary>
/// <summary>
/// Returns the exception that occurred, if any.
/// </summary>
/// <summary>
/// Returns the name of the file that caused the exception, if any.
/// </summary>
// Exceptions.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2008, 2009 Dino Chiesa and Microsoft Corporation.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-July-12 12:19:10>
//
// ------------------------------------------------------------------
//
// This module defines exceptions used in the class library.
//
///// <summary>
///// Base exception type for all custom exceptions in the Zip library. It acts as a marker class.
///// </summary>
//[AttributeUsage(AttributeTargets.Class)]
//public class ZipExceptionAttribute : Attribute { }
/// <summary>
/// Issued when an <c>ZipEntry.ExtractWithPassword()</c> method is invoked
/// with an incorrect password.
/// </summary>
/// <summary>
/// Default ctor.
/// </summary>
/// <summary>
/// Come on, you know how exceptions work. Why are you looking at this documentation?
/// </summary>
/// <param name="message">The message in the exception.</param>
/// <summary>
/// Come on, you know how exceptions work. Why are you looking at this documentation?
/// </summary>
/// <param name="message">The message in the exception.</param>
/// <param name="innerException">The innerException for this exception.</param>
/// <summary>
/// Come on, you know how exceptions work. Why are you looking at this documentation?
/// </summary>
/// <param name="info">The serialization info for the exception.</param>
/// <param name="context">The streaming context from which to deserialize.</param>
/// <summary>
/// Indicates that a read was attempted on a stream, and bad or incomplete data was
/// received.
/// </summary>
/// <summary>
/// Default ctor.
/// </summary>
/// <summary>
/// Come on, you know how exceptions work. Why are you looking at this documentation?
/// </summary>
/// <param name="message">The message in the exception.</param>
/// <summary>
/// Come on, you know how exceptions work. Why are you looking at this documentation?
/// </summary>
/// <param name="message">The message in the exception.</param>
/// <param name="innerException">The innerException for this exception.</param>
/// <summary>
/// Come on, you know how exceptions work. Why are you looking at this documentation?
/// </summary>
/// <param name="info">The serialization info for the exception.</param>
/// <param name="context">The streaming context from which to deserialize.</param>
/// <summary>
/// Issued when an CRC check fails upon extracting an entry from a zip archive.
/// </summary>
/// <summary>
/// Default ctor.
/// </summary>
/// <summary>
/// Come on, you know how exceptions work. Why are you looking at this documentation?
/// </summary>
/// <param name="message">The message in the exception.</param>
/// <summary>
/// Come on, you know how exceptions work. Why are you looking at this documentation?
/// </summary>
/// <param name="info">The serialization info for the exception.</param>
/// <param name="context">The streaming context from which to deserialize.</param>
/// <summary>
/// Issued when errors occur saving a self-extracting archive.
/// </summary>
/// <summary>
/// Default ctor.
/// </summary>
/// <summary>
/// Come on, you know how exceptions work. Why are you looking at this documentation?
/// </summary>
/// <param name="message">The message in the exception.</param>
/// <summary>
/// Come on, you know how exceptions work. Why are you looking at this documentation?
/// </summary>
/// <param name="info">The serialization info for the exception.</param>
/// <param name="context">The streaming context from which to deserialize.</param>
/// <summary>
/// Indicates that an operation was attempted on a ZipFile which was not possible
/// given the state of the instance. For example, if you call <c>Save()</c> on a ZipFile
/// which has no filename set, you can get this exception.
/// </summary>
/// <summary>
/// Default ctor.
/// </summary>
/// <summary>
/// Come on, you know how exceptions work. Why are you looking at this documentation?
/// </summary>
/// <param name="message">The message in the exception.</param>
/// <summary>
/// Come on, you know how exceptions work. Why are you looking at this documentation?
/// </summary>
/// <param name="message">The message in the exception.</param>
/// <param name="innerException">The innerException for this exception.</param>
/// <summary>
/// Come on, you know how exceptions work. Why are you looking at this documentation?
/// </summary>
/// <param name="info">The serialization info for the exception.</param>
/// <param name="context">The streaming context from which to deserialize.</param>
/// <summary>
/// Base class for all exceptions defined by and throw by the Zip library.
/// </summary>
/// <summary>
/// Default ctor.
/// </summary>
/// <summary>
/// Come on, you know how exceptions work. Why are you looking at this documentation?
/// </summary>
/// <param name="message">The message in the exception.</param>
/// <summary>
/// Come on, you know how exceptions work. Why are you looking at this documentation?
/// </summary>
/// <param name="message">The message in the exception.</param>
/// <param name="innerException">The innerException for this exception.</param>
/// <summary>
/// Come on, you know how exceptions work. Why are you looking at this documentation?
/// </summary>
/// <param name="info">The serialization info for the exception.</param>
/// <param name="context">The streaming context from which to deserialize.</param>
// ExtractExistingFileAction.cs
// ------------------------------------------------------------------
//
// Copyright (c)  2009 Dino Chiesa
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License. 
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs): 
// Time-stamp: <2009-August-25 08:44:37>
//
// ------------------------------------------------------------------
//
// This module defines the ExtractExistingFileAction enum
//
// 
// ------------------------------------------------------------------
/// <summary>
/// An enum for the options when extracting an entry would overwrite an existing file. 
/// </summary>
/// 
/// <remarks>
///   <para>
///     This enum describes the actions that the library can take when an
///     <c>Extract()</c> or <c>ExtractWithPassword()</c> method is called to extract an
///     entry to a filesystem, and the extraction would overwrite an existing filesystem
///     file.
///   </para>
/// </remarks>
///
/// <summary>
/// Throw an exception when extraction would overwrite an existing file. (For
/// COM clients, this is a 0 (zero).)
/// </summary>
/// <summary>
/// When extraction would overwrite an existing file, overwrite the file silently.
/// The overwrite will happen even if the target file is marked as read-only.
/// (For COM clients, this is a 1.)
/// </summary>
/// <summary>
/// When extraction would overwrite an existing file, don't overwrite the file, silently. 
/// (For COM clients, this is a 2.)
/// </summary>
/// <summary>
/// When extraction would overwrite an existing file, invoke the ExtractProgress
/// event, using an event type of <see
/// cref="ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite"/>.  In
/// this way, the application can decide, just-in-time, whether to overwrite the
/// file. For example, a GUI application may wish to pop up a dialog to allow
/// the user to choose. You may want to examine the <see
/// cref="ExtractProgressEventArgs.ExtractLocation"/> property before making
/// the decision. If, after your processing in the Extract progress event, you
/// want to NOT extract the file, set <see cref="ZipEntry.ExtractExistingFile"/>
/// on the <c>ZipProgressEventArgs.CurrentEntry</c> to <c>DoNotOverwrite</c>.
/// If you do want to extract the file, set <c>ZipEntry.ExtractExistingFile</c>
/// to <c>OverwriteSilently</c>.  If you want to cancel the Extraction, set
/// <c>ZipProgressEventArgs.Cancel</c> to true.  Cancelling differs from using
/// DoNotOverwrite in that a cancel will not extract any further entries, if
/// there are any.  (For COM clients, the value of this enum is a 3.)
/// </summary>
//#define SelectorTrace
// FileSelector.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2008-2011 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved: <2011-August-05 11:03:11>
//
// ------------------------------------------------------------------
//
// This module implements a "file selector" that finds files based on a
// set of inclusion criteria, including filename, size, file time, and
// potentially file attributes.  The criteria are given in a string with
// a simple expression language. Examples:
//
// find all .txt files:
//     name = *.txt
//
// shorthand for the above
//     *.txt
//
// all files modified after January 1st, 2009
//     mtime > 2009-01-01
//
// All .txt files modified after the first of the year
//     name = *.txt  AND  mtime > 2009-01-01
//
// All .txt files modified after the first of the year, or any file with the archive bit set
//     (name = *.txt  AND  mtime > 2009-01-01) or (attribtues = A)
//
// All .txt files or any file greater than 1mb in size
//     (name = *.txt  or  size > 1mb)
//
// and so on.
// ------------------------------------------------------------------
/// <summary>
/// Enumerates the options for a logical conjunction. This enum is intended for use
/// internally by the FileSelector class.
/// </summary>
//System.Console.WriteLine("  " + format, args);
// workitem 8245
//.Replace(@"\*", @"[^\\\.]*") // ill-conceived
// No slash in the pattern implicitly means recurse, which means compare to
// filename only, not full path.
// compare to fullpath
// 'D' = Directory, 'F' = File
// workitem 10191
// Directories don't have file attributes, so the result
// of an evaluation is always NO. This gets negated if
// the operator is NotEqualTo.
/// <summary>
///   FileSelector encapsulates logic that selects files from a source - a zip file
///   or the filesystem - based on a set of criteria.  This class is used internally
///   by the DotNetZip library, in particular for the AddSelectedFiles() methods.
///   This class can also be used independently of the zip capability in DotNetZip.
/// </summary>
///
/// <remarks>
///
/// <para>
///   The FileSelector class is used internally by the ZipFile class for selecting
///   files for inclusion into the ZipFile, when the <see
///   cref="Ionic.Zip.ZipFile.AddSelectedFiles(String,String)"/> method, or one of
///   its overloads, is called.  It's also used for the <see
///   cref="Ionic.Zip.ZipFile.ExtractSelectedEntries(String)"/> methods.  Typically, an
///   application that creates or manipulates Zip archives will not directly
///   interact with the FileSelector class.
/// </para>
///
/// <para>
///   Some applications may wish to use the FileSelector class directly, to
///   select files from disk volumes based on a set of criteria, without creating or
///   querying Zip archives.  The file selection criteria include: a pattern to
///   match the filename; the last modified, created, or last accessed time of the
///   file; the size of the file; and the attributes of the file.
/// </para>
///
/// <para>
///   Consult the documentation for <see cref="SelectionCriteria"/>
///   for more information on specifying the selection criteria.
/// </para>
///
/// </remarks>
/// <summary>
///   The default constructor.
/// </summary>
/// <remarks>
///   Typically, applications won't use this constructor.  Instead they'll
///   call the constructor that accepts a selectionCriteria string.  If you
///   use this constructor, you'll want to set the SelectionCriteria
///   property on the instance before calling SelectFiles().
/// </remarks>
/// <summary>
///   Constructor that allows the caller to specify file selection criteria.
/// </summary>
///
/// <remarks>
/// <para>
///   This constructor allows the caller to specify a set of criteria for
///   selection of files.
/// </para>
///
/// <para>
///   See <see cref="FileSelector.SelectionCriteria"/> for a description of
///   the syntax of the selectionCriteria string.
/// </para>
///
/// <para>
///   By default the FileSelector will traverse NTFS Reparse Points.  To
///   change this, use <see cref="FileSelector(String,
///   bool)">FileSelector(String, bool)</see>.
/// </para>
/// </remarks>
///
/// <param name="selectionCriteria">The criteria for file selection.</param>
/// <summary>
///   Constructor that allows the caller to specify file selection criteria.
/// </summary>
///
/// <remarks>
/// <para>
///   This constructor allows the caller to specify a set of criteria for
///   selection of files.
/// </para>
///
/// <para>
///   See <see cref="FileSelector.SelectionCriteria"/> for a description of
///   the syntax of the selectionCriteria string.
/// </para>
/// </remarks>
///
/// <param name="selectionCriteria">The criteria for file selection.</param>
/// <param name="traverseDirectoryReparsePoints">
/// whether to traverse NTFS reparse points (junctions).
/// </param>
/// <summary>
///   The string specifying which files to include when retrieving.
/// </summary>
/// <remarks>
///
/// <para>
///   Specify the criteria in statements of 3 elements: a noun, an operator,
///   and a value.  Consider the string "name != *.doc" .  The noun is
///   "name".  The operator is "!=", implying "Not Equal".  The value is
///   "*.doc".  That criterion, in English, says "all files with a name that
///   does not end in the .doc extension."
/// </para>
///
/// <para>
///   Supported nouns include "name" (or "filename") for the filename;
///   "atime", "mtime", and "ctime" for last access time, last modfied time,
///   and created time of the file, respectively; "attributes" (or "attrs")
///   for the file attributes; "size" (or "length") for the file length
///   (uncompressed); and "type" for the type of object, either a file or a
///   directory.  The "attributes", "type", and "name" nouns all support =
///   and != as operators.  The "size", "atime", "mtime", and "ctime" nouns
///   support = and !=, and &gt;, &gt;=, &lt;, &lt;= as well.  The times are
///   taken to be expressed in local time.
/// </para>
///
/// <para>
///   Specify values for the file attributes as a string with one or more of
///   the characters H,R,S,A,I,L in any order, implying file attributes of
///   Hidden, ReadOnly, System, Archive, NotContextIndexed, and ReparsePoint
///   (symbolic link) respectively.
/// </para>
///
/// <para>
///   To specify a time, use YYYY-MM-DD-HH:mm:ss or YYYY/MM/DD-HH:mm:ss as
///   the format.  If you omit the HH:mm:ss portion, it is assumed to be
///   00:00:00 (midnight).
/// </para>
///
/// <para>
///   The value for a size criterion is expressed in integer quantities of
///   bytes, kilobytes (use k or kb after the number), megabytes (m or mb),
///   or gigabytes (g or gb).
/// </para>
///
/// <para>
///   The value for a name is a pattern to match against the filename,
///   potentially including wildcards.  The pattern follows CMD.exe glob
///   rules: * implies one or more of any character, while ?  implies one
///   character.  If the name pattern contains any slashes, it is matched to
///   the entire filename, including the path; otherwise, it is matched
///   against only the filename without the path.  This means a pattern of
///   "*\*.*" matches all files one directory level deep, while a pattern of
///   "*.*" matches all files in all directories.
/// </para>
///
/// <para>
///   To specify a name pattern that includes spaces, use single quotes
///   around the pattern.  A pattern of "'* *.*'" will match all files that
///   have spaces in the filename.  The full criteria string for that would
///   be "name = '* *.*'" .
/// </para>
///
/// <para>
///   The value for a type criterion is either F (implying a file) or D
///   (implying a directory).
/// </para>
///
/// <para>
///   Some examples:
/// </para>
///
/// <list type="table">
///   <listheader>
///     <term>criteria</term>
///     <description>Files retrieved</description>
///   </listheader>
///
///   <item>
///     <term>name != *.xls </term>
///     <description>any file with an extension that is not .xls
///     </description>
///   </item>
///
///   <item>
///     <term>name = *.mp3 </term>
///     <description>any file with a .mp3 extension.
///     </description>
///   </item>
///
///   <item>
///     <term>*.mp3</term>
///     <description>(same as above) any file with a .mp3 extension.
///     </description>
///   </item>
///
///   <item>
///     <term>attributes = A </term>
///     <description>all files whose attributes include the Archive bit.
///     </description>
///   </item>
///
///   <item>
///     <term>attributes != H </term>
///     <description>all files whose attributes do not include the Hidden bit.
///     </description>
///   </item>
///
///   <item>
///     <term>mtime > 2009-01-01</term>
///     <description>all files with a last modified time after January 1st, 2009.
///     </description>
///   </item>
///
///   <item>
///     <term>ctime > 2009/01/01-03:00:00</term>
///     <description>all files with a created time after 3am (local time),
///     on January 1st, 2009.
///     </description>
///   </item>
///
///   <item>
///     <term>size > 2gb</term>
///     <description>all files whose uncompressed size is greater than 2gb.
///     </description>
///   </item>
///
///   <item>
///     <term>type = D</term>
///     <description>all directories in the filesystem. </description>
///   </item>
///
/// </list>
///
/// <para>
///   You can combine criteria with the conjunctions AND, OR, and XOR. Using
///   a string like "name = *.txt AND size &gt;= 100k" for the
///   selectionCriteria retrieves entries whose names end in .txt, and whose
///   uncompressed size is greater than or equal to 100 kilobytes.
/// </para>
///
/// <para>
///   For more complex combinations of criteria, you can use parenthesis to
///   group clauses in the boolean logic.  Absent parenthesis, the
///   precedence of the criterion atoms is determined by order of
///   appearance.  Unlike the C# language, the AND conjunction does not take
///   precendence over the logical OR.  This is important only in strings
///   that contain 3 or more criterion atoms.  In other words, "name = *.txt
///   and size &gt; 1000 or attributes = H" implies "((name = *.txt AND size
///   &gt; 1000) OR attributes = H)" while "attributes = H OR name = *.txt
///   and size &gt; 1000" evaluates to "((attributes = H OR name = *.txt)
///   AND size &gt; 1000)".  When in doubt, use parenthesis.
/// </para>
///
/// <para>
///   Using time properties requires some extra care. If you want to
///   retrieve all entries that were last updated on 2009 February 14,
///   specify "mtime &gt;= 2009-02-14 AND mtime &lt; 2009-02-15".  Read this
///   to say: all files updated after 12:00am on February 14th, until
///   12:00am on February 15th.  You can use the same bracketing approach to
///   specify any time period - a year, a month, a week, and so on.
/// </para>
///
/// <para>
///   The syntax allows one special case: if you provide a string with no
///   spaces, it is treated as a pattern to match for the filename.
///   Therefore a string like "*.xls" will be equivalent to specifying "name
///   = *.xls".  This "shorthand" notation does not work with compound
///   criteria.
/// </para>
///
/// <para>
///   There is no logic in this class that insures that the inclusion
///   criteria are internally consistent.  For example, it's possible to
///   specify criteria that says the file must have a size of less than 100
///   bytes, as well as a size that is greater than 1000 bytes.  Obviously
///   no file will ever satisfy such criteria, but this class does not check
///   for or detect such inconsistencies.
/// </para>
///
/// </remarks>
///
/// <exception cref="System.Exception">
///   Thrown in the setter if the value has an invalid syntax.
/// </exception>
/// <summary>
///  Indicates whether searches will traverse NTFS reparse points, like Junctions.
/// </summary>
// The goal here is to normalize the criterion expression. At output, in
// the transformed criterion string, every significant syntactic element
// - a property element, grouping paren for the boolean logic, operator
// ( = < > != ), conjunction, or property value - will be separated from
// its neighbors by at least one space. Thus,
//
// before                         after
// -------------------------------------------------------------------
// name=*.txt                     name = *.txt
// (size>100)AND(name=*.txt)      ( size > 100 ) AND ( name = *.txt )
//
// This is relatively straightforward using regular expression
// replacement. This method applies a distinct regex pattern and
// corresponding replacement string for each one of a number of cases:
// an open paren followed by a word; a word followed by a close-paren; a
// pair of open parens; a close paren followed by a word (which should
// then be followed by an open paren). And so on. These patterns and
// replacements are all stored in prPairs. By applying each of these
// regex replacements in turn, we get the transformed string. Easy.
//
// The resulting "normalized" criterion string, is then used as the
// subject that gets parsed, by splitting the string into tokens that
// are separated by spaces.  Here, there's a twist. The spaces within
// single-quote delimiters do not delimit distinct tokens.  So, this
// normalization method temporarily replaces those spaces with
// ASCII 6 (0x06), a control character which is not a legal
// character in a filename. The parsing logic that happens later will
// revert that change, restoring the original value of the filename
// specification.
//
// To illustrate, for a "before" string of [(size>100)AND(name='Name
// (with Parens).txt')] , the "after" string is [( size > 100 ) AND
// ( name = 'Name\u0006(with\u0006Parens).txt' )].
//
// A. opening double parens - insert a space between them
// B. closing double parens - insert a space between
// C. single open paren with a following word - insert a space between
// D. single close paren with a preceding word - insert a space between the two
// E. close paren at line start?, insert a space before the close paren
// this seems like a degenerate case.  I don't recall why it's here.
// F. a word (likely a conjunction) followed by an open paren - insert a space between
// G. single close paren followed by word - insert a paren after close paren
// H. insert space between = and a following single quote
//new string[] { @"(=|!=)('[^']*')", "$1 $2" },
// I. insert space between property names and the following operator
//new string[] { @"([^ ])([><(?:!=)=])", "$1 $2" },
// J. insert spaces between operators and the following values
//new string[] { @"([><(?:!=)=])([^ ])", "$1 $2" },
// K. replace fwd slash with backslash
//char caseIdx = (char)('A' + i);
// match a fwd slash, followed by an odd number of single quotes.
// This matches fwd slashes only inside a pair of single quote delimiters,
// eg, a filename.  This must be done as well as the case above, to handle
// filenames specified inside quotes as well as filenames without quotes.
// replace with backslash
// match a space, followed by an odd number of single quotes.
// This matches spaces only inside a pair of single quote delimiters.
// Replace all spaces that appear inside single quotes, with
// ascii 6.  This allows a split on spaces to get tokens in
// the expression. The split will not split any filename or
// wildcard that appears within single quotes. After tokenizing, we
// need to replace ascii 6 with ascii 32 to revert the
// spaces within quotes.
// inject spaces after open paren and before close paren, etc
// no spaces in the criteria is shorthand for filename glob
// split the expression into tokens
// handle single-quoted filespecs (used to include
// spaces in filename patterns)
// trim off leading and trailing single quotes and
// revert the control characters to spaces.
// if (m.StartsWith("'"))
//     m = m.Replace("\u0006", " ");
//Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes
// NOP
// mark the parent as current (walk up the tree)
// the conjunction is no longer pending
// not sure?
/// <summary>
/// Returns a string representation of the FileSelector object.
/// </summary>
/// <returns>The string representation of the boolean logic statement of the file
/// selection criteria for this instance. </returns>
// dinoch - Thu, 11 Feb 2010  18:34
/// <summary>
///   Returns the names of the files in the specified directory
///   that fit the selection criteria specified in the FileSelector.
/// </summary>
///
/// <remarks>
///   This is equivalent to calling <see cref="SelectFiles(String, bool)"/>
///   with recurseDirectories = false.
/// </remarks>
///
/// <param name="directory">
///   The name of the directory over which to apply the FileSelector
///   criteria.
/// </param>
///
/// <returns>
///   A collection of strings containing fully-qualified pathnames of files
///   that match the criteria specified in the FileSelector instance.
/// </returns>
/// <summary>
///   Returns the names of the files in the specified directory that fit the
///   selection criteria specified in the FileSelector, optionally recursing
///   through subdirectories.
/// </summary>
///
/// <remarks>
///   This method applies the file selection criteria contained in the
///   FileSelector to the files contained in the given directory, and
///   returns the names of files that conform to the criteria.
/// </remarks>
///
/// <param name="directory">
///   The name of the directory over which to apply the FileSelector
///   criteria.
/// </param>
///
/// <param name="recurseDirectories">
///   Whether to recurse through subdirectories when applying the file
///   selection criteria.
/// </param>
///
/// <returns>
///   A collection of strings containing fully-qualified pathnames of files
///   that match the criteria specified in the FileSelector instance.
/// </returns>
// add the files:
// add the subdirectories:
// workitem 10191
// can get System.UnauthorizedAccessException here
/// <summary>
/// Summary description for EnumUtil.
/// </summary>
/// <summary>
///   Returns the value of the DescriptionAttribute if the specified Enum
///   value has one.  If not, returns the ToString() representation of the
///   Enum value.
/// </summary>
/// <param name="value">The Enum to get the description for</param>
/// <returns></returns>
/// <summary>
///   Converts the string representation of the name or numeric value of one
///   or more enumerated constants to an equivalent enumerated object.
///   Note: use the DescriptionAttribute on enum values to enable this.
/// </summary>
/// <param name="enumType">The System.Type of the enumeration.</param>
/// <param name="stringRepresentation">
///   A string containing the name or value to convert.
/// </param>
/// <returns></returns>
/// <summary>
///   Converts the string representation of the name or numeric value of one
///   or more enumerated constants to an equivalent enumerated object.  A
///   parameter specified whether the operation is case-sensitive.  Note:
///   use the DescriptionAttribute on enum values to enable this.
/// </summary>
/// <param name="enumType">The System.Type of the enumeration.</param>
/// <param name="stringRepresentation">
///   A string containing the name or value to convert.
/// </param>
/// <param name="ignoreCase">
///   Whether the operation is case-sensitive or not.</param>
/// <returns></returns>
// OffsetStream.cs
// ------------------------------------------------------------------
//
// Copyright (c)  2009 Dino Chiesa
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License. 
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs): 
// Time-stamp: <2009-August-27 12:50:35>
//
// ------------------------------------------------------------------
//
// This module defines logic for handling reading of zip archives embedded 
// into larger streams.  The initial position of the stream serves as
// the base offset for all future Seek() operations.
// 
// ------------------------------------------------------------------
// Shared.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2006-2011 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// Last Saved: <2011-August-02 19:41:01>
//
// ------------------------------------------------------------------
//
// This module defines some shared utility classes and methods.
//
// Created: Tue, 27 Mar 2007  15:30
//
/// <summary>
/// Collects general purpose utility methods.
/// </summary>
/// private null constructor
//private SharedUtilities() { }
// workitem 8423
/// <summary>
/// Round the given DateTime value to an even second value.
/// </summary>
///
/// <remarks>
/// <para>
/// Round up in the case of an odd second value.  The rounding does not consider
/// fractional seconds.
/// </para>
/// <para>
/// This is useful because the Zip spec allows storage of time only to the nearest
/// even second.  So if you want to compare the time of an entry in the archive with
/// it's actual time in the filesystem, you need to round the actual filesystem
/// time, or use a 2-second threshold for the comparison.
/// </para>
/// <para>
/// This is most nautrally an extension method for the DateTime class but this
/// library used to be built for .NET 2.0; This meant extension methods were
/// a no-no.
/// </para>
/// </remarks>
/// <param name="source">The DateTime value to round</param>
/// <returns>The ruonded DateTime value</returns>
// round to nearest second:
//if (source.Millisecond >= 500) dtRounded = dtRounded.AddSeconds(1);
// remove leading single dot slash
// remove intervening dot-slash
// remove double dot when preceded by a directory name
// Replace foo/anything/../bar with foo/bar
/// <summary>
/// Utility routine for transforming path names from filesystem format (on Windows that means backslashes) to
/// a format suitable for use within zipfiles. This means trimming the volume letter and colon (if any) And
/// swapping backslashes for forward slashes.
/// </summary>
/// <param name="pathName">source path.</param>
/// <returns>transformed path</returns>
// boundary case
// trim volume if necessary
// swap slashes
// trim all leading slashes
/// <summary>
/// Sanitize paths in zip files. This means making sure that relative paths in a zip file don't go outside
/// the top directory. Entries like something/../../../../Temp/evil.txt get sanitized to Temp/evil.txt
/// when extracting
/// </summary>
/// <param name="path">A path with forward slashes as directory separator</param>
/// <returns>sanitized path</returns>
//static System.Text.Encoding ibm437 = System.Text.Encoding.GetEncoding("IBM437");
/*e*/)
/*e*/)
/*e*/)
//internal static byte[] Utf8StringToByteArray(string value)
//{
//    return StringToByteArray(value, utf8);
//}
//internal static string StringFromBuffer(byte[] buf, int maxlength)
//{
//    return StringFromBuffer(buf, maxlength, ibm437);
//}
// handle the case of ill-formatted zip archives - includes a data descriptor
// when none is expected.
// advance past data descriptor - 12 bytes if not zip64
// Maybe zip64 was in use for the prior entry.
// Therefore, skip another 8 bytes.
// seek back to the first spot
/// <summary>
///   Finds a signature in the zip stream. This is useful for finding
///   the end of a zip entry, for example, or the beginning of the next ZipEntry.
/// </summary>
///
/// <remarks>
///   <para>
///     Scans through 64k at a time.
///   </para>
///
///   <para>
///     If the method fails to find the requested signature, the stream Position
///     after completion of this method is unchanged. If the method succeeds in
///     finding the requested signature, the stream position after completion is
///     direct AFTER the signature found in the stream.
///   </para>
/// </remarks>
///
/// <param name="stream">The stream to search</param>
/// <param name="SignatureToFind">The 4-byte signature to find</param>
/// <returns>The number of bytes read</returns>
//  8192;
// workitem 7711
// out of for loop
// or throw?
// subtract 4 for the signature.
// If I have a time in the .NET environment, and I want to use it for
// SetWastWriteTime() etc, then I need to adjust it for Win32.
// If I read a time from a file with GetLastWriteTime() (etc), I need
// to adjust it for display in the .NET environment.
// workitem 7074 & workitem 7170
// return a fixed date when none is supplied.
//int second = packedTime & 0x001F;
// validation and error checking.
// this is not foolproof but will catch most errors.
// workitem 8814
// my god, I can't believe how many different ways applications
// can mess up a simple date format.
// workitem 6191
//d = AdjustTime_Reverse(d);
// The time is passed in here only for purposes of writing LastModified to the
// zip archive. It should always be LocalTime, but we convert anyway.  And,
// since the time is being written out, it needs to be adjusted.
// workitem 7966
//time = AdjustTime_Forward(time);
// see http://www.vsft.com/hal/dostime.htm for the format
/// <summary>
///   Create a pseudo-random filename, suitable for use as a temporary
///   file, and open it.
/// </summary>
/// <remarks>
/// <para>
///   This method produces a filename of the form
///   DotNetZip-xxxxxxxx.tmp, where xxxxxxxx is replaced by randomly
///   chosen characters, and creates that file.
/// </para>
/// </remarks>
// workitem 9763
// http://dotnet.org.za/markn/archive/2006/04/15/51594.aspx
// try 3 times:
/// <summary>
/// Workitem 7889: handle ERROR_LOCK_VIOLATION during read
/// </summary>
/// <remarks>
/// This could be gracefully handled with an extension attribute, but
/// This assembly used to be built for .NET 2.0, so could not use
/// extension methods.
/// </remarks>
// Check if we can call GetHRForException,
// which makes unmanaged code calls.
// ERROR_LOCK_VIOLATION
// max time waited on last retry = 250 + 10*550 = 5.75s
// aggregate time waited after 10 retries: 250 + 55*550 = 30.5s
// The permission.Demand() failed. Therefore, we cannot call
// GetHRForException, and cannot do the subtle handling of
// ERROR_LOCK_VIOLATION.  Just bail.
// workitem 8009
//
// This method must remain separate.
//
// Marshal.GetHRForException() is needed to do special exception handling for
// the read.  But, that method requires UnmanagedCode permissions, and is marked
// with LinkDemand for UnmanagedCode.  In an ASP.NET medium trust environment,
// where UnmanagedCode is restricted, will generate a SecurityException at the
// time of JIT of the method that calls a method that is marked with LinkDemand
// for UnmanagedCode. The SecurityException, if it is restricted, will occur
// when this method is JITed.
//
// The Marshal.GetHRForException() is factored out of ReadWithRetry in order to
// avoid the SecurityException at JIT compile time. Because _HRForException is
// called only when the UnmanagedCode is allowed.  This means .NET never
// JIT-compiles this method when UnmanagedCode is disallowed, and thus never
// generates the JIT-compile time exception.
//
/// <summary>
///   A decorator stream. It wraps another stream, and performs bookkeeping
///   to keep track of the stream Position.
/// </summary>
/// <remarks>
///   <para>
///     In some cases, it is not possible to get the Position of a stream, let's
///     say, on a write-only output stream like ASP.NET's
///     <c>Response.OutputStream</c>, or on a different write-only stream
///     provided as the destination for the zip by the application.  In this
///     case, programmers can use this counting stream to count the bytes read
///     or written.
///   </para>
///   <para>
///     Consider the scenario of an application that saves a self-extracting
///     archive (SFX), that uses a custom SFX stub.
///   </para>
///   <para>
///     Saving to a filesystem file, the application would open the
///     filesystem file (getting a <c>FileStream</c>), save the custom sfx stub
///     into it, and then call <c>ZipFile.Save()</c>, specifying the same
///     FileStream. <c>ZipFile.Save()</c> does the right thing for the zipentry
///     offsets, by inquiring the Position of the <c>FileStream</c> before writing
///     any data, and then adding that initial offset into any ZipEntry
///     offsets in the zip directory. Everything works fine.
///   </para>
///   <para>
///     Now suppose the application is an ASPNET application and it saves
///     directly to <c>Response.OutputStream</c>. It's not possible for DotNetZip to
///     inquire the <c>Position</c>, so the offsets for the SFX will be wrong.
///   </para>
///   <para>
///     The workaround is for the application to use this class to wrap
///     <c>HttpResponse.OutputStream</c>, then write the SFX stub and the ZipFile
///     into that wrapper stream. Because <c>ZipFile.Save()</c> can inquire the
///     <c>Position</c>, it will then do the right thing with the offsets.
///   </para>
/// </remarks>
// workitem 12374: this class is now public
/// <summary>
/// The constructor.
/// </summary>
/// <param name="stream">The underlying stream</param>
/// <summary>
///   Gets the wrapped stream.
/// </summary>
/// <summary>
///   The count of bytes written out to the stream.
/// </summary>
/// <summary>
///   the count of bytes that have been read from the stream.
/// </summary>
/// <summary>
///    Adjust the byte count on the stream.
/// </summary>
///
/// <param name='delta'>
///   the number of bytes to subtract from the count.
/// </param>
///
/// <remarks>
///   <para>
///     Subtract delta from the count of bytes written to the stream.
///     This is necessary when seeking back, and writing additional data,
///     as happens in some cases when saving Zip files.
///   </para>
/// </remarks>
/// <summary>
///   The read method.
/// </summary>
/// <param name="buffer">The buffer to hold the data read from the stream.</param>
/// <param name="offset">the offset within the buffer to copy the first byte read.</param>
/// <param name="count">the number of bytes to read.</param>
/// <returns>the number of bytes read, after decryption and decompression.</returns>
/// <summary>
///   Write data into the stream.
/// </summary>
/// <param name="buffer">The buffer holding data to write to the stream.</param>
/// <param name="offset">the offset within that data array to find the first byte to write.</param>
/// <param name="count">the number of bytes to write.</param>
/// <summary>
///   Whether the stream can be read.
/// </summary>
/// <summary>
///   Whether it is possible to call Seek() on the stream.
/// </summary>
/// <summary>
///   Whether it is possible to call Write() on the stream.
/// </summary>
/// <summary>
///   Flushes the underlying stream.
/// </summary>
/// <summary>
///   The length of the underlying stream.
/// </summary>
// bytesWritten??
/// <summary>
///   Returns the sum of number of bytes written, plus the initial
///   offset before writing.
/// </summary>
/// <summary>
///   The Position of the stream.
/// </summary>
/// <summary>
///   Seek in the stream.
/// </summary>
/// <param name="offset">the offset point to seek to</param>
/// <param name="origin">the reference point from which to seek</param>
/// <returns>The new position</returns>
/// <summary>
///   Set the length of the underlying stream.  Be careful with this!
/// </summary>
///
/// <param name='value'>the length to set on the underlying stream.</param>
//#define Trace
// WinZipAes.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2011 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-July-12 13:42:06>
//
// ------------------------------------------------------------------
//
// This module defines the classes for dealing with WinZip's AES encryption,
// according to the specifications for the format available on WinZip's website.
//
// Created: January 2009
//
// ------------------------------------------------------------------
/// <summary>
///   This is a helper class supporting WinZip AES encryption.
///   This class is intended for use only by the DotNetZip library.
/// </summary>
///
/// <remarks>
///   Most uses of the DotNetZip library will not involve direct calls into
///   the WinZipAesCrypto class.  Instead, the WinZipAesCrypto class is
///   instantiated and used by the ZipEntry() class when WinZip AES
///   encryption or decryption on an entry is employed.
/// </remarks>
// from http://www.winzip.com/aes_info.htm
//
// Size(bytes)   Content
// -----------------------------------
// Variable      Salt value
// 2             Password verification value
// Variable      Encrypted file data
// 10            Authentication code
//
// ZipEntry.CompressedSize represents the size of all of those elements.
// salt size varies with key length:
//    128 bit key => 8 bytes salt
//    192 bits => 12 bytes salt
//    256 bits => 16 bytes salt
// 10 bytes after, (n-10) before the compressed data
//Console.WriteLine(" provided password: '{0}'", _Password);
// 16 or 24 or 32 ???
// read integrityCheckVector.
// caller must ensure that the file pointer is in the right spot!
// aka "authentication code"
// first N bytes of the buffer
// last N bytes of the buffer
/// <summary>
///   A stream that encrypts as it writes, or decrypts as it reads.  The
///   Crypto is AES in CTR (counter) mode, which is compatible with the AES
///   encryption employed by WinZip 12.0.
/// </summary>
/// <remarks>
///   <para>
///     The AES/CTR encryption protocol used by WinZip works like this:
///
///       - start with a counter, initialized to zero.
///
///       - to encrypt, take the data by 16-byte blocks. For each block:
///         - apply the transform to the counter
///         - increement the counter
///         - XOR the result of the transform with the plaintext to
///           get the ciphertext.
///         - compute the mac on the encrypted bytes
///       - when finished with all blocks, store the computed MAC.
///
///       - to decrypt, take the data by 16-byte blocks. For each block:
///         - compute the mac on the encrypted bytes,
///         - apply the transform to the counter
///         - increement the counter
///         - XOR the result of the transform with the ciphertext to
///           get the plaintext.
///       - when finished with all blocks, compare the computed MAC against
///         the stored MAC
///
///   </para>
/// </remarks>
//
// I've had a problem when wrapping a WinZipAesCipherStream inside
// a DeflateStream. Calling Read() on the DeflateStream results in
// a Read() on the WinZipAesCipherStream, but the buffer is larger
// than the total size of the encrypted data, and larger than the
// initial Read() on the DeflateStream!  When the encrypted
// bytestream is embedded within a larger stream (As in a zip
// archive), the Read() doesn't fail with EOF.  This causes bad
// data to be returned, and it messes up the MAC.
// This field is used to provide a hard-stop to the size of
// data that can be read from the stream.  In Read(), if the buffer or
// read request goes beyond the stop, we truncate it.
/// <summary>
/// The constructor.
/// </summary>
/// <param name="s">The underlying stream</param>
/// <param name="mode">To either encrypt or decrypt.</param>
/// <param name="cryptoParams">The pre-initialized WinZipAesCrypto object.</param>
/// <param name="length">The maximum number of bytes to read from the stream.</param>
// don't read beyond this limit!
//Console.WriteLine("max length of AES stream: {0}", _length);
// 128, 192, 256
// all zeroes
// Create an ENCRYPTOR, regardless whether doing decryption or encryption.
// It is reflexive.
// update the counter
// Determine if this is the final block
// offset
// offset
// When I wrap a WinZipAesStream in a DeflateStream, the
// DeflateStream asks its captive to read 4k blocks, even if the
// encrypted bytestream is smaller than that.  This is a way to
// limit the number of bytes read.
// EOF
/// <summary>
/// Returns the final HMAC-SHA1-80 for the data that was encrypted.
/// </summary>
// special-case zero-byte files
// Must call ComputeHash on an empty byte array when no data
// has run through the MAC.
// fall through
// For proper AES encryption, an AES encryptor application calls
// TransformBlock repeatedly for all 16-byte blocks except the
// last. For the last block, it then calls TransformFinalBlock().
//
// This class is a stream that encrypts via Write().  But, it's not
// possible to recognize which are the "last" bytes from within the call
// to Write(). The caller can call Write() several times in succession,
// with varying buffers. This class only "knows" that the last bytes
// have been written when the app calls Close().
//
// Therefore, this class buffers writes: After completion every Write(),
// a 16-byte "pending" block (_PendingWriteBlock) must hold between 1
// and 16 bytes, which will be used in TransformFinalBlock if the app
// calls Close() immediately thereafter. Also, every write must
// transform any pending bytes, before transforming the data passed in
// to the current call.
//
// In operation, after the first call to Write() and before the call to
// Close(), one full or partial block of bytes is always available,
// pending.  At time of Close(), this class calls
// WriteTransformFinalBlock() to flush the pending bytes.
//
// This approach works whether the caller writes in odd-sized batches,
// for example 5000 bytes, or in batches that are neat multiples of the
// blocksize (16).
//
// Logicaly, what we do is this:
//
//  1. if there are fewer than 16 bytes (pending + current), then
//     just copy them into th pending buffer and return.
//
//  2. there are more than 16 bytes to write. So, take the leading slice
//     of bytes from the current buffer, enough to fill the pending
//     buffer. Transform the pending block, and write it out.
//
//  3. Take the trailing slice of bytes (a full block or a partial block),
//     and copy it to the pending block for next time.
//
//  4. transform and write all the other blocks, the middle slice.
//
// There are 16 or fewer bytes, so just buffer the bytes.
// At this point, _PendingWriteBlock contains up to
// BLOCK_SIZE_IN_BYTES bytes, and _pendingCount ranges from 0 to
// BLOCK_SIZE_IN_BYTES. We don't want to xform+write them yet,
// because this may have been the last block.  The last block gets
// written at Close().
// We know there are at least 17 bytes, counting those in the current
// buffer, along with the (possibly empty) pending block.
// workitem 12815
//
// xform chunkwise ... Cannot transform in place using the original
// buffer because that is user-maintained.
// We have more than one block of data to write, therefore it is safe
// to xform+write.
// fillCount is possibly zero here. That happens when the pending
// buffer held 16 bytes (one complete block) before this call to
// Write.
// adjust counts:
// xform and write:
// At this point _PendingWriteBlock is empty, and bytesRemaining is
// always greater than 0.
// Now, xform N blocks, where N = floor((bytesRemaining-1)/16).  If
// writing 32 bytes, then xform 1 block, and stage the remaining 16.  If
// writing 10037 bytes, xform 627 blocks of 16 bytes, then stage the
// remaining 5 bytes.
// _pendingCount is ALWAYS between 1 and 16.
// Put the last _pendingCount bytes into the pending block.
// will be true after the loop
// now, transform all the full blocks preceding that.
// bytesRemaining is always a multiple of 16 .
/// <summary>
///   Close the stream.
/// </summary>
// In the degenerate case, no bytes have been written to the
// stream at all.  Need to check here, and NOT emit the
// final block if Write has not been called.
/// <summary>
/// Returns true if the stream can be read.
/// </summary>
/// <summary>
/// Always returns false.
/// </summary>
/// <summary>
/// Returns true if the CryptoMode is Encrypt.
/// </summary>
/// <summary>
/// Flush the content in the stream.
/// </summary>
/// <summary>
/// Getting this property throws a NotImplementedException.
/// </summary>
/// <summary>
/// Getting or Setting this property throws a NotImplementedException.
/// </summary>
/// <summary>
/// This method throws a NotImplementedException.
/// </summary>
/// <summary>
/// This method throws a NotImplementedException.
/// </summary>
// ZipConstants.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2006, 2007, 2008, 2009 Dino Chiesa and Microsoft Corporation.  
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License. 
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs): 
// Time-stamp: <2009-August-27 23:22:32>
//
// ------------------------------------------------------------------
//
// This module defines a few constants that are used in the project. 
//
// ------------------------------------------------------------------
// These are dictated by the Zip Spec.See APPNOTE.txt
// 128, 192, 256
// ???
// ZipCrypto.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2008, 2009, 2011 Dino Chiesa
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-July-28 06:30:59>
//
// ------------------------------------------------------------------
//
// This module provides the implementation for "traditional" Zip encryption.
//
// Created Tue Apr 15 17:39:56 2008
//
// ------------------------------------------------------------------
/// <summary>
///   This class implements the "traditional" or "classic" PKZip encryption,
///   which today is considered to be weak. On the other hand it is
///   ubiquitous. This class is intended for use only by the DotNetZip
///   library.
/// </summary>
///
/// <remarks>
///   Most uses of the DotNetZip library will not involve direct calls into
///   the ZipCrypto class.  Instead, the ZipCrypto class is instantiated and
///   used by the ZipEntry() class when encryption or decryption on an entry
///   is employed.  If for some reason you really wanted to use a weak
///   encryption algorithm in some other application, you might use this
///   library.  But you would be much better off using one of the built-in
///   strong encryption libraries in the .NET Framework, like the AES
///   algorithm or SHA.
/// </remarks>
/// <summary>
///   The default constructor for ZipCrypto.
/// </summary>
///
/// <remarks>
///   This class is intended for internal use by the library only. It's
///   probably not useful to you. Seriously.  Stop reading this
///   documentation.  It's a waste of your time.  Go do something else.
///   Check the football scores. Go get an ice cream with a friend.
///   Seriously.
/// </remarks>
///
// Decrypt the header.  This has a side effect of "further initializing the
// encryption keys" in the traditional zip encryption.
// CRC check
// According to the pkzip spec, the final byte in the decrypted header
// is the highest-order byte in the CRC. We check it here.
// In the case that bit 3 of the general purpose bit flag is set to
// indicate the presence of an 'Extended File Header' or a 'data
// descriptor' (signature 0x08074b50), the last byte of the decrypted
// header is sometimes compared with the high-order byte of the
// lastmodified time, rather than the high-order byte of the CRC, to
// verify the password.
//
// This is not documented in the PKWare Appnote.txt.  It was
// discovered this by analysis of the Crypt.c source file in the
// InfoZip library http://www.info-zip.org/pub/infozip/
//
// The reason for this is that the CRC for a file cannot be known
// until the entire contents of the file have been streamed. This
// means a tool would have to read the file content TWICE in its
// entirety in order to perform PKZIP encryption - once to compute
// the CRC, and again to actually encrypt.
//
// This is so important for performance that using the timeblob as
// the verification should be the standard practice for DotNetZip
// when using PKZIP encryption. This implies that bit 3 must be
// set. The downside is that some tools still cannot cope with ZIP
// files that use bit 3.  Therefore, DotNetZip DOES NOT force bit 3
// when PKZIP encryption is in use, and instead, reads the stream
// twice.
//
// We have a good password.
// A-OK
/// <summary>
/// From AppNote.txt:
/// unsigned char decrypt_byte()
///     local unsigned short temp
///     temp :=- Key(2) | 2
///     decrypt_byte := (temp * (temp ^ 1)) bitshift-right 8
/// end decrypt_byte
/// </summary>
// Decrypting:
// From AppNote.txt:
// loop for i from 0 to 11
//     C := buffer(i) ^ decrypt_byte()
//     update_keys(C)
//     buffer(i) := C
// end loop
/// <summary>
///   Call this method on a cipher text to render the plaintext. You must
///   first initialize the cipher with a call to InitCipher.
/// </summary>
///
/// <example>
///   <code>
///     var cipher = new ZipCrypto();
///     cipher.InitCipher(Password);
///     // Decrypt the header.  This has a side effect of "further initializing the
///     // encryption keys" in the traditional zip encryption.
///     byte[] DecryptedMessage = cipher.DecryptMessage(EncryptedMessage);
///   </code>
/// </example>
///
/// <param name="cipherText">The encrypted buffer.</param>
/// <param name="length">
///   The number of bytes to encrypt.
///   Should be less than or equal to CipherText.Length.
/// </param>
///
/// <returns>The plaintext.</returns>
/// <summary>
///   This is the converse of DecryptMessage.  It encrypts the plaintext
///   and produces a ciphertext.
/// </summary>
///
/// <param name="plainText">The plain text buffer.</param>
///
/// <param name="length">
///   The number of bytes to encrypt.
///   Should be less than or equal to plainText.Length.
/// </param>
///
/// <returns>The ciphertext.</returns>
/// <summary>
///   This initializes the cipher with the given password.
///   See AppNote.txt for details.
/// </summary>
///
/// <param name="passphrase">
///   The passphrase for encrypting or decrypting with this cipher.
/// </param>
///
/// <remarks>
/// <code>
/// Step 1 - Initializing the encryption keys
/// -----------------------------------------
/// Start with these keys:
/// Key(0) := 305419896 (0x12345678)
/// Key(1) := 591751049 (0x23456789)
/// Key(2) := 878082192 (0x34567890)
///
/// Then, initialize the keys with a password:
///
/// loop for i from 0 to length(password)-1
///     update_keys(password(i))
/// end loop
///
/// Where update_keys() is defined as:
///
/// update_keys(char):
///   Key(0) := crc32(key(0),char)
///   Key(1) := Key(1) + (Key(0) bitwiseAND 000000ffH)
///   Key(1) := Key(1) * 134775813 + 1
///   Key(2) := crc32(key(2),key(1) rightshift 24)
/// end update_keys
///
/// Where crc32(old_crc,char) is a routine that given a CRC value and a
/// character, returns an updated CRC value after applying the CRC-32
/// algorithm described elsewhere in this document.
///
/// </code>
///
/// <para>
///   After the keys are initialized, then you can use the cipher to
///   encrypt the plaintext.
/// </para>
///
/// <para>
///   Essentially we encrypt the password with the keys, then discard the
///   ciphertext for the password. This initializes the keys for later use.
/// </para>
///
/// </remarks>
///// <summary>
///// The byte array representing the seed keys used.
///// Get this after calling InitCipher.  The 12 bytes represents
///// what the zip spec calls the "EncryptionHeader".
///// </summary>
//public byte[] KeyHeader
//{
//    get
//    {
//        byte[] result = new byte[12];
//        result[0] = (byte)(_Keys[0] & 0xff);
//        result[1] = (byte)((_Keys[0] >> 8) & 0xff);
//        result[2] = (byte)((_Keys[0] >> 16) & 0xff);
//        result[3] = (byte)((_Keys[0] >> 24) & 0xff);
//        result[4] = (byte)(_Keys[1] & 0xff);
//        result[5] = (byte)((_Keys[1] >> 8) & 0xff);
//        result[6] = (byte)((_Keys[1] >> 16) & 0xff);
//        result[7] = (byte)((_Keys[1] >> 24) & 0xff);
//        result[8] = (byte)(_Keys[2] & 0xff);
//        result[9] = (byte)((_Keys[2] >> 8) & 0xff);
//        result[10] = (byte)((_Keys[2] >> 16) & 0xff);
//        result[11] = (byte)((_Keys[2] >> 24) & 0xff);
//        return result;
//    }
//}
// private fields for the crypto stuff:
/// <summary>
///   A Stream for reading and concurrently decrypting data from a zip file,
///   or for writing and concurrently encrypting data to a zip file.
/// </summary>
/// <summary>  The constructor. </summary>
/// <param name="s">The underlying stream</param>
/// <param name="mode">To either encrypt or decrypt.</param>
/// <param name="cipher">The pre-initialized ZipCrypto object.</param>
// workitem 7696
//throw new NotSupportedException();
// ZipDirEntry.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2006-2011 Dino Chiesa .
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-July-11 12:03:03>
//
// ------------------------------------------------------------------
//
// This module defines members of the ZipEntry class for reading the
// Zip file central directory.
//
// Created: Tue, 27 Mar 2007  15:30
//
// ------------------------------------------------------------------
/// <summary>
/// True if the referenced entry is a directory.
/// </summary>
// __FileDataPosition is the position of the file data for an entry.
// It is _RelativeOffsetOfLocalHeader + size of local header.
// We cannot know the __FileDataPosition until we read the local
// header.
// The local header is not necessarily the same length as the record
// in the central directory.
// Set to -1, to indicate we need to read this later.
// set _LengthOfHeader to 0, to indicate we need to read later.
// reset the copy counter because we've got a good entry now
/// <summary>
/// Provides a human-readable string with information about the ZipEntry.
/// </summary>
// workitem 10330
// there is no extension
//System.Console.WriteLine("HasExtension");
//System.Console.WriteLine("returning f({0})", f);
/// <summary>
///   Reads one entry from the zip directory structure in the zip file.
/// </summary>
///
/// <param name="zf">
///   The zipfile for which a directory entry will be read.  From this param, the
///   method gets the ReadStream and the expected text encoding
///   (ProvisionalAlternateEncoding) which is used if the entry is not marked
///   UTF-8.
/// </param>
///
/// <param name="previouslySeen">
///   a list of previously seen entry names; used to prevent duplicates.
/// </param>
///
/// <returns>the entry read from the archive.</returns>
// return null if this is not a local file header signature
// Getting "not a ZipDirEntry signature" here is not always wrong or an
// error.  This can happen when walking through a zipfile.  After the
// last ZipDirEntry, we expect to read an
// EndOfCentralDirectorySignature.  When we get this is how we know
// we've reached the end of the central directory.
// workitem 8299
// preserve
// workitem 7801
// UTF-8 is in use
// workitem 10330
// insure unique entry names
// may append a slash to filename if nec.
// workitem 6898
// this may change after processing the Extra field
// Console.WriteLine("  Input uses Z64?:      {0}", zde._InputUsesZip64);
// we've processed the extra field, so we know the encryption method is set now.
// the "encryption header" of 12 bytes precedes the file data
// tally the trailing descriptor
// sig, CRC, Comp and Uncomp sizes
// workitem 12744
// UTF-8 is in use
//zde._LengthOfDirEntry = bytesRead;
/// <summary>
/// Returns true if the passed-in value is a valid signature for a ZipDirEntry.
/// </summary>
/// <param name="signature">the candidate 4-byte signature value.</param>
/// <returns>true, if the signature is valid according to the PKWare spec.</returns>
//private Int32 _LengthOfDirEntry;
// ZipEntry.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2006-2010 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-August-06 17:25:53>
//
// ------------------------------------------------------------------
//
// This module defines the ZipEntry class, which models the entries within a zip file.
//
// Created: Tue, 27 Mar 2007  15:30
//
// ------------------------------------------------------------------
/// <summary>
/// Represents a single entry in a ZipFile. Typically, applications get a ZipEntry
/// by enumerating the entries within a ZipFile, or by adding an entry to a ZipFile.
/// </summary>
// AutoDual
/// <summary>
/// Default constructor.
/// </summary>
/// <remarks>
/// Applications should never need to call this directly.  It is exposed to
/// support COM Automation environments.
/// </remarks>
/// <summary>
///   The time and date at which the file indicated by the <c>ZipEntry</c> was
///   last modified.
/// </summary>
///
/// <remarks>
/// <para>
///   The DotNetZip library sets the LastModified value for an entry, equal to
///   the Last Modified time of the file in the filesystem.  If an entry is
///   added from a stream, the library uses <c>System.DateTime.Now</c> for this
///   value, for the given entry.
/// </para>
///
/// <para>
///   This property allows the application to retrieve and possibly set the
///   LastModified value on an entry, to an arbitrary value.  <see
///   cref="System.DateTime"/> values with a <see cref="System.DateTimeKind" />
///   setting of <c>DateTimeKind.Unspecified</c> are taken to be expressed as
///   <c>DateTimeKind.Local</c>.
/// </para>
///
/// <para>
///   Be aware that because of the way <see
///   href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWare's
///   Zip specification</see> describes how times are stored in the zip file,
///   the full precision of the <c>System.DateTime</c> datatype is not stored
///   for the last modified time when saving zip files.  For more information on
///   how times are formatted, see the PKZip specification.
/// </para>
///
/// <para>
///   The actual last modified time of a file can be stored in multiple ways in
///   the zip file, and they are not mutually exclusive:
/// </para>
///
/// <list type="bullet">
///   <item>
///     In the so-called "DOS" format, which has a 2-second precision. Values
///     are rounded to the nearest even second. For example, if the time on the
///     file is 12:34:43, then it will be stored as 12:34:44. This first value
///     is accessible via the <c>LastModified</c> property. This value is always
///     present in the metadata for each zip entry.  In some cases the value is
///     invalid, or zero.
///   </item>
///
///   <item>
///     In the so-called "Windows" or "NTFS" format, as an 8-byte integer
///     quantity expressed as the number of 1/10 milliseconds (in other words
///     the number of 100 nanosecond units) since January 1, 1601 (UTC).  This
///     format is how Windows represents file times.  This time is accessible
///     via the <c>ModifiedTime</c> property.
///   </item>
///
///   <item>
///     In the "Unix" format, a 4-byte quantity specifying the number of seconds since
///     January 1, 1970 UTC.
///   </item>
///
///   <item>
///     In an older format, now deprecated but still used by some current
///     tools. This format is also a 4-byte quantity specifying the number of
///     seconds since January 1, 1970 UTC.
///   </item>
///
/// </list>
///
/// <para>
///   Zip tools and libraries will always at least handle (read or write) the
///   DOS time, and may also handle the other time formats.  Keep in mind that
///   while the names refer to particular operating systems, there is nothing in
///   the time formats themselves that prevents their use on other operating
///   systems.
/// </para>
///
/// <para>
///   When reading ZIP files, the DotNetZip library reads the Windows-formatted
///   time, if it is stored in the entry, and sets both <c>LastModified</c> and
///   <c>ModifiedTime</c> to that value. When writing ZIP files, the DotNetZip
///   library by default will write both time quantities. It can also emit the
///   Unix-formatted time if desired (See <see
///   cref="EmitTimesInUnixFormatWhenSaving"/>.)
/// </para>
///
/// <para>
///   The last modified time of the file created upon a call to
///   <c>ZipEntry.Extract()</c> may be adjusted during extraction to compensate
///   for differences in how the .NET Base Class Library deals with daylight
///   saving time (DST) versus how the Windows filesystem deals with daylight
///   saving time.  Raymond Chen <see
///   href="http://blogs.msdn.com/oldnewthing/archive/2003/10/24/55413.aspx">provides
///   some good context</see>.
/// </para>
///
/// <para>
///   In a nutshell: Daylight savings time rules change regularly.  In 2007, for
///   example, the inception week of DST changed.  In 1977, DST was in place all
///   year round. In 1945, likewise.  And so on.  Win32 does not attempt to
///   guess which time zone rules were in effect at the time in question.  It
///   will render a time as "standard time" and allow the app to change to DST
///   as necessary.  .NET makes a different choice.
/// </para>
///
/// <para>
///   Compare the output of FileInfo.LastWriteTime.ToString("f") with what you
///   see in the Windows Explorer property sheet for a file that was last
///   written to on the other side of the DST transition. For example, suppose
///   the file was last modified on October 17, 2003, during DST but DST is not
///   currently in effect. Explorer's file properties reports Thursday, October
///   17, 2003, 8:45:38 AM, but .NETs FileInfo reports Thursday, October 17,
///   2003, 9:45 AM.
/// </para>
///
/// <para>
///   Win32 says, "Thursday, October 17, 2002 8:45:38 AM PST". Note: Pacific
///   STANDARD Time. Even though October 17 of that year occurred during Pacific
///   Daylight Time, Win32 displays the time as standard time because that's
///   what time it is NOW.
/// </para>
///
/// <para>
///   .NET BCL assumes that the current DST rules were in place at the time in
///   question.  So, .NET says, "Well, if the rules in effect now were also in
///   effect on October 17, 2003, then that would be daylight time" so it
///   displays "Thursday, October 17, 2003, 9:45 AM PDT" - daylight time.
/// </para>
///
/// <para>
///   So .NET gives a value which is more intuitively correct, but is also
///   potentially incorrect, and which is not invertible. Win32 gives a value
///   which is intuitively incorrect, but is strictly correct.
/// </para>
///
/// <para>
///   Because of this funkiness, this library adds one hour to the LastModified
///   time on the extracted file, if necessary.  That is to say, if the time in
///   question had occurred in what the .NET Base Class Library assumed to be
///   DST. This assumption may be wrong given the constantly changing DST rules,
///   but it is the best we can do.
/// </para>
///
/// </remarks>
///
/// <summary>
/// Ability to set Last Modified DOS time to zero
/// (for using with EmitTimesInWindowsFormatWhenSaving+EmitTimesInUnixFormatWhenSaving setted to false)
/// some flasher hardware use as marker of first binary
/// </summary>
/// <summary>
/// Last Modified time for the file represented by the entry.
/// </summary>
///
/// <remarks>
///
/// <para>
///   This value corresponds to the "last modified" time in the NTFS file times
///   as described in <see
///   href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
///   specification</see>.  When getting this property, the value may be
///   different from <see cref="LastModified" />.  When setting the property,
///   the <see cref="LastModified"/> property also gets set, but with a lower
///   precision.
/// </para>
///
/// <para>
///   Let me explain. It's going to take a while, so get
///   comfortable. Originally, waaaaay back in 1989 when the ZIP specification
///   was originally described by the esteemed Mr. Phil Katz, the dominant
///   operating system of the time was MS-DOS. MSDOS stored file times with a
///   2-second precision, because, c'mon, <em>who is ever going to need better
///   resolution than THAT?</em> And so ZIP files, regardless of the platform on
///   which the zip file was created, store file times in exactly <see
///   href="http://www.vsft.com/hal/dostime.htm">the same format that DOS used
///   in 1989</see>.
/// </para>
///
/// <para>
///   Since then, the ZIP spec has evolved, but the internal format for file
///   timestamps remains the same.  Despite the fact that the way times are
///   stored in a zip file is rooted in DOS heritage, any program on any
///   operating system can format a time in this way, and most zip tools and
///   libraries DO - they round file times to the nearest even second and store
///   it just like DOS did 25+ years ago.
/// </para>
///
/// <para>
///   PKWare extended the ZIP specification to allow a zip file to store what
///   are called "NTFS Times" and "Unix(tm) times" for a file.  These are the
///   <em>last write</em>, <em>last access</em>, and <em>file creation</em>
///   times of a particular file. These metadata are not actually specific
///   to NTFS or Unix. They are tracked for each file by NTFS and by various
///   Unix filesystems, but they are also tracked by other filesystems, too.
///   The key point is that the times are <em>formatted in the zip file</em>
///   in the same way that NTFS formats the time (ticks since win32 epoch),
///   or in the same way that Unix formats the time (seconds since Unix
///   epoch). As with the DOS time, any tool or library running on any
///   operating system is capable of formatting a time in one of these ways
///   and embedding it into the zip file.
/// </para>
///
/// <para>
///   These extended times are higher precision quantities than the DOS time.
///   As described above, the (DOS) LastModified has a precision of 2 seconds.
///   The Unix time is stored with a precision of 1 second. The NTFS time is
///   stored with a precision of 0.0000001 seconds. The quantities are easily
///   convertible, except for the loss of precision you may incur.
/// </para>
///
/// <para>
///   A zip archive can store the {C,A,M} times in NTFS format, in Unix format,
///   or not at all.  Often a tool running on Unix or Mac will embed the times
///   in Unix format (1 second precision), while WinZip running on Windows might
///   embed the times in NTFS format (precision of of 0.0000001 seconds).  When
///   reading a zip file with these "extended" times, in either format,
///   DotNetZip represents the values with the
///   <c>ModifiedTime</c>, <c>AccessedTime</c> and <c>CreationTime</c>
///   properties on the <c>ZipEntry</c>.
/// </para>
///
/// <para>
///   While any zip application or library, regardless of the platform it
///   runs on, could use any of the time formats allowed by the ZIP
///   specification, not all zip tools or libraries do support all these
///   formats.  Storing the higher-precision times for each entry is
///   optional for zip files, and many tools and libraries don't use the
///   higher precision quantities at all. The old DOS time, represented by
///   <see cref="LastModified"/>, is guaranteed to be present, though it
///   sometimes unset.
/// </para>
///
/// <para>
///   Ok, getting back to the question about how the <c>LastModified</c>
///   property relates to this <c>ModifiedTime</c>
///   property... <c>LastModified</c> is always set, while
///   <c>ModifiedTime</c> is not. (The other times stored in the <em>NTFS
///   times extension</em>, <c>CreationTime</c> and <c>AccessedTime</c> also
///   may not be set on an entry that is read from an existing zip file.)
///   When reading a zip file, then <c>LastModified</c> takes the DOS time
///   that is stored with the file. If the DOS time has been stored as zero
///   in the zipfile, then this library will use <c>DateTime.Now</c> for the
///   <c>LastModified</c> value.  If the ZIP file was created by an evolved
///   tool, then there will also be higher precision NTFS or Unix times in
///   the zip file.  In that case, this library will read those times, and
///   set <c>LastModified</c> and <c>ModifiedTime</c> to the same value, the
///   one corresponding to the last write time of the file.  If there are no
///   higher precision times stored for the entry, then <c>ModifiedTime</c>
///   remains unset (likewise <c>AccessedTime</c> and <c>CreationTime</c>),
///   and <c>LastModified</c> keeps its DOS time.
/// </para>
///
/// <para>
///   When creating zip files with this library, by default the extended time
///   properties (<c>ModifiedTime</c>, <c>AccessedTime</c>, and
///   <c>CreationTime</c>) are set on the ZipEntry instance, and these data are
///   stored in the zip archive for each entry, in NTFS format. If you add an
///   entry from an actual filesystem file, then the entry gets the actual file
///   times for that file, to NTFS-level precision.  If you add an entry from a
///   stream, or a string, then the times get the value <c>DateTime.Now</c>.  In
///   this case <c>LastModified</c> and <c>ModifiedTime</c> will be identical,
///   to 2 seconds of precision.  You can explicitly set the
///   <c>CreationTime</c>, <c>AccessedTime</c>, and <c>ModifiedTime</c> of an
///   entry using the property setters.  If you want to set all of those
///   quantities, it's more efficient to use the <see
///   cref="SetEntryTimes(DateTime, DateTime, DateTime)"/> method.  Those
///   changes are not made permanent in the zip file until you call <see
///   cref="ZipFile.Save()"/> or one of its cousins.
/// </para>
///
/// <para>
///   When creating a zip file, you can override the default behavior of
///   this library for formatting times in the zip file, disabling the
///   embedding of file times in NTFS format or enabling the storage of file
///   times in Unix format, or both.  You may want to do this, for example,
///   when creating a zip file on Windows, that will be consumed on a Mac,
///   by an application that is not hip to the "NTFS times" format. To do
///   this, use the <see cref="EmitTimesInWindowsFormatWhenSaving"/> and
///   <see cref="EmitTimesInUnixFormatWhenSaving"/> properties.  A valid zip
///   file may store the file times in both formats.  But, there are no
///   guarantees that a program running on Mac or Linux will gracefully
///   handle the NTFS-formatted times when Unix times are present, or that a
///   non-DotNetZip-powered application running on Windows will be able to
///   handle file times in Unix format. DotNetZip will always do something
///   reasonable; other libraries or tools may not. When in doubt, test.
/// </para>
///
/// <para>
///   I'll bet you didn't think one person could type so much about time, eh?
///   And reading it was so enjoyable, too!  Well, in appreciation, <see
///   href="http://cheeso.members.winisp.net/DotNetZipDonate.aspx">maybe you
///   should donate</see>?
/// </para>
/// </remarks>
///
/// <seealso cref="AccessedTime"/>
/// <seealso cref="CreationTime"/>
/// <seealso cref="Ionic.Zip.ZipEntry.LastModified"/>
/// <seealso cref="SetEntryTimes"/>
/// <summary>
/// Last Access time for the file represented by the entry.
/// </summary>
/// <remarks>
/// This value may or may not be meaningful.  If the <c>ZipEntry</c> was read from an existing
/// Zip archive, this information may not be available. For an explanation of why, see
/// <see cref="ModifiedTime"/>.
/// </remarks>
/// <seealso cref="ModifiedTime"/>
/// <seealso cref="CreationTime"/>
/// <seealso cref="SetEntryTimes"/>
/// <summary>
/// The file creation time for the file represented by the entry.
/// </summary>
///
/// <remarks>
/// This value may or may not be meaningful.  If the <c>ZipEntry</c> was read
/// from an existing zip archive, and the creation time was not set on the entry
/// when the zip file was created, then this property may be meaningless. For an
/// explanation of why, see <see cref="ModifiedTime"/>.
/// </remarks>
/// <seealso cref="ModifiedTime"/>
/// <seealso cref="AccessedTime"/>
/// <seealso cref="SetEntryTimes"/>
/// <summary>
///   Sets the NTFS Creation, Access, and Modified times for the given entry.
/// </summary>
///
/// <remarks>
/// <para>
///   When adding an entry from a file or directory, the Creation, Access, and
///   Modified times for the given entry are automatically set from the
///   filesystem values. When adding an entry from a stream or string, the
///   values are implicitly set to DateTime.Now.  The application may wish to
///   set these values to some arbitrary value, before saving the archive, and
///   can do so using the various setters.  If you want to set all of the times,
///   this method is more efficient.
/// </para>
///
/// <para>
///   The values you set here will be retrievable with the <see
///   cref="ModifiedTime"/>, <see cref="CreationTime"/> and <see
///   cref="AccessedTime"/> properties.
/// </para>
///
/// <para>
///   When this method is called, if both <see
///   cref="EmitTimesInWindowsFormatWhenSaving"/> and <see
///   cref="EmitTimesInUnixFormatWhenSaving"/> are false, then the
///   <c>EmitTimesInWindowsFormatWhenSaving</c> flag is automatically set.
/// </para>
///
/// <para>
///   DateTime values provided here without a DateTimeKind are assumed to be Local Time.
/// </para>
///
/// </remarks>
/// <param name="created">the creation time of the entry.</param>
/// <param name="accessed">the last access time of the entry.</param>
/// <param name="modified">the last modified time of the entry.</param>
///
/// <seealso cref="EmitTimesInWindowsFormatWhenSaving" />
/// <seealso cref="EmitTimesInUnixFormatWhenSaving" />
/// <seealso cref="AccessedTime"/>
/// <seealso cref="CreationTime"/>
/// <seealso cref="ModifiedTime"/>
/// <summary>
///   Specifies whether the Creation, Access, and Modified times for the given
///   entry will be emitted in "Windows format" when the zip archive is saved.
/// </summary>
///
/// <remarks>
/// <para>
///   An application creating a zip archive can use this flag to explicitly
///   specify that the file times for the entry should or should not be stored
///   in the zip archive in the format used by Windows. The default value of
///   this property is <c>true</c>.
/// </para>
///
/// <para>
///   When adding an entry from a file or directory, the Creation (<see
///   cref="CreationTime"/>), Access (<see cref="AccessedTime"/>), and Modified
///   (<see cref="ModifiedTime"/>) times for the given entry are automatically
///   set from the filesystem values. When adding an entry from a stream or
///   string, all three values are implicitly set to DateTime.Now.  Applications
///   can also explicitly set those times by calling <see
///   cref="SetEntryTimes(DateTime, DateTime, DateTime)" />.
/// </para>
///
/// <para>
///   <see
///   href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
///   zip specification</see> describes multiple ways to format these times in a
///   zip file. One is the format Windows applications normally use: 100ns ticks
///   since Jan 1, 1601 UTC.  The other is a format Unix applications typically
///   use: seconds since January 1, 1970 UTC.  Each format can be stored in an
///   "extra field" in the zip entry when saving the zip archive. The former
///   uses an extra field with a Header Id of 0x000A, while the latter uses a
///   header ID of 0x5455.
/// </para>
///
/// <para>
///   Not all zip tools and libraries can interpret these fields.  Windows
///   compressed folders is one that can read the Windows Format timestamps,
///   while I believe the <see href="http://www.info-zip.org/">Infozip</see>
///   tools can read the Unix format timestamps. Although the time values are
///   easily convertible, subject to a loss of precision, some tools and
///   libraries may be able to read only one or the other. DotNetZip can read or
///   write times in either or both formats.
/// </para>
///
/// <para>
///   The times stored are taken from <see cref="ModifiedTime"/>, <see
///   cref="AccessedTime"/>, and <see cref="CreationTime"/>.
/// </para>
///
/// <para>
///   This property is not mutually exclusive from the <see
///   cref="ZipEntry.EmitTimesInUnixFormatWhenSaving"/> property.  It is
///   possible that a zip entry can embed the timestamps in both forms, one
///   form, or neither.  But, there are no guarantees that a program running on
///   Mac or Linux will gracefully handle NTFS Formatted times, or that a
///   non-DotNetZip-powered application running on Windows will be able to
///   handle file times in Unix format. When in doubt, test.
/// </para>
///
/// <para>
///   Normally you will use the <see
///   cref="ZipFile.EmitTimesInWindowsFormatWhenSaving">ZipFile.EmitTimesInWindowsFormatWhenSaving</see>
///   property, to specify the behavior for all entries in a zip, rather than
///   the property on each individual entry.
/// </para>
///
/// </remarks>
///
/// <seealso cref="SetEntryTimes(DateTime, DateTime, DateTime)"/>
/// <seealso cref="EmitTimesInUnixFormatWhenSaving"/>
/// <seealso cref="CreationTime"/>
/// <seealso cref="AccessedTime"/>
/// <seealso cref="ModifiedTime"/>
/// <summary>
///   Specifies whether the Creation, Access, and Modified times for the given
///   entry will be emitted in &quot;Unix(tm) format&quot; when the zip archive is saved.
/// </summary>
///
/// <remarks>
/// <para>
///   An application creating a zip archive can use this flag to explicitly
///   specify that the file times for the entry should or should not be stored
///   in the zip archive in the format used by Unix. By default this flag is
///   <c>false</c>, meaning the Unix-format times are not stored in the zip
///   archive.
/// </para>
///
/// <para>
///   When adding an entry from a file or directory, the Creation (<see
///   cref="CreationTime"/>), Access (<see cref="AccessedTime"/>), and Modified
///   (<see cref="ModifiedTime"/>) times for the given entry are automatically
///   set from the filesystem values. When adding an entry from a stream or
///   string, all three values are implicitly set to DateTime.Now.  Applications
///   can also explicitly set those times by calling <see
///   cref="SetEntryTimes(DateTime, DateTime, DateTime)"/>.
/// </para>
///
/// <para>
///   <see
///   href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
///   zip specification</see> describes multiple ways to format these times in a
///   zip file. One is the format Windows applications normally use: 100ns ticks
///   since Jan 1, 1601 UTC.  The other is a format Unix applications typically
///   use: seconds since Jan 1, 1970 UTC.  Each format can be stored in an
///   "extra field" in the zip entry when saving the zip archive. The former
///   uses an extra field with a Header Id of 0x000A, while the latter uses a
///   header ID of 0x5455.
/// </para>
///
/// <para>
///   Not all tools and libraries can interpret these fields.  Windows
///   compressed folders is one that can read the Windows Format timestamps,
///   while I believe the <see href="http://www.info-zip.org/">Infozip</see>
///   tools can read the Unix format timestamps. Although the time values are
///   easily convertible, subject to a loss of precision, some tools and
///   libraries may be able to read only one or the other. DotNetZip can read or
///   write times in either or both formats.
/// </para>
///
/// <para>
///   The times stored are taken from <see cref="ModifiedTime"/>, <see
///   cref="AccessedTime"/>, and <see cref="CreationTime"/>.
/// </para>
///
/// <para>
///   This property is not mutually exclusive from the <see
///   cref="ZipEntry.EmitTimesInWindowsFormatWhenSaving"/> property.  It is
///   possible that a zip entry can embed the timestamps in both forms, one
///   form, or neither.  But, there are no guarantees that a program running on
///   Mac or Linux will gracefully handle NTFS Formatted times, or that a
///   non-DotNetZip-powered application running on Windows will be able to
///   handle file times in Unix format. When in doubt, test.
/// </para>
///
/// <para>
///   Normally you will use the <see
///   cref="ZipFile.EmitTimesInUnixFormatWhenSaving">ZipFile.EmitTimesInUnixFormatWhenSaving</see>
///   property, to specify the behavior for all entries, rather than the
///   property on each individual entry.
/// </para>
/// </remarks>
///
/// <seealso cref="SetEntryTimes(DateTime, DateTime, DateTime)"/>
/// <seealso cref="EmitTimesInWindowsFormatWhenSaving"/>
/// <seealso cref="ZipFile.EmitTimesInUnixFormatWhenSaving"/>
/// <seealso cref="CreationTime"/>
/// <seealso cref="AccessedTime"/>
/// <seealso cref="ModifiedTime"/>
/// <summary>
/// The type of timestamp attached to the ZipEntry.
/// </summary>
///
/// <remarks>
/// This property is valid only for a ZipEntry that was read from a zip archive.
/// It indicates the type of timestamp attached to the entry.
/// </remarks>
///
/// <seealso cref="EmitTimesInWindowsFormatWhenSaving"/>
/// <seealso cref="EmitTimesInUnixFormatWhenSaving"/>
/// <summary>
///   The file attributes for the entry.
/// </summary>
///
/// <remarks>
///
/// <para>
///   The <see cref="System.IO.FileAttributes">attributes</see> in NTFS include
///   ReadOnly, Archive, Hidden, System, and Indexed.  When adding a
///   <c>ZipEntry</c> to a ZipFile, these attributes are set implicitly when
///   adding an entry from the filesystem.  When adding an entry from a stream
///   or string, the Attributes are not set implicitly.  Regardless of the way
///   an entry was added to a <c>ZipFile</c>, you can set the attributes
///   explicitly if you like.
/// </para>
///
/// <para>
///   When reading a <c>ZipEntry</c> from a <c>ZipFile</c>, the attributes are
///   set according to the data stored in the <c>ZipFile</c>. If you extract the
///   entry from the archive to a filesystem file, DotNetZip will set the
///   attributes on the resulting file accordingly.
/// </para>
///
/// <para>
///   The attributes can be set explicitly by the application.  For example the
///   application may wish to set the <c>FileAttributes.ReadOnly</c> bit for all
///   entries added to an archive, so that on unpack, this attribute will be set
///   on the extracted file.  Any changes you make to this property are made
///   permanent only when you call a <c>Save()</c> method on the <c>ZipFile</c>
///   instance that contains the ZipEntry.
/// </para>
///
/// <para>
///   For example, an application may wish to zip up a directory and set the
///   ReadOnly bit on every file in the archive, so that upon later extraction,
///   the resulting files will be marked as ReadOnly.  Not every extraction tool
///   respects these attributes, but if you unpack with DotNetZip, as for
///   example in a self-extracting archive, then the attributes will be set as
///   they are stored in the <c>ZipFile</c>.
/// </para>
///
/// <para>
///   These attributes may not be interesting or useful if the resulting archive
///   is extracted on a non-Windows platform.  How these attributes get used
///   upon extraction depends on the platform and tool used.
/// </para>
///
/// </remarks>
// workitem 7071
// Since the application is explicitly setting the attributes, overwriting
// whatever was there, we will explicitly set the Version made by field.
// workitem 7926 - "version made by" OS should be zero for compat with WinZip
// v4.5 of the spec
/// <summary>
///   The name of the filesystem file, referred to by the ZipEntry.
/// </summary>
///
/// <remarks>
///  <para>
///    This property specifies the thing-to-be-zipped on disk, and is set only
///    when the <c>ZipEntry</c> is being created from a filesystem file.  If the
///    <c>ZipFile</c> is instantiated by reading an existing .zip archive, then
///    the LocalFileName will be <c>null</c> (<c>Nothing</c> in VB).
///  </para>
///
///  <para>
///    When it is set, the value of this property may be different than <see
///    cref="FileName"/>, which is the path used in the archive itself.  If you
///    call <c>Zip.AddFile("foop.txt", AlternativeDirectory)</c>, then the path
///    used for the <c>ZipEntry</c> within the zip archive will be different
///    than this path.
///  </para>
///
///  <para>
///   If the entry is being added from a stream, then this is null (Nothing in VB).
///  </para>
///
/// </remarks>
/// <seealso cref="FileName"/>
/// <summary>
///   The name of the file contained in the ZipEntry.
/// </summary>
///
/// <remarks>
///
/// <para>
///   This is the name of the entry in the <c>ZipFile</c> itself.  When creating
///   a zip archive, if the <c>ZipEntry</c> has been created from a filesystem
///   file, via a call to <see cref="ZipFile.AddFile(String,String)"/> or <see
///   cref="ZipFile.AddItem(String,String)"/>, or a related overload, the value
///   of this property is derived from the name of that file. The
///   <c>FileName</c> property does not include drive letters, and may include a
///   different directory path, depending on the value of the
///   <c>directoryPathInArchive</c> parameter used when adding the entry into
///   the <c>ZipFile</c>.
/// </para>
///
/// <para>
///   In some cases there is no related filesystem file - for example when a
///   <c>ZipEntry</c> is created using <see cref="ZipFile.AddEntry(string,
///   string)"/> or one of the similar overloads.  In this case, the value of
///   this property is derived from the fileName and the directory path passed
///   to that method.
/// </para>
///
/// <para>
///   When reading a zip file, this property takes the value of the entry name
///   as stored in the zip file. If you extract such an entry, the extracted
///   file will take the name given by this property.
/// </para>
///
/// <para>
///   Applications can set this property when creating new zip archives or when
///   reading existing archives. When setting this property, the actual value
///   that is set will replace backslashes with forward slashes, in accordance
///   with <see
///   href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
///   specification</see>, for compatibility with Unix(tm) and ... get
///   this.... Amiga!
/// </para>
///
/// <para>
///   If an application reads a <c>ZipFile</c> via <see
///   cref="ZipFile.Read(String)"/> or a related overload, and then explicitly
///   sets the FileName on an entry contained within the <c>ZipFile</c>, and
///   then calls <see cref="ZipFile.Save()"/>, the application will effectively
///   rename the entry within the zip archive.
/// </para>
///
/// <para>
///   If an application sets the value of <c>FileName</c>, then calls
///   <c>Extract()</c> on the entry, the entry is extracted to a file using the
///   newly set value as the filename.  The <c>FileName</c> value is made
///   permanent in the zip archive only <em>after</em> a call to one of the
///   <c>ZipFile.Save()</c> methods on the <c>ZipFile</c> that contains the
///   ZipEntry.
/// </para>
///
/// <para>
///   If an application attempts to set the <c>FileName</c> to a value that
///   would result in a duplicate entry in the <c>ZipFile</c>, an exception is
///   thrown.
/// </para>
///
/// <para>
///   When a <c>ZipEntry</c> is contained within a <c>ZipFile</c>, applications
///   cannot rename the entry within the context of a <c>foreach</c> (<c>For
///   Each</c> in VB) loop, because of the way the <c>ZipFile</c> stores
///   entries.  If you need to enumerate through all the entries and rename one
///   or more of them, use <see
///   cref="ZipFile.EntriesSorted">ZipFile.EntriesSorted</see> as the
///   collection.  See also, <see
///   cref="ZipFile.GetEnumerator()">ZipFile.GetEnumerator()</see>.
/// </para>
///
/// </remarks>
// rename the entry!
// workitem 8180
// nothing to do
// workitem 8047 - when renaming, must remove old and then add a new entry
/// <summary>
/// The stream that provides content for the ZipEntry.
/// </summary>
///
/// <remarks>
///
/// <para>
///   The application can use this property to set the input stream for an
///   entry on a just-in-time basis. Imagine a scenario where the application
///   creates a <c>ZipFile</c> comprised of content obtained from hundreds of
///   files, via calls to <c>AddFile()</c>. The DotNetZip library opens streams
///   on these files on a just-in-time basis, only when writing the entry out to
///   an external store within the scope of a <c>ZipFile.Save()</c> call.  Only
///   one input stream is opened at a time, as each entry is being written out.
/// </para>
///
/// <para>
///   Now imagine a different application that creates a <c>ZipFile</c>
///   with content obtained from hundreds of streams, added through <see
///   cref="ZipFile.AddEntry(string, System.IO.Stream)"/>.  Normally the
///   application would supply an open stream to that call.  But when large
///   numbers of streams are being added, this can mean many open streams at one
///   time, unnecessarily.
/// </para>
///
/// <para>
///   To avoid this, call <see cref="ZipFile.AddEntry(String, OpenDelegate,
///   CloseDelegate)"/> and specify delegates that open and close the stream at
///   the time of Save.
/// </para>
///
///
/// <para>
///   Setting the value of this property when the entry was not added from a
///   stream (for example, when the <c>ZipEntry</c> was added with <see
///   cref="ZipFile.AddFile(String)"/> or <see
///   cref="ZipFile.AddDirectory(String)"/>, or when the entry was added by
///   reading an existing zip archive) will throw an exception.
/// </para>
///
/// </remarks>
///
/// <summary>
///   A flag indicating whether the InputStream was provided Just-in-time.
/// </summary>
///
/// <remarks>
///
/// <para>
///   When creating a zip archive, an application can obtain content for one or
///   more of the <c>ZipEntry</c> instances from streams, using the <see
///   cref="ZipFile.AddEntry(string, System.IO.Stream)"/> method.  At the time
///   of calling that method, the application can supply null as the value of
///   the stream parameter.  By doing so, the application indicates to the
///   library that it will provide a stream for the entry on a just-in-time
///   basis, at the time one of the <c>ZipFile.Save()</c> methods is called and
///   the data for the various entries are being compressed and written out.
/// </para>
///
/// <para>
///   In this case, the application can set the <see cref="InputStream"/>
///   property, typically within the SaveProgress event (event type: <see
///   cref="ZipProgressEventType.Saving_BeforeWriteEntry"/>) for that entry.
/// </para>
///
/// <para>
///   The application will later want to call Close() and Dispose() on that
///   stream.  In the SaveProgress event, when the event type is <see
///   cref="ZipProgressEventType.Saving_AfterWriteEntry"/>, the application can
///   do so.  This flag indicates that the stream has been provided by the
///   application on a just-in-time basis and that it is the application's
///   responsibility to call Close/Dispose on that stream.
/// </para>
///
/// </remarks>
/// <seealso cref="InputStream"/>
/// <summary>
/// An enum indicating the source of the ZipEntry.
/// </summary>
/// <summary>
/// The version of the zip engine needed to read the ZipEntry.
/// </summary>
///
/// <remarks>
/// <para>
///   This is a readonly property, indicating the version of <a
///   href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
///   specification</a> that the extracting tool or library must support to
///   extract the given entry.  Generally higher versions indicate newer
///   features.  Older zip engines obviously won't know about new features, and
///   won't be able to extract entries that depend on those newer features.
/// </para>
///
/// <list type="table">
/// <listheader>
/// <term>value</term>
/// <description>Features</description>
/// </listheader>
///
/// <item>
/// <term>20</term>
/// <description>a basic Zip Entry, potentially using PKZIP encryption.
/// </description>
/// </item>
///
/// <item>
/// <term>45</term>
/// <description>The ZIP64 extension is used on the entry.
/// </description>
/// </item>
///
/// <item>
/// <term>46</term>
/// <description> File is compressed using BZIP2 compression*</description>
/// </item>
///
/// <item>
/// <term>50</term>
/// <description> File is encrypted using PkWare's DES, 3DES, (broken) RC2 or RC4</description>
/// </item>
///
/// <item>
/// <term>51</term>
/// <description> File is encrypted using PKWare's AES encryption or corrected RC2 encryption.</description>
/// </item>
///
/// <item>
/// <term>52</term>
/// <description> File is encrypted using corrected RC2-64 encryption**</description>
/// </item>
///
/// <item>
/// <term>61</term>
/// <description> File is encrypted using non-OAEP key wrapping***</description>
/// </item>
///
/// <item>
/// <term>63</term>
/// <description> File is compressed using LZMA, PPMd+, Blowfish, or Twofish</description>
/// </item>
///
/// </list>
///
/// <para>
///   There are other values possible, not listed here. DotNetZip supports
///   regular PKZip encryption, and ZIP64 extensions.  DotNetZip cannot extract
///   entries that require a zip engine higher than 45.
/// </para>
///
/// <para>
///   This value is set upon reading an existing zip file, or after saving a zip
///   archive.
/// </para>
/// </remarks>
/// <summary>
/// The comment attached to the ZipEntry.
/// </summary>
///
/// <remarks>
/// <para>
///   Each entry in a zip file can optionally have a comment associated to
///   it. The comment might be displayed by a zip tool during extraction, for
///   example.
/// </para>
///
/// <para>
///   By default, the <c>Comment</c> is encoded in IBM437 code page. You can
///   specify an alternative with <see cref="AlternateEncoding"/> and
///  <see cref="AlternateEncodingUsage"/>.
/// </para>
/// </remarks>
/// <seealso cref="AlternateEncoding"/>
/// <seealso cref="AlternateEncodingUsage"/>
/// <summary>
/// Indicates whether the entry requires ZIP64 extensions.
/// </summary>
///
/// <remarks>
///
/// <para>
///   This property is null (Nothing in VB) until a <c>Save()</c> method on the
///   containing <see cref="ZipFile"/> instance has been called. The property is
///   non-null (<c>HasValue</c> is true) only after a <c>Save()</c> method has
///   been called.
/// </para>
///
/// <para>
///   After the containing <c>ZipFile</c> has been saved, the Value of this
///   property is true if any of the following three conditions holds: the
///   uncompressed size of the entry is larger than 0xFFFFFFFF; the compressed
///   size of the entry is larger than 0xFFFFFFFF; the relative offset of the
///   entry within the zip archive is larger than 0xFFFFFFFF.  These quantities
///   are not known until a <c>Save()</c> is attempted on the zip archive and
///   the compression is applied.
/// </para>
///
/// <para>
///   If none of the three conditions holds, then the <c>Value</c> is false.
/// </para>
///
/// <para>
///   A <c>Value</c> of false does not indicate that the entry, as saved in the
///   zip archive, does not use ZIP64.  It merely indicates that ZIP64 is
///   <em>not required</em>.  An entry may use ZIP64 even when not required if
///   the <see cref="ZipFile.UseZip64WhenSaving"/> property on the containing
///   <c>ZipFile</c> instance is set to <see cref="Zip64Option.Always"/>, or if
///   the <see cref="ZipFile.UseZip64WhenSaving"/> property on the containing
///   <c>ZipFile</c> instance is set to <see cref="Zip64Option.AsNecessary"/>
///   and the output stream was not seekable.
/// </para>
///
/// </remarks>
/// <seealso cref="OutputUsedZip64"/>
/// <summary>
///   Indicates whether the entry actually used ZIP64 extensions, as it was most
///   recently written to the output file or stream.
/// </summary>
///
/// <remarks>
///
/// <para>
///   This Nullable property is null (Nothing in VB) until a <c>Save()</c>
///   method on the containing <see cref="ZipFile"/> instance has been
///   called. <c>HasValue</c> is true only after a <c>Save()</c> method has been
///   called.
/// </para>
///
/// <para>
///   The value of this property for a particular <c>ZipEntry</c> may change
///   over successive calls to <c>Save()</c> methods on the containing ZipFile,
///   even if the file that corresponds to the <c>ZipEntry</c> does not. This
///   may happen if other entries contained in the <c>ZipFile</c> expand,
///   causing the offset for this particular entry to exceed 0xFFFFFFFF.
/// </para>
/// </remarks>
/// <seealso cref="RequiresZip64"/>
/// <summary>
///   The bitfield for the entry as defined in the zip spec. You probably
///   never need to look at this.
/// </summary>
///
/// <remarks>
/// <para>
///   You probably do not need to concern yourself with the contents of this
///   property, but in case you do:
/// </para>
///
/// <list type="table">
/// <listheader>
/// <term>bit</term>
/// <description>meaning</description>
/// </listheader>
///
/// <item>
/// <term>0</term>
/// <description>set if encryption is used.</description>
/// </item>
///
/// <item>
/// <term>1-2</term>
/// <description>
/// set to determine whether normal, max, fast deflation.  DotNetZip library
/// always leaves these bits unset when writing (indicating "normal"
/// deflation"), but can read an entry with any value here.
/// </description>
/// </item>
///
/// <item>
/// <term>3</term>
/// <description>
/// Indicates that the Crc32, Compressed and Uncompressed sizes are zero in the
/// local header.  This bit gets set on an entry during writing a zip file, when
/// it is saved to a non-seekable output stream.
/// </description>
/// </item>
///
///
/// <item>
/// <term>4</term>
/// <description>reserved for "enhanced deflating". This library doesn't do enhanced deflating.</description>
/// </item>
///
/// <item>
/// <term>5</term>
/// <description>set to indicate the zip is compressed patched data.  This library doesn't do that.</description>
/// </item>
///
/// <item>
/// <term>6</term>
/// <description>
/// set if PKWare's strong encryption is used (must also set bit 1 if bit 6 is
/// set). This bit is not set if WinZip's AES encryption is set.</description>
/// </item>
///
/// <item>
/// <term>7</term>
/// <description>not used</description>
/// </item>
///
/// <item>
/// <term>8</term>
/// <description>not used</description>
/// </item>
///
/// <item>
/// <term>9</term>
/// <description>not used</description>
/// </item>
///
/// <item>
/// <term>10</term>
/// <description>not used</description>
/// </item>
///
/// <item>
/// <term>11</term>
/// <description>
/// Language encoding flag (EFS).  If this bit is set, the filename and comment
/// fields for this file must be encoded using UTF-8. This library currently
/// does not support UTF-8.
/// </description>
/// </item>
///
/// <item>
/// <term>12</term>
/// <description>Reserved by PKWARE for enhanced compression.</description>
/// </item>
///
/// <item>
/// <term>13</term>
/// <description>
///   Used when encrypting the Central Directory to indicate selected data
///   values in the Local Header are masked to hide their actual values.  See
///   the section in <a
///   href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
///   specification</a> describing the Strong Encryption Specification for
///   details.
/// </description>
/// </item>
///
/// <item>
/// <term>14</term>
/// <description>Reserved by PKWARE.</description>
/// </item>
///
/// <item>
/// <term>15</term>
/// <description>Reserved by PKWARE.</description>
/// </item>
///
/// </list>
///
/// </remarks>
/// <summary>
///   The compression method employed for this ZipEntry.
/// </summary>
///
/// <remarks>
///
/// <para>
///   <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">The
///   Zip specification</see> allows a variety of compression methods.  This
///   library supports just two: 0x08 = Deflate.  0x00 = Store (no compression),
///   for reading or writing.
/// </para>
///
/// <para>
///   When reading an entry from an existing zipfile, the value you retrieve
///   here indicates the compression method used on the entry by the original
///   creator of the zip.  When writing a zipfile, you can specify either 0x08
///   (Deflate) or 0x00 (None).  If you try setting something else, you will get
///   an exception.
/// </para>
///
/// <para>
///   You may wish to set <c>CompressionMethod</c> to <c>CompressionMethod.None</c> (0)
///   when zipping already-compressed data like a jpg, png, or mp3 file.
///   This can save time and cpu cycles.
/// </para>
///
/// <para>
///   When setting this property on a <c>ZipEntry</c> that is read from an
///   existing zip file, calling <c>ZipFile.Save()</c> will cause the new
///   CompressionMethod to be used on the entry in the newly saved zip file.
/// </para>
///
/// <para>
///   Setting this property may have the side effect of modifying the
///   <c>CompressionLevel</c> property. If you set the <c>CompressionMethod</c> to a
///   value other than <c>None</c>, and <c>CompressionLevel</c> is previously
///   set to <c>None</c>, then <c>CompressionLevel</c> will be set to
///   <c>Default</c>.
/// </para>
/// </remarks>
///
/// <seealso cref="CompressionMethod"/>
///
/// <example>
///   In this example, the first entry added to the zip archive uses the default
///   behavior - compression is used where it makes sense.  The second entry,
///   the MP3 file, is added to the archive without being compressed.
/// <code>
/// using (ZipFile zip = new ZipFile(ZipFileToCreate))
/// {
///   ZipEntry e1= zip.AddFile(@"notes\Readme.txt");
///   ZipEntry e2= zip.AddFile(@"music\StopThisTrain.mp3");
///   e2.CompressionMethod = CompressionMethod.None;
///   zip.Save();
/// }
/// </code>
///
/// <code lang="VB">
/// Using zip As New ZipFile(ZipFileToCreate)
///   zip.AddFile("notes\Readme.txt")
///   Dim e2 as ZipEntry = zip.AddFile("music\StopThisTrain.mp3")
///   e2.CompressionMethod = CompressionMethod.None
///   zip.Save
/// End Using
/// </code>
/// </example>
// nothing to do.
// If the source is a zip archive and there was encryption on the
// entry, changing the compression method is not supported.
//                 if (this._Source == ZipEntrySource.ZipFile && _sourceIsEncrypted)
//                     throw new InvalidOperationException("Cannot change compression method on encrypted entries read from archives.");
/// <summary>
///   Sets the compression level to be used for the entry when saving the zip
///   archive. This applies only for CompressionMethod = DEFLATE.
/// </summary>
///
/// <remarks>
///  <para>
///    When using the DEFLATE compression method, Varying the compression
///    level used on entries can affect the size-vs-speed tradeoff when
///    compression and decompressing data streams or files.
///  </para>
///
///  <para>
///    If you do not set this property, the default compression level is used,
///    which normally gives a good balance of compression efficiency and
///    compression speed.  In some tests, using <c>BestCompression</c> can
///    double the time it takes to compress, while delivering just a small
///    increase in compression efficiency.  This behavior will vary with the
///    type of data you compress.  If you are in doubt, just leave this setting
///    alone, and accept the default.
///  </para>
///
///  <para>
///    When setting this property on a <c>ZipEntry</c> that is read from an
///    existing zip file, calling <c>ZipFile.Save()</c> will cause the new
///    <c>CompressionLevel</c> to be used on the entry in the newly saved zip file.
///  </para>
///
///  <para>
///    Setting this property may have the side effect of modifying the
///    <c>CompressionMethod</c> property. If you set the <c>CompressionLevel</c>
///    to a value other than <c>None</c>, <c>CompressionMethod</c> will be set
///    to <c>Deflate</c>, if it was previously <c>None</c>.
///  </para>
///
///  <para>
///    Setting this property has no effect if the <c>CompressionMethod</c> is something
///    other than <c>Deflate</c> or <c>None</c>.
///  </para>
/// </remarks>
///
/// <seealso cref="CompressionMethod"/>
// no effect
// nothing to do
// nothing more to do
/// <summary>
///   The compressed size of the file, in bytes, within the zip archive.
/// </summary>
///
/// <remarks>
///   When reading a <c>ZipFile</c>, this value is read in from the existing
///   zip file. When creating or updating a <c>ZipFile</c>, the compressed
///   size is computed during compression.  Therefore the value on a
///   <c>ZipEntry</c> is valid after a call to <c>Save()</c> (or one of its
///   overloads) in that case.
/// </remarks>
///
/// <seealso cref="Ionic.Zip.ZipEntry.UncompressedSize"/>
/// <summary>
///   The size of the file, in bytes, before compression, or after extraction.
/// </summary>
///
/// <remarks>
///   When reading a <c>ZipFile</c>, this value is read in from the existing
///   zip file. When creating or updating a <c>ZipFile</c>, the uncompressed
///   size is computed during compression.  Therefore the value on a
///   <c>ZipEntry</c> is valid after a call to <c>Save()</c> (or one of its
///   overloads) in that case.
/// </remarks>
///
/// <seealso cref="Ionic.Zip.ZipEntry.CompressedSize"/>
/// <summary>
/// The ratio of compressed size to uncompressed size of the ZipEntry.
/// </summary>
///
/// <remarks>
/// <para>
///   This is a ratio of the compressed size to the uncompressed size of the
///   entry, expressed as a double in the range of 0 to 100+. A value of 100
///   indicates no compression at all.  It could be higher than 100 when the
///   compression algorithm actually inflates the data, as may occur for small
///   files, or uncompressible data that is encrypted.
/// </para>
///
/// <para>
///   You could format it for presentation to a user via a format string of
///   "{3,5:F0}%" to see it as a percentage.
/// </para>
///
/// <para>
///   If the size of the original uncompressed file is 0, implying a
///   denominator of 0, the return value will be zero.
/// </para>
///
/// <para>
///   This property is valid after reading in an existing zip file, or after
///   saving the <c>ZipFile</c> that contains the ZipEntry. You cannot know the
///   effect of a compression transform until you try it.
/// </para>
///
/// </remarks>
/// <summary>
/// The 32-bit CRC (Cyclic Redundancy Check) on the contents of the ZipEntry.
/// </summary>
///
/// <remarks>
///
/// <para> You probably don't need to concern yourself with this. It is used
/// internally by DotNetZip to verify files or streams upon extraction.  </para>
///
/// <para> The value is a <see href="http://en.wikipedia.org/wiki/CRC32">32-bit
/// CRC</see> using 0xEDB88320 for the polynomial. This is the same CRC-32 used in
/// PNG, MPEG-2, and other protocols and formats.  It is a read-only property; when
/// creating a Zip archive, the CRC for each entry is set only after a call to
/// <c>Save()</c> on the containing ZipFile. When reading an existing zip file, the value
/// of this property reflects the stored CRC for the entry.  </para>
///
/// </remarks>
/// <summary>
/// True if the entry is a directory (not a file).
/// This is a readonly property on the entry.
/// </summary>
/// <summary>
/// A derived property that is <c>true</c> if the entry uses encryption.
/// </summary>
///
/// <remarks>
/// <para>
///   This is a readonly property on the entry.  When reading a zip file,
///   the value for the <c>ZipEntry</c> is determined by the data read
///   from the zip file.  After saving a ZipFile, the value of this
///   property for each <c>ZipEntry</c> indicates whether encryption was
///   actually used (which will have been true if the <see
///   cref="Password"/> was set and the <see cref="Encryption"/> property
///   was something other than <see cref="EncryptionAlgorithm.None"/>.
/// </para>
/// </remarks>
/// <summary>
///   Set this to specify which encryption algorithm to use for the entry when
///   saving it to a zip archive.
/// </summary>
///
/// <remarks>
///
/// <para>
///   Set this property in order to encrypt the entry when the <c>ZipFile</c> is
///   saved. When setting this property, you must also set a <see
///   cref="Password"/> on the entry.  If you set a value other than <see
///   cref="EncryptionAlgorithm.None"/> on this property and do not set a
///   <c>Password</c> then the entry will not be encrypted. The <c>ZipEntry</c>
///   data is encrypted as the <c>ZipFile</c> is saved, when you call <see
///   cref="ZipFile.Save()"/> or one of its cousins on the containing
///   <c>ZipFile</c> instance. You do not need to specify the <c>Encryption</c>
///   when extracting entries from an archive.
/// </para>
///
/// <para>
///   The Zip specification from PKWare defines a set of encryption algorithms,
///   and the data formats for the zip archive that support them, and PKWare
///   supports those algorithms in the tools it produces. Other vendors of tools
///   and libraries, such as WinZip or Xceed, typically support <em>a
///   subset</em> of the algorithms specified by PKWare. These tools can
///   sometimes support additional different encryption algorithms and data
///   formats, not specified by PKWare. The AES Encryption specified and
///   supported by WinZip is the most popular example. This library supports a
///   subset of the complete set of algorithms specified by PKWare and other
///   vendors.
/// </para>
///
/// <para>
///   There is no common, ubiquitous multi-vendor standard for strong encryption
///   within zip files. There is broad support for so-called "traditional" Zip
///   encryption, sometimes called Zip 2.0 encryption, as <see
///   href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">specified
///   by PKWare</see>, but this encryption is considered weak and
///   breakable. This library currently supports the Zip 2.0 "weak" encryption,
///   and also a stronger WinZip-compatible AES encryption, using either 128-bit
///   or 256-bit key strength. If you want DotNetZip to support an algorithm
///   that is not currently supported, call the author of this library and maybe
///   we can talk business.
/// </para>
///
/// <para>
///   The <see cref="ZipFile"/> class also has a <see
///   cref="ZipFile.Encryption"/> property.  In most cases you will use
///   <em>that</em> property when setting encryption. This property takes
///   precedence over any <c>Encryption</c> set on the <c>ZipFile</c> itself.
///   Typically, you would use the per-entry Encryption when most entries in the
///   zip archive use one encryption algorithm, and a few entries use a
///   different one.  If all entries in the zip file use the same Encryption,
///   then it is simpler to just set this property on the ZipFile itself, when
///   creating a zip archive.
/// </para>
///
/// <para>
///   Some comments on updating archives: If you read a <c>ZipFile</c>, you can
///   modify the Encryption on an encrypted entry: you can remove encryption
///   from an entry that was encrypted; you can encrypt an entry that was not
///   encrypted previously; or, you can change the encryption algorithm.  The
///   changes in encryption are not made permanent until you call Save() on the
///   <c>ZipFile</c>.  To effect changes in encryption, the entry content is
///   streamed through several transformations, depending on the modification
///   the application has requested. For example if the entry is not encrypted
///   and the application sets <c>Encryption</c> to <c>PkzipWeak</c>, then at
///   the time of <c>Save()</c>, the original entry is read and decompressed,
///   then re-compressed and encrypted.  Conversely, if the original entry is
///   encrypted with <c>PkzipWeak</c> encryption, and the application sets the
///   <c>Encryption</c> property to <c>WinZipAes128</c>, then at the time of
///   <c>Save()</c>, the original entry is decrypted via PKZIP encryption and
///   decompressed, then re-compressed and re-encrypted with AES.  This all
///   happens automatically within the library, but it can be time-consuming for
///   large entries.
/// </para>
///
/// <para>
///   Additionally, when updating archives, it is not possible to change the
///   password when changing the encryption algorithm.  To change both the
///   algorithm and the password, you need to Save() the zipfile twice.  First
///   set the <c>Encryption</c> to None, then call <c>Save()</c>.  Then set the
///   <c>Encryption</c> to the new value (not "None"), then call <c>Save()</c>
///   once again.
/// </para>
///
/// <para>
///   The WinZip AES encryption algorithms are not supported on the .NET Compact
///   Framework.
/// </para>
/// </remarks>
///
/// <example>
/// <para>
///   This example creates a zip archive that uses encryption, and then extracts
///   entries from the archive.  When creating the zip archive, the ReadMe.txt
///   file is zipped without using a password or encryption.  The other file
///   uses encryption.
/// </para>
/// <code>
/// // Create a zip archive with AES Encryption.
/// using (ZipFile zip = new ZipFile())
/// {
///     zip.AddFile("ReadMe.txt")
///     ZipEntry e1= zip.AddFile("2008-Regional-Sales-Report.pdf");
///     e1.Encryption= EncryptionAlgorithm.WinZipAes256;
///     e1.Password= "Top.Secret.No.Peeking!";
///     zip.Save("EncryptedArchive.zip");
/// }
///
/// // Extract a zip archive that uses AES Encryption.
/// // You do not need to specify the algorithm during extraction.
/// using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
/// {
///     // Specify the password that is used during extraction, for
///     // all entries that require a password:
///     zip.Password= "Top.Secret.No.Peeking!";
///     zip.ExtractAll("extractDirectory");
/// }
/// </code>
///
/// <code lang="VB">
/// ' Create a zip that uses Encryption.
/// Using zip As New ZipFile()
///     zip.AddFile("ReadMe.txt")
///     Dim e1 as ZipEntry
///     e1= zip.AddFile("2008-Regional-Sales-Report.pdf")
///     e1.Encryption= EncryptionAlgorithm.WinZipAes256
///     e1.Password= "Top.Secret.No.Peeking!"
///     zip.Save("EncryptedArchive.zip")
/// End Using
///
/// ' Extract a zip archive that uses AES Encryption.
/// ' You do not need to specify the algorithm during extraction.
/// Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
///     ' Specify the password that is used during extraction, for
///     ' all entries that require a password:
///     zip.Password= "Top.Secret.No.Peeking!"
///     zip.ExtractAll("extractDirectory")
/// End Using
/// </code>
///
/// </example>
///
/// <exception cref="System.InvalidOperationException">
/// Thrown in the setter if EncryptionAlgorithm.Unsupported is specified.
/// </exception>
///
/// <seealso cref="Ionic.Zip.ZipEntry.Password">ZipEntry.Password</seealso>
/// <seealso cref="Ionic.Zip.ZipFile.Encryption">ZipFile.Encryption</seealso>
// no change
// If the source is a zip archive and there was encryption
// on the entry, this will not work. <XXX>
//if (this._Source == ZipEntrySource.ZipFile && _sourceIsEncrypted)
//    throw new InvalidOperationException("You cannot change the encryption method on encrypted entries read from archives.");
/// <summary>
/// The Password to be used when encrypting a <c>ZipEntry</c> upon
/// <c>ZipFile.Save()</c>, or when decrypting an entry upon Extract().
/// </summary>
///
/// <remarks>
/// <para>
///   This is a write-only property on the entry. Set this to request that the
///   entry be encrypted when writing the zip archive, or set it to specify the
///   password to be used when extracting an existing entry that is encrypted.
/// </para>
///
/// <para>
///   The password set here is implicitly used to encrypt the entry during the
///   <see cref="ZipFile.Save()"/> operation, or to decrypt during the <see
///   cref="Extract()"/> or <see cref="OpenReader()"/> operation.  If you set
///   the Password on a <c>ZipEntry</c> after calling <c>Save()</c>, there is no
///   effect.
/// </para>
///
/// <para>
///   Consider setting the <see cref="Encryption"/> property when using a
///   password. Answering concerns that the standard password protection
///   supported by all zip tools is weak, WinZip has extended the ZIP
///   specification with a way to use AES Encryption to protect entries in the
///   Zip file. Unlike the "PKZIP 2.0" encryption specified in the PKZIP
///   specification, <see href=
///   "http://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES
///   Encryption</see> uses a standard, strong, tested, encryption
///   algorithm. DotNetZip can create zip archives that use WinZip-compatible
///   AES encryption, if you set the <see cref="Encryption"/> property. But,
///   archives created that use AES encryption may not be readable by all other
///   tools and libraries. For example, Windows Explorer cannot read a
///   "compressed folder" (a zip file) that uses AES encryption, though it can
///   read a zip file that uses "PKZIP encryption."
/// </para>
///
/// <para>
///   The <see cref="ZipFile"/> class also has a <see cref="ZipFile.Password"/>
///   property.  This property takes precedence over any password set on the
///   ZipFile itself.  Typically, you would use the per-entry Password when most
///   entries in the zip archive use one password, and a few entries use a
///   different password.  If all entries in the zip file use the same password,
///   then it is simpler to just set this property on the ZipFile itself,
///   whether creating a zip archive or extracting a zip archive.
/// </para>
///
/// <para>
///   Some comments on updating archives: If you read a <c>ZipFile</c>, you
///   cannot modify the password on any encrypted entry, except by extracting
///   the entry with the original password (if any), removing the original entry
///   via <see cref="ZipFile.RemoveEntry(ZipEntry)"/>, and then adding a new
///   entry with a new Password.
/// </para>
///
/// <para>
///   For example, suppose you read a <c>ZipFile</c>, and there is an encrypted
///   entry.  Setting the Password property on that <c>ZipEntry</c> and then
///   calling <c>Save()</c> on the <c>ZipFile</c> does not update the password
///   on that entry in the archive.  Neither is an exception thrown. Instead,
///   what happens during the <c>Save()</c> is the existing entry is copied
///   through to the new zip archive, in its original encrypted form. Upon
///   re-reading that archive, the entry can be decrypted with its original
///   password.
/// </para>
///
/// <para>
///   If you read a ZipFile, and there is an un-encrypted entry, you can set the
///   <c>Password</c> on the entry and then call Save() on the ZipFile, and get
///   encryption on that entry.
/// </para>
///
/// </remarks>
///
/// <example>
/// <para>
///   This example creates a zip file with two entries, and then extracts the
///   entries from the zip file.  When creating the zip file, the two files are
///   added to the zip file using password protection. Each entry uses a
///   different password.  During extraction, each file is extracted with the
///   appropriate password.
/// </para>
/// <code>
/// // create a file with encryption
/// using (ZipFile zip = new ZipFile())
/// {
///     ZipEntry entry;
///     entry= zip.AddFile("Declaration.txt");
///     entry.Password= "123456!";
///     entry = zip.AddFile("Report.xls");
///     entry.Password= "1Secret!";
///     zip.Save("EncryptedArchive.zip");
/// }
///
/// // extract entries that use encryption
/// using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
/// {
///     ZipEntry entry;
///     entry = zip["Declaration.txt"];
///     entry.Password = "123456!";
///     entry.Extract("extractDir");
///     entry = zip["Report.xls"];
///     entry.Password = "1Secret!";
///     entry.Extract("extractDir");
/// }
///
/// </code>
///
/// <code lang="VB">
/// Using zip As New ZipFile
///     Dim entry as ZipEntry
///     entry= zip.AddFile("Declaration.txt")
///     entry.Password= "123456!"
///     entry = zip.AddFile("Report.xls")
///     entry.Password= "1Secret!"
///     zip.Save("EncryptedArchive.zip")
/// End Using
///
///
/// ' extract entries that use encryption
/// Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
///     Dim entry as ZipEntry
///     entry = zip("Declaration.txt")
///     entry.Password = "123456!"
///     entry.Extract("extractDir")
///     entry = zip("Report.xls")
///     entry.Password = "1Secret!"
///     entry.Extract("extractDir")
/// End Using
///
/// </code>
///
/// </example>
///
/// <seealso cref="Ionic.Zip.ZipEntry.Encryption"/>
/// <seealso cref="Ionic.Zip.ZipFile.Password">ZipFile.Password</seealso>
// We're setting a non-null password.
// For entries obtained from a zip file that are encrypted, we cannot
// simply restream (recompress, re-encrypt) the file data, because we
// need the old password in order to decrypt the data, and then we
// need the new password to encrypt.  So, setting the password is
// never going to work on an entry that is stored encrypted in a zipfile.
// But it is not en error to set the password, obviously: callers will
// set the password in order to Extract encrypted archives.
// If the source is a zip archive and there was previously no encryption
// on the entry, then we must re-stream the entry in order to encrypt it.
/// <summary>
/// The action the library should take when extracting a file that already exists.
/// </summary>
///
/// <remarks>
///   <para>
///     This property affects the behavior of the Extract methods (one of the
///     <c>Extract()</c> or <c>ExtractWithPassword()</c> overloads), when
///     extraction would would overwrite an existing filesystem file. If you do
///     not set this property, the library throws an exception when extracting
///     an entry would overwrite an existing file.
///   </para>
///
///   <para>
///     This property has no effect when extracting to a stream, or when the file to be
///     extracted does not already exist.
///   </para>
///
/// </remarks>
/// <seealso cref="Ionic.Zip.ZipFile.ExtractExistingFile"/>
///
/// <example>
///   This example shows how to set the <c>ExtractExistingFile</c> property in
///   an <c>ExtractProgress</c> event, in response to user input. The
///   <c>ExtractProgress</c> event is invoked if and only if the
///   <c>ExtractExistingFile</c> property was previously set to
///   <c>ExtractExistingFileAction.InvokeExtractProgressEvent</c>.
/// <code lang="C#">
/// public static void ExtractProgress(object sender, ExtractProgressEventArgs e)
/// {
///     if (e.EventType == ZipProgressEventType.Extracting_BeforeExtractEntry)
///         Console.WriteLine("extract {0} ", e.CurrentEntry.FileName);
///
///     else if (e.EventType == ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite)
///     {
///         ZipEntry entry = e.CurrentEntry;
///         string response = null;
///         // Ask the user if he wants overwrite the file
///         do
///         {
///             Console.Write("Overwrite {0} in {1} ? (y/n/C) ", entry.FileName, e.ExtractLocation);
///             response = Console.ReadLine();
///             Console.WriteLine();
///
///         } while (response != null &amp;&amp; response[0]!='Y' &amp;&amp;
///                  response[0]!='N' &amp;&amp; response[0]!='C');
///
///         if  (response[0]=='C')
///             e.Cancel = true;
///         else if (response[0]=='Y')
///             entry.ExtractExistingFile = ExtractExistingFileAction.OverwriteSilently;
///         else
///             entry.ExtractExistingFile= ExtractExistingFileAction.DoNotOverwrite;
///     }
/// }
/// </code>
/// </example>
/// <summary>
///   The action to take when an error is encountered while
///   opening or reading files as they are saved into a zip archive.
/// </summary>
///
/// <remarks>
///  <para>
///     Errors can occur within a call to <see
///     cref="ZipFile.Save()">ZipFile.Save</see>, as the various files contained
///     in a ZipFile are being saved into the zip archive.  During the
///     <c>Save</c>, DotNetZip will perform a <c>File.Open</c> on the file
///     associated to the ZipEntry, and then will read the entire contents of
///     the file as it is zipped. Either the open or the Read may fail, because
///     of lock conflicts or other reasons.  Using this property, you can
///     specify the action to take when such errors occur.
///  </para>
///
///  <para>
///     Typically you will NOT set this property on individual ZipEntry
///     instances.  Instead, you will set the <see
///     cref="ZipFile.ZipErrorAction">ZipFile.ZipErrorAction</see> property on
///     the ZipFile instance, before adding any entries to the
///     <c>ZipFile</c>. If you do this, errors encountered on behalf of any of
///     the entries in the ZipFile will be handled the same way.
///  </para>
///
///  <para>
///     But, if you use a <see cref="ZipFile.ZipError"/> handler, you will want
///     to set this property on the <c>ZipEntry</c> within the handler, to
///     communicate back to DotNetZip what you would like to do with the
///     particular error.
///  </para>
///
/// </remarks>
/// <seealso cref="Ionic.Zip.ZipFile.ZipErrorAction"/>
/// <seealso cref="Ionic.Zip.ZipFile.ZipError"/>
/// <summary>
/// Indicates whether the entry was included in the most recent save.
/// </summary>
/// <remarks>
/// An entry can be excluded or skipped from a save if there is an error
/// opening or reading the entry.
/// </remarks>
/// <seealso cref="ZipErrorAction"/>
/// <summary>
///   A callback that allows the application to specify the compression to use
///   for a given entry that is about to be added to the zip archive.
/// </summary>
///
/// <remarks>
/// <para>
///   See <see cref="ZipFile.SetCompression" />
/// </para>
/// </remarks>
/// <summary>
///   Set to indicate whether to use UTF-8 encoding for filenames and comments.
/// </summary>
///
/// <remarks>
///
/// <para>
///   If this flag is set, the comment and filename for the entry will be
///   encoded with UTF-8, as described in <see
///   href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
///   specification</see>, if necessary. "Necessary" means, the filename or
///   entry comment (if any) cannot be reflexively encoded and decoded using the
///   default code page, IBM437.
/// </para>
///
/// <para>
///   Setting this flag to true is equivalent to setting <see
///   cref="ProvisionalAlternateEncoding"/> to <c>System.Text.Encoding.UTF8</c>.
/// </para>
///
/// <para>
///   This flag has no effect or relation to the text encoding used within the
///   file itself.
/// </para>
///
/// </remarks>
/// <summary>
///   The text encoding to use for the FileName and Comment on this ZipEntry,
///   when the default encoding is insufficient.
/// </summary>
///
/// <remarks>
///
/// <para>
///   Don't use this property.  See <see cref='AlternateEncoding'/>.
/// </para>
///
/// </remarks>
/// <summary>
///   Specifies the alternate text encoding used by this ZipEntry
/// </summary>
/// <remarks>
///   <para>
///     The default text encoding used in Zip files for encoding filenames and
///     comments is IBM437, which is something like a superset of ASCII.  In
///     cases where this is insufficient, applications can specify an
///     alternate encoding.
///   </para>
///   <para>
///     When creating a zip file, the usage of the alternate encoding is
///     governed by the <see cref="AlternateEncodingUsage"/> property.
///     Typically you would set both properties to tell DotNetZip to employ an
///     encoding that is not IBM437 in the zipfile you are creating.
///   </para>
///   <para>
///     Keep in mind that because the ZIP specification states that the only
///     valid encodings to use are IBM437 and UTF-8, if you use something
///     other than that, then zip tools and libraries may not be able to
///     successfully read the zip archive you generate.
///   </para>
///   <para>
///     The zip specification states that applications should presume that
///     IBM437 is in use, except when a special bit is set, which indicates
///     UTF-8. There is no way to specify an arbitrary code page, within the
///     zip file itself. When you create a zip file encoded with gb2312 or
///     ibm861 or anything other than IBM437 or UTF-8, then the application
///     that reads the zip file needs to "know" which code page to use. In
///     some cases, the code page used when reading is chosen implicitly. For
///     example, WinRar uses the ambient code page for the host desktop
///     operating system. The pitfall here is that if you create a zip in
///     Copenhagen and send it to Tokyo, the reader of the zipfile may not be
///     able to decode successfully.
///   </para>
/// </remarks>
/// <example>
///   This example shows how to create a zipfile encoded with a
///   language-specific encoding:
/// <code>
///   using (var zip = new ZipFile())
///   {
///      zip.AlternateEnoding = System.Text.Encoding.GetEncoding("ibm861");
///      zip.AlternateEnodingUsage = ZipOption.Always;
///      zip.AddFileS(arrayOfFiles);
///      zip.Save("Myarchive-Encoded-in-IBM861.zip");
///   }
/// </code>
/// </example>
/// <seealso cref="ZipFile.AlternateEncodingUsage" />
/// <summary>
///   Describes if and when this instance should apply
///   AlternateEncoding to encode the FileName and Comment, when
///   saving.
/// </summary>
/// <seealso cref="ZipFile.AlternateEncoding" />
// /// <summary>
// /// The text encoding actually used for this ZipEntry.
// /// </summary>
// ///
// /// <remarks>
// ///
// /// <para>
// ///   This read-only property describes the encoding used by the
// ///   <c>ZipEntry</c>.  If the entry has been read in from an existing ZipFile,
// ///   then it may take the value UTF-8, if the entry is coded to specify UTF-8.
// ///   If the entry does not specify UTF-8, the typical case, then the encoding
// ///   used is whatever the application specified in the call to
// ///   <c>ZipFile.Read()</c>. If the application has used one of the overloads of
// ///   <c>ZipFile.Read()</c> that does not accept an encoding parameter, then the
// ///   encoding used is IBM437, which is the default encoding described in the
// ///   ZIP specification.  </para>
// ///
// /// <para>
// ///   If the entry is being created, then the value of ActualEncoding is taken
// ///   according to the logic described in the documentation for <see
// ///   cref="ZipFile.ProvisionalAlternateEncoding" />.  </para>
// ///
// /// <para>
// ///   An application might be interested in retrieving this property to see if
// ///   an entry read in from a file has used Unicode (UTF-8).  </para>
// ///
// /// </remarks>
// ///
// /// <seealso cref="ZipFile.ProvisionalAlternateEncoding" />
// public System.Text.Encoding ActualEncoding
// {
//     get
//     {
//         return _actualEncoding;
//     }
// }
// explicitly specify a pathname for this file
//result = Path.GetFullPath(result);
// workitem 9073
// workitem 7071
// workitem 7926 - "version made by" OS should be zero for compat with WinZip
// indicates the attributes are FAT Attributes, and v4.5 of the spec
// may  or may not be null
// may  or may not be null
// may  or may not be null
// may  or may not be null
// workitem 9073
// make this a valid value, for later.
// must not be null
// The named file may or may not exist at this time.  For
// example, when adding a directory by name.  We test existence
// when necessary: when saving the ZipFile, or when getting the
// attributes, and so on.
// workitem 6878??
// workitem 7071
// can only get attributes on files that exist.
// workitem 8813
// workitem 14035
// We don't actually slurp in the file data until the caller invokes Write on this entry.
// workitem 6279
/// <summary>
///   Indicates whether an entry is marked as a text file. Be careful when
///   using on this property. Unless you have a good reason, you should
///   probably ignore this property.
/// </summary>
///
/// <remarks>
/// <para>
///   The ZIP format includes a provision for specifying whether an entry in
///   the zip archive is a text or binary file.  This property exposes that
///   metadata item. Be careful when using this property: It's not clear
///   that this property as a firm meaning, across tools and libraries.
/// </para>
///
/// <para>
///   To be clear, when reading a zip file, the property value may or may
///   not be set, and its value may or may not be valid.  Not all entries
///   that you may think of as "text" entries will be so marked, and entries
///   marked as "text" are not guaranteed in any way to be text entries.
///   Whether the value is set and set correctly depends entirely on the
///   application that produced the zip file.
/// </para>
///
/// <para>
///   There are many zip tools available, and when creating zip files, some
///   of them "respect" the IsText metadata field, and some of them do not.
///   Unfortunately, even when an application tries to do "the right thing",
///   it's not always clear what "the right thing" is.
/// </para>
///
/// <para>
///   There's no firm definition of just what it means to be "a text file",
///   and the zip specification does not help in this regard. Twenty years
///   ago, text was ASCII, each byte was less than 127. IsText meant, all
///   bytes in the file were less than 127.  These days, it is not the case
///   that all text files have all bytes less than 127.  Any unicode file
///   may have bytes that are above 0x7f.  The zip specification has nothing
///   to say on this topic. Therefore, it's not clear what IsText really
///   means.
/// </para>
///
/// <para>
///   This property merely tells a reading application what is stored in the
///   metadata for an entry, without guaranteeing its validity or its
///   meaning.
/// </para>
///
/// <para>
///   When DotNetZip is used to create a zipfile, it attempts to set this
///   field "correctly." For example, if a file ends in ".txt", this field
///   will be set. Your application may override that default setting.  When
///   writing a zip file, you must set the property before calling
///   <c>Save()</c> on the ZipFile.
/// </para>
///
/// <para>
///   When reading a zip file, a more general way to decide just what kind
///   of file is contained in a particular entry is to use the file type
///   database stored in the operating system.  The operating system stores
///   a table that says, a file with .jpg extension is a JPG image file, a
///   file with a .xml extension is an XML document, a file with a .txt is a
///   pure ASCII text document, and so on.  To get this information on
///   Windows, <see
///   href="http://www.codeproject.com/KB/cs/GetFileTypeAndIcon.aspx"> you
///   need to read and parse the registry.</see> </para>
/// </remarks>
///
/// <example>
/// <code>
/// using (var zip = new ZipFile())
/// {
///     var e = zip.UpdateFile("Descriptions.mme", "");
///     e.IsText = true;
///     zip.Save(zipPath);
/// }
/// </code>
///
/// <code lang="VB">
/// Using zip As New ZipFile
///     Dim e2 as ZipEntry = zip.AddFile("Descriptions.mme", "")
///     e.IsText= True
///     zip.Save(zipPath)
/// End Using
/// </code>
/// </example>
// workitem 7801
/// <summary>Provides a string representation of the instance.</summary>
/// <returns>a string representation of the instance.</returns>
// The value for FileDataPosition has not yet been set.
// Therefore, seek to the local header, and figure the start of file data.
// workitem 8098: ok (restore)
// At this point we could verify the contents read from the local header
// with the contents read from the central header.  We could, but don't need to.
// So we won't.
// Console.WriteLine("  pos  0x{0:X8} ({0})", this.ArchiveStream.Position);
// Console.WriteLine("  seek 0x{0:X8} ({0})", filenameLength + extraFieldLength);
// Console.WriteLine("  ROLH  0x{0:X8} ({0})", _RelativeOffsetOfLocalHeader);
// Console.WriteLine("  LOH   0x{0:X8} ({0})", _LengthOfHeader);
// workitem 8098: ok (arithmetic)
// Console.WriteLine("  FDP   0x{0:X8} ({0})", __FileDataPosition);
// restore file position:
// workitem 8098: ok (restore)
//if ((_BitField & 0x01) != 0x01) return 0;
// workitem 6878: NTFS quantities
// by default, false
// by default, trim them.
// CompressedSize less 12 bytes for the encryption header, if any
//private System.Text.Encoding _provisionalAlternateEncoding = System.Text.Encoding.GetEncoding("IBM437");
// workitem 7801
// summary
// The default size of the IO buffer for ZipEntry instances. Currently it is 8192 bytes.
// summary
//public const int IO_BUFFER_SIZE_DEFAULT = 8192; // 0x8000; // 0x4400
/// <summary>
///   An enum that specifies the type of timestamp available on the ZipEntry.
/// </summary>
///
/// <remarks>
///
/// <para>
///   The last modified time of a file can be stored in multiple ways in
///   a zip file, and they are not mutually exclusive:
/// </para>
///
/// <list type="bullet">
///   <item>
///     In the so-called "DOS" format, which has a 2-second precision. Values
///     are rounded to the nearest even second. For example, if the time on the
///     file is 12:34:43, then it will be stored as 12:34:44. This first value
///     is accessible via the <c>LastModified</c> property. This value is always
///     present in the metadata for each zip entry.  In some cases the value is
///     invalid, or zero.
///   </item>
///
///   <item>
///     In the so-called "Windows" or "NTFS" format, as an 8-byte integer
///     quantity expressed as the number of 1/10 milliseconds (in other words
///     the number of 100 nanosecond units) since January 1, 1601 (UTC).  This
///     format is how Windows represents file times.  This time is accessible
///     via the <c>ModifiedTime</c> property.
///   </item>
///
///   <item>
///     In the "Unix" format, a 4-byte quantity specifying the number of seconds since
///     January 1, 1970 UTC.
///   </item>
///
///   <item>
///     In an older format, now deprecated but still used by some current
///     tools. This format is also a 4-byte quantity specifying the number of
///     seconds since January 1, 1970 UTC.
///   </item>
///
/// </list>
///
/// <para>
///   This bit field describes which of the formats were found in a <c>ZipEntry</c> that was read.
/// </para>
///
/// </remarks>
/// <summary>
/// Default value.
/// </summary>
/// <summary>
/// A DOS timestamp with 2-second precision.
/// </summary>
/// <summary>
/// A Windows timestamp with 100-ns precision.
/// </summary>
/// <summary>
/// A Unix timestamp with 1-second precision.
/// </summary>
/// <summary>
/// A Unix timestamp with 1-second precision, stored in InfoZip v1 format.  This
/// format is outdated and is supported for reading archives only.
/// </summary>
/// <summary>
///   The method of compression to use for a particular ZipEntry.
/// </summary>
///
/// <remarks>
///   <see
///   href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWare's
///   ZIP Specification</see> describes a number of distinct
///   cmopression methods that can be used within a zip
///   file. DotNetZip supports a subset of them.
/// </remarks>
/// <summary>
/// No compression at all. For COM environments, the value is 0 (zero).
/// </summary>
/// <summary>
///   DEFLATE compression, as described in <see
///   href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC
///   1951</see>.  This is the "normal" compression used in zip
///   files. For COM environments, the value is 8.
/// </summary>
/// <summary>
///   BZip2 compression, a compression algorithm developed by Julian Seward.
///   For COM environments, the value is 12.
/// </summary>
// ZipEntry.Extract.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2011 Dino Chiesa
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-August-06 18:08:21>
//
// ------------------------------------------------------------------
//
// This module defines logic for Extract methods on the ZipEntry class.
//
// ------------------------------------------------------------------
/// <summary>
///   Extract the entry to the filesystem, starting at the current
///   working directory.
/// </summary>
///
/// <overloads>
///   This method has a bunch of overloads! One of them is sure to
///   be the right one for you... If you don't like these, check
///   out the <c>ExtractWithPassword()</c> methods.
/// </overloads>
///
/// <seealso cref="Ionic.Zip.ZipEntry.ExtractExistingFile"/>
/// <seealso cref="ZipEntry.Extract(ExtractExistingFileAction)"/>
///
/// <remarks>
///
/// <para>
///   This method extracts an entry from a zip file into the current
///   working directory.  The path of the entry as extracted is the full
///   path as specified in the zip archive, relative to the current
///   working directory.  After the file is extracted successfully, the
///   file attributes and timestamps are set.
/// </para>
///
/// <para>
///   The action taken when extraction an entry would overwrite an
///   existing file is determined by the <see cref="ExtractExistingFile"
///   /> property.
/// </para>
///
/// <para>
///   Within the call to <c>Extract()</c>, the content for the entry is
///   written into a filesystem file, and then the last modified time of the
///   file is set according to the <see cref="LastModified"/> property on
///   the entry. See the remarks the <see cref="LastModified"/> property for
///   some details about the last modified time.
/// </para>
///
/// </remarks>
/// <summary>
///   Extract the entry to a file in the filesystem, using the specified
///   behavior when extraction would overwrite an existing file.
/// </summary>
///
/// <remarks>
/// <para>
///   See the remarks on the <see cref="LastModified"/> property, for some
///   details about how the last modified time of the file is set after
///   extraction.
/// </para>
/// </remarks>
///
/// <param name="extractExistingFile">
///   The action to take if extraction would overwrite an existing file.
/// </param>
/// <summary>
///   Extracts the entry to the specified stream.
/// </summary>
///
/// <remarks>
/// <para>
///   The caller can specify any write-able stream, for example a <see
///   cref="System.IO.FileStream"/>, a <see
///   cref="System.IO.MemoryStream"/>, or ASP.NET's
///   <c>Response.OutputStream</c>.  The content will be decrypted and
///   decompressed as necessary. If the entry is encrypted and no password
///   is provided, this method will throw.
/// </para>
/// <para>
///   The position on the stream is not reset by this method before it extracts.
///   You may want to call stream.Seek() before calling ZipEntry.Extract().
/// </para>
/// </remarks>
///
/// <param name="stream">
///   the stream to which the entry should be extracted.
/// </param>
///
/// <summary>
///   Extract the entry to the filesystem, starting at the specified base
///   directory.
/// </summary>
///
/// <param name="baseDirectory">the pathname of the base directory</param>
///
/// <seealso cref="Ionic.Zip.ZipEntry.ExtractExistingFile"/>
/// <seealso cref="Ionic.Zip.ZipEntry.Extract(string, ExtractExistingFileAction)"/>
///
/// <example>
/// This example extracts only the entries in a zip file that are .txt files,
/// into a directory called "textfiles".
/// <code lang="C#">
/// using (ZipFile zip = ZipFile.Read("PackedDocuments.zip"))
/// {
///   foreach (string s1 in zip.EntryFilenames)
///   {
///     if (s1.EndsWith(".txt"))
///     {
///       zip[s1].Extract("textfiles");
///     }
///   }
/// }
/// </code>
/// <code lang="VB">
///   Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip")
///       Dim s1 As String
///       For Each s1 In zip.EntryFilenames
///           If s1.EndsWith(".txt") Then
///               zip(s1).Extract("textfiles")
///           End If
///       Next
///   End Using
/// </code>
/// </example>
///
/// <remarks>
///
/// <para>
///   Using this method, existing entries in the filesystem will not be
///   overwritten. If you would like to force the overwrite of existing
///   files, see the <see cref="ExtractExistingFile"/> property, or call
///   <see cref="Extract(string, ExtractExistingFileAction)"/>.
/// </para>
///
/// <para>
///   See the remarks on the <see cref="LastModified"/> property, for some
///   details about how the last modified time of the created file is set.
/// </para>
/// </remarks>
/// <summary>
///   Extract the entry to the filesystem, starting at the specified base
///   directory, and using the specified behavior when extraction would
///   overwrite an existing file.
/// </summary>
///
/// <remarks>
/// <para>
///   See the remarks on the <see cref="LastModified"/> property, for some
///   details about how the last modified time of the created file is set.
/// </para>
/// </remarks>
///
/// <example>
/// <code lang="C#">
/// String sZipPath = "Airborne.zip";
/// String sFilePath = "Readme.txt";
/// String sRootFolder = "Digado";
/// using (ZipFile zip = ZipFile.Read(sZipPath))
/// {
///   if (zip.EntryFileNames.Contains(sFilePath))
///   {
///     // use the string indexer on the zip file
///     zip[sFileName].Extract(sRootFolder,
///                            ExtractExistingFileAction.OverwriteSilently);
///   }
/// }
/// </code>
///
/// <code lang="VB">
/// Dim sZipPath as String = "Airborne.zip"
/// Dim sFilePath As String = "Readme.txt"
/// Dim sRootFolder As String = "Digado"
/// Using zip As ZipFile = ZipFile.Read(sZipPath)
///   If zip.EntryFileNames.Contains(sFilePath)
///     ' use the string indexer on the zip file
///     zip(sFilePath).Extract(sRootFolder, _
///                            ExtractExistingFileAction.OverwriteSilently)
///   End If
/// End Using
/// </code>
/// </example>
///
/// <param name="baseDirectory">the pathname of the base directory</param>
/// <param name="extractExistingFile">
/// The action to take if extraction would overwrite an existing file.
/// </param>
/// <summary>
///   Extract the entry to the filesystem, using the current working directory
///   and the specified password.
/// </summary>
///
/// <overloads>
///   This method has a bunch of overloads! One of them is sure to be
///   the right one for you...
/// </overloads>
///
/// <seealso cref="Ionic.Zip.ZipEntry.ExtractExistingFile"/>
/// <seealso cref="Ionic.Zip.ZipEntry.ExtractWithPassword(ExtractExistingFileAction, string)"/>
///
/// <remarks>
///
/// <para>
///   Existing entries in the filesystem will not be overwritten. If you
///   would like to force the overwrite of existing files, see the <see
///   cref="Ionic.Zip.ZipEntry.ExtractExistingFile"/>property, or call
///   <see
///   cref="ExtractWithPassword(ExtractExistingFileAction,string)"/>.
/// </para>
///
/// <para>
///   See the remarks on the <see cref="LastModified"/> property for some
///   details about how the "last modified" time of the created file is
///   set.
/// </para>
/// </remarks>
///
/// <example>
///   In this example, entries that use encryption are extracted using a
///   particular password.
/// <code>
/// using (var zip = ZipFile.Read(FilePath))
/// {
///     foreach (ZipEntry e in zip)
///     {
///         if (e.UsesEncryption)
///             e.ExtractWithPassword("Secret!");
///         else
///             e.Extract();
///     }
/// }
/// </code>
/// <code lang="VB">
/// Using zip As ZipFile = ZipFile.Read(FilePath)
///     Dim e As ZipEntry
///     For Each e In zip
///         If (e.UsesEncryption)
///           e.ExtractWithPassword("Secret!")
///         Else
///           e.Extract
///         End If
///     Next
/// End Using
/// </code>
/// </example>
/// <param name="password">The Password to use for decrypting the entry.</param>
/// <summary>
///   Extract the entry to the filesystem, starting at the specified base
///   directory, and using the specified password.
/// </summary>
///
/// <seealso cref="Ionic.Zip.ZipEntry.ExtractExistingFile"/>
/// <seealso cref="Ionic.Zip.ZipEntry.ExtractWithPassword(string, ExtractExistingFileAction, string)"/>
///
/// <remarks>
/// <para>
///   Existing entries in the filesystem will not be overwritten. If you
///   would like to force the overwrite of existing files, see the <see
///   cref="Ionic.Zip.ZipEntry.ExtractExistingFile"/>property, or call
///   <see
///   cref="ExtractWithPassword(ExtractExistingFileAction,string)"/>.
/// </para>
///
/// <para>
///   See the remarks on the <see cref="LastModified"/> property, for some
///   details about how the last modified time of the created file is set.
/// </para>
/// </remarks>
///
/// <param name="baseDirectory">The pathname of the base directory.</param>
/// <param name="password">The Password to use for decrypting the entry.</param>
/// <summary>
///   Extract the entry to a file in the filesystem, relative to the
///   current directory, using the specified behavior when extraction
///   would overwrite an existing file.
/// </summary>
///
/// <remarks>
/// <para>
///   See the remarks on the <see cref="LastModified"/> property, for some
///   details about how the last modified time of the created file is set.
/// </para>
/// </remarks>
///
/// <param name="password">The Password to use for decrypting the entry.</param>
///
/// <param name="extractExistingFile">
/// The action to take if extraction would overwrite an existing file.
/// </param>
/// <summary>
///   Extract the entry to the filesystem, starting at the specified base
///   directory, and using the specified behavior when extraction would
///   overwrite an existing file.
/// </summary>
///
/// <remarks>
///   See the remarks on the <see cref="LastModified"/> property, for some
///   details about how the last modified time of the created file is set.
/// </remarks>
///
/// <param name="baseDirectory">the pathname of the base directory</param>
///
/// <param name="extractExistingFile">The action to take if extraction would
/// overwrite an existing file.</param>
///
/// <param name="password">The Password to use for decrypting the entry.</param>
/// <summary>
///   Extracts the entry to the specified stream, using the specified
///   Password.  For example, the caller could extract to Console.Out, or
///   to a MemoryStream.
/// </summary>
///
/// <remarks>
/// <para>
///   The caller can specify any write-able stream, for example a <see
///   cref="System.IO.FileStream"/>, a <see
///   cref="System.IO.MemoryStream"/>, or ASP.NET's
///   <c>Response.OutputStream</c>.  The content will be decrypted and
///   decompressed as necessary. If the entry is encrypted and no password
///   is provided, this method will throw.
/// </para>
/// <para>
///   The position on the stream is not reset by this method before it extracts.
///   You may want to call stream.Seek() before calling ZipEntry.Extract().
/// </para>
/// </remarks>
///
///
/// <param name="stream">
///   the stream to which the entry should be extracted.
/// </param>
/// <param name="password">
///   The password to use for decrypting the entry.
/// </param>
/// <summary>
///   Opens a readable stream corresponding to the zip entry in the
///   archive.  The stream decompresses and decrypts as necessary, as it
///   is read.
/// </summary>
///
/// <remarks>
///
/// <para>
///   DotNetZip offers a variety of ways to extract entries from a zip
///   file.  This method allows an application to extract an entry by
///   reading a <see cref="System.IO.Stream"/>.
/// </para>
///
/// <para>
///   The return value is of type <see
///   cref="Ionic.Crc.CrcCalculatorStream"/>.  Use it as you would any
///   stream for reading.  When an application calls <see
///   cref="Stream.Read(byte[], int, int)"/> on that stream, it will
///   receive data from the zip entry that is decrypted and decompressed
///   as necessary.
/// </para>
///
/// <para>
///   <c>CrcCalculatorStream</c> adds one additional feature: it keeps a
///   CRC32 checksum on the bytes of the stream as it is read.  The CRC
///   value is available in the <see
///   cref="Ionic.Crc.CrcCalculatorStream.Crc"/> property on the
///   <c>CrcCalculatorStream</c>.  When the read is complete, your
///   application
///   <em>should</em> check this CRC against the <see cref="ZipEntry.Crc"/>
///   property on the <c>ZipEntry</c> to validate the content of the
///   ZipEntry. You don't have to validate the entry using the CRC, but
///   you should, to verify integrity. Check the example for how to do
///   this.
/// </para>
///
/// <para>
///   If the entry is protected with a password, then you need to provide
///   a password prior to calling <see cref="OpenReader()"/>, either by
///   setting the <see cref="Password"/> property on the entry, or the
///   <see cref="ZipFile.Password"/> property on the <c>ZipFile</c>
///   itself. Or, you can use <see cref="OpenReader(String)" />, the
///   overload of OpenReader that accepts a password parameter.
/// </para>
///
/// <para>
///   If you want to extract entry data into a write-able stream that is
///   already opened, like a <see cref="System.IO.FileStream"/>, do not
///   use this method. Instead, use <see cref="Extract(Stream)"/>.
/// </para>
///
/// <para>
///   Your application may use only one stream created by OpenReader() at
///   a time, and you should not call other Extract methods before
///   completing your reads on a stream obtained from OpenReader().  This
///   is because there is really only one source stream for the compressed
///   content.  A call to OpenReader() seeks in the source stream, to the
///   beginning of the compressed content.  A subsequent call to
///   OpenReader() on a different entry will seek to a different position
///   in the source stream, as will a call to Extract() or one of its
///   overloads.  This will corrupt the state for the decompressing stream
///   from the original call to OpenReader().
/// </para>
///
/// <para>
///    The <c>OpenReader()</c> method works only when the ZipEntry is
///    obtained from an instance of <c>ZipFile</c>. This method will throw
///    an exception if the ZipEntry is obtained from a <see
///    cref="ZipInputStream"/>.
/// </para>
/// </remarks>
///
/// <example>
///   This example shows how to open a zip archive, then read in a named
///   entry via a stream. After the read loop is complete, the code
///   compares the calculated during the read loop with the expected CRC
///   on the <c>ZipEntry</c>, to verify the extraction.
/// <code>
/// using (ZipFile zip = new ZipFile(ZipFileToRead))
/// {
///   ZipEntry e1= zip["Elevation.mp3"];
///   using (Ionic.Zlib.CrcCalculatorStream s = e1.OpenReader())
///   {
///     byte[] buffer = new byte[4096];
///     int n, totalBytesRead= 0;
///     do {
///       n = s.Read(buffer,0, buffer.Length);
///       totalBytesRead+=n;
///     } while (n&gt;0);
///      if (s.Crc32 != e1.Crc32)
///       throw new Exception(string.Format("The Zip Entry failed the CRC Check. (0x{0:X8}!=0x{1:X8})", s.Crc32, e1.Crc32));
///      if (totalBytesRead != e1.UncompressedSize)
///       throw new Exception(string.Format("We read an unexpected number of bytes. ({0}!={1})", totalBytesRead, e1.UncompressedSize));
///   }
/// }
/// </code>
/// <code lang="VB">
///   Using zip As New ZipFile(ZipFileToRead)
///       Dim e1 As ZipEntry = zip.Item("Elevation.mp3")
///       Using s As Ionic.Zlib.CrcCalculatorStream = e1.OpenReader
///           Dim n As Integer
///           Dim buffer As Byte() = New Byte(4096) {}
///           Dim totalBytesRead As Integer = 0
///           Do
///               n = s.Read(buffer, 0, buffer.Length)
///               totalBytesRead = (totalBytesRead + n)
///           Loop While (n &gt; 0)
///           If (s.Crc32 &lt;&gt; e1.Crc32) Then
///               Throw New Exception(String.Format("The Zip Entry failed the CRC Check. (0x{0:X8}!=0x{1:X8})", s.Crc32, e1.Crc32))
///           End If
///           If (totalBytesRead &lt;&gt; e1.UncompressedSize) Then
///               Throw New Exception(String.Format("We read an unexpected number of bytes. ({0}!={1})", totalBytesRead, e1.UncompressedSize))
///           End If
///       End Using
///   End Using
/// </code>
/// </example>
/// <seealso cref="Ionic.Zip.ZipEntry.Extract(System.IO.Stream)"/>
/// <returns>The Stream for reading.</returns>
// workitem 10923
// use the entry password if it is non-null,
// else use the zipfile password, which is possibly null
/// <summary>
///   Opens a readable stream for an encrypted zip entry in the archive.
///   The stream decompresses and decrypts as necessary, as it is read.
/// </summary>
///
/// <remarks>
/// <para>
///   See the documentation on the <see cref="OpenReader()"/> method for
///   full details. This overload allows the application to specify a
///   password for the <c>ZipEntry</c> to be read.
/// </para>
/// </remarks>
///
/// <param name="password">The password to use for decrypting the entry.</param>
/// <returns>The Stream for reading.</returns>
// workitem 10923
// workitem 7958
// LeftToRead is a count of bytes remaining to be read (out)
// from the stream AFTER decompression and decryption.
// It is the uncompressed size, unless ... there is no compression in which
// case ...?  :< I'm not sure why it's not always UncompressedSize
// When in the context of a ZipFile.ExtractAll, the events are generated from
// the ZipFile method, not from within the ZipEntry instance. (why?)
// Therefore we suppress the events originating from the ZipEntry method.
// returned boolean is always ignored for all callers of OnBeforeExtract
// When in the context of a ZipFile.ExtractAll, the events are generated from
// the ZipFile method, not from within the ZipEntry instance. (why?)
// Therefore we suppress the events originating from the ZipEntry method.
// workitem 7881
// reset ReadOnly bit if necessary
/// <summary>
/// Pass in either basedir or s, but not both.
/// In other words, you can extract to a stream or to a directory (filesystem), but not both!
/// The Password param is required for encrypted entries.
/// </summary>
// workitem 7958
// workitem 10355
// if true, then the entry was a directory and has been created.
// We need to fire the Extract Event.
// workitem 10639
// do we want to extract to a regular filesystem file?
// Check for extracting to a previously existing file. The user
// can specify bejavior for that case: overwrite, don't
// overwrite, and throw.  Also, if the file exists prior to
// extraction, it affects exception handling: whether to delete
// the target of extraction or not. This check needs to be done
// before the password check is done, because password check may
// throw a BadPasswordException, which triggers the catch,
// wherein the existing file may be deleted if not flagged as
// pre-existing.
// cancel
// do not overwrite
// If no password explicitly specified, use the password on the entry itself,
// or on the zipfile itself.
// set up the output stream
// An exception has occurred. If the file exists, check
// to see if it existed before we tried extracting.  If
// it did not, attempt to remove the target file. There
// is a small possibility that the existing file has
// been extracted successfully, overwriting a previously
// existing file, and an exception was thrown after that
// but before final completion (setting times, etc). In
// that case the file will remain, even though some
// error occurred.  Nothing to be done about it.
/// <summary>
/// Extract to a stream
/// In other words, you can extract to a stream or to a directory (filesystem), but not both!
/// The Password param is required for encrypted entries.
/// </summary>
// workitem 7958
// workitem 10355
// if true, then the entry was a directory and has been created.
// We need to fire the Extract Event.
// If no password explicitly specified, use the password on the entry itself,
// or on the zipfile itself.
// need to dispose it
// workitem 10639
// move file to permanent home
// An AV program may hold the target file open, which means
// File.Delete() will succeed, though the actual deletion
// remains pending. This will prevent a subsequent
// File.Move() from succeeding. To avoid this, when the file
// already exists, we need to replace it in 3 steps:
//
//     1. rename the existing file to a zombie name;
//     2. rename the extracted file from the temp name to
//        the target file name;
//     3. delete the zombie.
//
// workitem 8264
// This is sort of a hack.  What I do here is set the time on
// the parent directory, every time a file is extracted into
// it.  If there is a directory with 1000 files, then I set
// the time on the dir, 1000 times. This allows the directory
// to have times that reflect the actual time on the entry in
// the zip archive.
// workitem 7071
//
// We can only apply attributes if they are relevant to the NTFS
// OS.  Must do this LAST because it may involve a ReadOnly bit,
// which would prevent us from setting the time, etc.
//
// workitem 7926 - version made by OS can be zero (FAT) or 10
// (NTFS)
// ensure the target path exists
// we create the directory here, but we do not set the
// create/modified/accessed times on it because it is being
// created implicitly, not explcitly. There's no entry in the
// zip archive for the directory.
// workitem 8264
// File.Create(CreateNew) will overwrite any existing file.
// After extracting, Validate the CRC32
// CRC is not meaningful with WinZipAES and AES method 2 (AE-2)
// ignore MAC if the size of the file is zero
// calculate the MAC
// throws if MAC is bad
// side effect: advances file position.
// returns: 0 == extract, 1 = don't, 2 = cancel
// loop around
// change for workitem 8098
// The extraction process varies depending on how the entry was
// stored.  It could have been encrypted, and it coould have
// been compressed, or both, or neither. So we need to check
// both the encryption flag and the compression flag, and take
// the proper action in all cases.
// Get a stream that either decrypts or not.
// As we read, we maybe decrypt, and then we maybe decompress. Then we write.
//Console.WriteLine("ExtractOne: LeftToRead {0}", LeftToRead);
// Casting LeftToRead down to an int is ok here in the else clause,
// because that only happens when it is less than bytes.Length,
// which is much less than MAX_INT.
// must check data read - essential for detecting corrupt zip files
// fire the progress event, check for cancels
// get a stream that either decompresses or not.
// workitem 8807:
// Because setting the time is not considered to be a fatal error,
// and because other applications can interfere with the setting
// of a time on a directory, we're going to swallow IO exceptions
// in this method.
// It's possible that the extract was cancelled, in which case,
// the file does not exist.
// It's possible that the extract was cancelled, in which case,
// the directory does not exist.
// workitem 6191
// workitem 7968
// - RC2 (version needed to extract < 5.2)
// - 3DES 168
// - 3DES 112
// - AES 128
// - AES 192
// - AES 256
// - RC2 (version needed to extract >= 5.2)
// - Blowfish
// - Twofish
// - RC4
// - Unknown algorithm
// workitem 7968
// only if BZIP not compiled in
// workitem 7968
//if (password == null) return;
// If we already have a WinZipAesCrypto object in place, use it.
// It can be set up in the ReadDirEntry(), or during a previous Extract.
/// <summary>
/// Validates that the args are consistent; returning whether the caller can return
/// because it's done, or not (caller should continue)
/// </summary>
// Sometimes the name on the entry starts with a slash.
// Rather than unpack to the root of the volume, we're going to
// drop the slash and unpack to the specified base directory.
// workitem 11772: remove drive letter with separator
// workitem 10639
// check if it is a directory
// the dir exists, maybe we want to overwrite times.
// true == all done, caller will return
// false == work to do by caller.
/// <summary>
/// Validates that the args are consistent; returning whether the caller can return
/// because it's done, or not (caller should continue)
/// </summary>
// ZipEntry.Read.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2011 Dino Chiesa
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-July-09 21:31:28>
//
// ------------------------------------------------------------------
//
// This module defines logic for Reading the ZipEntry from a
// zip file.
//
// ------------------------------------------------------------------
// workitem 8098: ok (restore)
// workitem 8098: ok (relative)
// workitem 8098: ok (restore)
// change for workitem 8098
// Return false if this is not a local file header signature.
// Getting "not a ZipEntry signature" is not always wrong or an error.
// This will happen after the last entry in a zipfile.  In that case, we
// expect to read :
//    a ZipDirEntry signature (if a non-empty zip file) or
//    a ZipConstants.EndOfCentralDirectorySignature.
//
// Anything else is a surprise.
// unread the signature
// transform the time data into something usable (a DateTime)
// this *may* change after processing the Extra field
// NB: if ((ze._BitField & 0x0008) != 0x0008), then the Compressed, uncompressed and
// CRC values are not true values; the true values will follow the entry data.
// But, regardless of the status of bit 3 in the bitfield, the slots for
// the three amigos may contain marker values for ZIP64.  So we must read them.
// if the UTF8 bit is set for this entry, override the
// encoding the application requested.
// workitem 12744
// workitem 6898
// workitem 6607 - don't read for directories
// actually get the compressed size and CRC if necessary
// This descriptor exists only if bit 3 of the general
// purpose bit flag is set (see below).  It is byte aligned
// and immediately follows the last byte of compressed data,
// as well as any encryption trailer, as with AES.
// This descriptor is used only when it was not possible to
// seek in the output .ZIP file, e.g., when the output .ZIP file
// was standard output or a non-seekable device.  For ZIP64(tm) format
// archives, the compressed and uncompressed sizes are 8 bytes each.
// workitem 8098: ok (restore)
// Here, we're going to loop until we find a ZipEntryDataDescriptorSignature and
// a consistent data record after that.   To be consistent, the data record must
// indicate the length of the entry data.
// We call the FindSignature shared routine to find the specified signature
// in the already-opened zip archive, starting from the current cursor
// position in that filestream.  If we cannot find the signature, then the
// routine returns -1, and the ReadHeader() method returns false,
// indicating we cannot read a legal entry header.  If we have found it,
// then the FindSignature() method returns the number of bytes in the
// stream we had to seek forward, to find the sig.  We need this to
// determine if the zip entry is valid, later.
// total size of data read (through all loops of this).
// read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size, Uncompressed Size)
// do not increment bytesRead - it is for entry header only.
// the data we have just read is a footer (falls after the file data)
//bytesRead += n;
// read 3x 4-byte fields (CRC, Compressed Size, Uncompressed Size)
// do not increment bytesRead - it is for entry header only.
// the data we have just read is a footer (falls after the file data)
//bytesRead += n;
// Seek back to un-read the last 12 bytes  - maybe THEY contain
// the ZipEntryDataDescriptorSignature.
// (12 bytes for the CRC, Comp and Uncomp size.)
// Adjust the size to account for the false signature read in
// FindSignature().
// seek back to previous position, to prepare to read file data
// workitem 8098: ok (restore)
// bytes including sig, CRC, Comp and Uncomp sizes
// bit 0 set indicates that some kind of encryption is in use
// read in the WinZip AES metadata: salt + PV. 18 bytes for AES256. 10 bytes for AES128.
// MAC (follows crypto bytes)
// according to WinZip, the CompressedSize includes the AES Crypto framing data.
// MAC
// read in the header data for "weak" encryption
// decrease the filedata size by 12 bytes
// Remember the size of the blob for this entry.
// We also have the starting position in the stream for this entry.
// We've read in the regular entry header, the extra field, and any
// encryption header.  The pointer in the file is now at the start of the
// filedata, which is potentially compressed and encrypted.  Just ahead in
// the file, there are _CompressedFileDataSize bytes of data, followed by
// potentially a non-zero length trailer, consisting of optionally, some
// encryption stuff (10 byte MAC for AES), and the bit-3 trailer (16 or 24
// bytes).
// PKZIP encrypts the compressed data stream.  Encrypted files must
// be decrypted before they can be extracted.
// Each PKZIP-encrypted file has an extra 12 bytes stored at the start of the data
// area defining the encryption header for that file.  The encryption header is
// originally set to random values, and then itself encrypted, using three, 32-bit
// keys.  The key values are initialized using the supplied encryption password.
// After each byte is encrypted, the keys are then updated using pseudo-random
// number generation techniques in combination with the same CRC-32 algorithm used
// in PKZIP and implemented in the CRC32.cs module in this project.
// read the 12-byte encryption header
/// <summary>
///   Reads one <c>ZipEntry</c> from the given stream.  The content for
///   the entry does not get decompressed or decrypted.  This method
///   basically reads metadata, and seeks.
/// </summary>
/// <param name="zc">the ZipContainer this entry belongs to.</param>
/// <param name="first">
///   true of this is the first entry being read from the stream.
/// </param>
/// <returns>the <c>ZipEntry</c> read from the stream.</returns>
// Read entry header, including any encryption header
// Store the position in the stream for this entry
// change for workitem 8098
// seek past the data without reading it. We will read on Extract()
// ReadHeader moves the file pointer to the end of the entry header,
// as well as any encryption header.
// CompressedFileDataSize includes:
//   the maybe compressed, maybe encrypted file data
//   the encryption trailer, if any
//   the bit 3 descriptor, if any
// workitem 5306
// http://www.codeplex.com/DotNetZip/WorkItem/View.aspx?WorkItemId=5306
// in some cases, the zip file begins with "PK00".  This is a throwback and is rare,
// but we handle it anyway. We do not change behavior based on it.
// unread the block
// In some cases, the "data descriptor" is present, without a signature, even when
// bit 3 of the BitField is NOT SET.  This is the CRC, followed
//    by the compressed length and the uncompressed length (4 bytes for each
//    of those three elements).  Need to check that here.
//
// ignore everything and discard it.
// unread the three blocks
// unread the two blocks
// unread the block
/// <summary>
///   Finds a particular segment in the given extra field.
///   This is used when modifying a previously-generated
///   extra field, in particular when removing the AES crypto
///   segment in the extra field.
/// </summary>
// else advance to next segment
/// <summary>
///   At current cursor position in the stream, read the extra
///   field, and set the properties on the ZipEntry instance
///   appropriately.  This can be called when processing the
///   Extra field in the Central Directory, or in the local
///   header.
/// </summary>
// NTFS ctime, atime, mtime
// Unix ctime, atime, mtime
// Info-zip Extra field (outdated)
// This is outdated, so the field is supported on
// read only.
// Unix uid/gid
// ignored. DotNetZip does not handle this field.
// ??
// ignored.  I could not find documentation on this field,
// though it appears in some zip files.
// ZIP64
// WinZip AES encryption is in use.  (workitem 6834)
// we will handle this extra field only  if compressionmethod is 0x63
// workitem 7968: handle PKWare Strong encryption header
// move to the next Header in the extra field
//           Value     Size     Description
//           -----     ----     -----------
//           0x0017    2 bytes  Tag for this "extra" block type
//           TSize     2 bytes  Size of data that follows
//           Format    2 bytes  Format definition for this record
//           AlgID     2 bytes  Encryption algorithm identifier
//           Bitlen    2 bytes  Bit length of encryption key
//           Flags     2 bytes  Processing flags
//           CertData  TSize-8  Certificate decryption extra field data
//                              (refer to the explanation for CertData
//                               in the section describing the
//                               Certificate Processing Method under
//                               the Strong Encryption Specification)
// DotNetZip doesn't support this algorithm, but we don't need to throw
// here.  we might just be reading the archive, which is fine.  We'll
// need to throw if Extract() is called.
//this._aesCrypto = new WinZipAesCrypto(this);
// see spec at http://www.winzip.com/aes_info.htm
// set the actual compression method
// for the next segment of the extra field
// The PKWare spec says that any of {UncompressedSize, CompressedSize,
// RelativeOffset} exceeding 0xFFFFFFFF can lead to the ZIP64 header,
// and the ZIP64 header may contain one or more of those.  If the
// values are present, they will be found in the prescribed order.
// There may also be a 4-byte "disk start number."
// This means that the DataSize must be 28 bytes or less.
// workitem 7941: check datasize before reading.
// Ignore anything else. Potentially there are 4 more bytes for the
// disk start number.  DotNetZip currently doesn't handle multi-disk
// archives.
// The Unix filetimes are 32-bit unsigned integers,
// storing seconds since Unix epoch.
// will recurse
// The NTFS filetimes are 64-bit unsigned integers, stored in Intel
// (least significant byte first) byte order. They are expressed as the
// number of 1.0E-07 seconds (1/10th microseconds!) past WinNT "epoch",
// which is "01-Jan-1601 00:00:00 UTC".
//
// HeaderId   2 bytes    0x000a == NTFS stuff
// Datasize   2 bytes    ?? (usually 32)
// reserved   4 bytes    ??
// timetag    2 bytes    0x0001 == time
// size       2 bytes    24 == 8 bytes each for ctime, mtime, atime
// mtime      8 bytes    win32 ticks since win32epoch
// atime      8 bytes    win32 ticks since win32epoch
// ctime      8 bytes    win32 ticks since win32epoch
// reserved
// tag and size
// At this point the library *could* set the LastModified value
// to coincide with the Mtime value.  In theory, they refer to
// the same property of the file, and should be the same anyway,
// allowing for differences in precision.  But they are
// independent quantities in the zip archive, and this library
// will keep them separate in the object model. There is no ill
// effect from this, because as files are extracted, the
// higher-precision value (Mtime) is used if it is present.
// Apps may wish to compare the Mtime versus LastModified
// values, but any difference when both are present is not
// germaine to the correctness of the library. but note: when
// explicitly setting either value, both are set. See the setter
// for LastModified or the SetNtfsTimes() method.
//#define Trace
// ZipEntry.Write.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2011 Dino Chiesa
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// Last Saved: <2011-July-30 14:55:47>
//
// ------------------------------------------------------------------
//
// This module defines logic for writing (saving) the ZipEntry into a
// zip file.
//
// ------------------------------------------------------------------
//CDE header size: 46 + extra field length + filename length + comment length
// signature
// Version Made By
// workitem 7071
// We must not overwrite the VersionMadeBy field when writing out a zip
// archive.  The VersionMadeBy tells the zip reader the meaning of the
// File attributes.  Overwriting the VersionMadeBy will result in
// inconsistent metadata.  Consider the scenario where the application
// opens and reads a zip file that had been created on Linux. Then the
// app adds one file to the Zip archive, and saves it.  The file
// attributes for all the entries added on Linux will be significant for
// Linux.  Therefore the VersionMadeBy for those entries must not be
// changed.  Only the entries that are actually created on Windows NTFS
// should get the VersionMadeBy indicating Windows/NTFS.
// Apparently we want to duplicate the extra field here; we cannot
// simply zero it out and assume tools and apps will use the right one.
////Int16 extraFieldLengthSave = (short)(_EntryHeader[28] + _EntryHeader[29] * 256);
////_EntryHeader[28] = 0;
////_EntryHeader[29] = 0;
// Version Needed, Bitfield, compression method, lastmod,
// crc, compressed and uncompressed sizes, filename length and extra field length.
// These are all present in the local file header, but they may be zero values there.
// So we cannot just copy them.
// workitem 11969: Version Needed To Extract in central directory must be
// the same as the local entry or MS .NET System.IO.Zip fails read.
// workitem 12964
// a zipentry in a zipoutputstream, with zero bytes written
// CompressedSize (Int32) and UncompressedSize - all 0xFF
// do this again because now we have real data
// workitem 11131
//
// cannot generate the extra field again, here's why: In the case of a
// zero-byte entry, which uses encryption, DotNetZip will "remove" the
// encryption from the entry.  It does this in PostProcessOutput; it
// modifies the entry header, and rewrites it, resetting the Bitfield
// (one bit indicates encryption), and potentially resetting the
// compression method - for AES the Compression method is 0x63, and it
// would get reset to zero (no compression).  It then calls SetLength()
// to truncate the stream to remove the encryption header (12 bytes for
// AES256).  But, it leaves the previously-generated "Extra Field"
// metadata (11 bytes) for AES in the entry header. This extra field
// data is now "orphaned" - it refers to AES encryption when in fact no
// AES encryption is used. But no problem, the PKWARE spec says that
// unrecognized extra fields can just be ignored. ok.  After "removal"
// of AES encryption, the length of the Extra Field can remains the
// same; it's just that there will be 11 bytes in there that previously
// pertained to AES which are now unused. Even the field code is still
// there, but it will be unused by readers, as the encryption bit is not
// set.
//
// Re-calculating the Extra field now would produce a block that is 11
// bytes shorter, and that mismatch - between the extra field in the
// local header and the extra field in the Central Directory - would
// cause problems. (where? why? what problems?)  So we can't do
// that. It's all good though, because though the content may have
// changed, the length definitely has not. Also, the _EntryHeader
// contains the "updated" extra field (after PostProcessOutput) at
// offset (30 + filenameLength).
// File (entry) Comment Length
// the _CommentBytes private field was set during WriteHeader()
// skip comment length because we set it at the end
// Disk number start
// workitem 13915
// Emit nonzero disknumber only if saving segmented archive.
// If reading a segmneted archive and saving to a regular archive,
// ZipEntry._diskNumber will be non-zero but it should be saved as
// zero.
// internal file attrs
// workitem 7801
// lo bit: filetype hint.  0=bin, 1=txt.
// external file attrs
// workitem 7071
// workitem 11131
// relative offset of local header.
//
// If necessary to go to 64-bit value, then emit 0xFFFFFFFF,
// else write out the value.
//
// Even if zip64 is required for other reasons - number of the entry
// > 65534, or uncompressed size of the entry > MAX_INT32, the ROLH
// need not be stored in a 64-bit field .
// _OutputUsesZip64.Value
// actual filename
// "Extra field"
// workitem 11131
//
// copy from EntryHeader if available - it may have been updated.
// if not, copy from Extra. This would be unnecessary if I just
// updated the Extra field when updating EntryHeader, in
// PostProcessOutput.
//?? I don't understand why I wouldn't want to just use
// the recalculated Extra field. ??
// byte[] h = _EntryHeader ?? _Extra;
// int offx = (h == _EntryHeader) ? 30 + filenameLength : 0;
// Buffer.BlockCopy(h, offx, bytes, i, extraFieldLength);
// i += extraFieldLength;
// file (entry) comment
// the size of our buffer defines the max length of the comment we can write
// now actually write the comment itself into the byte buffer
// for (j = 0; (j < commentLength) && (i + j < bytes.Length); j++)
//     bytes[i + j] = _CommentBytes[j];
// Conditionally emit an extra field with Zip64 information.  If the
// Zip64 option is Always, we emit the field, before knowing that it's
// necessary.  Later, if it turns out this entry does not need zip64,
// we'll set the header ID to rubbish and the data will be ignored.
// This results in additional overhead metadata in the zip file, but
// it will be small in comparison to the entry data.
//
// On the other hand if the Zip64 option is AsNecessary and it's NOT
// for the central directory, then we do the same thing.  Or, if the
// Zip64 option is AsNecessary and it IS for the central directory,
// and the entry requires zip64, then emit the header.
// add extra field for zip64 here
// workitem 7924
// HeaderId = always use zip64 extensions.
// HeaderId = dummy data now, maybe set to 0x0001 (ZIP64) later.
// DataSize
// decimal 28 or 16  (workitem 7924)
// The actual metadata - we may or may not have real values yet...
// uncompressed size
// compressed size
// workitem 7924 - only include this if the "extra" field is for
// use in the central directory.  It is unnecessary and not useful
// for local header; makes WinZip choke.
// relative offset
// starting disk number
// extra field for WinZip AES
// header id
// data size
// vendor number
// AE-1 - means "Verify CRC"
// vendor id "AE"
// key strength
// actual compression method
// HeaderId   2 bytes    0x000a == NTFS times
// Datasize   2 bytes    32
// reserved   4 bytes    ?? don't care
// timetag    2 bytes    0x0001 == NTFS time
// size       2 bytes    24 == 8 bytes each for ctime, mtime, atime
// mtime      8 bytes    win32 ticks since win32epoch
// atime      8 bytes    win32 ticks since win32epoch
// ctime      8 bytes    win32 ticks since win32epoch
// extra field for NTFS times
// header id
// data size
// reserved
// time tag
// data size (again)
// local form:
// --------------
// HeaderId   2 bytes    0x5455 == unix timestamp
// Datasize   2 bytes    13
// flags      1 byte     7 (low three bits all set)
// mtime      4 bytes    seconds since unix epoch
// atime      4 bytes    seconds since unix epoch
// ctime      4 bytes    seconds since unix epoch
//
// central directory form:
//---------------------------------
// HeaderId   2 bytes    0x5455 == unix timestamp
// Datasize   2 bytes    5
// flags      1 byte     7 (low three bits all set)
// mtime      4 bytes    seconds since unix epoch
//
// extra field for "unix" times
// header id
// data size
// flags
// inject other blocks here...
// concatenate any blocks we've got:
// private System.Text.Encoding GenerateCommentBytes()
// {
//     var getEncoding = new Func<System.Text.Encoding>({
//     switch (AlternateEncodingUsage)
//     {
//         case ZipOption.Always:
//             return AlternateEncoding;
//         case ZipOption.Never:
//             return ibm437;
//     }
//     var cb = ibm437.GetBytes(_Comment);
//     string s1 = ibm437.GetString(cb);
//     if (s1 == _Comment)
//         return ibm437;
//     return AlternateEncoding;
//     });
//
//     var encoding = getEncoding();
//     _CommentBytes = encoding.GetBytes(_Comment);
//     return encoding;
// }
// here, we need to flip the backslashes to forward-slashes,
// also, we need to trim the \\server\share syntax from any UNC path.
// and finally, we need to remove any leading .\
// trim off volume letter, colon, and slash
// trim off dot and slash
/// <summary>
///   generate and return a byte array that encodes the filename
///   for the entry.
/// </summary>
/// <remarks>
///   <para>
///     side effects: generate and store into _CommentBytes the
///     byte array for any comment attached to the entry. Also
///     sets _actualEncoding to indicate the actual encoding
///     used. The same encoding is used for both filename and
///     comment.
///   </para>
/// </remarks>
// workitem 6513
// arriving here means AlternateEncodingUsage is "AsNecessary"
// case ZipOption.AsNecessary:
// workitem 6513: when writing, use the alternative encoding
// only when _actualEncoding is not yet set (it can be set
// during Read), and when ibm437 will not do.
// Encoding the filename with ibm437 does not allow round-trips.
// Therefore, use the alternate encoding.  Assume it will work,
// no checking of round trips here.
// Using ibm437, FileName can be encoded without information
// loss; now try the Comment.
// if there is no comment, use ibm437.
// there is a comment. Get the encoded form.
// Check for round-trip.
// Comment cannot correctly be encoded with ibm437.  Use
// the alternate encoding.
// use IBM437
// if we've already tried with compression... turn it off this time
// compression for directories = 0x00 (No Compression)
// do nothing
// If __FileDataPosition is zero, then that means we will get the data
// from a file or stream.
// It is never possible to compress a zero-length file, so we check for
// this condition.
// workitem 7742
// Length prop will throw if CanSeek is false
// Ok, we're getting the data to be compressed from a
// non-zero-length file or stream, or a file or stream of
// unknown length, and we presume that it is non-zero.  In
// that case we check the callback to see if the app wants
// to tell us whether to compress or not.
// finally, set CompressionMethod to None if CompressionLevel is None
// write the header info for an entry
// Must remember the offset, within the output stream, of this particular
// entry header.
//
// This is for 2 reasons:
//
//  1. so we can determine the RelativeOffsetOfLocalHeader (ROLH) for
//     use in the central directory.
//  2. so we can seek backward in case there is an error opening or reading
//     the file, and the application decides to skip the file. In this case,
//     we need to seek backward in the output stream to allow the next entry
//     to be added to the zipfile output stream.
//
// Normally you would just store the offset before writing to the output
// stream and be done with it.  But the possibility to use split archives
// makes this approach ineffective.  In split archives, each file or segment
// is bound to a max size limit, and each local file header must not span a
// segment boundary; it must be written contiguously.  If it will fit in the
// current segment, then the ROLH is just the current Position in the output
// stream.  If it won't fit, then we need a new file (segment) and the ROLH
// is zero.
//
// But we only can know if it is possible to write a header contiguously
// after we know the size of the local header, a size that varies with
// things like filename length, comments, and extra fields.  We have to
// compute the header fully before knowing whether it will fit.
//
// That takes care of item #1 above.  Now, regarding #2.  If an error occurs
// while computing the local header, we want to just seek backward. The
// exception handling logic (in the caller of WriteHeader) uses ROLH to
// scroll back.
//
// All this means we have to preserve the starting offset before computing
// the header, and also we have to compute the offset later, to handle the
// case of split archives.
// workitem 8098: ok (output)
// This may change later, for split archives
// Don't set _RelativeOffsetOfLocalHeader. Instead, set a temp variable.
// This allows for re-streaming, where a zip entry might be read from a
// zip archive (and maybe decrypted, and maybe decompressed) and then
// written to another zip archive, with different settings for
// compression method, compression level, or encryption algorithm.
// signature
// Design notes for ZIP64:
//
// The specification says that the header must include the Compressed
// and Uncompressed sizes, as well as the CRC32 value.  When creating
// a zip via streamed processing, these quantities are not known until
// after the compression is done.  Thus, a typical way to do it is to
// insert zeroes for these quantities, then do the compression, then
// seek back to insert the appropriate values, then seek forward to
// the end of the file data.
//
// There is also the option of using bit 3 in the GP bitfield - to
// specify that there is a data descriptor after the file data
// containing these three quantities.
//
// This works when the size of the quantities is known, either 32-bits
// or 64 bits as with the ZIP64 extensions.
//
// With Zip64, the 4-byte fields are set to 0xffffffff, and there is a
// corresponding data block in the "extra field" that contains the
// actual Compressed, uncompressed sizes.  (As well as an additional
// field, the "Relative Offset of Local Header")
//
// The problem is when the app desires to use ZIP64 extensions
// optionally, only when necessary.  Suppose the library assumes no
// zip64 extensions when writing the header, then after compression
// finds that the size of the data requires zip64.  At this point, the
// header, already written to the file, won't have the necessary data
// block in the "extra field".  The size of the entry header is fixed,
// so it is not possible to just "add on" the zip64 data block after
// compressing the file.  On the other hand, always using zip64 will
// break interoperability with many other systems and apps.
//
// The approach we take is to insert a 32-byte dummy data block in the
// extra field, whenever zip64 is to be used "as necessary". This data
// block will get the actual zip64 HeaderId and zip64 metadata if
// necessary.  If not necessary, the data block will get a meaningless
// HeaderId (0x1111), and will be filled with zeroes.
//
// When zip64 is actually in use, we also need to set the
// VersionNeededToExtract field to 45.
//
// There is one additional wrinkle: using zip64 as necessary conflicts
// with output to non-seekable devices.  The header is emitted and
// must indicate whether zip64 is in use, before we know if zip64 is
// necessary.  Because there is no seeking, the header can never be
// changed.  Therefore, on non-seekable devices,
// Zip64Option.AsNecessary is the same as Zip64Option.Always.
//
// version needed- see AppNote.txt.
//
// need v5.1 for PKZIP strong encryption, or v2.0 for no encryption or
// for PK encryption, 4.5 for zip64.  We may reset this later, as
// necessary or zip64.
// (i==4)
// Get byte array. Side effect: sets ActualEncoding.
// Must determine encoding before setting the bitfield.
// workitem 6513
// general purpose bitfield
// In the current implementation, this library uses only these bits
// in the GP bitfield:
//  bit 0 = if set, indicates the entry is encrypted
//  bit 3 = if set, indicates the CRC, C and UC sizes follow the file data.
//  bit 6 = strong encryption - for pkware's meaning of strong encryption
//  bit 11 = UTF-8 encoding is used in the comment and filename
// Here we set or unset the encryption bit.
// _BitField may already be set, as with a ZipEntry added into ZipOutputStream, which
// has bit 3 always set. We only want to set one bit
// encryption bit OFF
// encryption bit ON
// workitem 7941: WinZip does not the "strong encryption" bit  when using AES.
// This "Strong Encryption" is a PKWare Strong encryption thing.
//                 _BitField |= 0x0020;
// set the UTF8 bit if necessary
// The PKZIP spec says that if bit 3 is set (0x0008) in the General
// Purpose BitField, then the CRC, Compressed size, and uncompressed
// size are written directly after the file data.
//
// These 3 quantities are normally present in the regular zip entry
// header. But, they are not knowable until after the compression is
// done. So, in the normal case, we
//
//  - write the header, using zeros for these quantities
//  - compress the data, and incidentally compute these quantities.
//  - seek back and write the correct values them into the header.
//
// This is nice because, while it is more complicated to write the zip
// file, it is simpler and less error prone to read the zip file, and
// as a result more applications can read zip files produced this way,
// with those 3 quantities in the header.
//
// But if seeking in the output stream is not possible, then we need
// to set the appropriate bitfield and emit these quantities after the
// compressed file data in the output.
//
// workitem 7216 - having trouble formatting a zip64 file that is
// readable by WinZip.  not sure why!  What I found is that setting
// bit 3 and following all the implications, the zip64 file is
// readable by WinZip 12. and Perl's IO::Compress::Zip .  Perl takes
// an interesting approach - it always sets bit 3 if ZIP64 in use.
// DotNetZip now does the same; this gives better compatibility with
// WinZip 12.
// (cycle == 99) indicates a zero-length entry written by ZipOutputStream
// unset bit 3 - no "data descriptor" - ever
// unset bit 1 - no encryption - ever
// Set bit 3 to avoid the double-read perf issue.
//
// When PKZIP encryption is used, byte 11 of the encryption header is
// used as a consistency check. It is normally set to the MSByte of the
// CRC.  But this means the cRC must be known ebfore compression and
// encryption, which means the entire stream has to be read twice.  To
// avoid that, the high-byte of the time blob (when in DOS format) can
// be used for the consistency check (byte 11 in the encryption header).
// But this means the entry must have bit 3 set.
//
// Previously I used a more complex arrangement - using the methods like
// FigureCrc32(), PrepOutputStream() and others, in order to manage the
// seek-back in the source stream.  Why?  Because bit 3 is not always
// friendly with third-party zip tools, like those on the Mac.
//
// This is why this code is still ifdef'd  out.
//
// Might consider making this yet another programmable option -
// AlwaysUseBit3ForPkzip.  But that's for another day.
//
// (i==6)
// Here, we want to set values for Compressed Size, Uncompressed Size,
// and CRC.  If we have __FileDataPosition as not -1 (zero is a valid
// FDP), then that means we are reading this zip entry from a zip
// file, and we have good values for those quantities.
//
// If _FileDataPosition is -1, then we are constructing this Entry
// from nothing.  We zero those quantities now, and we will compute
// actual values for the three quantities later, when we do the
// compression, and then seek back to write them into the appropriate
// place in the header.
//_UncompressedSize = 0; // do not unset - may need this value for restream
// _Crc32 = 0;           // ditto
// set compression method here
// (i==8) compression method
// (cycle == 99) indicates a zero-length entry written by ZipOutputStream
// LastMod
// (i==10) time blob
// (i==14) CRC - if source==filesystem, this is zero now, actual value
// will be calculated later.  if source==archive, this is a bonafide
// value.
// (i==18) CompressedSize (Int32) and UncompressedSize - all 0xFF for now
// (i==18) CompressedSize (Int32) - this value may or may not be
// bonafide.  if source == filesystem, then it is zero, and we'll
// learn it after we compress.  if source == archive, then it is
// bonafide data.
// (i==22) UncompressedSize (Int32) - this value may or may not be
// bonafide.
// (i==26) filename length (Int16)
// (i==28) extra field length (short)
// workitem 13542
// get the fixed portion
//for (j = 0; j < i; j++) bytes[j] = block[j];
// The filename written to the archive.
// for (j = 0; j < fileNameBytes.Length; j++)
//     bytes[i + j] = fileNameBytes[j];
// "Extra field"
// for (j = 0; j < _Extra.Length; j++)
//     bytes[i + j] = _Extra[j];
// handle split archives
// rollover!
// validate the ZIP64 usage
// finally, write the header to the stream
// now that the header is written, we can turn off the contiguous write restriction.
// Preserve this header data, we'll use it again later.
// ..when seeking backward, to write again, after we have the Crc, compressed
//   and uncompressed sizes.
// ..and when writing the central directory structure.
// get the original stream:
// allow the application to write the data
// nothing to do - the CRC is already set
// allow the application to open the stream
//input = File.OpenRead(LocalFileName);
/// <summary>
///   Stores the position of the entry source stream, or, if the position is
///   already stored, seeks to that position.
/// </summary>
///
/// <remarks>
/// <para>
///   This method is called in prep for reading the source stream.  If PKZIP
///   encryption is used, then we need to calc the CRC32 before doing the
///   encryption, because the CRC is used in the 12th byte of the PKZIP
///   encryption header.  So, we need to be able to seek backward in the source
///   when saving the ZipEntry. This method is called from the place that
///   calculates the CRC, and also from the method that does the encryption of
///   the file data.
/// </para>
///
/// <para>
///   The first time through, this method sets the _sourceStreamOriginalPosition
///   field. Subsequent calls to this method seek to that position.
/// </para>
/// </remarks>
// this will happen the 2nd cycle through, if the stream is seekable
// this will happen the first cycle through, if seekable
// In general, using PKZIP encryption on a a zip entry whose input
// comes from a non-seekable stream, is tricky.  Here's why:
//
// Byte 11 of the PKZIP encryption header is used for password
// validation and consistency checknig.
//
// Normally, the highest byte of the CRC is used as the 11th (last) byte
// in the PKZIP encryption header. This means the CRC must be known
// before encryption is performed. Normally that means we read the full
// data stream, compute the CRC, then seek back and read it again for
// the compression+encryption phase. Obviously this is bad for
// performance with a large input file.
//
// There's a twist in the ZIP spec (actually documented only in infozip
// code, not in the spec itself) that allows the high-order byte of the
// last modified time for the entry, when the lastmod time is in packed
// (DOS) format, to be used for Byte 11 in the encryption header. In
// this case, the bit 3 "data descriptor" must be used.
//
// An intelligent implementation would therefore force the use of the
// bit 3 data descriptor when PKZIP encryption is in use, regardless.
// This avoids the double-read of the stream to be encrypted.  So far,
// DotNetZip doesn't do that; it just punts when the input stream is
// non-seekable, and the output does not use Bit 3.
//
// The other option is to use the CRC when it is already available, eg,
// when the source for the data is a ZipEntry (when the zip file is
// being updated). In this case we already know the CRC and can just use
// what we know.
/// <summary>
/// Copy metadata that may have been changed by the app.  We do this when
/// resetting the zipFile instance.  If the app calls Save() on a ZipFile, then
/// tries to party on that file some more, we may need to Reset() it , which
/// means re-reading the entries and then copying the metadata.  I think.
/// </summary>
// Read in the data from the input stream (often a file in the filesystem),
// and write it to the output stream, calculating a CRC on it as we go.
// We will also compress and encrypt as necessary.
// Want to record the position in the zip file of the zip entry
// data (as opposed to the metadata).  s.Position may fail on some
// write-only streams, eg stdout or System.Web.HttpResponseStream.
// We swallow that exception, because we don't care, in that case.
// But, don't set __FileDataPosition directly.  It may be needed
// to READ the zip entry from the zip file, if this is a
// "re-stream" situation. In other words if the zip entry has
// changed compression level, or compression method, or (maybe?)
// encryption algorithm.  In that case if the original entry is
// encrypted, we need __FileDataPosition to be the value for the
// input zip file.  This s.Position is for the output zipfile.  So
// we copy fdp to __FileDataPosition after this entry has been
// (maybe) restreamed.
// Use fileLength for progress updates, and to decide whether we can
// skip encryption and compression altogether (in case of length==zero)
// Wrap a counting stream around the raw output stream:
// This is the last thing that happens before the bits go to the
// application-provided stream.
//
// Sometimes s is a CountingStream. Doesn't matter. Wrap it with a
// counter anyway. We need to count at both levels.
// Maybe wrap an encrypting stream around the counter: This will
// happen BEFORE output counting, and AFTER compression, if encryption
// is used.
// Maybe wrap a compressing Stream around that.
// This will happen BEFORE encryption (if any) as we write data out.
// Wrap a CrcCalculatorStream around that.
// This will happen BEFORE compression (if any) as we write data out.
// output.Write() causes this flow:
// calc-crc -> compress -> encrypt -> count -> actually write
// allow the application to write the data
// synchronously copy the input stream to the output stream-chain
// allow the application to close the stream
// set FDP now, to allow for re-streaming
/// <summary>
///   Set the input stream and get its length, if possible.  The length is
///   used for progress updates, AND, to allow an optimization in case of
///   a stream/file of zero length. In that case we skip the Encrypt and
///   compression Stream. (like DeflateStream or BZip2OutputStream)
/// </summary>
// get the original stream:
// Try to get the length, no big deal if not available.
// we are "re-streaming" the zip entry.
// allow the application to open the stream
// workitem 7145
// workitem 8423
// by calling Close() on the deflate stream, we write the footer bytes, as necessary.
// may be adjusted
// Set _RelativeOffsetOfLocalHeader now, to allow for re-streaming
// workitem 8931 - for WriteDelegate.
// The WriteDelegate changes things because there can be a zero-byte stream
// written. In all other cases DotNetZip knows the length of the stream
// before compressing and encrypting. In this case we have to circle back,
// and omit all the crypto stuff - the GP bitfield, and the crypto header.
// nothing to do...
// seek back in the stream to un-output the security metadata
// workitem 11131
// adjust the count on the CountingStream as necessary
// subtract the size of the security header from the _LengthOfHeader
// turn off the encryption bit
// copy the updated bitfield value into the header
// Fix the extra field - overwrite the 0x9901 headerId
// with dummy data. (arbitrarily, 0x9999)
// 12 extra bytes for the encryption header
// adjust the compressed size to include the variable (salt+pv)
// security header and 10-byte trailer. According to the winzip AES
// spec, that metadata is included in the "Compressed Size" figure
// when encoding the zip archive.
// CRC - the correct value now
// (i==26) filename length (Int16)
// VersionNeededToExtract - set to 45 to indicate zip64
// workitem 7924 - don't need bit 3
// // workitem 7917
// // set bit 3 for ZIP64 compatibility with WinZip12
// _BitField |= 0x0008;
// _EntryHeader[6] = (byte)(_BitField & 0x00FF);
// CompressedSize and UncompressedSize - 0xFF
// At this point we need to find the "Extra field" that follows the
// filename.  We had already emitted it, but the data (uncomp, comp,
// ROLH) was not available at the time we did so.  Here, we emit it
// again, with final values.
// zip64
// skip over data size, which is 16+4
// VersionNeededToExtract - reset to 20 since no zip64
// CompressedSize - the correct value now
// UncompressedSize - the correct value now
// The HeaderId in the extra field header, is already dummied out.
// For zip archives written by this library, if the zip64
// header exists, it is the first header. Because of the logic
// used when first writing the _EntryHeader bytes, the
// HeaderId is not guaranteed to be any particular value.  So
// we determine if the first header is a putative zip64 header
// by examining the datasize.  UInt16 HeaderId =
// (UInt16)(_EntryHeader[i] + _EntryHeader[i + 1] * 256);
// reset to Header Id to dummy value, effectively dummy-ing out the zip64 metadata
// Must set compressionmethod to 0x0063 (decimal 99)
//
// and then set the compression method bytes inside the extra
// field to the actual compression method value.
// skip this header
// actual compression method
// finally, write the data.
// workitem 7216 - sometimes we don't seek even if we CAN.  ASP.NET
// Response.OutputStream, or stdout are non-seekable.  But we may also want
// to NOT seek in other cases, eg zip64.  For all cases, we just check bit 3
// to see if we want to seek.  There's one exception - if using a
// ZipOutputStream, and PKZip encryption is in use, then we set bit 3 even
// if the out is seekable. This is so the check on the last byte of the
// PKZip Encryption Header can be done on the current time, as opposed to
// the CRC, to prevent streaming the file twice.  So, test for
// ZipOutputStream and seekable, and if so, seek back, even if bit 3 is set.
// seek back and rewrite the entry header
// In this case the entry header is in a different file,
// which has already been closed. Need to re-open it.
// seek in the raw output stream, to the beginning of the header for
// this entry.
// workitem 8098: ok (output)
// write the updated header to the output stream
// adjust the count on the CountingStream as necessary
// seek in the raw output stream, to the end of the file data
// for this entry
// emit the descriptor - only if not a directory.
// signature
// CRC - the correct value now
// workitem 7917
// CompressedSize - the correct value now
// UncompressedSize - the correct value now
// CompressedSize - (lower 32 bits) the correct value now
// UncompressedSize - (lower 32 bits) the correct value now
// finally, write the trailing descriptor to the output stream
// zip64 housekeeping
// validate the ZIP64 usage
/// <summary>
///   Prepare the given stream for output - wrap it in a CountingStream, and
///   then in a CRC stream, and an encryptor and deflator as appropriate.
/// </summary>
/// <remarks>
///   <para>
///     Previously this was used in ZipEntry.Write(), but in an effort to
///     introduce some efficiencies in that method I've refactored to put the
///     code inline.  This method still gets called by ZipOutputStream.
///   </para>
/// </remarks>
// Wrap a counting stream around the raw output stream:
// This is the last thing that happens before the bits go to the
// application-provided stream.
// Sometimes the incoming "raw" output stream is already a CountingStream.
// Doesn't matter. Wrap it with a counter anyway. We need to count at both
// levels.
// Maybe wrap an encrypting stream around that:
// This will happen BEFORE output counting, and AFTER deflation, if encryption
// is used.
// Maybe wrap a compressing Stream around that.
// This will happen BEFORE encryption (if any) as we write data out.
// Wrap a CrcCalculatorStream around that.
// This will happen BEFORE compression (if any) as we write data out.
// ParallelDeflateThreshold == 0    means ALWAYS use parallel deflate
// ParallelDeflateThreshold == -1L  means NEVER use parallel deflate
// Other values specify the actual threshold.
// This is sort of hacky.
//
// It's expensive to create a ParallelDeflateOutputStream, because
// of the large memory buffers.  But the class is unlike most Stream
// classes in that it can be re-used, so the caller can compress
// multiple files with it, one file at a time.  The key is to call
// Reset() on it, in between uses.
//
// The ParallelDeflateOutputStream is attached to the container
// itself - there is just one for the entire ZipFile or
// ZipOutputStream. So it gets created once, per save, and then
// re-used many times.
//
// This approach will break when we go to a "parallel save"
// approach, where multiple entries within the zip file are being
// compressed and saved at the same time.  But for now it's ok.
//
// instantiate the ParallelDeflateOutputStream
// can set the codec buffer size only before the first call to Write().
// reset it with the new stream
// When the app is updating a zip file, it may be possible to
// just copy data for a ZipEntry from the source zipfile to the
// destination, as a block, without decompressing and
// recompressing, etc.  But, in some cases the app modifies the
// properties on a ZipEntry prior to calling Save(). A change to
// any of the metadata - the FileName, CompressioLeve and so on,
// means DotNetZip cannot simply copy through the existing
// ZipEntry data unchanged.
//
// There are two cases:
//
//  1. Changes to only metadata, which means the header and
//     central directory must be changed.
//
//  2. Changes to the properties that affect the compressed
//     stream, such as CompressionMethod, CompressionLevel, or
//     EncryptionAlgorithm. In this case, DotNetZip must
//     "re-stream" the data: the old entry data must be maybe
//     decrypted, maybe decompressed, then maybe re-compressed
//     and maybe re-encrypted.
//
// This test checks if the source for the entry data is a zip file, and
// if a restream is necessary.  If NOT, then it just copies through
// one entry, potentially changing the metadata.
// Is the entry a directory?  If so, the write is relatively simple.
// handle case for split archives
// At this point, the source for this entry is not a directory, and
// not a previously created zip file, or the source for the entry IS
// a previously created zip but the settings whave changed in
// important ways and therefore we will need to process the
// bytestream (compute crc, maybe compress, maybe encrypt) in order
// to write the content into the new zip.
//
// We do this in potentially 2 passes: The first time we do it as
// requested, maybe with compression and maybe encryption.  If that
// causes the bytestream to inflate in size, and if compression was
// on, then we turn off compression and do it again.
// write the encrypted header
// write the (potentially compressed, potentially encrypted) file data
// track total entry size (including the trailing descriptor and MAC)
// The file data has now been written to the stream, and
// the file pointer is positioned directly after file data.
// Seek back in the raw output stream, to the beginning of the file
// data for this entry.
// handle case for split archives
// Console.WriteLine("***_diskNumber/first: {0}", _diskNumber);
// Console.WriteLine("***_diskNumber/current: {0}", zss.CurrentSegment);
// workitem 8098: ok (output).
// If the last entry expands, we read again; but here, we must
// truncate the stream to prevent garbage data after the
// end-of-central-directory.
// workitem 8098: ok (output).
// Adjust the count on the CountingStream as necessary.
// must reset file pointer here.
// workitem 13903 - seek back only when necessary
// may throw
// to prevent garbage if this is the last entry
// When updating a zip file, there are two contexts for properties
// like Encryption or CompressionMethod - the values read from the
// original zip file, and the values used in the updated zip file.
// The _FromZipFile versions are the originals.  At the end of a save,
// these values are the same.  So we need to update them.  This takes
// care of the boundary case where a single zipfile instance can be
// saved multiple times, with distinct changes to the properties on
// the entries, in between each Save().
//_Source = ZipEntrySource.None;
// workitem 10694
// special handling for source == ZipFile.
// Want to support the case where we re-stream an encrypted entry. This will involve,
// at runtime, reading, decrypting, and decompressing from the original zip file, then
// compressing, encrypting, and writing to the output zip file.
// If that's what we're doing, and the password hasn't been set on the entry,
// we use the container (ZipFile/ZipOutputStream) password to decrypt.
// This test here says to use the container password to re-encrypt, as well,
// with that password, if the entry password is null.
// If PKZip (weak) encryption is in use, then the encrypted entry data
// is preceded by 12-byte "encryption header" for the entry.
// generate the random 12-byte header:
// workitem 8271
// In the case that bit 3 of the general purpose bit flag is set to
// indicate the presence of a 'data descriptor' (signature
// 0x08074b50), the last byte of the decrypted header is sometimes
// compared with the high-order byte of the lastmodified time,
// rather than the high-order byte of the CRC, to verify the
// password.
//
// This is not documented in the PKWare Appnote.txt.
// This was discovered this by analysis of the Crypt.c source file in the
// InfoZip library
// http://www.info-zip.org/pub/infozip/
// Also, winzip insists on this!
// When bit 3 is not set, the CRC value is required before
// encryption of the file data begins. In this case there is no way
// around it: must read the stream in its entirety to compute the
// actual CRC before proceeding.
// Encrypt the random header, INCLUDING the final byte which is either
// the high-order byte of the CRC32, or the high-order byte of the
// _TimeBlob.  Must do this BEFORE encrypting the file data.  This
// step changes the state of the cipher, or in the words of the PKZIP
// spec, it "further initializes" the cipher keys.
// Write the ciphered bonafide encryption header.
// 12 bytes
// If WinZip AES encryption is in use, then the encrypted entry data is
// preceded by a variable-sized Salt and a 2-byte "password
// verification" value for the entry.
// Just read the entry from the existing input zipfile and write to the output.
// But, if metadata has changed (like file times or attributes), or if the ZIP64
// option has changed, we can re-stream the entry data but must recompute the
// metadata.
// is it necessary to re-constitute new metadata for this entry?
// zip64 housekeeping
// The header length may change due to rename of file, add a comment, etc.
// We need to retain the original.
// including crypto bytes!
// WriteHeader() has the side effect of changing _RelativeOffsetOfLocalHeader
// and setting _LengthOfHeader.  While ReadHeader() reads the crypto header if
// present, WriteHeader() does not write the crypto header.
// Not a directory; there is file data.
// Seek to the beginning of the entry data in the input stream.
// want to keep the crypto header
// copy through everything after the header to the output stream
// read
// write
// bit 3 descriptor
// original descriptor was 24 bytes, now we need 16.
// Must check for underflow here.
// signature + CRC.
// Compressed
// UnCompressed
// original descriptor was 16 bytes, now we need 24
// signature + CRC
// Compressed
// UnCompressed
// same descriptor on input and output. Copy it through.
//_LengthOfTrailer += size;
// seek to the beginning of the entry data in the input stream
// We've never set the length of the entry.
// Set it here.
// The CompressedSize includes all the leading metadata associated
// to encryption, if any, as well as the compressed data, or
// compressed-then-encrypted data, and the trailer in case of AES.
// The CompressedFileData size is the same, less the encryption
// framing data (12 bytes header for PKZip; 10/18 bytes header and
// 10 byte trailer for AES).
// The _LengthOfHeader includes all the zip entry header plus the
// crypto header, if any.  The _LengthOfTrailer includes the
// 10-byte MAC for AES, where appropriate, and the bit-3
// Descriptor, where applicable.
// workitem 5616
// remember the offset, within the output stream, of this particular entry header.
// This may have changed if any of the other entries changed (eg, if a different
// entry was removed or added.)
// BytesWritten
// copy through the header, filedata, trailer, everything...
// read
// write
// ZipEntrySource.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009 Dino Chiesa
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License. 
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs): 
// Time-stamp: <2009-November-19 11:18:42>
//
// ------------------------------------------------------------------
//
/// <summary>
/// An enum that specifies the source of the ZipEntry. 
/// </summary>
/// <summary>
/// Default value.  Invalid on a bonafide ZipEntry.
/// </summary>
/// <summary>
/// The entry was instantiated by calling AddFile() or another method that 
/// added an entry from the filesystem.
/// </summary>
/// <summary>
/// The entry was instantiated via <see cref="Ionic.Zip.ZipFile.AddEntry(string,string)"/> or
/// <see cref="Ionic.Zip.ZipFile.AddEntry(string,System.IO.Stream)"/> .
/// </summary>
/// <summary>
/// The ZipEntry was instantiated by reading a zipfile.
/// </summary>
/// <summary>
/// The content for the ZipEntry will be or was provided by the WriteDelegate.
/// </summary>
/// <summary>
/// The content for the ZipEntry will be obtained from the stream dispensed by the <c>OpenDelegate</c>.
/// The entry was instantiated via <see cref="Ionic.Zip.ZipFile.AddEntry(string,OpenDelegate,CloseDelegate)"/>.
/// </summary>
/// <summary>
/// The content for the ZipEntry will be or was obtained from a <c>ZipOutputStream</c>.
/// </summary>
// ZipErrorAction.cs
// ------------------------------------------------------------------
//
// Copyright (c)  2009 Dino Chiesa
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License. 
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs): 
// Time-stamp: <2009-September-01 18:43:20>
//
// ------------------------------------------------------------------
//
// This module defines the ZipErrorAction enum, which provides
// an action to take when errors occur when opening or reading
// files to be added to a zip file. 
// 
// ------------------------------------------------------------------
/// <summary>
/// An enum providing the options when an error occurs during opening or reading
/// of a file or directory that is being saved to a zip file. 
/// </summary>
///
/// <remarks>
///  <para>
///    This enum describes the actions that the library can take when an error occurs
///    opening or reading a file, as it is being saved into a Zip archive. 
///  </para>
///
///  <para>
///     In some cases an error will occur when DotNetZip tries to open a file to be
///     added to the zip archive.  In other cases, an error might occur after the
///     file has been successfully opened, while DotNetZip is reading the file.
///  </para>
/// 
///  <para>
///    The first problem might occur when calling AddDirectory() on a directory
///    that contains a Clipper .dbf file; the file is locked by Clipper and
///    cannot be opened by another process. An example of the second problem is
///    the ERROR_LOCK_VIOLATION that results when a file is opened by another
///    process, but not locked, and a range lock has been taken on the file.
///    Microsoft Outlook takes range locks on .PST files.
///  </para>
/// </remarks>
/// <summary>
/// Throw an exception when an error occurs while zipping.  This is the default
/// behavior.  (For COM clients, this is a 0 (zero).)
/// </summary>
/// <summary>
/// When an error occurs during zipping, for example a file cannot be opened,
/// skip the file causing the error, and continue zipping.  (For COM clients,
/// this is a 1.)
/// </summary>
/// <summary>
/// When an error occurs during zipping, for example a file cannot be opened,
/// retry the operation that caused the error. Be careful with this option. If
/// the error is not temporary, the library will retry forever.  (For COM
/// clients, this is a 2.)
/// </summary>
/// <summary>
/// When an error occurs, invoke the zipError event.  The event type used is
/// <see cref="ZipProgressEventType.Error_Saving"/>.  A typical use of this option:
/// a GUI application may wish to pop up a dialog to allow the user to view the
/// error that occurred, and choose an appropriate action.  After your
/// processing in the error event, if you want to skip the file, set <see
/// cref="ZipEntry.ZipErrorAction"/> on the
/// <c>ZipProgressEventArgs.CurrentEntry</c> to <c>Skip</c>.  If you want the
/// exception to be thrown, set <c>ZipErrorAction</c> on the <c>CurrentEntry</c>
/// to <c>Throw</c>.  If you want to cancel the zip, set
/// <c>ZipProgressEventArgs.Cancel</c> to true.  Cancelling differs from using
/// Skip in that a cancel will not save any further entries, if there are any.
/// (For COM clients, the value of this enum is a 3.)
/// </summary>
// ZipFile.AddUpdate.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2011 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-November-01 13:56:58>
//
// ------------------------------------------------------------------
//
// This module defines the methods for Adding and Updating entries in
// the ZipFile.
//
// ------------------------------------------------------------------
//
/// <summary>
///   Adds an item, either a file or a directory, to a zip file archive.
/// </summary>
///
/// <remarks>
/// <para>
///   This method is handy if you are adding things to zip archive and don't
///   want to bother distinguishing between directories or files.  Any files are
///   added as single entries.  A directory added through this method is added
///   recursively: all files and subdirectories contained within the directory
///   are added to the <c>ZipFile</c>.
/// </para>
///
/// <para>
///   The name of the item may be a relative path or a fully-qualified
///   path. Remember, the items contained in <c>ZipFile</c> instance get written
///   to the disk only when you call <see cref="ZipFile.Save()"/> or a similar
///   save method.
/// </para>
///
/// <para>
///   The directory name used for the file within the archive is the same
///   as the directory name (potentially a relative path) specified in the
///   <paramref name="fileOrDirectoryName"/>.
/// </para>
///
/// <para>
///   For <c>ZipFile</c> properties including <see cref="Encryption"/>, <see
///   cref="Password"/>, <see cref="SetCompression"/>, <see
///   cref="ProvisionalAlternateEncoding"/>, <see cref="ExtractExistingFile"/>,
///   <see cref="ZipErrorAction"/>, and <see cref="CompressionLevel"/>, their
///   respective values at the time of this call will be applied to the
///   <c>ZipEntry</c> added.
/// </para>
///
/// </remarks>
///
/// <seealso cref="Ionic.Zip.ZipFile.AddFile(string)"/>
/// <seealso cref="Ionic.Zip.ZipFile.AddDirectory(string)"/>
/// <seealso cref="Ionic.Zip.ZipFile.UpdateItem(string)"/>
///
/// <overloads>This method has two overloads.</overloads>
/// <param name="fileOrDirectoryName">
/// the name of the file or directory to add.</param>
///
/// <returns>The <c>ZipEntry</c> added.</returns>
/// <summary>
///   Adds an item, either a file or a directory, to a zip file archive,
///   explicitly specifying the directory path to be used in the archive.
/// </summary>
///
/// <remarks>
/// <para>
///   If adding a directory, the add is recursive on all files and
///   subdirectories contained within it.
/// </para>
/// <para>
///   The name of the item may be a relative path or a fully-qualified path.
///   The item added by this call to the <c>ZipFile</c> is not read from the
///   disk nor written to the zip file archive until the application calls
///   Save() on the <c>ZipFile</c>.
/// </para>
///
/// <para>
///   This version of the method allows the caller to explicitly specify the
///   directory path to be used in the archive, which would override the
///   "natural" path of the filesystem file.
/// </para>
///
/// <para>
///   Encryption will be used on the file data if the <c>Password</c> has
///   been set on the <c>ZipFile</c> object, prior to calling this method.
/// </para>
///
/// <para>
///   For <c>ZipFile</c> properties including <see cref="Encryption"/>, <see
///   cref="Password"/>, <see cref="SetCompression"/>, <see
///   cref="ProvisionalAlternateEncoding"/>, <see cref="ExtractExistingFile"/>,
///   <see cref="ZipErrorAction"/>, and <see cref="CompressionLevel"/>, their
///   respective values at the time of this call will be applied to the
///   <c>ZipEntry</c> added.
/// </para>
///
/// </remarks>
///
/// <exception cref="System.IO.FileNotFoundException">
///   Thrown if the file or directory passed in does not exist.
/// </exception>
///
/// <param name="fileOrDirectoryName">the name of the file or directory to add.
/// </param>
///
/// <param name="directoryPathInArchive">
///   The name of the directory path to use within the zip archive.  This path
///   need not refer to an extant directory in the current filesystem.  If the
///   files within the zip are later extracted, this is the path used for the
///   extracted file.  Passing <c>null</c> (<c>Nothing</c> in VB) will use the
///   path on the fileOrDirectoryName.  Passing the empty string ("") will
///   insert the item at the root path within the archive.
/// </param>
///
/// <seealso cref="Ionic.Zip.ZipFile.AddFile(string, string)"/>
/// <seealso cref="Ionic.Zip.ZipFile.AddDirectory(string, string)"/>
/// <seealso cref="Ionic.Zip.ZipFile.UpdateItem(string, string)"/>
///
/// <example>
///   This example shows how to zip up a set of files into a flat hierarchy,
///   regardless of where in the filesystem the files originated. The resulting
///   zip archive will contain a toplevel directory named "flat", which itself
///   will contain files Readme.txt, MyProposal.docx, and Image1.jpg.  A
///   subdirectory under "flat" called SupportFiles will contain all the files
///   in the "c:\SupportFiles" directory on disk.
///
/// <code>
/// String[] itemnames= {
///   "c:\\fixedContent\\Readme.txt",
///   "MyProposal.docx",
///   "c:\\SupportFiles",  // a directory
///   "images\\Image1.jpg"
/// };
///
/// try
/// {
///   using (ZipFile zip = new ZipFile())
///   {
///     for (int i = 1; i &lt; itemnames.Length; i++)
///     {
///       // will add Files or Dirs, recurses and flattens subdirectories
///       zip.AddItem(itemnames[i],"flat");
///     }
///     zip.Save(ZipToCreate);
///   }
/// }
/// catch (System.Exception ex1)
/// {
///   System.Console.Error.WriteLine("exception: {0}", ex1);
/// }
/// </code>
///
/// <code lang="VB">
///   Dim itemnames As String() = _
///     New String() { "c:\fixedContent\Readme.txt", _
///                    "MyProposal.docx", _
///                    "SupportFiles", _
///                    "images\Image1.jpg" }
///   Try
///       Using zip As New ZipFile
///           Dim i As Integer
///           For i = 1 To itemnames.Length - 1
///               ' will add Files or Dirs, recursing and flattening subdirectories.
///               zip.AddItem(itemnames(i), "flat")
///           Next i
///           zip.Save(ZipToCreate)
///       End Using
///   Catch ex1 As Exception
///       Console.Error.WriteLine("exception: {0}", ex1.ToString())
///   End Try
/// </code>
/// </example>
/// <returns>The <c>ZipEntry</c> added.</returns>
/// <summary>
///   Adds a File to a Zip file archive.
/// </summary>
/// <remarks>
///
/// <para>
///   This call collects metadata for the named file in the filesystem,
///   including the file attributes and the timestamp, and inserts that metadata
///   into the resulting ZipEntry.  Only when the application calls Save() on
///   the <c>ZipFile</c>, does DotNetZip read the file from the filesystem and
///   then write the content to the zip file archive.
/// </para>
///
/// <para>
///   This method will throw an exception if an entry with the same name already
///   exists in the <c>ZipFile</c>.
/// </para>
///
/// <para>
///   For <c>ZipFile</c> properties including <see cref="Encryption"/>, <see
///   cref="Password"/>, <see cref="SetCompression"/>, <see
///   cref="ProvisionalAlternateEncoding"/>, <see cref="ExtractExistingFile"/>,
///   <see cref="ZipErrorAction"/>, and <see cref="CompressionLevel"/>, their
///   respective values at the time of this call will be applied to the
///   <c>ZipEntry</c> added.
/// </para>
///
/// </remarks>
///
/// <example>
/// <para>
///   In this example, three files are added to a Zip archive. The ReadMe.txt
///   file will be placed in the root of the archive. The .png file will be
///   placed in a folder within the zip called photos\personal.  The pdf file
///   will be included into a folder within the zip called Desktop.
/// </para>
/// <code>
///    try
///    {
///      using (ZipFile zip = new ZipFile())
///      {
///        zip.AddFile("c:\\photos\\personal\\7440-N49th.png");
///        zip.AddFile("c:\\Desktop\\2008-Regional-Sales-Report.pdf");
///        zip.AddFile("ReadMe.txt");
///
///        zip.Save("Package.zip");
///      }
///    }
///    catch (System.Exception ex1)
///    {
///      System.Console.Error.WriteLine("exception: " + ex1);
///    }
/// </code>
///
/// <code lang="VB">
///  Try
///       Using zip As ZipFile = New ZipFile
///           zip.AddFile("c:\photos\personal\7440-N49th.png")
///           zip.AddFile("c:\Desktop\2008-Regional-Sales-Report.pdf")
///           zip.AddFile("ReadMe.txt")
///           zip.Save("Package.zip")
///       End Using
///   Catch ex1 As Exception
///       Console.Error.WriteLine("exception: {0}", ex1.ToString)
///   End Try
/// </code>
/// </example>
///
/// <overloads>This method has two overloads.</overloads>
///
/// <seealso cref="Ionic.Zip.ZipFile.AddItem(string)"/>
/// <seealso cref="Ionic.Zip.ZipFile.AddDirectory(string)"/>
/// <seealso cref="Ionic.Zip.ZipFile.UpdateFile(string)"/>
///
/// <param name="fileName">
///   The name of the file to add. It should refer to a file in the filesystem.
///   The name of the file may be a relative path or a fully-qualified path.
/// </param>
/// <returns>The <c>ZipEntry</c> corresponding to the File added.</returns>
/// <summary>
///   Adds a File to a Zip file archive, potentially overriding the path to be
///   used within the zip archive.
/// </summary>
///
/// <remarks>
/// <para>
///   The file added by this call to the <c>ZipFile</c> is not written to the
///   zip file archive until the application calls Save() on the <c>ZipFile</c>.
/// </para>
///
/// <para>
///   This method will throw an exception if an entry with the same name already
///   exists in the <c>ZipFile</c>.
/// </para>
///
/// <para>
///   This version of the method allows the caller to explicitly specify the
///   directory path to be used in the archive.
/// </para>
///
/// <para>
///   For <c>ZipFile</c> properties including <see cref="Encryption"/>, <see
///   cref="Password"/>, <see cref="SetCompression"/>, <see
///   cref="ProvisionalAlternateEncoding"/>, <see cref="ExtractExistingFile"/>,
///   <see cref="ZipErrorAction"/>, and <see cref="CompressionLevel"/>, their
///   respective values at the time of this call will be applied to the
///   <c>ZipEntry</c> added.
/// </para>
///
/// </remarks>
///
/// <example>
/// <para>
///   In this example, three files are added to a Zip archive. The ReadMe.txt
///   file will be placed in the root of the archive. The .png file will be
///   placed in a folder within the zip called images.  The pdf file will be
///   included into a folder within the zip called files\docs, and will be
///   encrypted with the given password.
/// </para>
/// <code>
/// try
/// {
///   using (ZipFile zip = new ZipFile())
///   {
///     // the following entry will be inserted at the root in the archive.
///     zip.AddFile("c:\\datafiles\\ReadMe.txt", "");
///     // this image file will be inserted into the "images" directory in the archive.
///     zip.AddFile("c:\\photos\\personal\\7440-N49th.png", "images");
///     // the following will result in a password-protected file called
///     // files\\docs\\2008-Regional-Sales-Report.pdf  in the archive.
///     zip.Password = "EncryptMe!";
///     zip.AddFile("c:\\Desktop\\2008-Regional-Sales-Report.pdf", "files\\docs");
///     zip.Save("Archive.zip");
///   }
/// }
/// catch (System.Exception ex1)
/// {
///   System.Console.Error.WriteLine("exception: {0}", ex1);
/// }
/// </code>
///
/// <code lang="VB">
///   Try
///       Using zip As ZipFile = New ZipFile
///           ' the following entry will be inserted at the root in the archive.
///           zip.AddFile("c:\datafiles\ReadMe.txt", "")
///           ' this image file will be inserted into the "images" directory in the archive.
///           zip.AddFile("c:\photos\personal\7440-N49th.png", "images")
///           ' the following will result in a password-protected file called
///           ' files\\docs\\2008-Regional-Sales-Report.pdf  in the archive.
///           zip.Password = "EncryptMe!"
///           zip.AddFile("c:\Desktop\2008-Regional-Sales-Report.pdf", "files\documents")
///           zip.Save("Archive.zip")
///       End Using
///   Catch ex1 As Exception
///       Console.Error.WriteLine("exception: {0}", ex1)
///   End Try
/// </code>
/// </example>
///
/// <seealso cref="Ionic.Zip.ZipFile.AddItem(string,string)"/>
/// <seealso cref="Ionic.Zip.ZipFile.AddDirectory(string, string)"/>
/// <seealso cref="Ionic.Zip.ZipFile.UpdateFile(string,string)"/>
///
/// <param name="fileName">
///   The name of the file to add.  The name of the file may be a relative path
///   or a fully-qualified path.
/// </param>
///
/// <param name="directoryPathInArchive">
///   Specifies a directory path to use to override any path in the fileName.
///   This path may, or may not, correspond to a real directory in the current
///   filesystem.  If the files within the zip are later extracted, this is the
///   path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
///   VB) will use the path on the fileName, if any.  Passing the empty string
///   ("") will insert the item at the root path within the archive.
/// </param>
///
/// <returns>The <c>ZipEntry</c> corresponding to the file added.</returns>
/// <summary>
///   This method removes a collection of entries from the <c>ZipFile</c>.
/// </summary>
///
/// <param name="entriesToRemove">
///   A collection of ZipEntry instances from this zip file to be removed. For
///   example, you can pass in an array of ZipEntry instances; or you can call
///   SelectEntries(), and then add or remove entries from that
///   ICollection&lt;ZipEntry&gt; (ICollection(Of ZipEntry) in VB), and pass
///   that ICollection to this method.
/// </param>
///
/// <seealso cref="Ionic.Zip.ZipFile.SelectEntries(String)" />
/// <seealso cref="Ionic.Zip.ZipFile.RemoveSelectedEntries(String)" />
/// <summary>
///   This method removes a collection of entries from the <c>ZipFile</c>, by name.
/// </summary>
///
/// <param name="entriesToRemove">
///   A collection of strings that refer to names of entries to be removed
///   from the <c>ZipFile</c>.  For example, you can pass in an array or a
///   List of Strings that provide the names of entries to be removed.
/// </param>
///
/// <seealso cref="Ionic.Zip.ZipFile.SelectEntries(String)" />
/// <seealso cref="Ionic.Zip.ZipFile.RemoveSelectedEntries(String)" />
/// <summary>
///   This method adds a set of files to the <c>ZipFile</c>.
/// </summary>
///
/// <remarks>
/// <para>
///   Use this method to add a set of files to the zip archive, in one call.
///   For example, a list of files received from
///   <c>System.IO.Directory.GetFiles()</c> can be added to a zip archive in one
///   call.
/// </para>
///
/// <para>
///   For <c>ZipFile</c> properties including <see cref="Encryption"/>, <see
///   cref="Password"/>, <see cref="SetCompression"/>, <see
///   cref="ProvisionalAlternateEncoding"/>, <see cref="ExtractExistingFile"/>,
///   <see cref="ZipErrorAction"/>, and <see cref="CompressionLevel"/>, their
///   respective values at the time of this call will be applied to each
///   ZipEntry added.
/// </para>
/// </remarks>
///
/// <param name="fileNames">
///   The collection of names of the files to add. Each string should refer to a
///   file in the filesystem. The name of the file may be a relative path or a
///   fully-qualified path.
/// </param>
///
/// <example>
///   This example shows how to create a zip file, and add a few files into it.
/// <code>
/// String ZipFileToCreate = "archive1.zip";
/// String DirectoryToZip = "c:\\reports";
/// using (ZipFile zip = new ZipFile())
/// {
///   // Store all files found in the top level directory, into the zip archive.
///   String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
///   zip.AddFiles(filenames);
///   zip.Save(ZipFileToCreate);
/// }
/// </code>
///
/// <code lang="VB">
/// Dim ZipFileToCreate As String = "archive1.zip"
/// Dim DirectoryToZip As String = "c:\reports"
/// Using zip As ZipFile = New ZipFile
///     ' Store all files found in the top level directory, into the zip archive.
///     Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
///     zip.AddFiles(filenames)
///     zip.Save(ZipFileToCreate)
/// End Using
/// </code>
/// </example>
///
/// <seealso cref="Ionic.Zip.ZipFile.AddSelectedFiles(String, String)" />
/// <summary>
///   Adds or updates a set of files in the <c>ZipFile</c>.
/// </summary>
///
/// <remarks>
/// <para>
///   Any files that already exist in the archive are updated. Any files that
///   don't yet exist in the archive are added.
/// </para>
///
/// <para>
///   For <c>ZipFile</c> properties including <see cref="Encryption"/>, <see
///   cref="Password"/>, <see cref="SetCompression"/>, <see
///   cref="ProvisionalAlternateEncoding"/>, <see cref="ExtractExistingFile"/>,
///   <see cref="ZipErrorAction"/>, and <see cref="CompressionLevel"/>, their
///   respective values at the time of this call will be applied to each
///   ZipEntry added.
/// </para>
/// </remarks>
///
/// <param name="fileNames">
///   The collection of names of the files to update. Each string should refer to a file in
///   the filesystem. The name of the file may be a relative path or a fully-qualified path.
/// </param>
///
/// <summary>
///   Adds a set of files to the <c>ZipFile</c>, using the
///   specified directory path in the archive.
/// </summary>
///
/// <remarks>
/// <para>
///   Any directory structure that may be present in the
///   filenames contained in the list is "flattened" in the
///   archive.  Each file in the list is added to the archive in
///   the specified top-level directory.
/// </para>
///
/// <para>
///   For <c>ZipFile</c> properties including <see
///   cref="Encryption"/>, <see cref="Password"/>, <see
///   cref="SetCompression"/>, <see
///   cref="ProvisionalAlternateEncoding"/>, <see
///   cref="ExtractExistingFile"/>, <see
///   cref="ZipErrorAction"/>, and <see
///   cref="CompressionLevel"/>, their respective values at the
///   time of this call will be applied to each ZipEntry added.
/// </para>
/// </remarks>
///
/// <param name="fileNames">
///   The names of the files to add. Each string should refer to
///   a file in the filesystem.  The name of the file may be a
///   relative path or a fully-qualified path.
/// </param>
///
/// <param name="directoryPathInArchive">
///   Specifies a directory path to use to override any path in the file name.
///   Th is path may, or may not, correspond to a real directory in the current
///   filesystem.  If the files within the zip are later extracted, this is the
///   path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
///   VB) will use the path on each of the <c>fileNames</c>, if any.  Passing
///   the empty string ("") will insert the item at the root path within the
///   archive.
/// </param>
///
/// <seealso cref="Ionic.Zip.ZipFile.AddSelectedFiles(String, String)" />
/// <summary>
///   Adds a set of files to the <c>ZipFile</c>, using the specified directory
///   path in the archive, and preserving the full directory structure in the
///   filenames.
/// </summary>
///
/// <remarks>
///
/// <para>
///   Think of the <paramref name="directoryPathInArchive"/> as a "root" or
///   base directory used in the archive for the files that get added.  when
///   <paramref name="preserveDirHierarchy"/> is true, the hierarchy of files
///   found in the filesystem will be placed, with the hierarchy intact,
///   starting at that root in the archive. When <c>preserveDirHierarchy</c>
///   is false, the path hierarchy of files is flattned, and the flattened
///   set of files gets placed in the root within the archive as specified in
///   <c>directoryPathInArchive</c>.
/// </para>
///
/// <para>
///   For <c>ZipFile</c> properties including <see cref="Encryption"/>, <see
///   cref="Password"/>, <see cref="SetCompression"/>, <see
///   cref="ProvisionalAlternateEncoding"/>, <see cref="ExtractExistingFile"/>,
///   <see cref="ZipErrorAction"/>, and <see cref="CompressionLevel"/>, their
///   respective values at the time of this call will be applied to each
///   ZipEntry added.
/// </para>
///
/// </remarks>
///
/// <param name="fileNames">
///   The names of the files to add. Each string should refer to a file in the
///   filesystem.  The name of the file may be a relative path or a
///   fully-qualified path.
/// </param>
///
/// <param name="directoryPathInArchive">
///   Specifies a directory path to use as a prefix for each entry name.
///   This path may, or may not, correspond to a real directory in the current
///   filesystem.  If the files within the zip are later extracted, this is the
///   path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
///   VB) will use the path on each of the <c>fileNames</c>, if any.  Passing
///   the empty string ("") will insert the item at the root path within the
///   archive.
/// </param>
///
/// <param name="preserveDirHierarchy">
///   whether the entries in the zip archive will reflect the directory
///   hierarchy that is present in the various filenames.  For example, if
///   <paramref name="fileNames"/> includes two paths,
///   \Animalia\Chordata\Mammalia\Info.txt and
///   \Plantae\Magnoliophyta\Dicotyledon\Info.txt, then calling this method
///   with <paramref name="preserveDirHierarchy"/> = <c>false</c> will
///   result in an exception because of a duplicate entry name, while
///   calling this method with <paramref name="preserveDirHierarchy"/> =
///   <c>true</c> will result in the full direcory paths being included in
///   the entries added to the ZipFile.
/// </param>
/// <seealso cref="Ionic.Zip.ZipFile.AddSelectedFiles(String, String)" />
//string s = SharedUtilities.NormalizePath(Path.Combine(directoryPathInArchive, Path.GetDirectoryName(f)));
/// <summary>
///   Adds or updates a set of files to the <c>ZipFile</c>, using the specified
///   directory path in the archive.
/// </summary>
///
/// <remarks>
///
/// <para>
///   Any files that already exist in the archive are updated. Any files that
///   don't yet exist in the archive are added.
/// </para>
///
/// <para>
///   For <c>ZipFile</c> properties including <see cref="Encryption"/>, <see
///   cref="Password"/>, <see cref="SetCompression"/>, <see
///   cref="ProvisionalAlternateEncoding"/>, <see cref="ExtractExistingFile"/>,
///   <see cref="ZipErrorAction"/>, and <see cref="CompressionLevel"/>, their
///   respective values at the time of this call will be applied to each
///   ZipEntry added.
/// </para>
/// </remarks>
///
/// <param name="fileNames">
///   The names of the files to add or update. Each string should refer to a
///   file in the filesystem.  The name of the file may be a relative path or a
///   fully-qualified path.
/// </param>
///
/// <param name="directoryPathInArchive">
///   Specifies a directory path to use to override any path in the file name.
///   This path may, or may not, correspond to a real directory in the current
///   filesystem.  If the files within the zip are later extracted, this is the
///   path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
///   VB) will use the path on each of the <c>fileNames</c>, if any.  Passing
///   the empty string ("") will insert the item at the root path within the
///   archive.
/// </param>
///
/// <seealso cref="Ionic.Zip.ZipFile.AddSelectedFiles(String, String)" />
/// <summary>
///   Adds or Updates a File in a Zip file archive.
/// </summary>
///
/// <remarks>
/// <para>
///   This method adds a file to a zip archive, or, if the file already exists
///   in the zip archive, this method Updates the content of that given filename
///   in the zip archive.  The <c>UpdateFile</c> method might more accurately be
///   called "AddOrUpdateFile".
/// </para>
///
/// <para>
///   Upon success, there is no way for the application to learn whether the file
///   was added versus updated.
/// </para>
///
/// <para>
///   For <c>ZipFile</c> properties including <see cref="Encryption"/>, <see
///   cref="Password"/>, <see cref="SetCompression"/>, <see
///   cref="ProvisionalAlternateEncoding"/>, <see cref="ExtractExistingFile"/>,
///   <see cref="ZipErrorAction"/>, and <see cref="CompressionLevel"/>, their
///   respective values at the time of this call will be applied to the
///   <c>ZipEntry</c> added.
/// </para>
/// </remarks>
///
/// <example>
///
///   This example shows how to Update an existing entry in a zipfile. The first
///   call to UpdateFile adds the file to the newly-created zip archive.  The
///   second call to UpdateFile updates the content for that file in the zip
///   archive.
///
/// <code>
/// using (ZipFile zip1 = new ZipFile())
/// {
///   // UpdateFile might more accurately be called "AddOrUpdateFile"
///   zip1.UpdateFile("MyDocuments\\Readme.txt");
///   zip1.UpdateFile("CustomerList.csv");
///   zip1.Comment = "This zip archive has been created.";
///   zip1.Save("Content.zip");
/// }
///
/// using (ZipFile zip2 = ZipFile.Read("Content.zip"))
/// {
///   zip2.UpdateFile("Updates\\Readme.txt");
///   zip2.Comment = "This zip archive has been updated: The Readme.txt file has been changed.";
///   zip2.Save();
/// }
///
/// </code>
/// <code lang="VB">
///   Using zip1 As New ZipFile
///       ' UpdateFile might more accurately be called "AddOrUpdateFile"
///       zip1.UpdateFile("MyDocuments\Readme.txt")
///       zip1.UpdateFile("CustomerList.csv")
///       zip1.Comment = "This zip archive has been created."
///       zip1.Save("Content.zip")
///   End Using
///
///   Using zip2 As ZipFile = ZipFile.Read("Content.zip")
///       zip2.UpdateFile("Updates\Readme.txt")
///       zip2.Comment = "This zip archive has been updated: The Readme.txt file has been changed."
///       zip2.Save
///   End Using
/// </code>
/// </example>
///
/// <seealso cref="Ionic.Zip.ZipFile.AddFile(string)"/>
/// <seealso cref="Ionic.Zip.ZipFile.UpdateDirectory(string)"/>
/// <seealso cref="Ionic.Zip.ZipFile.UpdateItem(string)"/>
///
/// <param name="fileName">
///   The name of the file to add or update. It should refer to a file in the
///   filesystem.  The name of the file may be a relative path or a
///   fully-qualified path.
/// </param>
///
/// <returns>
///   The <c>ZipEntry</c> corresponding to the File that was added or updated.
/// </returns>
/// <summary>
///   Adds or Updates a File in a Zip file archive.
/// </summary>
///
/// <remarks>
/// <para>
///   This method adds a file to a zip archive, or, if the file already exists
///   in the zip archive, this method Updates the content of that given filename
///   in the zip archive.
/// </para>
///
/// <para>
///   This version of the method allows the caller to explicitly specify the
///   directory path to be used in the archive.  The entry to be added or
///   updated is found by using the specified directory path, combined with the
///   basename of the specified filename.
/// </para>
///
/// <para>
///   Upon success, there is no way for the application to learn if the file was
///   added versus updated.
/// </para>
///
/// <para>
///   For <c>ZipFile</c> properties including <see cref="Encryption"/>, <see
///   cref="Password"/>, <see cref="SetCompression"/>, <see
///   cref="ProvisionalAlternateEncoding"/>, <see cref="ExtractExistingFile"/>,
///   <see cref="ZipErrorAction"/>, and <see cref="CompressionLevel"/>, their
///   respective values at the time of this call will be applied to the
///   <c>ZipEntry</c> added.
/// </para>
/// </remarks>
///
/// <seealso cref="Ionic.Zip.ZipFile.AddFile(string,string)"/>
/// <seealso cref="Ionic.Zip.ZipFile.UpdateDirectory(string,string)"/>
/// <seealso cref="Ionic.Zip.ZipFile.UpdateItem(string,string)"/>
///
/// <param name="fileName">
///   The name of the file to add or update. It should refer to a file in the
///   filesystem.  The name of the file may be a relative path or a
///   fully-qualified path.
/// </param>
///
/// <param name="directoryPathInArchive">
///   Specifies a directory path to use to override any path in the
///   <c>fileName</c>.  This path may, or may not, correspond to a real
///   directory in the current filesystem.  If the files within the zip are
///   later extracted, this is the path used for the extracted file.  Passing
///   <c>null</c> (<c>Nothing</c> in VB) will use the path on the
///   <c>fileName</c>, if any.  Passing the empty string ("") will insert the
///   item at the root path within the archive.
/// </param>
///
/// <returns>
///   The <c>ZipEntry</c> corresponding to the File that was added or updated.
/// </returns>
// ideally this would all be transactional!
/// <summary>
///   Add or update a directory in a zip archive.
/// </summary>
///
/// <remarks>
///   If the specified directory does not exist in the archive, then this method
///   is equivalent to calling <c>AddDirectory()</c>.  If the specified
///   directory already exists in the archive, then this method updates any
///   existing entries, and adds any new entries. Any entries that are in the
///   zip archive but not in the specified directory, are left alone.  In other
///   words, the contents of the zip file will be a union of the previous
///   contents and the new files.
/// </remarks>
///
/// <seealso cref="Ionic.Zip.ZipFile.UpdateFile(string)"/>
/// <seealso cref="Ionic.Zip.ZipFile.AddDirectory(string)"/>
/// <seealso cref="Ionic.Zip.ZipFile.UpdateItem(string)"/>
///
/// <param name="directoryName">
///   The path to the directory to be added to the zip archive, or updated in
///   the zip archive.
/// </param>
///
/// <returns>
/// The <c>ZipEntry</c> corresponding to the Directory that was added or updated.
/// </returns>
/// <summary>
///   Add or update a directory in the zip archive at the specified root
///   directory in the archive.
/// </summary>
///
/// <remarks>
///   If the specified directory does not exist in the archive, then this method
///   is equivalent to calling <c>AddDirectory()</c>.  If the specified
///   directory already exists in the archive, then this method updates any
///   existing entries, and adds any new entries. Any entries that are in the
///   zip archive but not in the specified directory, are left alone.  In other
///   words, the contents of the zip file will be a union of the previous
///   contents and the new files.
/// </remarks>
///
/// <seealso cref="Ionic.Zip.ZipFile.UpdateFile(string,string)"/>
/// <seealso cref="Ionic.Zip.ZipFile.AddDirectory(string,string)"/>
/// <seealso cref="Ionic.Zip.ZipFile.UpdateItem(string,string)"/>
///
/// <param name="directoryName">
///   The path to the directory to be added to the zip archive, or updated
///   in the zip archive.
/// </param>
///
/// <param name="directoryPathInArchive">
///   Specifies a directory path to use to override any path in the
///   <c>directoryName</c>.  This path may, or may not, correspond to a real
///   directory in the current filesystem.  If the files within the zip are
///   later extracted, this is the path used for the extracted file.  Passing
///   <c>null</c> (<c>Nothing</c> in VB) will use the path on the
///   <c>directoryName</c>, if any.  Passing the empty string ("") will insert
///   the item at the root path within the archive.
/// </param>
///
/// <returns>
///   The <c>ZipEntry</c> corresponding to the Directory that was added or updated.
/// </returns>
/// <summary>
///   Add or update a file or directory in the zip archive.
/// </summary>
///
/// <remarks>
/// <para>
///   This is useful when the application is not sure or does not care if the
///   item to be added is a file or directory, and does not know or does not
///   care if the item already exists in the <c>ZipFile</c>. Calling this method
///   is equivalent to calling <c>RemoveEntry()</c> if an entry by the same name
///   already exists, followed calling by <c>AddItem()</c>.
/// </para>
///
/// <para>
///   For <c>ZipFile</c> properties including <see cref="Encryption"/>, <see
///   cref="Password"/>, <see cref="SetCompression"/>, <see
///   cref="ProvisionalAlternateEncoding"/>, <see cref="ExtractExistingFile"/>,
///   <see cref="ZipErrorAction"/>, and <see cref="CompressionLevel"/>, their
///   respective values at the time of this call will be applied to the
///   <c>ZipEntry</c> added.
/// </para>
/// </remarks>
///
/// <seealso cref="Ionic.Zip.ZipFile.AddItem(string)"/>
/// <seealso cref="Ionic.Zip.ZipFile.UpdateFile(string)"/>
/// <seealso cref="Ionic.Zip.ZipFile.UpdateDirectory(string)"/>
///
/// <param name="itemName">
///  the path to the file or directory to be added or updated.
/// </param>
/// <summary>
///   Add or update a file or directory.
/// </summary>
///
/// <remarks>
/// <para>
///   This method is useful when the application is not sure or does not care if
///   the item to be added is a file or directory, and does not know or does not
///   care if the item already exists in the <c>ZipFile</c>. Calling this method
///   is equivalent to calling <c>RemoveEntry()</c>, if an entry by that name
///   exists, and then calling <c>AddItem()</c>.
/// </para>
///
/// <para>
///   This version of the method allows the caller to explicitly specify the
///   directory path to be used for the item being added to the archive.  The
///   entry or entries that are added or updated will use the specified
///   <c>DirectoryPathInArchive</c>. Extracting the entry from the archive will
///   result in a file stored in that directory path.
/// </para>
///
/// <para>
///   For <c>ZipFile</c> properties including <see cref="Encryption"/>, <see
///   cref="Password"/>, <see cref="SetCompression"/>, <see
///   cref="ProvisionalAlternateEncoding"/>, <see cref="ExtractExistingFile"/>,
///   <see cref="ZipErrorAction"/>, and <see cref="CompressionLevel"/>, their
///   respective values at the time of this call will be applied to the
///   <c>ZipEntry</c> added.
/// </para>
/// </remarks>
///
/// <seealso cref="Ionic.Zip.ZipFile.AddItem(string, string)"/>
/// <seealso cref="Ionic.Zip.ZipFile.UpdateFile(string, string)"/>
/// <seealso cref="Ionic.Zip.ZipFile.UpdateDirectory(string, string)"/>
///
/// <param name="itemName">
///   The path for the File or Directory to be added or updated.
/// </param>
/// <param name="directoryPathInArchive">
///   Specifies a directory path to use to override any path in the
///   <c>itemName</c>.  This path may, or may not, correspond to a real
///   directory in the current filesystem.  If the files within the zip are
///   later extracted, this is the path used for the extracted file.  Passing
///   <c>null</c> (<c>Nothing</c> in VB) will use the path on the
///   <c>itemName</c>, if any.  Passing the empty string ("") will insert the
///   item at the root path within the archive.
/// </param>
/// <summary>
///   Adds a named entry into the zip archive, taking content for the entry
///   from a string.
/// </summary>
///
/// <remarks>
///   Calling this method creates an entry using the given fileName and
///   directory path within the archive.  There is no need for a file by the
///   given name to exist in the filesystem; the name is used within the zip
///   archive only. The content for the entry is encoded using the default text
///   encoding for the machine.
/// </remarks>
///
/// <param name="content">
///   The content of the file, should it be extracted from the zip.
/// </param>
///
/// <param name="entryName">
///   The name, including any path, to use for the entry within the archive.
/// </param>
///
/// <returns>The <c>ZipEntry</c> added.</returns>
///
/// <example>
///
/// This example shows how to add an entry to the zipfile, using a string as
/// content for that entry.
///
/// <code lang="C#">
/// string Content = "This string will be the content of the Readme.txt file in the zip archive.";
/// using (ZipFile zip1 = new ZipFile())
/// {
///   zip1.AddFile("MyDocuments\\Resume.doc", "files");
///   zip1.AddEntry("Readme.txt", Content);
///   zip1.Comment = "This zip file was created at " + System.DateTime.Now.ToString("G");
///   zip1.Save("Content.zip");
/// }
///
/// </code>
/// <code lang="VB">
/// Public Sub Run()
///   Dim Content As String = "This string will be the content of the Readme.txt file in the zip archive."
///   Using zip1 As ZipFile = New ZipFile
///     zip1.AddEntry("Readme.txt", Content)
///     zip1.AddFile("MyDocuments\Resume.doc", "files")
///     zip1.Comment = ("This zip file was created at " &amp; DateTime.Now.ToString("G"))
///     zip1.Save("Content.zip")
///   End Using
/// End Sub
/// </code>
/// </example>
/// <summary>
///   Adds a named entry into the zip archive, taking content for the entry
///   from a string, and using the specified text encoding.
/// </summary>
///
/// <remarks>
///
/// <para>
///   Calling this method creates an entry using the given fileName and
///   directory path within the archive.  There is no need for a file by the
///   given name to exist in the filesystem; the name is used within the zip
///   archive only.
/// </para>
///
/// <para>
///   The content for the entry, a string value, is encoded using the given
///   text encoding. A BOM (byte-order-mark) is emitted into the file, if the
///   Encoding parameter is set for that.
/// </para>
///
/// <para>
///   Most Encoding classes support a constructor that accepts a boolean,
///   indicating whether to emit a BOM or not. For example see <see
///   cref="System.Text.UTF8Encoding(bool)"/>.
/// </para>
///
/// </remarks>
///
/// <param name="entryName">
///   The name, including any path, to use within the archive for the entry.
/// </param>
///
/// <param name="content">
///   The content of the file, should it be extracted from the zip.
/// </param>
///
/// <param name="encoding">
///   The text encoding to use when encoding the string. Be aware: This is
///   distinct from the text encoding used to encode the fileName, as specified
///   in <see cref="ProvisionalAlternateEncoding" />.
/// </param>
///
/// <returns>The <c>ZipEntry</c> added.</returns>
///
// cannot employ a using clause here.  We need the stream to
// persist after exit from this method.
// cannot use a using clause here; StreamWriter takes
// ownership of the stream and Disposes it before we are ready.
// reset to allow reading later
// must not dispose the MemoryStream - it will be used later.
/// <summary>
///   Create an entry in the <c>ZipFile</c> using the given <c>Stream</c>
///   as input.  The entry will have the given filename.
/// </summary>
///
/// <remarks>
///
/// <para>
///   The application should provide an open, readable stream; in this case it
///   will be read during the call to <see cref="ZipFile.Save()"/> or one of
///   its overloads.
/// </para>
///
/// <para>
///   The passed stream will be read from its current position. If
///   necessary, callers should set the position in the stream before
///   calling AddEntry(). This might be appropriate when using this method
///   with a MemoryStream, for example.
/// </para>
///
/// <para>
///   In cases where a large number of streams will be added to the
///   <c>ZipFile</c>, the application may wish to avoid maintaining all of the
///   streams open simultaneously.  To handle this situation, the application
///   should use the <see cref="AddEntry(string, OpenDelegate, CloseDelegate)"/>
///   overload.
/// </para>
///
/// <para>
///   For <c>ZipFile</c> properties including <see cref="Encryption"/>, <see
///   cref="Password"/>, <see cref="SetCompression"/>, <see
///   cref="ProvisionalAlternateEncoding"/>, <see cref="ExtractExistingFile"/>,
///   <see cref="ZipErrorAction"/>, and <see cref="CompressionLevel"/>, their
///   respective values at the time of this call will be applied to the
///   <c>ZipEntry</c> added.
/// </para>
///
/// </remarks>
///
/// <example>
/// <para>
///   This example adds a single entry to a <c>ZipFile</c> via a <c>Stream</c>.
/// </para>
///
/// <code lang="C#">
/// String zipToCreate = "Content.zip";
/// String fileNameInArchive = "Content-From-Stream.bin";
/// using (System.IO.Stream streamToRead = MyStreamOpener())
/// {
///   using (ZipFile zip = new ZipFile())
///   {
///     ZipEntry entry= zip.AddEntry(fileNameInArchive, streamToRead);
///     zip.AddFile("Readme.txt");
///     zip.Save(zipToCreate);  // the stream is read implicitly here
///   }
/// }
/// </code>
///
/// <code lang="VB">
/// Dim zipToCreate As String = "Content.zip"
/// Dim fileNameInArchive As String = "Content-From-Stream.bin"
/// Using streamToRead as System.IO.Stream = MyStreamOpener()
///   Using zip As ZipFile = New ZipFile()
///     Dim entry as ZipEntry = zip.AddEntry(fileNameInArchive, streamToRead)
///     zip.AddFile("Readme.txt")
///     zip.Save(zipToCreate)  '' the stream is read implicitly, here
///   End Using
/// End Using
/// </code>
/// </example>
///
/// <seealso cref="Ionic.Zip.ZipFile.UpdateEntry(string, System.IO.Stream)"/>
///
/// <param name="entryName">
///   The name, including any path, which is shown in the zip file for the added
///   entry.
/// </param>
/// <param name="stream">
///   The input stream from which to grab content for the file
/// </param>
/// <returns>The <c>ZipEntry</c> added.</returns>
/// <summary>
///   Add a ZipEntry for which content is written directly by the application.
/// </summary>
///
/// <remarks>
/// <para>
///   When the application needs to write the zip entry data, use this
///   method to add the ZipEntry. For example, in the case that the
///   application wishes to write the XML representation of a DataSet into
///   a ZipEntry, the application can use this method to do so.
/// </para>
///
/// <para>
///   For <c>ZipFile</c> properties including <see cref="Encryption"/>, <see
///   cref="Password"/>, <see cref="SetCompression"/>, <see
///   cref="ProvisionalAlternateEncoding"/>, <see cref="ExtractExistingFile"/>,
///   <see cref="ZipErrorAction"/>, and <see cref="CompressionLevel"/>, their
///   respective values at the time of this call will be applied to the
///   <c>ZipEntry</c> added.
/// </para>
///
/// <para>
///   About progress events: When using the WriteDelegate, DotNetZip does
///   not issue any SaveProgress events with <c>EventType</c> = <see
///   cref="ZipProgressEventType.Saving_EntryBytesRead">
///   Saving_EntryBytesRead</see>. (This is because it is the
///   application's code that runs in WriteDelegate - there's no way for
///   DotNetZip to know when to issue a EntryBytesRead event.)
///   Applications that want to update a progress bar or similar status
///   indicator should do so from within the WriteDelegate
///   itself. DotNetZip will issue the other SaveProgress events,
///   including <see cref="ZipProgressEventType.Saving_Started">
///   Saving_Started</see>,
///   <see cref="ZipProgressEventType.Saving_BeforeWriteEntry">
///   Saving_BeforeWriteEntry</see>, and <see
///   cref="ZipProgressEventType.Saving_AfterWriteEntry">
///   Saving_AfterWriteEntry</see>.
/// </para>
///
/// <para>
///   Note: When you use PKZip encryption, it's normally necessary to
///   compute the CRC of the content to be encrypted, before compressing or
///   encrypting it. Therefore, when using PKZip encryption with a
///   WriteDelegate, the WriteDelegate CAN BE called twice: once to compute
///   the CRC, and the second time to potentially compress and
///   encrypt. Surprising, but true. This is because PKWARE specified that
///   the encryption initialization data depends on the CRC.
///   If this happens, for each call of the delegate, your
///   application must stream the same entry data in its entirety. If your
///   application writes different data during the second call, it will
///   result in a corrupt zip file.
/// </para>
///
/// <para>
///   The double-read behavior happens with all types of entries, not only
///   those that use WriteDelegate. It happens if you add an entry from a
///   filesystem file, or using a string, or a stream, or an opener/closer
///   pair. But in those cases, DotNetZip takes care of reading twice; in
///   the case of the WriteDelegate, the application code gets invoked
///   twice. Be aware.
/// </para>
///
/// <para>
///   As you can imagine, this can cause performance problems for large
///   streams, and it can lead to correctness problems when you use a
///   <c>WriteDelegate</c>. This is a pretty big pitfall.  There are two
///   ways to avoid it.  First, and most preferred: don't use PKZIP
///   encryption.  If you use the WinZip AES encryption, this problem
///   doesn't occur, because the encryption protocol doesn't require the CRC
///   up front. Second: if you do choose to use PKZIP encryption, write out
///   to a non-seekable stream (like standard output, or the
///   Response.OutputStream in an ASP.NET application).  In this case,
///   DotNetZip will use an alternative encryption protocol that does not
///   rely on the CRC of the content.  This also implies setting bit 3 in
///   the zip entry, which still presents problems for some zip tools.
/// </para>
///
/// <para>
///   In the future I may modify DotNetZip to *always* use bit 3 when PKZIP
///   encryption is in use.  This seems like a win overall, but there will
///   be some work involved.  If you feel strongly about it, visit the
///   DotNetZip forums and vote up <see
///   href="http://dotnetzip.codeplex.com/workitem/13686">the Workitem
///   tracking this issue</see>.
/// </para>
///
/// </remarks>
///
/// <param name="entryName">the name of the entry to add</param>
/// <param name="writer">the delegate which will write the entry content</param>
/// <returns>the ZipEntry added</returns>
///
/// <example>
///
///   This example shows an application filling a DataSet, then saving the
///   contents of that DataSet as XML, into a ZipEntry in a ZipFile, using an
///   anonymous delegate in C#. The DataSet XML is never saved to a disk file.
///
/// <code lang="C#">
/// var c1= new System.Data.SqlClient.SqlConnection(connstring1);
/// var da = new System.Data.SqlClient.SqlDataAdapter()
///     {
///         SelectCommand=  new System.Data.SqlClient.SqlCommand(strSelect, c1)
///     };
///
/// DataSet ds1 = new DataSet();
/// da.Fill(ds1, "Invoices");
///
/// using(Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile())
/// {
///     zip.AddEntry(zipEntryName, (name,stream) => ds1.WriteXml(stream) );
///     zip.Save(zipFileName);
/// }
/// </code>
/// </example>
///
/// <example>
///
/// This example uses an anonymous method in C# as the WriteDelegate to provide
/// the data for the ZipEntry. The example is a bit contrived - the
/// <c>AddFile()</c> method is a simpler way to insert the contents of a file
/// into an entry in a zip file. On the other hand, if there is some sort of
/// processing or transformation of the file contents required before writing,
/// the application could use the <c>WriteDelegate</c> to do it, in this way.
///
/// <code lang="C#">
/// using (var input = File.Open(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite ))
/// {
///     using(Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile())
///     {
///         zip.AddEntry(zipEntryName, (name,output) =>
///             {
///                 byte[] buffer = new byte[BufferSize];
///                 int n;
///                 while ((n = input.Read(buffer, 0, buffer.Length)) != 0)
///                 {
///                     // could transform the data here...
///                     output.Write(buffer, 0, n);
///                     // could update a progress bar here
///                 }
///             });
///
///         zip.Save(zipFileName);
///     }
/// }
/// </code>
/// </example>
///
/// <example>
///
/// This example uses a named delegate in VB to write data for the given
/// ZipEntry (VB9 does not have anonymous delegates). The example here is a bit
/// contrived - a simpler way to add the contents of a file to a ZipEntry is to
/// simply use the appropriate <c>AddFile()</c> method.  The key scenario for
/// which the <c>WriteDelegate</c> makes sense is saving a DataSet, in XML
/// format, to the zip file. The DataSet can write XML to a stream, and the
/// WriteDelegate is the perfect place to write into the zip file.  There may be
/// other data structures that can write to a stream, but cannot be read as a
/// stream.  The <c>WriteDelegate</c> would be appropriate for those cases as
/// well.
///
/// <code lang="VB">
/// Private Sub WriteEntry (ByVal name As String, ByVal output As Stream)
///     Using input As FileStream = File.Open(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)
///         Dim n As Integer = -1
///         Dim buffer As Byte() = New Byte(BufferSize){}
///         Do While n &lt;&gt; 0
///             n = input.Read(buffer, 0, buffer.Length)
///             output.Write(buffer, 0, n)
///         Loop
///     End Using
/// End Sub
///
/// Public Sub Run()
///     Using zip = New ZipFile
///         zip.AddEntry(zipEntryName, New WriteDelegate(AddressOf WriteEntry))
///         zip.Save(zipFileName)
///     End Using
/// End Sub
/// </code>
/// </example>
/// <summary>
///   Add an entry, for which the application will provide a stream
///   containing the entry data, on a just-in-time basis.
/// </summary>
///
/// <remarks>
/// <para>
///   In cases where the application wishes to open the stream that
///   holds the content for the ZipEntry, on a just-in-time basis, the
///   application can use this method.  The application provides an
///   opener delegate that will be called by the DotNetZip library to
///   obtain a readable stream that can be read to get the bytes for
///   the given entry.  Typically, this delegate opens a stream.
///   Optionally, the application can provide a closer delegate as
///   well, which will be called by DotNetZip when all bytes have been
///   read from the entry.
/// </para>
///
/// <para>
///   These delegates are called from within the scope of the call to
///   ZipFile.Save().
/// </para>
///
/// <para>
///   For <c>ZipFile</c> properties including <see cref="Encryption"/>, <see
///   cref="Password"/>, <see cref="SetCompression"/>, <see
///   cref="ProvisionalAlternateEncoding"/>, <see cref="ExtractExistingFile"/>,
///   <see cref="ZipErrorAction"/>, and <see cref="CompressionLevel"/>, their
///   respective values at the time of this call will be applied to the
///   <c>ZipEntry</c> added.
/// </para>
///
/// </remarks>
///
/// <example>
///
///   This example uses anonymous methods in C# to open and close the
///   source stream for the content for a zip entry.
///
/// <code lang="C#">
/// using(Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile())
/// {
///     zip.AddEntry(zipEntryName,
///                  (name) =>  File.Open(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite ),
///                  (name, stream) =>  stream.Close()
///                  );
///
///     zip.Save(zipFileName);
/// }
/// </code>
///
/// </example>
///
/// <example>
///
///   This example uses delegates in VB.NET to open and close the
///   the source stream for the content for a zip entry.  VB 9.0 lacks
///   support for "Sub" lambda expressions, and so the CloseDelegate must
///   be an actual, named Sub.
///
/// <code lang="VB">
///
/// Function MyStreamOpener(ByVal entryName As String) As Stream
///     '' This simply opens a file.  You probably want to do somethinig
///     '' more involved here: open a stream to read from a database,
///     '' open a stream on an HTTP connection, and so on.
///     Return File.OpenRead(entryName)
/// End Function
///
/// Sub MyStreamCloser(entryName As String, stream As Stream)
///     stream.Close()
/// End Sub
///
/// Public Sub Run()
///     Dim dirToZip As String = "fodder"
///     Dim zipFileToCreate As String = "Archive.zip"
///     Dim opener As OpenDelegate = AddressOf MyStreamOpener
///     Dim closer As CloseDelegate = AddressOf MyStreamCloser
///     Dim numFilestoAdd As Int32 = 4
///     Using zip As ZipFile = New ZipFile
///         Dim i As Integer
///         For i = 0 To numFilesToAdd - 1
///             zip.AddEntry(String.Format("content-{0:000}.txt"), opener, closer)
///         Next i
///         zip.Save(zipFileToCreate)
///     End Using
/// End Sub
///
/// </code>
/// </example>
///
/// <param name="entryName">the name of the entry to add</param>
/// <param name="opener">
///  the delegate that will be invoked by ZipFile.Save() to get the
///  readable stream for the given entry. ZipFile.Save() will call
///  read on this stream to obtain the data for the entry. This data
///  will then be compressed and written to the newly created zip
///  file.
/// </param>
/// <param name="closer">
///  the delegate that will be invoked to close the stream. This may
///  be null (Nothing in VB), in which case no call is makde to close
///  the stream.
/// </param>
/// <returns>the ZipEntry added</returns>
///
// stamp all the props onto the entry
//string key = DictionaryKeyForEntry(ze);
/// <summary>
///   Updates the given entry in the <c>ZipFile</c>, using the given
///   string as content for the <c>ZipEntry</c>.
/// </summary>
///
/// <remarks>
///
/// <para>
///   Calling this method is equivalent to removing the <c>ZipEntry</c> for
///   the given file name and directory path, if it exists, and then calling
///   <see cref="AddEntry(String,String)" />.  See the documentation for
///   that method for further explanation. The string content is encoded
///   using the default encoding for the machine. This encoding is distinct
///   from the encoding used for the filename itself.  See
///   <see cref="AlternateEncoding"/>.
/// </para>
///
/// </remarks>
///
/// <param name="entryName">
///   The name, including any path, to use within the archive for the entry.
/// </param>
///
/// <param name="content">
///   The content of the file, should it be extracted from the zip.
/// </param>
///
/// <returns>The <c>ZipEntry</c> added.</returns>
///
/// <summary>
///   Updates the given entry in the <c>ZipFile</c>, using the given string as
///   content for the <c>ZipEntry</c>.
/// </summary>
///
/// <remarks>
///   Calling this method is equivalent to removing the <c>ZipEntry</c> for the
///   given file name and directory path, if it exists, and then calling <see
///   cref="AddEntry(String,String, System.Text.Encoding)" />.  See the
///   documentation for that method for further explanation.
/// </remarks>
///
/// <param name="entryName">
///   The name, including any path, to use within the archive for the entry.
/// </param>
///
/// <param name="content">
///   The content of the file, should it be extracted from the zip.
/// </param>
///
/// <param name="encoding">
///   The text encoding to use when encoding the string. Be aware: This is
///   distinct from the text encoding used to encode the filename. See <see
///   cref="AlternateEncoding" />.
/// </param>
///
/// <returns>The <c>ZipEntry</c> added.</returns>
///
/// <summary>
///   Updates the given entry in the <c>ZipFile</c>, using the given delegate
///   as the source for content for the <c>ZipEntry</c>.
/// </summary>
///
/// <remarks>
///   Calling this method is equivalent to removing the <c>ZipEntry</c> for the
///   given file name and directory path, if it exists, and then calling <see
///   cref="AddEntry(String,WriteDelegate)" />.  See the
///   documentation for that method for further explanation.
/// </remarks>
///
/// <param name="entryName">
///   The name, including any path, to use within the archive for the entry.
/// </param>
///
/// <param name="writer">the delegate which will write the entry content.</param>
///
/// <returns>The <c>ZipEntry</c> added.</returns>
///
/// <summary>
///   Updates the given entry in the <c>ZipFile</c>, using the given delegates
///   to open and close the stream that provides the content for the <c>ZipEntry</c>.
/// </summary>
///
/// <remarks>
///   Calling this method is equivalent to removing the <c>ZipEntry</c> for the
///   given file name and directory path, if it exists, and then calling <see
///   cref="AddEntry(String,OpenDelegate, CloseDelegate)" />.  See the
///   documentation for that method for further explanation.
/// </remarks>
///
/// <param name="entryName">
///   The name, including any path, to use within the archive for the entry.
/// </param>
///
/// <param name="opener">
///  the delegate that will be invoked to open the stream
/// </param>
/// <param name="closer">
///  the delegate that will be invoked to close the stream
/// </param>
///
/// <returns>The <c>ZipEntry</c> added or updated.</returns>
///
/// <summary>
///   Updates the given entry in the <c>ZipFile</c>, using the given stream as
///   input, and the given filename and given directory Path.
/// </summary>
///
/// <remarks>
/// <para>
///   Calling the method is equivalent to calling <c>RemoveEntry()</c> if an
///   entry by the same name already exists, and then calling <c>AddEntry()</c>
///   with the given <c>fileName</c> and stream.
/// </para>
///
/// <para>
///   The stream must be open and readable during the call to
///   <c>ZipFile.Save</c>.  You can dispense the stream on a just-in-time basis
///   using the <see cref="ZipEntry.InputStream"/> property. Check the
///   documentation of that property for more information.
/// </para>
///
/// <para>
///   For <c>ZipFile</c> properties including <see cref="Encryption"/>, <see
///   cref="Password"/>, <see cref="SetCompression"/>, <see
///   cref="ProvisionalAlternateEncoding"/>, <see cref="ExtractExistingFile"/>,
///   <see cref="ZipErrorAction"/>, and <see cref="CompressionLevel"/>, their
///   respective values at the time of this call will be applied to the
///   <c>ZipEntry</c> added.
/// </para>
///
/// </remarks>
///
/// <seealso cref="Ionic.Zip.ZipFile.AddEntry(string, System.IO.Stream)"/>
/// <seealso cref="Ionic.Zip.ZipEntry.InputStream"/>
///
/// <param name="entryName">
///   The name, including any path, to use within the archive for the entry.
/// </param>
///
/// <param name="stream">The input stream from which to read file data.</param>
/// <returns>The <c>ZipEntry</c> added.</returns>
/// <summary>
///   Add an entry into the zip archive using the given filename and
///   directory path within the archive, and the given content for the
///   file. No file is created in the filesystem.
/// </summary>
///
/// <param name="byteContent">The data to use for the entry.</param>
///
/// <param name="entryName">
///   The name, including any path, to use within the archive for the entry.
/// </param>
///
/// <returns>The <c>ZipEntry</c> added.</returns>
/// <summary>
///   Updates the given entry in the <c>ZipFile</c>, using the given byte
///   array as content for the entry.
/// </summary>
///
/// <remarks>
///   Calling this method is equivalent to removing the <c>ZipEntry</c>
///   for the given filename and directory path, if it exists, and then
///   calling <see cref="AddEntry(String,byte[])" />.  See the
///   documentation for that method for further explanation.
/// </remarks>
///
/// <param name="entryName">
///   The name, including any path, to use within the archive for the entry.
/// </param>
///
/// <param name="byteContent">The content to use for the <c>ZipEntry</c>.</param>
///
/// <returns>The <c>ZipEntry</c> added.</returns>
///
//         private string DictionaryKeyForEntry(ZipEntry ze1)
//         {
//             var filename = SharedUtilities.NormalizePathForUseInZipFile(ze1.FileName);
//             return filename;
//         }
/// <summary>
///   Adds the contents of a filesystem directory to a Zip file archive.
/// </summary>
///
/// <remarks>
///
/// <para>
///   The name of the directory may be a relative path or a fully-qualified
///   path. Any files within the named directory are added to the archive.  Any
///   subdirectories within the named directory are also added to the archive,
///   recursively.
/// </para>
///
/// <para>
///   Top-level entries in the named directory will appear as top-level entries
///   in the zip archive.  Entries in subdirectories in the named directory will
///   result in entries in subdirectories in the zip archive.
/// </para>
///
/// <para>
///   If you want the entries to appear in a containing directory in the zip
///   archive itself, then you should call the AddDirectory() overload that
///   allows you to explicitly specify a directory path for use in the archive.
/// </para>
///
/// <para>
///   For <c>ZipFile</c> properties including <see cref="Encryption"/>, <see
///   cref="Password"/>, <see cref="SetCompression"/>, <see
///   cref="ProvisionalAlternateEncoding"/>, <see cref="ExtractExistingFile"/>,
///   <see cref="ZipErrorAction"/>, and <see cref="CompressionLevel"/>, their
///   respective values at the time of this call will be applied to each
///   ZipEntry added.
/// </para>
///
/// </remarks>
///
/// <seealso cref="Ionic.Zip.ZipFile.AddItem(string)"/>
/// <seealso cref="Ionic.Zip.ZipFile.AddFile(string)"/>
/// <seealso cref="Ionic.Zip.ZipFile.UpdateDirectory(string)"/>
/// <seealso cref="Ionic.Zip.ZipFile.AddDirectory(string, string)"/>
///
/// <overloads>This method has 2 overloads.</overloads>
///
/// <param name="directoryName">The name of the directory to add.</param>
/// <returns>The <c>ZipEntry</c> added.</returns>
/// <summary>
///   Adds the contents of a filesystem directory to a Zip file archive,
///   overriding the path to be used for entries in the archive.
/// </summary>
///
/// <remarks>
/// <para>
///   The name of the directory may be a relative path or a fully-qualified
///   path. The add operation is recursive, so that any files or subdirectories
///   within the name directory are also added to the archive.
/// </para>
///
/// <para>
///   Top-level entries in the named directory will appear as top-level entries
///   in the zip archive.  Entries in subdirectories in the named directory will
///   result in entries in subdirectories in the zip archive.
/// </para>
///
/// <para>
///   For <c>ZipFile</c> properties including <see cref="Encryption"/>, <see
///   cref="Password"/>, <see cref="SetCompression"/>, <see
///   cref="ProvisionalAlternateEncoding"/>, <see cref="ExtractExistingFile"/>,
///   <see cref="ZipErrorAction"/>, and <see cref="CompressionLevel"/>, their
///   respective values at the time of this call will be applied to each
///   ZipEntry added.
/// </para>
///
/// </remarks>
///
/// <example>
/// <para>
///   In this code, calling the ZipUp() method with a value of "c:\reports" for
///   the directory parameter will result in a zip file structure in which all
///   entries are contained in a toplevel "reports" directory.
/// </para>
///
/// <code lang="C#">
/// public void ZipUp(string targetZip, string directory)
/// {
///   using (var zip = new ZipFile())
///   {
///     zip.AddDirectory(directory, System.IO.Path.GetFileName(directory));
///     zip.Save(targetZip);
///   }
/// }
/// </code>
/// </example>
///
/// <seealso cref="Ionic.Zip.ZipFile.AddItem(string, string)"/>
/// <seealso cref="Ionic.Zip.ZipFile.AddFile(string, string)"/>
/// <seealso cref="Ionic.Zip.ZipFile.UpdateDirectory(string, string)"/>
///
/// <param name="directoryName">The name of the directory to add.</param>
///
/// <param name="directoryPathInArchive">
///   Specifies a directory path to use to override any path in the
///   DirectoryName.  This path may, or may not, correspond to a real directory
///   in the current filesystem.  If the zip is later extracted, this is the
///   path used for the extracted file or directory.  Passing <c>null</c>
///   (<c>Nothing</c> in VB) or the empty string ("") will insert the items at
///   the root path within the archive.
/// </param>
///
/// <returns>The <c>ZipEntry</c> added.</returns>
/// <summary>
///   Creates a directory in the zip archive.
/// </summary>
///
/// <remarks>
///
/// <para>
///   Use this when you want to create a directory in the archive but there is
///   no corresponding filesystem representation for that directory.
/// </para>
///
/// <para>
///   You will probably not need to do this in your code. One of the only times
///   you will want to do this is if you want an empty directory in the zip
///   archive.  The reason: if you add a file to a zip archive that is stored
///   within a multi-level directory, all of the directory tree is implicitly
///   created in the zip archive.
/// </para>
///
/// </remarks>
///
/// <param name="directoryNameInArchive">
///   The name of the directory to create in the archive.
/// </param>
/// <returns>The <c>ZipEntry</c> added.</returns>
// workitem 9073
// workitem 8984
//string key = DictionaryKeyForEntry(dir);
// workitem 13371
// if not top level, or if the root is non-empty, then explicitly add the directory
// workitem 6410
// add the directory only if it does not exist.
// It's not an error if it already exists.
// add the files:
// add the subdirectories:
// workitem 8617: Optionally traverse reparse points
// ZipFile.Check.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2011 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-July-31 14:40:50>
//
// ------------------------------------------------------------------
//
// This module defines the methods for doing Checks on zip files.
// These are not necessary to include in the Reduced version
// of the library.
//
// ------------------------------------------------------------------
//
/// <summary>
///   Checks a zip file to see if its directory is consistent.
/// </summary>
///
/// <remarks>
///
/// <para>
///   In cases of data error, the directory within a zip file can get out
///   of synch with the entries in the zip file.  This method checks the
///   given zip file and returns true if this has occurred.
/// </para>
///
/// <para> This method may take a long time to run for large zip files.  </para>
///
/// <para>
///   This method is not supported in the Reduced version of DotNetZip.
/// </para>
///
/// <para>
///   Developers using COM can use the <see
///   cref="ComHelper.CheckZip(String)">ComHelper.CheckZip(String)</see>
///   method.
/// </para>
///
/// </remarks>
///
/// <param name="zipFileName">The filename to of the zip file to check.</param>
///
/// <returns>true if the named zip file checks OK. Otherwise, false. </returns>
///
/// <seealso cref="FixZipDirectory(string)"/>
/// <seealso cref="CheckZip(string,bool,System.IO.TextWriter)"/>
/// <summary>
///   Checks a zip file to see if its directory is consistent,
///   and optionally fixes the directory if necessary.
/// </summary>
///
/// <remarks>
///
/// <para>
///   In cases of data error, the directory within a zip file can get out of
///   synch with the entries in the zip file.  This method checks the given
///   zip file, and returns true if this has occurred. It also optionally
///   fixes the zipfile, saving the fixed copy in <em>Name</em>_Fixed.zip.
/// </para>
///
/// <para>
///   This method may take a long time to run for large zip files.  It
///   will take even longer if the file actually needs to be fixed, and if
///   <c>fixIfNecessary</c> is true.
/// </para>
///
/// <para>
///   This method is not supported in the Reduced version of DotNetZip.
/// </para>
///
/// </remarks>
///
/// <param name="zipFileName">The filename to of the zip file to check.</param>
///
/// <param name="fixIfNecessary">If true, the method will fix the zip file if
///     necessary.</param>
///
/// <param name="writer">
/// a TextWriter in which messages generated while checking will be written.
/// </param>
///
/// <returns>true if the named zip is OK; false if the file needs to be fixed.</returns>
///
/// <seealso cref="CheckZip(string)"/>
/// <seealso cref="FixZipDirectory(string)"/>
// found a match, so stop the inside loop
/// <summary>
///   Rewrite the directory within a zipfile.
/// </summary>
///
/// <remarks>
///
/// <para>
///   In cases of data error, the directory in a zip file can get out of
///   synch with the entries in the zip file.  This method attempts to fix
///   the zip file if this has occurred.
/// </para>
///
/// <para> This can take a long time for large zip files. </para>
///
/// <para> This won't work if the zip file uses a non-standard
/// code page - neither IBM437 nor UTF-8. </para>
///
/// <para>
///   This method is not supported in the Reduced or Compact Framework
///   versions of DotNetZip.
/// </para>
///
/// <para>
///   Developers using COM can use the <see
///   cref="ComHelper.FixZipDirectory(String)">ComHelper.FixZipDirectory(String)</see>
///   method.
/// </para>
///
/// </remarks>
///
/// <param name="zipFileName">The filename to of the zip file to fix.</param>
///
/// <seealso cref="CheckZip(string)"/>
/// <seealso cref="CheckZip(string,bool,System.IO.TextWriter)"/>
/// <summary>
///   Verify the password on a zip file.
/// </summary>
///
/// <remarks>
///   <para>
///     Keep in mind that passwords in zipfiles are applied to
///     zip entries, not to the entire zip file. So testing a
///     zipfile for a particular password doesn't work in the
///     general case. On the other hand, it's often the case
///     that a single password will be used on all entries in a
///     zip file. This method works for that case.
///   </para>
///   <para>
///     There is no way to check a password without doing the
///     decryption. So this code decrypts and extracts the given
///     zipfile into <see cref="System.IO.Stream.Null"/>
///   </para>
/// </remarks>
///
/// <param name="zipFileName">The filename to of the zip file to fix.</param>
///
/// <param name="password">The password to check.</param>
///
/// <returns>a bool indicating whether the password matches.</returns>
// workitem 13664
/// <summary>
///   Provides a human-readable string with information about the ZipFile.
/// </summary>
///
/// <remarks>
///   <para>
///     The information string contains 10 lines or so, about each ZipEntry,
///     describing whether encryption is in use, the compressed and uncompressed
///     length of the entry, the offset of the entry, and so on. As a result the
///     information string can be very long for zip files that contain many
///     entries.
///   </para>
///   <para>
///     This information is mostly useful for diagnostic purposes.
///   </para>
/// </remarks>
// ZipFile.cs
//
// Copyright (c) 2006-2010 Dino Chiesa
// All rights reserved.
//
// This module is part of DotNetZip, a zipfile class library.
// The class library reads and writes zip files, according to the format
// described by PKware, at:
// http://www.pkware.com/business_and_developers/developer/popups/appnote.txt
//
//
// There are other Zip class libraries available.
//
// - it is possible to read and write zip files within .NET via the J# runtime.
//   But some people don't like to install the extra DLL, which is no longer
//   supported by MS. And also, the J# libraries don't support advanced zip
//   features, like ZIP64, spanned archives, or AES encryption.
//
// - There are third-party GPL and LGPL libraries available. Some people don't
//   like the license, and some of them don't support all the ZIP features, like AES.
//
// - Finally, there are commercial tools (From ComponentOne, XCeed, etc).  But
//   some people don't want to incur the cost.
//
// This alternative implementation is **not** GPL licensed. It is free of cost, and
// does not require J#. It balances a good set of features, with ease of use and
// speed of performance.
//
// This code is released under the Microsoft Public License .
// See the License.txt for details.
//
//
// NB: This implementation originally relied on the
// System.IO.Compression.DeflateStream base class in the .NET Framework
// v2.0 base class library, but now includes a managed-code port of Zlib.
//
// Thu, 08 Oct 2009  17:04
//
/// <summary>
///   The ZipFile type represents a zip archive file.
/// </summary>
///
/// <remarks>
/// <para>
///   This is the main type in the DotNetZip class library. This class reads and
///   writes zip files, as defined in the <see
///   href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">specification
///   for zip files described by PKWare</see>.  The compression for this
///   implementation is provided by a managed-code version of Zlib, included with
///   DotNetZip in the classes in the Ionic.Zlib namespace.
/// </para>
///
/// <para>
///   This class provides a general purpose zip file capability.  Use it to read,
///   create, or update zip files.  When you want to create zip files using a
///   <c>Stream</c> type to write the zip file, you may want to consider the <see
///   cref="ZipOutputStream"/> class.
/// </para>
///
/// <para>
///   Both the <c>ZipOutputStream</c> class and the <c>ZipFile</c> class can
///   be used to create zip files. Both of them support many of the common zip
///   features, including Unicode, different compression methods and levels,
///   and ZIP64. They provide very similar performance when creating zip
///   files.
/// </para>
///
/// <para>
///   The <c>ZipFile</c> class is generally easier to use than
///   <c>ZipOutputStream</c> and should be considered a higher-level interface.  For
///   example, when creating a zip file via calls to the <c>PutNextEntry()</c> and
///   <c>Write()</c> methods on the <c>ZipOutputStream</c> class, the caller is
///   responsible for opening the file, reading the bytes from the file, writing
///   those bytes into the <c>ZipOutputStream</c>, setting the attributes on the
///   <c>ZipEntry</c>, and setting the created, last modified, and last accessed
///   timestamps on the zip entry. All of these things are done automatically by a
///   call to <see cref="ZipFile.AddFile(string,string)">ZipFile.AddFile()</see>.
///   For this reason, the <c>ZipOutputStream</c> is generally recommended for use
///   only when your application emits arbitrary data, not necessarily data from a
///   filesystem file, directly into a zip file, and does so using a <c>Stream</c>
///   metaphor.
/// </para>
///
/// <para>
///   Aside from the differences in programming model, there are other
///   differences in capability between the two classes.
/// </para>
///
/// <list type="bullet">
///   <item>
///     <c>ZipFile</c> can be used to read and extract zip files, in addition to
///     creating zip files. <c>ZipOutputStream</c> cannot read zip files. If you want
///     to use a stream to read zip files, check out the <see cref="ZipInputStream"/> class.
///   </item>
///
///   <item>
///     <c>ZipOutputStream</c> does not support the creation of segmented or spanned
///     zip files.
///   </item>
///
///   <item>
///     <c>ZipOutputStream</c> cannot produce a self-extracting archive.
///   </item>
/// </list>
///
/// <para>
///   Be aware that the <c>ZipFile</c> class implements the <see
///   cref="System.IDisposable"/> interface.  In order for <c>ZipFile</c> to
///   produce a valid zip file, you use use it within a using clause (<c>Using</c>
///   in VB), or call the <c>Dispose()</c> method explicitly.  See the examples
///   for how to employ a using clause.
/// </para>
///
/// </remarks>
/// <summary>
/// Indicates whether to perform a full scan of the zip file when reading it.
/// </summary>
///
/// <remarks>
///
/// <para>
///   You almost never want to use this property.
/// </para>
///
/// <para>
///   When reading a zip file, if this flag is <c>true</c> (<c>True</c> in
///   VB), the entire zip archive will be scanned and searched for entries.
///   For large archives, this can take a very, long time. The much more
///   efficient default behavior is to read the zip directory, which is
///   stored at the end of the zip file. But, in some cases the directory is
///   corrupted and you need to perform a full scan of the zip file to
///   determine the contents of the zip file. This property lets you do
///   that, when necessary.
/// </para>
///
/// <para>
///   This flag is effective only when calling <see
///   cref="Initialize(string)"/>. Normally you would read a ZipFile with the
///   static <see cref="ZipFile.Read(String)">ZipFile.Read</see>
///   method. But you can't set the <c>FullScan</c> property on the
///   <c>ZipFile</c> instance when you use a static factory method like
///   <c>ZipFile.Read</c>.
/// </para>
///
/// </remarks>
///
/// <example>
///
///   This example shows how to read a zip file using the full scan approach,
///   and then save it, thereby producing a corrected zip file.
///
/// <code lang="C#">
/// using (var zip = new ZipFile())
/// {
///     zip.FullScan = true;
///     zip.Initialize(zipFileName);
///     zip.Save(newName);
/// }
/// </code>
///
/// <code lang="VB">
/// Using zip As New ZipFile
///     zip.FullScan = True
///     zip.Initialize(zipFileName)
///     zip.Save(newName)
/// End Using
/// </code>
/// </example>
///
/// <summary>
///   Whether to sort the ZipEntries before saving the file.
/// </summary>
///
/// <remarks>
///   The default is false.  If you have a large number of zip entries, the sort
///   alone can consume significant time.
/// </remarks>
///
/// <example>
/// <code lang="C#">
/// using (var zip = new ZipFile())
/// {
///     zip.AddFiles(filesToAdd);
///     zip.SortEntriesBeforeSaving = true;
///     zip.Save(name);
/// }
/// </code>
///
/// <code lang="VB">
/// Using zip As New ZipFile
///     zip.AddFiles(filesToAdd)
///     zip.SortEntriesBeforeSaving = True
///     zip.Save(name)
/// End Using
/// </code>
/// </example>
///
/// <summary>
///   Indicates whether NTFS Reparse Points, like junctions, should be
///   traversed during calls to <c>AddDirectory()</c>.
/// </summary>
///
/// <remarks>
///   By default, calls to AddDirectory() will traverse NTFS reparse
///   points, like mounted volumes, and directory junctions.  An example
///   of a junction is the "My Music" directory in Windows Vista.  In some
///   cases you may not want DotNetZip to traverse those directories.  In
///   that case, set this property to false.
/// </remarks>
///
/// <example>
/// <code lang="C#">
/// using (var zip = new ZipFile())
/// {
///     zip.AddDirectoryWillTraverseReparsePoints = false;
///     zip.AddDirectory(dirToZip,"fodder");
///     zip.Save(zipFileToCreate);
/// }
/// </code>
/// </example>
/// <summary>
///   Size of the IO buffer used while saving.
/// </summary>
///
/// <remarks>
///
/// <para>
///   First, let me say that you really don't need to bother with this.  It is
///   here to allow for optimizations that you probably won't make! It will work
///   fine if you don't set or get this property at all. Ok?
/// </para>
///
/// <para>
///   Now that we have <em>that</em> out of the way, the fine print: This
///   property affects the size of the buffer that is used for I/O for each
///   entry contained in the zip file. When a file is read in to be compressed,
///   it uses a buffer given by the size here.  When you update a zip file, the
///   data for unmodified entries is copied from the first zip file to the
///   other, through a buffer given by the size here.
/// </para>
///
/// <para>
///   Changing the buffer size affects a few things: first, for larger buffer
///   sizes, the memory used by the <c>ZipFile</c>, obviously, will be larger
///   during I/O operations.  This may make operations faster for very much
///   larger files.  Last, for any given entry, when you use a larger buffer
///   there will be fewer progress events during I/O operations, because there's
///   one progress event generated for each time the buffer is filled and then
///   emptied.
/// </para>
///
/// <para>
///   The default buffer size is 8k.  Increasing the buffer size may speed
///   things up as you compress larger files.  But there are no hard-and-fast
///   rules here, eh?  You won't know til you test it.  And there will be a
///   limit where ever larger buffers actually slow things down.  So as I said
///   in the beginning, it's probably best if you don't set or get this property
///   at all.
/// </para>
///
/// </remarks>
///
/// <example>
/// This example shows how you might set a large buffer size for efficiency when
/// dealing with zip entries that are larger than 1gb.
/// <code lang="C#">
/// using (ZipFile zip = new ZipFile())
/// {
///     zip.SaveProgress += this.zip1_SaveProgress;
///     zip.AddDirectory(directoryToZip, "");
///     zip.UseZip64WhenSaving = Zip64Option.Always;
///     zip.BufferSize = 65536*8; // 65536 * 8 = 512k
///     zip.Save(ZipFileToCreate);
/// }
/// </code>
/// </example>
/// <summary>
///   Size of the work buffer to use for the ZLIB codec during compression.
/// </summary>
///
/// <remarks>
///   <para>
///     When doing ZLIB or Deflate compression, the library fills a buffer,
///     then passes it to the compressor for compression. Then the library
///     reads out the compressed bytes. This happens repeatedly until there
///     is no more uncompressed data to compress. This property sets the
///     size of the buffer that will be used for chunk-wise compression. In
///     order for the setting to take effect, your application needs to set
///     this property before calling one of the <c>ZipFile.Save()</c>
///     overloads.
///   </para>
///   <para>
///     Setting this affects the performance and memory efficiency of
///     compression and decompression. For larger files, setting this to a
///     larger size may improve compression performance, but the exact
///     numbers vary depending on available memory, the size of the streams
///     you are compressing, and a bunch of other variables. I don't have
///     good firm recommendations on how to set it.  You'll have to test it
///     yourself. Or just leave it alone and accept the default.
///   </para>
/// </remarks>
/// <summary>
///   Indicates whether extracted files should keep their paths as
///   stored in the zip archive.
/// </summary>
///
/// <remarks>
///  <para>
///    This property affects Extraction.  It is not used when creating zip
///    archives.
///  </para>
///
///  <para>
///    With this property set to <c>false</c>, the default, extracting entries
///    from a zip file will create files in the filesystem that have the full
///    path associated to the entry within the zip file.  With this property set
///    to <c>true</c>, extracting entries from the zip file results in files
///    with no path: the folders are "flattened."
///  </para>
///
///  <para>
///    An example: suppose the zip file contains entries /directory1/file1.txt and
///    /directory2/file2.txt.  With <c>FlattenFoldersOnExtract</c> set to false,
///    the files created will be \directory1\file1.txt and \directory2\file2.txt.
///    With the property set to true, the files created are file1.txt and file2.txt.
///  </para>
///
/// </remarks>
/// <summary>
///   The compression strategy to use for all entries.
/// </summary>
///
/// <remarks>
///   Set the Strategy used by the ZLIB-compatible compressor, when
///   compressing entries using the DEFLATE method. Different compression
///   strategies work better on different sorts of data. The strategy
///   parameter can affect the compression ratio and the speed of
///   compression but not the correctness of the compresssion.  For more
///   information see <see
///   cref="Ionic.Zlib.CompressionStrategy">Ionic.Zlib.CompressionStrategy</see>.
/// </remarks>
/// <summary>
///   The name of the <c>ZipFile</c>, on disk.
/// </summary>
///
/// <remarks>
///
/// <para>
///   When the <c>ZipFile</c> instance was created by reading an archive using
///   one of the <c>ZipFile.Read</c> methods, this property represents the name
///   of the zip file that was read.  When the <c>ZipFile</c> instance was
///   created by using the no-argument constructor, this value is <c>null</c>
///   (<c>Nothing</c> in VB).
/// </para>
///
/// <para>
///   If you use the no-argument constructor, and you then explicitly set this
///   property, when you call <see cref="ZipFile.Save()"/>, this name will
///   specify the name of the zip file created.  Doing so is equivalent to
///   calling <see cref="ZipFile.Save(String)"/>.  When instantiating a
///   <c>ZipFile</c> by reading from a stream or byte array, the <c>Name</c>
///   property remains <c>null</c>.  When saving to a stream, the <c>Name</c>
///   property is implicitly set to <c>null</c>.
/// </para>
/// </remarks>
/// <summary>
///   Sets the compression level to be used for entries subsequently added to
///   the zip archive.
/// </summary>
///
/// <remarks>
///  <para>
///    Varying the compression level used on entries can affect the
///    size-vs-speed tradeoff when compression and decompressing data streams
///    or files.
///  </para>
///
///  <para>
///    As with some other properties on the <c>ZipFile</c> class, like <see
///    cref="Password"/>, <see cref="Encryption"/>, and <see
///    cref="ZipErrorAction"/>, setting this property on a <c>ZipFile</c>
///    instance will cause the specified <c>CompressionLevel</c> to be used on all
///    <see cref="ZipEntry"/> items that are subsequently added to the
///    <c>ZipFile</c> instance. If you set this property after you have added
///    items to the <c>ZipFile</c>, but before you have called <c>Save()</c>,
///    those items will not use the specified compression level.
///  </para>
///
///  <para>
///    If you do not set this property, the default compression level is used,
///    which normally gives a good balance of compression efficiency and
///    compression speed.  In some tests, using <c>BestCompression</c> can
///    double the time it takes to compress, while delivering just a small
///    increase in compression efficiency.  This behavior will vary with the
///    type of data you compress.  If you are in doubt, just leave this setting
///    alone, and accept the default.
///  </para>
/// </remarks>
/// <summary>
///   The compression method for the zipfile.
/// </summary>
/// <remarks>
///   <para>
///     By default, the compression method is <c>CompressionMethod.Deflate.</c>
///   </para>
/// </remarks>
/// <seealso cref="Ionic.Zip.CompressionMethod" />
/// <summary>
///   A comment attached to the zip archive.
/// </summary>
///
/// <remarks>
///
/// <para>
///   This property is read/write. It allows the application to specify a
///   comment for the <c>ZipFile</c>, or read the comment for the
///   <c>ZipFile</c>.  After setting this property, changes are only made
///   permanent when you call a <c>Save()</c> method.
/// </para>
///
/// <para>
///   According to <see
///   href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
///   zip specification</see>, the comment is not encrypted, even if there is a
///   password set on the zip file.
/// </para>
///
/// <para>
///   The specification does not describe how to indicate the encoding used
///   on a comment string. Many "compliant" zip tools and libraries use
///   IBM437 as the code page for comments; DotNetZip, too, follows that
///   practice.  On the other hand, there are situations where you want a
///   Comment to be encoded with something else, for example using code page
///   950 "Big-5 Chinese". To fill that need, DotNetZip will encode the
///   comment following the same procedure it follows for encoding
///   filenames: (a) if <see cref="AlternateEncodingUsage"/> is
///   <c>Never</c>, it uses the default encoding (IBM437). (b) if <see
///   cref="AlternateEncodingUsage"/> is <c>Always</c>, it always uses the
///   alternate encoding (<see cref="AlternateEncoding"/>). (c) if <see
///   cref="AlternateEncodingUsage"/> is <c>AsNecessary</c>, it uses the
///   alternate encoding only if the default encoding is not sufficient for
///   encoding the comment - in other words if decoding the result does not
///   produce the original string.  This decision is taken at the time of
///   the call to <c>ZipFile.Save()</c>.
/// </para>
///
/// <para>
///   When creating a zip archive using this library, it is possible to change
///   the value of <see cref="AlternateEncoding" /> between each
///   entry you add, and between adding entries and the call to
///   <c>Save()</c>. Don't do this.  It will likely result in a zip file that is
///   not readable by any tool or application.  For best interoperability, leave
///   <see cref="AlternateEncoding"/> alone, or specify it only
///   once, before adding any entries to the <c>ZipFile</c> instance.
/// </para>
///
/// </remarks>
/// <summary>
///   Specifies whether the Creation, Access, and Modified times for entries
///   added to the zip file will be emitted in &#147;Windows format&#148;
///   when the zip archive is saved.
/// </summary>
///
/// <remarks>
/// <para>
///   An application creating a zip archive can use this flag to explicitly
///   specify that the file times for the entries should or should not be stored
///   in the zip archive in the format used by Windows. By default this flag is
///   <c>true</c>, meaning the Windows-format times are stored in the zip
///   archive.
/// </para>
///
/// <para>
///   When adding an entry from a file or directory, the Creation (<see
///   cref="ZipEntry.CreationTime"/>), Access (<see
///   cref="ZipEntry.AccessedTime"/>), and Modified (<see
///   cref="ZipEntry.ModifiedTime"/>) times for the given entry are
///   automatically set from the filesystem values. When adding an entry from a
///   stream or string, all three values are implicitly set to
///   <c>DateTime.Now</c>.  Applications can also explicitly set those times by
///   calling <see cref="ZipEntry.SetEntryTimes(DateTime, DateTime,
///   DateTime)"/>.
/// </para>
///
/// <para>
///   <see
///   href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
///   zip specification</see> describes multiple ways to format these times in a
///   zip file. One is the format Windows applications normally use: 100ns ticks
///   since January 1, 1601 UTC.  The other is a format Unix applications typically
///   use: seconds since January 1, 1970 UTC.  Each format can be stored in an
///   "extra field" in the zip entry when saving the zip archive. The former
///   uses an extra field with a Header Id of 0x000A, while the latter uses a
///   header ID of 0x5455, although you probably don't need to know that.
/// </para>
///
/// <para>
///   Not all tools and libraries can interpret these fields.  Windows
///   compressed folders is one that can read the Windows Format timestamps,
///   while I believe <see href="http://www.info-zip.org/">the Infozip
///   tools</see> can read the Unix format timestamps. Some tools and libraries
///   may be able to read only one or the other. DotNetZip can read or write
///   times in either or both formats.
/// </para>
///
/// <para>
///   The times stored are taken from <see cref="ZipEntry.ModifiedTime"/>, <see
///   cref="ZipEntry.AccessedTime"/>, and <see cref="ZipEntry.CreationTime"/>.
/// </para>
///
/// <para>
///   The value set here applies to all entries subsequently added to the
///   <c>ZipFile</c>.
/// </para>
///
/// <para>
///   This property is not mutually exclusive of the <see
///   cref="EmitTimesInUnixFormatWhenSaving" /> property. It is possible and
///   legal and valid to produce a zip file that contains timestamps encoded in
///   the Unix format as well as in the Windows format, in addition to the <see
///   cref="ZipEntry.LastModified">LastModified</see> time attached to each
///   entry in the archive, a time that is always stored in "DOS format". And,
///   notwithstanding the names PKWare uses for these time formats, any of them
///   can be read and written by any computer, on any operating system.  But,
///   there are no guarantees that a program running on Mac or Linux will
///   gracefully handle a zip file with "Windows" formatted times, or that an
///   application that does not use DotNetZip but runs on Windows will be able to
///   handle file times in Unix format.
/// </para>
///
/// <para>
///   When in doubt, test.  Sorry, I haven't got a complete list of tools and
///   which sort of timestamps they can use and will tolerate.  If you get any
///   good information and would like to pass it on, please do so and I will
///   include that information in this documentation.
/// </para>
/// </remarks>
///
/// <example>
///   This example shows how to save a zip file that contains file timestamps
///   in a format normally used by Unix.
/// <code lang="C#">
/// using (var zip = new ZipFile())
/// {
///     // produce a zip file the Mac will like
///     zip.EmitTimesInWindowsFormatWhenSaving = false;
///     zip.EmitTimesInUnixFormatWhenSaving = true;
///     zip.AddDirectory(directoryToZip, "files");
///     zip.Save(outputFile);
/// }
/// </code>
///
/// <code lang="VB">
/// Using zip As New ZipFile
///     '' produce a zip file the Mac will like
///     zip.EmitTimesInWindowsFormatWhenSaving = False
///     zip.EmitTimesInUnixFormatWhenSaving = True
///     zip.AddDirectory(directoryToZip, "files")
///     zip.Save(outputFile)
/// End Using
/// </code>
/// </example>
///
/// <seealso cref="ZipEntry.EmitTimesInWindowsFormatWhenSaving" />
/// <seealso cref="EmitTimesInUnixFormatWhenSaving" />
/// <summary>
/// Specifies whether the Creation, Access, and Modified times
/// for entries added to the zip file will be emitted in "Unix(tm)
/// format" when the zip archive is saved.
/// </summary>
///
/// <remarks>
/// <para>
///   An application creating a zip archive can use this flag to explicitly
///   specify that the file times for the entries should or should not be stored
///   in the zip archive in the format used by Unix. By default this flag is
///   <c>false</c>, meaning the Unix-format times are not stored in the zip
///   archive.
/// </para>
///
/// <para>
///   When adding an entry from a file or directory, the Creation (<see
///   cref="ZipEntry.CreationTime"/>), Access (<see
///   cref="ZipEntry.AccessedTime"/>), and Modified (<see
///   cref="ZipEntry.ModifiedTime"/>) times for the given entry are
///   automatically set from the filesystem values. When adding an entry from a
///   stream or string, all three values are implicitly set to DateTime.Now.
///   Applications can also explicitly set those times by calling <see
///   cref="ZipEntry.SetEntryTimes(DateTime, DateTime, DateTime)"/>.
/// </para>
///
/// <para>
///   <see
///   href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
///   zip specification</see> describes multiple ways to format these times in a
///   zip file. One is the format Windows applications normally use: 100ns ticks
///   since January 1, 1601 UTC.  The other is a format Unix applications
///   typically use: seconds since January 1, 1970 UTC.  Each format can be
///   stored in an "extra field" in the zip entry when saving the zip
///   archive. The former uses an extra field with a Header Id of 0x000A, while
///   the latter uses a header ID of 0x5455, although you probably don't need to
///   know that.
/// </para>
///
/// <para>
///   Not all tools and libraries can interpret these fields.  Windows
///   compressed folders is one that can read the Windows Format timestamps,
///   while I believe the <see href="http://www.info-zip.org/">Infozip</see>
///   tools can read the Unix format timestamps. Some tools and libraries may be
///   able to read only one or the other.  DotNetZip can read or write times in
///   either or both formats.
/// </para>
///
/// <para>
///   The times stored are taken from <see cref="ZipEntry.ModifiedTime"/>, <see
///   cref="ZipEntry.AccessedTime"/>, and <see cref="ZipEntry.CreationTime"/>.
/// </para>
///
/// <para>
///   This property is not mutually exclusive of the <see
///   cref="EmitTimesInWindowsFormatWhenSaving" /> property. It is possible and
///   legal and valid to produce a zip file that contains timestamps encoded in
///   the Unix format as well as in the Windows format, in addition to the <see
///   cref="ZipEntry.LastModified">LastModified</see> time attached to each
///   entry in the zip archive, a time that is always stored in "DOS
///   format". And, notwithstanding the names PKWare uses for these time
///   formats, any of them can be read and written by any computer, on any
///   operating system.  But, there are no guarantees that a program running on
///   Mac or Linux will gracefully handle a zip file with "Windows" formatted
///   times, or that an application that does not use DotNetZip but runs on
///   Windows will be able to handle file times in Unix format.
/// </para>
///
/// <para>
///   When in doubt, test.  Sorry, I haven't got a complete list of tools and
///   which sort of timestamps they can use and will tolerate.  If you get any
///   good information and would like to pass it on, please do so and I will
///   include that information in this documentation.
/// </para>
/// </remarks>
///
/// <seealso cref="ZipEntry.EmitTimesInUnixFormatWhenSaving" />
/// <seealso cref="EmitTimesInWindowsFormatWhenSaving" />
/// <summary>
///   Indicates whether verbose output is sent to the <see
///   cref="StatusMessageTextWriter"/> during <c>AddXxx()</c> and
///   <c>ReadXxx()</c> operations.
/// </summary>
///
/// <remarks>
///   This is a <em>synthetic</em> property.  It returns true if the <see
///   cref="StatusMessageTextWriter"/> is non-null.
/// </remarks>
/// <summary>
///   Returns true if an entry by the given name exists in the ZipFile.
/// </summary>
///
/// <param name='name'>the name of the entry to find</param>
/// <returns>true if an entry with the given name exists; otherwise false.
/// </returns>
// workitem 12534
/// <summary>
///   Indicates whether to perform case-sensitive matching on the filename when
///   retrieving entries in the zipfile via the string-based indexer.
/// </summary>
///
/// <remarks>
///   The default value is <c>false</c>, which means don't do case-sensitive
///   matching. In other words, retrieving zip["ReadMe.Txt"] is the same as
///   zip["readme.txt"].  It really makes sense to set this to <c>true</c> only
///   if you are not running on Windows, which has case-insensitive
///   filenames. But since this library is not built for non-Windows platforms,
///   in most cases you should just leave this property alone.
/// </remarks>
/// <summary>
///   Indicates whether to ignore duplicate files (report only the first entry)
///   when loading a zipfile.
/// </summary>
/// 
/// <remarks>
///   The default value is <c>false</c>, which will try to make all files
///   available (duplicates will have a "copy" suffix appended to their name).
///   Setting this to <c>true</c> prior to using <c>Initialize</c> to read a
///   zipfile will prevent this and instead just ignore the duplicates.
/// </remarks>
/// <summary>
///   Indicates whether to encode entry filenames and entry comments using Unicode
///   (UTF-8).
/// </summary>
///
/// <remarks>
/// <para>
///   <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">The
///   PKWare zip specification</see> provides for encoding file names and file
///   comments in either the IBM437 code page, or in UTF-8.  This flag selects
///   the encoding according to that specification.  By default, this flag is
///   false, and filenames and comments are encoded into the zip file in the
///   IBM437 codepage.  Setting this flag to true will specify that filenames
///   and comments that cannot be encoded with IBM437 will be encoded with
///   UTF-8.
/// </para>
///
/// <para>
///   Zip files created with strict adherence to the PKWare specification with
///   respect to UTF-8 encoding can contain entries with filenames containing
///   any combination of Unicode characters, including the full range of
///   characters from Chinese, Latin, Hebrew, Greek, Cyrillic, and many other
///   alphabets.  However, because at this time, the UTF-8 portion of the PKWare
///   specification is not broadly supported by other zip libraries and
///   utilities, such zip files may not be readable by your favorite zip tool or
///   archiver. In other words, interoperability will decrease if you set this
///   flag to true.
/// </para>
///
/// <para>
///   In particular, Zip files created with strict adherence to the PKWare
///   specification with respect to UTF-8 encoding will not work well with
///   Explorer in Windows XP or Windows Vista, because Windows compressed
///   folders, as far as I know, do not support UTF-8 in zip files.  Vista can
///   read the zip files, but shows the filenames incorrectly. Unpacking from
///   Windows Vista Explorer will result in filenames that have rubbish
///   characters in place of the high-order UTF-8 bytes.
/// </para>
///
/// <para>
///   Also, zip files that use UTF-8 encoding will not work well with Java
///   applications that use the java.util.zip classes, as of v5.0 of the Java
///   runtime. The Java runtime does not correctly implement the PKWare
///   specification in this regard.
/// </para>
///
/// <para>
///   As a result, we have the unfortunate situation that "correct" behavior by
///   the DotNetZip library with regard to Unicode encoding of filenames during
///   zip creation will result in zip files that are readable by strictly
///   compliant and current tools (for example the most recent release of the
///   commercial WinZip tool); but these zip files will not be readable by
///   various other tools or libraries, including Windows Explorer.
/// </para>
///
/// <para>
///   The DotNetZip library can read and write zip files with UTF8-encoded
///   entries, according to the PKware spec.  If you use DotNetZip for both
///   creating and reading the zip file, and you use UTF-8, there will be no
///   loss of information in the filenames. For example, using a self-extractor
///   created by this library will allow you to unpack files correctly with no
///   loss of information in the filenames.
/// </para>
///
/// <para>
///   If you do not set this flag, it will remain false.  If this flag is false,
///   your <c>ZipFile</c> will encode all filenames and comments using the
///   IBM437 codepage.  This can cause "loss of information" on some filenames,
///   but the resulting zipfile will be more interoperable with other
///   utilities. As an example of the loss of information, diacritics can be
///   lost.  The o-tilde character will be down-coded to plain o.  The c with a
///   cedilla (Unicode 0xE7) used in Portugese will be downcoded to a c.
///   Likewise, the O-stroke character (Unicode 248), used in Danish and
///   Norwegian, will be down-coded to plain o. Chinese characters cannot be
///   represented in codepage IBM437; when using the default encoding, Chinese
///   characters in filenames will be represented as ?. These are all examples
///   of "information loss".
/// </para>
///
/// <para>
///   The loss of information associated to the use of the IBM437 encoding is
///   inconvenient, and can also lead to runtime errors. For example, using
///   IBM437, any sequence of 4 Chinese characters will be encoded as ????.  If
///   your application creates a <c>ZipFile</c>, then adds two files, each with
///   names of four Chinese characters each, this will result in a duplicate
///   filename exception.  In the case where you add a single file with a name
///   containing four Chinese characters, calling Extract() on the entry that
///   has question marks in the filename will result in an exception, because
///   the question mark is not legal for use within filenames on Windows.  These
///   are just a few examples of the problems associated to loss of information.
/// </para>
///
/// <para>
///   This flag is independent of the encoding of the content within the entries
///   in the zip file. Think of the zip file as a container - it supports an
///   encoding.  Within the container are other "containers" - the file entries
///   themselves.  The encoding within those entries is independent of the
///   encoding of the zip archive container for those entries.
/// </para>
///
/// <para>
///   Rather than specify the encoding in a binary fashion using this flag, an
///   application can specify an arbitrary encoding via the <see
///   cref="ProvisionalAlternateEncoding"/> property.  Setting the encoding
///   explicitly when creating zip archives will result in non-compliant zip
///   files that, curiously, are fairly interoperable.  The challenge is, the
///   PKWare specification does not provide for a way to specify that an entry
///   in a zip archive uses a code page that is neither IBM437 nor UTF-8.
///   Therefore if you set the encoding explicitly when creating a zip archive,
///   you must take care upon reading the zip archive to use the same code page.
///   If you get it wrong, the behavior is undefined and may result in incorrect
///   filenames, exceptions, stomach upset, hair loss, and acne.
/// </para>
/// </remarks>
/// <seealso cref="ProvisionalAlternateEncoding"/>
/// <summary>
///   Specify whether to use ZIP64 extensions when saving a zip archive.
/// </summary>
///
/// <remarks>
///
/// <para>
///   When creating a zip file, the default value for the property is <see
///   cref="Zip64Option.Never"/>. <see cref="Zip64Option.AsNecessary"/> is
///   safest, in the sense that you will not get an Exception if a pre-ZIP64
///   limit is exceeded.
/// </para>
///
/// <para>
///   You may set the property at any time before calling Save().
/// </para>
///
/// <para>
///   When reading a zip file via the <c>Zipfile.Read()</c> method, DotNetZip
///   will properly read ZIP64-endowed zip archives, regardless of the value of
///   this property.  DotNetZip will always read ZIP64 archives.  This property
///   governs only whether DotNetZip will write them. Therefore, when updating
///   archives, be careful about setting this property after reading an archive
///   that may use ZIP64 extensions.
/// </para>
///
/// <para>
///   An interesting question is, if you have set this property to
///   <c>AsNecessary</c>, and then successfully saved, does the resulting
///   archive use ZIP64 extensions or not?  To learn this, check the <see
///   cref="OutputUsedZip64"/> property, after calling <c>Save()</c>.
/// </para>
///
/// <para>
///   Have you thought about
///   <see href="http://cheeso.members.winisp.net/DotNetZipDonate.aspx">donating</see>?
/// </para>
///
/// </remarks>
/// <seealso cref="RequiresZip64"/>
/// <summary>
///   Indicates whether the archive requires ZIP64 extensions.
/// </summary>
///
/// <remarks>
///
/// <para>
///   This property is <c>null</c> (or <c>Nothing</c> in VB) if the archive has
///   not been saved, and there are fewer than 65334 <c>ZipEntry</c> items
///   contained in the archive.
/// </para>
///
/// <para>
///   The <c>Value</c> is true if any of the following four conditions holds:
///   the uncompressed size of any entry is larger than 0xFFFFFFFF; the
///   compressed size of any entry is larger than 0xFFFFFFFF; the relative
///   offset of any entry within the zip archive is larger than 0xFFFFFFFF; or
///   there are more than 65534 entries in the archive.  (0xFFFFFFFF =
///   4,294,967,295).  The result may not be known until a <c>Save()</c> is attempted
///   on the zip archive.  The Value of this <see cref="System.Nullable"/>
///   property may be set only AFTER one of the Save() methods has been called.
/// </para>
///
/// <para>
///   If none of the four conditions holds, and the archive has been saved, then
///   the <c>Value</c> is false.
/// </para>
///
/// <para>
///   A <c>Value</c> of false does not indicate that the zip archive, as saved,
///   does not use ZIP64.  It merely indicates that ZIP64 is not required.  An
///   archive may use ZIP64 even when not required if the <see
///   cref="ZipFile.UseZip64WhenSaving"/> property is set to <see
///   cref="Zip64Option.Always"/>, or if the <see
///   cref="ZipFile.UseZip64WhenSaving"/> property is set to <see
///   cref="Zip64Option.AsNecessary"/> and the output stream was not
///   seekable. Use the <see cref="OutputUsedZip64"/> property to determine if
///   the most recent <c>Save()</c> method resulted in an archive that utilized
///   the ZIP64 extensions.
/// </para>
///
/// </remarks>
/// <seealso cref="UseZip64WhenSaving"/>
/// <seealso cref="OutputUsedZip64"/>
// If the <c>ZipFile</c> has not been saved or if the contents have changed, then
// it is not known if ZIP64 is required.
// Whether ZIP64 is required is knowable.
/// <summary>
///   Indicates whether the most recent <c>Save()</c> operation used ZIP64 extensions.
/// </summary>
///
/// <remarks>
/// <para>
///   The use of ZIP64 extensions within an archive is not always necessary, and
///   for interoperability concerns, it may be desired to NOT use ZIP64 if
///   possible.  The <see cref="ZipFile.UseZip64WhenSaving"/> property can be
///   set to use ZIP64 extensions only when necessary.  In those cases,
///   Sometimes applications want to know whether a Save() actually used ZIP64
///   extensions.  Applications can query this read-only property to learn
///   whether ZIP64 has been used in a just-saved <c>ZipFile</c>.
/// </para>
///
/// <para>
///   The value is <c>null</c> (or <c>Nothing</c> in VB) if the archive has not
///   been saved.
/// </para>
///
/// <para>
///   Non-null values (<c>HasValue</c> is true) indicate whether ZIP64
///   extensions were used during the most recent <c>Save()</c> operation.  The
///   ZIP64 extensions may have been used as required by any particular entry
///   because of its uncompressed or compressed size, or because the archive is
///   larger than 4294967295 bytes, or because there are more than 65534 entries
///   in the archive, or because the <c>UseZip64WhenSaving</c> property was set
///   to <see cref="Zip64Option.Always"/>, or because the
///   <c>UseZip64WhenSaving</c> property was set to <see
///   cref="Zip64Option.AsNecessary"/> and the output stream was not seekable.
///   The value of this property does not indicate the reason the ZIP64
///   extensions were used.
/// </para>
///
/// </remarks>
/// <seealso cref="UseZip64WhenSaving"/>
/// <seealso cref="RequiresZip64"/>
/// <summary>
///   Indicates whether the most recent <c>Read()</c> operation read a zip file that uses
///   ZIP64 extensions.
/// </summary>
///
/// <remarks>
///   This property will return null (Nothing in VB) if you've added an entry after reading
///   the zip file.
/// </remarks>
// if any entry was added after reading the zip file, then the result is null
// if any entry read from the zip used zip64, then the result is true
/// <summary>
///   The text encoding to use when writing new entries to the <c>ZipFile</c>,
///   for those entries that cannot be encoded with the default (IBM437)
///   encoding; or, the text encoding that was used when reading the entries
///   from the <c>ZipFile</c>.
/// </summary>
///
/// <remarks>
/// <para>
///   In <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">its
///   zip specification</see>, PKWare describes two options for encoding
///   filenames and comments: using IBM437 or UTF-8.  But, some archiving tools
///   or libraries do not follow the specification, and instead encode
///   characters using the system default code page.  For example, WinRAR when
///   run on a machine in Shanghai may encode filenames with the Big-5 Chinese
///   (950) code page.  This behavior is contrary to the Zip specification, but
///   it occurs anyway.
/// </para>
///
/// <para>
///   When using DotNetZip to write zip archives that will be read by one of
///   these other archivers, set this property to specify the code page to use
///   when encoding the <see cref="ZipEntry.FileName"/> and <see
///   cref="ZipEntry.Comment"/> for each <c>ZipEntry</c> in the zip file, for
///   values that cannot be encoded with the default codepage for zip files,
///   IBM437.  This is why this property is "provisional".  In all cases, IBM437
///   is used where possible, in other words, where no loss of data would
///   result. It is possible, therefore, to have a given entry with a
///   <c>Comment</c> encoded in IBM437 and a <c>FileName</c> encoded with the
///   specified "provisional" codepage.
/// </para>
///
/// <para>
///   Be aware that a zip file created after you've explicitly set the <see
///   cref="ProvisionalAlternateEncoding" /> property to a value other than
///   IBM437 may not be compliant to the PKWare specification, and may not be
///   readable by compliant archivers.  On the other hand, many (most?)
///   archivers are non-compliant and can read zip files created in arbitrary
///   code pages.  The trick is to use or specify the proper codepage when
///   reading the zip.
/// </para>
///
/// <para>
///   When creating a zip archive using this library, it is possible to change
///   the value of <see cref="ProvisionalAlternateEncoding" /> between each
///   entry you add, and between adding entries and the call to
///   <c>Save()</c>. Don't do this. It will likely result in a zipfile that is
///   not readable.  For best interoperability, either leave <see
///   cref="ProvisionalAlternateEncoding" /> alone, or specify it only once,
///   before adding any entries to the <c>ZipFile</c> instance.  There is one
///   exception to this recommendation, described later.
/// </para>
///
/// <para>
///   When using an arbitrary, non-UTF8 code page for encoding, there is no
///   standard way for the creator application - whether DotNetZip, WinZip,
///   WinRar, or something else - to formally specify in the zip file which
///   codepage has been used for the entries. As a result, readers of zip files
///   are not able to inspect the zip file and determine the codepage that was
///   used for the entries contained within it.  It is left to the application
///   or user to determine the necessary codepage when reading zip files encoded
///   this way.  In other words, if you explicitly specify the codepage when you
///   create the zipfile, you must explicitly specify the same codepage when
///   reading the zipfile.
/// </para>
///
/// <para>
///   The way you specify the code page to use when reading a zip file varies
///   depending on the tool or library you use to read the zip.  In DotNetZip,
///   you use a ZipFile.Read() method that accepts an encoding parameter.  It
///   isn't possible with Windows Explorer, as far as I know, to specify an
///   explicit codepage to use when reading a zip.  If you use an incorrect
///   codepage when reading a zipfile, you will get entries with filenames that
///   are incorrect, and the incorrect filenames may even contain characters
///   that are not legal for use within filenames in Windows. Extracting entries
///   with illegal characters in the filenames will lead to exceptions. It's too
///   bad, but this is just the way things are with code pages in zip
///   files. Caveat Emptor.
/// </para>
///
/// <para>
///   Example: Suppose you create a zipfile that contains entries with
///   filenames that have Danish characters.  If you use <see
///   cref="ProvisionalAlternateEncoding" /> equal to "iso-8859-1" (cp 28591),
///   the filenames will be correctly encoded in the zip.  But, to read that
///   zipfile correctly, you have to specify the same codepage at the time you
///   read it. If try to read that zip file with Windows Explorer or another
///   application that is not flexible with respect to the codepage used to
///   decode filenames in zipfiles, you will get a filename like "Inf�.txt".
/// </para>
///
/// <para>
///   When using DotNetZip to read a zip archive, and the zip archive uses an
///   arbitrary code page, you must specify the encoding to use before or when
///   the <c>Zipfile</c> is READ.  This means you must use a <c>ZipFile.Read()</c>
///   method that allows you to specify a System.Text.Encoding parameter.  Setting
///   the ProvisionalAlternateEncoding property after your application has read in
///   the zip archive will not affect the entry names of entries that have already
///   been read in.
/// </para>
///
/// <para>
///   And now, the exception to the rule described above.  One strategy for
///   specifying the code page for a given zip file is to describe the code page
///   in a human-readable form in the Zip comment. For example, the comment may
///   read "Entries in this archive are encoded in the Big5 code page".  For
///   maximum interoperability, the zip comment in this case should be encoded
///   in the default, IBM437 code page.  In this case, the zip comment is
///   encoded using a different page than the filenames.  To do this, Specify
///   <c>ProvisionalAlternateEncoding</c> to your desired region-specific code
///   page, once before adding any entries, and then reset
///   <c>ProvisionalAlternateEncoding</c> to IBM437 before setting the <see
///   cref="Comment"/> property and calling Save().
/// </para>
/// </remarks>
///
/// <example>
/// This example shows how to read a zip file using the Big-5 Chinese code page
/// (950), and extract each entry in the zip file.  For this code to work as
/// desired, the <c>Zipfile</c> must have been created using the big5 code page
/// (CP950). This is typical, for example, when using WinRar on a machine with
/// CP950 set as the default code page.  In that case, the names of entries
/// within the Zip archive will be stored in that code page, and reading the zip
/// archive must be done using that code page.  If the application did not use
/// the correct code page in <c>ZipFile.Read()</c>, then names of entries within the
/// zip archive would not be correctly retrieved.
/// <code>
/// using (var zip = ZipFile.Read(zipFileName, System.Text.Encoding.GetEncoding("big5")))
/// {
///     // retrieve and extract an entry using a name encoded with CP950
///     zip[MyDesiredEntry].Extract("unpack");
/// }
/// </code>
///
/// <code lang="VB">
/// Using zip As ZipFile = ZipFile.Read(ZipToExtract, System.Text.Encoding.GetEncoding("big5"))
///     ' retrieve and extract an entry using a name encoded with CP950
///     zip(MyDesiredEntry).Extract("unpack")
/// End Using
/// </code>
/// </example>
///
/// <seealso cref="Ionic.Zip.ZipFile.DefaultEncoding">DefaultEncoding</seealso>
/// <summary>
///   A Text Encoding to use when encoding the filenames and comments for
///   all the ZipEntry items, during a ZipFile.Save() operation.
/// </summary>
/// <remarks>
///   <para>
///     Whether the encoding specified here is used during the save depends
///     on <see cref="AlternateEncodingUsage"/>.
///   </para>
/// </remarks>
/// <summary>
///   A flag that tells if and when this instance should apply
///   AlternateEncoding to encode the filenames and comments associated to
///   of ZipEntry objects contained within this instance.
/// </summary>
/// <summary>
/// Gets or sets the <c>TextWriter</c> to which status messages are delivered
/// for the instance.
/// </summary>
///
/// <remarks>
///   If the TextWriter is set to a non-null value, then verbose output is sent
///   to the <c>TextWriter</c> during <c>Add</c><c>, Read</c><c>, Save</c> and
///   <c>Extract</c> operations.  Typically, console applications might use
///   <c>Console.Out</c> and graphical or headless applications might use a
///   <c>System.IO.StringWriter</c>. The output of this is suitable for viewing
///   by humans.
/// </remarks>
///
/// <example>
/// <para>
///   In this example, a console application instantiates a <c>ZipFile</c>, then
///   sets the <c>StatusMessageTextWriter</c> to <c>Console.Out</c>.  At that
///   point, all verbose status messages for that <c>ZipFile</c> are sent to the
///   console.
/// </para>
///
/// <code lang="C#">
/// using (ZipFile zip= ZipFile.Read(FilePath))
/// {
///   zip.StatusMessageTextWriter= System.Console.Out;
///   // messages are sent to the console during extraction
///   zip.ExtractAll();
/// }
/// </code>
///
/// <code lang="VB">
/// Using zip As ZipFile = ZipFile.Read(FilePath)
///   zip.StatusMessageTextWriter= System.Console.Out
///   'Status Messages will be sent to the console during extraction
///   zip.ExtractAll()
/// End Using
/// </code>
///
/// <para>
///   In this example, a Windows Forms application instantiates a
///   <c>ZipFile</c>, then sets the <c>StatusMessageTextWriter</c> to a
///   <c>StringWriter</c>.  At that point, all verbose status messages for that
///   <c>ZipFile</c> are sent to the <c>StringWriter</c>.
/// </para>
///
/// <code lang="C#">
/// var sw = new System.IO.StringWriter();
/// using (ZipFile zip= ZipFile.Read(FilePath))
/// {
///   zip.StatusMessageTextWriter= sw;
///   zip.ExtractAll();
/// }
/// Console.WriteLine("{0}", sw.ToString());
/// </code>
///
/// <code lang="VB">
/// Dim sw as New System.IO.StringWriter
/// Using zip As ZipFile = ZipFile.Read(FilePath)
///   zip.StatusMessageTextWriter= sw
///   zip.ExtractAll()
/// End Using
/// 'Status Messages are now available in sw
///
/// </code>
/// </example>
/// <summary>
///   Gets or sets the name for the folder to store the temporary file
///   this library writes when saving a zip archive.
/// </summary>
///
/// <remarks>
/// <para>
///   This library will create a temporary file when saving a Zip archive to a
///   file.  This file is written when calling one of the <c>Save()</c> methods
///   that does not save to a stream, or one of the <c>SaveSelfExtractor()</c>
///   methods.
/// </para>
///
/// <para>
///   By default, the library will create the temporary file in the directory
///   specified for the file itself, via the <see cref="Name"/> property or via
///   the <see cref="ZipFile.Save(String)"/> method.
/// </para>
///
/// <para>
///   Setting this property allows applications to override this default
///   behavior, so that the library will create the temporary file in the
///   specified folder. For example, to have the library create the temporary
///   file in the current working directory, regardless where the <c>ZipFile</c>
///   is saved, specfy ".".  To revert to the default behavior, set this
///   property to <c>null</c> (<c>Nothing</c> in VB).
/// </para>
///
/// <para>
///   When setting the property to a non-null value, the folder specified must
///   exist; if it does not an exception is thrown.  The application should have
///   write and delete permissions on the folder.  The permissions are not
///   explicitly checked ahead of time; if the application does not have the
///   appropriate rights, an exception will be thrown at the time <c>Save()</c>
///   is called.
/// </para>
///
/// <para>
///   There is no temporary file created when reading a zip archive.  When
///   saving to a Stream, there is no temporary file created.  For example, if
///   the application is an ASP.NET application and calls <c>Save()</c>
///   specifying the <c>Response.OutputStream</c> as the output stream, there is
///   no temporary file created.
/// </para>
/// </remarks>
///
/// <exception cref="System.IO.FileNotFoundException">
/// Thrown when setting the property if the directory does not exist.
/// </exception>
///
/// <summary>
/// Sets the password to be used on the <c>ZipFile</c> instance.
/// </summary>
///
/// <remarks>
///
/// <para>
///   When writing a zip archive, this password is applied to the entries, not
///   to the zip archive itself. It applies to any <c>ZipEntry</c> subsequently
///   added to the <c>ZipFile</c>, using one of the <c>AddFile</c>,
///   <c>AddDirectory</c>, <c>AddEntry</c>, or <c>AddItem</c> methods, etc.
///   When reading a zip archive, this property applies to any entry
///   subsequently extracted from the <c>ZipFile</c> using one of the Extract
///   methods on the <c>ZipFile</c> class.
/// </para>
///
/// <para>
///   When writing a zip archive, keep this in mind: though the password is set
///   on the ZipFile object, according to the Zip spec, the "directory" of the
///   archive - in other words the list of entries or files contained in the archive - is
///   not encrypted with the password, or protected in any way.  If you set the
///   Password property, the password actually applies to individual entries
///   that are added to the archive, subsequent to the setting of this property.
///   The list of filenames in the archive that is eventually created will
///   appear in clear text, but the contents of the individual files are
///   encrypted.  This is how Zip encryption works.
/// </para>
///
/// <para>
///   One simple way around this limitation is to simply double-wrap sensitive
///   filenames: Store the files in a zip file, and then store that zip file
///   within a second, "outer" zip file.  If you apply a password to the outer
///   zip file, then readers will be able to see that the outer zip file
///   contains an inner zip file.  But readers will not be able to read the
///   directory or file list of the inner zip file.
/// </para>
///
/// <para>
///   If you set the password on the <c>ZipFile</c>, and then add a set of files
///   to the archive, then each entry is encrypted with that password.  You may
///   also want to change the password between adding different entries. If you
///   set the password, add an entry, then set the password to <c>null</c>
///   (<c>Nothing</c> in VB), and add another entry, the first entry is
///   encrypted and the second is not.  If you call <c>AddFile()</c>, then set
///   the <c>Password</c> property, then call <c>ZipFile.Save</c>, the file
///   added will not be password-protected, and no warning will be generated.
/// </para>
///
/// <para>
///   When setting the Password, you may also want to explicitly set the <see
///   cref="Encryption"/> property, to specify how to encrypt the entries added
///   to the ZipFile.  If you set the Password to a non-null value and do not
///   set <see cref="Encryption"/>, then PKZip 2.0 ("Weak") encryption is used.
///   This encryption is relatively weak but is very interoperable. If you set
///   the password to a <c>null</c> value (<c>Nothing</c> in VB), Encryption is
///   reset to None.
/// </para>
///
/// <para>
///   All of the preceding applies to writing zip archives, in other words when
///   you use one of the Save methods.  To use this property when reading or an
///   existing ZipFile, do the following: set the Password property on the
///   <c>ZipFile</c>, then call one of the Extract() overloads on the <see
///   cref="ZipEntry" />. In this case, the entry is extracted using the
///   <c>Password</c> that is specified on the <c>ZipFile</c> instance. If you
///   have not set the <c>Password</c> property, then the password is
///   <c>null</c>, and the entry is extracted with no password.
/// </para>
///
/// <para>
///   If you set the Password property on the <c>ZipFile</c>, then call
///   <c>Extract()</c> an entry that has not been encrypted with a password, the
///   password is not used for that entry, and the <c>ZipEntry</c> is extracted
///   as normal. In other words, the password is used only if necessary.
/// </para>
///
/// <para>
///   The <see cref="ZipEntry"/> class also has a <see
///   cref="ZipEntry.Password">Password</see> property.  It takes precedence
///   over this property on the <c>ZipFile</c>.  Typically, you would use the
///   per-entry Password when most entries in the zip archive use one password,
///   and a few entries use a different password.  If all entries in the zip
///   file use the same password, then it is simpler to just set this property
///   on the <c>ZipFile</c> itself, whether creating a zip archive or extracting
///   a zip archive.
/// </para>
///
/// </remarks>
///
/// <example>
/// <para>
///   This example creates a zip file, using password protection for the
///   entries, and then extracts the entries from the zip file.  When creating
///   the zip file, the Readme.txt file is not protected with a password, but
///   the other two are password-protected as they are saved. During extraction,
///   each file is extracted with the appropriate password.
/// </para>
/// <code>
/// // create a file with encryption
/// using (ZipFile zip = new ZipFile())
/// {
///     zip.AddFile("ReadMe.txt");
///     zip.Password= "!Secret1";
///     zip.AddFile("MapToTheSite-7440-N49th.png");
///     zip.AddFile("2008-Regional-Sales-Report.pdf");
///     zip.Save("EncryptedArchive.zip");
/// }
///
/// // extract entries that use encryption
/// using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
/// {
///     zip.Password= "!Secret1";
///     zip.ExtractAll("extractDir");
/// }
///
/// </code>
///
/// <code lang="VB">
/// Using zip As New ZipFile
///     zip.AddFile("ReadMe.txt")
///     zip.Password = "123456!"
///     zip.AddFile("MapToTheSite-7440-N49th.png")
///     zip.Password= "!Secret1";
///     zip.AddFile("2008-Regional-Sales-Report.pdf")
///     zip.Save("EncryptedArchive.zip")
/// End Using
///
///
/// ' extract entries that use encryption
/// Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
///     zip.Password= "!Secret1"
///     zip.ExtractAll("extractDir")
/// End Using
///
/// </code>
///
/// </example>
///
/// <seealso cref="Ionic.Zip.ZipFile.Encryption">ZipFile.Encryption</seealso>
/// <seealso cref="Ionic.Zip.ZipEntry.Password">ZipEntry.Password</seealso>
/// <summary>
///   The action the library should take when extracting a file that already
///   exists.
/// </summary>
///
/// <remarks>
/// <para>
///   This property affects the behavior of the Extract methods (one of the
///   <c>Extract()</c> or <c>ExtractWithPassword()</c> overloads), when
///   extraction would would overwrite an existing filesystem file. If you do
///   not set this property, the library throws an exception when extracting an
///   entry would overwrite an existing file.
/// </para>
///
/// <para>
///   This property has no effect when extracting to a stream, or when the file
///   to be extracted does not already exist.
/// </para>
/// </remarks>
/// <seealso cref="Ionic.Zip.ZipEntry.ExtractExistingFile"/>
/// <summary>
///   The action the library should take when an error is encountered while
///   opening or reading files as they are saved into a zip archive.
/// </summary>
///
/// <remarks>
///  <para>
///    Errors can occur as a file is being saved to the zip archive.  For
///    example, the File.Open may fail, or a File.Read may fail, because of
///    lock conflicts or other reasons.
///  </para>
///
///  <para>
///    The first problem might occur after having called AddDirectory() on a
///    directory that contains a Clipper .dbf file; the file is locked by
///    Clipper and cannot be opened for read by another process. An example of
///    the second problem might occur when trying to zip a .pst file that is in
///    use by Microsoft Outlook. Outlook locks a range on the file, which allows
///    other processes to open the file, but not read it in its entirety.
///  </para>
///
///  <para>
///    This property tells DotNetZip what you would like to do in the case of
///    these errors.  The primary options are: <c>ZipErrorAction.Throw</c> to
///    throw an exception (this is the default behavior if you don't set this
///    property); <c>ZipErrorAction.Skip</c> to Skip the file for which there
///    was an error and continue saving; <c>ZipErrorAction.Retry</c> to Retry
///    the entry that caused the problem; or
///    <c>ZipErrorAction.InvokeErrorEvent</c> to invoke an event handler.
///  </para>
///
///  <para>
///    This property is implicitly set to <c>ZipErrorAction.InvokeErrorEvent</c>
///    if you add a handler to the <see cref="ZipError" /> event.  If you set
///    this property to something other than
///    <c>ZipErrorAction.InvokeErrorEvent</c>, then the <c>ZipError</c>
///    event is implicitly cleared.  What it means is you can set one or the
///    other (or neither), depending on what you want, but you never need to set
///    both.
///  </para>
///
///  <para>
///    As with some other properties on the <c>ZipFile</c> class, like <see
///    cref="Password"/>, <see cref="Encryption"/>, and <see
///    cref="CompressionLevel"/>, setting this property on a <c>ZipFile</c>
///    instance will cause the specified <c>ZipErrorAction</c> to be used on all
///    <see cref="ZipEntry"/> items that are subsequently added to the
///    <c>ZipFile</c> instance. If you set this property after you have added
///    items to the <c>ZipFile</c>, but before you have called <c>Save()</c>,
///    those items will not use the specified error handling action.
///  </para>
///
///  <para>
///    If you want to handle any errors that occur with any entry in the zip
///    file in the same way, then set this property once, before adding any
///    entries to the zip archive.
///  </para>
///
///  <para>
///    If you set this property to <c>ZipErrorAction.Skip</c> and you'd like to
///    learn which files may have been skipped after a <c>Save()</c>, you can
///    set the <see cref="StatusMessageTextWriter" /> on the ZipFile before
///    calling <c>Save()</c>. A message will be emitted into that writer for
///    each skipped file, if any.
///  </para>
///
/// </remarks>
///
/// <example>
///   This example shows how to tell DotNetZip to skip any files for which an
///   error is generated during the Save().
/// <code lang="VB">
/// Public Sub SaveZipFile()
///     Dim SourceFolder As String = "fodder"
///     Dim DestFile As String =  "eHandler.zip"
///     Dim sw as New StringWriter
///     Using zipArchive As ZipFile = New ZipFile
///         ' Tell DotNetZip to skip any files for which it encounters an error
///         zipArchive.ZipErrorAction = ZipErrorAction.Skip
///         zipArchive.StatusMessageTextWriter = sw
///         zipArchive.AddDirectory(SourceFolder)
///         zipArchive.Save(DestFile)
///     End Using
///     ' examine sw here to see any messages
/// End Sub
///
/// </code>
/// </example>
///
/// <seealso cref="Ionic.Zip.ZipEntry.ZipErrorAction"/>
/// <seealso cref="Ionic.Zip.ZipFile.ZipError"/>
/// <summary>
///   The Encryption to use for entries added to the <c>ZipFile</c>.
/// </summary>
///
/// <remarks>
/// <para>
///   Set this when creating a zip archive, or when updating a zip archive. The
///   specified Encryption is applied to the entries subsequently added to the
///   <c>ZipFile</c> instance.  Applications do not need to set the
///   <c>Encryption</c> property when reading or extracting a zip archive.
/// </para>
///
/// <para>
///   If you set this to something other than EncryptionAlgorithm.None, you
///   will also need to set the <see cref="Password"/>.
/// </para>
///
/// <para>
///   As with some other properties on the <c>ZipFile</c> class, like <see
///   cref="Password"/> and <see cref="CompressionLevel"/>, setting this
///   property on a <c>ZipFile</c> instance will cause the specified
///   <c>EncryptionAlgorithm</c> to be used on all <see cref="ZipEntry"/> items
///   that are subsequently added to the <c>ZipFile</c> instance. In other
///   words, if you set this property after you have added items to the
///   <c>ZipFile</c>, but before you have called <c>Save()</c>, those items will
///   not be encrypted or protected with a password in the resulting zip
///   archive. To get a zip archive with encrypted entries, set this property,
///   along with the <see cref="Password"/> property, before calling
///   <c>AddFile</c>, <c>AddItem</c>, or <c>AddDirectory</c> (etc.) on the
///   <c>ZipFile</c> instance.
/// </para>
///
/// <para>
///   If you read a <c>ZipFile</c>, you can modify the <c>Encryption</c> on an
///   encrypted entry, only by setting the <c>Encryption</c> property on the
///   <c>ZipEntry</c> itself.  Setting the <c>Encryption</c> property on the
///   <c>ZipFile</c>, once it has been created via a call to
///   <c>ZipFile.Read()</c>, does not affect entries that were previously read.
/// </para>
///
/// <para>
///   For example, suppose you read a <c>ZipFile</c>, and there is an encrypted
///   entry.  Setting the <c>Encryption</c> property on that <c>ZipFile</c> and
///   then calling <c>Save()</c> on the <c>ZipFile</c> does not update the
///   <c>Encryption</c> used for the entries in the archive.  Neither is an
///   exception thrown. Instead, what happens during the <c>Save()</c> is that
///   all previously existing entries are copied through to the new zip archive,
///   with whatever encryption and password that was used when originally
///   creating the zip archive. Upon re-reading that archive, to extract
///   entries, applications should use the original password or passwords, if
///   any.
/// </para>
///
/// <para>
///   Suppose an application reads a <c>ZipFile</c>, and there is an encrypted
///   entry.  Setting the <c>Encryption</c> property on that <c>ZipFile</c> and
///   then adding new entries (via <c>AddFile()</c>, <c>AddEntry()</c>, etc)
///   and then calling <c>Save()</c> on the <c>ZipFile</c> does not update the
///   <c>Encryption</c> on any of the entries that had previously been in the
///   <c>ZipFile</c>.  The <c>Encryption</c> property applies only to the
///   newly-added entries.
/// </para>
///
/// </remarks>
///
/// <example>
/// <para>
///   This example creates a zip archive that uses encryption, and then extracts
///   entries from the archive.  When creating the zip archive, the ReadMe.txt
///   file is zipped without using a password or encryption.  The other files
///   use encryption.
/// </para>
///
/// <code>
/// // Create a zip archive with AES Encryption.
/// using (ZipFile zip = new ZipFile())
/// {
///     zip.AddFile("ReadMe.txt");
///     zip.Encryption= EncryptionAlgorithm.WinZipAes256;
///     zip.Password= "Top.Secret.No.Peeking!";
///     zip.AddFile("7440-N49th.png");
///     zip.AddFile("2008-Regional-Sales-Report.pdf");
///     zip.Save("EncryptedArchive.zip");
/// }
///
/// // Extract a zip archive that uses AES Encryption.
/// // You do not need to specify the algorithm during extraction.
/// using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
/// {
///     zip.Password= "Top.Secret.No.Peeking!";
///     zip.ExtractAll("extractDirectory");
/// }
/// </code>
///
/// <code lang="VB">
/// ' Create a zip that uses Encryption.
/// Using zip As New ZipFile()
///     zip.Encryption= EncryptionAlgorithm.WinZipAes256
///     zip.Password= "Top.Secret.No.Peeking!"
///     zip.AddFile("ReadMe.txt")
///     zip.AddFile("7440-N49th.png")
///     zip.AddFile("2008-Regional-Sales-Report.pdf")
///     zip.Save("EncryptedArchive.zip")
/// End Using
///
/// ' Extract a zip archive that uses AES Encryption.
/// ' You do not need to specify the algorithm during extraction.
/// Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
///     zip.Password= "Top.Secret.No.Peeking!"
///     zip.ExtractAll("extractDirectory")
/// End Using
/// </code>
///
/// </example>
///
/// <seealso cref="Ionic.Zip.ZipFile.Password">ZipFile.Password</seealso>
/// <seealso cref="Ionic.Zip.ZipEntry.Encryption">ZipEntry.Encryption</seealso>
/// <summary>
///   A callback that allows the application to specify the compression level
///   to use for entries subsequently added to the zip archive.
/// </summary>
///
/// <remarks>
///
/// <para>
///   With this callback, the DotNetZip library allows the application to
///   determine whether compression will be used, at the time of the
///   <c>Save</c>. This may be useful if the application wants to favor
///   speed over size, and wants to defer the decision until the time of
///   <c>Save</c>.
/// </para>
///
/// <para>
///   Typically applications set the <see cref="CompressionLevel"/> property on
///   the <c>ZipFile</c> or on each <c>ZipEntry</c> to determine the level of
///   compression used. This is done at the time the entry is added to the
///   <c>ZipFile</c>. Setting the property to
///   <c>Ionic.Zlib.CompressionLevel.None</c> means no compression will be used.
/// </para>
///
/// <para>
///   This callback allows the application to defer the decision on the
///   <c>CompressionLevel</c> to use, until the time of the call to
///   <c>ZipFile.Save()</c>. The callback is invoked once per <c>ZipEntry</c>,
///   at the time the data for the entry is being written out as part of a
///   <c>Save()</c> operation. The application can use whatever criteria it
///   likes in determining the level to return.  For example, an application may
///   wish that no .mp3 files should be compressed, because they are already
///   compressed and the extra compression is not worth the CPU time incurred,
///   and so can return <c>None</c> for all .mp3 entries.
/// </para>
///
/// <para>
///   The library determines whether compression will be attempted for an entry
///   this way: If the entry is a zero length file, or a directory, no
///   compression is used.  Otherwise, if this callback is set, it is invoked
///   and the <c>CompressionLevel</c> is set to the return value. If this
///   callback has not been set, then the previously set value for
///   <c>CompressionLevel</c> is used.
/// </para>
///
/// </remarks>
/// <summary>
/// The maximum size of an output segment, when saving a split Zip file.
/// </summary>
/// <remarks>
///   <para>
///     Make sure you do not read from this field if you've set the value using <see cref="MaxOutputSegmentSize64"/>
///   </para>
///   
///   <para>
///     Set this to a non-zero value before calling <see cref="Save()"/> or <see
///     cref="Save(String)"/> to specify that the ZipFile should be saved as a
///     split archive, also sometimes called a spanned archive. Some also
///     call them multi-file archives.
///   </para>
///
///   <para>
///     A split zip archive is saved in a set of discrete filesystem files,
///     rather than in a single file. This is handy when transmitting the
///     archive in email or some other mechanism that has a limit to the size of
///     each file.  The first file in a split archive will be named
///     <c>basename.z01</c>, the second will be named <c>basename.z02</c>, and
///     so on. The final file is named <c>basename.zip</c>. According to the zip
///     specification from PKWare, the minimum value is 65536, for a 64k segment
///     size. The maximum number of segments allows in a split archive is 99.
///   </para>
///
///   <para>
///     The value of this property determines the maximum size of a split
///     segment when writing a split archive.  For example, suppose you have a
///     <c>ZipFile</c> that would save to a single file of 200k. If you set the
///     <c>MaxOutputSegmentSize</c> to 65536 before calling <c>Save()</c>, you
///     will get four distinct output files. On the other hand if you set this
///     property to 256k, then you will get a single-file archive for that
///     <c>ZipFile</c>.
///   </para>
///
///   <para>
///     The size of each split output file will be as large as possible, up to
///     the maximum size set here. The zip specification requires that some data
///     fields in a zip archive may not span a split boundary, and an output
///     segment may be smaller than the maximum if necessary to avoid that
///     problem. Also, obviously the final segment of the archive may be smaller
///     than the maximum segment size. Segments will never be larger than the
///     value set with this property.
///   </para>
///
///   <para>
///     You can save a split Zip file only when saving to a regular filesystem
///     file. It's not possible to save a split zip file as a self-extracting
///     archive, nor is it possible to save a split zip file to a stream. When
///     saving to a SFX or to a Stream, this property is ignored.
///   </para>
///
///   <para>
///     About interoperability: Split or spanned zip files produced by DotNetZip
///     can be read by WinZip or PKZip, and vice-versa. Segmented zip files may
///     not be readable by other tools, if those other tools don't support zip
///     spanning or splitting.  When in doubt, test.  I don't believe Windows
///     Explorer can extract a split archive.
///   </para>
///
///   <para>
///     This property has no effect when reading a split archive. You can read
///     a split archive in the normal way with DotNetZip.
///   </para>
///
///   <para>
///     When saving a zip file, if you want a regular zip file rather than a
///     split zip file, don't set this property, or set it to Zero.
///   </para>
///
///   <para>
///     If you read a split archive, with <see cref="ZipFile.Read(string)"/> and
///     then subsequently call <c>ZipFile.Save()</c>, unless you set this
///     property before calling <c>Save()</c>, you will get a normal,
///     single-file archive.
///   </para>
/// </remarks>
///
/// <seealso cref="NumberOfSegmentsForMostRecentSave"/>
/// <summary>
/// The maximum size of an output segment, when saving a split Zip file.
/// </summary>
/// <remarks>
///   <para>
///     If you set this value, make sure you do not accidently use <see cref="MaxOutputSegmentSize"/> in your code
///   </para>
///   
///   <para>
///     Set this to a non-zero value before calling <see cref="Save()"/> or <see
///     cref="Save(String)"/> to specify that the ZipFile should be saved as a
///     split archive, also sometimes called a spanned archive. Some also
///     call them multi-file archives.
///   </para>
///
///   <para>
///     A split zip archive is saved in a set of discrete filesystem files,
///     rather than in a single file. This is handy when transmitting the
///     archive in email or some other mechanism that has a limit to the size of
///     each file.  The first file in a split archive will be named
///     <c>basename.z01</c>, the second will be named <c>basename.z02</c>, and
///     so on. The final file is named <c>basename.zip</c>. According to the zip
///     specification from PKWare, the minimum value is 65536, for a 64k segment
///     size. The maximum number of segments allows in a split archive is 99.
///   </para>
///
///   <para>
///     The value of this property determines the maximum size of a split
///     segment when writing a split archive.  For example, suppose you have a
///     <c>ZipFile</c> that would save to a single file of 200k. If you set the
///     <c>MaxOutputSegmentSize</c> to 65536 before calling <c>Save()</c>, you
///     will get four distinct output files. On the other hand if you set this
///     property to 256k, then you will get a single-file archive for that
///     <c>ZipFile</c>.
///   </para>
///
///   <para>
///     The size of each split output file will be as large as possible, up to
///     the maximum size set here. The zip specification requires that some data
///     fields in a zip archive may not span a split boundary, and an output
///     segment may be smaller than the maximum if necessary to avoid that
///     problem. Also, obviously the final segment of the archive may be smaller
///     than the maximum segment size. Segments will never be larger than the
///     value set with this property.
///   </para>
///
///   <para>
///     You can save a split Zip file only when saving to a regular filesystem
///     file. It's not possible to save a split zip file as a self-extracting
///     archive, nor is it possible to save a split zip file to a stream. When
///     saving to a SFX or to a Stream, this property is ignored.
///   </para>
///
///   <para>
///     About interoperability: Split or spanned zip files produced by DotNetZip
///     can be read by WinZip or PKZip, and vice-versa. Segmented zip files may
///     not be readable by other tools, if those other tools don't support zip
///     spanning or splitting.  When in doubt, test.  I don't believe Windows
///     Explorer can extract a split archive.
///   </para>
///
///   <para>
///     This property has no effect when reading a split archive. You can read
///     a split archive in the normal way with DotNetZip.
///   </para>
///
///   <para>
///     When saving a zip file, if you want a regular zip file rather than a
///     split zip file, don't set this property, or set it to Zero.
///   </para>
///
///   <para>
///     If you read a split archive, with <see cref="ZipFile.Read(string)"/> and
///     then subsequently call <c>ZipFile.Save()</c>, unless you set this
///     property before calling <c>Save()</c>, you will get a normal,
///     single-file archive.
///   </para>
/// </remarks>
///
/// <seealso cref="NumberOfSegmentsForMostRecentSave"/>
/// <summary>
///   Returns the number of segments used in the most recent Save() operation.
/// </summary>
/// <remarks>
///   <para>
///     This is normally zero, unless you have set the <see
///     cref="MaxOutputSegmentSize"/> property.  If you have set <see
///     cref="MaxOutputSegmentSize"/>, and then you save a file, after the call to
///     Save() completes, you can read this value to learn the number of segments that
///     were created.
///   </para>
///   <para>
///     If you call Save("Archive.zip"), and it creates 5 segments, then you
///     will have filesystem files named Archive.z01, Archive.z02, Archive.z03,
///     Archive.z04, and Archive.zip, and the value of this property will be 5.
///   </para>
/// </remarks>
/// <seealso cref="MaxOutputSegmentSize"/>
/// <summary>
///   The size threshold for an entry, above which a parallel deflate is used.
/// </summary>
///
/// <remarks>
///
///   <para>
///     DotNetZip will use multiple threads to compress any ZipEntry,
///     if the entry is larger than the given size.  Zero means "always
///     use parallel deflate", while -1 means "never use parallel
///     deflate". The default value for this property is 512k. Aside
///     from the special values of 0 and 1, the minimum value is 65536.
///   </para>
///
///   <para>
///     If the entry size cannot be known before compression, as with a
///     read-forward stream, then Parallel deflate will never be
///     performed, unless the value of this property is zero.
///   </para>
///
///   <para>
///     A parallel deflate operations will speed up the compression of
///     large files, on computers with multiple CPUs or multiple CPU
///     cores.  For files above 1mb, on a dual core or dual-cpu (2p)
///     machine, the time required to compress the file can be 70% of the
///     single-threaded deflate.  For very large files on 4p machines the
///     compression can be done in 30% of the normal time.  The downside
///     is that parallel deflate consumes extra memory during the deflate,
///     and the deflation is not as effective.
///   </para>
///
///   <para>
///     Parallel deflate tends to yield slightly less compression when
///     compared to as single-threaded deflate; this is because the original
///     data stream is split into multiple independent buffers, each of which
///     is compressed in parallel.  But because they are treated
///     independently, there is no opportunity to share compression
///     dictionaries.  For that reason, a deflated stream may be slightly
///     larger when compressed using parallel deflate, as compared to a
///     traditional single-threaded deflate. Sometimes the increase over the
///     normal deflate is as much as 5% of the total compressed size. For
///     larger files it can be as small as 0.1%.
///   </para>
///
///   <para>
///     Multi-threaded compression does not give as much an advantage when
///     using Encryption. This is primarily because encryption tends to slow
///     down the entire pipeline. Also, multi-threaded compression gives less
///     of an advantage when using lower compression levels, for example <see
///     cref="Ionic.Zlib.CompressionLevel.BestSpeed"/>.  You may have to
///     perform some tests to determine the best approach for your situation.
///   </para>
///
/// </remarks>
///
/// <seealso cref="ParallelDeflateMaxBufferPairs"/>
///
/// <summary>
///   The maximum number of buffer pairs to use when performing
///   parallel compression.
/// </summary>
///
/// <remarks>
/// <para>
///   This property sets an upper limit on the number of memory
///   buffer pairs to create when performing parallel
///   compression.  The implementation of the parallel
///   compression stream allocates multiple buffers to
///   facilitate parallel compression.  As each buffer fills up,
///   the stream uses <see
///   cref="System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)">
///   ThreadPool.QueueUserWorkItem()</see> to compress those
///   buffers in a background threadpool thread. After a buffer
///   is compressed, it is re-ordered and written to the output
///   stream.
/// </para>
///
/// <para>
///   A higher number of buffer pairs enables a higher degree of
///   parallelism, which tends to increase the speed of compression on
///   multi-cpu computers.  On the other hand, a higher number of buffer
///   pairs also implies a larger memory consumption, more active worker
///   threads, and a higher cpu utilization for any compression. This
///   property enables the application to limit its memory consumption and
///   CPU utilization behavior depending on requirements.
/// </para>
///
/// <para>
///   For each compression "task" that occurs in parallel, there are 2
///   buffers allocated: one for input and one for output.  This property
///   sets a limit for the number of pairs.  The total amount of storage
///   space allocated for buffering will then be (N*S*2), where N is the
///   number of buffer pairs, S is the size of each buffer (<see
///   cref="BufferSize"/>).  By default, DotNetZip allocates 4 buffer
///   pairs per CPU core, so if your machine has 4 cores, and you retain
///   the default buffer size of 128k, then the
///   ParallelDeflateOutputStream will use 4 * 4 * 2 * 128kb of buffer
///   memory in total, or 4mb, in blocks of 128kb.  If you then set this
///   property to 8, then the number will be 8 * 2 * 128kb of buffer
///   memory, or 2mb.
/// </para>
///
/// <para>
///   CPU utilization will also go up with additional buffers, because a
///   larger number of buffer pairs allows a larger number of background
///   threads to compress in parallel. If you find that parallel
///   compression is consuming too much memory or CPU, you can adjust this
///   value downward.
/// </para>
///
/// <para>
///   The default value is 16. Different values may deliver better or
///   worse results, depending on your priorities and the dynamic
///   performance characteristics of your storage and compute resources.
/// </para>
///
/// <para>
///   This property is not the number of buffer pairs to use; it is an
///   upper limit. An illustration: Suppose you have an application that
///   uses the default value of this property (which is 16), and it runs
///   on a machine with 2 CPU cores. In that case, DotNetZip will allocate
///   4 buffer pairs per CPU core, for a total of 8 pairs.  The upper
///   limit specified by this property has no effect.
/// </para>
///
/// <para>
///   The application can set this value at any time
///   before calling <c>ZipFile.Save()</c>.
/// </para>
/// </remarks>
///
/// <seealso cref="ParallelDeflateThreshold"/>
///
/// <summary>Provides a string representation of the instance.</summary>
/// <returns>a string representation of the instance.</returns>
/// <summary>
/// Returns the version number on the DotNetZip assembly.
/// </summary>
///
/// <remarks>
///   <para>
///     This property is exposed as a convenience.  Callers could also get the
///     version value by retrieving GetName().Version on the
///     System.Reflection.Assembly object pointing to the DotNetZip
///     assembly. But sometimes it is not clear which assembly is being loaded.
///     This property makes it clear.
///   </para>
///   <para>
///     This static property is primarily useful for diagnostic purposes.
///   </para>
/// </remarks>
//return (this.ReadStream as FileStream);
// called by ZipEntry in ZipEntry.Extract(), when there is no stream set for the
// ZipEntry.
// read in the just-saved zip archive
// workitem 10735
// if we just saved to a stream no file is available to read from
// copy the contents of the entries.
// cannot just replace the entries - the app may be holding them
/// <summary>
///   Creates a new <c>ZipFile</c> instance, using the specified filename.
/// </summary>
///
/// <remarks>
/// <para>
///   Applications can use this constructor to create a new ZipFile for writing,
///   or to slurp in an existing zip archive for read and update purposes.
/// </para>
///
/// <para>
///   To create a new zip archive, an application can call this constructor,
///   passing the name of a file that does not exist.  The name may be a fully
///   qualified path. Then the application can add directories or files to the
///   <c>ZipFile</c> via <c>AddDirectory()</c>, <c>AddFile()</c>, <c>AddItem()</c>
///   and then write the zip archive to the disk by calling <c>Save()</c>. The
///   zip file is not actually opened and written to the disk until the
///   application calls <c>ZipFile.Save()</c>.  At that point the new zip file
///   with the given name is created.
/// </para>
///
/// <para>
///   If you won't know the name of the <c>Zipfile</c> until the time you call
///   <c>ZipFile.Save()</c>, or if you plan to save to a stream (which has no
///   name), then you should use the no-argument constructor.
/// </para>
///
/// <para>
///   The application can also call this constructor to read an existing zip
///   archive.  passing the name of a valid zip file that does exist. But, it's
///   better form to use the static <see cref="ZipFile.Read(String)"/> method,
///   passing the name of the zip file, because using <c>ZipFile.Read()</c> in
///   your code communicates very clearly what you are doing.  In either case,
///   the file is then read into the <c>ZipFile</c> instance.  The app can then
///   enumerate the entries or can modify the zip file, for example adding
///   entries, removing entries, changing comments, and so on.
/// </para>
///
/// <para>
///   One advantage to this parameterized constructor: it allows applications to
///   use the same code to add items to a zip archive, regardless of whether the
///   zip file exists.
/// </para>
///
/// <para>
///   Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
///   not party on a single instance with multiple threads.  You may have
///   multiple threads that each use a distinct <c>ZipFile</c> instance, or you
///   can synchronize multi-thread access to a single instance.
/// </para>
///
/// <para>
///   By the way, since DotNetZip is so easy to use, don't you think <see
///   href="http://cheeso.members.winisp.net/DotNetZipDonate.aspx">you should
///   donate $5 or $10</see>?
/// </para>
///
/// </remarks>
///
/// <exception cref="Ionic.Zip.ZipException">
/// Thrown if name refers to an existing file that is not a valid zip file.
/// </exception>
///
/// <example>
/// This example shows how to create a zipfile, and add a few files into it.
/// <code>
/// String ZipFileToCreate = "archive1.zip";
/// String DirectoryToZip  = "c:\\reports";
/// using (ZipFile zip = new ZipFile())
/// {
///   // Store all files found in the top level directory, into the zip archive.
///   String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
///   zip.AddFiles(filenames, "files");
///   zip.Save(ZipFileToCreate);
/// }
/// </code>
///
/// <code lang="VB">
/// Dim ZipFileToCreate As String = "archive1.zip"
/// Dim DirectoryToZip As String = "c:\reports"
/// Using zip As ZipFile = New ZipFile()
///     Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
///     zip.AddFiles(filenames, "files")
///     zip.Save(ZipFileToCreate)
/// End Using
/// </code>
/// </example>
///
/// <param name="fileName">The filename to use for the new zip archive.</param>
///
/// <summary>
///   Creates a new <c>ZipFile</c> instance, using the specified name for the
///   filename, and the specified Encoding.
/// </summary>
///
/// <remarks>
/// <para>
///   See the documentation on the <see cref="ZipFile(String)">ZipFile
///   constructor that accepts a single string argument</see> for basic
///   information on all the <c>ZipFile</c> constructors.
/// </para>
///
/// <para>
///   The Encoding is used as the default alternate encoding for entries with
///   filenames or comments that cannot be encoded with the IBM437 code page.
///   This is equivalent to setting the <see
///   cref="ProvisionalAlternateEncoding"/> property on the <c>ZipFile</c>
///   instance after construction.
/// </para>
///
/// <para>
///   Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
///   not party on a single instance with multiple threads.  You may have
///   multiple threads that each use a distinct <c>ZipFile</c> instance, or you
///   can synchronize multi-thread access to a single instance.
/// </para>
///
/// </remarks>
///
/// <exception cref="Ionic.Zip.ZipException">
/// Thrown if name refers to an existing file that is not a valid zip file.
/// </exception>
///
/// <param name="fileName">The filename to use for the new zip archive.</param>
/// <param name="encoding">The Encoding is used as the default alternate
/// encoding for entries with filenames or comments that cannot be encoded
/// with the IBM437 code page. </param>
/// <summary>
///   Create a zip file, without specifying a target filename or stream to save to.
/// </summary>
///
/// <remarks>
/// <para>
///   See the documentation on the <see cref="ZipFile(String)">ZipFile
///   constructor that accepts a single string argument</see> for basic
///   information on all the <c>ZipFile</c> constructors.
/// </para>
///
/// <para>
///   After instantiating with this constructor and adding entries to the
///   archive, the application should call <see cref="ZipFile.Save(String)"/> or
///   <see cref="ZipFile.Save(System.IO.Stream)"/> to save to a file or a
///   stream, respectively.  The application can also set the <see cref="Name"/>
///   property and then call the no-argument <see cref="Save()"/> method.  (This
///   is the preferred approach for applications that use the library through
///   COM interop.)  If you call the no-argument <see cref="Save()"/> method
///   without having set the <c>Name</c> of the <c>ZipFile</c>, either through
///   the parameterized constructor or through the explicit property , the
///   Save() will throw, because there is no place to save the file.  </para>
///
/// <para>
///   Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
///   have multiple threads that each use a distinct <c>ZipFile</c> instance, or
///   you can synchronize multi-thread access to a single instance.  </para>
///
/// </remarks>
///
/// <example>
/// This example creates a Zip archive called Backup.zip, containing all the files
/// in the directory DirectoryToZip. Files within subdirectories are not zipped up.
/// <code>
/// using (ZipFile zip = new ZipFile())
/// {
///   // Store all files found in the top level directory, into the zip archive.
///   // note: this code does not recurse subdirectories!
///   String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
///   zip.AddFiles(filenames, "files");
///   zip.Save("Backup.zip");
/// }
/// </code>
///
/// <code lang="VB">
/// Using zip As New ZipFile
///     ' Store all files found in the top level directory, into the zip archive.
///     ' note: this code does not recurse subdirectories!
///     Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
///     zip.AddFiles(filenames, "files")
///     zip.Save("Backup.zip")
/// End Using
/// </code>
/// </example>
/// <summary>
///   Create a zip file, specifying a text Encoding, but without specifying a
///   target filename or stream to save to.
/// </summary>
///
/// <remarks>
/// <para>
///   See the documentation on the <see cref="ZipFile(String)">ZipFile
///   constructor that accepts a single string argument</see> for basic
///   information on all the <c>ZipFile</c> constructors.
/// </para>
///
/// </remarks>
///
/// <param name="encoding">
/// The Encoding is used as the default alternate encoding for entries with
/// filenames or comments that cannot be encoded with the IBM437 code page.
/// </param>
/// <summary>
///   Creates a new <c>ZipFile</c> instance, using the specified name for the
///   filename, and the specified status message writer.
/// </summary>
///
/// <remarks>
/// <para>
///   See the documentation on the <see cref="ZipFile(String)">ZipFile
///   constructor that accepts a single string argument</see> for basic
///   information on all the <c>ZipFile</c> constructors.
/// </para>
///
/// <para>
///   This version of the constructor allows the caller to pass in a TextWriter,
///   to which verbose messages will be written during extraction or creation of
///   the zip archive.  A console application may wish to pass
///   System.Console.Out to get messages on the Console. A graphical or headless
///   application may wish to capture the messages in a different
///   <c>TextWriter</c>, for example, a <c>StringWriter</c>, and then display
///   the messages in a TextBox, or generate an audit log of ZipFile operations.
/// </para>
///
/// <para>
///   To encrypt the data for the files added to the <c>ZipFile</c> instance,
///   set the Password property after creating the <c>ZipFile</c> instance.
/// </para>
///
/// <para>
///   Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
///   not party on a single instance with multiple threads.  You may have
///   multiple threads that each use a distinct <c>ZipFile</c> instance, or you
///   can synchronize multi-thread access to a single instance.
/// </para>
///
/// </remarks>
///
/// <exception cref="Ionic.Zip.ZipException">
/// Thrown if name refers to an existing file that is not a valid zip file.
/// </exception>
///
/// <example>
/// <code>
/// using (ZipFile zip = new ZipFile("Backup.zip", Console.Out))
/// {
///   // Store all files found in the top level directory, into the zip archive.
///   // note: this code does not recurse subdirectories!
///   // Status messages will be written to Console.Out
///   String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
///   zip.AddFiles(filenames);
///   zip.Save();
/// }
/// </code>
///
/// <code lang="VB">
/// Using zip As New ZipFile("Backup.zip", Console.Out)
///     ' Store all files found in the top level directory, into the zip archive.
///     ' note: this code does not recurse subdirectories!
///     ' Status messages will be written to Console.Out
///     Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
///     zip.AddFiles(filenames)
///     zip.Save()
/// End Using
/// </code>
/// </example>
///
/// <param name="fileName">The filename to use for the new zip archive.</param>
/// <param name="statusMessageWriter">A TextWriter to use for writing
/// verbose status messages.</param>
/// <summary>
///   Creates a new <c>ZipFile</c> instance, using the specified name for the
///   filename, the specified status message writer, and the specified Encoding.
/// </summary>
///
/// <remarks>
/// <para>
///   This constructor works like the <see cref="ZipFile(String)">ZipFile
///   constructor that accepts a single string argument.</see> See that
///   reference for detail on what this constructor does.
/// </para>
///
/// <para>
///   This version of the constructor allows the caller to pass in a
///   <c>TextWriter</c>, and an Encoding.  The <c>TextWriter</c> will collect
///   verbose messages that are generated by the library during extraction or
///   creation of the zip archive.  A console application may wish to pass
///   <c>System.Console.Out</c> to get messages on the Console. A graphical or
///   headless application may wish to capture the messages in a different
///   <c>TextWriter</c>, for example, a <c>StringWriter</c>, and then display
///   the messages in a <c>TextBox</c>, or generate an audit log of
///   <c>ZipFile</c> operations.
/// </para>
///
/// <para>
///   The <c>Encoding</c> is used as the default alternate encoding for entries
///   with filenames or comments that cannot be encoded with the IBM437 code
///   page.  This is a equivalent to setting the <see
///   cref="ProvisionalAlternateEncoding"/> property on the <c>ZipFile</c>
///   instance after construction.
/// </para>
///
/// <para>
///   To encrypt the data for the files added to the <c>ZipFile</c> instance,
///   set the <c>Password</c> property after creating the <c>ZipFile</c>
///   instance.
/// </para>
///
/// <para>
///   Instances of the <c>ZipFile</c> class are not multi-thread safe.  You may
///   not party on a single instance with multiple threads.  You may have
///   multiple threads that each use a distinct <c>ZipFile</c> instance, or you
///   can synchronize multi-thread access to a single instance.
/// </para>
///
/// </remarks>
///
/// <exception cref="Ionic.Zip.ZipException">
/// Thrown if <c>fileName</c> refers to an existing file that is not a valid zip file.
/// </exception>
///
/// <param name="fileName">The filename to use for the new zip archive.</param>
/// <param name="statusMessageWriter">A TextWriter to use for writing verbose
/// status messages.</param>
/// <param name="encoding">
/// The Encoding is used as the default alternate encoding for entries with
/// filenames or comments that cannot be encoded with the IBM437 code page.
/// </param>
/// <summary>
///   Initialize a <c>ZipFile</c> instance by reading in a zip file.
/// </summary>
///
/// <remarks>
///
/// <para>
///   This method is primarily useful from COM Automation environments, when
///   reading or extracting zip files. In COM, it is not possible to invoke
///   parameterized constructors for a class. A COM Automation application can
///   update a zip file by using the <see cref="ZipFile()">default (no argument)
///   constructor</see>, then calling <c>Initialize()</c> to read the contents
///   of an on-disk zip archive into the <c>ZipFile</c> instance.
/// </para>
///
/// <para>
///   .NET applications are encouraged to use the <c>ZipFile.Read()</c> methods
///   for better clarity.
/// </para>
///
/// </remarks>
/// <param name="fileName">the name of the existing zip file to read in.</param>
// create a new zipfile
// workitem 8617
// workitem 7685, 9868
/// <summary>
///   This is an integer indexer into the Zip archive.
/// </summary>
///
/// <remarks>
/// <para>
///   This property is read-only.
/// </para>
///
/// <para>
///   Internally, the <c>ZipEntry</c> instances that belong to the
///   <c>ZipFile</c> are stored in a Dictionary.  When you use this
///   indexer the first time, it creates a read-only
///   <c>List&lt;ZipEntry&gt;</c> from the Dictionary.Values Collection.
///   If at any time you modify the set of entries in the <c>ZipFile</c>,
///   either by adding an entry, removing an entry, or renaming an
///   entry, a new List will be created, and the numeric indexes for the
///   remaining entries may be different.
/// </para>
///
/// <para>
///   This means you cannot rename any ZipEntry from
///   inside an enumeration of the zip file.
/// </para>
///
/// <param name="ix">
///   The index value.
/// </param>
///
/// </remarks>
///
/// <returns>
///   The <c>ZipEntry</c> within the Zip archive at the specified index. If the
///   entry does not exist in the archive, this indexer throws.
/// </returns>
///
// workitem 6402
/// <summary>
///   This is a name-based indexer into the Zip archive.
/// </summary>
///
/// <remarks>
/// <para>
///   This property is read-only.
/// </para>
///
/// <para>
///   The <see cref="CaseSensitiveRetrieval"/> property on the <c>ZipFile</c>
///   determines whether retrieval via this indexer is done via case-sensitive
///   comparisons. By default, retrieval is not case sensitive.  This makes
///   sense on Windows, in which filesystems are not case sensitive.
/// </para>
///
/// <para>
///   Regardless of case-sensitivity, it is not always the case that
///   <c>this[value].FileName == value</c>. In other words, the <c>FileName</c>
///   property of the <c>ZipEntry</c> retrieved with this indexer, may or may
///   not be equal to the index value.
/// </para>
///
/// <para>
///   This is because DotNetZip performs a normalization of filenames passed to
///   this indexer, before attempting to retrieve the item.  That normalization
///   includes: removal of a volume letter and colon, swapping backward slashes
///   for forward slashes.  So, <c>zip["dir1\\entry1.txt"].FileName ==
///   "dir1/entry.txt"</c>.
/// </para>
///
/// <para>
///   Directory entries in the zip file may be retrieved via this indexer only
///   with names that have a trailing slash. DotNetZip automatically appends a
///   trailing slash to the names of any directory entries added to a zip.
/// </para>
///
/// </remarks>
///
/// <example>
/// This example extracts only the entries in a zip file that are .txt files.
/// <code>
/// using (ZipFile zip = ZipFile.Read("PackedDocuments.zip"))
/// {
///   foreach (string s1 in zip.EntryFilenames)
///   {
///     if (s1.EndsWith(".txt"))
///       zip[s1].Extract("textfiles");
///   }
/// }
/// </code>
/// <code lang="VB">
///   Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip")
///       Dim s1 As String
///       For Each s1 In zip.EntryFilenames
///           If s1.EndsWith(".txt") Then
///               zip(s1).Extract("textfiles")
///           End If
///       Next
///   End Using
/// </code>
/// </example>
/// <seealso cref="Ionic.Zip.ZipFile.RemoveEntry(string)"/>
///
/// <exception cref="System.ArgumentException">
///   Thrown if the caller attempts to assign a non-null value to the indexer.
/// </exception>
///
/// <param name="fileName">
///   The name of the file, including any directory path, to retrieve from the
///   zip.  The filename match is not case-sensitive by default; you can use the
///   <see cref="CaseSensitiveRetrieval"/> property to change this behavior. The
///   pathname can use forward-slashes or backward slashes.
/// </param>
///
/// <returns>
///   The <c>ZipEntry</c> within the Zip archive, given by the specified
///   filename. If the named entry does not exist in the archive, this indexer
///   returns <c>null</c> (<c>Nothing</c> in VB).
/// </returns>
///
// workitem 11056
// check for the file match with a case-sensitive comparison.
// also check for equivalence
// check for a difference only in trailing slash
// also check for equivalence
// check for the file match in a case-insensitive manner.
// also check for equivalence
// check for a difference only in trailing slash
// also check for equivalence
/// <summary>
///   The list of filenames for the entries contained within the zip archive.
/// </summary>
///
/// <remarks>
///   According to the ZIP specification, the names of the entries use forward
///   slashes in pathnames.  If you are scanning through the list, you may have
///   to swap forward slashes for backslashes.
/// </remarks>
///
/// <seealso cref="Ionic.Zip.ZipFile.this[string]"/>
///
/// <example>
///   This example shows one way to test if a filename is already contained
///   within a zip archive.
/// <code>
/// String zipFileToRead= "PackedDocuments.zip";
/// string candidate = "DatedMaterial.xps";
/// using (ZipFile zip = new ZipFile(zipFileToRead))
/// {
///   if (zip.EntryFilenames.Contains(candidate))
///     Console.WriteLine("The file '{0}' exists in the zip archive '{1}'",
///                       candidate,
///                       zipFileName);
///   else
///     Console.WriteLine("The file, '{0}', does not exist in the zip archive '{1}'",
///                       candidate,
///                       zipFileName);
///   Console.WriteLine();
/// }
/// </code>
/// <code lang="VB">
///   Dim zipFileToRead As String = "PackedDocuments.zip"
///   Dim candidate As String = "DatedMaterial.xps"
///   Using zip As ZipFile.Read(ZipFileToRead)
///       If zip.EntryFilenames.Contains(candidate) Then
///           Console.WriteLine("The file '{0}' exists in the zip archive '{1}'", _
///                       candidate, _
///                       zipFileName)
///       Else
///         Console.WriteLine("The file, '{0}', does not exist in the zip archive '{1}'", _
///                       candidate, _
///                       zipFileName)
///       End If
///       Console.WriteLine
///   End Using
/// </code>
/// </example>
///
/// <returns>
///   The list of strings for the filenames contained within the Zip archive.
/// </returns>
///
/// <summary>
///   Returns the readonly collection of entries in the Zip archive.
/// </summary>
///
/// <remarks>
///
/// <para>
///   If there are no entries in the current <c>ZipFile</c>, the value returned is a
///   non-null zero-element collection.  If there are entries in the zip file,
///   the elements are returned in no particular order.
/// </para>
/// <para>
///   This is the implied enumerator on the <c>ZipFile</c> class.  If you use a
///   <c>ZipFile</c> instance in a context that expects an enumerator, you will
///   get this collection.
/// </para>
/// </remarks>
/// <seealso cref="EntriesSorted"/>
/// <summary>
///   Returns a readonly collection of entries in the Zip archive, sorted by FileName.
/// </summary>
///
/// <remarks>
///   If there are no entries in the current <c>ZipFile</c>, the value returned
///   is a non-null zero-element collection.  If there are entries in the zip
///   file, the elements are returned sorted by the name of the entry.
/// </remarks>
///
/// <example>
///
///   This example fills a Windows Forms ListView with the entries in a zip file.
///
/// <code lang="C#">
/// using (ZipFile zip = ZipFile.Read(zipFile))
/// {
///     foreach (ZipEntry entry in zip.EntriesSorted)
///     {
///         ListViewItem item = new ListViewItem(n.ToString());
///         n++;
///         string[] subitems = new string[] {
///             entry.FileName.Replace("/","\\"),
///             entry.LastModified.ToString("yyyy-MM-dd HH:mm:ss"),
///             entry.UncompressedSize.ToString(),
///             String.Format("{0,5:F0}%", entry.CompressionRatio),
///             entry.CompressedSize.ToString(),
///             (entry.UsesEncryption) ? "Y" : "N",
///             String.Format("{0:X8}", entry.Crc)};
///
///         foreach (String s in subitems)
///         {
///             ListViewItem.ListViewSubItem subitem = new ListViewItem.ListViewSubItem();
///             subitem.Text = s;
///             item.SubItems.Add(subitem);
///         }
///
///         this.listView1.Items.Add(item);
///     }
/// }
/// </code>
/// </example>
///
/// <seealso cref="Entries"/>
/// <summary>
/// Returns the number of entries in the Zip archive.
/// </summary>
/// <summary>
///   Removes the given <c>ZipEntry</c> from the zip archive.
/// </summary>
///
/// <remarks>
/// <para>
///   After calling <c>RemoveEntry</c>, the application must call <c>Save</c> to
///   make the changes permanent.
/// </para>
/// </remarks>
///
/// <exception cref="System.ArgumentException">
///   Thrown if the specified <c>ZipEntry</c> does not exist in the <c>ZipFile</c>.
/// </exception>
///
/// <example>
///   In this example, all entries in the zip archive dating from before
///   December 31st, 2007, are removed from the archive.  This is actually much
///   easier if you use the RemoveSelectedEntries method.  But I needed an
///   example for RemoveEntry, so here it is.
/// <code>
/// String ZipFileToRead = "ArchiveToModify.zip";
/// System.DateTime Threshold = new System.DateTime(2007,12,31);
/// using (ZipFile zip = ZipFile.Read(ZipFileToRead))
/// {
///   var EntriesToRemove = new System.Collections.Generic.List&lt;ZipEntry&gt;();
///   foreach (ZipEntry e in zip)
///   {
///     if (e.LastModified &lt; Threshold)
///     {
///       // We cannot remove the entry from the list, within the context of
///       // an enumeration of said list.
///       // So we add the doomed entry to a list to be removed later.
///       EntriesToRemove.Add(e);
///     }
///   }
///
///   // actually remove the doomed entries.
///   foreach (ZipEntry zombie in EntriesToRemove)
///     zip.RemoveEntry(zombie);
///
///   zip.Comment= String.Format("This zip archive was updated at {0}.",
///                              System.DateTime.Now.ToString("G"));
///
///   // save with a different name
///   zip.Save("Archive-Updated.zip");
/// }
/// </code>
///
/// <code lang="VB">
///   Dim ZipFileToRead As String = "ArchiveToModify.zip"
///   Dim Threshold As New DateTime(2007, 12, 31)
///   Using zip As ZipFile = ZipFile.Read(ZipFileToRead)
///       Dim EntriesToRemove As New System.Collections.Generic.List(Of ZipEntry)
///       Dim e As ZipEntry
///       For Each e In zip
///           If (e.LastModified &lt; Threshold) Then
///               ' We cannot remove the entry from the list, within the context of
///               ' an enumeration of said list.
///               ' So we add the doomed entry to a list to be removed later.
///               EntriesToRemove.Add(e)
///           End If
///       Next
///
///       ' actually remove the doomed entries.
///       Dim zombie As ZipEntry
///       For Each zombie In EntriesToRemove
///           zip.RemoveEntry(zombie)
///       Next
///       zip.Comment = String.Format("This zip archive was updated at {0}.", DateTime.Now.ToString("G"))
///       'save as a different name
///       zip.Save("Archive-Updated.zip")
///   End Using
/// </code>
/// </example>
///
/// <param name="entry">
/// The <c>ZipEntry</c> to remove from the zip.
/// </param>
///
/// <seealso cref="Ionic.Zip.ZipFile.RemoveSelectedEntries(string)"/>
///
//if (!_entries.Values.Contains(entry))
//    throw new ArgumentException("The entry you specified does not exist in the zip archive.");
// this has to search _entries rather than _caseInsensitiveEntries because it's used to determine whether to update the latter
/// <summary>
/// Removes the <c>ZipEntry</c> with the given filename from the zip archive.
/// </summary>
///
/// <remarks>
/// <para>
///   After calling <c>RemoveEntry</c>, the application must call <c>Save</c> to
///   make the changes permanent.
/// </para>
///
/// </remarks>
///
/// <exception cref="System.InvalidOperationException">
///   Thrown if the <c>ZipFile</c> is not updatable.
/// </exception>
///
/// <exception cref="System.ArgumentException">
///   Thrown if a <c>ZipEntry</c> with the specified filename does not exist in
///   the <c>ZipFile</c>.
/// </exception>
///
/// <example>
///
///   This example shows one way to remove an entry with a given filename from
///   an existing zip archive.
///
/// <code>
/// String zipFileToRead= "PackedDocuments.zip";
/// string candidate = "DatedMaterial.xps";
/// using (ZipFile zip = ZipFile.Read(zipFileToRead))
/// {
///   if (zip.EntryFilenames.Contains(candidate))
///   {
///     zip.RemoveEntry(candidate);
///     zip.Comment= String.Format("The file '{0}' has been removed from this archive.",
///                                Candidate);
///     zip.Save();
///   }
/// }
/// </code>
/// <code lang="VB">
///   Dim zipFileToRead As String = "PackedDocuments.zip"
///   Dim candidate As String = "DatedMaterial.xps"
///   Using zip As ZipFile = ZipFile.Read(zipFileToRead)
///       If zip.EntryFilenames.Contains(candidate) Then
///           zip.RemoveEntry(candidate)
///           zip.Comment = String.Format("The file '{0}' has been removed from this archive.", Candidate)
///           zip.Save
///       End If
///   End Using
/// </code>
/// </example>
///
/// <param name="fileName">
/// The name of the file, including any directory path, to remove from the zip.
/// The filename match is not case-sensitive by default; you can use the
/// <c>CaseSensitiveRetrieval</c> property to change this behavior. The
/// pathname can use forward-slashes or backward slashes.
/// </param>
///
//         /// <summary>
//         /// This is the class Destructor, which gets called implicitly when the instance
//         /// is destroyed.  Because the <c>ZipFile</c> type implements IDisposable, this
//         /// method calls Dispose(false).
//         /// </summary>
//         ~ZipFile()
//         {
//             // call Dispose with false.  Since we're in the
//             // destructor call, the managed resources will be
//             // disposed of anyways.
//             Dispose(false);
//         }
/// <summary>
///   Closes the read and write streams associated
///   to the <c>ZipFile</c>, if necessary.
/// </summary>
///
/// <remarks>
///   The Dispose() method is generally employed implicitly, via a <c>using(..) {..}</c>
///   statement. (<c>Using...End Using</c> in VB) If you do not employ a using
///   statement, insure that your application calls Dispose() explicitly.  For
///   example, in a Powershell application, or an application that uses the COM
///   interop interface, you must call Dispose() explicitly.
/// </remarks>
///
/// <example>
/// This example extracts an entry selected by name, from the Zip file to the
/// Console.
/// <code>
/// using (ZipFile zip = ZipFile.Read(zipfile))
/// {
///   foreach (ZipEntry e in zip)
///   {
///     if (WantThisEntry(e.FileName))
///       zip.Extract(e.FileName, Console.OpenStandardOutput());
///   }
/// } // Dispose() is called implicitly here.
/// </code>
///
/// <code lang="VB">
/// Using zip As ZipFile = ZipFile.Read(zipfile)
///     Dim e As ZipEntry
///     For Each e In zip
///       If WantThisEntry(e.FileName) Then
///           zip.Extract(e.FileName, Console.OpenStandardOutput())
///       End If
///     Next
/// End Using ' Dispose is implicity called here
/// </code>
/// </example>
// dispose of the managed and unmanaged resources
// tell the GC that the Finalize process no longer needs
// to be run for this object.
/// <summary>
///   Disposes any managed resources, if the flag is set, then marks the
///   instance disposed.  This method is typically not called explicitly from
///   application code.
/// </summary>
///
/// <remarks>
///   Applications should call <see cref="Dispose()">the no-arg Dispose method</see>.
/// </remarks>
///
/// <param name="disposeManagedResources">
///   indicates whether the method should dispose streams or not.
/// </param>
// dispose managed resources
// workitem 7704
// only dispose the writestream if there is a backing file
// workitem 7704
// workitem 10030
// workitem 9763
//private System.Collections.Generic.List<ZipEntry> _entries;
/// <summary>
///   Default size of the buffer used for IO.
/// </summary>
/// <summary>
///   Options for using ZIP64 extensions when saving zip archives.
/// </summary>
///
/// <remarks>
///
/// <para>
///   Designed many years ago, the <see
///   href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">original zip
///   specification from PKWARE</see> allowed for 32-bit quantities for the
///   compressed and uncompressed sizes of zip entries, as well as a 32-bit quantity
///   for specifying the length of the zip archive itself, and a maximum of 65535
///   entries.  These limits are now regularly exceeded in many backup and archival
///   scenarios.  Recently, PKWare added extensions to the original zip spec, called
///   "ZIP64 extensions", to raise those limitations.  This property governs whether
///   DotNetZip will use those extensions when writing zip archives. The use of
///   these extensions is optional and explicit in DotNetZip because, despite the
///   status of ZIP64 as a bona fide standard, many other zip tools and libraries do
///   not support ZIP64, and therefore a zip file with ZIP64 extensions may be
///   unreadable by some of those other tools.
/// </para>
///
/// <para>
///   Set this property to <see cref="Zip64Option.Always"/> to always use ZIP64
///   extensions when saving, regardless of whether your zip archive needs it.
///   Suppose you add 5 files, each under 100k, to a ZipFile. If you specify Always
///   for this flag, you will get a ZIP64 archive, though the archive does not need
///   to use ZIP64 because none of the original zip limits had been exceeded.
/// </para>
///
/// <para>
///   Set this property to <see cref="Zip64Option.Never"/> to tell the DotNetZip
///   library to never use ZIP64 extensions.  This is useful for maximum
///   compatibility and interoperability, at the expense of the capability of
///   handling large files or large archives.  NB: Windows Explorer in Windows XP
///   and Windows Vista cannot currently extract files from a zip64 archive, so if
///   you want to guarantee that a zip archive produced by this library will work in
///   Windows Explorer, use <c>Never</c>. If you set this property to <see
///   cref="Zip64Option.Never"/>, and your application creates a zip that would
///   exceed one of the Zip limits, the library will throw an exception while saving
///   the zip file.
/// </para>
///
/// <para>
///   Set this property to <see cref="Zip64Option.AsNecessary"/> to tell the
///   DotNetZip library to use the ZIP64 extensions when required by the
///   entry. After the file is compressed, the original and compressed sizes are
///   checked, and if they exceed the limits described above, then zip64 can be
///   used. That is the general idea, but there is an additional wrinkle when saving
///   to a non-seekable device, like the ASP.NET <c>Response.OutputStream</c>, or
///   <c>Console.Out</c>.  When using non-seekable streams for output, the entry
///   header - which indicates whether zip64 is in use - is emitted before it is
///   known if zip64 is necessary.  It is only after all entries have been saved
///   that it can be known if ZIP64 will be required.  On seekable output streams,
///   after saving all entries, the library can seek backward and re-emit the zip
///   file header to be consistent with the actual ZIP64 requirement.  But using a
///   non-seekable output stream, the library cannot seek backward, so the header
///   can never be changed. In other words, the archive's use of ZIP64 extensions is
///   not alterable after the header is emitted.  Therefore, when saving to
///   non-seekable streams, using <see cref="Zip64Option.AsNecessary"/> is the same
///   as using <see cref="Zip64Option.Always"/>: it will always produce a zip
///   archive that uses ZIP64 extensions.
/// </para>
///
/// </remarks>
/// <summary>
/// The default behavior, which is "Never".
/// (For COM clients, this is a 0 (zero).)
/// </summary>
/// <summary>
/// Do not use ZIP64 extensions when writing zip archives.
/// (For COM clients, this is a 0 (zero).)
/// </summary>
/// <summary>
/// Use ZIP64 extensions when writing zip archives, as necessary.
/// For example, when a single entry exceeds 0xFFFFFFFF in size, or when the archive as a whole
/// exceeds 0xFFFFFFFF in size, or when there are more than 65535 entries in an archive.
/// (For COM clients, this is a 1.)
/// </summary>
/// <summary>
/// Always use ZIP64 extensions when writing zip archives, even when unnecessary.
/// (For COM clients, this is a 2.)
/// </summary>
/// <summary>
///  An enum representing the values on a three-way toggle switch
///  for various options in the library. This might be used to
///  specify whether to employ a particular text encoding, or to use
///  ZIP64 extensions, or some other option.
/// </summary>
/// <summary>
/// The default behavior. This is the same as "Never".
/// (For COM clients, this is a 0 (zero).)
/// </summary>
/// <summary>
/// Never use the associated option.
/// (For COM clients, this is a 0 (zero).)
/// </summary>
/// <summary>
/// Use the associated behavior "as necessary."
/// (For COM clients, this is a 1.)
/// </summary>
/// <summary>
/// Use the associated behavior Always, whether necessary or not.
/// (For COM clients, this is a 2.)
/// </summary>
// ==================================================================
//
// Information on the ZIP format:
//
// From
// http://www.pkware.com/documents/casestudies/APPNOTE.TXT
//
//  Overall .ZIP file format:
//
//     [local file header 1]
//     [file data 1]
//     [data descriptor 1]  ** sometimes
//     .
//     .
//     .
//     [local file header n]
//     [file data n]
//     [data descriptor n]   ** sometimes
//     [archive decryption header]
//     [archive extra data record]
//     [central directory]
//     [zip64 end of central directory record]
//     [zip64 end of central directory locator]
//     [end of central directory record]
//
// Local File Header format:
//         local file header signature ... 4 bytes  (0x04034b50)
//         version needed to extract ..... 2 bytes
//         general purpose bit field ..... 2 bytes
//         compression method ............ 2 bytes
//         last mod file time ............ 2 bytes
//         last mod file date............. 2 bytes
//         crc-32 ........................ 4 bytes
//         compressed size................ 4 bytes
//         uncompressed size.............. 4 bytes
//         file name length............... 2 bytes
//         extra field length ............ 2 bytes
//         file name                       varies
//         extra field                     varies
//
//
// Data descriptor:  (used only when bit 3 of the general purpose bitfield is set)
//         (although, I have found zip files where bit 3 is not set, yet this descriptor is present!)
//         local file header signature     4 bytes  (0x08074b50)  ** sometimes!!! Not always
//         crc-32                          4 bytes
//         compressed size                 4 bytes
//         uncompressed size               4 bytes
//
//
//   Central directory structure:
//
//       [file header 1]
//       .
//       .
//       .
//       [file header n]
//       [digital signature]
//
//
//       File header:  (This is a ZipDirEntry)
//         central file header signature   4 bytes  (0x02014b50)
//         version made by                 2 bytes
//         version needed to extract       2 bytes
//         general purpose bit flag        2 bytes
//         compression method              2 bytes
//         last mod file time              2 bytes
//         last mod file date              2 bytes
//         crc-32                          4 bytes
//         compressed size                 4 bytes
//         uncompressed size               4 bytes
//         file name length                2 bytes
//         extra field length              2 bytes
//         file comment length             2 bytes
//         disk number start               2 bytes
//         internal file attributes **     2 bytes
//         external file attributes ***    4 bytes
//         relative offset of local header 4 bytes
//         file name (variable size)
//         extra field (variable size)
//         file comment (variable size)
//
// ** The internal file attributes, near as I can tell,
// uses 0x01 for a file and a 0x00 for a directory.
//
// ***The external file attributes follows the MS-DOS file attribute byte, described here:
// at http://support.microsoft.com/kb/q125019/
// 0x0010 => directory
// 0x0020 => file
//
//
// End of central directory record:
//
//         end of central dir signature    4 bytes  (0x06054b50)
//         number of this disk             2 bytes
//         number of the disk with the
//         start of the central directory  2 bytes
//         total number of entries in the
//         central directory on this disk  2 bytes
//         total number of entries in
//         the central directory           2 bytes
//         size of the central directory   4 bytes
//         offset of start of central
//         directory with respect to
//         the starting disk number        4 bytes
//         .ZIP file comment length        2 bytes
//         .ZIP file comment       (variable size)
//
// date and time are packed values, as MSDOS did them
// time: bits 0-4 : seconds (divided by 2)
//            5-10: minute
//            11-15: hour
// date  bits 0-4 : day
//            5-8: month
//            9-15 year (since 1980)
//
// see http://msdn.microsoft.com/en-us/library/ms724274(VS.85).aspx
// ZipFile.Events.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2008, 2009, 2011 Dino Chiesa .
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-July-09 08:42:35>
//
// ------------------------------------------------------------------
//
// This module defines the methods for issuing events from the ZipFile class.
//
// ------------------------------------------------------------------
//
/// <summary>
///   An event handler invoked when a Save() starts, before and after each
///   entry has been written to the archive, when a Save() completes, and
///   during other Save events.
/// </summary>
///
/// <remarks>
/// <para>
///   Depending on the particular event, different properties on the <see
///   cref="SaveProgressEventArgs"/> parameter are set.  The following
///   table summarizes the available EventTypes and the conditions under
///   which this event handler is invoked with a
///   <c>SaveProgressEventArgs</c> with the given EventType.
/// </para>
///
/// <list type="table">
/// <listheader>
/// <term>value of EntryType</term>
/// <description>Meaning and conditions</description>
/// </listheader>
///
/// <item>
/// <term>ZipProgressEventType.Saving_Started</term>
/// <description>Fired when ZipFile.Save() begins.
/// </description>
/// </item>
///
/// <item>
/// <term>ZipProgressEventType.Saving_BeforeSaveEntry</term>
/// <description>
///   Fired within ZipFile.Save(), just before writing data for each
///   particular entry.
/// </description>
/// </item>
///
/// <item>
/// <term>ZipProgressEventType.Saving_AfterSaveEntry</term>
/// <description>
///   Fired within ZipFile.Save(), just after having finished writing data
///   for each particular entry.
/// </description>
/// </item>
///
/// <item>
/// <term>ZipProgressEventType.Saving_Completed</term>
/// <description>Fired when ZipFile.Save() has completed.
/// </description>
/// </item>
///
/// <item>
/// <term>ZipProgressEventType.Saving_AfterSaveTempArchive</term>
/// <description>
///   Fired after the temporary file has been created.  This happens only
///   when saving to a disk file.  This event will not be invoked when
///   saving to a stream.
/// </description>
/// </item>
///
/// <item>
/// <term>ZipProgressEventType.Saving_BeforeRenameTempArchive</term>
/// <description>
///   Fired just before renaming the temporary file to the permanent
///   location.  This happens only when saving to a disk file.  This event
///   will not be invoked when saving to a stream.
/// </description>
/// </item>
///
/// <item>
/// <term>ZipProgressEventType.Saving_AfterRenameTempArchive</term>
/// <description>
///   Fired just after renaming the temporary file to the permanent
///   location.  This happens only when saving to a disk file.  This event
///   will not be invoked when saving to a stream.
/// </description>
/// </item>
///
/// <item>
/// <term>ZipProgressEventType.Saving_AfterCompileSelfExtractor</term>
/// <description>
///   Fired after a self-extracting archive has finished compiling.  This
///   EventType is used only within SaveSelfExtractor().
/// </description>
/// </item>
///
/// <item>
/// <term>ZipProgressEventType.Saving_BytesRead</term>
/// <description>
///   Set during the save of a particular entry, to update progress of the
///   Save().  When this EventType is set, the BytesTransferred is the
///   number of bytes that have been read from the source stream.  The
///   TotalBytesToTransfer is the number of bytes in the uncompressed
///   file.
/// </description>
/// </item>
///
/// </list>
/// </remarks>
///
/// <example>
///
///    This example uses an anonymous method to handle the
///    SaveProgress event, by updating a progress bar.
///
/// <code lang="C#">
/// progressBar1.Value = 0;
/// progressBar1.Max = listbox1.Items.Count;
/// using (ZipFile zip = new ZipFile())
/// {
///    // listbox1 contains a list of filenames
///    zip.AddFiles(listbox1.Items);
///
///    // do the progress bar:
///    zip.SaveProgress += (sender, e) => {
///       if (e.EventType == ZipProgressEventType.Saving_BeforeWriteEntry) {
///          progressBar1.PerformStep();
///       }
///    };
///
///    zip.Save(fs);
/// }
/// </code>
/// </example>
///
/// <example>
///   This example uses a named method as the
///   <c>SaveProgress</c> event handler, to update the user, in a
///   console-based application.
///
/// <code lang="C#">
/// static bool justHadByteUpdate= false;
/// public static void SaveProgress(object sender, SaveProgressEventArgs e)
/// {
///     if (e.EventType == ZipProgressEventType.Saving_Started)
///         Console.WriteLine("Saving: {0}", e.ArchiveName);
///
///     else if (e.EventType == ZipProgressEventType.Saving_Completed)
///     {
///         justHadByteUpdate= false;
///         Console.WriteLine();
///         Console.WriteLine("Done: {0}", e.ArchiveName);
///     }
///
///     else if (e.EventType == ZipProgressEventType.Saving_BeforeWriteEntry)
///     {
///         if (justHadByteUpdate)
///             Console.WriteLine();
///         Console.WriteLine("  Writing: {0} ({1}/{2})",
///                           e.CurrentEntry.FileName, e.EntriesSaved, e.EntriesTotal);
///         justHadByteUpdate= false;
///     }
///
///     else if (e.EventType == ZipProgressEventType.Saving_EntryBytesRead)
///     {
///         if (justHadByteUpdate)
///             Console.SetCursorPosition(0, Console.CursorTop);
///          Console.Write("     {0}/{1} ({2:N0}%)", e.BytesTransferred, e.TotalBytesToTransfer,
///                       e.BytesTransferred / (0.01 * e.TotalBytesToTransfer ));
///         justHadByteUpdate= true;
///     }
/// }
///
/// public static ZipUp(string targetZip, string directory)
/// {
///   using (var zip = new ZipFile()) {
///     zip.SaveProgress += SaveProgress;
///     zip.AddDirectory(directory);
///     zip.Save(targetZip);
///   }
/// }
///
/// </code>
///
/// <code lang="VB">
/// Public Sub ZipUp(ByVal targetZip As String, ByVal directory As String)
///     Using zip As ZipFile = New ZipFile
///         AddHandler zip.SaveProgress, AddressOf MySaveProgress
///         zip.AddDirectory(directory)
///         zip.Save(targetZip)
///     End Using
/// End Sub
///
/// Private Shared justHadByteUpdate As Boolean = False
///
/// Public Shared Sub MySaveProgress(ByVal sender As Object, ByVal e As SaveProgressEventArgs)
///     If (e.EventType Is ZipProgressEventType.Saving_Started) Then
///         Console.WriteLine("Saving: {0}", e.ArchiveName)
///
///     ElseIf (e.EventType Is ZipProgressEventType.Saving_Completed) Then
///         justHadByteUpdate = False
///         Console.WriteLine
///         Console.WriteLine("Done: {0}", e.ArchiveName)
///
///     ElseIf (e.EventType Is ZipProgressEventType.Saving_BeforeWriteEntry) Then
///         If justHadByteUpdate Then
///             Console.WriteLine
///         End If
///         Console.WriteLine("  Writing: {0} ({1}/{2})", e.CurrentEntry.FileName, e.EntriesSaved, e.EntriesTotal)
///         justHadByteUpdate = False
///
///     ElseIf (e.EventType Is ZipProgressEventType.Saving_EntryBytesRead) Then
///         If justHadByteUpdate Then
///             Console.SetCursorPosition(0, Console.CursorTop)
///         End If
///         Console.Write("     {0}/{1} ({2:N0}%)", e.BytesTransferred, _
///                       e.TotalBytesToTransfer, _
///                       (CDbl(e.BytesTransferred) / (0.01 * e.TotalBytesToTransfer)))
///         justHadByteUpdate = True
///     End If
/// End Sub
/// </code>
/// </example>
///
/// <example>
///
/// This is a more complete example of using the SaveProgress
/// events in a Windows Forms application, with a
/// Thread object.
///
/// <code lang="C#">
/// delegate void SaveEntryProgress(SaveProgressEventArgs e);
/// delegate void ButtonClick(object sender, EventArgs e);
///
/// public class WorkerOptions
/// {
///     public string ZipName;
///     public string Folder;
///     public string Encoding;
///     public string Comment;
///     public int ZipFlavor;
///     public Zip64Option Zip64;
/// }
///
/// private int _progress2MaxFactor;
/// private bool _saveCanceled;
/// private long _totalBytesBeforeCompress;
/// private long _totalBytesAfterCompress;
/// private Thread _workerThread;
///
///
/// private void btnZipup_Click(object sender, EventArgs e)
/// {
///     KickoffZipup();
/// }
///
/// private void btnCancel_Click(object sender, EventArgs e)
/// {
///     if (this.lblStatus.InvokeRequired)
///     {
///         this.lblStatus.Invoke(new ButtonClick(this.btnCancel_Click), new object[] { sender, e });
///     }
///     else
///     {
///         _saveCanceled = true;
///         lblStatus.Text = "Canceled...";
///         ResetState();
///     }
/// }
///
/// private void KickoffZipup()
/// {
///     _folderName = tbDirName.Text;
///
///     if (_folderName == null || _folderName == "") return;
///     if (this.tbZipName.Text == null || this.tbZipName.Text == "") return;
///
///     // check for existence of the zip file:
///     if (System.IO.File.Exists(this.tbZipName.Text))
///     {
///         var dlgResult = MessageBox.Show(String.Format("The file you have specified ({0}) already exists." +
///                                                       "  Do you want to overwrite this file?", this.tbZipName.Text),
///                                         "Confirmation is Required", MessageBoxButtons.YesNo, MessageBoxIcon.Question);
///         if (dlgResult != DialogResult.Yes) return;
///         System.IO.File.Delete(this.tbZipName.Text);
///     }
///
///      _saveCanceled = false;
///     _nFilesCompleted = 0;
///     _totalBytesAfterCompress = 0;
///     _totalBytesBeforeCompress = 0;
///     this.btnOk.Enabled = false;
///     this.btnOk.Text = "Zipping...";
///     this.btnCancel.Enabled = true;
///     lblStatus.Text = "Zipping...";
///
///     var options = new WorkerOptions
///     {
///         ZipName = this.tbZipName.Text,
///         Folder = _folderName,
///         Encoding = "ibm437"
///     };
///
///     if (this.comboBox1.SelectedIndex != 0)
///     {
///         options.Encoding = this.comboBox1.SelectedItem.ToString();
///     }
///
///     if (this.radioFlavorSfxCmd.Checked)
///         options.ZipFlavor = 2;
///     else if (this.radioFlavorSfxGui.Checked)
///         options.ZipFlavor = 1;
///     else options.ZipFlavor = 0;
///
///     if (this.radioZip64AsNecessary.Checked)
///         options.Zip64 = Zip64Option.AsNecessary;
///     else if (this.radioZip64Always.Checked)
///         options.Zip64 = Zip64Option.Always;
///     else options.Zip64 = Zip64Option.Never;
///
///     options.Comment = String.Format("Encoding:{0} || Flavor:{1} || ZIP64:{2}\r\nCreated at {3} || {4}\r\n",
///                 options.Encoding,
///                 FlavorToString(options.ZipFlavor),
///                 options.Zip64.ToString(),
///                 System.DateTime.Now.ToString("yyyy-MMM-dd HH:mm:ss"),
///                 this.Text);
///
///     if (this.tbComment.Text != TB_COMMENT_NOTE)
///         options.Comment += this.tbComment.Text;
///
///     _workerThread = new Thread(this.DoSave);
///     _workerThread.Name = "Zip Saver thread";
///     _workerThread.Start(options);
///     this.Cursor = Cursors.WaitCursor;
///  }
///
///
/// private void DoSave(Object p)
/// {
///     WorkerOptions options = p as WorkerOptions;
///     try
///     {
///         using (var zip1 = new ZipFile())
///         {
///             zip1.ProvisionalAlternateEncoding = System.Text.Encoding.GetEncoding(options.Encoding);
///             zip1.Comment = options.Comment;
///             zip1.AddDirectory(options.Folder);
///             _entriesToZip = zip1.EntryFileNames.Count;
///             SetProgressBars();
///             zip1.SaveProgress += this.zip1_SaveProgress;
///
///             zip1.UseZip64WhenSaving = options.Zip64;
///
///             if (options.ZipFlavor == 1)
///                 zip1.SaveSelfExtractor(options.ZipName, SelfExtractorFlavor.WinFormsApplication);
///             else if (options.ZipFlavor == 2)
///                 zip1.SaveSelfExtractor(options.ZipName, SelfExtractorFlavor.ConsoleApplication);
///             else
///                 zip1.Save(options.ZipName);
///         }
///     }
///     catch (System.Exception exc1)
///     {
///         MessageBox.Show(String.Format("Exception while zipping: {0}", exc1.Message));
///         btnCancel_Click(null, null);
///     }
/// }
///
///
///
/// void zip1_SaveProgress(object sender, SaveProgressEventArgs e)
/// {
///     switch (e.EventType)
///     {
///         case ZipProgressEventType.Saving_AfterWriteEntry:
///             StepArchiveProgress(e);
///             break;
///         case ZipProgressEventType.Saving_EntryBytesRead:
///             StepEntryProgress(e);
///             break;
///         case ZipProgressEventType.Saving_Completed:
///             SaveCompleted();
///             break;
///         case ZipProgressEventType.Saving_AfterSaveTempArchive:
///             // this event only occurs when saving an SFX file
///             TempArchiveSaved();
///             break;
///     }
///     if (_saveCanceled)
///         e.Cancel = true;
/// }
///
///
///
/// private void StepArchiveProgress(SaveProgressEventArgs e)
/// {
///     if (this.progressBar1.InvokeRequired)
///     {
///         this.progressBar1.Invoke(new SaveEntryProgress(this.StepArchiveProgress), new object[] { e });
///     }
///     else
///     {
///         if (!_saveCanceled)
///         {
///             _nFilesCompleted++;
///             this.progressBar1.PerformStep();
///             _totalBytesAfterCompress += e.CurrentEntry.CompressedSize;
///             _totalBytesBeforeCompress += e.CurrentEntry.UncompressedSize;
///
///             // reset the progress bar for the entry:
///             this.progressBar2.Value = this.progressBar2.Maximum = 1;
///
///             this.Update();
///         }
///     }
/// }
///
///
/// private void StepEntryProgress(SaveProgressEventArgs e)
/// {
///     if (this.progressBar2.InvokeRequired)
///     {
///         this.progressBar2.Invoke(new SaveEntryProgress(this.StepEntryProgress), new object[] { e });
///     }
///     else
///     {
///         if (!_saveCanceled)
///         {
///             if (this.progressBar2.Maximum == 1)
///             {
///                 // reset
///                 Int64 max = e.TotalBytesToTransfer;
///                 _progress2MaxFactor = 0;
///                 while (max > System.Int32.MaxValue)
///                 {
///                     max /= 2;
///                     _progress2MaxFactor++;
///                 }
///                 this.progressBar2.Maximum = (int)max;
///                 lblStatus.Text = String.Format("{0} of {1} files...({2})",
///                     _nFilesCompleted + 1, _entriesToZip, e.CurrentEntry.FileName);
///             }
///
///              int xferred = e.BytesTransferred >> _progress2MaxFactor;
///
///              this.progressBar2.Value = (xferred >= this.progressBar2.Maximum)
///                 ? this.progressBar2.Maximum
///                 : xferred;
///
///              this.Update();
///         }
///     }
/// }
///
/// private void SaveCompleted()
/// {
///     if (this.lblStatus.InvokeRequired)
///     {
///         this.lblStatus.Invoke(new MethodInvoker(this.SaveCompleted));
///     }
///     else
///     {
///         lblStatus.Text = String.Format("Done, Compressed {0} files, {1:N0}% of original.",
///             _nFilesCompleted, (100.00 * _totalBytesAfterCompress) / _totalBytesBeforeCompress);
///          ResetState();
///     }
/// }
///
/// private void ResetState()
/// {
///     this.btnCancel.Enabled = false;
///     this.btnOk.Enabled = true;
///     this.btnOk.Text = "Zip it!";
///     this.progressBar1.Value = 0;
///     this.progressBar2.Value = 0;
///     this.Cursor = Cursors.Default;
///     if (!_workerThread.IsAlive)
///         _workerThread.Join();
/// }
/// </code>
///
/// </example>
///
/// <seealso cref="Ionic.Zip.ZipFile.ReadProgress"/>
/// <seealso cref="Ionic.Zip.ZipFile.AddProgress"/>
/// <seealso cref="Ionic.Zip.ZipFile.ExtractProgress"/>
/// <summary>
/// An event handler invoked before, during, and after the reading of a zip archive.
/// </summary>
///
/// <remarks>
/// <para>
/// Depending on the particular event being signaled, different properties on the
/// <see cref="ReadProgressEventArgs"/> parameter are set.  The following table
/// summarizes the available EventTypes and the conditions under which this
/// event handler is invoked with a <c>ReadProgressEventArgs</c> with the given EventType.
/// </para>
///
/// <list type="table">
/// <listheader>
/// <term>value of EntryType</term>
/// <description>Meaning and conditions</description>
/// </listheader>
///
/// <item>
/// <term>ZipProgressEventType.Reading_Started</term>
/// <description>Fired just as ZipFile.Read() begins. Meaningful properties: ArchiveName.
/// </description>
/// </item>
///
/// <item>
/// <term>ZipProgressEventType.Reading_Completed</term>
/// <description>Fired when ZipFile.Read() has completed. Meaningful properties: ArchiveName.
/// </description>
/// </item>
///
/// <item>
/// <term>ZipProgressEventType.Reading_ArchiveBytesRead</term>
/// <description>Fired while reading, updates the number of bytes read for the entire archive.
/// Meaningful properties: ArchiveName, CurrentEntry, BytesTransferred, TotalBytesToTransfer.
/// </description>
/// </item>
///
/// <item>
/// <term>ZipProgressEventType.Reading_BeforeReadEntry</term>
/// <description>Indicates an entry is about to be read from the archive.
/// Meaningful properties: ArchiveName, EntriesTotal.
/// </description>
/// </item>
///
/// <item>
/// <term>ZipProgressEventType.Reading_AfterReadEntry</term>
/// <description>Indicates an entry has just been read from the archive.
/// Meaningful properties: ArchiveName, EntriesTotal, CurrentEntry.
/// </description>
/// </item>
///
/// </list>
/// </remarks>
///
/// <seealso cref="Ionic.Zip.ZipFile.SaveProgress"/>
/// <seealso cref="Ionic.Zip.ZipFile.AddProgress"/>
/// <seealso cref="Ionic.Zip.ZipFile.ExtractProgress"/>
/// <summary>
///   An event handler invoked before, during, and after extraction of
///   entries in the zip archive.
/// </summary>
///
/// <remarks>
/// <para>
///   Depending on the particular event, different properties on the <see
///   cref="ExtractProgressEventArgs"/> parameter are set.  The following
///   table summarizes the available EventTypes and the conditions under
///   which this event handler is invoked with a
///   <c>ExtractProgressEventArgs</c> with the given EventType.
/// </para>
///
/// <list type="table">
/// <listheader>
/// <term>value of EntryType</term>
/// <description>Meaning and conditions</description>
/// </listheader>
///
/// <item>
/// <term>ZipProgressEventType.Extracting_BeforeExtractAll</term>
/// <description>
///   Set when ExtractAll() begins. The ArchiveName, Overwrite, and
///   ExtractLocation properties are meaningful.</description>
/// </item>
///
/// <item>
/// <term>ZipProgressEventType.Extracting_AfterExtractAll</term>
/// <description>
///   Set when ExtractAll() has completed.  The ArchiveName, Overwrite,
///   and ExtractLocation properties are meaningful.
/// </description>
/// </item>
///
/// <item>
/// <term>ZipProgressEventType.Extracting_BeforeExtractEntry</term>
/// <description>
///   Set when an Extract() on an entry in the ZipFile has begun.
///   Properties that are meaningful: ArchiveName, EntriesTotal,
///   CurrentEntry, Overwrite, ExtractLocation, EntriesExtracted.
/// </description>
/// </item>
///
/// <item>
/// <term>ZipProgressEventType.Extracting_AfterExtractEntry</term>
/// <description>
///   Set when an Extract() on an entry in the ZipFile has completed.
///   Properties that are meaningful: ArchiveName, EntriesTotal,
///   CurrentEntry, Overwrite, ExtractLocation, EntriesExtracted.
/// </description>
/// </item>
///
/// <item>
/// <term>ZipProgressEventType.Extracting_EntryBytesWritten</term>
/// <description>
///   Set within a call to Extract() on an entry in the ZipFile, as data
///   is extracted for the entry.  Properties that are meaningful:
///   ArchiveName, CurrentEntry, BytesTransferred, TotalBytesToTransfer.
/// </description>
/// </item>
///
/// <item>
/// <term>ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite</term>
/// <description>
///   Set within a call to Extract() on an entry in the ZipFile, when the
///   extraction would overwrite an existing file. This event type is used
///   only when <c>ExtractExistingFileAction</c> on the <c>ZipFile</c> or
///   <c>ZipEntry</c> is set to <c>InvokeExtractProgressEvent</c>.
/// </description>
/// </item>
///
/// </list>
///
/// </remarks>
///
/// <example>
/// <code>
/// private static bool justHadByteUpdate = false;
/// public static void ExtractProgress(object sender, ExtractProgressEventArgs e)
/// {
///   if(e.EventType == ZipProgressEventType.Extracting_EntryBytesWritten)
///   {
///     if (justHadByteUpdate)
///       Console.SetCursorPosition(0, Console.CursorTop);
///
///     Console.Write("   {0}/{1} ({2:N0}%)", e.BytesTransferred, e.TotalBytesToTransfer,
///                   e.BytesTransferred / (0.01 * e.TotalBytesToTransfer ));
///     justHadByteUpdate = true;
///   }
///   else if(e.EventType == ZipProgressEventType.Extracting_BeforeExtractEntry)
///   {
///     if (justHadByteUpdate)
///       Console.WriteLine();
///     Console.WriteLine("Extracting: {0}", e.CurrentEntry.FileName);
///     justHadByteUpdate= false;
///   }
/// }
///
/// public static ExtractZip(string zipToExtract, string directory)
/// {
///   string TargetDirectory= "extract";
///   using (var zip = ZipFile.Read(zipToExtract)) {
///     zip.ExtractProgress += ExtractProgress;
///     foreach (var e in zip1)
///     {
///       e.Extract(TargetDirectory, true);
///     }
///   }
/// }
///
/// </code>
/// <code lang="VB">
/// Public Shared Sub Main(ByVal args As String())
///     Dim ZipToUnpack As String = "C1P3SML.zip"
///     Dim TargetDir As String = "ExtractTest_Extract"
///     Console.WriteLine("Extracting file {0} to {1}", ZipToUnpack, TargetDir)
///     Using zip1 As ZipFile = ZipFile.Read(ZipToUnpack)
///         AddHandler zip1.ExtractProgress, AddressOf MyExtractProgress
///         Dim e As ZipEntry
///         For Each e In zip1
///             e.Extract(TargetDir, True)
///         Next
///     End Using
/// End Sub
///
/// Private Shared justHadByteUpdate As Boolean = False
///
/// Public Shared Sub MyExtractProgress(ByVal sender As Object, ByVal e As ExtractProgressEventArgs)
///     If (e.EventType = ZipProgressEventType.Extracting_EntryBytesWritten) Then
///         If ExtractTest.justHadByteUpdate Then
///             Console.SetCursorPosition(0, Console.CursorTop)
///         End If
///         Console.Write("   {0}/{1} ({2:N0}%)", e.BytesTransferred, e.TotalBytesToTransfer, (CDbl(e.BytesTransferred) / (0.01 * e.TotalBytesToTransfer)))
///         ExtractTest.justHadByteUpdate = True
///     ElseIf (e.EventType = ZipProgressEventType.Extracting_BeforeExtractEntry) Then
///         If ExtractTest.justHadByteUpdate Then
///             Console.WriteLine
///         End If
///         Console.WriteLine("Extracting: {0}", e.CurrentEntry.FileName)
///         ExtractTest.justHadByteUpdate = False
///     End If
/// End Sub
/// </code>
/// </example>
///
/// <seealso cref="Ionic.Zip.ZipFile.SaveProgress"/>
/// <seealso cref="Ionic.Zip.ZipFile.ReadProgress"/>
/// <seealso cref="Ionic.Zip.ZipFile.AddProgress"/>
// Can be called from within ZipEntry._ExtractOne.
// Can be called from within ZipEntry.InternalExtract.
/// <summary>
/// An event handler invoked before, during, and after Adding entries to a zip archive.
/// </summary>
///
/// <remarks>
///     Adding a large number of entries to a zip file can take a long
///     time.  For example, when calling <see cref="AddDirectory(string)"/> on a
///     directory that contains 50,000 files, it could take 3 minutes or so.
///     This event handler allws an application to track the progress of the Add
///     operation, and to optionally cancel a lengthy Add operation.
/// </remarks>
///
/// <example>
/// <code lang="C#">
///
/// int _numEntriesToAdd= 0;
/// int _numEntriesAdded= 0;
/// void AddProgressHandler(object sender, AddProgressEventArgs e)
/// {
///     switch (e.EventType)
///     {
///         case ZipProgressEventType.Adding_Started:
///             Console.WriteLine("Adding files to the zip...");
///             break;
///         case ZipProgressEventType.Adding_AfterAddEntry:
///             _numEntriesAdded++;
///             Console.WriteLine(String.Format("Adding file {0}/{1} :: {2}",
///                                      _numEntriesAdded, _numEntriesToAdd, e.CurrentEntry.FileName));
///             break;
///         case ZipProgressEventType.Adding_Completed:
///             Console.WriteLine("Added all files");
///             break;
///     }
/// }
///
/// void CreateTheZip()
/// {
///     using (ZipFile zip = new ZipFile())
///     {
///         zip.AddProgress += AddProgressHandler;
///         zip.AddDirectory(System.IO.Path.GetFileName(DirToZip));
///         zip.Save(ZipFileToCreate);
///     }
/// }
///
/// </code>
///
/// <code lang="VB">
///
/// Private Sub AddProgressHandler(ByVal sender As Object, ByVal e As AddProgressEventArgs)
///     Select Case e.EventType
///         Case ZipProgressEventType.Adding_Started
///             Console.WriteLine("Adding files to the zip...")
///             Exit Select
///         Case ZipProgressEventType.Adding_AfterAddEntry
///             Console.WriteLine(String.Format("Adding file {0}", e.CurrentEntry.FileName))
///             Exit Select
///         Case ZipProgressEventType.Adding_Completed
///             Console.WriteLine("Added all files")
///             Exit Select
///     End Select
/// End Sub
///
/// Sub CreateTheZip()
///     Using zip as ZipFile = New ZipFile
///         AddHandler zip.AddProgress, AddressOf AddProgressHandler
///         zip.AddDirectory(System.IO.Path.GetFileName(DirToZip))
///         zip.Save(ZipFileToCreate);
///     End Using
/// End Sub
///
/// </code>
///
/// </example>
///
/// <seealso cref="Ionic.Zip.ZipFile.SaveProgress"/>
/// <seealso cref="Ionic.Zip.ZipFile.ReadProgress"/>
/// <seealso cref="Ionic.Zip.ZipFile.ExtractProgress"/>
// workitem 13371
// workitem 13371
/// <summary>
/// An event that is raised when an error occurs during open or read of files
/// while saving a zip archive.
/// </summary>
///
/// <remarks>
///  <para>
///     Errors can occur as a file is being saved to the zip archive.  For
///     example, the File.Open may fail, or a File.Read may fail, because of
///     lock conflicts or other reasons.  If you add a handler to this event,
///     you can handle such errors in your own code.  If you don't add a
///     handler, the library will throw an exception if it encounters an I/O
///     error during a call to <c>Save()</c>.
///  </para>
///
///  <para>
///    Setting a handler implicitly sets <see cref="ZipFile.ZipErrorAction"/> to
///    <c>ZipErrorAction.InvokeErrorEvent</c>.
///  </para>
///
///  <para>
///    The handler you add applies to all <see cref="ZipEntry"/> items that are
///    subsequently added to the <c>ZipFile</c> instance. If you set this
///    property after you have added items to the <c>ZipFile</c>, but before you
///    have called <c>Save()</c>, errors that occur while saving those items
///    will not cause the error handler to be invoked.
///  </para>
///
///  <para>
///    If you want to handle any errors that occur with any entry in the zip
///    file using the same error handler, then add your error handler once,
///    before adding any entries to the zip archive.
///  </para>
///
///  <para>
///    In the error handler method, you need to set the <see
///    cref="ZipEntry.ZipErrorAction"/> property on the
///    <c>ZipErrorEventArgs.CurrentEntry</c>.  This communicates back to
///    DotNetZip what you would like to do with this particular error.  Within
///    an error handler, if you set the <c>ZipEntry.ZipErrorAction</c> property
///    on the <c>ZipEntry</c> to <c>ZipErrorAction.InvokeErrorEvent</c> or if
///    you don't set it at all, the library will throw the exception. (It is the
///    same as if you had set the <c>ZipEntry.ZipErrorAction</c> property on the
///    <c>ZipEntry</c> to <c>ZipErrorAction.Throw</c>.) If you set the
///    <c>ZipErrorEventArgs.Cancel</c> to true, the entire <c>Save()</c> will be
///    canceled.
///  </para>
///
///  <para>
///    In the case that you use <c>ZipErrorAction.Skip</c>, implying that
///    you want to skip the entry for which there's been an error, DotNetZip
///    tries to seek backwards in the output stream, and truncate all bytes
///    written on behalf of that particular entry. This works only if the
///    output stream is seekable.  It will not work, for example, when using
///    ASPNET's Response.OutputStream.
///  </para>
///
/// </remarks>
///
/// <example>
///
/// This example shows how to use an event handler to handle
/// errors during save of the zip file.
/// <code lang="C#">
///
/// public static void MyZipError(object sender, ZipErrorEventArgs e)
/// {
///     Console.WriteLine("Error saving {0}...", e.FileName);
///     Console.WriteLine("   Exception: {0}", e.exception);
///     ZipEntry entry = e.CurrentEntry;
///     string response = null;
///     // Ask the user whether he wants to skip this error or not
///     do
///     {
///         Console.Write("Retry, Skip, Throw, or Cancel ? (R/S/T/C) ");
///         response = Console.ReadLine();
///         Console.WriteLine();
///
///     } while (response != null &amp;&amp;
///              response[0]!='S' &amp;&amp; response[0]!='s' &amp;&amp;
///              response[0]!='R' &amp;&amp; response[0]!='r' &amp;&amp;
///              response[0]!='T' &amp;&amp; response[0]!='t' &amp;&amp;
///              response[0]!='C' &amp;&amp; response[0]!='c');
///
///     e.Cancel = (response[0]=='C' || response[0]=='c');
///
///     if (response[0]=='S' || response[0]=='s')
///         entry.ZipErrorAction = ZipErrorAction.Skip;
///     else if (response[0]=='R' || response[0]=='r')
///         entry.ZipErrorAction = ZipErrorAction.Retry;
///     else if (response[0]=='T' || response[0]=='t')
///         entry.ZipErrorAction = ZipErrorAction.Throw;
/// }
///
/// public void SaveTheFile()
/// {
///   string directoryToZip = "fodder";
///   string directoryInArchive = "files";
///   string zipFileToCreate = "Archive.zip";
///   using (var zip = new ZipFile())
///   {
///     // set the event handler before adding any entries
///     zip.ZipError += MyZipError;
///     zip.AddDirectory(directoryToZip, directoryInArchive);
///     zip.Save(zipFileToCreate);
///   }
/// }
/// </code>
///
/// <code lang="VB">
/// Private Sub MyZipError(ByVal sender As Object, ByVal e As Ionic.Zip.ZipErrorEventArgs)
///     ' At this point, the application could prompt the user for an action to take.
///     ' But in this case, this application will simply automatically skip the file, in case of error.
///     Console.WriteLine("Zip Error,  entry {0}", e.CurrentEntry.FileName)
///     Console.WriteLine("   Exception: {0}", e.exception)
///     ' set the desired ZipErrorAction on the CurrentEntry to communicate that to DotNetZip
///     e.CurrentEntry.ZipErrorAction = Zip.ZipErrorAction.Skip
/// End Sub
///
/// Public Sub SaveTheFile()
///     Dim directoryToZip As String = "fodder"
///     Dim directoryInArchive As String = "files"
///     Dim zipFileToCreate as String = "Archive.zip"
///     Using zipArchive As ZipFile = New ZipFile
///         ' set the event handler before adding any entries
///         AddHandler zipArchive.ZipError, AddressOf MyZipError
///         zipArchive.AddDirectory(directoryToZip, directoryInArchive)
///         zipArchive.Save(zipFileToCreate)
///     End Using
/// End Sub
///
/// </code>
/// </example>
///
/// <seealso cref="Ionic.Zip.ZipFile.ZipErrorAction"/>
// ZipFile.Extract.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-July-31 14:45:18>
//
// ------------------------------------------------------------------
//
// This module defines the methods for Extract operations on zip files.
//
// ------------------------------------------------------------------
//
/// <summary>
/// Extracts all of the items in the zip archive, to the specified path in the
/// filesystem.  The path can be relative or fully-qualified.
/// </summary>
///
/// <remarks>
/// <para>
///   This method will extract all entries in the <c>ZipFile</c> to the
///   specified path.
/// </para>
///
/// <para>
///   If an extraction of a file from the zip archive would overwrite an
///   existing file in the filesystem, the action taken is dictated by the
///   ExtractExistingFile property, which overrides any setting you may have
///   made on individual ZipEntry instances.  By default, if you have not
///   set that property on the <c>ZipFile</c> instance, the entry will not
///   be extracted, the existing file will not be overwritten and an
///   exception will be thrown. To change this, set the property, or use the
///   <see cref="ZipFile.ExtractAll(string,
///   Ionic.Zip.ExtractExistingFileAction)" /> overload that allows you to
///   specify an ExtractExistingFileAction parameter.
/// </para>
///
/// <para>
///   The action to take when an extract would overwrite an existing file
///   applies to all entries.  If you want to set this on a per-entry basis,
///   then you must use one of the <see
///   cref="ZipEntry.Extract()">ZipEntry.Extract</see> methods.
/// </para>
///
/// <para>
///   This method will send verbose output messages to the <see
///   cref="StatusMessageTextWriter"/>, if it is set on the <c>ZipFile</c>
///   instance.
/// </para>
///
/// <para>
/// You may wish to take advantage of the <c>ExtractProgress</c> event.
/// </para>
///
/// <para>
///   About timestamps: When extracting a file entry from a zip archive, the
///   extracted file gets the last modified time of the entry as stored in
///   the archive. The archive may also store extended file timestamp
///   information, including last accessed and created times. If these are
///   present in the <c>ZipEntry</c>, then the extracted file will also get
///   these times.
/// </para>
///
/// <para>
///   A Directory entry is somewhat different. It will get the times as
///   described for a file entry, but, if there are file entries in the zip
///   archive that, when extracted, appear in the just-created directory,
///   then when those file entries are extracted, the last modified and last
///   accessed times of the directory will change, as a side effect.  The
///   result is that after an extraction of a directory and a number of
///   files within the directory, the last modified and last accessed
///   timestamps on the directory will reflect the time that the last file
///   was extracted into the directory, rather than the time stored in the
///   zip archive for the directory.
/// </para>
///
/// <para>
///   To compensate, when extracting an archive with <c>ExtractAll</c>,
///   DotNetZip will extract all the file and directory entries as described
///   above, but it will then make a second pass on the directories, and
///   reset the times on the directories to reflect what is stored in the
///   zip archive.
/// </para>
///
/// <para>
///   This compensation is performed only within the context of an
///   <c>ExtractAll</c>. If you call <c>ZipEntry.Extract</c> on a directory
///   entry, the timestamps on directory in the filesystem will reflect the
///   times stored in the zip.  If you then call <c>ZipEntry.Extract</c> on
///   a file entry, which is extracted into the directory, the timestamps on
///   the directory will be updated to the current time.
/// </para>
/// </remarks>
///
/// <example>
///   This example extracts all the entries in a zip archive file, to the
///   specified target directory.  The extraction will overwrite any
///   existing files silently.
///
/// <code>
/// String TargetDirectory= "unpack";
/// using(ZipFile zip= ZipFile.Read(ZipFileToExtract))
/// {
///     zip.ExtractExistingFile= ExtractExistingFileAction.OverwriteSilently;
///     zip.ExtractAll(TargetDirectory);
/// }
/// </code>
///
/// <code lang="VB">
/// Dim TargetDirectory As String = "unpack"
/// Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
///     zip.ExtractExistingFile= ExtractExistingFileAction.OverwriteSilently
///     zip.ExtractAll(TargetDirectory)
/// End Using
/// </code>
/// </example>
///
/// <seealso cref="Ionic.Zip.ZipFile.ExtractProgress"/>
/// <seealso cref="Ionic.Zip.ZipFile.ExtractExistingFile"/>
///
/// <param name="path">
///   The path to which the contents of the zipfile will be extracted.
///   The path can be relative or fully-qualified.
/// </param>
///
/// <summary>
/// Extracts all of the items in the zip archive, to the specified path in the
/// filesystem, using the specified behavior when extraction would overwrite an
/// existing file.
/// </summary>
///
/// <remarks>
///
/// <para>
/// This method will extract all entries in the <c>ZipFile</c> to the specified
/// path.  For an extraction that would overwrite an existing file, the behavior
/// is dictated by <paramref name="extractExistingFile"/>, which overrides any
/// setting you may have made on individual ZipEntry instances.
/// </para>
///
/// <para>
/// The action to take when an extract would overwrite an existing file
/// applies to all entries.  If you want to set this on a per-entry basis,
/// then you must use <see cref="ZipEntry.Extract(String,
/// ExtractExistingFileAction)" /> or one of the similar methods.
/// </para>
///
/// <para>
/// Calling this method is equivalent to setting the <see
/// cref="ExtractExistingFile"/> property and then calling <see
/// cref="ExtractAll(String)"/>.
/// </para>
///
/// <para>
/// This method will send verbose output messages to the
/// <see cref="StatusMessageTextWriter"/>, if it is set on the <c>ZipFile</c> instance.
/// </para>
/// </remarks>
///
/// <example>
/// This example extracts all the entries in a zip archive file, to the
/// specified target directory.  It does not overwrite any existing files.
/// <code>
/// String TargetDirectory= "c:\\unpack";
/// using(ZipFile zip= ZipFile.Read(ZipFileToExtract))
/// {
///   zip.ExtractAll(TargetDirectory, ExtractExistingFileAction.DontOverwrite);
/// }
/// </code>
///
/// <code lang="VB">
/// Dim TargetDirectory As String = "c:\unpack"
/// Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
///     zip.ExtractAll(TargetDirectory, ExtractExistingFileAction.DontOverwrite)
/// End Using
/// </code>
/// </example>
///
/// <param name="path">
/// The path to which the contents of the zipfile will be extracted.
/// The path can be relative or fully-qualified.
/// </param>
///
/// <param name="extractExistingFile">
/// The action to take if extraction would overwrite an existing file.
/// </param>
/// <seealso cref="ExtractSelectedEntries(String,ExtractExistingFileAction)"/>
// this may be null
// workitem 8264:
// now, set times on directory entries, again.
// The problem is, extracting a file changes the times on the parent
// directory.  So after all files have been extracted, we have to
// run through the directories again.
// check if it is a directory
// ZipFile.Read.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2011 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-August-05 11:38:59>
//
// ------------------------------------------------------------------
//
// This module defines the methods for Reading zip files.
//
// ------------------------------------------------------------------
//
/// <summary>
///   A class for collecting the various options that can be used when
///   Reading zip files for extraction or update.
/// </summary>
///
/// <remarks>
///   <para>
///     When reading a zip file, there are several options an
///     application can set, to modify how the file is read, or what
///     the library does while reading.  This class collects those
///     options into one container.
///   </para>
///
///   <para>
///     Pass an instance of the <c>ReadOptions</c> class into the
///     <c>ZipFile.Read()</c> method.
///   </para>
///
/// <seealso cref="ZipFile.Read(String, ReadOptions)"/>.
/// <seealso cref="ZipFile.Read(Stream, ReadOptions)"/>.
/// </remarks>
/// <summary>
/// An event handler for Read operations.  When opening large zip
/// archives, you may want to display a progress bar or other
/// indicator of status progress while reading.  This parameter
/// allows you to specify a ReadProgress Event Handler directly.
/// When you call <c>Read()</c>, the progress event is invoked as
/// necessary.
/// </summary>
/// <summary>
/// The <c>System.IO.TextWriter</c> to use for writing verbose status messages
/// during operations on the zip archive.  A console application may wish to
/// pass <c>System.Console.Out</c> to get messages on the Console. A graphical
/// or headless application may wish to capture the messages in a different
/// <c>TextWriter</c>, such as a <c>System.IO.StringWriter</c>.
/// </summary>
/// <summary>
/// The <c>System.Text.Encoding</c> to use when reading in the zip archive. Be
/// careful specifying the encoding.  If the value you use here is not the same
/// as the Encoding used when the zip archive was created (possibly by a
/// different archiver) you will get unexpected results and possibly exceptions.
/// </summary>
///
/// <seealso cref="ZipFile.ProvisionalAlternateEncoding"/>
///
/// <summary>
/// Reads a zip file archive and returns the instance.
/// </summary>
///
/// <remarks>
/// <para>
/// The stream is read using the default <c>System.Text.Encoding</c>, which is the
/// <c>IBM437</c> codepage.
/// </para>
/// </remarks>
///
/// <exception cref="System.Exception">
/// Thrown if the <c>ZipFile</c> cannot be read. The implementation of this method
/// relies on <c>System.IO.File.OpenRead</c>, which can throw a variety of exceptions,
/// including specific exceptions if a file is not found, an unauthorized access
/// exception, exceptions for poorly formatted filenames, and so on.
/// </exception>
///
/// <param name="fileName">
/// The name of the zip archive to open.  This can be a fully-qualified or relative
/// pathname.
/// </param>
///
/// <seealso cref="ZipFile.Read(String, ReadOptions)"/>.
///
/// <returns>The instance read from the zip archive.</returns>
///
/// <summary>
///   Reads a zip file archive from the named filesystem file using the
///   specified options.
/// </summary>
///
/// <remarks>
/// <para>
///   This version of the <c>Read()</c> method allows the caller to pass
///   in a <c>TextWriter</c> an <c>Encoding</c>, via an instance of the
///   <c>ReadOptions</c> class.  The <c>ZipFile</c> is read in using the
///   specified encoding for entries where UTF-8 encoding is not
///   explicitly specified.
/// </para>
/// </remarks>
///
/// <example>
///
/// <para>
///   This example shows how to read a zip file using the Big-5 Chinese
///   code page (950), and extract each entry in the zip file, while
///   sending status messages out to the Console.
/// </para>
///
/// <para>
///   For this code to work as intended, the zipfile must have been
///   created using the big5 code page (CP950). This is typical, for
///   example, when using WinRar on a machine with CP950 set as the
///   default code page.  In that case, the names of entries within the
///   Zip archive will be stored in that code page, and reading the zip
///   archive must be done using that code page.  If the application did
///   not use the correct code page in ZipFile.Read(), then names of
///   entries within the zip archive would not be correctly retrieved.
/// </para>
///
/// <code lang="C#">
/// string zipToExtract = "MyArchive.zip";
/// string extractDirectory = "extract";
/// var options = new ReadOptions
/// {
///   StatusMessageWriter = System.Console.Out,
///   Encoding = System.Text.Encoding.GetEncoding(950)
/// };
/// using (ZipFile zip = ZipFile.Read(zipToExtract, options))
/// {
///   foreach (ZipEntry e in zip)
///   {
///      e.Extract(extractDirectory);
///   }
/// }
/// </code>
///
///
/// <code lang="VB">
/// Dim zipToExtract as String = "MyArchive.zip"
/// Dim extractDirectory as String = "extract"
/// Dim options as New ReadOptions
/// options.Encoding = System.Text.Encoding.GetEncoding(950)
/// options.StatusMessageWriter = System.Console.Out
/// Using zip As ZipFile = ZipFile.Read(zipToExtract, options)
///     Dim e As ZipEntry
///     For Each e In zip
///      e.Extract(extractDirectory)
///     Next
/// End Using
/// </code>
/// </example>
///
///
/// <example>
///
/// <para>
///   This example shows how to read a zip file using the default
///   code page, to remove entries that have a modified date before a given threshold,
///   sending status messages out to a <c>StringWriter</c>.
/// </para>
///
/// <code lang="C#">
/// var options = new ReadOptions
/// {
///   StatusMessageWriter = new System.IO.StringWriter()
/// };
/// using (ZipFile zip =  ZipFile.Read("PackedDocuments.zip", options))
/// {
///   var Threshold = new DateTime(2007,7,4);
///   // We cannot remove the entry from the list, within the context of
///   // an enumeration of said list.
///   // So we add the doomed entry to a list to be removed later.
///   // pass 1: mark the entries for removal
///   var MarkedEntries = new System.Collections.Generic.List&lt;ZipEntry&gt;();
///   foreach (ZipEntry e in zip)
///   {
///     if (e.LastModified &lt; Threshold)
///       MarkedEntries.Add(e);
///   }
///   // pass 2: actually remove the entry.
///   foreach (ZipEntry zombie in MarkedEntries)
///      zip.RemoveEntry(zombie);
///   zip.Comment = "This archive has been updated.";
///   zip.Save();
/// }
/// // can now use contents of sw, eg store in an audit log
/// </code>
///
/// <code lang="VB">
/// Dim options as New ReadOptions
/// options.StatusMessageWriter = New System.IO.StringWriter
/// Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip", options)
///     Dim Threshold As New DateTime(2007, 7, 4)
///     ' We cannot remove the entry from the list, within the context of
///     ' an enumeration of said list.
///     ' So we add the doomed entry to a list to be removed later.
///     ' pass 1: mark the entries for removal
///     Dim MarkedEntries As New System.Collections.Generic.List(Of ZipEntry)
///     Dim e As ZipEntry
///     For Each e In zip
///         If (e.LastModified &lt; Threshold) Then
///             MarkedEntries.Add(e)
///         End If
///     Next
///     ' pass 2: actually remove the entry.
///     Dim zombie As ZipEntry
///     For Each zombie In MarkedEntries
///         zip.RemoveEntry(zombie)
///     Next
///     zip.Comment = "This archive has been updated."
///     zip.Save
/// End Using
/// ' can now use contents of sw, eg store in an audit log
/// </code>
/// </example>
///
/// <exception cref="System.Exception">
///   Thrown if the zipfile cannot be read. The implementation of
///   this method relies on <c>System.IO.File.OpenRead</c>, which
///   can throw a variety of exceptions, including specific
///   exceptions if a file is not found, an unauthorized access
///   exception, exceptions for poorly formatted filenames, and so
///   on.
/// </exception>
///
/// <param name="fileName">
/// The name of the zip archive to open.
/// This can be a fully-qualified or relative pathname.
/// </param>
///
/// <param name="options">
/// The set of options to use when reading the zip file.
/// </param>
///
/// <returns>The ZipFile instance read from the zip archive.</returns>
///
/// <seealso cref="ZipFile.Read(Stream, ReadOptions)"/>
///
/// <summary>
/// Reads a zip file archive using the specified text encoding,  the specified
/// TextWriter for status messages, and the specified ReadProgress event handler,
/// and returns the instance.
/// </summary>
///
/// <param name="fileName">
/// The name of the zip archive to open.
/// This can be a fully-qualified or relative pathname.
/// </param>
///
/// <param name="readProgress">
/// An event handler for Read operations.
/// </param>
///
/// <param name="statusMessageWriter">
/// The <c>System.IO.TextWriter</c> to use for writing verbose status messages
/// during operations on the zip archive.  A console application may wish to
/// pass <c>System.Console.Out</c> to get messages on the Console. A graphical
/// or headless application may wish to capture the messages in a different
/// <c>TextWriter</c>, such as a <c>System.IO.StringWriter</c>.
/// </param>
///
/// <param name="encoding">
/// The <c>System.Text.Encoding</c> to use when reading in the zip archive. Be
/// careful specifying the encoding.  If the value you use here is not the same
/// as the Encoding used when the zip archive was created (possibly by a
/// different archiver) you will get unexpected results and possibly exceptions.
/// </param>
///
/// <returns>The instance read from the zip archive.</returns>
///
/// <summary>
///   Reads a zip archive from a stream.
/// </summary>
///
/// <remarks>
///
/// <para>
///   When reading from a file, it's probably easier to just use
///   <see cref="ZipFile.Read(String,
///   ReadOptions)">ZipFile.Read(String, ReadOptions)</see>.  This
///   overload is useful when when the zip archive content is
///   available from an already-open stream. The stream must be
///   open and readable and seekable when calling this method.  The
///   stream is left open when the reading is completed.
/// </para>
///
/// <para>
///   Using this overload, the stream is read using the default
///   <c>System.Text.Encoding</c>, which is the <c>IBM437</c>
///   codepage. If you want to specify the encoding to use when
///   reading the zipfile content, see
///   <see cref="ZipFile.Read(Stream,
///   ReadOptions)">ZipFile.Read(Stream, ReadOptions)</see>.  This
/// </para>
///
/// <para>
///   Reading of zip content begins at the current position in the
///   stream.  This means if you have a stream that concatenates
///   regular data and zip data, if you position the open, readable
///   stream at the start of the zip data, you will be able to read
///   the zip archive using this constructor, or any of the ZipFile
///   constructors that accept a <see cref="System.IO.Stream" /> as
///   input. Some examples of where this might be useful: the zip
///   content is concatenated at the end of a regular EXE file, as
///   some self-extracting archives do.  (Note: SFX files produced
///   by DotNetZip do not work this way; they can be read as normal
///   ZIP files). Another example might be a stream being read from
///   a database, where the zip content is embedded within an
///   aggregate stream of data.
/// </para>
///
/// </remarks>
///
/// <example>
/// <para>
///   This example shows how to Read zip content from a stream, and
///   extract one entry into a different stream. In this example,
///   the filename "NameOfEntryInArchive.doc", refers only to the
///   name of the entry within the zip archive.  A file by that
///   name is not created in the filesystem.  The I/O is done
///   strictly with the given streams.
/// </para>
///
/// <code>
/// using (ZipFile zip = ZipFile.Read(InputStream))
/// {
///    zip.Extract("NameOfEntryInArchive.doc", OutputStream);
/// }
/// </code>
///
/// <code lang="VB">
/// Using zip as ZipFile = ZipFile.Read(InputStream)
///    zip.Extract("NameOfEntryInArchive.doc", OutputStream)
/// End Using
/// </code>
/// </example>
///
/// <param name="zipStream">the stream containing the zip data.</param>
///
/// <returns>The ZipFile instance read from the stream</returns>
///
/// <summary>
///   Reads a zip file archive from the given stream using the
///   specified options.
/// </summary>
///
/// <remarks>
///
/// <para>
///   When reading from a file, it's probably easier to just use
///   <see cref="ZipFile.Read(String,
///   ReadOptions)">ZipFile.Read(String, ReadOptions)</see>.  This
///   overload is useful when when the zip archive content is
///   available from an already-open stream. The stream must be
///   open and readable and seekable when calling this method.  The
///   stream is left open when the reading is completed.
/// </para>
///
/// <para>
///   Reading of zip content begins at the current position in the
///   stream.  This means if you have a stream that concatenates
///   regular data and zip data, if you position the open, readable
///   stream at the start of the zip data, you will be able to read
///   the zip archive using this constructor, or any of the ZipFile
///   constructors that accept a <see cref="System.IO.Stream" /> as
///   input. Some examples of where this might be useful: the zip
///   content is concatenated at the end of a regular EXE file, as
///   some self-extracting archives do.  (Note: SFX files produced
///   by DotNetZip do not work this way; they can be read as normal
///   ZIP files). Another example might be a stream being read from
///   a database, where the zip content is embedded within an
///   aggregate stream of data.
/// </para>
/// </remarks>
///
/// <param name="zipStream">the stream containing the zip data.</param>
///
/// <param name="options">
///   The set of options to use when reading the zip file.
/// </param>
///
/// <exception cref="System.Exception">
///   Thrown if the zip archive cannot be read.
/// </exception>
///
/// <returns>The ZipFile instance read from the stream.</returns>
///
/// <seealso cref="ZipFile.Read(String, ReadOptions)"/>
///
/// <summary>
/// Reads a zip archive from a stream, using the specified text Encoding, the
/// specified TextWriter for status messages,
/// and the specified ReadProgress event handler.
/// </summary>
///
/// <remarks>
/// <para>
/// Reading of zip content begins at the current position in the stream.  This
/// means if you have a stream that concatenates regular data and zip data, if
/// you position the open, readable stream at the start of the zip data, you
/// will be able to read the zip archive using this constructor, or any of the
/// ZipFile constructors that accept a <see cref="System.IO.Stream" /> as
/// input. Some examples of where this might be useful: the zip content is
/// concatenated at the end of a regular EXE file, as some self-extracting
/// archives do.  (Note: SFX files produced by DotNetZip do not work this
/// way). Another example might be a stream being read from a database, where
/// the zip content is embedded within an aggregate stream of data.
/// </para>
/// </remarks>
///
/// <param name="zipStream">the stream containing the zip data.</param>
///
/// <param name="statusMessageWriter">
/// The <c>System.IO.TextWriter</c> to which verbose status messages are written
/// during operations on the <c>ZipFile</c>.  For example, in a console
/// application, System.Console.Out works, and will get a message for each entry
/// added to the ZipFile.  If the TextWriter is <c>null</c>, no verbose messages
/// are written.
/// </param>
///
/// <param name="encoding">
/// The text encoding to use when reading entries that do not have the UTF-8
/// encoding bit set.  Be careful specifying the encoding.  If the value you use
/// here is not the same as the Encoding used when the zip archive was created
/// (possibly by a different archiver) you will get unexpected results and
/// possibly exceptions.  See the <see cref="ProvisionalAlternateEncoding"/>
/// property for more information.
/// </param>
///
/// <param name="readProgress">
/// An event handler for Read operations.
/// </param>
///
/// <returns>an instance of ZipFile</returns>
// workitem 13915
// change for workitem 8098
//zf._originPosition = s.Position;
// Try reading the central directory, rather than scanning the file.
// start at the end of the file...
// seek backwards a bit, then look for the EoCD signature.
// The size of the end-of-central-directory-footer plus 2 bytes is 18.
// This implies an archive comment length of 0.  We'll add a margin of
// safety and start "in front" of that, when looking for the
// EndOfCentralDirectorySignature
// BOF
// started at the BOF and found nothing
// Weird: with NETCF, negative offsets from SeekOrigin.End DO
// NOT WORK. So rather than seek a negative offset, we seek
// from SeekOrigin.Begin using a smaller number.
//
// We no longer target NETCF, so somebody feeling brave could
// restore the (very) old code.
// workitem 8299
// I think the number in the file differs from reality by 1
// change for workitem 8098
// Could not find the central directory.
// Fallback to the old method.
// workitem 8098: ok
//s.Seek(zf._originPosition, SeekOrigin.Begin);
// the instance has been read in
// seek back to find the ZIP64 EoCD.
// change for workitem 8098
//zf.SeekFromOrigin(Offset64);
// change for workitem 8098
//zf.SeekFromOrigin(Offset64);
// We must have the central directory footer record, in order to properly
// read zip dir entries from the central directory.  This because the logic
// knows when to open a spanned file when the volume number for the central
// directory differs from the volume number for the zip entry.  The
// _diskNumberWithCd was set when originally finding the offset for the
// start of the Central Directory.
// workitem 9214
// in lieu of hashset, use a dictionary
// workitem 9214
// to prevent dupes
// workitem 9214; auto-set the zip64 flag
// workitem 8299
// We keep the read stream open after reading.
// build the TOC by reading each entry in the file.
// work item 6647:  PK00 (packed to removable disk)
// read the zipfile's central directory structure here.
// workitem 9912
// But, because it may be corrupted, ignore errors.
// in lieu of hashset, use a dictionary
// Housekeeping: Since ZipFile exposes ZipEntry elements in the enumerator,
// we need to copy the comment that we grab from the ZipDirEntry
// into the ZipEntry, so the application can access the comment.
// Also since ZipEntry is used to Write zip files, we need to copy the
// file attributes to the ZipEntry as appropriate.
// to prevent dupes
// workitem 8299
// We have a ZIP64 EOCD
// This data block is 4 bytes sig, 8 bytes size, 44 bytes fixed data,
// followed by a variable-sized extension block.  We have read the sig already.
// 8 - datasize (64 bits)
// 2 - version made by
// 2 - version needed to extract
// 4 - number of this disk
// 4 - number of the disk with the start of the CD
// 8 - total number of entries in the CD on this disk
// 8 - total number of entries in the CD
// 8 - size of the CD
// 8 - offset of the CD
// -----------------------
// 52 bytes
// == 44 + the variable length
//zf._diskNumberWithCd++; // hack!!
// read the extended block
// discard the result
// discard the result
// Throw if this is not a signature for "end of central directory record"
// This is a sanity check.
// read the End-of-Central-Directory-Record
// off sz  data
// -------------------------------------------------------
//  0   4  end of central dir signature (0x06054b50)
//  4   2  number of this disk
//  6   2  number of the disk with start of the central directory
//  8   2  total number of entries in the  central directory on this disk
// 10   2  total number of entries in  the central directory
// 12   4  size of the central directory
// 16   4  offset of start of central directory with respect to the starting disk number
// 20   2  ZIP file comment length
// 22  ??  ZIP file comment
//zf._diskNumberWithCd++; // hack!!
// read the comment here
// read the comment here
// workitem 10392 - prefer ProvisionalAlternateEncoding,
// first.  The fix for workitem 6513 tried to use UTF8
// only as necessary, but that is impossible to test
// for, in this direction. There's no way to know what
// characters the already-encoded bytes refer
// to. Therefore, must do what the user tells us.
// private static bool BlocksAreEqual(byte[] a, byte[] b)
// {
//     if (a.Length != b.Length) return false;
//     for (int i = 0; i < a.Length; i++)
//     {
//         if (a[i] != b[i]) return false;
//     }
//     return true;
// }
/// <summary>
/// Checks the given file to see if it appears to be a valid zip file.
/// </summary>
/// <remarks>
///
/// <para>
///   Calling this method is equivalent to calling <see cref="IsZipFile(string,
///   bool)"/> with the testExtract parameter set to false.
/// </para>
/// </remarks>
///
/// <param name="fileName">The file to check.</param>
/// <returns>true if the file appears to be a zip file.</returns>
/// <summary>
/// Checks a file to see if it is a valid zip file.
/// </summary>
///
/// <remarks>
/// <para>
///   This method opens the specified zip file, reads in the zip archive,
///   verifying the ZIP metadata as it reads.
/// </para>
///
/// <para>
///   If everything succeeds, then the method returns true.  If anything fails -
///   for example if an incorrect signature or CRC is found, indicating a
///   corrupt file, the the method returns false.  This method also returns
///   false for a file that does not exist.
/// </para>
///
/// <para>
///   If <paramref name="testExtract"/> is true, as part of its check, this
///   method reads in the content for each entry, expands it, and checks CRCs.
///   This provides an additional check beyond verifying the zip header and
///   directory data.
/// </para>
///
/// <para>
///   If <paramref name="testExtract"/> is true, and if any of the zip entries
///   are protected with a password, this method will return false.  If you want
///   to verify a <c>ZipFile</c> that has entries which are protected with a
///   password, you will need to do that manually.
/// </para>
///
/// </remarks>
///
/// <param name="fileName">The zip file to check.</param>
/// <param name="testExtract">true if the caller wants to extract each entry.</param>
/// <returns>true if the file contains a valid zip file.</returns>
/// <summary>
/// Checks a stream to see if it contains a valid zip archive.
/// </summary>
///
/// <remarks>
/// <para>
/// This method reads the zip archive contained in the specified stream, verifying
/// the ZIP metadata as it reads.  If testExtract is true, this method also extracts
/// each entry in the archive, dumping all the bits into <see cref="Stream.Null"/>.
/// </para>
///
/// <para>
/// If everything succeeds, then the method returns true.  If anything fails -
/// for example if an incorrect signature or CRC is found, indicating a corrupt
/// file, the the method returns false.  This method also returns false for a
/// file that does not exist.
/// </para>
///
/// <para>
/// If <c>testExtract</c> is true, this method reads in the content for each
/// entry, expands it, and checks CRCs.  This provides an additional check
/// beyond verifying the zip header data.
/// </para>
///
/// <para>
/// If <c>testExtract</c> is true, and if any of the zip entries are protected
/// with a password, this method will return false.  If you want to verify a
/// ZipFile that has entries which are protected with a password, you will need
/// to do that manually.
/// </para>
/// </remarks>
///
/// <seealso cref="IsZipFile(string, bool)"/>
///
/// <param name="stream">The stream to check.</param>
/// <param name="testExtract">true if the caller wants to extract each entry.</param>
/// <returns>true if the stream contains a valid zip archive.</returns>
// ZipFile.Save.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-August-05 13:31:23>
//
// ------------------------------------------------------------------
//
// This module defines the methods for Save operations on zip files.
//
// ------------------------------------------------------------------
//
/// <summary>
///   Delete file with retry on UnauthorizedAccessException.
/// </summary>
///
/// <remarks>
///   <para>
///     When calling File.Delete() on a file that has been "recently"
///     created, the call sometimes fails with
///     UnauthorizedAccessException. This method simply retries the Delete 3
///     times with a sleep between tries.
///   </para>
/// </remarks>
///
/// <param name='filename'>the name of the file to be deleted</param>
/// <summary>
///   Saves the Zip archive to a file, specified by the Name property of the
///   <c>ZipFile</c>.
/// </summary>
///
/// <remarks>
/// <para>
///   The <c>ZipFile</c> instance is written to storage, typically a zip file
///   in a filesystem, only when the caller calls <c>Save</c>.  In the typical
///   case, the Save operation writes the zip content to a temporary file, and
///   then renames the temporary file to the desired name. If necessary, this
///   method will delete a pre-existing file before the rename.
/// </para>
///
/// <para>
///   The <see cref="ZipFile.Name"/> property is specified either explicitly,
///   or implicitly using one of the parameterized ZipFile constructors.  For
///   COM Automation clients, the <c>Name</c> property must be set explicitly,
///   because COM Automation clients cannot call parameterized constructors.
/// </para>
///
/// <para>
///   When using a filesystem file for the Zip output, it is possible to call
///   <c>Save</c> multiple times on the <c>ZipFile</c> instance. With each
///   call the zip content is re-written to the same output file.
/// </para>
///
/// <para>
///   Data for entries that have been added to the <c>ZipFile</c> instance is
///   written to the output when the <c>Save</c> method is called. This means
///   that the input streams for those entries must be available at the time
///   the application calls <c>Save</c>.  If, for example, the application
///   adds entries with <c>AddEntry</c> using a dynamically-allocated
///   <c>MemoryStream</c>, the memory stream must not have been disposed
///   before the call to <c>Save</c>. See the <see
///   cref="ZipEntry.InputStream"/> property for more discussion of the
///   availability requirements of the input stream for an entry, and an
///   approach for providing just-in-time stream lifecycle management.
/// </para>
///
/// </remarks>
///
/// <seealso cref="Ionic.Zip.ZipFile.AddEntry(String, System.IO.Stream)"/>
///
/// <exception cref="Ionic.Zip.BadStateException">
///   Thrown if you haven't specified a location or stream for saving the zip,
///   either in the constructor or by setting the Name property, or if you try
///   to save a regular zip archive to a filename with a .exe extension.
/// </exception>
///
/// <exception cref="System.OverflowException">
///   Thrown if <see cref="MaxOutputSegmentSize"/> or <see cref="MaxOutputSegmentSize64"/> is non-zero, and the number
///   of segments that would be generated for the spanned zip file during the
///   save operation exceeds 99.  If this happens, you need to increase the
///   segment size.
/// </exception>
///
// check if modified, before saving.
// validate the number of entries
// write an entry in the zip for each file
// workitem 9831
// _entries.Values
// Some entries can be skipped during the save.
// This means we opened and read a zip file.
// If we are now saving, we need to close the orig file, first.
// the archiveStream for each entry needs to be null
// do the rename as necessary
// _temporaryFileName may remain null if we are writing to a stream.
// only close the stream if there is a file behind it.
// the steps:
//
// 1. Delete tmpName
// 2. move existing zip to tmpName
// 3. rename (File.Move) working file to name of existing zip
// 4. delete tmpName
//
// This series of steps avoids the exception,
// System.IO.IOException:
//   "Cannot create a file when that file already exists."
//
// Cannot just call File.Replace() here because
// there is a possibility that the TEMP volume is different
// that the volume for the final file (c:\ vs d:\).
// So we need to do a Delete+Move pair.
//
// But, when doing the delete, Windows allows a process to
// delete the file, even though it is held open by, say, a
// virus scanner. It gets internally marked as "delete
// pending". The file does not actually get removed from the
// file system, it is still there after the File.Delete
// call.
//
// Therefore, we need to move the existing zip, which may be
// held open, to some other name. Then rename our working
// file to the desired name, then delete (possibly delete
// pending) the "other name".
//
// Ideally this would be transactional. It's possible that the
// delete succeeds and the move fails. Lacking transactions, if
// this kind of failure happens, we're hosed, and this logic will
// throw on the next File.Move().
//
//File.Delete(_name);
// workitem 10447
// not critical
// don't care about exceptions here.
// workitem 5043
// close the stream if there is a file behind it.
// workitem 7704
/// <summary>
/// Save the file to a new zipfile, with the given name.
/// </summary>
///
/// <remarks>
/// <para>
/// This method allows the application to explicitly specify the name of the zip
/// file when saving. Use this when creating a new zip file, or when
/// updating a zip archive.
/// </para>
///
/// <para>
/// An application can also save a zip archive in several places by calling this
/// method multiple times in succession, with different filenames.
/// </para>
///
/// <para>
/// The <c>ZipFile</c> instance is written to storage, typically a zip file in a
/// filesystem, only when the caller calls <c>Save</c>.  The Save operation writes
/// the zip content to a temporary file, and then renames the temporary file
/// to the desired name. If necessary, this method will delete a pre-existing file
/// before the rename.
/// </para>
///
/// </remarks>
///
/// <exception cref="System.ArgumentException">
/// Thrown if you specify a directory for the filename.
/// </exception>
///
/// <param name="fileName">
/// The name of the zip archive to save to. Existing files will
/// be overwritten with great prejudice.
/// </param>
///
/// <example>
/// This example shows how to create and Save a zip file.
/// <code>
/// using (ZipFile zip = new ZipFile())
/// {
///   zip.AddDirectory(@"c:\reports\January");
///   zip.Save("January.zip");
/// }
/// </code>
///
/// <code lang="VB">
/// Using zip As New ZipFile()
///   zip.AddDirectory("c:\reports\January")
///   zip.Save("January.zip")
/// End Using
/// </code>
///
/// </example>
///
/// <example>
/// This example shows how to update a zip file.
/// <code>
/// using (ZipFile zip = ZipFile.Read("ExistingArchive.zip"))
/// {
///   zip.AddFile("NewData.csv");
///   zip.Save("UpdatedArchive.zip");
/// }
/// </code>
///
/// <code lang="VB">
/// Using zip As ZipFile = ZipFile.Read("ExistingArchive.zip")
///   zip.AddFile("NewData.csv")
///   zip.Save("UpdatedArchive.zip")
/// End Using
/// </code>
///
/// </example>
// Check for the case where we are re-saving a zip archive
// that was originally instantiated with a stream.  In that case,
// the _name will be null. If so, we set _writestream to null,
// which insures that we'll cons up a new WriteStream (with a filesystem
// file backing it) in the Save() method.
// workitem 13915
/// <summary>
///   Save the zip archive to the specified stream.
/// </summary>
///
/// <remarks>
/// <para>
///   The <c>ZipFile</c> instance is written to storage - typically a zip file
///   in a filesystem, but using this overload, the storage can be anything
///   accessible via a writable stream - only when the caller calls <c>Save</c>.
/// </para>
///
/// <para>
///   Use this method to save the zip content to a stream directly.  A common
///   scenario is an ASP.NET application that dynamically generates a zip file
///   and allows the browser to download it. The application can call
///   <c>Save(Response.OutputStream)</c> to write a zipfile directly to the
///   output stream, without creating a zip file on the disk on the ASP.NET
///   server.
/// </para>
///
/// <para>
///   Be careful when saving a file to a non-seekable stream, including
///   <c>Response.OutputStream</c>. When DotNetZip writes to a non-seekable
///   stream, the zip archive is formatted in such a way that may not be
///   compatible with all zip tools on all platforms.  It's a perfectly legal
///   and compliant zip file, but some people have reported problems opening
///   files produced this way using the Mac OS archive utility.
/// </para>
///
/// </remarks>
///
/// <example>
///
///   This example saves the zipfile content into a MemoryStream, and
///   then gets the array of bytes from that MemoryStream.
///
/// <code lang="C#">
/// using (var zip = new Ionic.Zip.ZipFile())
/// {
///     zip.CompressionLevel= Ionic.Zlib.CompressionLevel.BestCompression;
///     zip.Password = "VerySecret.";
///     zip.Encryption = EncryptionAlgorithm.WinZipAes128;
///     zip.AddFile(sourceFileName);
///     MemoryStream output = new MemoryStream();
///     zip.Save(output);
///
///     byte[] zipbytes = output.ToArray();
/// }
/// </code>
/// </example>
///
/// <example>
/// <para>
///   This example shows a pitfall you should avoid. DO NOT read
///   from a stream, then try to save to the same stream.  DO
///   NOT DO THIS:
/// </para>
///
/// <code lang="C#">
/// using (var fs = new FileStream(filename, FileMode.Open))
/// {
///   using (var zip = Ionic.Zip.ZipFile.Read(inputStream))
///   {
///     zip.AddEntry("Name1.txt", "this is the content");
///     zip.Save(inputStream);  // NO NO NO!!
///   }
/// }
/// </code>
///
/// <para>
///   Better like this:
/// </para>
///
/// <code lang="C#">
/// using (var zip = Ionic.Zip.ZipFile.Read(filename))
/// {
///     zip.AddEntry("Name1.txt", "this is the content");
///     zip.Save();  // YES!
/// }
/// </code>
///
/// </example>
///
/// <param name="outputStream">
///   The <c>System.IO.Stream</c> to write to. It must be
///   writable. If you created the ZipFile instance by calling
///   ZipFile.Read(), this stream must not be the same stream
///   you passed to ZipFile.Read().
/// </param>
// if we had a filename to save to, we are now obliterating it.
// if we saved to a stream before read from there
// if we saved to or read from a file before
// if we had a filename to save to, we are now obliterating it.
// write to a memory stream in order to keep the
// CDR contiguous
// this writes a ZipDirEntry corresponding to the ZipEntry
// We need to keep track of the start and
// Finish of the Central Directory Structure.
// Cannot always use WriteStream.Length or Position; some streams do
// not support these. (eg, ASP.NET Response.OutputStream) In those
// cases we have a CountingStream.
// Also, we cannot just set Start as s.Position bfore the write, and Finish
// as s.Position after the write.  In a split zip, the write may actually
// flip to the next segment.  In that case, Start will be zero.  But we
// don't know that til after we know the size of the thing to write.  So the
// answer is to compute the directory, then ask the ZipSegmentedStream which
// segment that directory would fall in, it it were written.  Then, include
// that data into the directory, and finally, write the directory to the
// output stream.
// BytesWritten
// need to know which segment the EOCD record starts in
// emit ZIP64 extensions as required
// number of this disk
// number of the disk with the start of the central directory
//Array.Copy(BitConverter.GetBytes(startSegment), 0, a, i, 4);
// offset 60
// number of the disk with the start of the zip64 eocd
// offset 72
// total number of disks
// now, the regular footer
// The assumption is the central directory is never split across
// segment boundaries.
// number of this disk
// number of the disk with the start of the central directory
//Array.Copy(BitConverter.GetBytes((UInt16)startSegment), 0, a2, i, 2);
// reset the contiguous write property if necessary
// AsNecessary is in force
// signature
// number of this disk
// (this number may change later)
// number of the disk with the start of the central directory
// (this number may change later)
// handle ZIP64 extensions for the end-of-central-directory
// the ZIP64 version.
// the standard version.
// total number of entries in the central dir on this disk
// total number of entries in the central directory
// size of the central directory
// The actual data is in the ZIP64 central directory structure
// size of the central directory (we just get the low 4 bytes)
// offset of the start of the central directory (we just get the low 4 bytes)
// zip archive comment
// no comment!
// the size of our buffer defines the max length of the comment we can write
// now actually write the comment itself into the byte buffer
//   s.Write(bytes, 0, i);
// signature
// There is a possibility to include "Extensible" data in the zip64
// end-of-central-dir record.  I cannot figure out what it might be used to
// store, so the size of this record is always fixed.  Maybe it is used for
// strong encryption data?  That is for another day.
// offset 12
// VersionMadeBy = 45;
// VersionNeededToExtract = 45;
// offset 16
// number of the disk, and the disk with the start of the central dir.
// (this may change later)
// offset 24
// offset 40
// offset 56
// now, the locator
// signature
// offset 60
// number of the disk with the start of the zip64 eocd
// (this will change later)  (it will?)
// offset 64
// relative offset of the zip64 eocd
// offset 72
// total number of disks
// (this will change later)
// Cannot just emit _entries.Count, because some of the entries
// may have been skipped.
// ZipFile.Selector.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2010 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-August-06 09:35:58>
//
// ------------------------------------------------------------------
//
// This module defines methods in the ZipFile class associated to the FileFilter
// capability - selecting files to add into the archive, or selecting entries to
// retrieve from the archive based on criteria including the filename, size, date, or
// attributes.  It is something like a "poor man's LINQ".  I included it into DotNetZip
// because not everyone has .NET 3.5 yet.  When using DotNetZip on .NET 3.5, the LINQ
// query/selection will be superior.
//
// These methods are segregated into a different module to facilitate easy exclusion for
// those people who wish to have a smaller library without this function.
//
// ------------------------------------------------------------------
/// <summary>
///   Adds to the ZipFile a set of files from the current working directory on
///   disk, that conform to the specified criteria.
/// </summary>
///
/// <remarks>
/// <para>
///   This method selects files from the the current working directory matching
///   the specified criteria, and adds them to the ZipFile.
/// </para>
///
/// <para>
///   Specify the criteria in statements of 3 elements: a noun, an operator, and
///   a value.  Consider the string "name != *.doc" .  The noun is "name".  The
///   operator is "!=", implying "Not Equal".  The value is "*.doc".  That
///   criterion, in English, says "all files with a name that does not end in
///   the .doc extension."
/// </para>
///
/// <para>
///   Supported nouns include "name" (or "filename") for the filename; "atime",
///   "mtime", and "ctime" for last access time, last modfied time, and created
///   time of the file, respectively; "attributes" (or "attrs") for the file
///   attributes; "size" (or "length") for the file length (uncompressed), and
///   "type" for the type of object, either a file or a directory.  The
///   "attributes", "name" and "type" nouns both support = and != as operators.
///   The "size", "atime", "mtime", and "ctime" nouns support = and !=, and
///   &gt;, &gt;=, &lt;, &lt;= as well. The times are taken to be expressed in
///   local time.
/// </para>
///
/// <para>
/// Specify values for the file attributes as a string with one or more of the
/// characters H,R,S,A,I,L in any order, implying file attributes of Hidden,
/// ReadOnly, System, Archive, NotContextIndexed, and ReparsePoint (symbolic
/// link) respectively.
/// </para>
///
/// <para>
/// To specify a time, use YYYY-MM-DD-HH:mm:ss or YYYY/MM/DD-HH:mm:ss as the
/// format.  If you omit the HH:mm:ss portion, it is assumed to be 00:00:00
/// (midnight).
/// </para>
///
/// <para>
/// The value for a size criterion is expressed in integer quantities of bytes,
/// kilobytes (use k or kb after the number), megabytes (m or mb), or gigabytes
/// (g or gb).
/// </para>
///
/// <para>
/// The value for a name is a pattern to match against the filename, potentially
/// including wildcards.  The pattern follows CMD.exe glob rules: * implies one
/// or more of any character, while ?  implies one character.  If the name
/// pattern contains any slashes, it is matched to the entire filename,
/// including the path; otherwise, it is matched against only the filename
/// without the path.  This means a pattern of "*\*.*" matches all files one
/// directory level deep, while a pattern of "*.*" matches all files in all
/// directories.
/// </para>
///
/// <para>
/// To specify a name pattern that includes spaces, use single quotes around the
/// pattern.  A pattern of "'* *.*'" will match all files that have spaces in
/// the filename.  The full criteria string for that would be "name = '* *.*'" .
/// </para>
///
/// <para>
/// The value for a type criterion is either F (implying a file) or D (implying
/// a directory).
/// </para>
///
/// <para>
/// Some examples:
/// </para>
///
/// <list type="table">
///   <listheader>
///     <term>criteria</term>
///     <description>Files retrieved</description>
///   </listheader>
///
///   <item>
///     <term>name != *.xls </term>
///     <description>any file with an extension that is not .xls
///     </description>
///   </item>
///
///   <item>
///     <term>name = *.mp3 </term>
///     <description>any file with a .mp3 extension.
///     </description>
///   </item>
///
///   <item>
///     <term>*.mp3</term>
///     <description>(same as above) any file with a .mp3 extension.
///     </description>
///   </item>
///
///   <item>
///     <term>attributes = A </term>
///     <description>all files whose attributes include the Archive bit.
///     </description>
///   </item>
///
///   <item>
///     <term>attributes != H </term>
///     <description>all files whose attributes do not include the Hidden bit.
///     </description>
///   </item>
///
///   <item>
///     <term>mtime > 2009-01-01</term>
///     <description>all files with a last modified time after January 1st, 2009.
///     </description>
///   </item>
///
///   <item>
///     <term>size > 2gb</term>
///     <description>all files whose uncompressed size is greater than 2gb.
///     </description>
///   </item>
///
///   <item>
///     <term>type = D</term>
///     <description>all directories in the filesystem. </description>
///   </item>
///
/// </list>
///
/// <para>
/// You can combine criteria with the conjunctions AND or OR. Using a string
/// like "name = *.txt AND size &gt;= 100k" for the selectionCriteria retrieves
/// entries whose names end in .txt, and whose uncompressed size is greater than
/// or equal to 100 kilobytes.
/// </para>
///
/// <para>
/// For more complex combinations of criteria, you can use parenthesis to group
/// clauses in the boolean logic.  Without parenthesis, the precedence of the
/// criterion atoms is determined by order of appearance.  Unlike the C#
/// language, the AND conjunction does not take precendence over the logical OR.
/// This is important only in strings that contain 3 or more criterion atoms.
/// In other words, "name = *.txt and size &gt; 1000 or attributes = H" implies
/// "((name = *.txt AND size &gt; 1000) OR attributes = H)" while "attributes =
/// H OR name = *.txt and size &gt; 1000" evaluates to "((attributes = H OR name
/// = *.txt) AND size &gt; 1000)".  When in doubt, use parenthesis.
/// </para>
///
/// <para>
/// Using time properties requires some extra care. If you want to retrieve all
/// entries that were last updated on 2009 February 14, specify a time range
/// like so:"mtime &gt;= 2009-02-14 AND mtime &lt; 2009-02-15".  Read this to
/// say: all files updated after 12:00am on February 14th, until 12:00am on
/// February 15th.  You can use the same bracketing approach to specify any time
/// period - a year, a month, a week, and so on.
/// </para>
///
/// <para>
/// The syntax allows one special case: if you provide a string with no spaces, it is
/// treated as a pattern to match for the filename.  Therefore a string like "*.xls"
/// will be equivalent to specifying "name = *.xls".
/// </para>
///
/// <para>
/// There is no logic in this method that insures that the file inclusion
/// criteria are internally consistent.  For example, it's possible to specify
/// criteria that says the file must have a size of less than 100 bytes, as well
/// as a size that is greater than 1000 bytes. Obviously no file will ever
/// satisfy such criteria, but this method does not detect such logical
/// inconsistencies. The caller is responsible for insuring the criteria are
/// sensible.
/// </para>
///
/// <para>
///   Using this method, the file selection does not recurse into
///   subdirectories, and the full path of the selected files is included in the
///   entries added into the zip archive.  If you don't like these behaviors,
///   see the other overloads of this method.
/// </para>
/// </remarks>
///
/// <example>
/// This example zips up all *.csv files in the current working directory.
/// <code>
/// using (ZipFile zip = new ZipFile())
/// {
///     // To just match on filename wildcards,
///     // use the shorthand form of the selectionCriteria string.
///     zip.AddSelectedFiles("*.csv");
///     zip.Save(PathToZipArchive);
/// }
/// </code>
/// <code lang="VB">
/// Using zip As ZipFile = New ZipFile()
///     zip.AddSelectedFiles("*.csv")
///     zip.Save(PathToZipArchive)
/// End Using
/// </code>
/// </example>
///
/// <param name="selectionCriteria">The criteria for file selection</param>
/// <summary>
///   Adds to the ZipFile a set of files from the disk that conform to the
///   specified criteria, optionally recursing into subdirectories.
/// </summary>
///
/// <remarks>
/// <para>
///   This method selects files from the the current working directory matching
///   the specified criteria, and adds them to the ZipFile.  If
///   <c>recurseDirectories</c> is true, files are also selected from
///   subdirectories, and the directory structure in the filesystem is
///   reproduced in the zip archive, rooted at the current working directory.
/// </para>
///
/// <para>
///   Using this method, the full path of the selected files is included in the
///   entries added into the zip archive.  If you don't want this behavior, use
///   one of the overloads of this method that allows the specification of a
///   <c>directoryInArchive</c>.
/// </para>
///
/// <para>
///   For details on the syntax for the selectionCriteria parameter, see <see
///   cref="AddSelectedFiles(String)"/>.
/// </para>
///
/// </remarks>
///
/// <example>
///
///   This example zips up all *.xml files in the current working directory, or any
///   subdirectory, that are larger than 1mb.
///
/// <code>
/// using (ZipFile zip = new ZipFile())
/// {
///     // Use a compound expression in the selectionCriteria string.
///     zip.AddSelectedFiles("name = *.xml  and  size > 1024kb", true);
///     zip.Save(PathToZipArchive);
/// }
/// </code>
/// <code lang="VB">
/// Using zip As ZipFile = New ZipFile()
///     ' Use a compound expression in the selectionCriteria string.
///     zip.AddSelectedFiles("name = *.xml  and  size > 1024kb", true)
///     zip.Save(PathToZipArchive)
/// End Using
/// </code>
/// </example>
///
/// <param name="selectionCriteria">The criteria for file selection</param>
///
/// <param name="recurseDirectories">
///   If true, the file selection will recurse into subdirectories.
/// </param>
/// <summary>
///   Adds to the ZipFile a set of files from a specified directory in the
///   filesystem, that conform to the specified criteria.
/// </summary>
///
/// <remarks>
/// <para>
///   This method selects files that conform to the specified criteria, from the
///   the specified directory on disk, and adds them to the ZipFile.  The search
///   does not recurse into subdirectores.
/// </para>
///
/// <para>
///   Using this method, the full filesystem path of the files on disk is
///   reproduced on the entries added to the zip file.  If you don't want this
///   behavior, use one of the other overloads of this method.
/// </para>
///
/// <para>
///   For details on the syntax for the selectionCriteria parameter, see <see
///   cref="AddSelectedFiles(String)"/>.
/// </para>
///
/// </remarks>
///
/// <example>
///
///   This example zips up all *.xml files larger than 1mb in the directory
///   given by "d:\rawdata".
///
/// <code>
/// using (ZipFile zip = new ZipFile())
/// {
///     // Use a compound expression in the selectionCriteria string.
///     zip.AddSelectedFiles("name = *.xml  and  size > 1024kb", "d:\\rawdata");
///     zip.Save(PathToZipArchive);
/// }
/// </code>
///
/// <code lang="VB">
/// Using zip As ZipFile = New ZipFile()
///     ' Use a compound expression in the selectionCriteria string.
///     zip.AddSelectedFiles("name = *.xml  and  size > 1024kb", "d:\rawdata)
///     zip.Save(PathToZipArchive)
/// End Using
/// </code>
/// </example>
///
/// <param name="selectionCriteria">The criteria for file selection</param>
///
/// <param name="directoryOnDisk">
/// The name of the directory on the disk from which to select files.
/// </param>
/// <summary>
///   Adds to the ZipFile a set of files from the specified directory on disk,
///   that conform to the specified criteria.
/// </summary>
///
/// <remarks>
///
/// <para>
///   This method selects files from the the specified disk directory matching
///   the specified selection criteria, and adds them to the ZipFile.  If
///   <c>recurseDirectories</c> is true, files are also selected from
///   subdirectories.
/// </para>
///
/// <para>
///   The full directory structure in the filesystem is reproduced on the
///   entries added to the zip archive.  If you don't want this behavior, use
///   one of the overloads of this method that allows the specification of a
///   <c>directoryInArchive</c>.
/// </para>
///
/// <para>
///   For details on the syntax for the selectionCriteria parameter, see <see
///   cref="AddSelectedFiles(String)"/>.
/// </para>
/// </remarks>
///
/// <example>
///
///   This example zips up all *.csv files in the "files" directory, or any
///   subdirectory, that have been saved since 2009 February 14th.
///
/// <code>
/// using (ZipFile zip = new ZipFile())
/// {
///     // Use a compound expression in the selectionCriteria string.
///     zip.AddSelectedFiles("name = *.csv  and  mtime > 2009-02-14", "files", true);
///     zip.Save(PathToZipArchive);
/// }
/// </code>
/// <code lang="VB">
/// Using zip As ZipFile = New ZipFile()
///     ' Use a compound expression in the selectionCriteria string.
///     zip.AddSelectedFiles("name = *.csv  and  mtime > 2009-02-14", "files", true)
///     zip.Save(PathToZipArchive)
/// End Using
/// </code>
/// </example>
///
/// <example>
///   This example zips up all files in the current working
///   directory, and all its child directories, except those in
///   the <c>excludethis</c> subdirectory.
/// <code lang="VB">
/// Using Zip As ZipFile = New ZipFile(zipfile)
///   Zip.AddSelectedFfiles("name != 'excludethis\*.*'", datapath, True)
///   Zip.Save()
/// End Using
/// </code>
/// </example>
///
/// <param name="selectionCriteria">The criteria for file selection</param>
///
/// <param name="directoryOnDisk">
///   The filesystem path from which to select files.
/// </param>
///
/// <param name="recurseDirectories">
///   If true, the file selection will recurse into subdirectories.
/// </param>
/// <summary>
///   Adds to the ZipFile a selection of files from the specified directory on
///   disk, that conform to the specified criteria, and using a specified root
///   path for entries added to the zip archive.
/// </summary>
///
/// <remarks>
/// <para>
///   This method selects files from the specified disk directory matching the
///   specified selection criteria, and adds those files to the ZipFile, using
///   the specified directory path in the archive.  The search does not recurse
///   into subdirectories.  For details on the syntax for the selectionCriteria
///   parameter, see <see cref="AddSelectedFiles(String)" />.
/// </para>
///
/// </remarks>
///
/// <example>
///
///   This example zips up all *.psd files in the "photos" directory that have
///   been saved since 2009 February 14th, and puts them all in a zip file,
///   using the directory name of "content" in the zip archive itself. When the
///   zip archive is unzipped, the folder containing the .psd files will be
///   named "content".
///
/// <code>
/// using (ZipFile zip = new ZipFile())
/// {
///     // Use a compound expression in the selectionCriteria string.
///     zip.AddSelectedFiles("name = *.psd  and  mtime > 2009-02-14", "photos", "content");
///     zip.Save(PathToZipArchive);
/// }
/// </code>
/// <code lang="VB">
/// Using zip As ZipFile = New ZipFile
///     zip.AddSelectedFiles("name = *.psd  and  mtime > 2009-02-14", "photos", "content")
///     zip.Save(PathToZipArchive)
/// End Using
/// </code>
/// </example>
///
/// <param name="selectionCriteria">
///   The criteria for selection of files to add to the <c>ZipFile</c>.
/// </param>
///
/// <param name="directoryOnDisk">
///   The path to the directory in the filesystem from which to select files.
/// </param>
///
/// <param name="directoryPathInArchive">
///   Specifies a directory path to use to in place of the
///   <c>directoryOnDisk</c>.  This path may, or may not, correspond to a real
///   directory in the current filesystem.  If the files within the zip are
///   later extracted, this is the path used for the extracted file.  Passing
///   null (nothing in VB) will use the path on the file name, if any; in other
///   words it would use <c>directoryOnDisk</c>, plus any subdirectory.  Passing
///   the empty string ("") will insert the item at the root path within the
///   archive.
/// </param>
/// <summary>
///   Adds to the ZipFile a selection of files from the specified directory on
///   disk, that conform to the specified criteria, optionally recursing through
///   subdirectories, and using a specified root path for entries added to the
///   zip archive.
/// </summary>
///
/// <remarks>
///   This method selects files from the specified disk directory that match the
///   specified selection criteria, and adds those files to the ZipFile, using
///   the specified directory path in the archive. If <c>recurseDirectories</c>
///   is true, files are also selected from subdirectories, and the directory
///   structure in the filesystem is reproduced in the zip archive, rooted at
///   the directory specified by <c>directoryOnDisk</c>.  For details on the
///   syntax for the selectionCriteria parameter, see <see
///   cref="AddSelectedFiles(String)" />.
/// </remarks>
///
/// <example>
///
///   This example zips up all files that are NOT *.pst files, in the current
///   working directory and any subdirectories.
///
/// <code>
/// using (ZipFile zip = new ZipFile())
/// {
///     zip.AddSelectedFiles("name != *.pst", SourceDirectory, "backup", true);
///     zip.Save(PathToZipArchive);
/// }
/// </code>
/// <code lang="VB">
/// Using zip As ZipFile = New ZipFile
///     zip.AddSelectedFiles("name != *.pst", SourceDirectory, "backup", true)
///     zip.Save(PathToZipArchive)
/// End Using
/// </code>
/// </example>
///
/// <param name="selectionCriteria">
///   The criteria for selection of files to add to the <c>ZipFile</c>.
/// </param>
///
/// <param name="directoryOnDisk">
///   The path to the directory in the filesystem from which to select files.
/// </param>
///
/// <param name="directoryPathInArchive">
///   Specifies a directory path to use to in place of the
///   <c>directoryOnDisk</c>.  This path may, or may not, correspond to a real
///   directory in the current filesystem.  If the files within the zip are
///   later extracted, this is the path used for the extracted file.  Passing
///   null (nothing in VB) will use the path on the file name, if any; in other
///   words it would use <c>directoryOnDisk</c>, plus any subdirectory.  Passing
///   the empty string ("") will insert the item at the root path within the
///   archive.
/// </param>
///
/// <param name="recurseDirectories">
///   If true, the method also scans subdirectories for files matching the
///   criteria.
/// </param>
/// <summary>
///   Updates the ZipFile with a selection of files from the disk that conform
///   to the specified criteria.
/// </summary>
///
/// <remarks>
///   This method selects files from the specified disk directory that match the
///   specified selection criteria, and Updates the <c>ZipFile</c> with those
///   files, using the specified directory path in the archive. If
///   <c>recurseDirectories</c> is true, files are also selected from
///   subdirectories, and the directory structure in the filesystem is
///   reproduced in the zip archive, rooted at the directory specified by
///   <c>directoryOnDisk</c>.  For details on the syntax for the
///   selectionCriteria parameter, see <see cref="AddSelectedFiles(String)" />.
/// </remarks>
///
/// <param name="selectionCriteria">
///   The criteria for selection of files to add to the <c>ZipFile</c>.
/// </param>
///
/// <param name="directoryOnDisk">
///   The path to the directory in the filesystem from which to select files.
/// </param>
///
/// <param name="directoryPathInArchive">
///   Specifies a directory path to use to in place of the
///   <c>directoryOnDisk</c>. This path may, or may not, correspond to a
///   real directory in the current filesystem. If the files within the zip
///   are later extracted, this is the path used for the extracted file.
///   Passing null (nothing in VB) will use the path on the file name, if
///   any; in other words it would use <c>directoryOnDisk</c>, plus any
///   subdirectory.  Passing the empty string ("") will insert the item at
///   the root path within the archive.
/// </param>
///
/// <param name="recurseDirectories">
///   If true, the method also scans subdirectories for files matching the criteria.
/// </param>
///
/// <seealso cref="AddSelectedFiles(String, String, String, bool)" />
// workitem 9176
// workitem 10153
// workitem 12260
// this adds "just" the directory, without recursing to the contained files
// workitem 12260
/// <summary>
/// Retrieve entries from the zipfile by specified criteria.
/// </summary>
///
/// <remarks>
/// <para>
/// This method allows callers to retrieve the collection of entries from the zipfile
/// that fit the specified criteria.  The criteria are described in a string format, and
/// can include patterns for the filename; constraints on the size of the entry;
/// constraints on the last modified, created, or last accessed time for the file
/// described by the entry; or the attributes of the entry.
/// </para>
///
/// <para>
/// For details on the syntax for the selectionCriteria parameter, see <see
/// cref="AddSelectedFiles(String)"/>.
/// </para>
///
/// <para>
/// This method is intended for use with a ZipFile that has been read from storage.
/// When creating a new ZipFile, this method will work only after the ZipArchive has
/// been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
/// archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
/// saved will deliver undefined results.
/// </para>
/// </remarks>
///
/// <exception cref="System.Exception">
/// Thrown if selectionCriteria has an invalid syntax.
/// </exception>
///
/// <example>
/// This example selects all the PhotoShop files from within an archive, and extracts them
/// to the current working directory.
/// <code>
/// using (ZipFile zip1 = ZipFile.Read(ZipFileName))
/// {
///     var PhotoShopFiles = zip1.SelectEntries("*.psd");
///     foreach (ZipEntry psd in PhotoShopFiles)
///     {
///         psd.Extract();
///     }
/// }
/// </code>
/// <code lang="VB">
/// Using zip1 As ZipFile = ZipFile.Read(ZipFileName)
///     Dim PhotoShopFiles as ICollection(Of ZipEntry)
///     PhotoShopFiles = zip1.SelectEntries("*.psd")
///     Dim psd As ZipEntry
///     For Each psd In PhotoShopFiles
///         psd.Extract
///     Next
/// End Using
/// </code>
/// </example>
/// <param name="selectionCriteria">the string that specifies which entries to select</param>
/// <returns>a collection of ZipEntry objects that conform to the inclusion spec</returns>
/// <summary>
/// Retrieve entries from the zipfile by specified criteria.
/// </summary>
///
/// <remarks>
/// <para>
/// This method allows callers to retrieve the collection of entries from the zipfile
/// that fit the specified criteria.  The criteria are described in a string format, and
/// can include patterns for the filename; constraints on the size of the entry;
/// constraints on the last modified, created, or last accessed time for the file
/// described by the entry; or the attributes of the entry.
/// </para>
///
/// <para>
/// For details on the syntax for the selectionCriteria parameter, see <see
/// cref="AddSelectedFiles(String)"/>.
/// </para>
///
/// <para>
/// This method is intended for use with a ZipFile that has been read from storage.
/// When creating a new ZipFile, this method will work only after the ZipArchive has
/// been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
/// archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
/// saved will deliver undefined results.
/// </para>
/// </remarks>
///
/// <exception cref="System.Exception">
/// Thrown if selectionCriteria has an invalid syntax.
/// </exception>
///
/// <example>
/// <code>
/// using (ZipFile zip1 = ZipFile.Read(ZipFileName))
/// {
///     var UpdatedPhotoShopFiles = zip1.SelectEntries("*.psd", "UpdatedFiles");
///     foreach (ZipEntry e in UpdatedPhotoShopFiles)
///     {
///         // prompt for extract here
///         if (WantExtract(e.FileName))
///             e.Extract();
///     }
/// }
/// </code>
/// <code lang="VB">
/// Using zip1 As ZipFile = ZipFile.Read(ZipFileName)
///     Dim UpdatedPhotoShopFiles As ICollection(Of ZipEntry) = zip1.SelectEntries("*.psd", "UpdatedFiles")
///     Dim e As ZipEntry
///     For Each e In UpdatedPhotoShopFiles
///         ' prompt for extract here
///         If Me.WantExtract(e.FileName) Then
///             e.Extract
///         End If
///     Next
/// End Using
/// </code>
/// </example>
/// <param name="selectionCriteria">the string that specifies which entries to select</param>
///
/// <param name="directoryPathInArchive">
/// the directory in the archive from which to select entries. If null, then
/// all directories in the archive are used.
/// </param>
///
/// <returns>a collection of ZipEntry objects that conform to the inclusion spec</returns>
/// <summary>
/// Remove entries from the zipfile by specified criteria.
/// </summary>
///
/// <remarks>
/// <para>
/// This method allows callers to remove the collection of entries from the zipfile
/// that fit the specified criteria.  The criteria are described in a string format, and
/// can include patterns for the filename; constraints on the size of the entry;
/// constraints on the last modified, created, or last accessed time for the file
/// described by the entry; or the attributes of the entry.
/// </para>
///
/// <para>
/// For details on the syntax for the selectionCriteria parameter, see <see
/// cref="AddSelectedFiles(String)"/>.
/// </para>
///
/// <para>
/// This method is intended for use with a ZipFile that has been read from storage.
/// When creating a new ZipFile, this method will work only after the ZipArchive has
/// been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
/// archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
/// saved will deliver undefined results.
/// </para>
/// </remarks>
///
/// <exception cref="System.Exception">
/// Thrown if selectionCriteria has an invalid syntax.
/// </exception>
///
/// <example>
/// This example removes all entries in a zip file that were modified prior to January 1st, 2008.
/// <code>
/// using (ZipFile zip1 = ZipFile.Read(ZipFileName))
/// {
///     // remove all entries from prior to Jan 1, 2008
///     zip1.RemoveEntries("mtime &lt; 2008-01-01");
///     // don't forget to save the archive!
///     zip1.Save();
/// }
/// </code>
/// <code lang="VB">
/// Using zip As ZipFile = ZipFile.Read(ZipFileName)
///     ' remove all entries from prior to Jan 1, 2008
///     zip1.RemoveEntries("mtime &lt; 2008-01-01")
///     ' do not forget to save the archive!
///     zip1.Save
/// End Using
/// </code>
/// </example>
/// <param name="selectionCriteria">the string that specifies which entries to select</param>
/// <returns>the number of entries removed</returns>
/// <summary>
/// Remove entries from the zipfile by specified criteria, and within the specified
/// path in the archive.
/// </summary>
///
/// <remarks>
/// <para>
/// This method allows callers to remove the collection of entries from the zipfile
/// that fit the specified criteria.  The criteria are described in a string format, and
/// can include patterns for the filename; constraints on the size of the entry;
/// constraints on the last modified, created, or last accessed time for the file
/// described by the entry; or the attributes of the entry.
/// </para>
///
/// <para>
/// For details on the syntax for the selectionCriteria parameter, see <see
/// cref="AddSelectedFiles(String)"/>.
/// </para>
///
/// <para>
/// This method is intended for use with a ZipFile that has been read from storage.
/// When creating a new ZipFile, this method will work only after the ZipArchive has
/// been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
/// archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
/// saved will deliver undefined results.
/// </para>
/// </remarks>
///
/// <exception cref="System.Exception">
/// Thrown if selectionCriteria has an invalid syntax.
/// </exception>
///
/// <example>
/// <code>
/// using (ZipFile zip1 = ZipFile.Read(ZipFileName))
/// {
///     // remove all entries from prior to Jan 1, 2008
///     zip1.RemoveEntries("mtime &lt; 2008-01-01", "documents");
///     // a call to ZipFile.Save will make the modifications permanent
///     zip1.Save();
/// }
/// </code>
/// <code lang="VB">
/// Using zip As ZipFile = ZipFile.Read(ZipFileName)
///     ' remove all entries from prior to Jan 1, 2008
///     zip1.RemoveEntries("mtime &lt; 2008-01-01", "documents")
///     ' a call to ZipFile.Save will make the modifications permanent
///     zip1.Save
/// End Using
/// </code>
/// </example>
///
/// <param name="selectionCriteria">the string that specifies which entries to select</param>
/// <param name="directoryPathInArchive">
/// the directory in the archive from which to select entries. If null, then
/// all directories in the archive are used.
/// </param>
/// <returns>the number of entries removed</returns>
/// <summary>
/// Selects and Extracts a set of Entries from the ZipFile.
/// </summary>
///
/// <remarks>
/// <para>
/// The entries are extracted into the current working directory.
/// </para>
///
/// <para>
/// If any of the files to be extracted already exist, then the action taken is as
/// specified in the <see cref="ZipEntry.ExtractExistingFile"/> property on the
/// corresponding ZipEntry instance.  By default, the action taken in this case is to
/// throw an exception.
/// </para>
///
/// <para>
/// For information on the syntax of the selectionCriteria string,
/// see <see cref="AddSelectedFiles(String)" />.
/// </para>
/// </remarks>
///
/// <example>
/// This example shows how extract all XML files modified after 15 January 2009.
/// <code>
/// using (ZipFile zip = ZipFile.Read(zipArchiveName))
/// {
///   zip.ExtractSelectedEntries("name = *.xml  and  mtime &gt; 2009-01-15");
/// }
/// </code>
/// </example>
/// <param name="selectionCriteria">the selection criteria for entries to extract.</param>
///
/// <seealso cref="ExtractSelectedEntries(String,ExtractExistingFileAction)"/>
// possibly null
/// <summary>
/// Selects and Extracts a set of Entries from the ZipFile.
/// </summary>
///
/// <remarks>
/// <para>
/// The entries are extracted into the current working directory. When extraction would would
/// overwrite an existing filesystem file, the action taken is as specified in the
/// <paramref name="extractExistingFile"/> parameter.
/// </para>
///
/// <para>
/// For information on the syntax of the string describing the entry selection criteria,
/// see <see cref="AddSelectedFiles(String)" />.
/// </para>
/// </remarks>
///
/// <example>
/// This example shows how extract all XML files modified after 15 January 2009,
/// overwriting any existing files.
/// <code>
/// using (ZipFile zip = ZipFile.Read(zipArchiveName))
/// {
///   zip.ExtractSelectedEntries("name = *.xml  and  mtime &gt; 2009-01-15",
///                              ExtractExistingFileAction.OverwriteSilently);
/// }
/// </code>
/// </example>
///
/// <param name="selectionCriteria">the selection criteria for entries to extract.</param>
///
/// <param name="extractExistingFile">
/// The action to take if extraction would overwrite an existing file.
/// </param>
// possibly null
/// <summary>
/// Selects and Extracts a set of Entries from the ZipFile.
/// </summary>
///
/// <remarks>
/// <para>
/// The entries are selected from the specified directory within the archive, and then
/// extracted into the current working directory.
/// </para>
///
/// <para>
/// If any of the files to be extracted already exist, then the action taken is as
/// specified in the <see cref="ZipEntry.ExtractExistingFile"/> property on the
/// corresponding ZipEntry instance.  By default, the action taken in this case is to
/// throw an exception.
/// </para>
///
/// <para>
/// For information on the syntax of the string describing the entry selection criteria,
/// see <see cref="AddSelectedFiles(String)" />.
/// </para>
/// </remarks>
///
/// <example>
/// This example shows how extract all XML files modified after 15 January 2009,
/// and writes them to the "unpack" directory.
/// <code>
/// using (ZipFile zip = ZipFile.Read(zipArchiveName))
/// {
///   zip.ExtractSelectedEntries("name = *.xml  and  mtime &gt; 2009-01-15","unpack");
/// }
/// </code>
/// </example>
///
/// <param name="selectionCriteria">the selection criteria for entries to extract.</param>
///
/// <param name="directoryPathInArchive">
/// the directory in the archive from which to select entries. If null, then
/// all directories in the archive are used.
/// </param>
///
/// <seealso cref="ExtractSelectedEntries(String,String,String,ExtractExistingFileAction)"/>
// possibly null
/// <summary>
/// Selects and Extracts a set of Entries from the ZipFile.
/// </summary>
///
/// <remarks>
/// <para>
/// The entries are extracted into the specified directory. If any of the files to be
/// extracted already exist, an exception will be thrown.
/// </para>
/// <para>
/// For information on the syntax of the string describing the entry selection criteria,
/// see <see cref="AddSelectedFiles(String)" />.
/// </para>
/// </remarks>
///
/// <param name="selectionCriteria">the selection criteria for entries to extract.</param>
///
/// <param name="directoryInArchive">
/// the directory in the archive from which to select entries. If null, then
/// all directories in the archive are used.
/// </param>
///
/// <param name="extractDirectory">
/// the directory on the disk into which to extract. It will be created
/// if it does not exist.
/// </param>
// possibly null
/// <summary>
/// Selects and Extracts a set of Entries from the ZipFile.
/// </summary>
///
/// <remarks>
/// <para>
/// The entries are extracted into the specified directory. When extraction would would
/// overwrite an existing filesystem file, the action taken is as specified in the
/// <paramref name="extractExistingFile"/> parameter.
/// </para>
///
/// <para>
/// For information on the syntax of the string describing the entry selection criteria,
/// see <see cref="AddSelectedFiles(String)" />.
/// </para>
/// </remarks>
///
/// <example>
/// This example shows how extract all files  with an XML extension or with  a size larger than 100,000 bytes,
/// and puts them in the unpack directory.  For any files that already exist in
/// that destination directory, they will not be overwritten.
/// <code>
/// using (ZipFile zip = ZipFile.Read(zipArchiveName))
/// {
///   zip.ExtractSelectedEntries("name = *.xml  or  size &gt; 100000",
///                              null,
///                              "unpack",
///                              ExtractExistingFileAction.DontOverwrite);
/// }
/// </code>
/// </example>
///
/// <param name="selectionCriteria">the selection criteria for entries to extract.</param>
///
/// <param name="extractDirectory">
/// The directory on the disk into which to extract. It will be created if it does not exist.
/// </param>
///
/// <param name="directoryPathInArchive">
/// The directory in the archive from which to select entries. If null, then
/// all directories in the archive are used.
/// </param>
///
/// <param name="extractExistingFile">
/// The action to take if extraction would overwrite an existing file.
/// </param>
///
// possibly null
// swap slashes in reference to local configuration
/// <summary>
/// Retrieve the ZipEntry items in the ZipFile that conform to the specified criteria.
/// </summary>
/// <remarks>
///
/// <para>
/// This method applies the criteria set in the FileSelector instance (as described in
/// the <see cref="FileSelector.SelectionCriteria"/>) to the specified ZipFile.  Using this
/// method, for example, you can retrieve all entries from the given ZipFile that
/// have filenames ending in .txt.
/// </para>
///
/// <para>
/// Normally, applications would not call this method directly.  This method is used
/// by the ZipFile class.
/// </para>
///
/// <para>
/// Using the appropriate SelectionCriteria, you can retrieve entries based on size,
/// time, and attributes. See <see cref="FileSelector.SelectionCriteria"/> for a
/// description of the syntax of the SelectionCriteria string.
/// </para>
///
/// </remarks>
///
/// <param name="zip">The ZipFile from which to retrieve entries.</param>
///
/// <returns>a collection of ZipEntry objects that conform to the criteria.</returns>
/// <summary>
/// Retrieve the ZipEntry items in the ZipFile that conform to the specified criteria.
/// </summary>
/// <remarks>
///
/// <para>
/// This method applies the criteria set in the FileSelector instance (as described in
/// the <see cref="FileSelector.SelectionCriteria"/>) to the specified ZipFile.  Using this
/// method, for example, you can retrieve all entries from the given ZipFile that
/// have filenames ending in .txt.
/// </para>
///
/// <para>
/// Normally, applications would not call this method directly.  This method is used
/// by the ZipFile class.
/// </para>
///
/// <para>
/// This overload allows the selection of ZipEntry instances from the ZipFile to be restricted
/// to entries contained within a particular directory in the ZipFile.
/// </para>
///
/// <para>
/// Using the appropriate SelectionCriteria, you can retrieve entries based on size,
/// time, and attributes. See <see cref="FileSelector.SelectionCriteria"/> for a
/// description of the syntax of the SelectionCriteria string.
/// </para>
///
/// </remarks>
///
/// <param name="zip">The ZipFile from which to retrieve entries.</param>
///
/// <param name="directoryPathInArchive">
/// the directory in the archive from which to select entries. If null, then
/// all directories in the archive are used.
/// </param>
///
/// <returns>a collection of ZipEntry objects that conform to the criteria.</returns>
// workitem 8559
// workitem 9174
// workitem 8559
/// <summary>
/// 
/// 
/// Static constructor for ZipFile
/// </summary>
/// <remarks>
/// Code Pages 437 and 1252 for English are same
/// Code Page 1252 Windows Latin 1 (ANSI) - <see href="https://msdn.microsoft.com/en-us/library/cc195054.aspx"/>
/// Code Page 437 MS-DOS Latin US - <see href="https://msdn.microsoft.com/en-us/library/cc195060.aspx"/>
/// </remarks>
/*e*/)
/*e*/)
/*e*/)
/// <summary>
/// The default text encoding used in zip archives.  It is numeric 437, also
/// known as IBM437.
/// </summary>
/// <seealso cref="Ionic.Zip.ZipFile.AlternateEncoding"/>
// ZipFile.x-IEnumerable.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2006, 2007, 2008, 2009 Dino Chiesa and Microsoft Corporation.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2009-December-26 15:13:26>
//
// ------------------------------------------------------------------
//
// This module defines smoe methods for IEnumerable support. It is
// particularly important for COM to have these things in a separate module.
//
// ------------------------------------------------------------------
// For some weird reason, the method with the DispId(-4) attribute, which is used as
// the _NewEnum() method, and which is required to get enumeration to work from COM
// environments like VBScript and Javascript (etc) must be the LAST MEMBER in the
// source.  In the event of Partial classes, it needs to be the last member defined
// in the last source module.  The source modules are ordered alphabetically by
// filename.  Not sure why this is true. In any case, we put the enumeration stuff
// here in this oddly-named module, for this reason.
//
/// <summary>
/// Generic IEnumerator support, for use of a ZipFile in an enumeration.
/// </summary>
///
/// <remarks>
/// You probably do not want to call <c>GetEnumerator</c> explicitly. Instead
/// it is implicitly called when you use a <see langword="foreach"/> loop in C#, or a
/// <c>For Each</c> loop in VB.NET.
/// </remarks>
///
/// <example>
/// This example reads a zipfile of a given name, then enumerates the
/// entries in that zip file, and displays the information about each
/// entry on the Console.
/// <code>
/// using (ZipFile zip = ZipFile.Read(zipfile))
/// {
///   bool header = true;
///   foreach (ZipEntry e in zip)
///   {
///     if (header)
///     {
///        System.Console.WriteLine("Zipfile: {0}", zip.Name);
///        System.Console.WriteLine("Version Needed: 0x{0:X2}", e.VersionNeeded);
///        System.Console.WriteLine("BitField: 0x{0:X2}", e.BitField);
///        System.Console.WriteLine("Compression Method: 0x{0:X2}", e.CompressionMethod);
///        System.Console.WriteLine("\n{1,-22} {2,-6} {3,4}   {4,-8}  {0}",
///                     "Filename", "Modified", "Size", "Ratio", "Packed");
///        System.Console.WriteLine(new System.String('-', 72));
///        header = false;
///     }
///
///     System.Console.WriteLine("{1,-22} {2,-6} {3,4:F0}%   {4,-8}  {0}",
///                 e.FileName,
///                 e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"),
///                 e.UncompressedSize,
///                 e.CompressionRatio,
///                 e.CompressedSize);
///
///     e.Extract();
///   }
/// }
/// </code>
///
/// <code lang="VB">
///   Dim ZipFileToExtract As String = "c:\foo.zip"
///   Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
///       Dim header As Boolean = True
///       Dim e As ZipEntry
///       For Each e In zip
///           If header Then
///               Console.WriteLine("Zipfile: {0}", zip.Name)
///               Console.WriteLine("Version Needed: 0x{0:X2}", e.VersionNeeded)
///               Console.WriteLine("BitField: 0x{0:X2}", e.BitField)
///               Console.WriteLine("Compression Method: 0x{0:X2}", e.CompressionMethod)
///               Console.WriteLine(ChrW(10) &amp; "{1,-22} {2,-6} {3,4}   {4,-8}  {0}", _
///                 "Filename", "Modified", "Size", "Ratio", "Packed" )
///               Console.WriteLine(New String("-"c, 72))
///               header = False
///           End If
///           Console.WriteLine("{1,-22} {2,-6} {3,4:F0}%   {4,-8}  {0}", _
///             e.FileName, _
///             e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"), _
///             e.UncompressedSize, _
///             e.CompressionRatio, _
///             e.CompressedSize )
///           e.Extract
///       Next
///   End Using
/// </code>
/// </example>
///
/// <returns>A generic enumerator suitable for use  within a foreach loop.</returns>
/// <summary>
/// An IEnumerator, for use of a ZipFile in a foreach construct.
/// </summary>
///
/// <remarks>
/// This method is included for COM support.  An application generally does not call
/// this method directly.  It is called implicitly by COM clients when enumerating
/// the entries in the ZipFile instance.  In VBScript, this is done with a <c>For Each</c>
/// statement.  In Javascript, this is done with <c>new Enumerator(zipfile)</c>.
/// </remarks>
///
/// <returns>
/// The IEnumerator over the entries in the ZipFile.
/// </returns>
// the name of this method is not significant
// ZipInputStream.cs
//
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2010 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-July-31 14:48:30>
//
// ------------------------------------------------------------------
//
// This module defines the ZipInputStream class, which is a stream metaphor for
// reading zip files.  This class does not depend on Ionic.Zip.ZipFile, but rather
// stands alongside it as an alternative "container" for ZipEntry, when reading zips.
//
// It adds one interesting method to the normal "stream" interface: GetNextEntry.
//
// ------------------------------------------------------------------
//
/// <summary>
///   Provides a stream metaphor for reading zip files.
/// </summary>
///
/// <remarks>
/// <para>
///   This class provides an alternative programming model for reading zip files to
///   the one enabled by the <see cref="ZipFile"/> class.  Use this when reading zip
///   files, as an alternative to the <see cref="ZipFile"/> class, when you would
///   like to use a Stream class to read the file.
/// </para>
///
/// <para>
///   Some application designs require a readable stream for input. This stream can
///   be used to read a zip file, and extract entries.
/// </para>
///
/// <para>
///   Both the <c>ZipInputStream</c> class and the <c>ZipFile</c> class can be used
///   to read and extract zip files.  Both of them support many of the common zip
///   features, including Unicode, different compression levels, and ZIP64.  The
///   programming models differ. For example, when extracting entries via calls to
///   the <c>GetNextEntry()</c> and <c>Read()</c> methods on the
///   <c>ZipInputStream</c> class, the caller is responsible for creating the file,
///   writing the bytes into the file, setting the attributes on the file, and
///   setting the created, last modified, and last accessed timestamps on the
///   file. All of these things are done automatically by a call to <see
///   cref="ZipEntry.Extract()">ZipEntry.Extract()</see>.  For this reason, the
///   <c>ZipInputStream</c> is generally recommended for when your application wants
///   to extract the data, without storing that data into a file.
/// </para>
///
/// <para>
///   Aside from the obvious differences in programming model, there are some
///   differences in capability between the <c>ZipFile</c> class and the
///   <c>ZipInputStream</c> class.
/// </para>
///
/// <list type="bullet">
///   <item>
///     <c>ZipFile</c> can be used to create or update zip files, or read and
///     extract zip files. <c>ZipInputStream</c> can be used only to read and
///     extract zip files. If you want to use a stream to create zip files, check
///     out the <see cref="ZipOutputStream"/>.
///   </item>
///
///   <item>
///     <c>ZipInputStream</c> cannot read segmented or spanned
///     zip files.
///   </item>
///
///   <item>
///     <c>ZipInputStream</c> will not read Zip file comments.
///   </item>
///
///   <item>
///     When reading larger files, <c>ZipInputStream</c> will always underperform
///     <c>ZipFile</c>. This is because the <c>ZipInputStream</c> does a full scan on the
///     zip file, while the <c>ZipFile</c> class reads the central directory of the
///     zip file.
///   </item>
///
/// </list>
///
/// </remarks>
/// <summary>
///   Create a <c>ZipInputStream</c>, wrapping it around an existing stream.
/// </summary>
///
/// <remarks>
///
/// <para>
///   While the <see cref="ZipFile"/> class is generally easier
///   to use, this class provides an alternative to those
///   applications that want to read from a zipfile directly,
///   using a <see cref="System.IO.Stream"/>.
/// </para>
///
/// <para>
///   Both the <c>ZipInputStream</c> class and the <c>ZipFile</c> class can be used
///   to read and extract zip files.  Both of them support many of the common zip
///   features, including Unicode, different compression levels, and ZIP64.  The
///   programming models differ. For example, when extracting entries via calls to
///   the <c>GetNextEntry()</c> and <c>Read()</c> methods on the
///   <c>ZipInputStream</c> class, the caller is responsible for creating the file,
///   writing the bytes into the file, setting the attributes on the file, and
///   setting the created, last modified, and last accessed timestamps on the
///   file. All of these things are done automatically by a call to <see
///   cref="ZipEntry.Extract()">ZipEntry.Extract()</see>.  For this reason, the
///   <c>ZipInputStream</c> is generally recommended for when your application wants
///   to extract the data, without storing that data into a file.
/// </para>
///
/// <para>
///   Aside from the obvious differences in programming model, there are some
///   differences in capability between the <c>ZipFile</c> class and the
///   <c>ZipInputStream</c> class.
/// </para>
///
/// <list type="bullet">
///   <item>
///   <c>ZipFile</c> can be used to create or update zip files, or read and extract
///   zip files. <c>ZipInputStream</c> can be used only to read and extract zip
///     files. If you want to use a stream to create zip files, check out the <see
///     cref="ZipOutputStream"/>.
///   </item>
///
///   <item>
///     <c>ZipInputStream</c> cannot read segmented or spanned
///     zip files.
///   </item>
///
///   <item>
///     <c>ZipInputStream</c> will not read Zip file comments.
///   </item>
///
///   <item>
///     When reading larger files, <c>ZipInputStream</c> will always underperform
///     <c>ZipFile</c>. This is because the <c>ZipInputStream</c> does a full scan on the
///     zip file, while the <c>ZipFile</c> class reads the central directory of the
///     zip file.
///   </item>
///
/// </list>
///
/// </remarks>
///
/// <param name="stream">
///   The stream to read. It must be readable. This stream will be closed at
///   the time the <c>ZipInputStream</c> is closed.
/// </param>
///
/// <example>
///
///   This example shows how to read a zip file, and extract entries, using the
///   <c>ZipInputStream</c> class.
///
/// <code lang="C#">
/// private void Unzip()
/// {
///     byte[] buffer= new byte[2048];
///     int n;
///     using (var raw = File.Open(inputFileName, FileMode.Open, FileAccess.Read))
///     {
///         using (var input= new ZipInputStream(raw))
///         {
///             ZipEntry e;
///             while (( e = input.GetNextEntry()) != null)
///             {
///                 if (e.IsDirectory) continue;
///                 string outputPath = Path.Combine(extractDir, e.FileName);
///                 using (var output = File.Open(outputPath, FileMode.Create, FileAccess.ReadWrite))
///                 {
///                     while ((n= input.Read(buffer, 0, buffer.Length)) > 0)
///                     {
///                         output.Write(buffer,0,n);
///                     }
///                 }
///             }
///         }
///     }
/// }
/// </code>
///
/// <code lang="VB">
/// Private Sub UnZip()
///     Dim inputFileName As String = "MyArchive.zip"
///     Dim extractDir As String = "extract"
///     Dim buffer As Byte() = New Byte(2048) {}
///     Using raw As FileStream = File.Open(inputFileName, FileMode.Open, FileAccess.Read)
///         Using input As ZipInputStream = New ZipInputStream(raw)
///             Dim e As ZipEntry
///             Do While (Not e = input.GetNextEntry Is Nothing)
///                 If Not e.IsDirectory Then
///                     Using output As FileStream = File.Open(Path.Combine(extractDir, e.FileName), _
///                                                            FileMode.Create, FileAccess.ReadWrite)
///                         Dim n As Integer
///                         Do While (n = input.Read(buffer, 0, buffer.Length) > 0)
///                             output.Write(buffer, 0, n)
///                         Loop
///                     End Using
///                 End If
///             Loop
///         End Using
///     End Using
/// End Sub
/// </code>
/// </example>
/// <summary>
///   Create a <c>ZipInputStream</c>, given the name of an existing zip file.
/// </summary>
///
/// <remarks>
///
/// <para>
///   This constructor opens a <c>FileStream</c> for the given zipfile, and
///   wraps a <c>ZipInputStream</c> around that.  See the documentation for the
///   <see cref="ZipInputStream(Stream)"/> constructor for full details.
/// </para>
///
/// <para>
///   While the <see cref="ZipFile"/> class is generally easier
///   to use, this class provides an alternative to those
///   applications that want to read from a zipfile directly,
///   using a <see cref="System.IO.Stream"/>.
/// </para>
///
/// </remarks>
///
/// <param name="fileName">
///   The name of the filesystem file to read.
/// </param>
///
/// <example>
///
///   This example shows how to read a zip file, and extract entries, using the
///   <c>ZipInputStream</c> class.
///
/// <code lang="C#">
/// private void Unzip()
/// {
///     byte[] buffer= new byte[2048];
///     int n;
///     using (var input= new ZipInputStream(inputFileName))
///     {
///         ZipEntry e;
///         while (( e = input.GetNextEntry()) != null)
///         {
///             if (e.IsDirectory) continue;
///             string outputPath = Path.Combine(extractDir, e.FileName);
///             using (var output = File.Open(outputPath, FileMode.Create, FileAccess.ReadWrite))
///             {
///                 while ((n= input.Read(buffer, 0, buffer.Length)) > 0)
///                 {
///                     output.Write(buffer,0,n);
///                 }
///             }
///         }
///     }
/// }
/// </code>
///
/// <code lang="VB">
/// Private Sub UnZip()
///     Dim inputFileName As String = "MyArchive.zip"
///     Dim extractDir As String = "extract"
///     Dim buffer As Byte() = New Byte(2048) {}
///     Using input As ZipInputStream = New ZipInputStream(inputFileName)
///         Dim e As ZipEntry
///         Do While (Not e = input.GetNextEntry Is Nothing)
///             If Not e.IsDirectory Then
///                 Using output As FileStream = File.Open(Path.Combine(extractDir, e.FileName), _
///                                                        FileMode.Create, FileAccess.ReadWrite)
///                     Dim n As Integer
///                     Do While (n = input.Read(buffer, 0, buffer.Length) > 0)
///                         output.Write(buffer, 0, n)
///                     Loop
///                 End Using
///             End If
///         Loop
///     End Using
/// End Sub
/// </code>
/// </example>
/// <summary>
///   Create a <c>ZipInputStream</c>, explicitly specifying whether to
///   keep the underlying stream open.
/// </summary>
///
/// <remarks>
///   See the documentation for the <see
///   cref="ZipInputStream(Stream)">ZipInputStream(Stream)</see>
///   constructor for a discussion of the class, and an example of how to use the class.
/// </remarks>
///
/// <param name="stream">
///   The stream to read from. It must be readable.
/// </param>
///
/// <param name="leaveOpen">
///   true if the application would like the stream
///   to remain open after the <c>ZipInputStream</c> has been closed.
/// </param>
/// <summary>Provides a string representation of the instance.</summary>
/// <remarks>
///   <para>
///     This can be useful for debugging purposes.
///   </para>
/// </remarks>
/// <returns>a string representation of the instance.</returns>
/// <summary>
///   The text encoding to use when reading entries into the zip archive, for
///   those entries whose filenames or comments cannot be encoded with the
///   default (IBM437) encoding.
/// </summary>
///
/// <remarks>
/// <para>
///   In <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">its
///   zip specification</see>, PKWare describes two options for encoding
///   filenames and comments: using IBM437 or UTF-8.  But, some archiving tools
///   or libraries do not follow the specification, and instead encode
///   characters using the system default code page.  For example, WinRAR when
///   run on a machine in Shanghai may encode filenames with the Big-5 Chinese
///   (950) code page.  This behavior is contrary to the Zip specification, but
///   it occurs anyway.
/// </para>
///
/// <para>
///   When using DotNetZip to read zip archives that use something other than
///   UTF-8 or IBM437, set this property to specify the code page to use when
///   reading encoded filenames and comments for each <c>ZipEntry</c> in the zip
///   file.
/// </para>
///
/// <para>
///   This property is "provisional". When the entry in the zip archive is not
///   explicitly marked as using UTF-8, then IBM437 is used to decode filenames
///   and comments. If a loss of data would result from using IBM436 -
///   specifically when encoding and decoding is not reflexive - the codepage
///   specified here is used. It is possible, therefore, to have a given entry
///   with a <c>Comment</c> encoded in IBM437 and a <c>FileName</c> encoded with
///   the specified "provisional" codepage.
/// </para>
///
/// <para>
///   When a zip file uses an arbitrary, non-UTF8 code page for encoding, there
///   is no standard way for the reader application - whether DotNetZip, WinZip,
///   WinRar, or something else - to know which codepage has been used for the
///   entries. Readers of zip files are not able to inspect the zip file and
///   determine the codepage that was used for the entries contained within it.
///   It is left to the application or user to determine the necessary codepage
///   when reading zip files encoded this way.  If you use an incorrect codepage
///   when reading a zipfile, you will get entries with filenames that are
///   incorrect, and the incorrect filenames may even contain characters that
///   are not legal for use within filenames in Windows. Extracting entries with
///   illegal characters in the filenames will lead to exceptions. It's too bad,
///   but this is just the way things are with code pages in zip files. Caveat
///   Emptor.
/// </para>
///
/// </remarks>
/// <summary>
///   Size of the work buffer to use for the ZLIB codec during decompression.
/// </summary>
///
/// <remarks>
///   Setting this affects the performance and memory efficiency of compression
///   and decompression.  For larger files, setting this to a larger size may
///   improve performance, but the exact numbers vary depending on available
///   memory, and a bunch of other variables. I don't have good firm
///   recommendations on how to set it.  You'll have to test it yourself. Or
///   just leave it alone and accept the default.
/// </remarks>
/// <summary>
///   Sets the password to be used on the <c>ZipInputStream</c> instance.
/// </summary>
///
/// <remarks>
///
/// <para>
///   When reading a zip archive, this password is used to read and decrypt the
///   entries that are encrypted within the zip file. When entries within a zip
///   file use different passwords, set the appropriate password for the entry
///   before the first call to <c>Read()</c> for each entry.
/// </para>
///
/// <para>
///   When reading an entry that is not encrypted, the value of this property is
///   ignored.
/// </para>
///
/// </remarks>
///
/// <example>
///
///   This example uses the ZipInputStream to read and extract entries from a
///   zip file, using a potentially different password for each entry.
///
/// <code lang="C#">
/// byte[] buffer= new byte[2048];
/// int n;
/// using (var raw = File.Open(_inputFileName, FileMode.Open, FileAccess.Read ))
/// {
///     using (var input= new ZipInputStream(raw))
///     {
///         ZipEntry e;
///         while (( e = input.GetNextEntry()) != null)
///         {
///             input.Password = PasswordForEntry(e.FileName);
///             if (e.IsDirectory) continue;
///             string outputPath = Path.Combine(_extractDir, e.FileName);
///             using (var output = File.Open(outputPath, FileMode.Create, FileAccess.ReadWrite))
///             {
///                 while ((n= input.Read(buffer,0,buffer.Length)) > 0)
///                 {
///                     output.Write(buffer,0,n);
///                 }
///             }
///         }
///     }
/// }
///
/// </code>
/// </example>
// Seek to the correct posn in the file, and open a
// stream that can be read.
/// <summary>
///   Read the data from the stream into the buffer.
/// </summary>
///
/// <remarks>
/// <para>
///   The data for the zipentry will be decrypted and uncompressed, as
///   necessary, before being copied into the buffer.
/// </para>
///
/// <para>
///   You must set the <see cref="Password"/> property before calling
///   <c>Read()</c> the first time for an encrypted entry.  To determine if an
///   entry is encrypted and requires a password, check the <see
///   cref="ZipEntry.Encryption">ZipEntry.Encryption</see> property.
/// </para>
/// </remarks>
///
/// <param name="buffer">The buffer to hold the data read from the stream.</param>
/// <param name="offset">the offset within the buffer to copy the first byte read.</param>
/// <param name="count">the number of bytes to read.</param>
/// <returns>the number of bytes read, after decryption and decompression.</returns>
/// <summary>
///   Read the next entry from the zip file.
/// </summary>
///
/// <remarks>
/// <para>
///   Call this method just before calling <see cref="Read(byte[], int, int)"/>,
///   to position the pointer in the zip file to the next entry that can be
///   read.  Subsequent calls to <c>Read()</c>, will decrypt and decompress the
///   data in the zip file, until <c>Read()</c> returns 0.
/// </para>
///
/// <para>
///   Each time you call <c>GetNextEntry()</c>, the pointer in the wrapped
///   stream is moved to the next entry in the zip file.  If you call <see
///   cref="Seek(long, SeekOrigin)"/>, and thus re-position the pointer within
///   the file, you will need to call <c>GetNextEntry()</c> again, to insure
///   that the file pointer is positioned at the beginning of a zip entry.
/// </para>
///
/// <para>
///   This method returns the <c>ZipEntry</c>. Using a stream approach, you will
///   read the raw bytes for an entry in a zip file via calls to <c>Read()</c>.
///   Alternatively, you can extract an entry into a file, or a stream, by
///   calling <see cref="ZipEntry.Extract()"/>, or one of its siblings.
/// </para>
///
/// </remarks>
///
/// <returns>
///   The <c>ZipEntry</c> read. Returns null (or Nothing in VB) if there are no more
///   entries in the zip file.
/// </returns>
///
// find the next signature
// back up 4 bytes: ReadEntry assumes the file pointer is positioned before the entry signature
// workitem 10923
// we've already read one entry.
// Seek to the end of it.
// ReadEntry leaves the file position after all the entry
// data and the optional bit-3 data descriptpr.  This is
// where the next entry would normally start.
/// <summary>
///   Dispose the stream.
/// </summary>
///
/// <remarks>
/// <para>
///   This method disposes the ZipInputStream.  It may also close the
///   underlying stream, depending on which constructor was used.
/// </para>
///
/// <para>
///   Typically the application will call <c>Dispose()</c> implicitly, via
///   a <c>using</c> statement in C#, or a <c>Using</c> statement in VB.
/// </para>
///
///   <para>
///     Application code won't call this code directly.  This method may
///     be invoked in two distinct scenarios.  If disposing == true, the
///     method has been called directly or indirectly by a user's code,
///     for example via the public Dispose() method. In this case, both
///     managed and unmanaged resources can be referenced and disposed.
///     If disposing == false, the method has been called by the runtime
///     from inside the object finalizer and this method should not
///     reference other objects; in that case only unmanaged resources
///     must be referenced or disposed.
///   </para>
/// </remarks>
///
/// <param name="disposing">
///   true if the Dispose method was invoked by user code.
/// </param>
// not called from finalizer
// When ZipInputStream is used within a using clause, and an
// exception is thrown, Close() is invoked.  But we don't want to
// try to write anything in that case.  Eventually the exception
// will be propagated to the application.
/// <summary>
/// Always returns true.
/// </summary>
/// <summary>
/// Returns the value of <c>CanSeek</c> for the underlying (wrapped) stream.
/// </summary>
/// <summary>
/// Always returns false.
/// </summary>
/// <summary>
/// Returns the length of the underlying stream.
/// </summary>
/// <summary>
/// Gets or sets the position of the underlying stream.
/// </summary>
/// <remarks>
/// Setting the position is equivalent to calling <c>Seek(value, SeekOrigin.Begin)</c>.
/// </remarks>
/// <summary>
/// This is a no-op.
/// </summary>
/// <summary>
/// This method always throws a NotSupportedException.
/// </summary>
/// <param name="buffer">ignored</param>
/// <param name="offset">ignored</param>
/// <param name="count">ignored</param>
/// <summary>
///   This method seeks in the underlying stream.
/// </summary>
///
/// <remarks>
/// <para>
///   Call this method if you want to seek around within the zip file for random access.
/// </para>
///
/// <para>
///   Applications can intermix calls to <c>Seek()</c> with calls to <see
///   cref="GetNextEntry()"/>.  After a call to <c>Seek()</c>,
///   <c>GetNextEntry()</c> will get the next <c>ZipEntry</c> that falls after
///   the current position in the input stream. You're on your own for finding
///   out just where to seek in the stream, to get to the various entries.
/// </para>
///
/// </remarks>
///
/// <param name="offset">the offset point to seek to</param>
/// <param name="origin">the reference point from which to seek</param>
/// <returns>The new position</returns>
/// <summary>
/// This method always throws a NotSupportedException.
/// </summary>
/// <param name="value">ignored</param>
// ZipOutputStream.cs
//
// ------------------------------------------------------------------
//
// Copyright (c) 2009 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-July-28 06:34:30>
//
// ------------------------------------------------------------------
//
// This module defines the ZipOutputStream class, which is a stream metaphor for
// generating zip files.  This class does not depend on Ionic.Zip.ZipFile, but rather
// stands alongside it as an alternative "container" for ZipEntry.  It replicates a
// subset of the properties, including these:
//
//  - Comment
//  - Encryption
//  - Password
//  - CodecBufferSize
//  - CompressionLevel
//  - CompressionMethod
//  - EnableZip64 (UseZip64WhenSaving)
//  - IgnoreCase (!CaseSensitiveRetrieval)
//
// It adds these novel methods:
//
//  - PutNextEntry
//
//
// ------------------------------------------------------------------
//
/// <summary>
///   Provides a stream metaphor for generating zip files.
/// </summary>
///
/// <remarks>
/// <para>
///   This class writes zip files, as defined in the <see
///   href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">specification
///   for zip files described by PKWare</see>.  The compression for this
///   implementation is provided by a managed-code version of Zlib, included with
///   DotNetZip in the classes in the Ionic.Zlib namespace.
/// </para>
///
/// <para>
///   This class provides an alternative programming model to the one enabled by the
///   <see cref="ZipFile"/> class. Use this when creating zip files, as an
///   alternative to the <see cref="ZipFile"/> class, when you would like to use a
///   <c>Stream</c> type to write the zip file.
/// </para>
///
/// <para>
///   Both the <c>ZipOutputStream</c> class and the <c>ZipFile</c> class can be used
///   to create zip files. Both of them support many of the common zip features,
///   including Unicode, different compression levels, and ZIP64.   They provide
///   very similar performance when creating zip files.
/// </para>
///
/// <para>
///   The <c>ZipFile</c> class is generally easier to use than
///   <c>ZipOutputStream</c> and should be considered a higher-level interface.  For
///   example, when creating a zip file via calls to the <c>PutNextEntry()</c> and
///   <c>Write()</c> methods on the <c>ZipOutputStream</c> class, the caller is
///   responsible for opening the file, reading the bytes from the file, writing
///   those bytes into the <c>ZipOutputStream</c>, setting the attributes on the
///   <c>ZipEntry</c>, and setting the created, last modified, and last accessed
///   timestamps on the zip entry. All of these things are done automatically by a
///   call to <see cref="ZipFile.AddFile(string,string)">ZipFile.AddFile()</see>.
///   For this reason, the <c>ZipOutputStream</c> is generally recommended for use
///   only when your application emits arbitrary data, not necessarily data from a
///   filesystem file, directly into a zip file, and does so using a <c>Stream</c>
///   metaphor.
/// </para>
///
/// <para>
///   Aside from the differences in programming model, there are other
///   differences in capability between the two classes.
/// </para>
///
/// <list type="bullet">
///   <item>
///     <c>ZipFile</c> can be used to read and extract zip files, in addition to
///     creating zip files. <c>ZipOutputStream</c> cannot read zip files. If you want
///     to use a stream to read zip files, check out the <see cref="ZipInputStream"/> class.
///   </item>
///
///   <item>
///     <c>ZipOutputStream</c> does not support the creation of segmented or spanned
///     zip files.
///   </item>
///
///   <item>
///     <c>ZipOutputStream</c> cannot produce a self-extracting archive.
///   </item>
/// </list>
///
/// <para>
///   Be aware that the <c>ZipOutputStream</c> class implements the <see
///   cref="System.IDisposable"/> interface.  In order for
///   <c>ZipOutputStream</c> to produce a valid zip file, you use use it within
///   a using clause (<c>Using</c> in VB), or call the <c>Dispose()</c> method
///   explicitly.  See the examples for how to employ a using clause.
/// </para>
///
/// <para>
///   Also, a note regarding compression performance: On the desktop .NET
///   Framework, DotNetZip can use a multi-threaded compression implementation
///   that provides significant speed increases on large files, over 300k or so,
///   at the cost of increased memory use at runtime.  (The output of the
///   compression is almost exactly the same size).  But, the multi-threaded
///   approach incurs a performance hit on smaller files. There's no way for the
///   ZipOutputStream to know whether parallel compression will be beneficial,
///   because the ZipOutputStream does not know how much data you will write
///   through the stream.  You may wish to set the <see
///   cref="ParallelDeflateThreshold"/> property to zero, if you are compressing
///   large files through <c>ZipOutputStream</c>.  This will cause parallel
///   compression to be used, always.
/// </para>
/// </remarks>
/// <summary>
///   Create a ZipOutputStream, wrapping an existing stream.
/// </summary>
///
/// <remarks>
/// <para>
///   The <see cref="ZipFile"/> class is generally easier to use when creating
///   zip files. The ZipOutputStream offers a different metaphor for creating a
///   zip file, based on the <see cref="System.IO.Stream"/> class.
/// </para>
///
/// </remarks>
///
/// <param name="stream">
/// The stream to wrap. It must be writable. This stream will be closed at
/// the time the ZipOutputStream is closed.
/// </param>
///
/// <example>
///
///   This example shows how to create a zip file, using the
///   ZipOutputStream class.
///
/// <code lang="C#">
/// private void Zipup()
/// {
///     if (filesToZip.Count == 0)
///     {
///         System.Console.WriteLine("Nothing to do.");
///         return;
///     }
///
///     using (var raw = File.Open(_outputFileName, FileMode.Create, FileAccess.ReadWrite ))
///     {
///         using (var output= new ZipOutputStream(raw))
///         {
///             output.Password = "VerySecret!";
///             output.Encryption = EncryptionAlgorithm.WinZipAes256;
///
///             foreach (string inputFileName in filesToZip)
///             {
///                 System.Console.WriteLine("file: {0}", inputFileName);
///
///                 output.PutNextEntry(inputFileName);
///                 using (var input = File.Open(inputFileName, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Write ))
///                 {
///                     byte[] buffer= new byte[2048];
///                     int n;
///                     while ((n= input.Read(buffer,0,buffer.Length)) > 0)
///                     {
///                         output.Write(buffer,0,n);
///                     }
///                 }
///             }
///         }
///     }
/// }
/// </code>
///
/// <code lang="VB">
/// Private Sub Zipup()
///     Dim outputFileName As String = "XmlData.zip"
///     Dim filesToZip As String() = Directory.GetFiles(".", "*.xml")
///     If (filesToZip.Length = 0) Then
///         Console.WriteLine("Nothing to do.")
///     Else
///         Using raw As FileStream = File.Open(outputFileName, FileMode.Create, FileAccess.ReadWrite)
///             Using output As ZipOutputStream = New ZipOutputStream(raw)
///                 output.Password = "VerySecret!"
///                 output.Encryption = EncryptionAlgorithm.WinZipAes256
///                 Dim inputFileName As String
///                 For Each inputFileName In filesToZip
///                     Console.WriteLine("file: {0}", inputFileName)
///                     output.PutNextEntry(inputFileName)
///                     Using input As FileStream = File.Open(inputFileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)
///                         Dim n As Integer
///                         Dim buffer As Byte() = New Byte(2048) {}
///                         Do While (n = input.Read(buffer, 0, buffer.Length) > 0)
///                             output.Write(buffer, 0, n)
///                         Loop
///                     End Using
///                 Next
///             End Using
///         End Using
///     End If
/// End Sub
/// </code>
/// </example>
/// <summary>
///   Create a ZipOutputStream that writes to a filesystem file.
/// </summary>
///
/// <remarks>
///   The <see cref="ZipFile"/> class is generally easier to use when creating
///   zip files. The ZipOutputStream offers a different metaphor for creating a
///   zip file, based on the <see cref="System.IO.Stream"/> class.
/// </remarks>
///
/// <param name="fileName">
///   The name of the zip file to create.
/// </param>
///
/// <example>
///
///   This example shows how to create a zip file, using the
///   ZipOutputStream class.
///
/// <code lang="C#">
/// private void Zipup()
/// {
///     if (filesToZip.Count == 0)
///     {
///         System.Console.WriteLine("Nothing to do.");
///         return;
///     }
///
///     using (var output= new ZipOutputStream(outputFileName))
///     {
///         output.Password = "VerySecret!";
///         output.Encryption = EncryptionAlgorithm.WinZipAes256;
///
///         foreach (string inputFileName in filesToZip)
///         {
///             System.Console.WriteLine("file: {0}", inputFileName);
///
///             output.PutNextEntry(inputFileName);
///             using (var input = File.Open(inputFileName, FileMode.Open, FileAccess.Read,
///                                          FileShare.Read | FileShare.Write ))
///             {
///                 byte[] buffer= new byte[2048];
///                 int n;
///                 while ((n= input.Read(buffer,0,buffer.Length)) > 0)
///                 {
///                     output.Write(buffer,0,n);
///                 }
///             }
///         }
///     }
/// }
/// </code>
///
/// <code lang="VB">
/// Private Sub Zipup()
///     Dim outputFileName As String = "XmlData.zip"
///     Dim filesToZip As String() = Directory.GetFiles(".", "*.xml")
///     If (filesToZip.Length = 0) Then
///         Console.WriteLine("Nothing to do.")
///     Else
///         Using output As ZipOutputStream = New ZipOutputStream(outputFileName)
///             output.Password = "VerySecret!"
///             output.Encryption = EncryptionAlgorithm.WinZipAes256
///             Dim inputFileName As String
///             For Each inputFileName In filesToZip
///                 Console.WriteLine("file: {0}", inputFileName)
///                 output.PutNextEntry(inputFileName)
///                 Using input As FileStream = File.Open(inputFileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)
///                     Dim n As Integer
///                     Dim buffer As Byte() = New Byte(2048) {}
///                     Do While (n = input.Read(buffer, 0, buffer.Length) > 0)
///                         output.Write(buffer, 0, n)
///                     Loop
///                 End Using
///             Next
///         End Using
///     End If
/// End Sub
/// </code>
/// </example>
/// <summary>
///   Create a ZipOutputStream.
/// </summary>
///
/// <remarks>
///   See the documentation for the <see
///   cref="ZipOutputStream(Stream)">ZipOutputStream(Stream)</see>
///   constructor for an example.
/// </remarks>
///
/// <param name="stream">
///   The stream to wrap. It must be writable.
/// </param>
///
/// <param name="leaveOpen">
///   true if the application would like the stream
///   to remain open after the <c>ZipOutputStream</c> has been closed.
/// </param>
// workitem 9307
/// <summary>Provides a string representation of the instance.</summary>
/// <remarks>
///   <para>
///     This can be useful for debugging purposes.
///   </para>
/// </remarks>
/// <returns>a string representation of the instance.</returns>
/// <summary>
///   Sets the password to be used on the <c>ZipOutputStream</c> instance.
/// </summary>
///
/// <remarks>
///
/// <para>
///   When writing a zip archive, this password is applied to the entries, not
///   to the zip archive itself. It applies to any <c>ZipEntry</c> subsequently
///   written to the <c>ZipOutputStream</c>.
/// </para>
///
/// <para>
///   Using a password does not encrypt or protect the "directory" of the
///   archive - the list of entries contained in the archive.  If you set the
///   <c>Password</c> property, the password actually applies to individual
///   entries that are added to the archive, subsequent to the setting of this
///   property.  The list of filenames in the archive that is eventually created
///   will appear in clear text, but the contents of the individual files are
///   encrypted.  This is how Zip encryption works.
/// </para>
///
/// <para>
///   If you set this property, and then add a set of entries to the archive via
///   calls to <c>PutNextEntry</c>, then each entry is encrypted with that
///   password.  You may also want to change the password between adding
///   different entries. If you set the password, add an entry, then set the
///   password to <c>null</c> (<c>Nothing</c> in VB), and add another entry, the
///   first entry is encrypted and the second is not.
/// </para>
///
/// <para>
///   When setting the <c>Password</c>, you may also want to explicitly set the <see
///   cref="Encryption"/> property, to specify how to encrypt the entries added
///   to the ZipFile.  If you set the <c>Password</c> to a non-null value and do not
///   set <see cref="Encryption"/>, then PKZip 2.0 ("Weak") encryption is used.
///   This encryption is relatively weak but is very interoperable. If
///   you set the password to a <c>null</c> value (<c>Nothing</c> in VB),
///   <c>Encryption</c> is reset to None.
/// </para>
///
/// <para>
///   Special case: if you wrap a ZipOutputStream around a non-seekable stream,
///   and use encryption, and emit an entry of zero bytes, the <c>Close()</c> or
///   <c>PutNextEntry()</c> following the entry will throw an exception.
/// </para>
///
/// </remarks>
/// <summary>
///   The Encryption to use for entries added to the <c>ZipOutputStream</c>.
/// </summary>
///
/// <remarks>
/// <para>
///   The specified Encryption is applied to the entries subsequently
///   written to the <c>ZipOutputStream</c> instance.
/// </para>
///
/// <para>
///   If you set this to something other than
///   EncryptionAlgorithm.None, you will also need to set the
///   <see cref="Password"/> to a non-null, non-empty value in
///   order to actually get encryption on the entry.
/// </para>
///
/// </remarks>
///
/// <seealso cref="Password">ZipOutputStream.Password</seealso>
/// <seealso cref="Ionic.Zip.ZipEntry.Encryption">ZipEntry.Encryption</seealso>
/// <summary>
///   Size of the work buffer to use for the ZLIB codec during compression.
/// </summary>
///
/// <remarks>
///   Setting this may affect performance.  For larger files, setting this to a
///   larger size may improve performance, but I'm not sure.  Sorry, I don't
///   currently have good recommendations on how to set it.  You can test it if
///   you like.
/// </remarks>
/// <summary>
///   The compression strategy to use for all entries.
/// </summary>
///
/// <remarks>
///   Set the Strategy used by the ZLIB-compatible compressor, when compressing
///   data for the entries in the zip archive. Different compression strategies
///   work better on different sorts of data. The strategy parameter can affect
///   the compression ratio and the speed of compression but not the correctness
///   of the compresssion.  For more information see <see
///   cref="Ionic.Zlib.CompressionStrategy "/>.
/// </remarks>
/// <summary>
///   The type of timestamp attached to the ZipEntry.
/// </summary>
///
/// <remarks>
///   Set this in order to specify the kind of timestamp that should be emitted
///   into the zip file for each entry.
/// </remarks>
/// <summary>
///   Sets the compression level to be used for entries subsequently added to
///   the zip archive.
/// </summary>
///
/// <remarks>
///  <para>
///    Varying the compression level used on entries can affect the
///    size-vs-speed tradeoff when compression and decompressing data streams
///    or files.
///  </para>
///
///  <para>
///    As with some other properties on the <c>ZipOutputStream</c> class, like <see
///    cref="Password"/>, and <see cref="Encryption"/>,
///    setting this property on a <c>ZipOutputStream</c>
///    instance will cause the specified <c>CompressionLevel</c> to be used on all
///    <see cref="ZipEntry"/> items that are subsequently added to the
///    <c>ZipOutputStream</c> instance.
///  </para>
///
///  <para>
///    If you do not set this property, the default compression level is used,
///    which normally gives a good balance of compression efficiency and
///    compression speed.  In some tests, using <c>BestCompression</c> can
///    double the time it takes to compress, while delivering just a small
///    increase in compression efficiency.  This behavior will vary with the
///    type of data you compress.  If you are in doubt, just leave this setting
///    alone, and accept the default.
///  </para>
/// </remarks>
/// <summary>
///   The compression method used on each entry added to the ZipOutputStream.
/// </summary>
/// <summary>
///   A comment attached to the zip archive.
/// </summary>
///
/// <remarks>
///
/// <para>
///   The application sets this property to specify a comment to be embedded
///   into the generated zip archive.
/// </para>
///
/// <para>
///   According to <see
///   href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
///   zip specification</see>, the comment is not encrypted, even if there is a
///   password set on the zip file.
/// </para>
///
/// <para>
///   The specification does not describe how to indicate the encoding used
///   on a comment string. Many "compliant" zip tools and libraries use
///   IBM437 as the code page for comments; DotNetZip, too, follows that
///   practice.  On the other hand, there are situations where you want a
///   Comment to be encoded with something else, for example using code page
///   950 "Big-5 Chinese". To fill that need, DotNetZip will encode the
///   comment following the same procedure it follows for encoding
///   filenames: (a) if <see cref="AlternateEncodingUsage"/> is
///   <c>Never</c>, it uses the default encoding (IBM437). (b) if <see
///   cref="AlternateEncodingUsage"/> is <c>Always</c>, it always uses the
///   alternate encoding (<see cref="AlternateEncoding"/>). (c) if <see
///   cref="AlternateEncodingUsage"/> is <c>AsNecessary</c>, it uses the
///   alternate encoding only if the default encoding is not sufficient for
///   encoding the comment - in other words if decoding the result does not
///   produce the original string.  This decision is taken at the time of
///   the call to <c>ZipFile.Save()</c>.
/// </para>
///
/// </remarks>
/// <summary>
///   Specify whether to use ZIP64 extensions when saving a zip archive.
/// </summary>
///
/// <remarks>
/// <para>
///   The default value for the property is <see
///   cref="Zip64Option.Never"/>. <see cref="Zip64Option.AsNecessary"/> is
///   safest, in the sense that you will not get an Exception if a
///   pre-ZIP64 limit is exceeded.
/// </para>
///
/// <para>
///   You must set this property before calling <c>Write()</c>.
/// </para>
///
/// </remarks>
/// <summary>
///   Indicates whether ZIP64 extensions were used when saving the zip archive.
/// </summary>
///
/// <remarks>
///   The value is defined only after the <c>ZipOutputStream</c> has been closed.
/// </remarks>
/// <summary>
///   Whether the ZipOutputStream should use case-insensitive comparisons when
///   checking for uniqueness of zip entries.
/// </summary>
///
/// <remarks>
///   <para>
///   Though the zip specification doesn't prohibit zipfiles with duplicate
///   entries, Sane zip files have no duplicates, and the DotNetZip library
///   cannot create zip files with duplicate entries. If an application attempts
///   to call <see cref="PutNextEntry(String)"/> with a name that duplicates one
///   already used within the archive, the library will throw an Exception.
///   </para>
///   <para>
///   This property allows the application to specify whether the
///   ZipOutputStream instance considers ordinal case when checking for
///   uniqueness of zip entries.
///   </para>
/// </remarks>
/// <summary>
///   Indicates whether to encode entry filenames and entry comments using
///   Unicode (UTF-8).
/// </summary>
///
/// <remarks>
/// <para>
///   <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">The
///   PKWare zip specification</see> provides for encoding file names and file
///   comments in either the IBM437 code page, or in UTF-8.  This flag selects
///   the encoding according to that specification.  By default, this flag is
///   false, and filenames and comments are encoded into the zip file in the
///   IBM437 codepage.  Setting this flag to true will specify that filenames
///   and comments that cannot be encoded with IBM437 will be encoded with
///   UTF-8.
/// </para>
///
/// <para>
///   Zip files created with strict adherence to the PKWare specification with
///   respect to UTF-8 encoding can contain entries with filenames containing
///   any combination of Unicode characters, including the full range of
///   characters from Chinese, Latin, Hebrew, Greek, Cyrillic, and many other
///   alphabets.  However, because at this time, the UTF-8 portion of the PKWare
///   specification is not broadly supported by other zip libraries and
///   utilities, such zip files may not be readable by your favorite zip tool or
///   archiver. In other words, interoperability will decrease if you set this
///   flag to true.
/// </para>
///
/// <para>
///   In particular, Zip files created with strict adherence to the PKWare
///   specification with respect to UTF-8 encoding will not work well with
///   Explorer in Windows XP or Windows Vista, because Windows compressed
///   folders, as far as I know, do not support UTF-8 in zip files.  Vista can
///   read the zip files, but shows the filenames incorrectly. Unpacking from
///   Windows Vista Explorer will result in filenames that have rubbish
///   characters in place of the high-order UTF-8 bytes.
/// </para>
///
/// <para>
///   Also, zip files that use UTF-8 encoding will not work well with Java
///   applications that use the java.util.zip classes, as of v5.0 of the Java
///   runtime. The Java runtime does not correctly implement the PKWare
///   specification in this regard.
/// </para>
///
/// <para>
///   As a result, we have the unfortunate situation that "correct" behavior by
///   the DotNetZip library with regard to Unicode encoding of filenames during
///   zip creation will result in zip files that are readable by strictly
///   compliant and current tools (for example the most recent release of the
///   commercial WinZip tool); but these zip files will not be readable by
///   various other tools or libraries, including Windows Explorer.
/// </para>
///
/// <para>
///   The DotNetZip library can read and write zip files with UTF8-encoded
///   entries, according to the PKware spec.  If you use DotNetZip for both
///   creating and reading the zip file, and you use UTF-8, there will be no
///   loss of information in the filenames. For example, using a self-extractor
///   created by this library will allow you to unpack files correctly with no
///   loss of information in the filenames.
/// </para>
///
/// <para>
///   If you do not set this flag, it will remain false.  If this flag is false,
///   the <c>ZipOutputStream</c> will encode all filenames and comments using
///   the IBM437 codepage.  This can cause "loss of information" on some
///   filenames, but the resulting zipfile will be more interoperable with other
///   utilities. As an example of the loss of information, diacritics can be
///   lost.  The o-tilde character will be down-coded to plain o.  The c with a
///   cedilla (Unicode 0xE7) used in Portugese will be downcoded to a c.
///   Likewise, the O-stroke character (Unicode 248), used in Danish and
///   Norwegian, will be down-coded to plain o. Chinese characters cannot be
///   represented in codepage IBM437; when using the default encoding, Chinese
///   characters in filenames will be represented as ?. These are all examples
///   of "information loss".
/// </para>
///
/// <para>
///   The loss of information associated to the use of the IBM437 encoding is
///   inconvenient, and can also lead to runtime errors. For example, using
///   IBM437, any sequence of 4 Chinese characters will be encoded as ????.  If
///   your application creates a <c>ZipOutputStream</c>, does not set the
///   encoding, then adds two files, each with names of four Chinese characters
///   each, this will result in a duplicate filename exception.  In the case
///   where you add a single file with a name containing four Chinese
///   characters, the zipfile will save properly, but extracting that file
///   later, with any zip tool, will result in an error, because the question
///   mark is not legal for use within filenames on Windows.  These are just a
///   few examples of the problems associated to loss of information.
/// </para>
///
/// <para>
///   This flag is independent of the encoding of the content within the entries
///   in the zip file. Think of the zip file as a container - it supports an
///   encoding.  Within the container are other "containers" - the file entries
///   themselves.  The encoding within those entries is independent of the
///   encoding of the zip archive container for those entries.
/// </para>
///
/// <para>
///   Rather than specify the encoding in a binary fashion using this flag, an
///   application can specify an arbitrary encoding via the <see
///   cref="ProvisionalAlternateEncoding"/> property.  Setting the encoding
///   explicitly when creating zip archives will result in non-compliant zip
///   files that, curiously, are fairly interoperable.  The challenge is, the
///   PKWare specification does not provide for a way to specify that an entry
///   in a zip archive uses a code page that is neither IBM437 nor UTF-8.
///   Therefore if you set the encoding explicitly when creating a zip archive,
///   you must take care upon reading the zip archive to use the same code page.
///   If you get it wrong, the behavior is undefined and may result in incorrect
///   filenames, exceptions, stomach upset, hair loss, and acne.
/// </para>
/// </remarks>
/// <seealso cref="ProvisionalAlternateEncoding"/>
/// <summary>
///   The text encoding to use when emitting entries into the zip archive, for
///   those entries whose filenames or comments cannot be encoded with the
///   default (IBM437) encoding.
/// </summary>
///
/// <remarks>
/// <para>
///   In <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">its
///   zip specification</see>, PKWare describes two options for encoding
///   filenames and comments: using IBM437 or UTF-8.  But, some archiving tools
///   or libraries do not follow the specification, and instead encode
///   characters using the system default code page.  For example, WinRAR when
///   run on a machine in Shanghai may encode filenames with the Big-5 Chinese
///   (950) code page.  This behavior is contrary to the Zip specification, but
///   it occurs anyway.
/// </para>
///
/// <para>
///   When using DotNetZip to write zip archives that will be read by one of
///   these other archivers, set this property to specify the code page to use
///   when encoding the <see cref="ZipEntry.FileName"/> and <see
///   cref="ZipEntry.Comment"/> for each <c>ZipEntry</c> in the zip file, for
///   values that cannot be encoded with the default codepage for zip files,
///   IBM437.  This is why this property is "provisional".  In all cases, IBM437
///   is used where possible, in other words, where no loss of data would
///   result. It is possible, therefore, to have a given entry with a
///   <c>Comment</c> encoded in IBM437 and a <c>FileName</c> encoded with the
///   specified "provisional" codepage.
/// </para>
///
/// <para>
///   Be aware that a zip file created after you've explicitly set the
///   <c>ProvisionalAlternateEncoding</c> property to a value other than
///   IBM437 may not be compliant to the PKWare specification, and may not be
///   readable by compliant archivers.  On the other hand, many (most?)
///   archivers are non-compliant and can read zip files created in arbitrary
///   code pages.  The trick is to use or specify the proper codepage when
///   reading the zip.
/// </para>
///
/// <para>
///   When creating a zip archive using this library, it is possible to change
///   the value of <c>ProvisionalAlternateEncoding</c> between each entry you
///   add, and between adding entries and the call to <c>Close()</c>. Don't do
///   this. It will likely result in a zipfile that is not readable.  For best
///   interoperability, either leave <c>ProvisionalAlternateEncoding</c>
///   alone, or specify it only once, before adding any entries to the
///   <c>ZipOutputStream</c> instance.  There is one exception to this
///   recommendation, described later.
/// </para>
///
/// <para>
///   When using an arbitrary, non-UTF8 code page for encoding, there is no
///   standard way for the creator application - whether DotNetZip, WinZip,
///   WinRar, or something else - to formally specify in the zip file which
///   codepage has been used for the entries. As a result, readers of zip files
///   are not able to inspect the zip file and determine the codepage that was
///   used for the entries contained within it.  It is left to the application
///   or user to determine the necessary codepage when reading zip files encoded
///   this way.  If you use an incorrect codepage when reading a zipfile, you
///   will get entries with filenames that are incorrect, and the incorrect
///   filenames may even contain characters that are not legal for use within
///   filenames in Windows. Extracting entries with illegal characters in the
///   filenames will lead to exceptions. It's too bad, but this is just the way
///   things are with code pages in zip files. Caveat Emptor.
/// </para>
///
/// <para>
///   One possible approach for specifying the code page for a given zip file is
///   to describe the code page in a human-readable form in the Zip comment. For
///   example, the comment may read "Entries in this archive are encoded in the
///   Big5 code page".  For maximum interoperability, the zip comment in this
///   case should be encoded in the default, IBM437 code page.  In this case,
///   the zip comment is encoded using a different page than the filenames.  To
///   do this, Specify <c>ProvisionalAlternateEncoding</c> to your desired
///   region-specific code page, once before adding any entries, and then set
///   the <see cref="Comment"/> property and reset
///   <c>ProvisionalAlternateEncoding</c> to IBM437 before calling <c>Close()</c>.
/// </para>
/// </remarks>
/// <summary>
///   A Text Encoding to use when encoding the filenames and comments for
///   all the ZipEntry items, during a ZipFile.Save() operation.
/// </summary>
/// <remarks>
///   <para>
///     Whether the encoding specified here is used during the save depends
///     on <see cref="AlternateEncodingUsage"/>.
///   </para>
/// </remarks>
/// <summary>
///   A flag that tells if and when this instance should apply
///   AlternateEncoding to encode the filenames and comments associated to
///   of ZipEntry objects contained within this instance.
/// </summary>
/// <summary>
/// The default text encoding used in zip archives.  It is numeric 437, also
/// known as IBM437.
/// </summary>
/// <seealso cref="Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>
/// <summary>
///   The size threshold for an entry, above which a parallel deflate is used.
/// </summary>
///
/// <remarks>
///
///   <para>
///     DotNetZip will use multiple threads to compress any ZipEntry, when
///     the <c>CompressionMethod</c> is Deflate, and if the entry is
///     larger than the given size.  Zero means "always use parallel
///     deflate", while -1 means "never use parallel deflate".
///   </para>
///
///   <para>
///     If the entry size cannot be known before compression, as with any entry
///     added via a ZipOutputStream, then Parallel deflate will never be
///     performed, unless the value of this property is zero.
///   </para>
///
///   <para>
///     A parallel deflate operations will speed up the compression of
///     large files, on computers with multiple CPUs or multiple CPU
///     cores.  For files above 1mb, on a dual core or dual-cpu (2p)
///     machine, the time required to compress the file can be 70% of the
///     single-threaded deflate.  For very large files on 4p machines the
///     compression can be done in 30% of the normal time.  The downside
///     is that parallel deflate consumes extra memory during the deflate,
///     and the deflation is slightly less effective.
///   </para>
///
///   <para>
///     Parallel deflate tends to not be as effective as single-threaded deflate
///     because the original data stream is split into multiple independent
///     buffers, each of which is compressed in parallel.  But because they are
///     treated independently, there is no opportunity to share compression
///     dictionaries, and additional framing bytes must be added to the output
///     stream.  For that reason, a deflated stream may be slightly larger when
///     compressed using parallel deflate, as compared to a traditional
///     single-threaded deflate. For files of about 512k, the increase over the
///     normal deflate is as much as 5% of the total compressed size. For larger
///     files, the difference can be as small as 0.1%.
///   </para>
///
///   <para>
///     Multi-threaded compression does not give as much an advantage when using
///     Encryption. This is primarily because encryption tends to slow down
///     the entire pipeline. Also, multi-threaded compression gives less of an
///     advantage when using lower compression levels, for example <see
///     cref="Ionic.Zlib.CompressionLevel.BestSpeed"/>.  You may have to perform
///     some tests to determine the best approach for your situation.
///   </para>
///
///   <para>
///     The default value for this property is -1, which means parallel
///     compression will not be performed unless you set it to zero.
///   </para>
///
/// </remarks>
/// <summary>
///   The maximum number of buffer pairs to use when performing
///   parallel compression.
/// </summary>
///
/// <remarks>
/// <para>
///   This property sets an upper limit on the number of memory
///   buffer pairs to create when performing parallel
///   compression.  The implementation of the parallel
///   compression stream allocates multiple buffers to
///   facilitate parallel compression.  As each buffer fills up,
///   the stream uses <see
///   cref="System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback)">
///   ThreadPool.QueueUserWorkItem()</see> to compress those
///   buffers in a background threadpool thread. After a buffer
///   is compressed, it is re-ordered and written to the output
///   stream.
/// </para>
///
/// <para>
///   A higher number of buffer pairs enables a higher degree of
///   parallelism, which tends to increase the speed of compression on
///   multi-cpu computers.  On the other hand, a higher number of buffer
///   pairs also implies a larger memory consumption, more active worker
///   threads, and a higher cpu utilization for any compression. This
///   property enables the application to limit its memory consumption and
///   CPU utilization behavior depending on requirements.
/// </para>
///
/// <para>
///   For each compression "task" that occurs in parallel, there are 2
///   buffers allocated: one for input and one for output.  This property
///   sets a limit for the number of pairs.  The total amount of storage
///   space allocated for buffering will then be (N*S*2), where N is the
///   number of buffer pairs, S is the size of each buffer (<see
///   cref="CodecBufferSize"/>).  By default, DotNetZip allocates 4 buffer
///   pairs per CPU core, so if your machine has 4 cores, and you retain
///   the default buffer size of 128k, then the
///   ParallelDeflateOutputStream will use 4 * 4 * 2 * 128kb of buffer
///   memory in total, or 4mb, in blocks of 128kb.  If you then set this
///   property to 8, then the number will be 8 * 2 * 128kb of buffer
///   memory, or 2mb.
/// </para>
///
/// <para>
///   CPU utilization will also go up with additional buffers, because a
///   larger number of buffer pairs allows a larger number of background
///   threads to compress in parallel. If you find that parallel
///   compression is consuming too much memory or CPU, you can adjust this
///   value downward.
/// </para>
///
/// <para>
///   The default value is 16. Different values may deliver better or
///   worse results, depending on your priorities and the dynamic
///   performance characteristics of your storage and compute resources.
/// </para>
///
/// <para>
///   This property is not the number of buffer pairs to use; it is an
///   upper limit. An illustration: Suppose you have an application that
///   uses the default value of this property (which is 16), and it runs
///   on a machine with 2 CPU cores. In that case, DotNetZip will allocate
///   4 buffer pairs per CPU core, for a total of 8 pairs.  The upper
///   limit specified by this property has no effect.
/// </para>
///
/// <para>
///   The application can set this value at any time, but it is
///   effective only if set before calling
///   <c>ZipOutputStream.Write()</c> for the first time.
/// </para>
/// </remarks>
///
/// <seealso cref="ParallelDeflateThreshold"/>
///
/// <summary>
///   Returns true if an entry by the given name has already been written
///   to the ZipOutputStream.
/// </summary>
///
/// <param name="name">
///   The name of the entry to scan for.
/// </param>
///
/// <returns>
/// true if an entry by the given name has already been written.
/// </returns>
/// <summary>
///   Write the data from the buffer to the stream.
/// </summary>
///
/// <remarks>
///   As the application writes data into this stream, the data may be
///   compressed and encrypted before being written out to the underlying
///   stream, depending on the settings of the <see cref="CompressionLevel"/>
///   and the <see cref="Encryption"/> properties.
/// </remarks>
///
/// <param name="buffer">The buffer holding data to write to the stream.</param>
/// <param name="offset">the offset within that data array to find the first byte to write.</param>
/// <param name="count">the number of bytes to write.</param>
/// <summary>
///   Specify the name of the next entry that will be written to the zip file.
/// </summary>
///
/// <remarks>
/// <para>
///   Call this method just before calling <see cref="Write(byte[], int, int)"/>, to
///   specify the name of the entry that the next set of bytes written to
///   the <c>ZipOutputStream</c> belongs to. All subsequent calls to <c>Write</c>,
///   until the next call to <c>PutNextEntry</c>,
///   will be inserted into the named entry in the zip file.
/// </para>
///
/// <para>
///   If the <paramref name="entryName"/> used in <c>PutNextEntry()</c> ends in
///   a slash, then the entry added is marked as a directory. Because directory
///   entries do not contain data, a call to <c>Write()</c>, before an
///   intervening additional call to <c>PutNextEntry()</c>, will throw an
///   exception.
/// </para>
///
/// <para>
///   If you don't call <c>Write()</c> between two calls to
///   <c>PutNextEntry()</c>, the first entry is inserted into the zip file as a
///   file of zero size.  This may be what you want.
/// </para>
///
/// <para>
///   Because <c>PutNextEntry()</c> closes out the prior entry, if any, this
///   method may throw if there is a problem with the prior entry.
/// </para>
///
/// <para>
///   This method returns the <c>ZipEntry</c>.  You can modify public properties
///   on the <c>ZipEntry</c>, such as <see cref="ZipEntry.Encryption"/>, <see
///   cref="ZipEntry.Password"/>, and so on, until the first call to
///   <c>ZipOutputStream.Write()</c>, or until the next call to
///   <c>PutNextEntry()</c>.  If you modify the <c>ZipEntry</c> <em>after</em>
///   having called <c>Write()</c>, you may get a runtime exception, or you may
///   silently get an invalid zip archive.
/// </para>
///
/// </remarks>
///
/// <example>
///
///   This example shows how to create a zip file, using the
///   <c>ZipOutputStream</c> class.
///
/// <code>
/// private void Zipup()
/// {
///     using (FileStream fs raw = File.Open(_outputFileName, FileMode.Create, FileAccess.ReadWrite ))
///     {
///         using (var output= new ZipOutputStream(fs))
///         {
///             output.Password = "VerySecret!";
///             output.Encryption = EncryptionAlgorithm.WinZipAes256;
///             output.PutNextEntry("entry1.txt");
///             byte[] buffer= System.Text.Encoding.ASCII.GetBytes("This is the content for entry #1.");
///             output.Write(buffer,0,buffer.Length);
///             output.PutNextEntry("entry2.txt");  // this will be zero length
///             output.PutNextEntry("entry3.txt");
///             buffer= System.Text.Encoding.ASCII.GetBytes("This is the content for entry #3.");
///             output.Write(buffer,0,buffer.Length);
///         }
///     }
/// }
/// </code>
/// </example>
///
/// <param name="entryName">
///   The name of the entry to be added, including any path to be used
///   within the zip file.
/// </param>
///
/// <returns>
///   The ZipEntry created.
/// </returns>
///
// workitem 8932
// workitem 13909
// workitem 12634
// If finishing==true, this means we're initiating the entry at the time of
// Close() or PutNextEntry().  If this happens, it means no data was written
// for the entry - Write() was never called.  (The usual case us to call
// _InitiateCurrentEntry(bool) from within Write().)  If finishing==true,
// the entry could be either a zero-byte file or a directory.
// could use _entriesWritten.Count, but I don't want to incur
// the cost.
// Write out the header.
//
// If finishing, and encryption is in use, then we don't want to emit the
// normal encryption header.  Signal that with a cycle=99 to turn off
// encryption for zero-byte entries or directories.
//
// If finishing, then we know the stream length is zero.  Else, unknown
// stream length.  Passing stream length == 0 allows an optimization so as
// not to setup an encryption or deflation stream, when stream length is
// zero.
// an empty entry - no writes
// workitem 12964
// reset all the streams
/// <summary>
/// Dispose the stream
/// </summary>
///
/// <remarks>
/// <para>
///   This method writes the Zip Central directory, then closes the stream.  The
///   application must call Dispose() (or Close) in order to produce a valid zip file.
/// </para>
///
/// <para>
///   Typically the application will call <c>Dispose()</c> implicitly, via a <c>using</c>
///   statement in C#, or a <c>Using</c> statement in VB.
/// </para>
///
/// </remarks>
///
/// <param name="disposing">set this to true, always.</param>
// not called from finalizer
// handle pending exceptions
// _numberOfSegmentsForMostRecentSave,
/// <summary>
/// Always returns false.
/// </summary>
/// <summary>
/// Always returns false.
/// </summary>
/// <summary>
/// Always returns true.
/// </summary>
/// <summary>
/// Always returns a NotSupportedException.
/// </summary>
/// <summary>
/// Setting this property always returns a NotSupportedException. Getting it
/// returns the value of the Position on the underlying stream.
/// </summary>
/// <summary>
/// This is a no-op.
/// </summary>
/// <summary>
/// This method always throws a NotSupportedException.
/// </summary>
/// <param name="buffer">ignored</param>
/// <param name="offset">ignored</param>
/// <param name="count">ignored</param>
/// <returns>nothing</returns>
/// <summary>
/// This method always throws a NotSupportedException.
/// </summary>
/// <param name="offset">ignored</param>
/// <param name="origin">ignored</param>
/// <returns>nothing</returns>
/// <summary>
/// This method always throws a NotSupportedException.
/// </summary>
/// <param name="value">ignored</param>
// default = IBM437
// **see note below
// **Note regarding exceptions:
// When ZipOutputStream is employed within a using clause, which
// is the typical scenario, and an exception is thrown within
// the scope of the using, Close()/Dispose() is invoked
// implicitly before processing the initial exception.  In that
// case, _exceptionPending is true, and we don't want to try to
// write anything in the Close/Dispose logic.  Doing so can
// cause additional exceptions that mask the original one. So,
// the _exceptionPending flag is used to track that, and to
// allow the original exception to be propagated to the
// application without extra "noise."
// n/a
// ZipSegmentedStream.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2011 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-July-13 22:25:45>
//
// ------------------------------------------------------------------
//
// This module defines logic for zip streams that span disk files.
//
// ------------------------------------------------------------------
//Update = 3
// **see note below
//private bool _isDisposed;
// **Note regarding exceptions:
//
// When ZipSegmentedStream is employed within a using clause,
// which is the typical scenario, and an exception is thrown
// within the scope of the using, Dispose() is invoked
// implicitly before processing the initial exception.  If that
// happens, this class sets _exceptionPending to true, and then
// within the Dispose(bool), takes special action as
// appropriate. Need to be careful: any additional exceptions
// will mask the original one.
// Console.WriteLine("ZSS: ForReading ({0})",
//                    Path.GetFileName(zss.CurrentName));
// workitem 9522
// Console.WriteLine("ZSS: ForWriting ({0})",
//                    Path.GetFileName(zss.CurrentName));
/// <summary>
///   Sort-of like a factory method, ForUpdate is used only when
///   the application needs to update the zip entry metadata for
///   a segmented zip file, when the starting segment is earlier
///   than the ending segment, for a particular entry.
/// </summary>
/// <remarks>
///   <para>
///     The update is always contiguous, never rolls over.  As a
///     result, this method doesn't need to return a ZSS; it can
///     simply return a FileStream.  That's why it's "sort of"
///     like a Factory method.
///   </para>
///   <para>
///     Caller must Close/Dispose the stream object returned by
///     this method.
///   </para>
/// </remarks>
// Console.WriteLine("ZSS: ForUpdate ({0})",
//                   Path.GetFileName(fname));
// This class assumes that the update will not expand the
// size of the segment. Update is used only for an in-place
// update of zip metadata. It never will try to write beyond
// the end of a segment.
// it will get updated next time referenced
/// <summary>
///   Name of the filesystem file corresponding to the current segment.
/// </summary>
/// <remarks>
///   <para>
///     The name is not always the name currently being used in the
///     filesystem.  When rwMode is RwMode.Write, the filesystem file has a
///     temporary name until the stream is closed or until the next segment is
///     started.
///   </para>
/// </remarks>
// Returns the segment that WILL be current if writing
// a block of the given length.
// This isn't exactly true. It could roll over beyond
// this number.
// the block will go AT LEAST into the next segment
// it will fit in the current segment
// Console.WriteLine("ZSS: SRS ({0})",
//                   Path.GetFileName(CurrentName));
/// <summary>
/// Read from the stream
/// </summary>
/// <param name="buffer">the buffer to read</param>
/// <param name="offset">the offset at which to start</param>
/// <param name="count">the number of bytes to read</param>
/// <returns>the number of bytes actually read</returns>
// no more to read
// Console.WriteLine("ZSS: SWS close ({0})",
//                   Path.GetFileName(CurrentName));
// Console.WriteLine("ZSS: SWS open ({0})",
//                   Path.GetFileName(_currentTempName));
/// <summary>
/// Write to the stream.
/// </summary>
/// <param name="buffer">the buffer from which to write</param>
/// <param name="offset">the offset at which to start writing</param>
/// <param name="count">the number of bytes to write</param>
// enough space for a contiguous write?
// Console.WriteLine("***ZSS.Trunc to disk {0}", diskNumber);
// Console.WriteLine("***ZSS.Trunc:  current disk {0}", CurrentSegment);
// Seek back in the segmented stream to a (maybe) prior segment.
// Check if it is the same segment.  If it is, very simple.
// Seeking back to a prior segment.
// The current segment and any intervening segments must be removed.
// First, close the current segment, and then remove it.
// Now, remove intervening segments.
// Console.WriteLine("***ZSS.Trunc:  removing file {0}", s);
// now, open the desired segment.  It must exist.
// get a new temp file, try 3 times:
// move the .z0x file back to a temp name
// workitem 12403
// open it
// this gets called by Stream.Close()
// if (_isDisposed) return;
// _isDisposed = true;
//Console.WriteLine("Dispose (mode={0})\n", rwMode.ToString());
//_innerStream = null;
// possibly could try to clean up all the
// temp files created so far...
// // move the final temp file to the .zNN name
// if (File.Exists(CurrentName))
//     File.Delete(CurrentName);
// if (File.Exists(_currentTempName))
//     File.Move(_currentTempName, CurrentName);
/// <summary>
/// Summary description for UnitTest1
/// </summary>
/// <summary>
///Gets or sets the test context which provides
///information about and functionality for the current test run.
///</summary>
//
// You can use the following additional attributes as you write your tests:
//
// Use ClassInitialize to run code before running the first test in the class
// [ClassInitialize()]
// public static void MyClassInitialize(TestContext testContext) { }
//
// Use ClassCleanup to run code after all tests in a class have run
// [ClassCleanup()]
// public static void MyClassCleanup() { }
//
// Use TestInitialize to run code before running each test
// [TestInitialize()]
// public void MyTestInitialize() { }
//
// Use TestCleanup to run code after each test has run
// [TestCleanup()]
// public void MyTestCleanup() { }
//
// Use TestInitialize to run code before running each test
// Use TestCleanup to run code after each test has run
/// <summary>
/// Converts a string to a MemoryStream.
/// </summary>
/// <summary>
/// Converts a MemoryStream to a string. Makes some assumptions about the content of the stream.
/// </summary>
/// <param name="s"></param>
/// <returns></returns>
// Microsoft.VisualStudio.TestTools.UnitTesting
// must read at least one of the stderr or stdout asynchronously,
// to avoid deadlock
//output = CleanWzzipOut(output); // just in case
// force small buffers
//CheckForError(decompressingStream, rc, "inflateInit");
/* force small buffers */
//CheckForError(decompressingStream, rc, "inflate");
//CheckForError(decompressingStream, rc, "inflateEnd");
//long dictId;
// force an error in first compressed block // dinoch - ??
// At this point, workBuffer is all zeroes, so it should compress very well.
// switch to no compression, keep same workBuffer (all zeroes):
// Insert data into workBuffer, and switch back to compressing mode.
// we'll use lengths of the same random byte:
// insert totally random data into the workBuffer
// upon inflating, we overwrite the decompressedBytes buffer repeatedly
// first, compress:
// at this point, msSinkCompressed contains the compressed bytes
// now, decompress:
// workitem 8557
// first, compress:
// At this point, msSinkCompressed contains the compressed bytes.
// Now, decompress:
// select the name of the zip file
// four trials, all combos of FileName and Comment null or not null.
// FileName is optional metadata in the GZip bytestream
// Comment is optional metadata in the GZip bytestream
// decompress twice:
// once with System.IO.Compression.GZipStream and once with Ionic.Zlib.GZipStream
// select the name of the zip file
// four trials, all combos of FileName and Comment null or not null.
// FileName is optional metadata in the GZip bytestream
// Comment is optional metadata in the GZip bytestream
// decompress twice:
// once with System.IO.Compression.GZipStream and once with Ionic.Zlib.GZipStream
// sets the final CRC
// once politely, and the 2nd time through, try to read after EOF
// we know there is no more data.  Want to insure it does
// not throw.
// compress with various Ionic levels, and System.IO.Compression (default level)
// de-compress with both Ionic and System.IO.Compression
// want to force EOF
// implicitly closes compressor
// implicitly closes compressor, again
// explicitly closes compressor
// verify that multiple calls to Close() do not throw
// implicitly closes compressor
// implicitly closes compressor, again
// explicitly closes compressor
// implicitly closes compressor
// implicitly closes compressor, again
// explicitly closes compressor
// implicitly closes compressor
// implicitly closes compressor, again
// explicitly closes compressor
// both binary and text files
// try both GZipStream and DeflateStream
// compress with Ionic and System.IO.Compression
// why 4 trials??   (only for GZIP and Ionic)
// k == 0, i == 0
// k == 1, i == 0
// k == 0, i == 1
// k == 1, i == 1
//TestContext.WriteLine("Compress with: {0} ..", compressor.GetType().FullName);
// now, decompress with Ionic and System.IO.Compression
// for (int j = 0; j < 2; j++)
// k == 0, j == 0
// k == 1, j == 0
// k == 0, j == 1
// k == 1, j == 1
//TestContext.WriteLine("Decompress: {0} ...", decompressor.GetType().FullName);
/*default buffer size*/ * rnd.Next(14, 28);
// fill with binary data
// fill the file with text data
// pick a word at random
// create a buffer full of 0xff's
// ctor
// force stream to read just one byte at a time
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
// CRC32.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2011 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// Last Saved: <2011-August-02 18:25:54>
//
// ------------------------------------------------------------------
//
// This module defines the CRC32 class, which can do the CRC32 algorithm, using
// arbitrary starting polynomials, and bit reversal. The bit reversal is what
// distinguishes this CRC-32 used in BZip2 from the CRC-32 that is used in PKZIP
// files, or GZIP files. This class does both.
//
// ------------------------------------------------------------------
/// <summary>
///   Computes a CRC-32. The CRC-32 algorithm is parameterized - you
///   can set the polynomial and enable or disable bit
///   reversal. This can be used for GZIP, BZip2, or ZIP.
/// </summary>
/// <remarks>
///   This type is used internally by DotNetZip; it is generally not used
///   directly by applications wishing to create, read, or manipulate zip
///   archive files.
/// </remarks>
/// <summary>
///   Indicates the total number of bytes applied to the CRC.
/// </summary>
/// <summary>
/// Indicates the current CRC for all blocks slurped in.
/// </summary>
/// <summary>
/// Returns the CRC32 for the specified stream.
/// </summary>
/// <param name="input">The stream over which to calculate the CRC32</param>
/// <returns>the CRC32 calculation</returns>
/// <summary>
/// Returns the CRC32 for the specified stream, and writes the input into the
/// output stream.
/// </summary>
/// <param name="input">The stream over which to calculate the CRC32</param>
/// <param name="output">The stream into which to deflate the input</param>
/// <returns>the CRC32 calculation</returns>
/// <summary>
///   Get the CRC32 for the given (word,byte) combo.  This is a
///   computation defined by PKzip for PKZIP 2.0 (weak) encryption.
/// </summary>
/// <param name="W">The word to start with.</param>
/// <param name="B">The byte to combine it with.</param>
/// <returns>The CRC-ized result.</returns>
/// <summary>
/// Update the value for the running CRC32 using the given block of bytes.
/// This is useful when using the CRC32() class in a Stream.
/// </summary>
/// <param name="block">block of bytes to slurp</param>
/// <param name="offset">starting point in the block</param>
/// <param name="count">how many bytes within the block to slurp</param>
// bzip algorithm
/// <summary>
///   Process one byte in the CRC.
/// </summary>
/// <param name = "b">the byte to include into the CRC .  </param>
/// <summary>
///   Process a run of N identical bytes into the CRC.
/// </summary>
/// <remarks>
///   <para>
///     This method serves as an optimization for updating the CRC when a
///     run of identical bytes is found. Rather than passing in a buffer of
///     length n, containing all identical bytes b, this method accepts the
///     byte value and the length of the (virtual) buffer - the length of
///     the run.
///   </para>
/// </remarks>
/// <param name = "b">the byte to include into the CRC.  </param>
/// <param name = "n">the number of times that byte should be repeated. </param>
/// <summary>
///   Combines the given CRC32 value with the current running total.
/// </summary>
/// <remarks>
///   This is useful when using a divide-and-conquer approach to
///   calculating a CRC.  Multiple threads can each calculate a
///   CRC32 on a segment of the data, and then combine the
///   individual CRC32 values at the end.
/// </remarks>
/// <param name="crc">the crc value to be combined with this one</param>
/// <param name="length">the length of data the CRC value was calculated on</param>
// even-power-of-two zeros operator
// odd-power-of-two zeros operator
// put operator for one zero bit in odd
// the CRC-32 polynomial
// put operator for two zero bits in even
// put operator for four zero bits in odd
// apply len2 zeros to crc1 (first square will put the operator for one
// zero byte, eight zero bits, in even)
// apply zeros operator for this bit of len2
// another iteration of the loop with odd and even swapped
//return (int) crc1;
/// <summary>
///   Create an instance of the CRC32 class using the default settings: no
///   bit reversal, and a polynomial of 0xEDB88320.
/// </summary>
/// <summary>
///   Create an instance of the CRC32 class, specifying whether to reverse
///   data bits or not.
/// </summary>
/// <param name='reverseBits'>
///   specify true if the instance should reverse data bits.
/// </param>
/// <remarks>
///   <para>
///     In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
///     want a CRC32 with compatibility with BZip2, you should pass true
///     here. In the CRC-32 used by GZIP and PKZIP, the bits are not
///     reversed; Therefore if you want a CRC32 with compatibility with
///     those, you should pass false.
///   </para>
/// </remarks>
/// <summary>
///   Create an instance of the CRC32 class, specifying the polynomial and
///   whether to reverse data bits or not.
/// </summary>
/// <param name='polynomial'>
///   The polynomial to use for the CRC, expressed in the reversed (LSB)
///   format: the highest ordered bit in the polynomial value is the
///   coefficient of the 0th power; the second-highest order bit is the
///   coefficient of the 1 power, and so on. Expressed this way, the
///   polynomial for the CRC-32C used in IEEE 802.3, is 0xEDB88320.
/// </param>
/// <param name='reverseBits'>
///   specify true if the instance should reverse data bits.
/// </param>
///
/// <remarks>
///   <para>
///     In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
///     want a CRC32 with compatibility with BZip2, you should pass true
///     here for the <c>reverseBits</c> parameter. In the CRC-32 used by
///     GZIP and PKZIP, the bits are not reversed; Therefore if you want a
///     CRC32 with compatibility with those, you should pass false for the
///     <c>reverseBits</c> parameter.
///   </para>
/// </remarks>
/// <summary>
///   Reset the CRC-32 class - clear the CRC "remainder register."
/// </summary>
/// <remarks>
///   <para>
///     Use this when employing a single instance of this class to compute
///     multiple, distinct CRCs on multiple, distinct data blocks.
///   </para>
/// </remarks>
// private member vars
/// <summary>
/// A Stream that calculates a CRC32 (a checksum) on all bytes read,
/// or on all bytes written.
/// </summary>
///
/// <remarks>
/// <para>
/// This class can be used to verify the CRC of a ZipEntry when
/// reading from a stream, or to calculate a CRC when writing to a
/// stream.  The stream should be used to either read, or write, but
/// not both.  If you intermix reads and writes, the results are not
/// defined.
/// </para>
///
/// <para>
/// This class is intended primarily for use internally by the
/// DotNetZip library.
/// </para>
/// </remarks>
/// <summary>
/// The default constructor.
/// </summary>
/// <remarks>
///   <para>
///     Instances returned from this constructor will leave the underlying
///     stream open upon Close().  The stream uses the default CRC32
///     algorithm, which implies a polynomial of 0xEDB88320.
///   </para>
/// </remarks>
/// <param name="stream">The underlying stream</param>
/// <summary>
///   The constructor allows the caller to specify how to handle the
///   underlying stream at close.
/// </summary>
/// <remarks>
///   <para>
///     The stream uses the default CRC32 algorithm, which implies a
///     polynomial of 0xEDB88320.
///   </para>
/// </remarks>
/// <param name="stream">The underlying stream</param>
/// <param name="leaveOpen">true to leave the underlying stream
/// open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
/// <summary>
///   A constructor allowing the specification of the length of the stream
///   to read.
/// </summary>
/// <remarks>
///   <para>
///     The stream uses the default CRC32 algorithm, which implies a
///     polynomial of 0xEDB88320.
///   </para>
///   <para>
///     Instances returned from this constructor will leave the underlying
///     stream open upon Close().
///   </para>
/// </remarks>
/// <param name="stream">The underlying stream</param>
/// <param name="length">The length of the stream to slurp</param>
/// <summary>
///   A constructor allowing the specification of the length of the stream
///   to read, as well as whether to keep the underlying stream open upon
///   Close().
/// </summary>
/// <remarks>
///   <para>
///     The stream uses the default CRC32 algorithm, which implies a
///     polynomial of 0xEDB88320.
///   </para>
/// </remarks>
/// <param name="stream">The underlying stream</param>
/// <param name="length">The length of the stream to slurp</param>
/// <param name="leaveOpen">true to leave the underlying stream
/// open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
/// <summary>
///   A constructor allowing the specification of the length of the stream
///   to read, as well as whether to keep the underlying stream open upon
///   Close(), and the CRC32 instance to use.
/// </summary>
/// <remarks>
///   <para>
///     The stream uses the specified CRC32 instance, which allows the
///     application to specify how the CRC gets calculated.
///   </para>
/// </remarks>
/// <param name="stream">The underlying stream</param>
/// <param name="length">The length of the stream to slurp</param>
/// <param name="leaveOpen">true to leave the underlying stream
/// open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
/// <param name="crc32">the CRC32 instance to use to calculate the CRC32</param>
// This ctor is private - no validation except null is done here.
// This is to allow the use
// of a (specific) negative value for the _lengthLimit, to indicate that there
// is no length set.  So we validate the length limit in those ctors that use an
// explicit param, otherwise we don't validate, because it could be our special
// value.
/// <summary>
///   Gets the total number of bytes run through the CRC32 calculator.
/// </summary>
///
/// <remarks>
///   This is either the total number of bytes read, or the total number of
///   bytes written, depending on the direction of this stream.
/// </remarks>
/// <summary>
///   Provides the current CRC for all blocks slurped in.
/// </summary>
/// <remarks>
///   <para>
///     The running total of the CRC is kept as data is written or read
///     through the stream.  read this property after all reads or writes to
///     get an accurate CRC for the entire stream.
///   </para>
/// </remarks>
/// <summary>
///   Indicates whether the underlying stream will be left open when the
///   <c>CrcCalculatorStream</c> is Closed.
/// </summary>
/// <remarks>
///   <para>
///     Set this at any point before calling <see cref="Close()"/>.
///   </para>
/// </remarks>
/// <summary>
/// Read from the stream
/// </summary>
/// <param name="buffer">the buffer to read</param>
/// <param name="offset">the offset at which to start</param>
/// <param name="count">the number of bytes to read</param>
/// <returns>the number of bytes actually read</returns>
// Need to limit the # of bytes returned, if the stream is intended to have
// a definite length.  This is especially useful when returning a stream for
// the uncompressed data directly to the application.  The app won't
// necessarily read only the UncompressedSize number of bytes.  For example
// wrapping the stream returned from OpenReader() into a StreadReader() and
// calling ReadToEnd() on it, We can "over-read" the zip data and get a
// corrupt string.  The length limits that, prevents that problem.
// EOF
/// <summary>
/// Write to the stream.
/// </summary>
/// <param name="buffer">the buffer from which to write</param>
/// <param name="offset">the offset at which to start writing</param>
/// <param name="count">the number of bytes to write</param>
/// <summary>
/// Indicates whether the stream supports reading.
/// </summary>
/// <summary>
///   Indicates whether the stream supports seeking.
/// </summary>
/// <remarks>
///   <para>
///     Always returns false.
///   </para>
/// </remarks>
/// <summary>
/// Indicates whether the stream supports writing.
/// </summary>
/// <summary>
/// Flush the stream.
/// </summary>
/// <summary>
///   Returns the length of the underlying stream.
/// </summary>
/// <summary>
///   The getter for this property returns the total bytes read.
///   If you use the setter, it will throw
/// <see cref="NotSupportedException"/>.
/// </summary>
/// <summary>
/// Seeking is not supported on this stream. This method always throws
/// <see cref="NotSupportedException"/>
/// </summary>
/// <param name="offset">N/A</param>
/// <param name="origin">N/A</param>
/// <returns>N/A</returns>
/// <summary>
/// This method always throws
/// <see cref="NotSupportedException"/>
/// </summary>
/// <param name="value">N/A</param>
/// <summary>
/// Closes the stream.
/// </summary>
// Deflate.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009 Dino Chiesa and Microsoft Corporation.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-August-03 19:52:15>
//
// ------------------------------------------------------------------
//
// This module defines logic for handling the Deflate or compression.
//
// This code is based on multiple sources:
// - the original zlib v1.2.3 source, which is Copyright (C) 1995-2005 Jean-loup Gailly.
// - the original jzlib, which is Copyright (c) 2000-2003 ymnk, JCraft,Inc.
//
// However, this code is significantly different from both.
// The object model is not the same, and many of the behaviors are different.
//
// In keeping with the license for these other works, the copyrights for
// jzlib and zlib are here.
//
// -----------------------------------------------------------------------
// Copyright (c) 2000,2001,2002,2003 ymnk, JCraft,Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in
// the documentation and/or other materials provided with the distribution.
//
// 3. The names of the authors may not be used to endorse or promote products
// derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
// FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
// INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// -----------------------------------------------------------------------
//
// This program is based on zlib-1.1.3; credit to authors
// Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
// and contributors of zlib.
//
// -----------------------------------------------------------------------
// block not completed, need more input or more output
// block flush performed
// finish started, need only more output at next deflate
// finish done, accept no more input or output
// Use a faster search when the previous match is longer than this
// reduce lazy search above this match length
// Attempt to find a better match only when the current match is
// strictly smaller than this value. This mechanism is used only for
// compression levels >= 4.  For levels 1,2,3: MaxLazy is actually
// MaxInsertLength. (See DeflateFast)
// do not perform lazy search above this match length
// quit search above this match length
// To speed up deflation, hash chains are never searched beyond this
// length.  A higher limit improves compression ratio but degrades the speed.
// preset dictionary flag in zlib header
// The deflate compression method
// The three kinds of block type
// the zlib encoder/decoder
// as the name implies
// output still pending - waiting to be compressed
// index of next pending byte to output to the stream
// number of bytes in the pending buffer
// UNKNOWN, BINARY or ASCII
// value of flush param for previous deflate call
// LZ77 window size (32K by default)
// log2(w_size)  (8..16)
// w_size - 1
//internal byte[] dictionary;
// Sliding window. Input bytes are read into the second half of the window,
// and move to the first half later to keep a dictionary of at least wSize
// bytes. With this organization, matches are limited to a distance of
// wSize-MAX_MATCH bytes, but this ensures that IO is always
// performed with a length multiple of the block size.
//
// To do: use the user input buffer as sliding window.
// Actual size of window: 2*wSize, except when the user input buffer
// is directly used as sliding window.
// Link to older string with same hash index. To limit the size of this
// array to 64K, this link is maintained only for the last 32K strings.
// An index in this array is thus a window index modulo 32K.
// Heads of the hash chains or NIL.
// hash index of string to be inserted
// number of elements in hash table
// log2(hash_size)
// hash_size-1
// Number of bits by which ins_h must be shifted at each input
// step. It must be such that after MIN_MATCH steps, the oldest
// byte no longer takes part in the hash key, that is:
// hash_shift * MIN_MATCH >= hash_bits
// Window position at the beginning of the current output block. Gets
// negative when the window is moved backwards.
// length of best match
// previous match
// set if previous match exists
// start of string to insert into.....????
// start of matching string
// number of valid bytes ahead in window
// Length of the best match at previous step. Matches not greater than this
// are discarded. This is used in the lazy match evaluation.
// Insert new strings in the hash table only if the match length is not
// greater than this length. This saves time but degrades compression.
// max_insert_length is used only for compression levels <= 3.
// compression level (1..9)
// favor or force Huffman coding
// literal and length tree
// distance tree
// Huffman tree for bit lengths
// desc for literal tree
// desc for distance tree
// desc for bit length tree
// number of codes at each bit length for an optimal tree
// heap used to build the Huffman trees
// number of elements in the heap
// element of largest frequency
// The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
// The same heap array is used to build all trees.
// Depth of each subtree used as tie breaker for trees of equal frequency
// index for literals or lengths
// Size of match buffer for literals/lengths.  There are 4 reasons for
// limiting lit_bufsize to 64K:
//   - frequencies can be kept in 16 bit counters
//   - if compression is not successful for the first block, all input
//     data is still in the window so we can still emit a stored block even
//     when input comes from standard input.  (This can also be done for
//     all blocks if lit_bufsize is not greater than 32K.)
//   - if compression is not successful for a file smaller than 64K, we can
//     even emit a stored file instead of a stored block (saving 5 bytes).
//     This is applicable only for zip (not gzip or zlib).
//   - creating new Huffman trees less frequently may not provide fast
//     adaptation to changes in the input data statistics. (Take for
//     example a binary file with poorly compressible code followed by
//     a highly compressible string table.) Smaller buffer sizes give
//     fast adaptation but have of course the overhead of transmitting
//     trees more frequently.
// running index in l_buf
// Buffer for distances. To simplify the code, d_buf and l_buf have
// the same number of elements. To use different lengths, an extra flag
// array would be necessary.
// index into pending; points to distance data??
// bit length of current block with optimal trees
// bit length of current block with static trees
// number of string matches in current block
// bit length of EOB code for last block
// Output buffer. bits are inserted starting at the bottom (least
// significant bits).
// Number of valid bits in bi_buf.  All bits above the last valid bit
// are always zero.
// distance tree
// Huffman tree for bit lengths
// lm_init
// clear the hash - workitem 9063
//for (int i = 0; i < hash_size; i++) head[i] = 0;
// Initialize the tree data structures for a new zlib stream.
// enough lookahead for inflate
// Initialize the first block of the first file:
// Initialize the trees.
// Restore the heap property by moving down the tree starting at node k,
// exchanging a node with the smallest of its two sons if necessary, stopping
// when the heap property is re-established (each father smaller than its
// two sons).
// left son of k
// Set j to the smallest of the two sons:
// Exit if v is smaller than both sons
// Exchange v with the smallest son
// And continue down the tree, setting j to the left son of k
// Scan a literal or distance tree to determine the frequencies of the codes
// in the bit length tree.
// iterates over all tree elements
// last emitted length
// length of current code
// length of next code
// repeat count of the current code
// max repeat count
// min repeat count
// guard //??
// Construct the Huffman tree for the bit lengths and return the index in
// bl_order of the last bit length code to send.
// index of last bit length code of non zero freq
// Determine the bit length frequencies for literal and distance trees
// Build the bit length tree:
// opt_len now includes the length of the tree representations, except
// the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
// Determine the number of bit length codes to send. The pkzip format
// requires that at least 4 bit length codes be sent. (appnote.txt says
// 3 but the actual value used is 4.)
// Update opt_len to include the bit length tree and counts
// Send the header for a block using dynamic Huffman trees: the counts, the
// lengths of the bit length codes, the literal tree and the distance tree.
// IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
// index in bl_order
// not +255 as stated in appnote.txt
// not -3 as stated in appnote.txt
// literal tree
// distance tree
// Send a literal or distance tree in compressed form, using the codes in
// bl_tree.
// iterates over all tree elements
// last emitted length
// length of current code
// length of next code
// repeat count of the current code
// max repeat count
// min repeat count
// Output a block of bytes on the stream.
// IN assertion: there is enough room in pending_buf.
//int val = value;
//      bi_buf |= (val << bi_valid);
//put_short(bi_buf);
//      bi_buf |= (value) << bi_valid;
// Send one empty static block to give enough lookahead for inflate.
// This takes 10 bits, of which 7 may remain in the bit buffer.
// The current inflate code requires 9 bits of lookahead. If the
// last two codes for the previous block (real code plus EOB) were coded
// on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
// the last real code. In this case we send two empty static blocks instead
// of one. (There are no problems if the previous block is stored or fixed.)
// To simplify the code, we assume the worst case of last real code encoded
// on one bit only.
// Of the 10 bits for the empty block, we have already sent
// (10 - bi_valid) bits. The lookahead for the last real code (before
// the EOB of the previous block) was thus at least one plus the length
// of the EOB plus what we have just sent of the empty static block.
// Save the match info and tally the frequency counts. Return true if
// the current block must be flushed.
// lc is the unmatched char
// Here, lc is the match length - MIN_MATCH
// dist = match distance - 1
// Compute an upper bound for the compressed length
// dinoch - wraparound?
// We avoid equality with lit_bufsize because of wraparound at 64K
// on 16 bit machines and because stored blocks are restricted to
// 64K-1 bytes.
// Send the block data compressed using the given Huffman trees
// distance of matched string
// match length or unmatched char (if dist == 0)
// running index in l_buf
// the code to send
// number of extra bits to send
// send a literal byte
// literal or match pair
// Here, lc is the match length - MIN_MATCH
// send the length code
// send the extra length bits
// dist is now the match distance - 1
// send the distance code
// send the extra distance bits
// Check that the overlay between pending and d_buf+l_buf is ok:
// Set the data type to ASCII or BINARY, using a crude approximation:
// binary if more than 20% of the bytes are <= 6 or >= 128, ascii otherwise.
// IN assertion: the fields freq of dyn_ltree are set and the total of all
// frequencies does not exceed 64K (to fit in an int on 16 bit machines).
// Flush the bit buffer, keeping at most 7 bits in it.
//put_byte((byte)bi_buf);
// Flush the bit buffer and align the output on a byte boundary
//put_byte((byte)bi_buf);
// Copy a stored block, storing first the length and its
// one's complement if requested.
// align on byte boundary
// enough lookahead for inflate
//put_short((short)len);
//put_short((short)~len);
// Copy without compression as much as possible from the input stream, return
// the current block state.
// This function does not insert new strings in the dictionary since
// uncompressible data is probably not useful. This function is used
// only for the level=0 compression option.
// NOTE: this function should be optimized to avoid extra copying from
// window to pending_buf.
// Stored blocks are limited to 0xffff bytes, pending is limited
// to pending_buf_size, and each stored block has a 5 byte header:
// Copy as much as possible from input to output:
// Fill the window as much as possible:
// flush the current block
// Emit a stored block if pending will be full:
// strstart == 0 is possible when wraparound on 16-bit machine
// Flush if we may have to slide, otherwise block_start may become
// negative and the data will be gone:
// Send a stored block
// send block type
// with header
// Determine the best encoding for the current block: dynamic trees, static
// trees or store, and output the encoded block to the zip file.
// opt_len and static_len in bytes
// index of last bit length code of non zero freq
// Build the Huffman trees unless a stored block is forced
// Check if the file is ascii or binary
// Construct the literal and distance trees
// At this point, opt_len and static_len are the total bit lengths of
// the compressed block data, excluding the tree representations.
// Build the bit length tree for the above two trees, and get the index
// in bl_order of the last bit length code to send.
// Determine the best encoding. Compute first the block length in bytes
// force a stored block
// 4: two words for the lengths
// The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
// Otherwise we can't have processed more than WSIZE input bytes since
// the last block flush, because compression would have been
// successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
// transform a block into a stored block.
// The above check is made mod 2^32, for files larger than 512 MB
// and uLong implemented on 32 bits.
// Fill the window when the lookahead becomes insufficient.
// Updates strstart and lookahead.
//
// IN assertion: lookahead < MIN_LOOKAHEAD
// OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
//    At least one byte has been read, or avail_in == 0; reads are
//    performed for at least two bytes (required for the zip translate_eol
//    option -- not supported here).
// Amount of free space at the end of the window.
// Deal with !@#$% 64K limit:
// Very unlikely, but possible on 16 bit machine if strstart == 0
// and lookahead == 1 (input done one byte at time)
// If the window is almost full and there is insufficient lookahead,
// move the upper half to the lower one to make room in the upper half.
// we now have strstart >= MAX_DIST
// Slide the hash table (could be avoided with 32 bit values
// at the expense of memory usage). We slide even when level == 0
// to keep the hash table consistent if we switch back to level > 0
// later. (Using level 0 permanently is not an optimal usage of
// zlib, so we don't care about this pathological case.)
// If n is not on any hash chain, prev[n] is garbage but
// its value will never be used.
// If there was no sliding:
//    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
//    more == window_size - lookahead - strstart
// => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
// => more >= window_size - 2*WSIZE + 2
// In the BIG_MEM or MMAP case (not yet supported),
//   window_size == input_size + MIN_LOOKAHEAD  &&
//   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
// Otherwise, window_size == 2*WSIZE so more >= 2.
// If there was sliding, more >= WSIZE. So in all cases, more >= 2.
// Initialize the hash value now that we have some input:
// If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
// but this is not important since only literal bytes will be emitted.
// Compress as much as possible from the input stream, return the current
// block state.
// This function does not perform lazy evaluation of matches and inserts
// new strings in the dictionary only for unmatched strings or for short
// matches. It is used only for the fast compression options.
//    short hash_head = 0; // head of the hash chain
// head of the hash chain
// set if current block must be flushed
// Make sure that we always have enough lookahead, except
// at the end of the input file. We need MAX_MATCH bytes
// for the next match, plus MIN_MATCH bytes to insert the
// string following the next match.
// flush the current block
// Insert the string window[strstart .. strstart+2] in the
// dictionary, and set hash_head to the head of the hash chain:
//  prev[strstart&w_mask]=hash_head=head[ins_h];
// Find the longest match, discarding those <= prev_length.
// At this point we have always match_length < MIN_MATCH
// To simplify the code, we prevent matches with the string
// of window index 0 (in particular we have to avoid a match
// of the string with itself at the start of the input file).
// longest_match() sets match_start
//        check_match(strstart, match_start, match_length);
// Insert new strings in the hash table only if the match length
// is not too large. This saves time but degrades compression.
// string at strstart already in hash table
//      prev[strstart&w_mask]=hash_head=head[ins_h];
// strstart never exceeds WSIZE-MAX_MATCH, so there are
// always MIN_MATCH bytes ahead.
// If lookahead < MIN_MATCH, ins_h is garbage, but it does not
// matter since it will be recomputed at next deflate call.
// No match, output a literal byte
// Same as above, but achieves better compression. We use a lazy
// evaluation for matches: a match is finally adopted only if there is
// no better match at the next window position.
//    short hash_head = 0;    // head of hash chain
// head of hash chain
// set if current block must be flushed
// Process the input block.
// Make sure that we always have enough lookahead, except
// at the end of the input file. We need MAX_MATCH bytes
// for the next match, plus MIN_MATCH bytes to insert the
// string following the next match.
// flush the current block
// Insert the string window[strstart .. strstart+2] in the
// dictionary, and set hash_head to the head of the hash chain:
//  prev[strstart&w_mask]=hash_head=head[ins_h];
// Find the longest match, discarding those <= prev_length.
// To simplify the code, we prevent matches with the string
// of window index 0 (in particular we have to avoid a match
// of the string with itself at the start of the input file).
// longest_match() sets match_start
// If prev_match is also MIN_MATCH, match_start is garbage
// but we will ignore the current match anyway.
// If there was a match at the previous step and the current
// match is not better, output the previous match:
// Do not insert strings in hash table beyond this.
//          check_match(strstart-1, prev_match, prev_length);
// Insert in hash table all strings up to the end of the match.
// strstart-1 and strstart are already inserted. If there is not
// enough lookahead, the last two strings are not inserted in
// the hash table.
//prev[strstart&w_mask]=hash_head=head[ins_h];
// If there was no match at the previous position, output a
// single literal. If there was a match but the current match
// is longer, truncate the previous match to a single literal.
// There is no previous match to compare with, wait for
// the next step to decide.
// max hash chain length
// current string
// matched string
// length of current match
// best match length so far
// Stop when cur_match becomes <= limit. To simplify the code,
// we prevent matches with the string of window index 0.
// The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
// It is easy to get rid of this optimization if necessary.
// Do not waste too much time if we already have a good match:
// Do not look for matches beyond the end of the input. This is necessary
// to make deflate deterministic.
// Skip to next match if the match length cannot increase
// or if the match length is less than 2:
// The check at best_len-1 can be removed because it will be made
// again later. (This heuristic is not always a win.)
// It is not necessary to compare scan[2] and match[2] since they
// are always equal when the other bytes match, given that
// the hash keys are equal and that HASH_BITS >= 8.
// We check for insufficient lookahead only every 8th comparison;
// the 256th check will be made at strstart+258.
// validation
// for memLevel==8, this will be 16384, 16k
// Use a single array as the buffer for data pending compression,
// the output distance codes, and the output length codes (aka tree).
// orig comment: This works just fine since the average
// output size for (length,distance) codes is <= 24 bits.
// So, for memLevel 8, the length of the pending buffer is 65536. 64k.
// The first 16k are pending bytes.
// The middle slice, of 32k, is used for distance codes.
// The final 16k are length codes.
//strm.data_type = Z_UNKNOWN;
// Deallocate in reverse order of allocations:
// free
// dstate=null;
// change in the deflate flavor (Fast vs slow vs none)?
// Flush the last buffer:
// no need to flush with change in strategy?  Really?
// use the tail of the dictionary
// Insert all strings in the hash table (except for the last two bytes).
// s->lookahead stays null, so s->ins_h will be recomputed at the next
// call of fill_window.
// Write the zlib (rfc1950) header bytes
//putShortMSB(header);
// Save the adler32 of the preset dictionary:
// Flush as much pending output as possible
//System.out.println("  avail_out==0");
// Since avail_out is 0, deflate will be called again with
// more output space, but possibly with both pending and
// avail_in equal to zero. There won't be anything to do,
// but this is not an error situation so make sure we
// return OK instead of BUF_ERROR at next call of deflate:
// Make sure there is something to do and avoid duplicate consecutive
// flushes. For repeated and useless calls with Z_FINISH, we keep
// returning Z_STREAM_END instead of Z_BUFF_ERROR.
// workitem 8557
//
// Not sure why this needs to be an error.  pendingCount == 0, which
// means there's nothing to deflate.  And the caller has not asked
// for a FlushType.Finish, but...  that seems very non-fatal.  We
// can just say "OK" and do nothing.
// _codec.Message = z_errmsg[ZlibConstants.Z_NEED_DICT - (ZlibConstants.Z_BUF_ERROR)];
// throw new ZlibException("AvailableBytesIn == 0 && flush<=old_flush && flush != FlushType.Finish");
// User must not provide more input after the first FINISH:
// Start a new block or continue the current one.
// avoid BUF_ERROR next call, see above
// If flush != Z_NO_FLUSH && avail_out == 0, the next call
// of deflate should use the same flush parameter to make sure
// that the flush is complete. So we don't have to output an
// empty block here, this will be done at next call. This also
// ensures that for a very small output buffer, we emit at most
// one empty block.
// FlushType.Full or FlushType.Sync
// For a full flush, this empty block will be recognized
// as a special marker by inflate_sync().
// clear hash (forget the history)
// avoid BUF_ERROR at next call, see above
// Write the zlib trailer (adler32)
//putShortMSB((int)(SharedUtils.URShift(_codec._Adler32, 16)));
//putShortMSB((int)(_codec._Adler32 & 0xffff));
// If avail_out is zero, the application will call deflate again
// to flush the rest.
// write the trailer only once!
// DeflateStream.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2010 Dino Chiesa.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-July-31 14:48:11>
//
// ------------------------------------------------------------------
//
// This module defines the DeflateStream class, which can be used as a replacement for
// the System.IO.Compression.DeflateStream class in the .NET BCL.
//
// ------------------------------------------------------------------
/// <summary>
/// A class for compressing and decompressing streams using the Deflate algorithm.
/// </summary>
///
/// <remarks>
///
/// <para>
///   The DeflateStream is a <see
///   href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a <see
///   cref="System.IO.Stream"/>.  It adds DEFLATE compression or decompression to any
///   stream.
/// </para>
///
/// <para>
///   Using this stream, applications can compress or decompress data via stream
///   <c>Read</c> and <c>Write</c> operations.  Either compresssion or decompression
///   can occur through either reading or writing. The compression format used is
///   DEFLATE, which is documented in <see
///   href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC 1951</see>, "DEFLATE
///   Compressed Data Format Specification version 1.3.".
/// </para>
///
/// <para>
///   This class is similar to <see cref="ZlibStream"/>, except that
///   <c>ZlibStream</c> adds the <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
///   1950 - ZLIB</see> framing bytes to a compressed stream when compressing, or
///   expects the RFC1950 framing bytes when decompressing. The <c>DeflateStream</c>
///   does not.
/// </para>
///
/// </remarks>
///
/// <seealso cref="ZlibStream" />
/// <seealso cref="GZipStream" />
/// <summary>
///   Create a DeflateStream using the specified CompressionMode.
/// </summary>
///
/// <remarks>
///   When mode is <c>CompressionMode.Compress</c>, the DeflateStream will use
///   the default compression level. The "captive" stream will be closed when
///   the DeflateStream is closed.
/// </remarks>
///
/// <example>
/// This example uses a DeflateStream to compress data from a file, and writes
/// the compressed data to another file.
/// <code>
/// using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
/// {
///     using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
///     {
///         using (Stream compressor = new DeflateStream(raw, CompressionMode.Compress))
///         {
///             byte[] buffer = new byte[WORKING_BUFFER_SIZE];
///             int n;
///             while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
///             {
///                 compressor.Write(buffer, 0, n);
///             }
///         }
///     }
/// }
/// </code>
///
/// <code lang="VB">
/// Using input As Stream = File.OpenRead(fileToCompress)
///     Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
///         Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress)
///             Dim buffer As Byte() = New Byte(4096) {}
///             Dim n As Integer = -1
///             Do While (n &lt;&gt; 0)
///                 If (n &gt; 0) Then
///                     compressor.Write(buffer, 0, n)
///                 End If
///                 n = input.Read(buffer, 0, buffer.Length)
///             Loop
///         End Using
///     End Using
/// End Using
/// </code>
/// </example>
/// <param name="stream">The stream which will be read or written.</param>
/// <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
/// <summary>
/// Create a DeflateStream using the specified CompressionMode and the specified CompressionLevel.
/// </summary>
///
/// <remarks>
///
/// <para>
///   When mode is <c>CompressionMode.Decompress</c>, the level parameter is
///   ignored.  The "captive" stream will be closed when the DeflateStream is
///   closed.
/// </para>
///
/// </remarks>
///
/// <example>
///
///   This example uses a DeflateStream to compress data from a file, and writes
///   the compressed data to another file.
///
/// <code>
/// using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
/// {
///     using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
///     {
///         using (Stream compressor = new DeflateStream(raw,
///                                                      CompressionMode.Compress,
///                                                      CompressionLevel.BestCompression))
///         {
///             byte[] buffer = new byte[WORKING_BUFFER_SIZE];
///             int n= -1;
///             while (n != 0)
///             {
///                 if (n &gt; 0)
///                     compressor.Write(buffer, 0, n);
///                 n= input.Read(buffer, 0, buffer.Length);
///             }
///         }
///     }
/// }
/// </code>
///
/// <code lang="VB">
/// Using input As Stream = File.OpenRead(fileToCompress)
///     Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
///         Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
///             Dim buffer As Byte() = New Byte(4096) {}
///             Dim n As Integer = -1
///             Do While (n &lt;&gt; 0)
///                 If (n &gt; 0) Then
///                     compressor.Write(buffer, 0, n)
///                 End If
///                 n = input.Read(buffer, 0, buffer.Length)
///             Loop
///         End Using
///     End Using
/// End Using
/// </code>
/// </example>
/// <param name="stream">The stream to be read or written while deflating or inflating.</param>
/// <param name="mode">Indicates whether the <c>DeflateStream</c> will compress or decompress.</param>
/// <param name="level">A tuning knob to trade speed for effectiveness.</param>
/// <summary>
///   Create a <c>DeflateStream</c> using the specified
///   <c>CompressionMode</c>, and explicitly specify whether the
///   stream should be left open after Deflation or Inflation.
/// </summary>
///
/// <remarks>
///
/// <para>
///   This constructor allows the application to request that the captive stream
///   remain open after the deflation or inflation occurs.  By default, after
///   <c>Close()</c> is called on the stream, the captive stream is also
///   closed. In some cases this is not desired, for example if the stream is a
///   memory stream that will be re-read after compression.  Specify true for
///   the <paramref name="leaveOpen"/> parameter to leave the stream open.
/// </para>
///
/// <para>
///   The <c>DeflateStream</c> will use the default compression level.
/// </para>
///
/// <para>
///   See the other overloads of this constructor for example code.
/// </para>
/// </remarks>
///
/// <param name="stream">
///   The stream which will be read or written. This is called the
///   "captive" stream in other places in this documentation.
/// </param>
///
/// <param name="mode">
///   Indicates whether the <c>DeflateStream</c> will compress or decompress.
/// </param>
///
/// <param name="leaveOpen">true if the application would like the stream to
/// remain open after inflation/deflation.</param>
/// <summary>
///   Create a <c>DeflateStream</c> using the specified <c>CompressionMode</c>
///   and the specified <c>CompressionLevel</c>, and explicitly specify whether
///   the stream should be left open after Deflation or Inflation.
/// </summary>
///
/// <remarks>
///
/// <para>
///   When mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored.
/// </para>
///
/// <para>
///   This constructor allows the application to request that the captive stream
///   remain open after the deflation or inflation occurs.  By default, after
///   <c>Close()</c> is called on the stream, the captive stream is also
///   closed. In some cases this is not desired, for example if the stream is a
///   <see cref="System.IO.MemoryStream"/> that will be re-read after
///   compression.  Specify true for the <paramref name="leaveOpen"/> parameter
///   to leave the stream open.
/// </para>
///
/// </remarks>
///
/// <example>
///
///   This example shows how to use a <c>DeflateStream</c> to compress data from
///   a file, and store the compressed data into another file.
///
/// <code>
/// using (var output = System.IO.File.Create(fileToCompress + ".deflated"))
/// {
///     using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
///     {
///         using (Stream compressor = new DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, true))
///         {
///             byte[] buffer = new byte[WORKING_BUFFER_SIZE];
///             int n= -1;
///             while (n != 0)
///             {
///                 if (n &gt; 0)
///                     compressor.Write(buffer, 0, n);
///                 n= input.Read(buffer, 0, buffer.Length);
///             }
///         }
///     }
///     // can write additional data to the output stream here
/// }
/// </code>
///
/// <code lang="VB">
/// Using output As FileStream = File.Create(fileToCompress &amp; ".deflated")
///     Using input As Stream = File.OpenRead(fileToCompress)
///         Using compressor As Stream = New DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, True)
///             Dim buffer As Byte() = New Byte(4096) {}
///             Dim n As Integer = -1
///             Do While (n &lt;&gt; 0)
///                 If (n &gt; 0) Then
///                     compressor.Write(buffer, 0, n)
///                 End If
///                 n = input.Read(buffer, 0, buffer.Length)
///             Loop
///         End Using
///     End Using
///     ' can write additional data to the output stream here.
/// End Using
/// </code>
/// </example>
/// <param name="stream">The stream which will be read or written.</param>
/// <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
/// <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
/// <param name="level">A tuning knob to trade speed for effectiveness.</param>
/// <summary>
/// This property sets the flush behavior on the stream.
/// </summary>
/// <remarks> See the ZLIB documentation for the meaning of the flush behavior.
/// </remarks>
/// <summary>
///   The size of the working buffer for the compression codec.
/// </summary>
///
/// <remarks>
/// <para>
///   The working buffer is used for all stream operations.  The default size is
///   1024 bytes.  The minimum size is 128 bytes. You may get better performance
///   with a larger buffer.  Then again, you might not.  You would have to test
///   it.
/// </para>
///
/// <para>
///   Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
///   stream. If you try to set it afterwards, it will throw.
/// </para>
/// </remarks>
/// <summary>
///   The ZLIB strategy to be used during compression.
/// </summary>
///
/// <remarks>
///   By tweaking this parameter, you may be able to optimize the compression for
///   data with particular characteristics.
/// </remarks>
/// <summary> Returns the total number of bytes input so far.</summary>
/// <summary> Returns the total number of bytes output so far.</summary>
/// <summary>
///   Dispose the stream.
/// </summary>
/// <remarks>
///   <para>
///     This may or may not result in a <c>Close()</c> call on the captive
///     stream.  See the constructors that have a <c>leaveOpen</c> parameter
///     for more information.
///   </para>
///   <para>
///     Application code won't call this code directly.  This method may be
///     invoked in two distinct scenarios.  If disposing == true, the method
///     has been called directly or indirectly by a user's code, for example
///     via the public Dispose() method. In this case, both managed and
///     unmanaged resources can be referenced and disposed.  If disposing ==
///     false, the method has been called by the runtime from inside the
///     object finalizer and this method should not reference other objects;
///     in that case only unmanaged resources must be referenced or
///     disposed.
///   </para>
/// </remarks>
/// <param name="disposing">
///   true if the Dispose method was invoked by user code.
/// </param>
/// <summary>
/// Indicates whether the stream can be read.
/// </summary>
/// <remarks>
/// The return value depends on whether the captive stream supports reading.
/// </remarks>
/// <summary>
/// Indicates whether the stream supports Seek operations.
/// </summary>
/// <remarks>
/// Always returns false.
/// </remarks>
/// <summary>
/// Indicates whether the stream can be written.
/// </summary>
/// <remarks>
/// The return value depends on whether the captive stream supports writing.
/// </remarks>
/// <summary>
/// Flush the stream.
/// </summary>
/// <summary>
/// Reading this property always throws a <see cref="NotImplementedException"/>.
/// </summary>
/// <summary>
/// The position of the stream pointer.
/// </summary>
///
/// <remarks>
///   Setting this property always throws a <see
///   cref="NotImplementedException"/>. Reading will return the total bytes
///   written out, if used in writing, or the total bytes read in, if used in
///   reading.  The count may refer to compressed bytes or uncompressed bytes,
///   depending on how you've used the stream.
/// </remarks>
/// <summary>
/// Read data from the stream.
/// </summary>
/// <remarks>
///
/// <para>
///   If you wish to use the <c>DeflateStream</c> to compress data while
///   reading, you can create a <c>DeflateStream</c> with
///   <c>CompressionMode.Compress</c>, providing an uncompressed data stream.
///   Then call Read() on that <c>DeflateStream</c>, and the data read will be
///   compressed as you read.  If you wish to use the <c>DeflateStream</c> to
///   decompress data while reading, you can create a <c>DeflateStream</c> with
///   <c>CompressionMode.Decompress</c>, providing a readable compressed data
///   stream.  Then call Read() on that <c>DeflateStream</c>, and the data read
///   will be decompressed as you read.
/// </para>
///
/// <para>
///   A <c>DeflateStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not both.
/// </para>
///
/// </remarks>
/// <param name="buffer">The buffer into which the read data should be placed.</param>
/// <param name="offset">the offset within that data array to put the first byte read.</param>
/// <param name="count">the number of bytes to read.</param>
/// <returns>the number of bytes actually read</returns>
/// <summary>
/// Calling this method always throws a <see cref="NotImplementedException"/>.
/// </summary>
/// <param name="offset">this is irrelevant, since it will always throw!</param>
/// <param name="origin">this is irrelevant, since it will always throw!</param>
/// <returns>irrelevant!</returns>
/// <summary>
/// Calling this method always throws a <see cref="NotImplementedException"/>.
/// </summary>
/// <param name="value">this is irrelevant, since it will always throw!</param>
/// <summary>
///   Write data to the stream.
/// </summary>
/// <remarks>
///
/// <para>
///   If you wish to use the <c>DeflateStream</c> to compress data while
///   writing, you can create a <c>DeflateStream</c> with
///   <c>CompressionMode.Compress</c>, and a writable output stream.  Then call
///   <c>Write()</c> on that <c>DeflateStream</c>, providing uncompressed data
///   as input.  The data sent to the output stream will be the compressed form
///   of the data written.  If you wish to use the <c>DeflateStream</c> to
///   decompress data while writing, you can create a <c>DeflateStream</c> with
///   <c>CompressionMode.Decompress</c>, and a writable output stream.  Then
///   call <c>Write()</c> on that stream, providing previously compressed
///   data. The data sent to the output stream will be the decompressed form of
///   the data written.
/// </para>
///
/// <para>
///   A <c>DeflateStream</c> can be used for <c>Read()</c> or <c>Write()</c>,
///   but not both.
/// </para>
///
/// </remarks>
///
/// <param name="buffer">The buffer holding data to write to the stream.</param>
/// <param name="offset">the offset within that data array to find the first byte to write.</param>
/// <param name="count">the number of bytes to write.</param>
/// <summary>
///   Compress a string into a byte array using DEFLATE (RFC 1951).
/// </summary>
///
/// <remarks>
///   Uncompress it with <see cref="DeflateStream.UncompressString(byte[])"/>.
/// </remarks>
///
/// <seealso cref="DeflateStream.UncompressString(byte[])">DeflateStream.UncompressString(byte[])</seealso>
/// <seealso cref="DeflateStream.CompressBuffer(byte[])">DeflateStream.CompressBuffer(byte[])</seealso>
/// <seealso cref="GZipStream.CompressString(string)">GZipStream.CompressString(string)</seealso>
/// <seealso cref="ZlibStream.CompressString(string)">ZlibStream.CompressString(string)</seealso>
///
/// <param name="s">
///   A string to compress. The string will first be encoded
///   using UTF8, then compressed.
/// </param>
///
/// <returns>The string in compressed form</returns>
/// <summary>
///   Compress a byte array into a new byte array using DEFLATE.
/// </summary>
///
/// <remarks>
///   Uncompress it with <see cref="DeflateStream.UncompressBuffer(byte[])"/>.
/// </remarks>
///
/// <seealso cref="DeflateStream.CompressString(string)">DeflateStream.CompressString(string)</seealso>
/// <seealso cref="DeflateStream.UncompressBuffer(byte[])">DeflateStream.UncompressBuffer(byte[])</seealso>
/// <seealso cref="GZipStream.CompressBuffer(byte[])">GZipStream.CompressBuffer(byte[])</seealso>
/// <seealso cref="ZlibStream.CompressBuffer(byte[])">ZlibStream.CompressBuffer(byte[])</seealso>
///
/// <param name="b">
///   A buffer to compress.
/// </param>
///
/// <returns>The data in compressed form</returns>
/// <summary>
///   Uncompress a DEFLATE'd byte array into a single string.
/// </summary>
///
/// <seealso cref="DeflateStream.CompressString(String)">DeflateStream.CompressString(String)</seealso>
/// <seealso cref="DeflateStream.UncompressBuffer(byte[])">DeflateStream.UncompressBuffer(byte[])</seealso>
/// <seealso cref="GZipStream.UncompressString(byte[])">GZipStream.UncompressString(byte[])</seealso>
/// <seealso cref="ZlibStream.UncompressString(byte[])">ZlibStream.UncompressString(byte[])</seealso>
///
/// <param name="compressed">
///   A buffer containing DEFLATE-compressed data.
/// </param>
///
/// <returns>The uncompressed string</returns>
/// <summary>
///   Uncompress a DEFLATE'd byte array into a byte array.
/// </summary>
///
/// <seealso cref="DeflateStream.CompressBuffer(byte[])">DeflateStream.CompressBuffer(byte[])</seealso>
/// <seealso cref="DeflateStream.UncompressString(byte[])">DeflateStream.UncompressString(byte[])</seealso>
/// <seealso cref="GZipStream.UncompressBuffer(byte[])">GZipStream.UncompressBuffer(byte[])</seealso>
/// <seealso cref="ZlibStream.UncompressBuffer(byte[])">ZlibStream.UncompressBuffer(byte[])</seealso>
///
/// <param name="compressed">
///   A buffer containing data that has been compressed with DEFLATE.
/// </param>
///
/// <returns>The data in uncompressed form</returns>
// GZipStream.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009 Dino Chiesa and Microsoft Corporation.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-August-08 18:14:39>
//
// ------------------------------------------------------------------
//
// This module defines the GZipStream class, which can be used as a replacement for
// the System.IO.Compression.GZipStream class in the .NET BCL.  NB: The design is not
// completely OO clean: there is some intelligence in the ZlibBaseStream that reads the
// GZip header.
//
// ------------------------------------------------------------------
/// <summary>
///   A class for compressing and decompressing GZIP streams.
/// </summary>
/// <remarks>
///
/// <para>
///   The <c>GZipStream</c> is a <see
///   href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a
///   <see cref="Stream"/>. It adds GZIP compression or decompression to any
///   stream.
/// </para>
///
/// <para>
///   Like the <c>System.IO.Compression.GZipStream</c> in the .NET Base Class Library, the
///   <c>Ionic.Zlib.GZipStream</c> can compress while writing, or decompress while
///   reading, but not vice versa.  The compression method used is GZIP, which is
///   documented in <see href="http://www.ietf.org/rfc/rfc1952.txt">IETF RFC
///   1952</see>, "GZIP file format specification version 4.3".</para>
///
/// <para>
///   A <c>GZipStream</c> can be used to decompress data (through <c>Read()</c>) or
///   to compress data (through <c>Write()</c>), but not both.
/// </para>
///
/// <para>
///   If you wish to use the <c>GZipStream</c> to compress data, you must wrap it
///   around a write-able stream. As you call <c>Write()</c> on the <c>GZipStream</c>, the
///   data will be compressed into the GZIP format.  If you want to decompress data,
///   you must wrap the <c>GZipStream</c> around a readable stream that contains an
///   IETF RFC 1952-compliant stream.  The data will be decompressed as you call
///   <c>Read()</c> on the <c>GZipStream</c>.
/// </para>
///
/// <para>
///   Though the GZIP format allows data from multiple files to be concatenated
///   together, this stream handles only a single segment of GZIP format, typically
///   representing a single file.
/// </para>
///
/// <para>
///   This class is similar to <see cref="ZlibStream"/> and <see cref="DeflateStream"/>.
///   <c>ZlibStream</c> handles RFC1950-compliant streams.  <see cref="DeflateStream"/>
///   handles RFC1951-compliant streams. This class handles RFC1952-compliant streams.
/// </para>
///
/// </remarks>
///
/// <seealso cref="DeflateStream" />
/// <seealso cref="ZlibStream" />
// GZip format
// source: http://tools.ietf.org/html/rfc1952
//
//  header id:           2 bytes    1F 8B
//  compress method      1 byte     8= DEFLATE (none other supported)
//  flag                 1 byte     bitfield (See below)
//  mtime                4 bytes    time_t (seconds since jan 1, 1970 UTC of the file.
//  xflg                 1 byte     2 = max compress used , 4 = max speed (can be ignored)
//  OS                   1 byte     OS for originating archive. set to 0xFF in compression.
//  extra field length   2 bytes    optional - only if FEXTRA is set.
//  extra field          varies
//  filename             varies     optional - if FNAME is set.  zero terminated. ISO-8859-1.
//  file comment         varies     optional - if FCOMMENT is set. zero terminated. ISO-8859-1.
//  crc16                1 byte     optional - present only if FHCRC bit is set
//  compressed data      varies
//  CRC32                4 bytes
//  isize                4 bytes    data size modulo 2^32
//
//     FLG (FLaGs)
//                bit 0   FTEXT - indicates file is ASCII text (can be safely ignored)
//                bit 1   FHCRC - there is a CRC16 for the header immediately following the header
//                bit 2   FEXTRA - extra fields are present
//                bit 3   FNAME - the zero-terminated filename is present. encoding; ISO-8859-1.
//                bit 4   FCOMMENT  - a zero-terminated file comment is present. encoding: ISO-8859-1
//                bit 5   reserved
//                bit 6   reserved
//                bit 7   reserved
//
// On consumption:
// Extra field is a bunch of nonsense and can be safely ignored.
// Header CRC and OS, likewise.
//
// on generation:
// all optional fields get 0, except for the OS, which gets 255.
//
/// <summary>
///   The comment on the GZIP stream.
/// </summary>
///
/// <remarks>
/// <para>
///   The GZIP format allows for each file to optionally have an associated
///   comment stored with the file.  The comment is encoded with the ISO-8859-1
///   code page.  To include a comment in a GZIP stream you create, set this
///   property before calling <c>Write()</c> for the first time on the
///   <c>GZipStream</c>.
/// </para>
///
/// <para>
///   When using <c>GZipStream</c> to decompress, you can retrieve this property
///   after the first call to <c>Read()</c>.  If no comment has been set in the
///   GZIP bytestream, the Comment property will return <c>null</c>
///   (<c>Nothing</c> in VB).
/// </para>
/// </remarks>
/// <summary>
///   The FileName for the GZIP stream.
/// </summary>
///
/// <remarks>
///
/// <para>
///   The GZIP format optionally allows each file to have an associated
///   filename.  When compressing data (through <c>Write()</c>), set this
///   FileName before calling <c>Write()</c> the first time on the <c>GZipStream</c>.
///   The actual filename is encoded into the GZIP bytestream with the
///   ISO-8859-1 code page, according to RFC 1952. It is the application's
///   responsibility to insure that the FileName can be encoded and decoded
///   correctly with this code page.
/// </para>
///
/// <para>
///   When decompressing (through <c>Read()</c>), you can retrieve this value
///   any time after the first <c>Read()</c>.  In the case where there was no filename
///   encoded into the GZIP bytestream, the property will return <c>null</c> (<c>Nothing</c>
///   in VB).
/// </para>
/// </remarks>
// trim any leading path
/// <summary>
///   The last modified time for the GZIP stream.
/// </summary>
///
/// <remarks>
///   GZIP allows the storage of a last modified time with each GZIP entry.
///   When compressing data, you can set this before the first call to
///   <c>Write()</c>.  When decompressing, you can retrieve this value any time
///   after the first call to <c>Read()</c>.
/// </remarks>
/// <summary>
/// The CRC on the GZIP stream.
/// </summary>
/// <remarks>
/// This is used for internal error checking. You probably don't need to look at this property.
/// </remarks>
/// <summary>
///   Create a <c>GZipStream</c> using the specified <c>CompressionMode</c>.
/// </summary>
/// <remarks>
///
/// <para>
///   When mode is <c>CompressionMode.Compress</c>, the <c>GZipStream</c> will use the
///   default compression level.
/// </para>
///
/// <para>
///   As noted in the class documentation, the <c>CompressionMode</c> (Compress
///   or Decompress) also establishes the "direction" of the stream.  A
///   <c>GZipStream</c> with <c>CompressionMode.Compress</c> works only through
///   <c>Write()</c>.  A <c>GZipStream</c> with
///   <c>CompressionMode.Decompress</c> works only through <c>Read()</c>.
/// </para>
///
/// </remarks>
///
/// <example>
///   This example shows how to use a GZipStream to compress data.
/// <code>
/// using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
/// {
///     using (var raw = System.IO.File.Create(outputFile))
///     {
///         using (Stream compressor = new GZipStream(raw, CompressionMode.Compress))
///         {
///             byte[] buffer = new byte[WORKING_BUFFER_SIZE];
///             int n;
///             while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
///             {
///                 compressor.Write(buffer, 0, n);
///             }
///         }
///     }
/// }
/// </code>
/// <code lang="VB">
/// Dim outputFile As String = (fileToCompress &amp; ".compressed")
/// Using input As Stream = File.OpenRead(fileToCompress)
///     Using raw As FileStream = File.Create(outputFile)
///     Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress)
///         Dim buffer As Byte() = New Byte(4096) {}
///         Dim n As Integer = -1
///         Do While (n &lt;&gt; 0)
///             If (n &gt; 0) Then
///                 compressor.Write(buffer, 0, n)
///             End If
///             n = input.Read(buffer, 0, buffer.Length)
///         Loop
///     End Using
///     End Using
/// End Using
/// </code>
/// </example>
///
/// <example>
/// This example shows how to use a GZipStream to uncompress a file.
/// <code>
/// private void GunZipFile(string filename)
/// {
///     if (!filename.EndsWith(".gz))
///         throw new ArgumentException("filename");
///     var DecompressedFile = filename.Substring(0,filename.Length-3);
///     byte[] working = new byte[WORKING_BUFFER_SIZE];
///     int n= 1;
///     using (System.IO.Stream input = System.IO.File.OpenRead(filename))
///     {
///         using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
///         {
///             using (var output = System.IO.File.Create(DecompressedFile))
///             {
///                 while (n !=0)
///                 {
///                     n= decompressor.Read(working, 0, working.Length);
///                     if (n > 0)
///                     {
///                         output.Write(working, 0, n);
///                     }
///                 }
///             }
///         }
///     }
/// }
/// </code>
///
/// <code lang="VB">
/// Private Sub GunZipFile(ByVal filename as String)
///     If Not (filename.EndsWith(".gz)) Then
///         Throw New ArgumentException("filename")
///     End If
///     Dim DecompressedFile as String = filename.Substring(0,filename.Length-3)
///     Dim working(WORKING_BUFFER_SIZE) as Byte
///     Dim n As Integer = 1
///     Using input As Stream = File.OpenRead(filename)
///         Using decompressor As Stream = new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, True)
///             Using output As Stream = File.Create(UncompressedFile)
///                 Do
///                     n= decompressor.Read(working, 0, working.Length)
///                     If n > 0 Then
///                         output.Write(working, 0, n)
///                     End IF
///                 Loop While (n  > 0)
///             End Using
///         End Using
///     End Using
/// End Sub
/// </code>
/// </example>
///
/// <param name="stream">The stream which will be read or written.</param>
/// <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
/// <summary>
///   Create a <c>GZipStream</c> using the specified <c>CompressionMode</c> and
///   the specified <c>CompressionLevel</c>.
/// </summary>
/// <remarks>
///
/// <para>
///   The <c>CompressionMode</c> (Compress or Decompress) also establishes the
///   "direction" of the stream.  A <c>GZipStream</c> with
///   <c>CompressionMode.Compress</c> works only through <c>Write()</c>.  A
///   <c>GZipStream</c> with <c>CompressionMode.Decompress</c> works only
///   through <c>Read()</c>.
/// </para>
///
/// </remarks>
///
/// <example>
///
/// This example shows how to use a <c>GZipStream</c> to compress a file into a .gz file.
///
/// <code>
/// using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
/// {
///     using (var raw = System.IO.File.Create(fileToCompress + ".gz"))
///     {
///         using (Stream compressor = new GZipStream(raw,
///                                                   CompressionMode.Compress,
///                                                   CompressionLevel.BestCompression))
///         {
///             byte[] buffer = new byte[WORKING_BUFFER_SIZE];
///             int n;
///             while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
///             {
///                 compressor.Write(buffer, 0, n);
///             }
///         }
///     }
/// }
/// </code>
///
/// <code lang="VB">
/// Using input As Stream = File.OpenRead(fileToCompress)
///     Using raw As FileStream = File.Create(fileToCompress &amp; ".gz")
///         Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
///             Dim buffer As Byte() = New Byte(4096) {}
///             Dim n As Integer = -1
///             Do While (n &lt;&gt; 0)
///                 If (n &gt; 0) Then
///                     compressor.Write(buffer, 0, n)
///                 End If
///                 n = input.Read(buffer, 0, buffer.Length)
///             Loop
///         End Using
///     End Using
/// End Using
/// </code>
/// </example>
/// <param name="stream">The stream to be read or written while deflating or inflating.</param>
/// <param name="mode">Indicates whether the <c>GZipStream</c> will compress or decompress.</param>
/// <param name="level">A tuning knob to trade speed for effectiveness.</param>
/// <summary>
///   Create a <c>GZipStream</c> using the specified <c>CompressionMode</c>, and
///   explicitly specify whether the stream should be left open after Deflation
///   or Inflation.
/// </summary>
///
/// <remarks>
/// <para>
///   This constructor allows the application to request that the captive stream
///   remain open after the deflation or inflation occurs.  By default, after
///   <c>Close()</c> is called on the stream, the captive stream is also
///   closed. In some cases this is not desired, for example if the stream is a
///   memory stream that will be re-read after compressed data has been written
///   to it.  Specify true for the <paramref name="leaveOpen"/> parameter to leave
///   the stream open.
/// </para>
///
/// <para>
///   The <see cref="CompressionMode"/> (Compress or Decompress) also
///   establishes the "direction" of the stream.  A <c>GZipStream</c> with
///   <c>CompressionMode.Compress</c> works only through <c>Write()</c>.  A <c>GZipStream</c>
///   with <c>CompressionMode.Decompress</c> works only through <c>Read()</c>.
/// </para>
///
/// <para>
///   The <c>GZipStream</c> will use the default compression level. If you want
///   to specify the compression level, see <see cref="GZipStream(Stream,
///   CompressionMode, CompressionLevel, bool)"/>.
/// </para>
///
/// <para>
///   See the other overloads of this constructor for example code.
/// </para>
///
/// </remarks>
///
/// <param name="stream">
///   The stream which will be read or written. This is called the "captive"
///   stream in other places in this documentation.
/// </param>
///
/// <param name="mode">Indicates whether the GZipStream will compress or decompress.
/// </param>
///
/// <param name="leaveOpen">
///   true if the application would like the base stream to remain open after
///   inflation/deflation.
/// </param>
/// <summary>
///   Create a <c>GZipStream</c> using the specified <c>CompressionMode</c> and the
///   specified <c>CompressionLevel</c>, and explicitly specify whether the
///   stream should be left open after Deflation or Inflation.
/// </summary>
///
/// <remarks>
///
/// <para>
///   This constructor allows the application to request that the captive stream
///   remain open after the deflation or inflation occurs.  By default, after
///   <c>Close()</c> is called on the stream, the captive stream is also
///   closed. In some cases this is not desired, for example if the stream is a
///   memory stream that will be re-read after compressed data has been written
///   to it.  Specify true for the <paramref name="leaveOpen"/> parameter to
///   leave the stream open.
/// </para>
///
/// <para>
///   As noted in the class documentation, the <c>CompressionMode</c> (Compress
///   or Decompress) also establishes the "direction" of the stream.  A
///   <c>GZipStream</c> with <c>CompressionMode.Compress</c> works only through
///   <c>Write()</c>.  A <c>GZipStream</c> with <c>CompressionMode.Decompress</c> works only
///   through <c>Read()</c>.
/// </para>
///
/// </remarks>
///
/// <example>
///   This example shows how to use a <c>GZipStream</c> to compress data.
/// <code>
/// using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
/// {
///     using (var raw = System.IO.File.Create(outputFile))
///     {
///         using (Stream compressor = new GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, true))
///         {
///             byte[] buffer = new byte[WORKING_BUFFER_SIZE];
///             int n;
///             while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
///             {
///                 compressor.Write(buffer, 0, n);
///             }
///         }
///     }
/// }
/// </code>
/// <code lang="VB">
/// Dim outputFile As String = (fileToCompress &amp; ".compressed")
/// Using input As Stream = File.OpenRead(fileToCompress)
///     Using raw As FileStream = File.Create(outputFile)
///     Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, True)
///         Dim buffer As Byte() = New Byte(4096) {}
///         Dim n As Integer = -1
///         Do While (n &lt;&gt; 0)
///             If (n &gt; 0) Then
///                 compressor.Write(buffer, 0, n)
///             End If
///             n = input.Read(buffer, 0, buffer.Length)
///         Loop
///     End Using
///     End Using
/// End Using
/// </code>
/// </example>
/// <param name="stream">The stream which will be read or written.</param>
/// <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
/// <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
/// <param name="level">A tuning knob to trade speed for effectiveness.</param>
/// <summary>
/// This property sets the flush behavior on the stream.
/// </summary>
/// <summary>
///   The size of the working buffer for the compression codec.
/// </summary>
///
/// <remarks>
/// <para>
///   The working buffer is used for all stream operations.  The default size is
///   1024 bytes.  The minimum size is 128 bytes. You may get better performance
///   with a larger buffer.  Then again, you might not.  You would have to test
///   it.
/// </para>
///
/// <para>
///   Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
///   stream. If you try to set it afterwards, it will throw.
/// </para>
/// </remarks>
/// <summary> Returns the total number of bytes input so far.</summary>
/// <summary> Returns the total number of bytes output so far.</summary>
/// <summary>
///   Dispose the stream.
/// </summary>
/// <remarks>
///   <para>
///     This may or may not result in a <c>Close()</c> call on the captive
///     stream.  See the constructors that have a <c>leaveOpen</c> parameter
///     for more information.
///   </para>
///   <para>
///     This method may be invoked in two distinct scenarios.  If disposing
///     == true, the method has been called directly or indirectly by a
///     user's code, for example via the public Dispose() method. In this
///     case, both managed and unmanaged resources can be referenced and
///     disposed.  If disposing == false, the method has been called by the
///     runtime from inside the object finalizer and this method should not
///     reference other objects; in that case only unmanaged resources must
///     be referenced or disposed.
///   </para>
/// </remarks>
/// <param name="disposing">
///   indicates whether the Dispose method was invoked by user code.
/// </param>
/// <summary>
/// Indicates whether the stream can be read.
/// </summary>
/// <remarks>
/// The return value depends on whether the captive stream supports reading.
/// </remarks>
/// <summary>
/// Indicates whether the stream supports Seek operations.
/// </summary>
/// <remarks>
/// Always returns false.
/// </remarks>
/// <summary>
/// Indicates whether the stream can be written.
/// </summary>
/// <remarks>
/// The return value depends on whether the captive stream supports writing.
/// </remarks>
/// <summary>
/// Flush the stream.
/// </summary>
/// <summary>
/// Reading this property always throws a <see cref="NotImplementedException"/>.
/// </summary>
/// <summary>
///   The position of the stream pointer.
/// </summary>
///
/// <remarks>
///   Setting this property always throws a <see
///   cref="NotImplementedException"/>. Reading will return the total bytes
///   written out, if used in writing, or the total bytes read in, if used in
///   reading.  The count may refer to compressed bytes or uncompressed bytes,
///   depending on how you've used the stream.
/// </remarks>
/// <summary>
///   Read and decompress data from the source stream.
/// </summary>
///
/// <remarks>
///   With a <c>GZipStream</c>, decompression is done through reading.
/// </remarks>
///
/// <example>
/// <code>
/// byte[] working = new byte[WORKING_BUFFER_SIZE];
/// using (System.IO.Stream input = System.IO.File.OpenRead(_CompressedFile))
/// {
///     using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
///     {
///         using (var output = System.IO.File.Create(_DecompressedFile))
///         {
///             int n;
///             while ((n= decompressor.Read(working, 0, working.Length)) !=0)
///             {
///                 output.Write(working, 0, n);
///             }
///         }
///     }
/// }
/// </code>
/// </example>
/// <param name="buffer">The buffer into which the decompressed data should be placed.</param>
/// <param name="offset">the offset within that data array to put the first byte read.</param>
/// <param name="count">the number of bytes to read.</param>
/// <returns>the number of bytes actually read</returns>
// Console.WriteLine("GZipStream::Read(buffer, off({0}), c({1}) = {2}", offset, count, n);
// Console.WriteLine( Util.FormatByteArray(buffer, offset, n) );
/// <summary>
///   Calling this method always throws a <see cref="NotImplementedException"/>.
/// </summary>
/// <param name="offset">irrelevant; it will always throw!</param>
/// <param name="origin">irrelevant; it will always throw!</param>
/// <returns>irrelevant!</returns>
/// <summary>
///   Calling this method always throws a <see cref="NotImplementedException"/>.
/// </summary>
/// <param name="value">irrelevant; this method will always throw!</param>
/// <summary>
///   Write data to the stream.
/// </summary>
///
/// <remarks>
/// <para>
///   If you wish to use the <c>GZipStream</c> to compress data while writing,
///   you can create a <c>GZipStream</c> with <c>CompressionMode.Compress</c>, and a
///   writable output stream.  Then call <c>Write()</c> on that <c>GZipStream</c>,
///   providing uncompressed data as input.  The data sent to the output stream
///   will be the compressed form of the data written.
/// </para>
///
/// <para>
///   A <c>GZipStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not
///   both. Writing implies compression.  Reading implies decompression.
/// </para>
///
/// </remarks>
/// <param name="buffer">The buffer holding data to write to the stream.</param>
/// <param name="offset">the offset within that data array to find the first byte to write.</param>
/// <param name="count">the number of bytes to write.</param>
//Console.WriteLine("GZipStream: First write");
// first write in compression, therefore, emit the GZIP header
// ID
// compression method
// flag
// mtime
// xflg
// this field is totally useless
// OS
// 0xFF == unspecified
// extra field length - only if FEXTRA is set, which it is not.
//header[i++]= 0;
//header[i++]= 0;
// filename
// terminate
// comment
// terminate
// bytes written
/// <summary>
///   Compress a string into a byte array using GZip.
/// </summary>
///
/// <remarks>
///   Uncompress it with <see cref="GZipStream.UncompressString(byte[])"/>.
/// </remarks>
///
/// <seealso cref="GZipStream.UncompressString(byte[])"/>
/// <seealso cref="GZipStream.CompressBuffer(byte[])"/>
///
/// <param name="s">
///   A string to compress. The string will first be encoded
///   using UTF8, then compressed.
/// </param>
///
/// <returns>The string in compressed form</returns>
/// <summary>
///   Compress a byte array into a new byte array using GZip.
/// </summary>
///
/// <remarks>
///   Uncompress it with <see cref="GZipStream.UncompressBuffer(byte[])"/>.
/// </remarks>
///
/// <seealso cref="GZipStream.CompressString(string)"/>
/// <seealso cref="GZipStream.UncompressBuffer(byte[])"/>
///
/// <param name="b">
///   A buffer to compress.
/// </param>
///
/// <returns>The data in compressed form</returns>
/// <summary>
///   Uncompress a GZip'ed byte array into a single string.
/// </summary>
///
/// <seealso cref="GZipStream.CompressString(String)"/>
/// <seealso cref="GZipStream.UncompressBuffer(byte[])"/>
///
/// <param name="compressed">
///   A buffer containing GZIP-compressed data.
/// </param>
///
/// <returns>The uncompressed string</returns>
/// <summary>
///   Uncompress a GZip'ed byte array into a byte array.
/// </summary>
///
/// <seealso cref="GZipStream.CompressBuffer(byte[])"/>
/// <seealso cref="GZipStream.UncompressString(byte[])"/>
///
/// <param name="compressed">
///   A buffer containing data that has been compressed with GZip.
/// </param>
///
/// <returns>The data in uncompressed form</returns>
// Inflate.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009 Dino Chiesa and Microsoft Corporation.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2010-January-08 18:32:12>
//
// ------------------------------------------------------------------
//
// This module defines classes for decompression. This code is derived
// from the jzlib implementation of zlib, but significantly modified.
// The object model is not the same, and many of the behaviors are
// different.  Nonetheless, in keeping with the license for jzlib, I am
// reproducing the copyright to that code here.
//
// ------------------------------------------------------------------
//
// Copyright (c) 2000,2001,2002,2003 ymnk, JCraft,Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in
// the documentation and/or other materials provided with the distribution.
//
// 3. The names of the authors may not be used to endorse or promote products
// derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
// FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
// INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// -----------------------------------------------------------------------
//
// This program is based on zlib-1.1.3; credit to authors
// Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
// and contributors of zlib.
//
// -----------------------------------------------------------------------
// Table for deflate from PKZIP's appnote.txt.
// get type bits (3, including end bit)
// get lengths for stored
// processing stored block
// get table lengths
// get bit lengths tree for a dynamic block
// get length, distance trees for a dynamic block
// processing fixed or dynamic block
// output remaining window bytes
// finished last block, done
// ot a data error--stuck here
// current inflate_block mode
// if STORED, bytes left to copy
// table lengths (14 bits)
// index into blens (or border)
// bit lengths of codes
// bit length tree depth
// bit length decoding tree
// if CODES, current state
// true if this block is the last block
// pointer back to this zlib stream
// mode independent information
// bits in bit buffer
// bit buffer
// single malloc for tree space
// sliding window
// one byte after sliding window
// window read pointer
// window write pointer
// check function
// check on output
// temporary storage
// bit buffer
// bits in bit buffer
// input data pointer
// bytes available there
// output window write pointer
// bytes to end of window or read pointer
// copy input/output information to locals (UPDATE macro restores)
// process input based on current state
// stored
// go to byte boundary
// get length of stored block
// fixed
// dynamic
// illegal
// dump bits
// for (int i = 0; i < t; i++)
// {
//     blens[i] = 0;
// }
// c == 16..18
// must be <= 9 for lookahead assumptions
// must be <= 9 for lookahead assumptions
// Returns true if inflate is currently at the end of a block generated
// by Z_SYNC_FLUSH or Z_FULL_FLUSH.
// copy as much as possible from the sliding window to the output area
// compute number of bytes to copy as far as end of window
// compute bytes to copy
// workitem 8870
// update counters
// update check information
// copy as far as end of window
// see if more to copy at beginning of window
// wrap pointers
// done
// And'ing with mask[n] masks the lower n bits
// waiting for "i:"=input,
//             "o:"=output,
//             "x:"=nothing
// x: set up for LEN
// i: get length/literal/eob next
// i: getting length extra (have base)
// i: get distance next
// i: getting distance extra
// o: copying bytes in window, waiting for space
// o: got literal, waiting for output space
// o: got eob, possibly still output waiting
// x: got eob and all data flushed
// x: got error
// current inflate_codes mode
// mode dependent information
// pointer into tree
// bits needed
// if EXT or COPY, where and how much
// bits to get for extra
// distance back to copy from
// ltree bits decoded per branch
// dtree bits decoder per branch
// literal/length/eob tree
// literal/length/eob tree
// distance tree
// distance tree
// temporary storage
// temporary pointer
// extra bits or operation
// bit buffer
// bits in bit buffer
// input data pointer
// bytes available there
// output window write pointer
// bytes to end of window or read pointer
// pointer to copy strings from
// copy input/output information to locals (UPDATE macro restores)
// process input and output based on current state
// waiting for "i:"=input, "o:"=output, "x:"=nothing
// x: set up for LEN
// i: get length/literal/eob next
// literal
// length
// next table
// end of block
// invalid code
// i: getting length extra (have base)
// i: get distance next
// distance
// next table
// invalid code
// i: getting distance extra
// o: copying bytes in window, waiting for space
// modulo window size-"while" instead
// of "if" handles invalid distances
// o: got literal, waiting for output space
// o: got eob, possibly more output
// return unused byte, if any
// can always return one
// x: got error
// Called with number of bytes left to write in window at least 258
// (the maximum string length) and number of input bytes available
// at least ten.  The ten bytes are six bytes for the longest length/
// distance pair plus four bytes for overloading the bit buffer.
// temporary pointer
// temporary pointer
// temporary pointer
// extra bits or operation
// bit buffer
// bits in bit buffer
// input data pointer
// bytes available there
// output window write pointer
// bytes to end of window or read pointer
// mask for literal/length tree
// mask for distance tree
// bytes to copy
// distance back to copy from
// copy source pointer
// (tp_index+t)*3
// load input, output, bit values
// initialize masks
// do until not enough input or output space for fast loop
// assume called with m >= 258 && n >= 10
// get literal/length code
// max bits for literal/length code
// decode distance base of block to copy
// max bits for distance code
// get extra bits to add to distance base
// get extra bits (up to 13)
// do the copy
// offset before dest
//  just copy
// minimum count is three,
// so unroll loop a little
// else offset after destination
// force pointer in window
// covers invalid distances
// if source crosses,
// wrapped copy
// copy rest from start of window
// copy all or what's left
// not enough input or output--restore pointers and return
// preset dictionary flag in zlib header
// waiting for method byte
// waiting for flag byte
// four dictionary check bytes to go
// three dictionary check bytes to go
// two dictionary check bytes to go
// one dictionary check byte to go
// waiting for inflateSetDictionary
// decompressing blocks
// four check bytes to go
// three check bytes to go
// two check bytes to go
// one check byte to go
// finished check, done
// got an error--stay here
// current inflate mode
// pointer back to this zlib stream
// mode dependent information
// if FLAGS, method byte
// if CHECK, check values to compare
// computed check value
// stream check value
// if BAD, inflateSync's marker bytes count
// mode independent information
//internal int nowrap; // flag for no wrapper
// log2(window size)  (8..15, defaults to 15)
// current inflate_blocks state
// handle undocumented nowrap option (no zlib header or check)
//nowrap = 0;
//if (w < 0)
//{
//    w = - w;
//    nowrap = 1;
//}
// set window size
//return ZlibConstants.Z_STREAM_ERROR;
// reset state
//             int f = (flush == FlushType.Finish)
//                 ? ZlibConstants.Z_BUF_ERROR
//                 : ZlibConstants.Z_OK;
// workitem 8870
// can't try inflateSync
// can't try inflateSync
// can't try inflateSync
// can try inflateSync
// can try inflateSync
// can't try inflateSync
//MSZip requires the dictionary to be set unconditionally
// number of bytes to look at
// pointer to bytes
// number of marker bytes found in a row
// temporaries to save total_in and total_out
// set up
// search
// restore
// return no joy or set up to restart on a new block
// Returns true if inflate is currently at the end of a block generated
// by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
// implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH
// but removes the length bytes of the resulting empty stored block. When
// decompressing, PPP checks that at the end of input packet, inflate is
// waiting for these length bytes.
// Inftree.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009 Dino Chiesa and Microsoft Corporation.  
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License. 
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs): 
// Time-stamp: <2009-October-28 12:43:54>
//
// ------------------------------------------------------------------
//
// This module defines classes used in  decompression. This code is derived
// from the jzlib implementation of zlib. In keeping with the license for jzlib, 
// the copyright to that code is below.
//
// ------------------------------------------------------------------
// 
// Copyright (c) 2000,2001,2002,2003 ymnk, JCraft,Inc. All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 
// 1. Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
// 
// 2. Redistributions in binary form must reproduce the above copyright 
// notice, this list of conditions and the following disclaimer in 
// the documentation and/or other materials provided with the distribution.
// 
// 3. The names of the authors may not be used to endorse or promote products
// derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
// FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
// INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 
// -----------------------------------------------------------------------
//
// This program is based on zlib-1.1.3; credit to authors
// Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
// and contributors of zlib.
//
// -----------------------------------------------------------------------
//UPGRADE_NOTE: Final was removed from the declaration of 'fixed_tl'. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1003'"
//UPGRADE_NOTE: Final was removed from the declaration of 'fixed_td'. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1003'"
// Tables for deflate from PKZIP's appnote.txt.
//UPGRADE_NOTE: Final was removed from the declaration of 'cplens'. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1003'"
// see note #13 above about 258
//UPGRADE_NOTE: Final was removed from the declaration of 'cplext'. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1003'"
//UPGRADE_NOTE: Final was removed from the declaration of 'cpdist'. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1003'"
//UPGRADE_NOTE: Final was removed from the declaration of 'cpdext'. "ms-help://MS.VSCC.v80/dv_commoner/local/redirect.htm?index='!DefaultContextWindowIndex'&keyword='jlca1003'"
// If BMAX needs to be larger than 16, then h and x[] should be uLong.
// maximum bit length of any code
// hufts used in space
// work area for huft_build 
// bit length count table
// table entry for structure assignment
// table stack
// bit offsets, then code stack
// Given a list of code lengths and a maximum table size, make a set of
// tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
// if the given code set is incomplete (the tables are still built in this
// case), Z_DATA_ERROR if the input is invalid (an over-subscribed set of
// lengths), or Z_MEM_ERROR if not enough memory.
// counter for codes of length k
// i repeats in table every f entries
// maximum code length
// table level
// counter, current code
// counter
// number of bits in current code
// bits per table (returned in m)
// (1 << w) - 1, to avoid cc -O bug on HP
// pointer into c[], b[], or v[]
// points to current table
// bits before this table == (l * h)
// pointer into x
// number of dummy codes added
// number of entries in current table
// Generate counts for each bit length
// assume all entries <= BMAX
// null input--all zero length codes
// Find minimum and maximum length, bound *m by those
// minimum code length
// maximum code length
// Adjust last length count to fill out codes, if needed
// Generate starting offsets into the value table for each length
// note that i == g from above
// Make a table of values in order of bit lengths
// set n to length of v
// Generate the Huffman codes and for each, make the table entries
// first Huffman code is zero
// grab values in bit order
// no tables yet--level -1
// bits decoded == (l * h)
// just to keep compilers happy
// ditto
// ditto
// go through the bit lengths (k already is bits in shortest code)
// here i is the Huffman code of length k bits for value *p
// make tables up to required level
// previous table always l bits
// compute minimum size table less than or equal to l bits
// table size upper limit
// try a k-w bit table
// too few codes for k-w bit table
// deduct codes from patterns left
// try smaller tables up to z bits
// enough codes to use up j bits
// else deduct codes from patterns
// table entries for j-bit table
// allocate new table
// (note: doesn't matter for fixed)
// overflow of MANY
// DEBUG
// connect to last table, if there is one
// save pattern for backing up
// bits in this table
// bits to dump before this table
// offset to this table
// connect to last table
// first table is returned result
// set up table entry in r
// out of values--invalid code
// 256 is end-of-block
// simple code is just the value
// non-simple--look up in lists
// fill code-like entries with r
// backwards increment the k-bit code i
// backup over finished tables
// needed on HP, cc -O bug
// don't need to update q
// Return Z_BUF_ERROR if we were given an incomplete table
// build literal/length tree
// build distance tree
//  for(int i=0; i<BMAX; i++){u[i]=0;}
//Array.Copy(c, 0, u, 0, BMAX);
//  for(int i=0; i<BMAX+1; i++){x[i]=0;}
//Array.Copy(c, 0, x, 0, BMAX + 1);
//#define Trace
// ParallelDeflateOutputStream.cs
// ------------------------------------------------------------------
//
// A DeflateStream that does compression only, it uses a
// divide-and-conquer approach with multiple threads to exploit multiple
// CPUs for the DEFLATE computation.
//
// last saved: <2011-July-31 14:49:40>
//
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2011 by Dino Chiesa
// All rights reserved!
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
// alloc 5 bytes overhead for every block (margin of safety= 2)
/// <summary>
///   A class for compressing streams using the
///   Deflate algorithm with multiple threads.
/// </summary>
///
/// <remarks>
/// <para>
///   This class performs DEFLATE compression through writing.  For
///   more information on the Deflate algorithm, see IETF RFC 1951,
///   "DEFLATE Compressed Data Format Specification version 1.3."
/// </para>
///
/// <para>
///   This class is similar to <see cref="Ionic.Zlib.DeflateStream"/>, except
///   that this class is for compression only, and this implementation uses an
///   approach that employs multiple worker threads to perform the DEFLATE.  On
///   a multi-cpu or multi-core computer, the performance of this class can be
///   significantly higher than the single-threaded DeflateStream, particularly
///   for larger streams.  How large?  Anything over 10mb is a good candidate
///   for parallel compression.
/// </para>
///
/// <para>
///   The tradeoff is that this class uses more memory and more CPU than the
///   vanilla DeflateStream, and also is less efficient as a compressor. For
///   large files the size of the compressed data stream can be less than 1%
///   larger than the size of a compressed data stream from the vanialla
///   DeflateStream.  For smaller files the difference can be larger.  The
///   difference will also be larger if you set the BufferSize to be lower than
///   the default value.  Your mileage may vary. Finally, for small files, the
///   ParallelDeflateOutputStream can be much slower than the vanilla
///   DeflateStream, because of the overhead associated to using the thread
///   pool.
/// </para>
///
/// </remarks>
/// <seealso cref="Ionic.Zlib.DeflateStream" />
// 128k
//private ManualResetEvent            _writingDone;
//private ManualResetEvent            _sessionReset;
// protects _pendingException
// This bitfield is used only when Trace is defined.
//private TraceBits _DesiredTrace = TraceBits.Write | TraceBits.WriteBegin |
//TraceBits.WriteDone | TraceBits.Lifecycle | TraceBits.Fill | TraceBits.Flush |
//TraceBits.Session;
//private TraceBits _DesiredTrace = TraceBits.WriteBegin | TraceBits.WriteDone | TraceBits.Synch | TraceBits.Lifecycle  | TraceBits.Session ;
/// <summary>
/// Create a ParallelDeflateOutputStream.
/// </summary>
/// <remarks>
///
/// <para>
///   This stream compresses data written into it via the DEFLATE
///   algorithm (see RFC 1951), and writes out the compressed byte stream.
/// </para>
///
/// <para>
///   The instance will use the default compression level, the default
///   buffer sizes and the default number of threads and buffers per
///   thread.
/// </para>
///
/// <para>
///   This class is similar to <see cref="Ionic.Zlib.DeflateStream"/>,
///   except that this implementation uses an approach that employs
///   multiple worker threads to perform the DEFLATE.  On a multi-cpu or
///   multi-core computer, the performance of this class can be
///   significantly higher than the single-threaded DeflateStream,
///   particularly for larger streams.  How large?  Anything over 10mb is
///   a good candidate for parallel compression.
/// </para>
///
/// </remarks>
///
/// <example>
///
/// This example shows how to use a ParallelDeflateOutputStream to compress
/// data.  It reads a file, compresses it, and writes the compressed data to
/// a second, output file.
///
/// <code>
/// byte[] buffer = new byte[WORKING_BUFFER_SIZE];
/// int n= -1;
/// String outputFile = fileToCompress + ".compressed";
/// using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
/// {
///     using (var raw = System.IO.File.Create(outputFile))
///     {
///         using (Stream compressor = new ParallelDeflateOutputStream(raw))
///         {
///             while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
///             {
///                 compressor.Write(buffer, 0, n);
///             }
///         }
///     }
/// }
/// </code>
/// <code lang="VB">
/// Dim buffer As Byte() = New Byte(4096) {}
/// Dim n As Integer = -1
/// Dim outputFile As String = (fileToCompress &amp; ".compressed")
/// Using input As Stream = File.OpenRead(fileToCompress)
///     Using raw As FileStream = File.Create(outputFile)
///         Using compressor As Stream = New ParallelDeflateOutputStream(raw)
///             Do While (n &lt;&gt; 0)
///                 If (n &gt; 0) Then
///                     compressor.Write(buffer, 0, n)
///                 End If
///                 n = input.Read(buffer, 0, buffer.Length)
///             Loop
///         End Using
///     End Using
/// End Using
/// </code>
/// </example>
/// <param name="stream">The stream to which compressed data will be written.</param>
/// <summary>
///   Create a ParallelDeflateOutputStream using the specified CompressionLevel.
/// </summary>
/// <remarks>
///   See the <see cref="ParallelDeflateOutputStream(System.IO.Stream)"/>
///   constructor for example code.
/// </remarks>
/// <param name="stream">The stream to which compressed data will be written.</param>
/// <param name="level">A tuning knob to trade speed for effectiveness.</param>
/// <summary>
/// Create a ParallelDeflateOutputStream and specify whether to leave the captive stream open
/// when the ParallelDeflateOutputStream is closed.
/// </summary>
/// <remarks>
///   See the <see cref="ParallelDeflateOutputStream(System.IO.Stream)"/>
///   constructor for example code.
/// </remarks>
/// <param name="stream">The stream to which compressed data will be written.</param>
/// <param name="leaveOpen">
///    true if the application would like the stream to remain open after inflation/deflation.
/// </param>
/// <summary>
/// Create a ParallelDeflateOutputStream and specify whether to leave the captive stream open
/// when the ParallelDeflateOutputStream is closed.
/// </summary>
/// <remarks>
///   See the <see cref="ParallelDeflateOutputStream(System.IO.Stream)"/>
///   constructor for example code.
/// </remarks>
/// <param name="stream">The stream to which compressed data will be written.</param>
/// <param name="level">A tuning knob to trade speed for effectiveness.</param>
/// <param name="leaveOpen">
///    true if the application would like the stream to remain open after inflation/deflation.
/// </param>
/// <summary>
/// Create a ParallelDeflateOutputStream using the specified
/// CompressionLevel and CompressionStrategy, and specifying whether to
/// leave the captive stream open when the ParallelDeflateOutputStream is
/// closed.
/// </summary>
/// <remarks>
///   See the <see cref="ParallelDeflateOutputStream(System.IO.Stream)"/>
///   constructor for example code.
/// </remarks>
/// <param name="stream">The stream to which compressed data will be written.</param>
/// <param name="level">A tuning knob to trade speed for effectiveness.</param>
/// <param name="strategy">
///   By tweaking this parameter, you may be able to optimize the compression for
///   data with particular characteristics.
/// </param>
/// <param name="leaveOpen">
///    true if the application would like the stream to remain open after inflation/deflation.
/// </param>
// default
/// <summary>
///   The ZLIB strategy to be used during compression.
/// </summary>
///
/// <summary>
///   The maximum number of buffer pairs to use.
/// </summary>
///
/// <remarks>
/// <para>
///   This property sets an upper limit on the number of memory buffer
///   pairs to create.  The implementation of this stream allocates
///   multiple buffers to facilitate parallel compression.  As each buffer
///   fills up, this stream uses <see
///   cref="System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback)">
///   ThreadPool.QueueUserWorkItem()</see>
///   to compress those buffers in a background threadpool thread. After a
///   buffer is compressed, it is re-ordered and written to the output
///   stream.
/// </para>
///
/// <para>
///   A higher number of buffer pairs enables a higher degree of
///   parallelism, which tends to increase the speed of compression on
///   multi-cpu computers.  On the other hand, a higher number of buffer
///   pairs also implies a larger memory consumption, more active worker
///   threads, and a higher cpu utilization for any compression. This
///   property enables the application to limit its memory consumption and
///   CPU utilization behavior depending on requirements.
/// </para>
///
/// <para>
///   For each compression "task" that occurs in parallel, there are 2
///   buffers allocated: one for input and one for output.  This property
///   sets a limit for the number of pairs.  The total amount of storage
///   space allocated for buffering will then be (N*S*2), where N is the
///   number of buffer pairs, S is the size of each buffer (<see
///   cref="BufferSize"/>).  By default, DotNetZip allocates 4 buffer
///   pairs per CPU core, so if your machine has 4 cores, and you retain
///   the default buffer size of 128k, then the
///   ParallelDeflateOutputStream will use 4 * 4 * 2 * 128kb of buffer
///   memory in total, or 4mb, in blocks of 128kb.  If you then set this
///   property to 8, then the number will be 8 * 2 * 128kb of buffer
///   memory, or 2mb.
/// </para>
///
/// <para>
///   CPU utilization will also go up with additional buffers, because a
///   larger number of buffer pairs allows a larger number of background
///   threads to compress in parallel. If you find that parallel
///   compression is consuming too much memory or CPU, you can adjust this
///   value downward.
/// </para>
///
/// <para>
///   The default value is 16. Different values may deliver better or
///   worse results, depending on your priorities and the dynamic
///   performance characteristics of your storage and compute resources.
/// </para>
///
/// <para>
///   This property is not the number of buffer pairs to use; it is an
///   upper limit. An illustration: Suppose you have an application that
///   uses the default value of this property (which is 16), and it runs
///   on a machine with 2 CPU cores. In that case, DotNetZip will allocate
///   4 buffer pairs per CPU core, for a total of 8 pairs.  The upper
///   limit specified by this property has no effect.
/// </para>
///
/// <para>
///   The application can set this value at any time, but it is effective
///   only before the first call to Write(), which is when the buffers are
///   allocated.
/// </para>
/// </remarks>
/// <summary>
///   The size of the buffers used by the compressor threads.
/// </summary>
/// <remarks>
///
/// <para>
///   The default buffer size is 128k. The application can set this value
///   at any time, but it is effective only before the first Write().
/// </para>
///
/// <para>
///   Larger buffer sizes implies larger memory consumption but allows
///   more efficient compression. Using smaller buffer sizes consumes less
///   memory but may result in less effective compression.  For example,
///   using the default buffer size of 128k, the compression delivered is
///   within 1% of the compression delivered by the single-threaded <see
///   cref="Ionic.Zlib.DeflateStream"/>.  On the other hand, using a
///   BufferSize of 8k can result in a compressed data stream that is 5%
///   larger than that delivered by the single-threaded
///   <c>DeflateStream</c>.  Excessively small buffer sizes can also cause
///   the speed of the ParallelDeflateOutputStream to drop, because of
///   larger thread scheduling overhead dealing with many many small
///   buffers.
/// </para>
///
/// <para>
///   The total amount of storage space allocated for buffering will be
///   (N*S*2), where N is the number of buffer pairs, and S is the size of
///   each buffer (this property). There are 2 buffers used by the
///   compressor, one for input and one for output.  By default, DotNetZip
///   allocates 4 buffer pairs per CPU core, so if your machine has 4
///   cores, then the number of buffer pairs used will be 16. If you
///   accept the default value of this property, 128k, then the
///   ParallelDeflateOutputStream will use 16 * 2 * 128kb of buffer memory
///   in total, or 4mb, in blocks of 128kb.  If you set this property to
///   64kb, then the number will be 16 * 2 * 64kb of buffer memory, or
///   2mb.
/// </para>
///
/// </remarks>
/// <summary>
/// The CRC32 for the data that was written out, prior to compression.
/// </summary>
/// <remarks>
/// This value is meaningful only after a call to Close().
/// </remarks>
/// <summary>
/// The total number of uncompressed bytes processed by the ParallelDeflateOutputStream.
/// </summary>
/// <remarks>
/// This value is meaningful only after a call to Close().
/// </remarks>
/// <summary>
///   Write data to the stream.
/// </summary>
///
/// <remarks>
///
/// <para>
///   To use the ParallelDeflateOutputStream to compress data, create a
///   ParallelDeflateOutputStream with CompressionMode.Compress, passing a
///   writable output stream.  Then call Write() on that
///   ParallelDeflateOutputStream, providing uncompressed data as input.  The
///   data sent to the output stream will be the compressed form of the data
///   written.
/// </para>
///
/// <para>
///   To decompress data, use the <see cref="Ionic.Zlib.DeflateStream"/> class.
/// </para>
///
/// </remarks>
/// <param name="buffer">The buffer holding data to write to the stream.</param>
/// <param name="offset">the offset within that data array to find the first byte to write.</param>
/// <param name="count">the number of bytes to write.</param>
// This method does this:
//   0. handles any pending exceptions
//   1. write any buffers that are ready to be written,
//   2. fills a work buffer; when full, flip state to 'Filled',
//   3. if more data to be written,  goto step 1
// dispense any exceptions that occurred on the BG threads
// Want to do this on first Write, first session, and not in the
// constructor.  We want to allow MaxBufferPairs to
// change after construction, but before first Write.
// may need to make buffers available
// use current buffer, or get a new buffer to fill
// no available buffers, so... need to emit
// compressed buffers.
// TODO: consider rollover?
// copy from the provided buffer to our workitem, starting at
// the tail end of whatever data we might have in there currently.
// No need for interlocked.increment: the Write()
// method is documented as not multi-thread safe, so
// we can assume Write() calls come in from only one
// thread.
// will get a new buffer next time
// until no more to write
// After writing a series of compressed buffers, each one closed
// with Flush.Sync, we now write the final one as Flush.Finish,
// and then stop.
// compress any partial buffer
// get a new buffer next Write()
/// <summary>
/// Flush the stream.
/// </summary>
/// <summary>
/// Close the stream.
/// </summary>
/// <remarks>
/// You must call Close on the stream to guarantee that all of the data written in has
/// been compressed, and the compressed data has been written out.
/// </remarks>
// workitem 10030 - implement a new Dispose method
/// <summary>Dispose the object</summary>
/// <remarks>
///   <para>
///     Because ParallelDeflateOutputStream is IDisposable, the
///     application must call this method when finished using the instance.
///   </para>
///   <para>
///     This method is generally called implicitly upon exit from
///     a <c>using</c> scope in C# (<c>Using</c> in VB).
///   </para>
/// </remarks>
/// <summary>The Dispose method</summary>
/// <param name="disposing">
///   indicates whether the Dispose method was invoked by user code.
/// </param>
/// <summary>
///   Resets the stream for use with another stream.
/// </summary>
/// <remarks>
///   Because the ParallelDeflateOutputStream is expensive to create, it
///   has been designed so that it can be recycled and re-used.  You have
///   to call Close() on the stream first, then you can call Reset() on
///   it, to use it again on another stream.
/// </remarks>
///
/// <param name="stream">
///   The new output stream for this era.
/// </param>
///
/// <example>
/// <code>
/// ParallelDeflateOutputStream deflater = null;
/// foreach (var inputFile in listOfFiles)
/// {
///     string outputFile = inputFile + ".compressed";
///     using (System.IO.Stream input = System.IO.File.OpenRead(inputFile))
///     {
///         using (var outStream = System.IO.File.Create(outputFile))
///         {
///             if (deflater == null)
///                 deflater = new ParallelDeflateOutputStream(outStream,
///                                                            CompressionLevel.Best,
///                                                            CompressionStrategy.Default,
///                                                            true);
///             deflater.Reset(outStream);
///
///             while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
///             {
///                 deflater.Write(buffer, 0, n);
///             }
///         }
///     }
/// }
/// </code>
/// </example>
// reset all status
// When combining parallel deflation with a ZipSegmentedStream, it's
// possible for the ZSS to throw from within this method.  In that
// case, Close/Dispose will be called on this stream, if this stream
// is employed within a using or try/finally pair as required. But
// this stream is unaware of the pending exception, so the Close()
// method invokes this method AGAIN.  This can lead to a deadlock.
// Therefore, failfast if re-entering.
// out of order. requeue and try again.
// We went around the list once.
// None of the items in the list is the one we want.
// Now wait for a compressor to signal again.
// don't wait next time through
// wait for the next session
// repeatedly write buffers as they become ready
// I've locked a workitem I cannot use.
// Therefore, wake someone else up, and then release the lock.
// wake up someone else
// release and wait
// Finish:
// After writing a series of buffers, closing each one with
// Flush.Sync, we now write the final one as Flush.Finish, and
// then stop.
// signal that writing is complete:
// expose the exception to the main thread
// compress one buffer
// calc CRC on the buffer
// deflate it
// update status
// expose the exception to the main thread
// step 1: deflate the buffer
// step 2: flush (sync)
// used only when Trace is defined
// enter _EmitPending
// begin to write out
// done writing out
// writer skipping a workitem
// All Emit flags
// constructor/disposer
// Close/Reset
// thread synchronization
// instance settings
// compress task
// filling buffers, when caller invokes Write()
// upon entry to Write()
// on _toFill.Take()
/// <summary>
/// Indicates whether the stream supports Seek operations.
/// </summary>
/// <remarks>
/// Always returns false.
/// </remarks>
/// <summary>
/// Indicates whether the stream supports Read operations.
/// </summary>
/// <remarks>
/// Always returns false.
/// </remarks>
/// <summary>
/// Indicates whether the stream supports Write operations.
/// </summary>
/// <remarks>
/// Returns true if the provided stream is writable.
/// </remarks>
/// <summary>
/// Reading this property always throws a NotSupportedException.
/// </summary>
/// <summary>
/// Returns the current position of the output stream.
/// </summary>
/// <remarks>
///   <para>
///     Because the output gets written by a background thread,
///     the value may change asynchronously.  Setting this
///     property always throws a NotSupportedException.
///   </para>
/// </remarks>
/// <summary>
/// This method always throws a NotSupportedException.
/// </summary>
/// <param name="buffer">
///   The buffer into which data would be read, IF THIS METHOD
///   ACTUALLY DID ANYTHING.
/// </param>
/// <param name="offset">
///   The offset within that data array at which to insert the
///   data that is read, IF THIS METHOD ACTUALLY DID
///   ANYTHING.
/// </param>
/// <param name="count">
///   The number of bytes to write, IF THIS METHOD ACTUALLY DID
///   ANYTHING.
/// </param>
/// <returns>nothing.</returns>
/// <summary>
/// This method always throws a NotSupportedException.
/// </summary>
/// <param name="offset">
///   The offset to seek to....
///   IF THIS METHOD ACTUALLY DID ANYTHING.
/// </param>
/// <param name="origin">
///   The reference specifying how to apply the offset....  IF
///   THIS METHOD ACTUALLY DID ANYTHING.
/// </param>
/// <returns>nothing. It always throws.</returns>
/// <summary>
/// This method always throws a NotSupportedException.
/// </summary>
/// <param name="value">
///   The new value for the stream length....  IF
///   THIS METHOD ACTUALLY DID ANYTHING.
/// </param>
// Tree.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009 Dino Chiesa and Microsoft Corporation.  
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License. 
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs): 
// Time-stamp: <2009-October-28 13:29:50>
//
// ------------------------------------------------------------------
//
// This module defines classes for zlib compression and
// decompression. This code is derived from the jzlib implementation of
// zlib. In keeping with the license for jzlib, the copyright to that
// code is below.
//
// ------------------------------------------------------------------
// 
// Copyright (c) 2000,2001,2002,2003 ymnk, JCraft,Inc. All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 
// 1. Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
// 
// 2. Redistributions in binary form must reproduce the above copyright 
// notice, this list of conditions and the following disclaimer in 
// the documentation and/or other materials provided with the distribution.
// 
// 3. The names of the authors may not be used to endorse or promote products
// derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
// FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
// INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 
// -----------------------------------------------------------------------
//
// This program is based on zlib-1.1.3; credit to authors
// Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
// and contributors of zlib.
//
// -----------------------------------------------------------------------
// extra bits for each length code
// extra bits for each distance code
// extra bits for each bit length code
// The lengths of the bit length codes are sent in order of decreasing
// probability, to avoid transmitting the lengths for unused bit
// length codes.
// see definition of array dist_code below
//internal const int DIST_CODE_LEN = 512;
/// <summary>
/// Map from a distance to a distance code.
/// </summary>
/// <remarks> 
/// No side effects. _dist_code[256] and _dist_code[257] are never used.
/// </remarks>
// the dynamic tree
// largest code with non zero frequency
// the corresponding static tree
// Compute the optimal bit lengths for a tree and update the total bit length
// for the current block.
// IN assertion: the fields freq and dad are set, heap[heap_max] and
//    above are the tree nodes sorted by increasing frequency.
// OUT assertions: the field len is set to the optimal bit length, the
//     array bl_count contains the frequencies for each bit length.
//     The length opt_len is updated; static_len is also updated if stree is
//     not null.
// heap index
// iterate over the tree elements
// bit length
// extra bits
// frequency
// number of elements with bit length too large
// In a first pass, compute the optimal bit lengths (which may
// overflow in the case of the bit length tree).
// root of the heap
// We overwrite tree[n*2+1] which is no longer needed
// not a leaf node
// This happens for example on obj2 and pic of the Calgary corpus
// Find the first bit length which could increase:
// move one leaf down the tree
// move one overflow item as its brother
// The brother of the overflow item also moves one step up,
// but this does not affect bl_count[max_length]
// Construct one Huffman tree and assigns the code bit strings and lengths.
// Update the total bit length for the current block.
// IN assertion: the field freq is set for all tree elements.
// OUT assertions: the fields len and code are set to the optimal bit length
//     and corresponding code. The length opt_len is updated; static_len is
//     also updated if stree is not null. The field max_code is set.
// iterate over heap elements
// largest code with non zero frequency
// new node being created
// Construct the initial heap, with least frequent element in
// heap[1]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
// heap[0] is not used.
// The pkzip format requires that at least one distance code exists,
// and that at least one bit should be sent even if there is only one
// possible code. So to avoid special checks later on we force at least
// two codes of non zero frequency.
// node is 0 or 1 so it does not have extra bits
// The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
// establish sub-heaps of increasing lengths:
// Construct the Huffman tree by repeatedly combining the least two
// frequent nodes.
// next internal node of the tree
// n = node of least frequency
// m = node of next least frequency
// keep the nodes sorted by frequency
// Create a new node father of n and m
// and insert the new node in the heap
// At this point, the fields freq and dad are set. We can now
// generate the bit lengths.
// The field len is now set, we can generate the bit codes
// Generate the codes for a given tree and bit counts (which need not be
// optimal).
// IN assertion: the array bl_count contains the bit length statistics for
// the given tree and the field len is set for all tree elements.
// OUT assertion: the field code is set for all tree elements of non
//     zero code length.
// next code value for each bit length
// running code value
// bit index
// code index
// The distribution counts are first used to generate the code values
// without bit reversal.
// Check that the bit counts in bl_count are consistent. The last code
// must be all ones.
//Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
//        "inconsistent bit counts");
//Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
// Now reverse the bits
// Reverse the first len bits of a code, using straightforward code (a faster
// method would use a table)
// IN assertion: 1 <= len <= 15
//SharedUtils.URShift(code, 1);
// Zlib.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009-2011 Dino Chiesa and Microsoft Corporation.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// Last Saved: <2011-August-03 19:52:28>
//
// ------------------------------------------------------------------
//
// This module defines classes for ZLIB compression and
// decompression. This code is derived from the jzlib implementation of
// zlib, but significantly modified.  The object model is not the same,
// and many of the behaviors are new or different.  Nonetheless, in
// keeping with the license for jzlib, the copyright to that code is
// included below.
//
// ------------------------------------------------------------------
//
// The following notice applies to jzlib:
//
// Copyright (c) 2000,2001,2002,2003 ymnk, JCraft,Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in
// the documentation and/or other materials provided with the distribution.
//
// 3. The names of the authors may not be used to endorse or promote products
// derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
// FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
// INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// -----------------------------------------------------------------------
//
// jzlib is based on zlib-1.1.3.
//
// The following notice applies to zlib:
//
// -----------------------------------------------------------------------
//
// Copyright (C) 1995-2004 Jean-loup Gailly and Mark Adler
//
//   The ZLIB software is provided 'as-is', without any express or implied
//   warranty.  In no event will the authors be held liable for any damages
//   arising from the use of this software.
//
//   Permission is granted to anyone to use this software for any purpose,
//   including commercial applications, and to alter it and redistribute it
//   freely, subject to the following restrictions:
//
//   1. The origin of this software must not be misrepresented; you must not
//      claim that you wrote the original software. If you use this software
//      in a product, an acknowledgment in the product documentation would be
//      appreciated but is not required.
//   2. Altered source versions must be plainly marked as such, and must not be
//      misrepresented as being the original software.
//   3. This notice may not be removed or altered from any source distribution.
//
//   Jean-loup Gailly jloup@gzip.org
//   Mark Adler madler@alumni.caltech.edu
//
// -----------------------------------------------------------------------
/// <summary>
/// Describes how to flush the current deflate operation.
/// </summary>
/// <remarks>
/// The different FlushType values are useful when using a Deflate in a streaming application.
/// </remarks>
/// <summary>No flush at all.</summary>
/// <summary>Closes the current block, but doesn't flush it to
/// the output. Used internally only in hypothetical
/// scenarios.  This was supposed to be removed by Zlib, but it is
/// still in use in some edge cases.
/// </summary>
/// <summary>
/// Use this during compression to specify that all pending output should be
/// flushed to the output buffer and the output should be aligned on a byte
/// boundary.  You might use this in a streaming communication scenario, so that
/// the decompressor can get all input data available so far.  When using this
/// with a ZlibCodec, <c>AvailableBytesIn</c> will be zero after the call if
/// enough output space has been provided before the call.  Flushing will
/// degrade compression and so it should be used only when necessary.
/// </summary>
/// <summary>
/// Use this during compression to specify that all output should be flushed, as
/// with <c>FlushType.Sync</c>, but also, the compression state should be reset
/// so that decompression can restart from this point if previous compressed
/// data has been damaged or if random access is desired.  Using
/// <c>FlushType.Full</c> too often can significantly degrade the compression.
/// </summary>
/// <summary>Signals the end of the compression/decompression stream.</summary>
/// <summary>
/// The compression level to be used when using a DeflateStream or ZlibStream with CompressionMode.Compress.
/// </summary>
/// <summary>
/// None means that the data will be simply stored, with no change at all.
/// If you are producing ZIPs for use on Mac OSX, be aware that archives produced with CompressionLevel.None
/// cannot be opened with the default zip reader. Use a different CompressionLevel.
/// </summary>
/// <summary>
/// Same as None.
/// </summary>
/// <summary>
/// The fastest but least effective compression.
/// </summary>
/// <summary>
/// A synonym for BestSpeed.
/// </summary>
/// <summary>
/// A little slower, but better, than level 1.
/// </summary>
/// <summary>
/// A little slower, but better, than level 2.
/// </summary>
/// <summary>
/// A little slower, but better, than level 3.
/// </summary>
/// <summary>
/// A little slower than level 4, but with better compression.
/// </summary>
/// <summary>
/// The default compression level, with a good balance of speed and compression efficiency.
/// </summary>
/// <summary>
/// A synonym for Default.
/// </summary>
/// <summary>
/// Pretty good compression!
/// </summary>
/// <summary>
///  Better compression than Level7!
/// </summary>
/// <summary>
/// The "best" compression, where best means greatest reduction in size of the input data stream.
/// This is also the slowest compression.
/// </summary>
/// <summary>
/// A synonym for BestCompression.
/// </summary>
/// <summary>
/// Describes options for how the compression algorithm is executed.  Different strategies
/// work better on different sorts of data.  The strategy parameter can affect the compression
/// ratio and the speed of compression but not the correctness of the compresssion.
/// </summary>
/// <summary>
/// The default strategy is probably the best for normal data.
/// </summary>
/// <summary>
/// The <c>Filtered</c> strategy is intended to be used most effectively with data produced by a
/// filter or predictor.  By this definition, filtered data consists mostly of small
/// values with a somewhat random distribution.  In this case, the compression algorithm
/// is tuned to compress them better.  The effect of <c>Filtered</c> is to force more Huffman
/// coding and less string matching; it is a half-step between <c>Default</c> and <c>HuffmanOnly</c>.
/// </summary>
/// <summary>
/// Using <c>HuffmanOnly</c> will force the compressor to do Huffman encoding only, with no
/// string matching.
/// </summary>
/// <summary>
/// An enum to specify the direction of transcoding - whether to compress or decompress.
/// </summary>
/// <summary>
/// Used to specify that the stream should compress the data.
/// </summary>
/// <summary>
/// Used to specify that the stream should decompress the data.
/// </summary>
/// <summary>
/// A general purpose exception class for exceptions in the Zlib library.
/// </summary>
/// <summary>
/// The ZlibException class captures exception information generated
/// by the Zlib library.
/// </summary>
/// <summary>
/// This ctor collects a message attached to the exception.
/// </summary>
/// <param name="s">the message for the exception.</param>
/// <summary>
/// Performs an unsigned bitwise right shift with the specified number
/// </summary>
/// <param name="number">Number to operate on</param>
/// <param name="bits">Ammount of bits to shift</param>
/// <returns>The resulting number from the shift operation</returns>
/// <summary>
/// Performs an unsigned bitwise right shift with the specified number
/// </summary>
/// <param name="number">Number to operate on</param>
/// <param name="bits">Ammount of bits to shift</param>
/// <returns>The resulting number from the shift operation</returns>
/// <summary>
///   Reads a number of characters from the current source TextReader and writes
///   the data to the target array at the specified index.
/// </summary>
///
/// <param name="sourceTextReader">The source TextReader to read from</param>
/// <param name="target">Contains the array of characteres read from the source TextReader.</param>
/// <param name="start">The starting index of the target array.</param>
/// <param name="count">The maximum number of characters to read from the source TextReader.</param>
///
/// <returns>
///   The number of characters read. The number will be less than or equal to
///   count depending on the data available in the source TextReader. Returns -1
///   if the end of the stream is reached.
/// </returns>
// Returns 0 bytes if not enough space in target
// Returns -1 if EOF
// Bit length codes must not exceed MAX_BL_BITS bits
// repeat previous bit length 3-6 times (2 bits of repeat count)
// repeat a zero length 3-10 times  (3 bits of repeat count)
// repeat a zero length 11-138 times  (7 bits of repeat count)
// static tree or null
// extra bits for each code or null
// base index for extra_bits
// max number of elements in the tree
// max bit length for the codes
/// <summary>
/// Computes an Adler-32 checksum.
/// </summary>
/// <remarks>
/// The Adler checksum is similar to a CRC checksum, but faster to compute, though less
/// reliable.  It is used in producing RFC1950 compressed streams.  The Adler checksum
/// is a required part of the "ZLIB" standard.  Applications will almost never need to
/// use this class directly.
/// </remarks>
///
/// <exclude/>
// largest prime smaller than 65536
// NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1
/// <summary>
///   Calculates the Adler32 checksum.
/// </summary>
/// <remarks>
///   <para>
///     This is used within ZLIB.  You probably don't need to use this directly.
///   </para>
/// </remarks>
/// <example>
///    To compute an Adler32 checksum on a byte array:
///  <code>
///    var adler = Adler.Adler32(0, null, 0, 0);
///    adler = Adler.Adler32(adler, buffer, index, length);
///  </code>
/// </example>
//s1 += (buf[index++] & 0xff); s2 += s1;
// ZlibBaseStream.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009 Dino Chiesa and Microsoft Corporation.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-August-06 21:22:38>
//
// ------------------------------------------------------------------
//
// This module defines the ZlibBaseStream class, which is an intnernal
// base class for DeflateStream, ZlibStream and GZipStream.
//
// ------------------------------------------------------------------
// deferred init... new ZlibCodec();
// workitem 7159
//this._workingBuffer = new byte[WORKING_BUFFER_SIZE_DEFAULT];
// workitem 7159
// workitem 7159
// calculate the CRC on the unccompressed data  (before writing)
// first reference of z property will initialize the private var _z
//if (_workingBuffer.Length - _z.AvailableBytesOut > 0)
// If GZIP and de-compress, we're done when 8 bytes remain.
// If GZIP and de-compress, we're done when 8 bytes remain.
// workitem 7159
// Emit the GZIP trailer: CRC32 and  size mod 2^32
// workitem 7159
// workitem 8501: handle edge case (decompress empty stream)
// Read and potentially verify the GZIP trailer:
// CRC32 and size mod 2^32
// workitems 8679 & 12554
// Make sure we have read to the end of the stream
//_outStream.Seek(offset, origin);
// calculate CRC after reading
// workitem 7740
// read the header on the first read
// workitem 8501: handle edge case (decompress empty stream)
// read and discard extra field
// 2-byte length field
// CRC16, ignore
// According to MS documentation, any implementation of the IO.Stream.Read function must:
// (a) throw an exception if offset & count reference an invalid part of the buffer,
//     or if count < 0, or if buffer is null
// (b) return 0 only upon EOF, or if count = 0
// (c) if not EOF, then return at least 1 byte, up to <count> bytes
// for the first read, set up some controls.
// (The first reference to _z goes through the private accessor which
// may initialize it.)
// workitem 8501: handle edge case (decompress empty stream)
// workitem 8557
// set up the output of the deflate/inflate codec:
// This is necessary in case _workingBuffer has been resized. (new byte[])
// (The first reference to _workingBuffer goes through the private accessor which
// may initialize it.)
// need data in _workingBuffer in order to deflate/inflate.  Here, we check if we have any.
// No data available, so try to Read data from the captive stream.
// we have data in InputBuffer; now compress or decompress as appropriate
// nothing more to read
//while (_z.AvailableBytesOut == count && rc == ZlibConstants.Z_OK);
// workitem 8557
// is there more room in output?
// deferred
// are we completely done reading?
// and in compression?
// no more input data available; therefore we flush to
// try to complete the read
// calculate CRC after reading
// workitem 8460
// workitem 8460
// reset to allow read from start
// workitem 8460
// ZlibCodec.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009 Dino Chiesa and Microsoft Corporation.  
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License. 
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs): 
// Time-stamp: <2009-November-03 15:40:51>
//
// ------------------------------------------------------------------
//
// This module defines a Codec for ZLIB compression and
// decompression. This code extends code that was based the jzlib
// implementation of zlib, but this code is completely novel.  The codec
// class is new, and encapsulates some behaviors that are new, and some
// that were present in other classes in the jzlib code base.  In
// keeping with the license for jzlib, the copyright to the jzlib code
// is included below.
//
// ------------------------------------------------------------------
// 
// Copyright (c) 2000,2001,2002,2003 ymnk, JCraft,Inc. All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 
// 1. Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
// 
// 2. Redistributions in binary form must reproduce the above copyright 
// notice, this list of conditions and the following disclaimer in 
// the documentation and/or other materials provided with the distribution.
// 
// 3. The names of the authors may not be used to endorse or promote products
// derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
// FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
// INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 
// -----------------------------------------------------------------------
//
// This program is based on zlib-1.1.3; credit to authors
// Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
// and contributors of zlib.
//
// -----------------------------------------------------------------------
/// <summary>
/// Encoder and Decoder for ZLIB and DEFLATE (IETF RFC1950 and RFC1951).
/// </summary>
///
/// <remarks>
/// This class compresses and decompresses data according to the Deflate algorithm
/// and optionally, the ZLIB format, as documented in <see
/// href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950 - ZLIB</see> and <see
/// href="http://www.ietf.org/rfc/rfc1951.txt">RFC 1951 - DEFLATE</see>.
/// </remarks>
/// <summary>
/// The buffer from which data is taken.
/// </summary>
/// <summary>
/// An index into the InputBuffer array, indicating where to start reading. 
/// </summary>
/// <summary>
/// The number of bytes available in the InputBuffer, starting at NextIn. 
/// </summary>
/// <remarks>
/// Generally you should set this to InputBuffer.Length before the first Inflate() or Deflate() call. 
/// The class will update this number as calls to Inflate/Deflate are made.
/// </remarks>
/// <summary>
/// Total number of bytes read so far, through all calls to Inflate()/Deflate().
/// </summary>
/// <summary>
/// Buffer to store output data.
/// </summary>
/// <summary>
/// An index into the OutputBuffer array, indicating where to start writing. 
/// </summary>
/// <summary>
/// The number of bytes available in the OutputBuffer, starting at NextOut. 
/// </summary>
/// <remarks>
/// Generally you should set this to OutputBuffer.Length before the first Inflate() or Deflate() call. 
/// The class will update this number as calls to Inflate/Deflate are made.
/// </remarks>
/// <summary>
/// Total number of bytes written to the output so far, through all calls to Inflate()/Deflate().
/// </summary>
/// <summary>
/// used for diagnostics, when something goes wrong!
/// </summary>
/// <summary>
/// The compression level to use in this codec.  Useful only in compression mode.
/// </summary>
/// <summary>
/// The number of Window Bits to use.  
/// </summary>
/// <remarks>
/// This gauges the size of the sliding window, and hence the 
/// compression effectiveness as well as memory consumption. It's best to just leave this 
/// setting alone if you don't know what it is.  The maximum value is 15 bits, which implies
/// a 32k window.  
/// </remarks>
/// <summary>
/// The compression strategy to use.
/// </summary>
/// <remarks>
/// This is only effective in compression.  The theory offered by ZLIB is that different
/// strategies could potentially produce significant differences in compression behavior
/// for different data sets.  Unfortunately I don't have any good recommendations for how
/// to set it differently.  When I tested changing the strategy I got minimally different
/// compression performance. It's best to leave this property alone if you don't have a
/// good feel for it.  Or, you may want to produce a test harness that runs through the
/// different strategy options and evaluates them on different file types. If you do that,
/// let me know your results.
/// </remarks>
/// <summary>
/// The Adler32 checksum on the data transferred through the codec so far. You probably don't need to look at this.
/// </summary>
/// <summary>
/// Create a ZlibCodec.
/// </summary>
/// <remarks>
/// If you use this default constructor, you will later have to explicitly call 
/// InitializeInflate() or InitializeDeflate() before using the ZlibCodec to compress 
/// or decompress. 
/// </remarks>
/// <summary>
/// Create a ZlibCodec that either compresses or decompresses.
/// </summary>
/// <param name="mode">
/// Indicates whether the codec should compress (deflate) or decompress (inflate).
/// </param>
/// <summary>
/// Initialize the inflation state. 
/// </summary>
/// <remarks>
/// It is not necessary to call this before using the ZlibCodec to inflate data; 
/// It is implicitly called when you call the constructor.
/// </remarks>
/// <returns>Z_OK if everything goes well.</returns>
/// <summary>
/// Initialize the inflation state with an explicit flag to
/// govern the handling of RFC1950 header bytes.
/// </summary>
///
/// <remarks>
/// By default, the ZLIB header defined in <see
/// href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950</see> is expected.  If
/// you want to read a zlib stream you should specify true for
/// expectRfc1950Header.  If you have a deflate stream, you will want to specify
/// false. It is only necessary to invoke this initializer explicitly if you
/// want to specify false.
/// </remarks>
///
/// <param name="expectRfc1950Header">whether to expect an RFC1950 header byte
/// pair when reading the stream of data to be inflated.</param>
///
/// <returns>Z_OK if everything goes well.</returns>
/// <summary>
/// Initialize the ZlibCodec for inflation, with the specified number of window bits. 
/// </summary>
/// <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
/// then you shouldn't be calling this initializer.</param>
/// <returns>Z_OK if all goes well.</returns>
/// <summary>
/// Initialize the inflation state with an explicit flag to govern the handling of
/// RFC1950 header bytes. 
/// </summary>
///
/// <remarks>
/// If you want to read a zlib stream you should specify true for
/// expectRfc1950Header. In this case, the library will expect to find a ZLIB
/// header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
/// 1950</see>, in the compressed stream.  If you will be reading a DEFLATE or
/// GZIP stream, which does not have such a header, you will want to specify
/// false.
/// </remarks>
///
/// <param name="expectRfc1950Header">whether to expect an RFC1950 header byte pair when reading 
/// the stream of data to be inflated.</param>
/// <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
/// then you shouldn't be calling this initializer.</param>
/// <returns>Z_OK if everything goes well.</returns>
/// <summary>
/// Inflate the data in the InputBuffer, placing the result in the OutputBuffer.
/// </summary>
/// <remarks>
/// You must have set InputBuffer and OutputBuffer, NextIn and NextOut, and AvailableBytesIn and 
/// AvailableBytesOut  before calling this method.
/// </remarks>
/// <example>
/// <code>
/// private void InflateBuffer()
/// {
///     int bufferSize = 1024;
///     byte[] buffer = new byte[bufferSize];
///     ZlibCodec decompressor = new ZlibCodec();
/// 
///     Console.WriteLine("\n============================================");
///     Console.WriteLine("Size of Buffer to Inflate: {0} bytes.", CompressedBytes.Length);
///     MemoryStream ms = new MemoryStream(DecompressedBytes);
/// 
///     int rc = decompressor.InitializeInflate();
/// 
///     decompressor.InputBuffer = CompressedBytes;
///     decompressor.NextIn = 0;
///     decompressor.AvailableBytesIn = CompressedBytes.Length;
/// 
///     decompressor.OutputBuffer = buffer;
/// 
///     // pass 1: inflate 
///     do
///     {
///         decompressor.NextOut = 0;
///         decompressor.AvailableBytesOut = buffer.Length;
///         rc = decompressor.Inflate(FlushType.None);
/// 
///         if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
///             throw new Exception("inflating: " + decompressor.Message);
/// 
///         ms.Write(decompressor.OutputBuffer, 0, buffer.Length - decompressor.AvailableBytesOut);
///     }
///     while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
/// 
///     // pass 2: finish and flush
///     do
///     {
///         decompressor.NextOut = 0;
///         decompressor.AvailableBytesOut = buffer.Length;
///         rc = decompressor.Inflate(FlushType.Finish);
/// 
///         if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
///             throw new Exception("inflating: " + decompressor.Message);
/// 
///         if (buffer.Length - decompressor.AvailableBytesOut &gt; 0)
///             ms.Write(buffer, 0, buffer.Length - decompressor.AvailableBytesOut);
///     }
///     while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
/// 
///     decompressor.EndInflate();
/// }
///
/// </code>
/// </example>
/// <param name="flush">The flush to use when inflating.</param>
/// <returns>Z_OK if everything goes well.</returns>
/// <summary>
/// Ends an inflation session. 
/// </summary>
/// <remarks>
/// Call this after successively calling Inflate().  This will cause all buffers to be flushed. 
/// After calling this you cannot call Inflate() without a intervening call to one of the
/// InitializeInflate() overloads.
/// </remarks>
/// <returns>Z_OK if everything goes well.</returns>
/// <summary>
/// I don't know what this does!
/// </summary>
/// <returns>Z_OK if everything goes well.</returns>
/// <summary>
/// Initialize the ZlibCodec for deflation operation.
/// </summary>
/// <remarks>
/// The codec will use the MAX window bits and the default level of compression.
/// </remarks>
/// <example>
/// <code>
///  int bufferSize = 40000;
///  byte[] CompressedBytes = new byte[bufferSize];
///  byte[] DecompressedBytes = new byte[bufferSize];
///  
///  ZlibCodec compressor = new ZlibCodec();
///  
///  compressor.InitializeDeflate(CompressionLevel.Default);
///  
///  compressor.InputBuffer = System.Text.ASCIIEncoding.ASCII.GetBytes(TextToCompress);
///  compressor.NextIn = 0;
///  compressor.AvailableBytesIn = compressor.InputBuffer.Length;
///  
///  compressor.OutputBuffer = CompressedBytes;
///  compressor.NextOut = 0;
///  compressor.AvailableBytesOut = CompressedBytes.Length;
///  
///  while (compressor.TotalBytesIn != TextToCompress.Length &amp;&amp; compressor.TotalBytesOut &lt; bufferSize)
///  {
///    compressor.Deflate(FlushType.None);
///  }
///  
///  while (true)
///  {
///    int rc= compressor.Deflate(FlushType.Finish);
///    if (rc == ZlibConstants.Z_STREAM_END) break;
///  }
///  
///  compressor.EndDeflate();
///   
/// </code>
/// </example>
/// <returns>Z_OK if all goes well. You generally don't need to check the return code.</returns>
/// <summary>
/// Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel.
/// </summary>
/// <remarks>
/// The codec will use the maximum window bits (15) and the specified
/// CompressionLevel.  It will emit a ZLIB stream as it compresses.
/// </remarks>
/// <param name="level">The compression level for the codec.</param>
/// <returns>Z_OK if all goes well.</returns>
/// <summary>
/// Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
/// and the explicit flag governing whether to emit an RFC1950 header byte pair.
/// </summary>
/// <remarks>
/// The codec will use the maximum window bits (15) and the specified CompressionLevel.
/// If you want to generate a zlib stream, you should specify true for
/// wantRfc1950Header. In this case, the library will emit a ZLIB
/// header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
/// 1950</see>, in the compressed stream.  
/// </remarks>
/// <param name="level">The compression level for the codec.</param>
/// <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
/// <returns>Z_OK if all goes well.</returns>
/// <summary>
/// Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
/// and the specified number of window bits. 
/// </summary>
/// <remarks>
/// The codec will use the specified number of window bits and the specified CompressionLevel.
/// </remarks>
/// <param name="level">The compression level for the codec.</param>
/// <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
/// <returns>Z_OK if all goes well.</returns>
/// <summary>
/// Initialize the ZlibCodec for deflation operation, using the specified
/// CompressionLevel, the specified number of window bits, and the explicit flag
/// governing whether to emit an RFC1950 header byte pair.
/// </summary>
///
/// <param name="level">The compression level for the codec.</param>
/// <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
/// <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
/// <returns>Z_OK if all goes well.</returns>
/// <summary>
/// Deflate one batch of data.
/// </summary>
/// <remarks>
/// You must have set InputBuffer and OutputBuffer before calling this method.
/// </remarks>
/// <example>
/// <code>
/// private void DeflateBuffer(CompressionLevel level)
/// {
///     int bufferSize = 1024;
///     byte[] buffer = new byte[bufferSize];
///     ZlibCodec compressor = new ZlibCodec();
/// 
///     Console.WriteLine("\n============================================");
///     Console.WriteLine("Size of Buffer to Deflate: {0} bytes.", UncompressedBytes.Length);
///     MemoryStream ms = new MemoryStream();
/// 
///     int rc = compressor.InitializeDeflate(level);
/// 
///     compressor.InputBuffer = UncompressedBytes;
///     compressor.NextIn = 0;
///     compressor.AvailableBytesIn = UncompressedBytes.Length;
/// 
///     compressor.OutputBuffer = buffer;
/// 
///     // pass 1: deflate 
///     do
///     {
///         compressor.NextOut = 0;
///         compressor.AvailableBytesOut = buffer.Length;
///         rc = compressor.Deflate(FlushType.None);
/// 
///         if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
///             throw new Exception("deflating: " + compressor.Message);
/// 
///         ms.Write(compressor.OutputBuffer, 0, buffer.Length - compressor.AvailableBytesOut);
///     }
///     while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
/// 
///     // pass 2: finish and flush
///     do
///     {
///         compressor.NextOut = 0;
///         compressor.AvailableBytesOut = buffer.Length;
///         rc = compressor.Deflate(FlushType.Finish);
/// 
///         if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
///             throw new Exception("deflating: " + compressor.Message);
/// 
///         if (buffer.Length - compressor.AvailableBytesOut &gt; 0)
///             ms.Write(buffer, 0, buffer.Length - compressor.AvailableBytesOut);
///     }
///     while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
/// 
///     compressor.EndDeflate();
/// 
///     ms.Seek(0, SeekOrigin.Begin);
///     CompressedBytes = new byte[compressor.TotalBytesOut];
///     ms.Read(CompressedBytes, 0, CompressedBytes.Length);
/// }
/// </code>
/// </example>
/// <param name="flush">whether to flush all data as you deflate. Generally you will want to 
/// use Z_NO_FLUSH here, in a series of calls to Deflate(), and then call EndDeflate() to 
/// flush everything. 
/// </param>
/// <returns>Z_OK if all goes well.</returns>
/// <summary>
/// End a deflation session.
/// </summary>
/// <remarks>
/// Call this after making a series of one or more calls to Deflate(). All buffers are flushed.
/// </remarks>
/// <returns>Z_OK if all goes well.</returns>
// TODO: dinoch Tue, 03 Nov 2009  15:39 (test this)
//int ret = dstate.End();
//ret;
/// <summary>
/// Reset a codec for another deflation session.
/// </summary>
/// <remarks>
/// Call this to reset the deflation state.  For example if a thread is deflating
/// non-consecutive blocks, you can call Reset() after the Deflate(Sync) of the first
/// block and before the next Deflate(None) of the second block.
/// </remarks>
/// <returns>Z_OK if all goes well.</returns>
/// <summary>
/// Set the CompressionStrategy and CompressionLevel for a deflation session.
/// </summary>
/// <param name="level">the level of compression to use.</param>
/// <param name="strategy">the strategy to use for compression.</param>
/// <returns>Z_OK if all goes well.</returns>
/// <summary>
/// Set the dictionary to be used for either Inflation or Deflation.
/// </summary>
/// <param name="dictionary">The dictionary bytes to use.</param>
/// <returns>Z_OK if all goes well.</returns>
/// <summary>
/// Set the dictionary to be used for either Inflation or Deflation unconditionally.
/// </summary>
/// <remarks>Decoding a MSZip file requires the dictionary state to be set unconditionally
/// at the end of each block to the previous decoded data</remarks>
/// <param name="dictionary">The dictionary bytes to use.</param>
/// <returns>Z_OK if all goes well.</returns>
// Flush as much pending output as possible. All deflate() output goes
// through this function so some applications may wish to modify it
// to avoid allocating a large strm->next_out buffer and copying into it.
// (See also read_buf()).
// Read a new buffer from the current input stream, update the adler32
// and total number of bytes read.  All deflate() input goes through
// this function so some applications may wish to modify it to avoid
// allocating a large strm->next_in buffer and copying from it.
// (See also flush_pending()).
// ZlibConstants.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009 Dino Chiesa and Microsoft Corporation.  
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License. 
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs): 
// Time-stamp: <2009-November-03 18:50:19>
//
// ------------------------------------------------------------------
//
// This module defines constants used by the zlib class library.  This
// code is derived from the jzlib implementation of zlib, but
// significantly modified.  In keeping with the license for jzlib, the
// copyright to that code is included here.
//
// ------------------------------------------------------------------
// 
// Copyright (c) 2000,2001,2002,2003 ymnk, JCraft,Inc. All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 
// 1. Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
// 
// 2. Redistributions in binary form must reproduce the above copyright 
// notice, this list of conditions and the following disclaimer in 
// the documentation and/or other materials provided with the distribution.
// 
// 3. The names of the authors may not be used to endorse or promote products
// derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
// FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
// INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 
// -----------------------------------------------------------------------
//
// This program is based on zlib-1.1.3; credit to authors
// Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
// and contributors of zlib.
//
// -----------------------------------------------------------------------
/// <summary>
/// A bunch of constants used in the Zlib interface.
/// </summary>
/// <summary>
/// The maximum number of window bits for the Deflate algorithm.
/// </summary>
// 32K LZ77 window
/// <summary>
/// The default number of window bits for the Deflate algorithm.
/// </summary>
/// <summary>
/// indicates everything is A-OK
/// </summary>
/// <summary>
/// Indicates that the last operation reached the end of the stream.
/// </summary>
/// <summary>
/// The operation ended in need of a dictionary. 
/// </summary>
/// <summary>
/// There was an error with the stream - not enough data, not open and readable, etc.
/// </summary>
/// <summary>
/// There was an error with the data - not enough data, bad data, etc.
/// </summary>
/// <summary>
/// There was an error with the working buffer.
/// </summary>
/// <summary>
/// The size of the working buffer used in the ZlibCodec class.
/// </summary>
/// <summary>
/// The minimum size of the working buffer used in the ZlibCodec class.
/// </summary>
// ZlibStream.cs
// ------------------------------------------------------------------
//
// Copyright (c) 2009 Dino Chiesa and Microsoft Corporation.
// All rights reserved.
//
// This code module is part of DotNetZip, a zipfile class library.
//
// ------------------------------------------------------------------
//
// This code is licensed under the Microsoft Public License.
// See the file License.txt for the license details.
// More info on: http://dotnetzip.codeplex.com
//
// ------------------------------------------------------------------
//
// last saved (in emacs):
// Time-stamp: <2011-July-31 14:53:33>
//
// ------------------------------------------------------------------
//
// This module defines the ZlibStream class, which is similar in idea to
// the System.IO.Compression.DeflateStream and
// System.IO.Compression.GZipStream classes in the .NET BCL.
//
// ------------------------------------------------------------------
/// <summary>
/// Represents a Zlib stream for compression or decompression.
/// </summary>
/// <remarks>
///
/// <para>
/// The ZlibStream is a <see
/// href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a <see
/// cref="System.IO.Stream"/>.  It adds ZLIB compression or decompression to any
/// stream.
/// </para>
///
/// <para> Using this stream, applications can compress or decompress data via
/// stream <c>Read()</c> and <c>Write()</c> operations.  Either compresssion or
/// decompression can occur through either reading or writing. The compression
/// format used is ZLIB, which is documented in <see
/// href="http://www.ietf.org/rfc/rfc1950.txt">IETF RFC 1950</see>, "ZLIB Compressed
/// Data Format Specification version 3.3". This implementation of ZLIB always uses
/// DEFLATE as the compression method.  (see <see
/// href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC 1951</see>, "DEFLATE
/// Compressed Data Format Specification version 1.3.") </para>
///
/// <para>
/// The ZLIB format allows for varying compression methods, window sizes, and dictionaries.
/// This implementation always uses the DEFLATE compression method, a preset dictionary,
/// and 15 window bits by default.
/// </para>
///
/// <para>
/// This class is similar to <see cref="DeflateStream"/>, except that it adds the
/// RFC1950 header and trailer bytes to a compressed stream when compressing, or expects
/// the RFC1950 header and trailer bytes when decompressing.  It is also similar to the
/// <see cref="GZipStream"/>.
/// </para>
/// </remarks>
/// <seealso cref="DeflateStream" />
/// <seealso cref="GZipStream" />
/// <summary>
/// Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c>.
/// </summary>
/// <remarks>
///
/// <para>
///   When mode is <c>CompressionMode.Compress</c>, the <c>ZlibStream</c>
///   will use the default compression level. The "captive" stream will be
///   closed when the <c>ZlibStream</c> is closed.
/// </para>
///
/// </remarks>
///
/// <example>
/// This example uses a <c>ZlibStream</c> to compress a file, and writes the
/// compressed data to another file.
/// <code>
/// using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
/// {
///     using (var raw = System.IO.File.Create(fileToCompress + ".zlib"))
///     {
///         using (Stream compressor = new ZlibStream(raw, CompressionMode.Compress))
///         {
///             byte[] buffer = new byte[WORKING_BUFFER_SIZE];
///             int n;
///             while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
///             {
///                 compressor.Write(buffer, 0, n);
///             }
///         }
///     }
/// }
/// </code>
/// <code lang="VB">
/// Using input As Stream = File.OpenRead(fileToCompress)
///     Using raw As FileStream = File.Create(fileToCompress &amp; ".zlib")
///     Using compressor As Stream = New ZlibStream(raw, CompressionMode.Compress)
///         Dim buffer As Byte() = New Byte(4096) {}
///         Dim n As Integer = -1
///         Do While (n &lt;&gt; 0)
///             If (n &gt; 0) Then
///                 compressor.Write(buffer, 0, n)
///             End If
///             n = input.Read(buffer, 0, buffer.Length)
///         Loop
///     End Using
///     End Using
/// End Using
/// </code>
/// </example>
///
/// <param name="stream">The stream which will be read or written.</param>
/// <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
/// <summary>
///   Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c> and
///   the specified <c>CompressionLevel</c>.
/// </summary>
///
/// <remarks>
///
/// <para>
///   When mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored.
///   The "captive" stream will be closed when the <c>ZlibStream</c> is closed.
/// </para>
///
/// </remarks>
///
/// <example>
///   This example uses a <c>ZlibStream</c> to compress data from a file, and writes the
///   compressed data to another file.
///
/// <code>
/// using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
/// {
///     using (var raw = System.IO.File.Create(fileToCompress + ".zlib"))
///     {
///         using (Stream compressor = new ZlibStream(raw,
///                                                   CompressionMode.Compress,
///                                                   CompressionLevel.BestCompression))
///         {
///             byte[] buffer = new byte[WORKING_BUFFER_SIZE];
///             int n;
///             while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
///             {
///                 compressor.Write(buffer, 0, n);
///             }
///         }
///     }
/// }
/// </code>
///
/// <code lang="VB">
/// Using input As Stream = File.OpenRead(fileToCompress)
///     Using raw As FileStream = File.Create(fileToCompress &amp; ".zlib")
///         Using compressor As Stream = New ZlibStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
///             Dim buffer As Byte() = New Byte(4096) {}
///             Dim n As Integer = -1
///             Do While (n &lt;&gt; 0)
///                 If (n &gt; 0) Then
///                     compressor.Write(buffer, 0, n)
///                 End If
///                 n = input.Read(buffer, 0, buffer.Length)
///             Loop
///         End Using
///     End Using
/// End Using
/// </code>
/// </example>
///
/// <param name="stream">The stream to be read or written while deflating or inflating.</param>
/// <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
/// <param name="level">A tuning knob to trade speed for effectiveness.</param>
/// <summary>
///   Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c>, and
///   explicitly specify whether the captive stream should be left open after
///   Deflation or Inflation.
/// </summary>
///
/// <remarks>
///
/// <para>
///   When mode is <c>CompressionMode.Compress</c>, the <c>ZlibStream</c> will use
///   the default compression level.
/// </para>
///
/// <para>
///   This constructor allows the application to request that the captive stream
///   remain open after the deflation or inflation occurs.  By default, after
///   <c>Close()</c> is called on the stream, the captive stream is also
///   closed. In some cases this is not desired, for example if the stream is a
///   <see cref="System.IO.MemoryStream"/> that will be re-read after
///   compression.  Specify true for the <paramref name="leaveOpen"/> parameter to leave the stream
///   open.
/// </para>
///
/// <para>
/// See the other overloads of this constructor for example code.
/// </para>
///
/// </remarks>
///
/// <param name="stream">The stream which will be read or written. This is called the
/// "captive" stream in other places in this documentation.</param>
/// <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
/// <param name="leaveOpen">true if the application would like the stream to remain
/// open after inflation/deflation.</param>
/// <summary>
///   Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c>
///   and the specified <c>CompressionLevel</c>, and explicitly specify
///   whether the stream should be left open after Deflation or Inflation.
/// </summary>
///
/// <remarks>
///
/// <para>
///   This constructor allows the application to request that the captive
///   stream remain open after the deflation or inflation occurs.  By
///   default, after <c>Close()</c> is called on the stream, the captive
///   stream is also closed. In some cases this is not desired, for example
///   if the stream is a <see cref="System.IO.MemoryStream"/> that will be
///   re-read after compression.  Specify true for the <paramref
///   name="leaveOpen"/> parameter to leave the stream open.
/// </para>
///
/// <para>
///   When mode is <c>CompressionMode.Decompress</c>, the level parameter is
///   ignored.
/// </para>
///
/// </remarks>
///
/// <example>
///
/// This example shows how to use a ZlibStream to compress the data from a file,
/// and store the result into another file. The filestream remains open to allow
/// additional data to be written to it.
///
/// <code>
/// using (var output = System.IO.File.Create(fileToCompress + ".zlib"))
/// {
///     using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
///     {
///         using (Stream compressor = new ZlibStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, true))
///         {
///             byte[] buffer = new byte[WORKING_BUFFER_SIZE];
///             int n;
///             while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
///             {
///                 compressor.Write(buffer, 0, n);
///             }
///         }
///     }
///     // can write additional data to the output stream here
/// }
/// </code>
/// <code lang="VB">
/// Using output As FileStream = File.Create(fileToCompress &amp; ".zlib")
///     Using input As Stream = File.OpenRead(fileToCompress)
///         Using compressor As Stream = New ZlibStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, True)
///             Dim buffer As Byte() = New Byte(4096) {}
///             Dim n As Integer = -1
///             Do While (n &lt;&gt; 0)
///                 If (n &gt; 0) Then
///                     compressor.Write(buffer, 0, n)
///                 End If
///                 n = input.Read(buffer, 0, buffer.Length)
///             Loop
///         End Using
///     End Using
///     ' can write additional data to the output stream here.
/// End Using
/// </code>
/// </example>
///
/// <param name="stream">The stream which will be read or written.</param>
///
/// <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
///
/// <param name="leaveOpen">
/// true if the application would like the stream to remain open after
/// inflation/deflation.
/// </param>
///
/// <param name="level">
/// A tuning knob to trade speed for effectiveness. This parameter is
/// effective only when mode is <c>CompressionMode.Compress</c>.
/// </param>
/// <summary>
/// This property sets the flush behavior on the stream.
/// Sorry, though, not sure exactly how to describe all the various settings.
/// </summary>
/// <summary>
///   The size of the working buffer for the compression codec.
/// </summary>
///
/// <remarks>
/// <para>
///   The working buffer is used for all stream operations.  The default size is
///   1024 bytes. The minimum size is 128 bytes. You may get better performance
///   with a larger buffer.  Then again, you might not.  You would have to test
///   it.
/// </para>
///
/// <para>
///   Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
///   stream. If you try to set it afterwards, it will throw.
/// </para>
/// </remarks>
/// <summary> Returns the total number of bytes input so far.</summary>
/// <summary> Returns the total number of bytes output so far.</summary>
/// <summary>
///   Dispose the stream.
/// </summary>
/// <remarks>
///   <para>
///     This may or may not result in a <c>Close()</c> call on the captive
///     stream.  See the constructors that have a <c>leaveOpen</c> parameter
///     for more information.
///   </para>
///   <para>
///     This method may be invoked in two distinct scenarios.  If disposing
///     == true, the method has been called directly or indirectly by a
///     user's code, for example via the public Dispose() method. In this
///     case, both managed and unmanaged resources can be referenced and
///     disposed.  If disposing == false, the method has been called by the
///     runtime from inside the object finalizer and this method should not
///     reference other objects; in that case only unmanaged resources must
///     be referenced or disposed.
///   </para>
/// </remarks>
/// <param name="disposing">
///   indicates whether the Dispose method was invoked by user code.
/// </param>
/// <summary>
/// Indicates whether the stream can be read.
/// </summary>
/// <remarks>
/// The return value depends on whether the captive stream supports reading.
/// </remarks>
/// <summary>
/// Indicates whether the stream supports Seek operations.
/// </summary>
/// <remarks>
/// Always returns false.
/// </remarks>
/// <summary>
/// Indicates whether the stream can be written.
/// </summary>
/// <remarks>
/// The return value depends on whether the captive stream supports writing.
/// </remarks>
/// <summary>
/// Flush the stream.
/// </summary>
/// <summary>
/// Reading this property always throws a <see cref="NotSupportedException"/>.
/// </summary>
/// <summary>
///   The position of the stream pointer.
/// </summary>
///
/// <remarks>
///   Setting this property always throws a <see
///   cref="NotSupportedException"/>. Reading will return the total bytes
///   written out, if used in writing, or the total bytes read in, if used in
///   reading.  The count may refer to compressed bytes or uncompressed bytes,
///   depending on how you've used the stream.
/// </remarks>
/// <summary>
/// Read data from the stream.
/// </summary>
///
/// <remarks>
///
/// <para>
///   If you wish to use the <c>ZlibStream</c> to compress data while reading,
///   you can create a <c>ZlibStream</c> with <c>CompressionMode.Compress</c>,
///   providing an uncompressed data stream.  Then call <c>Read()</c> on that
///   <c>ZlibStream</c>, and the data read will be compressed.  If you wish to
///   use the <c>ZlibStream</c> to decompress data while reading, you can create
///   a <c>ZlibStream</c> with <c>CompressionMode.Decompress</c>, providing a
///   readable compressed data stream.  Then call <c>Read()</c> on that
///   <c>ZlibStream</c>, and the data will be decompressed as it is read.
/// </para>
///
/// <para>
///   A <c>ZlibStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but
///   not both.
/// </para>
///
/// </remarks>
///
/// <param name="buffer">
/// The buffer into which the read data should be placed.</param>
///
/// <param name="offset">
/// the offset within that data array to put the first byte read.</param>
///
/// <param name="count">the number of bytes to read.</param>
///
/// <returns>the number of bytes read</returns>
/// <summary>
/// Calling this method always throws a <see cref="NotSupportedException"/>.
/// </summary>
/// <param name="offset">
///   The offset to seek to....
///   IF THIS METHOD ACTUALLY DID ANYTHING.
/// </param>
/// <param name="origin">
///   The reference specifying how to apply the offset....  IF
///   THIS METHOD ACTUALLY DID ANYTHING.
/// </param>
///
/// <returns>nothing. This method always throws.</returns>
/// <summary>
/// Calling this method always throws a <see cref="NotSupportedException"/>.
/// </summary>
/// <param name="value">
///   The new value for the stream length....  IF
///   THIS METHOD ACTUALLY DID ANYTHING.
/// </param>
/// <summary>
/// Write data to the stream.
/// </summary>
///
/// <remarks>
///
/// <para>
///   If you wish to use the <c>ZlibStream</c> to compress data while writing,
///   you can create a <c>ZlibStream</c> with <c>CompressionMode.Compress</c>,
///   and a writable output stream.  Then call <c>Write()</c> on that
///   <c>ZlibStream</c>, providing uncompressed data as input.  The data sent to
///   the output stream will be the compressed form of the data written.  If you
///   wish to use the <c>ZlibStream</c> to decompress data while writing, you
///   can create a <c>ZlibStream</c> with <c>CompressionMode.Decompress</c>, and a
///   writable output stream.  Then call <c>Write()</c> on that stream,
///   providing previously compressed data. The data sent to the output stream
///   will be the decompressed form of the data written.
/// </para>
///
/// <para>
///   A <c>ZlibStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not both.
/// </para>
/// </remarks>
/// <param name="buffer">The buffer holding data to write to the stream.</param>
/// <param name="offset">the offset within that data array to find the first byte to write.</param>
/// <param name="count">the number of bytes to write.</param>
/// <summary>
///   Compress a string into a byte array using ZLIB.
/// </summary>
///
/// <remarks>
///   Uncompress it with <see cref="ZlibStream.UncompressString(byte[])"/>.
/// </remarks>
///
/// <seealso cref="ZlibStream.UncompressString(byte[])"/>
/// <seealso cref="ZlibStream.CompressBuffer(byte[])"/>
/// <seealso cref="GZipStream.CompressString(string)"/>
///
/// <param name="s">
///   A string to compress.  The string will first be encoded
///   using UTF8, then compressed.
/// </param>
///
/// <returns>The string in compressed form</returns>
/// <summary>
///   Compress a byte array into a new byte array using ZLIB.
/// </summary>
///
/// <remarks>
///   Uncompress it with <see cref="ZlibStream.UncompressBuffer(byte[])"/>.
/// </remarks>
///
/// <seealso cref="ZlibStream.CompressString(string)"/>
/// <seealso cref="ZlibStream.UncompressBuffer(byte[])"/>
///
/// <param name="b">
/// A buffer to compress.
/// </param>
///
/// <returns>The data in compressed form</returns>
/// <summary>
///   Uncompress a ZLIB-compressed byte array into a single string.
/// </summary>
///
/// <seealso cref="ZlibStream.CompressString(String)"/>
/// <seealso cref="ZlibStream.UncompressBuffer(byte[])"/>
///
/// <param name="compressed">
///   A buffer containing ZLIB-compressed data.
/// </param>
///
/// <returns>The uncompressed string</returns>
/// <summary>
///   Uncompress a ZLIB-compressed byte array into a byte array.
/// </summary>
///
/// <seealso cref="ZlibStream.CompressBuffer(byte[])"/>
/// <seealso cref="ZlibStream.UncompressString(byte[])"/>
///
/// <param name="compressed">
///   A buffer containing ZLIB-compressed data.
/// </param>
///
/// <returns>The data in uncompressed form</returns>
