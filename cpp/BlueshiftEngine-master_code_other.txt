________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\Android\AndroidPlayer\jni\dso_handle.c
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\JavaAndroid\AndroidPlayer\app\src\main\java\com\AndroidPlayer\AndroidPlayer.java
/*
//www.apache.org/licenses/LICENSE-2.0
//package com.android.gles3jni;
// Initialize the Mobile Ads SDK.
/* , APP_ID */);
//loadRewardedVideoAd();
//Toast.makeText(this, "onRewardedVideoAdClosed", Toast.LENGTH_SHORT).show();
// Preload the next video ad.
//loadRewardedVideoAd();
//Toast.makeText(this, "onRewardedVideoAdFailedToLoad", Toast.LENGTH_SHORT).show();
//Toast.makeText(this, "onRewardedVideoAdLoaded", Toast.LENGTH_SHORT).show();
//Toast.makeText(this, "onRewardedVideoAdOpened", Toast.LENGTH_SHORT).show();
//Toast.makeText(this,
//        String.format(" onRewarded! currency: %s amount: %d", reward.getType(),
//                reward.getAmount()),
//        Toast.LENGTH_SHORT).show();
//Toast.makeText(this, "onRewardedVideoStarted", Toast.LENGTH_SHORT).show();
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\JavaAndroid\AndroidPlayer\app\src\main\java\com\AndroidPlayer\GLES3JNILib.java
/*
//www.apache.org/licenses/LICENSE-2.0
//package com.android.gles3jni;
//import java.util.concurrent.locks.Lock;
//import java.util.concurrent.locks.ReentrantLock;
// Wrapper for native library
// _ENGINE
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\JavaAndroid\AndroidPlayer\app\src\main\java\com\AndroidPlayer\GLES3JNIView.java
/*
//www.apache.org/licenses/LICENSE-2.0
//package com.android.gles3jni;
// Pick an EGLConfig with RGB8 color, 16-bit depth, no stencil,
// supporting OpenGL ES 2.0 or later backwards-compatible versions.
// Log.v(GLES3JNILib.TAG, "TouchBegin");
//Log.v(GLES3JNILib.TAG, "step");
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\JavaAndroid\AndroidPlayerLibrary\gl3stub.c
/*
//www.apache.org/licenses/LICENSE-2.0
/* Function pointer definitions */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\NativeAndroid\AndroidPlayer.NativeActivity\android_native_app_glue.c
/*
//www.apache.org/licenses/LICENSE-2.0
/* For debug builds, always enable the debug traces in this library */
// Can't touch android_app object after this.
// --------------------------------------------------------------------
// Native activity interaction (called from main thread)
// --------------------------------------------------------------------
// Wait for thread to start.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinAndroid\XamarinPlayer\MainActivity.cs
/*
//www.apache.org/licenses/LICENSE-2.0
//jet.ro/visuals/san-angeles-observation/
//gl.glViewport(0, 0, w, h);
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinAndroid\XamarinPlayer\Properties\AssemblyInfo.cs
// Information about this assembly is defined by the following attributes. 
// Change them to the values specific to your project.
// The assembly version has the format "{Major}.{Minor}.{Build}.{Revision}".
// The form "{Major}.{Minor}.*" will automatically update the build and revision,
// and "{Major}.{Minor}.{Build}.*" will update just the revision.
// The following attributes are used to specify the signing key for the assembly, 
// if desired. See the Mono documentation for more information about signing.
//[assembly: AssemblyDelaySign(false)]
//[assembly: AssemblyKeyFile("")]
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinAndroid\XamarinPlayerLibrary\jni\app-linux.c
/* San Angeles Observation OpenGL ES version example
//iki.fi/jetro/
// GLESonGL seems to be returning 0 when there is no errors?
// Initializes and opens both X11 display and OpenGL ES.
// not referenced:
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinAndroid\XamarinPlayerLibrary\jni\app-win32.c
/* San Angeles Observation OpenGL ES version example
//iki.fi/jetro/
// PVRSDK
// !DISABLE_IMPORTGL
// !PVRSDK
// !DISABLE_IMPORTGL
// not referenced:
// register class
// init instance
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinWin\XamarinControl\Program.cs
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Project\XamarinWin\XamarinControl\Properties\AssemblyInfo.cs
// Information about this assembly is defined by the following attributes.
// Change them to the values specific to your project.
// The assembly version has the format "{Major}.{Minor}.{Build}.{Revision}".
// The form "{Major}.{Minor}.*" will automatically update the build and revision,
// and "{Major}.{Minor}.{Build}.*" will update just the revision.
// The following attributes are used to specify the signing key for the assembly,
// if desired. See the Mono documentation for more information about signing.
//[assembly: AssemblyDelaySign(false)]
//[assembly: AssemblyKeyFile("")]
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Player\android_native_app_glue.c
/*
//www.apache.org/licenses/LICENSE-2.0
/* For debug builds, always enable the debug traces in this library */
// Can't touch android_app object after this.
// --------------------------------------------------------------------
// Native activity interaction (called from main thread)
// --------------------------------------------------------------------
// Wait for thread to start.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Player\Android\java\com\polygontek\BlueshiftPlayer\GameActivity.java
// Copyright(c) 2017 POLYGONTEK
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http ://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// tell Android that we want volume controls to change the media volume, aka music
// Tell the activity's window that we want to do our own drawing
// to its surface.  This prevents the view hierarchy from drawing to
// it, though we can still add views to capture input if desired.
// hide status bar
// hide nav bar
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Player\Android\java\com\polygontek\BlueshiftPlayer\GameAdMobActivity.java
// Copyright(c) 2017 POLYGONTEK
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http ://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// References
// Banner Ads: https://developers.google.com/admob/android/banner?hl=ko
// Interstitial Ads: https://developers.google.com/admob/android/interstitial?hl=ko
// Rewarded Video Ads: https://developers.google.com/admob/android/rewarded-video?hl=ko
// Set up event notifications for banner ads
// Code to be executed when an ad finishes loading.
// Code to be executed when an ad request fails.
// Code to be executed when an ad opens an overlay that
// covers the screen.
// Code to be executed when when the user is about to return
// to the app after tapping on an ad.
// Code to be executed when the user has left the app.
// NOTE: adWidth <= 0 means full screen width
//mAdPopupWindow.setWindowLayoutMode(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
// Set up event notifications for interstitial ads
// Code to be executed when an ad finishes loading.
// Code to be executed when an ad request fails.
// Code to be executed when the ad is displayed.
// Code to be executed when when the interstitial ad is closed.
// Code to be executed when the user has left the app.
// Use an activity context to get the rewarded video instance.
//
// Set up event notifications for rewarded video ads
//
//
// JNI functions for passing events to script functions.
//
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\RHIOpenGL\OpenGL\GGL\gegl.c
/*********************************************************************************************
/* EGL_VERSION_1_0 */
/* EGL_VERSION_1_1 */
/* EGL_VERSION_1_2 */
/* EGL_VERSION_1_4 */
/* EGL_VERSION_1_5 */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\RHIOpenGL\OpenGL\GGL\gglcore32.c
/*********************************************************************************************
/* GL_VERSION_1_0 */
/* GL_VERSION_1_1 */
/* GL_VERSION_1_2 */
/* GL_VERSION_1_3 */
/* GL_VERSION_1_4 */
/* GL_VERSION_1_5 */
/* GL_VERSION_2_0 */
/* GL_VERSION_2_1 */
/* GL_VERSION_3_0 */
/* GL_VERSION_3_1 */
/* GL_VERSION_3_2 */
/* GL_3DFX_tbuffer */
/* GL_AMD_debug_output */
/* GL_AMD_draw_buffers_blend */
/* GL_AMD_gpu_shader_int64 */
/* GL_AMD_interleaved_elements */
/* GL_AMD_multi_draw_indirect */
/* GL_AMD_name_gen_delete */
/* GL_AMD_occlusion_query_event */
/* GL_AMD_performance_monitor */
/* GL_AMD_sample_positions */
/* GL_AMD_sparse_texture */
/* GL_AMD_stencil_operation_extended */
/* GL_AMD_vertex_shader_tessellator */
/* GL_APPLE_element_array */
/* GL_APPLE_fence */
/* GL_APPLE_flush_buffer_range */
/* GL_APPLE_object_purgeable */
/* GL_APPLE_texture_range */
/* GL_APPLE_vertex_array_object */
/* GL_APPLE_vertex_array_range */
/* GL_APPLE_vertex_program_evaluators */
/* GL_ARB_ES2_compatibility */
/* GL_ARB_ES3_1_compatibility */
/* GL_ARB_ES3_2_compatibility */
/* GL_ARB_base_instance */
/* GL_ARB_bindless_texture */
/* GL_ARB_blend_func_extended */
/* GL_ARB_buffer_storage */
/* GL_ARB_cl_event */
/* GL_ARB_clear_buffer_object */
/* GL_ARB_clear_texture */
/* GL_ARB_clip_control */
/* GL_ARB_color_buffer_float */
/* GL_ARB_compute_shader */
/* GL_ARB_compute_variable_group_size */
/* GL_ARB_copy_buffer */
/* GL_ARB_copy_image */
/* GL_ARB_debug_output */
/* GL_ARB_direct_state_access */
/* GL_ARB_draw_buffers */
/* GL_ARB_draw_buffers_blend */
/* GL_ARB_draw_elements_base_vertex */
/* GL_ARB_draw_indirect */
/* GL_ARB_draw_instanced */
/* GL_ARB_fragment_program */
/* GL_ARB_framebuffer_no_attachments */
/* GL_ARB_framebuffer_object */
/* GL_ARB_geometry_shader4 */
/* GL_ARB_get_program_binary */
/* GL_ARB_get_texture_sub_image */
/* GL_ARB_gpu_shader_fp64 */
/* GL_ARB_gpu_shader_int64 */
/* GL_ARB_imaging */
/* GL_ARB_indirect_parameters */
/* GL_ARB_instanced_arrays */
/* GL_ARB_internalformat_query */
/* GL_ARB_internalformat_query2 */
/* GL_ARB_invalidate_subdata */
/* GL_ARB_map_buffer_range */
/* GL_ARB_matrix_palette */
/* GL_ARB_multi_bind */
/* GL_ARB_multi_draw_indirect */
/* GL_ARB_multisample */
/* GL_ARB_multitexture */
/* GL_ARB_occlusion_query */
/* GL_ARB_parallel_shader_compile */
/* GL_ARB_point_parameters */
/* GL_ARB_program_interface_query */
/* GL_ARB_provoking_vertex */
/* GL_ARB_robustness */
/* GL_ARB_sample_locations */
/* GL_ARB_sample_shading */
/* GL_ARB_sampler_objects */
/* GL_ARB_separate_shader_objects */
/* GL_ARB_shader_atomic_counters */
/* GL_ARB_shader_image_load_store */
/* GL_ARB_shader_objects */
/* GL_ARB_shader_storage_buffer_object */
/* GL_ARB_shader_subroutine */
/* GL_ARB_shading_language_include */
/* GL_ARB_sparse_buffer */
/* GL_ARB_sparse_texture */
/* GL_ARB_sync */
/* GL_ARB_tessellation_shader */
/* GL_ARB_texture_barrier */
/* GL_ARB_texture_buffer_object */
/* GL_ARB_texture_buffer_range */
/* GL_ARB_texture_compression */
/* GL_ARB_texture_multisample */
/* GL_ARB_texture_storage */
/* GL_ARB_texture_storage_multisample */
/* GL_ARB_texture_view */
/* GL_ARB_timer_query */
/* GL_ARB_transform_feedback2 */
/* GL_ARB_transform_feedback3 */
/* GL_ARB_transform_feedback_instanced */
/* GL_ARB_transpose_matrix */
/* GL_ARB_uniform_buffer_object */
/* GL_ARB_vertex_array_object */
/* GL_ARB_vertex_attrib_64bit */
/* GL_ARB_vertex_attrib_binding */
/* GL_ARB_vertex_blend */
/* GL_ARB_vertex_buffer_object */
/* GL_ARB_vertex_program */
/* GL_ARB_vertex_shader */
/* GL_ARB_vertex_type_2_10_10_10_rev */
/* GL_ARB_viewport_array */
/* GL_ARB_window_pos */
/* GL_ATI_draw_buffers */
/* GL_ATI_element_array */
/* GL_ATI_envmap_bumpmap */
/* GL_ATI_fragment_shader */
/* GL_ATI_map_object_buffer */
/* GL_ATI_pn_triangles */
/* GL_ATI_separate_stencil */
/* GL_ATI_vertex_array_object */
/* GL_ATI_vertex_attrib_array_object */
/* GL_ATI_vertex_streams */
/* GL_EXT_bindable_uniform */
/* GL_EXT_blend_color */
/* GL_EXT_blend_equation_separate */
/* GL_EXT_blend_func_separate */
/* GL_EXT_blend_minmax */
/* GL_EXT_color_subtable */
/* GL_EXT_compiled_vertex_array */
/* GL_EXT_convolution */
/* GL_EXT_coordinate_frame */
/* GL_EXT_copy_texture */
/* GL_EXT_cull_vertex */
/* GL_EXT_debug_label */
/* GL_EXT_debug_marker */
/* GL_EXT_depth_bounds_test */
/* GL_EXT_direct_state_access */
/* GL_EXT_draw_buffers2 */
/* GL_EXT_draw_instanced */
/* GL_EXT_draw_range_elements */
/* GL_EXT_fog_coord */
/* GL_EXT_framebuffer_blit */
/* GL_EXT_framebuffer_multisample */
/* GL_EXT_framebuffer_object */
/* GL_EXT_geometry_shader4 */
/* GL_EXT_gpu_program_parameters */
/* GL_EXT_gpu_shader4 */
/* GL_EXT_histogram */
/* GL_EXT_index_func */
/* GL_EXT_index_material */
/* GL_EXT_light_texture */
/* GL_EXT_multi_draw_arrays */
/* GL_EXT_multisample */
/* GL_EXT_paletted_texture */
/* GL_EXT_pixel_transform */
/* GL_EXT_point_parameters */
/* GL_EXT_polygon_offset */
/* GL_EXT_polygon_offset_clamp */
/* GL_EXT_provoking_vertex */
/* GL_EXT_raster_multisample */
/* GL_EXT_secondary_color */
/* GL_EXT_separate_shader_objects */
/* GL_EXT_shader_image_load_store */
/* GL_EXT_stencil_clear_tag */
/* GL_EXT_stencil_two_side */
/* GL_EXT_subtexture */
/* GL_EXT_texture3D */
/* GL_EXT_texture_array */
/* GL_EXT_texture_buffer_object */
/* GL_EXT_texture_filter_minmax */
/* GL_EXT_texture_integer */
/* GL_EXT_texture_object */
/* GL_EXT_texture_perturb_normal */
/* GL_EXT_timer_query */
/* GL_EXT_transform_feedback */
/* GL_EXT_vertex_array */
/* GL_EXT_vertex_attrib_64bit */
/* GL_EXT_vertex_shader */
/* GL_EXT_vertex_weighting */
/* GL_EXT_window_rectangles */
/* GL_EXT_x11_sync_object */
/* GL_GREMEDY_frame_terminator */
/* GL_GREMEDY_string_marker */
/* GL_HP_image_transform */
/* GL_IBM_multimode_draw_arrays */
/* GL_IBM_static_data */
/* GL_IBM_vertex_array_lists */
/* GL_INGR_blend_func_separate */
/* GL_INTEL_framebuffer_CMAA */
/* GL_INTEL_map_texture */
/* GL_INTEL_parallel_arrays */
/* GL_INTEL_performance_query */
/* GL_KHR_blend_equation_advanced */
/* GL_KHR_debug */
/* GL_KHR_robustness */
/* GL_MESA_resize_buffers */
/* GL_MESA_window_pos */
/* GL_NVX_conditional_render */
/* GL_NV_bindless_multi_draw_indirect */
/* GL_NV_bindless_multi_draw_indirect_count */
/* GL_NV_bindless_texture */
/* GL_NV_blend_equation_advanced */
/* GL_NV_clip_space_w_scaling */
/* GL_NV_command_list */
/* GL_NV_conditional_render */
/* GL_NV_conservative_raster */
/* GL_NV_conservative_raster_dilate */
/* GL_NV_conservative_raster_pre_snap_triangles */
/* GL_NV_copy_image */
/* GL_NV_depth_buffer_float */
/* GL_NV_draw_texture */
/* GL_NV_evaluators */
/* GL_NV_explicit_multisample */
/* GL_NV_fence */
/* GL_NV_fragment_coverage_to_color */
/* GL_NV_fragment_program */
/* GL_NV_framebuffer_mixed_samples */
/* GL_NV_framebuffer_multisample_coverage */
/* GL_NV_geometry_program4 */
/* GL_NV_gpu_program4 */
/* GL_NV_gpu_program5 */
/* GL_NV_gpu_shader5 */
/* GL_NV_half_float */
/* GL_NV_internalformat_sample_query */
/* GL_NV_occlusion_query */
/* GL_NV_parameter_buffer_object */
/* GL_NV_path_rendering */
/* GL_NV_pixel_data_range */
/* GL_NV_point_sprite */
/* GL_NV_present_video */
/* GL_NV_primitive_restart */
/* GL_NV_register_combiners */
/* GL_NV_register_combiners2 */
/* GL_NV_sample_locations */
/* GL_NV_shader_buffer_load */
/* GL_NV_texture_barrier */
/* GL_NV_texture_multisample */
/* GL_NV_transform_feedback */
/* GL_NV_transform_feedback2 */
/* GL_NV_vdpau_interop */
/* GL_NV_vertex_array_range */
/* GL_NV_vertex_attrib_integer_64bit */
/* GL_NV_vertex_buffer_unified_memory */
/* GL_NV_vertex_program */
/* GL_NV_vertex_program4 */
/* GL_NV_video_capture */
/* GL_NV_viewport_swizzle */
/* GL_OES_byte_coordinates */
/* GL_OES_fixed_point */
/* GL_OES_query_matrix */
/* GL_OES_single_precision */
/* GL_OVR_multiview */
/* GL_PGI_misc_hints */
/* GL_SGIS_detail_texture */
/* GL_SGIS_fog_function */
/* GL_SGIS_multisample */
/* GL_SGIS_pixel_texture */
/* GL_SGIS_point_parameters */
/* GL_SGIS_sharpen_texture */
/* GL_SGIS_texture4D */
/* GL_SGIS_texture_color_mask */
/* GL_SGIS_texture_filter4 */
/* GL_SGIX_async */
/* GL_SGIX_flush_raster */
/* GL_SGIX_fragment_lighting */
/* GL_SGIX_framezoom */
/* GL_SGIX_igloo_interface */
/* GL_SGIX_instruments */
/* GL_SGIX_list_priority */
/* GL_SGIX_pixel_texture */
/* GL_SGIX_polynomial_ffd */
/* GL_SGIX_reference_plane */
/* GL_SGIX_sprite */
/* GL_SGIX_tag_sample_buffer */
/* GL_SGI_color_table */
/* GL_SUNX_constant_data */
/* GL_SUN_global_alpha */
/* GL_SUN_mesh_array */
/* GL_SUN_triangle_list */
/* GL_SUN_vertex */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\RHIOpenGL\OpenGL\GGL\ggles3.c
/*********************************************************************************************
/* GL_ES_VERSION_2_0 */
/* GL_ES_VERSION_3_0 */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\RHIOpenGL\OpenGL\GGL\gglx.c
/*********************************************************************************************
/* GLX_VERSION_1_0 */
/* GLX_VERSION_1_1 */
/* GLX_VERSION_1_2 */
/* GLX_VERSION_1_3 */
/* GLX_VERSION_1_4 */
/* GLX_AMD_gpu_association */
/* GLX_ARB_create_context */
/* GLX_ARB_get_proc_address */
/* GLX_EXT_import_context */
/* GLX_EXT_swap_control */
/* GLX_EXT_texture_from_pixmap */
/* GLX_MESA_agp_offset */
/* GLX_MESA_copy_sub_buffer */
/* GLX_MESA_pixmap_colormap */
/* GLX_MESA_query_renderer */
/* GLX_MESA_release_buffers */
/* GLX_MESA_set_3dfx_mode */
/* GLX_NV_copy_buffer */
/* GLX_NV_copy_image */
/* GLX_NV_delay_before_swap */
/* GLX_NV_present_video */
/* GLX_NV_swap_group */
/* GLX_NV_video_capture */
/* GLX_NV_video_out */
/* GLX_OML_sync_control */
/* GLX_SGI_cushion */
/* GLX_SGI_make_current_read */
/* GLX_SGI_swap_control */
/* GLX_SGI_video_sync */
/* GLX_SGIX_dmbuffer */
/* GLX_SGIX_fbconfig */
/* GLX_SGIX_hyperpipe */
/* GLX_SGIX_pbuffer */
/* GLX_SGIX_swap_barrier */
/* GLX_SGIX_swap_group */
/* GLX_SGIX_video_resize */
/* GLX_SGIX_video_source */
/* GLX_SUN_get_transparent_index */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\Runtime\Private\RHIOpenGL\OpenGL\GGL\gwgl.c
/*********************************************************************************************
/* WGL_VERSION_1_0 */
/* WGL_3DL_stereo_control */
/* WGL_AMD_gpu_association */
/* WGL_ARB_buffer_region */
/* WGL_ARB_create_context */
/* WGL_ARB_extensions_string */
/* WGL_ARB_make_current_read */
/* WGL_ARB_pbuffer */
/* WGL_ARB_pixel_format */
/* WGL_ARB_render_texture */
/* WGL_EXT_display_color_table */
/* WGL_EXT_extensions_string */
/* WGL_EXT_make_current_read */
/* WGL_EXT_pbuffer */
/* WGL_EXT_pixel_format */
/* WGL_EXT_swap_control */
/* WGL_I3D_digital_video_control */
/* WGL_I3D_gamma */
/* WGL_I3D_genlock */
/* WGL_I3D_image_buffer */
/* WGL_I3D_swap_frame_lock */
/* WGL_I3D_swap_frame_usage */
/* WGL_NV_copy_image */
/* WGL_NV_delay_before_swap */
/* WGL_NV_DX_interop */
/* WGL_NV_gpu_affinity */
/* WGL_NV_present_video */
/* WGL_NV_swap_group */
/* WGL_NV_video_capture */
/* WGL_NV_video_output */
/* WGL_NV_vertex_array_range */
/* WGL_OML_sync_control */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\TestRenderer\android_native_app_glue.c
/*
//www.apache.org/licenses/LICENSE-2.0
/* For debug builds, always enable the debug traces in this library */
// Can't touch android_app object after this.
// --------------------------------------------------------------------
// Native activity interaction (called from main thread)
// --------------------------------------------------------------------
// Wait for thread to start.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\TestRenderer\Android\java\com\polygontek\TestRenderer\GameActivity.java
// Copyright(c) 2017 POLYGONTEK
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http ://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// hide status bar
// hide nav bar
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\Bullet\src\clew\clew.c
//////////////////////////////////////////////////////////////////////////
//  Copyright (c) 2009 Organic Vectory B.V.
//  Written by George van Venrooij
//
//  Distributed under the Boost Software License, Version 1.0.
//  (See accompanying file license.txt)
//////////////////////////////////////////////////////////////////////////
//! \brief module handle
//  Variables holding function entry points
//  Ignore errors
//  Check if already initialized
//  Load library
//  Check for errors
//  Set unloading
//  Failure queuing atexit, shutdown with error
//  Determine function entry-points
// Error Codes
//   0
//  -1
//  -2
//  -3
//  -4
//  -5
//  -6
//  -7
//  -8
//  -9
//  -10
//  -11
//  -12
//  -13
//  -14
//  -15
//  -16
//  -17
//  -18
//  -19
//  -20
//  -21
//  -22
//  -23
//  -24
//  -25
//  -26
//  -27
//  -28
//  -29
//  -30
//  -31
//  -32
//  -33
//  -34
//  -35
//  -36
//  -37
//  -38
//  -39
//  -40
//  -41
//  -42
//  -43
//  -44
//  -45
//  -46
//  -47
//  -48
//  -49
//  -50
//  -51
//  -52
//  -53
//  -54
//  -55
//  -56
//  -57
//  -58
//  -59
//  -60
//  -61
//  -62
//  -63
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\autofit\afangles.c
/***************************************************************************/
/*                                                                         */
/*  afangles.c                                                             */
/*                                                                         */
/*    Routines used to compute vector angles with limited accuracy         */
/*    and very high speed.  It also contains sorting routines (body).      */
/*                                                                         */
/*  Copyright 2003-2006, 2011-2012 by                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*
/*
/* the following table has been automatically generated with */
/* the `mather.py' Python script                             */
/* check trivial cases */
/* 0 */
/* sort */
/* compute and use mean values for clusters not larger than  */
/* `threshold'; this is very primitive and might not yield   */
/* the best result, but normally, using reference character  */
/* `o', `*count' is 2, so the code below is fully sufficient */
/* fix loop for end of array */
/* compress array to remove zero values */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\autofit\afblue.c
/* This file has been generated by the Perl script `afblue.pl', */
/* using data from file `afblue.dat'.                           */
/***************************************************************************/
/*                                                                         */
/*  afblue.c                                                               */
/*                                                                         */
/*    Auto-fitter data for blue strings (body).                            */
/*                                                                         */
/*  Copyright 2013 by                                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* */
/* БВЕПЗОСЭ */
/* БВЕШЗОСЭ */
/* хпншезос */
/* руф */
/* क म अ आ थ ध भ श */
/* ई ऐ ओ औ ि ी ो ौ */
/* क म अ आ थ ध भ श */
/* ु ृ */
/* ΓΒΕΖΘΟΩ */
/* ΒΔΖΞΘΟ */
/* βθδζλξ */
/* αειοπστω */
/* βγημρφχψ */
/* בדהחךכםס */
/* בטכםסצ */
/* קךןףץ */
/* THEZOCQS */
/* HEZLOCUS */
/* fijkdbh */
/* xzroesc */
/* pqgjy */
/* ఇ ఌ ఙ ఞ ణ ఱ ౯ */
/* అ క చ ర ఽ ౨ ౬ */
/* 他们你來們到和地 */
/* 对對就席我时時會 */
/* 来為能舰說说这這 */
/* 齊 | */
/* 军同已愿既星是景 */
/* 民照现現理用置要 */
/* 軍那配里開雷露面 */
/* 顾 */
/* 个为人他以们你來 */
/* 個們到和大对對就 */
/* 我时時有来為要說 */
/* 说 | */
/* 主些因它想意理生 */
/* 當看着置者自著裡 */
/* 过还进進過道還里 */
/* 面 */
/* 些们你來們到和地 */
/* 她将將就年得情最 */
/* 样樣理能說说这這 */
/* 通 | */
/* 即吗吧听呢品响嗎 */
/* 师師收断斷明眼間 */
/* 间际陈限除陳随際 */
/* 隨 */
/* 事前學将將情想或 */
/* 政斯新样樣民沒没 */
/* 然特现現球第經谁 */
/* 起 | */
/* 例別别制动動吗嗎 */
/* 增指明朝期构物确 */
/* 种調调費费那都間 */
/* 间 */
/* AF_CONFIG_OPTION_CJK_BLUE_HANI_VERT */
/* AF_CONFIG_OPTION_CJK                */
/* stringsets are specific to styles */
/* */
/* AF_CONFIG_OPTION_CJK_BLUE_HANI_VERT */
/* AF_CONFIG_OPTION_CJK                */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\autofit\afcjk.c
/***************************************************************************/
/*                                                                         */
/*  afcjk.c                                                                */
/*                                                                         */
/*    Auto-fitter hinting routines for CJK writing system (body).          */
/*                                                                         */
/*  Copyright 2006-2014 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*
//www.kde.gr.jp/~akito/patch/freetype2/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****              C J K   G L O B A L   M E T R I C S              *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* Basically the Latin version with AF_CJKMetrics */
/* to replace AF_LatinMetrics.                    */
/* scan the array of segments in each direction */
/* we only consider stem segments there! */
/* this also replaces multiple almost identical stem widths */
/* with a single one (the value 100 is heuristic)           */
/* let's try 20% of the smallest width */
/* Find all blue zones. */
/* we walk over the blue character strings as specified in the   */
/* style's entry in the `af_blue_stringset' array, computing its */
/* extremum points (depending on the string properties)          */
/* --   , --  */
/* --   , TOP */
/* HORIZ, --  */
/* HORIZ, TOP */
/* FT_DEBUG_LEVEL_TRACE */
/* start with characters that define fill values */
/* same as points.y or points.x, resp. */
/* switch to characters that define flat values */
/* load the character in the face -- skip unknown or empty ones */
/* now compute min or max point indices and coordinates */
/* make compiler happy */
/* Avoid single-point contours since they are never rasterized. */
/* In some fonts, they correspond to mark attachment points     */
/* which are way outside of the glyph's real outline.           */
/*
/* we have computed the contents of the `fill' and `flats' tables,   */
/* now determine the reference and overshoot position of the blue -- */
/* we simply take the median value after a simple sort               */
/* make sure blue_ref >= blue_shoot for top/right or */
/* vice versa for bottom/left                        */
/* AF_CJK_IS_TOP_BLUE covers `right' and `top' */
/* Basically the Latin version with type AF_CJKMetrics for metrics. */
/* digit `0' is 0x30 in all supported charmaps */
/* Initialize global metrics. */
/* Adjust scaling value, then scale and shift widths   */
/* and blue zones (if applicable) for given dimension. */
/* scale the blue zones */
/* a blue zone is only active if it is less than 3/4 pixels tall */
/* shoot is under shoot for cjk */
/* Scale global values in both directions. */
/* we copy the whole structure since the x and y scaling values */
/* are not modified, contrary to e.g. the `latin' auto-hinter   */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****              C J K   G L Y P H   A N A L Y S I S              *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* Walk over all contours and compute its segments. */
/* a segment is round if it doesn't have successive */
/* on-curve points.                                 */
/* now compare each segment to the others */
/*
/* seg2 < seg1 < link1 < link2 */
/*********************************************************************/
/*                                                                   */
/* We begin by generating a sorted table of edges for the current    */
/* direction.  To do so, we simply scan each segment and try to find */
/* an edge in our table that corresponds to its position.            */
/*                                                                   */
/* If no edge is found, we create and insert a new edge in the       */
/* sorted table.  Otherwise, we simply add the segment to the edge's */
/* list which is then processed in the second step to compute the    */
/* edge's properties.                                                */
/*                                                                   */
/* Note that the edges table is sorted along the segment/edge        */
/* position.                                                         */
/*                                                                   */
/*********************************************************************/
/* look for an edge corresponding to the segment */
/* check whether all linked segments of the candidate edge */
/* can make a single edge.                                 */
/* insert a new edge in the list and */
/* sort according to the position    */
/* add the segment to the new edge's list */
/* if an edge was found, simply add the segment to the edge's */
/* list                                                       */
/******************************************************************/
/*                                                                */
/* Good, we now compute each edge's properties according to the   */
/* segments found on its position.  Basically, these are          */
/*                                                                */
/*  - the edge's main direction                                   */
/*  - stem edge, serif edge or both (which defaults to stem then) */
/*  - rounded edge, straight or both (which defaults to straight) */
/*  - link for edge                                               */
/*                                                                */
/******************************************************************/
/* first of all, set the `edge' field in each segment -- this is */
/* required in order to compute edge links                       */
/*
/* now compute each edge properties */
/* does it contain round segments?    */
/* does it contain straight segments? */
/* check for roundness of segment */
/* check for links -- if seg->serif is set, then seg->link must */
/* be ignored                                                   */
/* set the round/straight flags */
/* get rid of serifs if link is set                 */
/* XXX: This gets rid of many unpleasant artefacts! */
/*      Example: the `c' in cour.pfa at size 13     */
/* Detect segments and edges for given dimension. */
/* Compute all edges which lie within blue zones. */
/* initial threshold */
/* compute the initial threshold as a fraction of the EM size */
/* maximum 1/2 pixel */
/* compute which blue zones are active, i.e. have their scaled */
/* size < 3/4 pixels                                           */
/* If the distant between an edge and a blue zone is shorter than */
/* best_dist0, set the blue zone for the edge.  Then search for   */
/* the blue zone with the smallest best_dist to the edge.         */
/* skip inactive blue zones (i.e., those that are too small) */
/* if it is a top zone, check for right edges -- if it is a bottom */
/* zone, check for left edges                                      */
/*                                                                 */
/* of course, that's for TrueType                                  */
/* if it is a top zone, the edge must be against the major    */
/* direction; if it is a bottom zone, it must be in the major */
/* direction                                                  */
/* Compare the edge to the closest blue zone type */
/* Initalize hinting engine. */
/*
/* compute flags depending on render mode, etc. */
/*
/*
/*
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****          C J K   G L Y P H   G R I D - F I T T I N G          *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* Snap a given width in scaled coordinates to one of the */
/* current standard widths.                               */
/* Compute the snapped width of a given stem.                          */
/* There is a lot of voodoo in this function; changing the hard-coded  */
/* parameters influence the whole hinting process.                     */
/* smooth hinting process: very lightly quantize the stem width */
/* strong hinting process: snap the stem width to integer pixels */
/* in the case of vertical hinting, always round */
/* the stem heights to integer pixels            */
/* monochrome horizontal hinting: snap widths to integer pixels */
/* with a different threshold                                   */
/* for horizontal anti-aliased hinting, we adopt a more subtle */
/* approach: we strengthen small stems, round stems whose size */
/* is between 1 and 2 pixels to an integer, otherwise nothing  */
/* round otherwise to prevent color fringes in LCD mode */
/* Align one stem edge relative to the previous stem edge. */
/* Shift the coordinates of the `serif' edge by the same amount */
/* as the corresponding `base' edge has been moved already.     */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                    E D G E   H I N T I N G                      ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* The main grid-fitting routine. */
/* we begin by aligning all stems relative to the blue zone */
/* now we align all stem edges. */
/* skip all non-stem edges */
/* Some CJK characters have so many stems that
/* now align the stem */
/* this should not happen, but it's better to be safe */
/* We rarely reaches here it seems;
/* 0 */
/* make sure that lowercase m's maintain their symmetry */
/* In general, lowercase m's have six vertical edges if they are sans */
/* serif, or twelve if they are with serifs.  This implementation is  */
/* based on that assumption, and seems to work very well with most    */
/* faces.  However, if for a certain face this assumption is not      */
/* true, the m is just rendered like before.  In addition, any stem   */
/* correction will only be applied to symmetrical glyphs (even if the */
/* glyph is not an m), so the potential for unwanted distortion is    */
/* relatively low.                                                    */
/* We don't handle horizontal edges since we can't easily assure that */
/* the third (lowest) stem aligns with the base line; it might end up */
/* one pixel higher or lower.                                         */
/* move the serifs along with the stem */
/*
/* move the points of each segment     */
/* in each edge to the edge's position */
/* Apply the complete hinting algorithm to a CJK glyph. */
/* analyze glyph outline */
/* grid-fit the outline */
/* AF_CONFIG_OPTION_USE_WARPER */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                C J K   S C R I P T   C L A S S                *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* !AF_CONFIG_OPTION_CJK */
/* !AF_CONFIG_OPTION_CJK */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\autofit\afdummy.c
/***************************************************************************/
/*                                                                         */
/*  afdummy.c                                                              */
/*                                                                         */
/*    Auto-fitter dummy routines to be used if no hinting should be        */
/*    performed (body).                                                    */
/*                                                                         */
/*  Copyright 2003-2005, 2011, 2013 by                                     */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\autofit\afglobal.c
/***************************************************************************/
/*                                                                         */
/*  afglobal.c                                                             */
/*                                                                         */
/*    Auto-fitter routines to compute global hinting values (body).        */
/*                                                                         */
/*  Copyright 2003-2014 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* get writing system specific header files */
/* empty */
/* do not remove */
/* do not remove */
/* do not remove */
/* !FT_CONFIG_OPTION_PIC */
/* FT_DEBUG_LEVEL_TRACE */
/* Compute the style index of each glyph within a given face. */
/* a non-valid value */
/* the value AF_STYLE_UNASSIGNED means `uncovered glyph' */
/*
/* scan each style in a Unicode charmap */
/*
/* get glyphs not directly addressable by cmap */
/* handle the default OpenType features of the default script ... */
/* ... and the remaining default OpenType features */
/* mark ASCII digits */
/*
/* FT_DEBUG_LEVEL_TRACE */
/* no need to free this one! */
/* if we have a forced style (via `options'), use it, */
/* otherwise look into `glyph_styles' array           */
/* create the global metrics object if necessary */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\autofit\afhints.c
/***************************************************************************/
/*                                                                         */
/*  afhints.c                                                              */
/*                                                                         */
/*    Auto-fitter hinting routines (body).                                 */
/*                                                                         */
/*  Copyright 2003-2007, 2009-2014 by                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* Get new segment for given axis. */
/* Get new edge for given axis, direction, and position, */
/* without initializing the edge itself.                 */
/* we want the edge with same position and minor direction */
/* to appear before those in the major one in the list     */
/* The dump functions are used in the `ftgrid' demo program, too. */
/* Dump the array of linked segments. */
/* Fetch number of segments. */
/* Fetch offset of segments into user supplied offset array. */
/* Dump the array of linked edges. */
/*
/* !FT_DEBUG_AUTOFIT */
/* Compute the direction value of a given vector. */
/* long and short arm lengths */
/* candidate direction        */
/* dy < dx */
/* return no direction if arm lengths differ too much            */
/* (value 14 is heuristic, corresponding to approx. 4.1 degrees) */
/*
/* Reset metrics. */
/* Recompute all AF_Point in AF_GlyphHints from the definitions */
/* in a source outline.                                         */
/* first of all, reallocate the contours array if necessary */
/* round up to a multiple of 4 */
/*
/* round up to a multiple of 8 */
/* We can't rely on the value of `FT_Outline.flags' to know the fill   */
/* direction used for a glyph, given that some fonts are broken (e.g., */
/* the Arphic ones).  We thus recompute it each time we need to.       */
/*                                                                     */
/* compute coordinates & Bezier flags, next and prev */
/* set up the contours array */
/*
/* value 20 in `near_limit' is heuristic */
/* since the first point of a contour could be part of a */
/* series of near points, go backwards to find the first */
/* non-near point and adjust `first'                     */
/*
/* adjust first point */
/* now loop over all points of the contour to get */
/* `in' and `out' vector directions               */
/*
/* adjust directions for all points inbetween; */
/* the loop also updates position of `curr'    */
/*
/* check whether both vectors point into the same quadrant */
/* yes, so tag current point as weak */
/* and update index deltas           */
/*
/* control points are always weak */
/* current point lies on a horizontal or          */
/* vertical segment (but doesn't start or end it) */
/* either the `in' or the `out' vector is much more  */
/* dominant than the other one, so tag current point */
/* as weak and update index deltas                   */
/* current point forms a spike */
/* Store the hinted outline in an FT_Outline structure. */
/****************************************************************
/* Align all points of an edge to the same coordinate value, */
/* either horizontally or vertically.                        */
/****************************************************************
/* Hint the strong points -- this is equivalent to the TrueType `IP' */
/* hinting instruction.                                              */
/* point position */
/* if this point is candidate to weak interpolation, we       */
/* interpolate it after all strong points have been processed */
/* is the point before the first edge? */
/* is the point after the last edge? */
/* find enclosing edges */
/* for a small number of edges, a linear search is better */
/* we are on the edge */
/* point is not on an edge */
/* assert( before && after && before != after ) */
/* save the point position */
/****************************************************************
/* Shift the original coordinates of all points between `p1' and */
/* `p2' to get hinted coordinates, using the same difference as  */
/* given by `ref'.                                               */
/* Interpolate the original coordinates of all points between `p1' and  */
/* `p2' to get hinted coordinates, using `ref1' and `ref2' as the       */
/* reference points.  The `u' and `v' members are the current and       */
/* original coordinate values, respectively.                            */
/*                                                                      */
/* Details can be found in the TrueType bytecode specification.         */
/* Hint the weak points -- this is equivalent to the TrueType `IUP' */
/* hinting instruction.                                             */
/* PASS 1: Move segment points to edge positions */
/* find first touched point */
/* no touched point in contour */
/* skip any touched neighbours */
/* find the next touched point, if any */
/* interpolate between last_touched and point */
/* special case: only one point was touched */
/* interpolate the last part */
/* now save the interpolated values back to x/y */
/* Apply (small) warp scale and warp delta for given dimension. */
/* AF_CONFIG_OPTION_USE_WARPER */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\autofit\afindic.c
/***************************************************************************/
/*                                                                         */
/*  afindic.c                                                              */
/*                                                                         */
/*    Auto-fitter hinting routines for Indic writing system (body).        */
/*                                                                         */
/*  Copyright 2007, 2011-2013 by                                           */
/*  Rahul Bhalerao <rahul.bhalerao@redhat.com>, <b.rahul.pm@gmail.com>.    */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* skip blue zone init in CJK routines */
/* either need indic specific blue_chars[] or just skip blue zones */
/* use CJK routines */
/* use CJK routines */
/* use CJK routines */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                I N D I C   S C R I P T   C L A S S            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* !AF_CONFIG_OPTION_INDIC */
/* !AF_CONFIG_OPTION_INDIC */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\autofit\aflatin.c
/***************************************************************************/
/*                                                                         */
/*  aflatin.c                                                              */
/*                                                                         */
/*    Auto-fitter hinting routines for latin writing system (body).        */
/*                                                                         */
/*  Copyright 2003-2014 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****            L A T I N   G L O B A L   M E T R I C S            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* Find segments and links, compute all stem widths, and initialize */
/* standard width and height for the glyph with given charcode.     */
/* scan the array of segments in each direction */
/*
/*
/* we only consider stem segments there! */
/* this also replaces multiple almost identical stem widths */
/* with a single one (the value 100 is heuristic)           */
/* let's try 20% of the smallest width */
/* Find all blue zones.  Flat segments give the reference points, */
/* round segments the overshoot positions.                        */
/* we walk over the blue character strings as specified in the */
/* style's entry in the `af_blue_stringset' array              */
/* FT_DEBUG_LEVEL_TRACE */
/* same as points.y */
/* load the character in the face -- skip unknown or empty ones */
/* now compute min or max point indices and coordinates */
/* make compiler happy */
/* ditto */
/* ditto */
/* Avoid single-point contours since they are never rasterized. */
/* In some fonts, they correspond to mark attachment points     */
/* that are way outside of the glyph's real outline.            */
/* now check whether the point belongs to a straight or round   */
/* segment; we first need to find in which contour the extremum */
/* lies, then inspect its previous and next points              */
/* look for the previous and next points on the contour  */
/* that are not on the same Y coordinate, then threshold */
/* the `closeness'...                                    */
/* accept a small distance or a small angle (both values are */
/* heuristic; value 20 corresponds to approx. 2.9 degrees)   */
/* If this flag is set, we have an additional constraint to  */
/* get the blue zone distance: Find a segment of the topmost */
/* (or bottommost) contour that is longer than a heuristic   */
/* threshold.  This ensures that small bumps in the outline  */
/* are ignored (for example, the `vertical serifs' found in  */
/* many Hebrew glyph designs).                               */
/* If this segment is long enough, we are done.  Otherwise,  */
/* search the segment next to the extremum that is long      */
/* enough, has the same direction, and a not too large       */
/* vertical distance from the extremum.  Note that the       */
/* algorithm doesn't check whether the found segment is      */
/* actually the one (vertically) nearest to the extremum.    */
/* heuristic threshold value */
/* heuristic threshold value */
/* we intentionally declare these two variables        */
/* outside of the loop since various compilers emit    */
/* incorrect warning messages otherwise, talking about */
/* `possibly uninitialized variables'                  */
/* make compiler happy */
/* compute direction */
/* skip glyph for the degenerate case */
/* no hit; adjust first point */
/* also adjust first and last on point */
/* vertical distance too large */
/* same test as above */
/* all constraints are met; update segment after finding */
/* its end                                               */
/* for computing blue zones, we add the y offset as returned */
/* by the currently used OpenType feature -- for example,    */
/* superscript glyphs might be identical to subscript glyphs */
/* with a vertical shift                                     */
/* now set the `round' flag depending on the segment's kind: */
/*                                                           */
/* - if the horizontal distance between the first and last   */
/*   `on' point is larger than upem/8 (value 8 is heuristic) */
/*   we have a flat segment                                  */
/* - if either the first or the last point of the segment is */
/*   an `off' point, the segment is round, otherwise it is   */
/*   flat                                                    */
/* only use flat segments for a neutral blue zone */
/*
/* we have computed the contents of the `rounds' and `flats' tables, */
/* now determine the reference and overshoot position of the blue -- */
/* we simply take the median value after a simple sort               */
/* there are sometimes problems: if the overshoot position of top     */
/* zones is under its reference position, or the opposite for bottom  */
/* zones.  We must thus check everything there and correct the errors */
/*
/* Check whether all ASCII digits have the same advance width. */
/* digit `0' is 0x30 in all supported charmaps */
/* Initialize global metrics. */
/* Adjust scaling value, then scale and shift widths   */
/* and blue zones (if applicable) for given dimension. */
/*
/* if the `increase-x-height' property is active, */
/* we round up much more often                    */
/* scale *= 0.98 */
/* scale the widths */
/* an extra-light axis corresponds to a standard width that is */
/* smaller than 5/8 pixels                                     */
/* scale the blue zones */
/* a blue zone is only active if it is less than 3/4 pixels tall */
/* use discrete values for blue zone widths */
/* generic, original code */
/* simplified version due to abs(dist) <= 48 */
/* Scale global values in both directions. */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****           L A T I N   G L Y P H   A N A L Y S I S             *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* Walk over all contours and compute its segments. */
/* set up (u,v) in each point */
/* do each contour separately */
/* minimum segment pos != min_coord */
/* maximum segment pos != max_coord */
/* skip singletons -- just in case */
/* we are already on an edge, try to locate its start */
/* we are just leaving an edge; record a new segment! */
/* a segment is round if either its first or last point */
/* is a control point                                   */
/* compute segment size */
/* fall through */
/* now exit if we are at the start/end point */
/* this is the start of a new segment! */
/* clear all segment fields */
/* contours */
/* now slightly increase the height of segments if this makes */
/* sense -- this is used to better detect and ignore serifs   */
/* Link segments to form stems and serifs.  If `width_count' and      */
/* `widths' are non-zero, use them to fine-tune the scoring function. */
/* a heuristic value to set up a minimum value for overlapping */
/* a heuristic value to weight lengths */
/* a heuristic value to weight distances (no call to    */
/* AF_LATIN_CONSTANT needed, since we work on multiples */
/* of the stem width)                                   */
/* now compare each segment to the others */
/* search for stems having opposite directions, */
/* with seg1 to the `left' of seg2              */
/* compute distance between the two segments */
/* compute maximum coordinate difference of the two segments */
/* (this is, how much they overlap)                          */
/*
/* distance demerits are based on multiples of `max_width'; */
/* we scale by 1024 for getting more precision              */
/* default if no widths available */
/* and we search for the smallest score */
/* now compute the `serif' segments, cf. explanations in `afhints.h' */
/* Link segments to edges, using feature analysis for selection. */
/*
/*********************************************************************/
/*                                                                   */
/* We begin by generating a sorted table of edges for the current    */
/* direction.  To do so, we simply scan each segment and try to find */
/* an edge in our table that corresponds to its position.            */
/*                                                                   */
/* If no edge is found, we create and insert a new edge in the       */
/* sorted table.  Otherwise, we simply add the segment to the edge's */
/* list which gets processed in the second step to compute the       */
/* edge's properties.                                                */
/*                                                                   */
/* Note that the table of edges is sorted along the segment/edge     */
/* position.                                                         */
/*                                                                   */
/*********************************************************************/
/* assure that edge distance threshold is at most 0.25px */
/* A special case for serif edges: If they are smaller than */
/* 1.5 pixels we ignore them.                               */
/* look for an edge corresponding to the segment */
/* insert a new edge in the list and */
/* sort according to the position    */
/* add the segment to the new edge's list */
/* if an edge was found, simply add the segment to the edge's */
/* list                                                       */
/******************************************************************/
/*                                                                */
/* Good, we now compute each edge's properties according to the   */
/* segments found on its position.  Basically, these are          */
/*                                                                */
/*  - the edge's main direction                                   */
/*  - stem edge, serif edge or both (which defaults to stem then) */
/*  - rounded edge, straight or both (which defaults to straight) */
/*  - link for edge                                               */
/*                                                                */
/******************************************************************/
/* first of all, set the `edge' field in each segment -- this is */
/* required in order to compute edge links                       */
/*
/* now compute each edge properties */
/* does it contain round segments?    */
/* does it contain straight segments? */
/* number of upwards segments         */
/* number of downwards segments       */
/* check for roundness of segment */
/* check for segment direction */
/* check for links -- if seg->serif is set, then seg->link must */
/* be ignored                                                   */
/* set the round/straight flags */
/* set the edge's main direction */
/* both up and down! */
/* get rid of serifs if link is set                 */
/* XXX: This gets rid of many unpleasant artefacts! */
/*      Example: the `c' in cour.pfa at size 13     */
/* Detect segments and edges for given dimension. */
/* Compute all edges which lie within blue zones. */
/* compute which blue zones are active, i.e. have their scaled */
/* size < 3/4 pixels                                           */
/* for each horizontal edge search the blue zone which is closest */
/* initial threshold */
/* compute the initial threshold as a fraction of the EM size */
/* (the value 40 is heuristic)                                */
/* assure a minimum distance of 0.5px */
/* skip inactive blue zones (i.e., those that are too large) */
/* if it is a top zone, check for right edges (against the major */
/* direction); if it is a bottom zone, check for left edges (in  */
/* the major direction) -- this assumes the TrueType convention  */
/* for the orientation of contours                               */
/* neutral blue zones are handled for both directions */
/* first of all, compare it to the reference position */
/* now compare it to the overshoot position and check whether */
/* the edge is rounded, and whether the edge is over the      */
/* reference position of a top zone, or under the reference   */
/* position of a bottom zone (provided we don't have a        */
/* neutral blue zone)                                         */
/* Initalize hinting engine. */
/*
/* compute flags depending on render mode, etc. */
/* #ifdef AF_CONFIG_OPTION_USE_WARPER */
/*
/*
/*
/*
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****        L A T I N   G L Y P H   G R I D - F I T T I N G        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* Snap a given width in scaled coordinates to one of the */
/* current standard widths.                               */
/* Compute the snapped width of a given stem, ignoring very thin ones. */
/* There is a lot of voodoo in this function; changing the hard-coded  */
/* parameters influence the whole hinting process.                     */
/* smooth hinting process: very lightly quantize the stem width */
/* leave the widths of serifs alone */
/* compare to standard width */
/* strong hinting process: snap the stem width to integer pixels */
/* in the case of vertical hinting, always round */
/* the stem heights to integer pixels            */
/* monochrome horizontal hinting: snap widths to integer pixels */
/* with a different threshold                                   */
/* for horizontal anti-aliased hinting, we adopt a more subtle */
/* approach: we strengthen small stems, round stems whose size */
/* is between 1 and 2 pixels to an integer, otherwise nothing  */
/* We only round to an integer width if the corresponding */
/* distortion is less than 1/4 pixel.  Otherwise this     */
/* makes everything worse since the diagonals, which are  */
/* not hinted, appear a lot bolder or thinner than the    */
/* vertical stems.                                        */
/* round otherwise to prevent color fringes in LCD mode */
/* Align one stem edge relative to the previous stem edge. */
/* Shift the coordinates of the `serif' edge by the same amount */
/* as the corresponding `base' edge has been moved already.     */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                    E D G E   H I N T I N G                      ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* The main grid-fitting routine. */
/* we begin by aligning all stems relative to the blue zone */
/* if needed -- that's only for horizontal edges            */
/* these edges form the stem to check */
/*
/* flip edges if the other edge is aligned to a blue zone */
/* now we align all other stem edges, trying to maintain the */
/* relative order of stems in the glyph                      */
/* skip all non-stem edges */
/* now align the stem */
/* this should not happen, but it's better to be safe */
/* if we reach this if clause, no stem has been aligned yet */
/* some voodoo to specially round edges for small stem widths; */
/* the idea is to align the center of a stem, then shifting    */
/* the stem edges to suitable positions                        */
/* width <= 1px */
/* 1px < width < 1.5px */
/* make sure that lowercase m's maintain their symmetry */
/* In general, lowercase m's have six vertical edges if they are sans */
/* serif, or twelve if they are with serifs.  This implementation is  */
/* based on that assumption, and seems to work very well with most    */
/* faces.  However, if for a certain face this assumption is not      */
/* true, the m is just rendered like before.  In addition, any stem   */
/* correction will only be applied to symmetrical glyphs (even if the */
/* glyph is not an m), so the potential for unwanted distortion is    */
/* relatively low.                                                    */
/* We don't handle horizontal edges since we can't easily assure that */
/* the third (lowest) stem aligns with the base line; it might end up */
/* one pixel higher or lower.                                         */
/* move the serifs along with the stem */
/*
/* Apply the complete hinting algorithm to a latin glyph. */
/* analyze glyph outline */
/* grid-fit the outline */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****              L A T I N   S C R I P T   C L A S S              *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\autofit\aflatin2.c
/***************************************************************************/
/*                                                                         */
/*  aflatin2.c                                                             */
/*                                                                         */
/*    Auto-fitter hinting routines for latin writing system (body).        */
/*                                                                         */
/*  Copyright 2003-2014 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****            L A T I N   G L O B A L   M E T R I C S            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* scan the array of segments in each direction */
/* we only consider stem segments there! */
/* let's try 20% of the smallest width */
/* we compute the blues simply by loading each character from the     */
/* 'af_latin2_blue_chars[blues]' string, then compute its top-most or */
/* bottom-most points (depending on `AF_IS_TOP_BLUE')                 */
/* load the character in the face -- skip unknown or empty ones */
/* now compute min or max point indices and coordinates */
/* make compiler happy */
/* ditto */
/* ditto */
/* Avoid single-point contours since they are never rasterized. */
/* In some fonts, they correspond to mark attachment points     */
/* which are way outside of the glyph's real outline.           */
/* now check whether the point belongs to a straight or round   */
/* segment; we first need to find in which contour the extremum */
/* lies, then inspect its previous and next points              */
/* now look for the previous and next points that are not on the */
/* same Y coordinate.  Threshold the `closeness'...              */
/* accept a small distance or a small angle (both values are */
/* heuristic; value 20 corresponds to approx. 2.9 degrees)   */
/* now, set the `round' flag depending on the segment's kind */
/*
/* we have computed the contents of the `rounds' and `flats' tables, */
/* now determine the reference and overshoot position of the blue -- */
/* we simply take the median value after a simple sort               */
/* there are sometimes problems: if the overshoot position of top     */
/* zones is under its reference position, or the opposite for bottom  */
/* zones.  We must thus check everything there and correct the errors */
/*
/* check whether all ASCII digits have the same advance width; */
/* digit `0' is 0x30 in all supported charmaps                 */
/* end of list */
/* do we have a latin charmap in there? */
/*
/* if the `increase-x-height' property is active, */
/* we round up much more often                    */
/* scale the standard widths */
/* an extra-light axis corresponds to a standard width that is */
/* smaller than 5/8 pixels                                     */
/* scale the blue zones */
/* a blue zone is only active if it is less than 3/4 pixels tall */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****           L A T I N   G L Y P H   A N A L Y S I S             *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* set up (u,v) in each point */
/* do each contour separately */
/* skip singletons -- just in case */
/* already on an edge ?, backtrack to find its start */
/* otherwise, find first segment start, if any */
/* we're at the start of a new segment */
/* record new segment */
/* a segment is round if it doesn't have successive */
/* on-curve points.                                 */
/* this can happen in the case of a degenerate contour
/* jump to the start of the next segment, if any */
/* contours */
/* now slightly increase the height of segments when this makes */
/* sense -- this is used to better detect and ignore serifs     */
/* place all segments with a negative direction to the start
/* now compare each segment to the others */
/* now, compute the `serif' segments */
/*
/*********************************************************************/
/*                                                                   */
/* We will begin by generating a sorted table of edges for the       */
/* current direction.  To do so, we simply scan each segment and try */
/* to find an edge in our table that corresponds to its position.    */
/*                                                                   */
/* If no edge is found, we create and insert a new edge in the       */
/* sorted table.  Otherwise, we simply add the segment to the edge's */
/* list which will be processed in the second step to compute the    */
/* edge's properties.                                                */
/*                                                                   */
/* Note that the edges table is sorted along the segment/edge        */
/* position.                                                         */
/*                                                                   */
/*********************************************************************/
/* A special case for serif edges: If they are smaller than */
/* 1.5 pixels we ignore them.                               */
/* unlink this serif, it is too distant from its reference stem */
/* look for an edge corresponding to the segment */
/* insert a new edge in the list and */
/* sort according to the position    */
/* add the segment to the new edge's list */
/* if an edge was found, simply add the segment to the edge's */
/* list                                                       */
/*********************************************************************/
/*                                                                   */
/* Good, we will now compute each edge's properties according to     */
/* segments found on its position.  Basically, these are:            */
/*                                                                   */
/*  - edge's main direction                                          */
/*  - stem edge, serif edge or both (which defaults to stem then)    */
/*  - rounded edge, straight or both (which defaults to straight)    */
/*  - link for edge                                                  */
/*                                                                   */
/*********************************************************************/
/* first of all, set the `edge' field in each segment -- this is */
/* required in order to compute edge links                       */
/*
/* now, compute each edge properties */
/* does it contain round segments?    */
/* does it contain straight segments? */
/* number of upwards segments         */
/* number of downwards segments       */
/* check for roundness of segment */
/* check for segment direction */
/* check for links -- if seg->serif is set, then seg->link must */
/* be ignored                                                   */
/* set the round/straight flags */
/* set the edge's main direction */
/* both up and down! */
/* gets rid of serifs if link is set                */
/* XXX: This gets rid of many unpleasant artefacts! */
/*      Example: the `c' in cour.pfa at size 13     */
/* initial threshold */
/* compute the initial threshold as a fraction of the EM size */
/* compute which blue zones are active, i.e. have their scaled */
/* size < 3/4 pixels                                           */
/* for each horizontal edge search the blue zone which is closest */
/* skip inactive blue zones (i.e., those that are too small) */
/* if it is a top zone, check for right edges -- if it is a bottom */
/* zone, check for left edges                                      */
/*                                                                 */
/* of course, that's for TrueType                                  */
/* if it is a top zone, the edge must be against the major    */
/* direction; if it is a bottom zone, it must be in the major */
/* direction                                                  */
/* if it's a rounded edge, compare it to the overshoot position */
/* if it's a flat edge, compare it to the reference position    */
/* now, compare it to the overshoot position if the edge is     */
/* rounded, and if the edge is over the reference position of a */
/* top zone, or under the reference position of a bottom zone   */
/*
/* compute flags depending on render mode, etc. */
/* #ifdef AF_CONFIG_OPTION_USE_WARPER */
/*
/*
/*
/*
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****        L A T I N   G L Y P H   G R I D - F I T T I N G        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* snap a given width in scaled coordinates to one of the */
/* current standard widths                                */
/* compute the snapped width of a given stem */
/* smooth hinting process: very lightly quantize the stem width */
/* leave the widths of serifs alone */
/* compare to standard width */
/* strong hinting process: snap the stem width to integer pixels */
/* in the case of vertical hinting, always round */
/* the stem heights to integer pixels            */
/* monochrome horizontal hinting: snap widths to integer pixels */
/* with a different threshold                                   */
/* for horizontal anti-aliased hinting, we adopt a more subtle */
/* approach: we strengthen small stems, round stems whose size */
/* is between 1 and 2 pixels to an integer, otherwise nothing  */
/* We only round to an integer width if the corresponding */
/* distortion is less than 1/4 pixel.  Otherwise this     */
/* makes everything worse since the diagonals, which are  */
/* not hinted, appear a lot bolder or thinner than the    */
/* vertical stems.                                        */
/* round otherwise to prevent color fringes in LCD mode */
/* align one stem edge relative to the previous stem edge */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                    E D G E   H I N T I N G                      ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* we begin by aligning all stems relative to the blue zone */
/* if needed -- that's only for horizontal edges            */
/* now we will align all stem edges, trying to maintain the */
/* relative order of stems in the glyph                     */
/* skip all non-stem edges */
/* now align the stem */
/* this should not happen, but it's better to be safe */
/* we want to compare several displacement, and choose
/* note: don't even try to fit tiny stems */
/* if the span is within a single pixel, don't touch it */
/* we want to avoid the absolute worst case which is
/* snapping the left edge to the grid */
/* snapping the right edge to the grid */
/* now find the best displacement */
/* make sure that lowercase m's maintain their symmetry */
/* In general, lowercase m's have six vertical edges if they are sans */
/* serif, or twelve if they are with serifs.  This implementation is  */
/* based on that assumption, and seems to work very well with most    */
/* faces.  However, if for a certain face this assumption is not      */
/* true, the m is just rendered like before.  In addition, any stem   */
/* correction will only be applied to symmetrical glyphs (even if the */
/* glyph is not an m), so the potential for unwanted distortion is    */
/* relatively low.                                                    */
/* We don't handle horizontal edges since we can't easily assure that */
/* the third (lowest) stem aligns with the base line; it might end up */
/* one pixel higher or lower.                                         */
/* move the serifs along with the stem */
/*
/* analyze glyph outline */
/* grid-fit the outline */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****              L A T I N   S C R I P T   C L A S S              *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\autofit\afloader.c
/***************************************************************************/
/*                                                                         */
/*  afloader.c                                                             */
/*                                                                         */
/*    Auto-fitter glyph loading routines (body).                           */
/*                                                                         */
/*  Copyright 2003-2009, 2011-2014 by                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* Initialize glyph loader. */
/* Reset glyph loader and compute globals if necessary. */
/* Finalize glyph loader. */
/* Load a single glyph component.  This routine calls itself */
/* recursively, if necessary, and does the main work of      */
/* `af_loader_load_glyph.'                                   */
/* translate the loaded glyph when an internal transform is needed */
/* copy the outline points in the loader's current                */
/* extra points which are used to keep original glyph coordinates */
/* compute original horizontal phantom points (and ignore */
/* vertical ones)                                         */
/* be sure to check for spacing glyphs */
/* now load the slot image into the auto-outline and run the */
/* automatic hinting process                                 */
/* we now need to adjust the metrics according to the change in */
/* width/positioning that occurred during the hinting process   */
/* leftmost edge  */
/* rightmost edge */
/* remember unhinted values to later account */
/* for rounding errors                       */
/* prefer too much space over too little space */
/* for very small sizes                        */
/* good, we simply add the glyph to our loader's base */
/* first of all, copy the subglyph descriptors in the glyph loader */
/* now read each subglyph independently */
/* gloader.current.subglyphs can change during glyph loading due */
/* to re-allocation -- we must recompute the current subglyph on */
/* each iteration                                                */
/* recompute subglyph pointer */
/* now perform the transformation required for this subglyph */
/* apply offset */
/* for now, only use the current point coordinates; */
/* we eventually may consider another approach      */
/* we don't support other formats (yet?) */
/* transform the hinted outline if needed */
/* we must translate our final outline by -pp1.x and compute */
/* the new metrics                                           */
/* for mono-width fonts (like Andale, Courier, etc.) we need */
/* to keep the original rounded advance width; ditto for     */
/* digits if all have the same advance width                 */
/* Set delta values to 0.  Otherwise code that uses them is */
/* going to ruin the fixed advance width.                   */
/* non-spacing glyphs must stay as-is */
/* now copy outline into glyph slot */
/* reassign all outline fields except flags to protect them */
/* Load a glyph. */
/* XXX: TODO: add support for sub-pixel hinting */
/* XXX: TODO: add support for sub-pixel hinting */
/* XXX: fix this */
/* XXX: undocumented hook to activate the latin2 writing system */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\autofit\afmodule.c
/***************************************************************************/
/*                                                                         */
/*  afmodule.c                                                             */
/*                                                                         */
/*    Auto-fitter module implementation (body).                            */
/*                                                                         */
/*  Copyright 2003-2006, 2009, 2011-2014 by                                */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* trigger computation of the global style data */
/* in case it hasn't been done yet              */
/* We translate the fallback script to a fallback style that uses */
/* `fallback-script' as its script and `AF_COVERAGE_NONE' as its  */
/* coverage value.                                                */
/* AF_SERVICES_GET dereferences `library' in PIC mode */
/* AF_Module */
/* AF_Module */
/* reset_face */
/* get_global_hints */
/* done_global_hints */
/* load_glyph */
/* version 1.0 of the autofitter  */
/* requires FreeType 2.0 or above */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\autofit\afpic.c
/***************************************************************************/
/*                                                                         */
/*  afpic.c                                                                */
/*                                                                         */
/*    The FreeType position independent code services for autofit module.  */
/*                                                                         */
/*  Copyright 2009-2014 by                                                 */
/*  Oran Agra and Mickey Gabel.                                            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* forward declaration of PIC init functions from afmodule.c */
/* forward declaration of PIC init functions from writing system classes */
/* empty */
/* allocate pointer, clear and set global container pointer */
/* initialize pointer table -                       */
/* this is how the module usually expects this data */
/* FT_CONFIG_OPTION_PIC */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\autofit\afranges.c
/***************************************************************************/
/*                                                                         */
/*  afranges.c                                                             */
/*                                                                         */
/*    Auto-fitter Unicode script ranges (body).                            */
/*                                                                         */
/*  Copyright 2013, 2014 by                                                */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* Cyrillic            */
/* Cyrillic Supplement */
/* Cyrillic Extended-A */
/* Cyrillic Extended-B */
/* there are some characters in the Devanagari Unicode block that are    */
/* generic to Indic scripts; we omit them so that their presence doesn't */
/* trigger Devanagari                                                    */
/* Devanagari       */
/* omitting U+093C nukta */
/* omitting U+0951 udatta, U+0952 anudatta */
/* omitting U+0964 danda, U+0965 double danda */
/* (new) Rupee sign */
/* Greek and Coptic */
/* Greek Extended   */
/* Hebrew                          */
/* Alphab. Present. Forms (Hebrew) */
/* Basic Latin (no control chars)         */
/* Latin-1 Supplement (no control chars)  */
/* Latin Extended-A                       */
/* Latin Extended-B                       */
/* IPA Extensions                         */
/* Spacing Modifier Letters               */
/* Combining Diacritical Marks            */
/* Phonetic Extensions                    */
/* Phonetic Extensions Supplement         */
/* Combining Diacritical Marks Supplement */
/* Latin Extended Additional              */
/* General Punctuation                    */
/* Superscripts and Subscripts            */
/* Currency Symbols ...                   */
/* ... except new Rupee sign              */
/* Number Forms                           */
/* Enclosed Alphanumerics                 */
/* Latin Extended-C                       */
/* Supplemental Punctuation               */
/* Latin Extended-D                       */
/* Alphab. Present. Forms (Latin Ligs)    */
/* Mathematical Alphanumeric Symbols      */
/* Enclosed Alphanumeric Supplement       */
/* Telugu */
/* Bengali */
/* Gujarati */
/* Gurmukhi */
/* Kannada */
/* Limbu */
/* Malayalam */
/* Oriya */
/* Sinhala */
/* Sundanese */
/* Syloti Nagri */
/* Tamil */
/* Tibetan */
/* !AF_CONFIG_OPTION_INDIC */
/* this corresponds to Unicode 6.0 */
/* Hangul Jamo                             */
/* CJK Radicals Supplement                 */
/* Kangxi Radicals                         */
/* Ideographic Description Characters      */
/* CJK Symbols and Punctuation             */
/* Hiragana                                */
/* Katakana                                */
/* Bopomofo                                */
/* Hangul Compatibility Jamo               */
/* Kanbun                                  */
/* Bopomofo Extended                       */
/* CJK Strokes                             */
/* Katakana Phonetic Extensions            */
/* Enclosed CJK Letters and Months         */
/* CJK Compatibility                       */
/* CJK Unified Ideographs Extension A      */
/* Yijing Hexagram Symbols                 */
/* CJK Unified Ideographs                  */
/* Hangul Jamo Extended-A                  */
/* Hangul Syllables                        */
/* Hangul Jamo Extended-B                  */
/* CJK Compatibility Ideographs            */
/* Vertical forms                          */
/* CJK Compatibility Forms                 */
/* Halfwidth and Fullwidth Forms           */
/* Kana Supplement                         */
/* Tai Xuan Hing Symbols                   */
/* Enclosed Ideographic Supplement         */
/* CJK Unified Ideographs Extension B      */
/* CJK Unified Ideographs Extension C      */
/* CJK Unified Ideographs Extension D      */
/* CJK Compatibility Ideographs Supplement */
/* !AF_CONFIG_OPTION_CJK */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\autofit\afwarp.c
/***************************************************************************/
/*                                                                         */
/*  afwarp.c                                                               */
/*                                                                         */
/*    Auto-fitter warping algorithm (body).                                */
/*                                                                         */
/*  Copyright 2006, 2007, 2011 by                                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* The weights cover the range 0/64 - 63/64 of a pixel.  Obviously, */
/* values around a half pixel (which means exactly between two grid */
/* lines) gets the worst weight.                                    */
/* Score segments for a given `scale' and `delta' in the range */
/* `xx1' to `xx2', and store the best result in `warper'.  If  */
/* the new best score is equal to the old one, prefer the      */
/* value with a smaller distortion (around `base_distort').    */
/* compute minimum and maximum indices */
/* score the length of the segments for the given range */
/* find best score */
/* Compute optimal scaling and delta values for a given glyph and */
/* dimension.                                                     */
/* get original scaling transformation */
/* get X1 and X2, minimum and maximum in original coordinates */
/* examine a half pixel wide range around the maximum coordinates */
/* examine (at most) a pixel wide range around the natural width */
/* some heuristics to reduce the number of widths to be examined */
/* no scaling, just translation */
/* compute min and max positions for given width,       */
/* assuring that they stay within the coordinate ranges */
/* give base distortion a greater weight while scoring */
/* !AF_CONFIG_OPTION_USE_WARPER */
/* ANSI C doesn't like empty source files */
/* !AF_CONFIG_OPTION_USE_WARPER */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\autofit\autofit.c
/***************************************************************************/
/*                                                                         */
/*  autofit.c                                                              */
/*                                                                         */
/*    Auto-fitter module (body).                                           */
/*                                                                         */
/*  Copyright 2003-2007, 2011, 2013 by                                     */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\autofit\hbshim.c
/***************************************************************************/
/*                                                                         */
/*  hbshim.c                                                               */
/*                                                                         */
/*    HarfBuzz interface for accessing OpenType features (body).           */
/*                                                                         */
/*  Copyright 2013, 2014 by                                                */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*
/* load coverage tags */
/* define mapping between coverage tags and AF_Coverage */
/* AF_COVERAGE_DEFAULT */
/* load HarfBuzz script tags */
/* GSUB lookups for a given script */
/* glyphs covered by GSUB lookups  */
/* GPOS lookups for a given script */
/* glyphs covered by GPOS lookups  */
/* Convert a HarfBuzz script tag into the corresponding OpenType */
/* tag or tags -- some Indic scripts like Devanagari have an old */
/* and a new set of features.                                    */
/* `hb_ot_tags_from_script' usually returns HB_OT_TAG_DEFAULT_SCRIPT */
/* as the second tag.  We change that to HB_TAG_NONE except for the  */
/* default script.                                                   */
/* nothing to do */
/* get output coverage of GSUB feature */
/* get input coverage of GPOS feature */
/*
/*
/* glyph indices returned by `hb_ot_layout_lookup_collect_glyphs' */
/* can be arbitrary: some fonts use fake indices for processing   */
/* internal to GSUB or GPOS, which is fully valid                 */
/* construct HarfBuzz features */
/* define mapping between HarfBuzz features and AF_Coverage */
/* AF_COVERAGE_DEFAULT */
/* we shape at a size of units per EM; this means font units */
/* XXX: is this sufficient for a single character of any script? */
/* we add one character to `buf' ... */
/* ... and apply one feature */
/* getting the same index indicates no substitution,         */
/* which means that the glyph isn't available in the feature */
/* !FT_CONFIG_OPTION_USE_HARFBUZZ */
/* !FT_CONFIG_OPTION_USE_HARFBUZZ */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\basepic.c
/***************************************************************************/
/*                                                                         */
/*  basepic.c                                                              */
/*                                                                         */
/*    The FreeType position independent code services for base.            */
/*                                                                         */
/*  Copyright 2009, 2012, 2013 by                                          */
/*  Oran Agra and Mickey Gabel.                                            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* forward declaration of PIC init functions from ftglyph.c */
/* forward declaration of PIC init function from ftrfork.c */
/* (not modularized)                                       */
/* forward declaration of PIC init functions from ftinit.c */
/* destroy default module classes            */
/* (in case FT_Add_Default_Modules was used) */
/* allocate pointer, clear and set global container pointer */
/* initialize default modules list and pointers */
/* initialize pointer table -                       */
/* this is how the module usually expects this data */
/* FT_CONFIG_OPTION_PIC */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftadvanc.c
/***************************************************************************/
/*                                                                         */
/*  ftadvanc.c                                                             */
/*                                                                         */
/*    Quick computation of advance widths (body).                          */
/*                                                                         */
/*  Copyright 2008, 2009, 2011, 2013, 2014 by                              */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* this must be the same scaling as to get linear{Hori,Vert}Advance */
/* (see `FT_Load_Glyph' implementation in src/base/ftobjs.c)        */
/* at the moment, we can perform fast advance retrieval only in */
/* the following cases:                                         */
/*                                                              */
/*  - unscaled load                                             */
/*  - unhinted load                                             */
/*  - light-hinted load                                         */
/* documentation is in ftadvanc.h */
/* documentation is in ftadvanc.h */
/* scale from 26.6 to 16.16 */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftapi.c
/***************************************************************************/
/*                                                                         */
/*  ftapi.c                                                                */
/*                                                                         */
/*    The FreeType compatibility functions (body).                         */
/*                                                                         */
/*  Copyright 2002 by                                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                                                                 ****/
/****                 C O M P A T I B I L I T Y                       ****/
/****                                                                 ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* backwards compatibility API */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftbase.c
/***************************************************************************/
/*                                                                         */
/*  ftbase.c                                                               */
/*                                                                         */
/*    Single object library component (body only).                         */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2006, 2007, 2008, 2009 by       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftbbox.c
/***************************************************************************/
/*                                                                         */
/*  ftbbox.c                                                               */
/*                                                                         */
/*    FreeType bbox computation (body).                                    */
/*                                                                         */
/*  Copyright 1996-2002, 2004, 2006, 2010, 2013, 2014 by                   */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used        */
/*  modified and distributed under the terms of the FreeType project       */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* This component has a _single_ role: to compute exact outline bounding */
/* boxes.                                                                */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    BBox_Move_To                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    This function is used as a `move_to' emitter during                */
/*    FT_Outline_Decompose().  It simply records the destination point   */
/*    in `user->last'. We also update bbox in case contour starts with   */
/*    an implicit `on' point.                                            */
/*                                                                       */
/* <Input>                                                               */
/*    to   :: A pointer to the destination vector.                       */
/*                                                                       */
/* <InOut>                                                               */
/*    user :: A pointer to the current walk context.                     */
/*                                                                       */
/* <Return>                                                              */
/*    Always 0.  Needed for the interface only.                          */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    BBox_Line_To                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    This function is used as a `line_to' emitter during                */
/*    FT_Outline_Decompose().  It simply records the destination point   */
/*    in `user->last'; no further computations are necessary because     */
/*    bbox already contains both explicit ends of the line segment.      */
/*                                                                       */
/* <Input>                                                               */
/*    to   :: A pointer to the destination vector.                       */
/*                                                                       */
/* <InOut>                                                               */
/*    user :: A pointer to the current walk context.                     */
/*                                                                       */
/* <Return>                                                              */
/*    Always 0.  Needed for the interface only.                          */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    BBox_Conic_Check                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Find the extrema of a 1-dimensional conic Bezier curve and update  */
/*    a bounding range.  This version uses direct computation, as it     */
/*    doesn't need square roots.                                         */
/*                                                                       */
/* <Input>                                                               */
/*    y1  :: The start coordinate.                                       */
/*                                                                       */
/*    y2  :: The coordinate of the control point.                        */
/*                                                                       */
/*    y3  :: The end coordinate.                                         */
/*                                                                       */
/* <InOut>                                                               */
/*    min :: The address of the current minimum.                         */
/*                                                                       */
/*    max :: The address of the current maximum.                         */
/*                                                                       */
/* This function is only called when a control off-point is outside */
/* the bbox that contains all on-points.  It finds a local extremum */
/* within the segment, equal to (y1*y3 - y2*y2)/(y1 - 2*y2 + y3).   */
/* Or, offsetting from y2, we get                                   */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    BBox_Conic_To                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    This function is used as a `conic_to' emitter during               */
/*    FT_Outline_Decompose().  It checks a conic Bezier curve with the   */
/*    current bounding box, and computes its extrema if necessary to     */
/*    update it.                                                         */
/*                                                                       */
/* <Input>                                                               */
/*    control :: A pointer to a control point.                           */
/*                                                                       */
/*    to      :: A pointer to the destination vector.                    */
/*                                                                       */
/* <InOut>                                                               */
/*    user    :: The address of the current walk context.                */
/*                                                                       */
/* <Return>                                                              */
/*    Always 0.  Needed for the interface only.                          */
/*                                                                       */
/* <Note>                                                                */
/*    In the case of a non-monotonous arc, we compute directly the       */
/*    extremum coordinates, as it is sufficiently fast.                  */
/*                                                                       */
/* in case `to' is implicit and not included in bbox yet */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    BBox_Cubic_Check                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Find the extrema of a 1-dimensional cubic Bezier curve and         */
/*    update a bounding range.  This version uses iterative splitting    */
/*    because it is faster than the exact solution with square roots.    */
/*                                                                       */
/* <Input>                                                               */
/*    p1  :: The start coordinate.                                       */
/*                                                                       */
/*    p2  :: The coordinate of the first control point.                  */
/*                                                                       */
/*    p3  :: The coordinate of the second control point.                 */
/*                                                                       */
/*    p4  :: The end coordinate.                                         */
/*                                                                       */
/* <InOut>                                                               */
/*    min :: The address of the current minimum.                         */
/*                                                                       */
/*    max :: The address of the current maximum.                         */
/*                                                                       */
/* This function finds a peak of a cubic segment if it is above 0    */
/* using iterative bisection of the segment, or returns 0.           */
/* The fixed-point arithmetic of bisection is inherently stable      */
/* but may loose accuracy in the two lowest bits.  To compensate,    */
/* we upscale the segment if there is room.  Large values may need   */
/* to be downscaled to avoid overflows during bisection.             */
/* It is called with either q2 or q3 positive, which is necessary    */
/* for the peak to exist and avoids undefined FT_MSB.                */
/* upscaling too much just wastes time */
/* for a peak to exist above 0, the cubic segment must have */
/* at least one of its control off-points above 0.          */
/* determine which half contains the maximum and split */
/* first half */
/* second half */
/* check whether either end reached the maximum */
/* This function is only called when a control off-point is outside  */
/* the bbox that contains all on-points.  So at least one of the     */
/* conditions below holds and cubic_peak is called with at least one */
/* non-zero argument.                                                */
/* now flip the signs to update the minimum */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    BBox_Cubic_To                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    This function is used as a `cubic_to' emitter during               */
/*    FT_Outline_Decompose().  It checks a cubic Bezier curve with the   */
/*    current bounding box, and computes its extrema if necessary to     */
/*    update it.                                                         */
/*                                                                       */
/* <Input>                                                               */
/*    control1 :: A pointer to the first control point.                  */
/*                                                                       */
/*    control2 :: A pointer to the second control point.                 */
/*                                                                       */
/*    to       :: A pointer to the destination vector.                   */
/*                                                                       */
/* <InOut>                                                               */
/*    user     :: The address of the current walk context.               */
/*                                                                       */
/* <Return>                                                              */
/*    Always 0.  Needed for the interface only.                          */
/*                                                                       */
/* <Note>                                                                */
/*    In the case of a non-monotonous arc, we don't compute directly     */
/*    extremum coordinates, we subdivide instead.                        */
/*                                                                       */
/* We don't need to check `to' since it is always an on-point,    */
/* thus within the bbox.  Only segments with an off-point outside */
/* the bbox can possibly reach new extreme values.                */
/* documentation is in ftbbox.h */
/* if outline is empty, return (0,0,0,0) */
/* We compute the control box as well as the bounding box of  */
/* all `on' points in the outline.  Then, if the two boxes    */
/* coincide, we exit immediately.                             */
/* test two boxes for equality */
/* the two boxes are different, now walk over the outline to */
/* get the Bezier arc extrema.                               */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftbdf.c
/***************************************************************************/
/*                                                                         */
/*  ftbdf.c                                                                */
/*                                                                         */
/*    FreeType API for accessing BDF-specific strings (body).              */
/*                                                                         */
/*  Copyright 2002-2004, 2013, 2014 by                                     */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* documentation is in ftbdf.h */
/* documentation is in ftbdf.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftbitmap.c
/***************************************************************************/
/*                                                                         */
/*  ftbitmap.c                                                             */
/*                                                                         */
/*    FreeType utility functions for bitmaps (body).                       */
/*                                                                         */
/*  Copyright 2004-2009, 2011, 2013, 2014 by                               */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* documentation is in ftbitmap.h */
/* documentation is in ftbitmap.h */
/* take care of bitmap flow */
/* Enlarge `bitmap' horizontally and vertically by `xpixels' */
/* and `ypixels', respectively.                              */
/* if no need to allocate memory */
/* zero the padding */
/* otherwise allocate new buffer */
/* new rows get added at the top of the bitmap, */
/* thus take care of the flow direction         */
/* set pitch only, width and height are left untouched */
/* documentation is in ftbitmap.h */
/* convert to 8bpp */
/* We don't embolden color glyphs. */
/* take care of bitmap flow */
/* for each row */
/*
/* the maximum value of 8 for `xstr' comes from here */
/*
/* Short-circuit transparent color to avoid division by zero. */
/*
//accessibility.kde.org/hsl-adjusted.php
/* 0.0722 * 65536 */ * bgra[0] * bgra[0] +
/* 0.7152 * 65536 */ * bgra[1] * bgra[1] +
/* 0.2126 * 65536 */ * bgra[2] * bgra[2] ) >> 16;
/*
/* documentation is in ftbitmap.h */
/* take care of bitmap flow */
/* get the full bytes */
/* avoid a byte->int cast on each line */
/* get remaining pixels (if any) */
/* get the full bytes */
/* get the full bytes */
/* documentation is in ftbitmap.h */
/* documentation is in ftbitmap.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftcalc.c
/***************************************************************************/
/*                                                                         */
/*  ftcalc.c                                                               */
/*                                                                         */
/*    Arithmetic computations (body).                                      */
/*                                                                         */
/*  Copyright 1996-2006, 2008, 2012-2014 by                                */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* Support for 1-complement arithmetic has been totally dropped in this  */
/* release.  You can still write your own code if you need it.           */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* Implementing basic computation routines.                              */
/*                                                                       */
/* FT_MulDiv(), FT_MulFix(), FT_DivFix(), FT_RoundFix(), FT_CeilFix(),   */
/* and FT_FloorFix() are declared in freetype.h.                         */
/*                                                                       */
/*************************************************************************/
/* we need to emulate a 64-bit data type if a real one isn't available */
/* !FT_LONG64 */
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* transfer sign leaving a positive number */
/* The following three functions are available regardless of whether */
/* FT_LONG64 is defined.                                             */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* determine msb bit index in `shift' */
/* z     >>= 1; */
/* !FT_MSB */
/* documentation is in ftcalc.h */
/* documentation is in freetype.h */
/* documentation is in ftcalc.h */
/* documentation is in freetype.h */
/* FT_MULFIX_ASSEMBLER */
/* documentation is in freetype.h */
/* !FT_LONG64 */
/* Check carry overflow of i1 + i2 */
/* Check carry overflow of i1 + lo */
/* We shift as many bits as we can into the high register, perform     */
/* 32-bit division with modulo there, then work through the remaining  */
/* bits with long division. This optimization is especially noticeable */
/* for smaller dividends that barely use the high register.            */
/* left 64-bit shift */
/* remainder */
/* bits remaining in low register */
/*  The FT_MulDiv function has been optimized thanks to ideas from     */
/*  Graham Asher and Alexei Podtelezhnikov.  The trick is to optimize  */
/*  a rather common case when everything fits within 32-bits.          */
/*                                                                     */
/*  We compute 'a*b+c/2', then divide it by 'c' (all positive values). */
/*                                                                     */
/*  The product of two positive numbers never exceeds the square of    */
/*  its mean values.  Therefore, we always avoid the overflow by       */
/*  imposing                                                           */
/*                                                                     */
/*    (a + b) / 2 <= sqrt(X - c/2)    ,                                */
/*                                                                     */
/*  where X = 2^32 - 1, the maximum unsigned 32-bit value, and using   */
/*  unsigned arithmetic.  Now we replace `sqrt' with a linear function */
/*  that is smaller or equal for all values of c in the interval       */
/*  [0;X/2]; it should be equal to sqrt(X) and sqrt(3X/4) at the       */
/*  endpoints.  Substituting the linear solution and explicit numbers  */
/*  we get                                                             */
/*                                                                     */
/*    a + b <= 131071.99 - c / 122291.84    .                          */
/*                                                                     */
/*  In practice, we should use a faster and even stronger inequality   */
/*                                                                     */
/*    a + b <= 131071 - (c >> 16)                                      */
/*                                                                     */
/*  or, alternatively,                                                 */
/*                                                                     */
/*    a + b <= 129894 - (c >> 17)    .                                 */
/*                                                                     */
/*  FT_MulFix, on the other hand, is optimized for a small value of    */
/*  the first argument, when the second argument can be much larger.   */
/*  This can be achieved by scaling the second argument and the limit  */
/*  in the above inequalities.  For example,                           */
/*                                                                     */
/*    a + (b >> 8) <= (131071 >> 4)                                    */
/*                                                                     */
/*  covers the practical range of use. The actual test below is a bit  */
/*  tighter to avoid the border case overflows.                        */
/*                                                                     */
/*  In the case of FT_DivFix, the exact overflow check                 */
/*                                                                     */
/*    a << 16 <= X - c/2                                               */
/*                                                                     */
/*  is scaled down by 2^16 and we use                                  */
/*                                                                     */
/*    a <= 65535 - (c >> 17)    .                                      */
/* documentation is in freetype.h */
/* XXX: this function does not allow 64-bit arguments */
/* last attempt to ditch long division */
/* last attempt to ditch long division */
/* documentation is in freetype.h */
/*
/*
/* 0 */
/* 0 */
/* documentation is in freetype.h */
/* XXX: this function does not allow 64-bit arguments */
/* check for division by 0 */
/* compute result directly */
/* we need more bits; we have to do it by hand */
/* FT_LONG64 */
/* documentation is in ftglyph.h */
/* documentation is in ftglyph.h */
/* compute discriminant */
/* matrix can't be inverted */
/* documentation is in ftcalc.h */
/* documentation is in ftcalc.h */
/* documentation is in ftcalc.h */
/* 0 */
/* documentation is in ftcalc.h */
/* avoid overflow on 16-bit system */
/* deal with the trivial cases quickly */
/* general case */
/* XXX: this function does not allow 64-bit arguments */
/* XXX: only the sign of return value, +1/0/-1 must be used */
/* documentation is in ftcalc.h */
/* The idea of this function is to compare the length of the */
/* hypotenuse with the `in' and `out' length.  The `corner'  */
/* represented by `in' and `out' is flat if the hypotenuse's */
/* length isn't too large.                                   */
/*                                                           */
/* This approach has the advantage that the angle between    */
/* `in' and `out' is not checked.  In case one of the two    */
/* vectors is `dominant', this is, much larger than the      */
/* other vector, we thus always have a flat corner.          */
/*                                                           */
/*                hypotenuse                                 */
/*       x---------------------------x                       */
/*        \                      /                           */
/*         \                /                                */
/*      in  \          /  out                                */
/*           \    /                                          */
/*            o                                              */
/*              Point                                        */
/* now do a simple length comparison: */
/*                                    */
/*   d_in + d_out < 17/16 d_hypot     */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftcid.c
/***************************************************************************/
/*                                                                         */
/*  ftcid.c                                                                */
/*                                                                         */
/*    FreeType API for accessing CID font information.                     */
/*                                                                         */
/*  Copyright 2007, 2009, 2013 by Derek Clegg, Michael Toftdal.            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* documentation is in ftcid.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftdbgmem.c
/***************************************************************************/
/*                                                                         */
/*  ftdbgmem.c                                                             */
/*                                                                         */
/*    Memory debugger (body).                                              */
/*                                                                         */
/*  Copyright 2001-2006, 2009, 2013 by                                     */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* `Keep alive' means that freed blocks aren't released
/*
/* current number of allocated blocks */
/* max. number of allocated blocks    */
/* total number of blocks allocated   */
/* current cumulative allocated size */
/* maximum cumulative allocated size */
/* total cumulative allocated size   */
/* current maximum allocated size */
/*
/*
/* < 0 if the block was freed */
/*
/*
/* remove all blocks from the table, revealing leaked ones */
/* remove all sources */
/* cast to FT_PtrDist first since void* can be larger */
/* than FT_UInt32 and GCC 4.1.1 emits a warning       */
/* This block was already freed.  Our memory is now completely */
/* corrupted!                                                  */
/* This can only happen in keep-alive mode.                    */
/* This block was already allocated.  This means that our memory */
/* is also corrupted!                                            */
/* we need to create a new node in this table */
/* this is an allocation */
/* we are growing or shrinking a reallocated block */
/* we are allocating a new block */
/* scramble the node's content for additional safety */
/* we simply invert the node's size to indicate that the node */
/* was freed.                                                 */
/* return NULL if the maximum number of allocations was reached */
/* return NULL if this allocation would overflow the maximum heap size */
/* unlikely, but possible */
/* the following is valid according to ANSI C */
/* while the following is allowed in ANSI C also, we abort since */
/* such case should be handled by FreeType.                      */
/* check `cur_size' value */
/* return NULL if the maximum number of allocations was reached */
/* return NULL if this allocation would overflow the maximum heap size */
/* !FT_DEBUG_MEMORY */
/* ANSI C doesn't like empty source files */
/* !FT_DEBUG_MEMORY */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftdebug.c
/***************************************************************************/
/*                                                                         */
/*  ftdebug.c                                                              */
/*                                                                         */
/*    Debugging and logging component (body).                              */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2004, 2008, 2013 by                         */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* This component contains various macros and functions used to ease the */
/* debugging of the FreeType engine.  Its main purpose is in assertion   */
/* checking, tracing, and error detection.                               */
/*                                                                       */
/* There are now three debugging modes:                                  */
/*                                                                       */
/* - trace mode                                                          */
/*                                                                       */
/*   Error and trace messages are sent to the log file (which can be the */
/*   standard error output).                                             */
/*                                                                       */
/* - error mode                                                          */
/*                                                                       */
/*   Only error messages are generated.                                  */
/*                                                                       */
/* - release mode:                                                       */
/*                                                                       */
/*   No error message is sent or generated.  The code is free from any   */
/*   debugging parts.                                                    */
/*                                                                       */
/*************************************************************************/
/* documentation is in ftdebug.h */
/* documentation is in ftdebug.h */
/* documentation is in ftdebug.h */
/* FT_DEBUG_LEVEL_ERROR */
/* array of trace levels, initialized to 0 */
/* define array of trace toggle names */
/* documentation is in ftdebug.h */
/* documentation is in ftdebug.h */
/*************************************************************************/
/*                                                                       */
/* Initialize the tracing sub-system.  This is done by retrieving the    */
/* value of the `FT2_DEBUG' environment variable.  It must be a list of  */
/* toggles, separated by spaces, `;', or `,'.  Example:                  */
/*                                                                       */
/*    export FT2_DEBUG="any:3 memory:7 stream:5"                         */
/*                                                                       */
/* This requests that all levels be set to 3, except the trace level for */
/* the memory and stream components which are set to 7 and 5,            */
/* respectively.                                                         */
/*                                                                       */
/* See the file <include/internal/fttrace.h> for details of the          */
/* available toggle names.                                               */
/*                                                                       */
/* The level must be between 0 and 7; 0 means quiet (except for serious  */
/* runtime errors), and 7 means _very_ verbose.                          */
/*                                                                       */
/* skip leading whitespace and separators */
/* read toggle name, followed by ':' */
/* read level */
/* special case for `any' */
/* !FT_DEBUG_LEVEL_TRACE */
/* nothing */
/* !FT_DEBUG_LEVEL_TRACE */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftfstype.c
/***************************************************************************/
/*                                                                         */
/*  ftfstype.c                                                             */
/*                                                                         */
/*    FreeType utility file to access FSType data (body).                  */
/*                                                                         */
/*  Copyright 2008, 2009, 2014 by                                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* documentation is in freetype.h */
/* first, try to get the fs_type directly from the font */
/* look at FSType before fsType for Type42 */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftgasp.c
/***************************************************************************/
/*                                                                         */
/*  ftgasp.c                                                               */
/*                                                                         */
/*    Access of TrueType's `gasp' table (body).                            */
/*                                                                         */
/*  Copyright 2007 by                                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* ensure that we don't have spurious bits */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftgloadr.c
/***************************************************************************/
/*                                                                         */
/*  ftgloadr.c                                                             */
/*                                                                         */
/*    The FreeType glyph loader (body).                                    */
/*                                                                         */
/*  Copyright 2002-2006, 2010, 2013 by                                     */
/*  David Turner, Robert Wilhelm, and Werner Lemberg                       */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                                                               *****/
/*****                    G L Y P H   L O A D E R                    *****/
/*****                                                               *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The glyph loader is a simple object which is used to load a set of    */
/* glyphs easily.  It is critical for the correct loading of composites. */
/*                                                                       */
/* Ideally, one can see it as a stack of abstract `glyph' objects.       */
/*                                                                       */
/*   loader.base     Is really the bottom of the stack.  It describes a  */
/*                   single glyph image made of the juxtaposition of     */
/*                   several glyphs (those `in the stack').              */
/*                                                                       */
/*   loader.current  Describes the top of the stack, on which a new      */
/*                   glyph can be loaded.                                */
/*                                                                       */
/*   Rewind          Clears the stack.                                   */
/*   Prepare         Set up `loader.current' for addition of a new glyph */
/*                   image.                                              */
/*   Add             Add the `current' glyph image to the `base' one,    */
/*                   and prepare for another one.                        */
/*                                                                       */
/* The glyph loader is now a base object.  Each driver used to           */
/* re-implement it in one way or the other, which wasted code and        */
/* energy.                                                               */
/*                                                                       */
/*************************************************************************/
/* create a new glyph loader */
/* rewind the glyph loader - reset counters to 0 */
/* reset the glyph loader, frees all allocated tables */
/* and starts from zero                               */
/* delete a glyph loader */
/* re-adjust the `current' outline fields */
/* handle extra points table - if any */
/* re-adjust the `current' subglyphs field */
/* Ensure that we can add `n_points' and `n_contours' to our glyph.      */
/* This function reallocates its outline tables if necessary.  Note that */
/* it DOESN'T change the number of points within the loader!             */
/*                                                                       */
/* check points & tags */
/* check contours */
/* Ensure that we can add `n_subglyphs' to our glyph. this function */
/* reallocates its subglyphs table if necessary.  Note that it DOES */
/* NOT change the number of subglyphs within the loader!            */
/*                                                                  */
/* prepare loader for the addition of a new glyph on top of the base one */
/* add current glyph to the base image -- and prepare for another */
/* adjust contours count in newest outline */
/* prepare for another new glyph image */
/* do we need to copy the extra points? */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftglyph.c
/***************************************************************************/
/*                                                                         */
/*  ftglyph.c                                                              */
/*                                                                         */
/*    FreeType convenience functions to handle glyphs (body).              */
/*                                                                         */
/*  Copyright 1996-2005, 2007, 2008, 2010, 2012-2014 by                    */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/*  This file contains the definition of several convenience functions   */
/*  that can be used by client applications to easily retrieve glyph     */
/*  bitmaps and outlines from a given face.                              */
/*                                                                       */
/*  These functions should be optional if you are writing a font server  */
/*  or text layout engine on top of FreeType.  However, they are pretty  */
/*  handy for many other simple uses of the library.                     */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****   FT_BitmapGlyph support                                        ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/* do lazy copying whenever possible */
/* FT_Glyph_TransformFunc */
/* FT_Glyph_PrepareFunc   */
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****   FT_OutlineGlyph support                                       ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/* check format in glyph slot */
/* allocate new outline */
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****   FT_Glyph class and API                                        ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/* documentation is in ftglyph.h */
/* check arguments */
/* documentation is in ftglyph.h */
/* if it is a bitmap, that's easy :-) */
/* if it is an outline */
/* try to find a renderer that supports the glyph image format */
/* create FT_Glyph object */
/* copy advance while converting it to 16.16 format */
/* now import the image from the glyph slot */
/* if an error occurred, destroy the glyph */
/* documentation is in ftglyph.h */
/* transform glyph image */
/* transform advance vector */
/* documentation is in ftglyph.h */
/* retrieve bbox in 26.6 coordinates */
/* perform grid fitting if needed */
/* convert to integer pixels if needed */
/* documentation is in ftglyph.h */
/* FT_BITMAP_GLYPH_CLASS_GET dereferences `library' in PIC mode */
/* check argument */
/* when called with a bitmap glyph, do nothing and return successfully */
/* we render the glyph into a glyph bitmap using a `dummy' glyph slot */
/* then calling FT_Render_Glyph_Internal()                            */
/* create result bitmap glyph */
/* if `origin' is set, translate the glyph image */
/* prepare dummy slot for rendering */
/* in case of success, copy the bitmap to the glyph bitmap */
/* copy advance */
/* documentation is in ftglyph.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftgxval.c
/***************************************************************************/
/*                                                                         */
/*  ftgxval.c                                                              */
/*                                                                         */
/*    FreeType API for validating TrueTyepGX/AAT tables (body).            */
/*                                                                         */
/*  Copyright 2004-2006, 2010, 2013, 2014 by                               */
/*  Masatake YAMATO, Redhat K.K,                                           */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/* documentation is in ftgxval.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftinit.c
/***************************************************************************/
/*                                                                         */
/*  ftinit.c                                                               */
/*                                                                         */
/*    FreeType initialization layer (body).                                */
/*                                                                         */
/*  Copyright 1996-2002, 2005, 2007, 2009, 2012-2014 by                    */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/*  The purpose of this file is to implement the following two           */
/*  functions:                                                           */
/*                                                                       */
/*  FT_Add_Default_Modules():                                            */
/*     This function is used to add the set of default modules to a      */
/*     fresh new library object.  The set is taken from the header file  */
/*     `config/ftmodule.h'.  See the document `FreeType 2.0 Build        */
/*     System' for more information.                                     */
/*                                                                       */
/*  FT_Init_FreeType():                                                  */
/*     This function creates a system object for the current platform,   */
/*     builds a library out of it, then calls FT_Default_Drivers().      */
/*                                                                       */
/*  Note that even if FT_Init_FreeType() uses the implementation of the  */
/*  system object defined at build time, client applications are still   */
/*  able to provide their own `ftsystem.c'.                              */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* FT_CONFIG_OPTION_PIC */
/* declare the module's class creation/destruction functions */
/* count all module classes */
/* destroy all module classes */
/* initialize all module classes and the pointer table */
/* initialize all pointers to 0, especially the last one */
/* FT_CONFIG_OPTION_PIC */
/* documentation is in ftmodapi.h */
/* FT_DEFAULT_MODULES_GET dereferences `library' in PIC mode */
/* GCC 4.6 warns the type difference:
/* test for valid `library' delayed to FT_Add_Module() */
/* notify errors, but don't stop */
/* documentation is in freetype.h */
/* check of `alibrary' delayed to `FT_New_Library' */
/* First of all, allocate a new system object -- this function is part */
/* of the system-specific component, i.e. `ftsystem.c'.                */
/* build a library out of it, then fill it with the set of */
/* default drivers.                                        */
/* documentation is in freetype.h */
/* Discard the library object */
/* discard memory manager */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftlcdfil.c
/***************************************************************************/
/*                                                                         */
/*  ftlcdfil.c                                                             */
/*                                                                         */
/*    FreeType API for color filtering of subpixel bitmap glyphs (body).   */
/*                                                                         */
/*  Copyright 2006, 2008-2010, 2013, 2014 by                               */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* define USE_LEGACY to implement the legacy filter */
/* FIR filter used by the default and light filters */
/* horizontal in-place FIR filter */
/* take care of bitmap flow */
/* `fir' and `pix' must be at least 32 bit wide, since the sum of */
/* the values in `weights' can exceed 0xFF                        */
/* below, `pix' is used as the 5th element */
/* vertical in-place FIR filter */
/* take care of bitmap flow */
/* below, `pix' is used as the 5th element */
/* intra-pixel filter used by the legacy filter */
/* horizontal in-place intra-pixel filter */
/* take care of bitmap flow */
/* take care of bitmap flow */
/* USE_LEGACY */
/* the values here sum up to a value larger than 256, */
/* providing a cheap gamma correction                 */
/* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
/* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftmac.c
/***************************************************************************/
/*                                                                         */
/*  ftmac.c                                                                */
/*                                                                         */
/*    Mac FOND support.  Written by just@letterror.com.                    */
/*  Heavily modified by mpsuzuki, George Williams, and Sean McBride.       */
/*                                                                         */
/*  This file is for Mac OS X only; see builds/mac/ftoldmac.c for          */
/*  classic platforms built by MPW.                                        */
/*                                                                         */
/*  Copyright 1996-2009, 2013, 2014 by                                     */
/*  Just van Rossum, David Turner, Robert Wilhelm, and Werner Lemberg.     */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*
/* This is for Mac OS X.  Without redefinition, OS_INLINE */
/* expands to `static inline' which doesn't survive the   */
/* -ansi compilation flag of GCC.                         */
/* `configure' checks the availability of `ResourceIndex' strictly */
/* and sets HAVE_TYPE_RESOURCE_INDEX 1 or 0 always.  If it is      */
/* not set (e.g., a build without `configure'), the availability   */
/* is guessed from the SDK version.                                */
/* !HAVE_TYPE_RESOURCE_INDEX */
/* PATH_MAX */
/* Don't want warnings about our own use of deprecated functions. */
/* since Mac OS X 10.1 */
/* Set PREFER_LWFN to 1 if LWFN (Type 1) is preferred over
/* This function is deprecated because FSSpec is deprecated in Mac OS X  */
/* Private function.                                         */
/* The FSSpec type has been discouraged for a long time,     */
/* unfortunately an FSRef replacement API for                */
/* ATSFontGetFileSpecification() is only available in        */
/* Mac OS X 10.5 and later.                                  */
/* No 64bit Carbon API on legacy platforms */
/* 32bit Carbon API on legacy platforms */
/* face_index calculation by searching preceding fontIDs */
/* with same FSRef                                       */
/* This function is deprecated because FSSpec is deprecated in Mac OS X  */
/* at present, no support for dfont format */
/* fallback to original resource-fork font */
/* Return the file type for given pathname */
/* Given a PostScript font name, create the Macintosh LWFN file name. */
/* The count is 1 greater than the value in the FOND.  */
/* Isn't that cute? :-)                                */
/* Look inside the FOND data, answer whether there should be an SFNT
/* the maximum faces in a FOND is 48, size of StyleTable.indexes[] */
/* Let's do a little range checking before we get too excited here */
/* add on the face_index! */
/* if the face at this index is not scalable,
/* Pathname for FSRef can be in various formats: HFS, HFS+, and POSIX. */
/* We should not extract parent directory by string manipulation.      */
/* now we have absolute dirname in path_lwfn */
/* Read Type 1 data from the POST resources inside the LWFN file,
/* First pass: load all POST resources, and determine the size of */
/* the output buffer.                                             */
/* we are done */
/* just the end code */
/* code + 4 bytes chunk length */
/* detect integer overflows */
/* Second pass: append all POST data to the buffer, add PFB fields. */
/* Glue all consecutive chunks of the same type together.           */
/* we are done */
/* we are done adding a chunk, fill in the size field */
/* the end */
/* binary segment */
/* ASCII segment */
/* save for later */
/* make space for size field */
/* Create a new FT_Face from a file path to an LWFN file. */
/* PFB is already loaded, useless anymore */
/* Create a new FT_Face from an SFNT resource, specified by res ID. */
/* Create a new FT_Face from a file path to a suitcase file. */
/* documentation is in ftmac.h */
/* check of `library' and `aface' delayed to `FT_New_Face_From_XXX' */
/* Common function to load a new FT_Face from a resource file. */
/* LWFN is a (very) specific file format, check for it explicitly */
/* Otherwise the file type doesn't matter (there are more than  */
/* `FFIL' and `tfil').  Just try opening it as a font suitcase; */
/* if it works, fine.                                           */
/* let it fall through to normal loader (.ttf, .otf, etc.); */
/* we signal this by returning no error and no FT_Face      */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    FT_New_Face                                                        */
/*                                                                       */
/* <Description>                                                         */
/*    This is the Mac-specific implementation of FT_New_Face.  In        */
/*    addition to the standard FT_New_Face() functionality, it also      */
/*    accepts pathnames to Mac suitcase files.  For further              */
/*    documentation see the original FT_New_Face() in freetype.h.        */
/*                                                                       */
/* test for valid `library' and `aface' delayed to FT_Open_Face() */
/* try resourcefork based font: LWFN, FFIL */
/* let it fall through to normal loader (.ttf, .otf, etc.) */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    FT_New_Face_From_FSRef                                             */
/*                                                                       */
/* <Description>                                                         */
/*    FT_New_Face_From_FSRef is identical to FT_New_Face except it       */
/*    accepts an FSRef instead of a path.                                */
/*                                                                       */
/* This function is deprecated because Carbon data types (FSRef)         */
/* are not cross-platform, and thus not suitable for the freetype API.   */
/* check of `library' and `aface' delayed to */
/* `FT_New_Face_From_Resource'               */
/* fallback to datafork font */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    FT_New_Face_From_FSSpec                                            */
/*                                                                       */
/* <Description>                                                         */
/*    FT_New_Face_From_FSSpec is identical to FT_New_Face except it      */
/*    accepts an FSSpec instead of a path.                               */
/*                                                                       */
/* This function is deprecated because FSSpec is deprecated in Mac OS X  */
/* check of `library' and `aface' delayed to `FT_New_Face_From_FSRef' */
/* FT_MACINTOSH */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftmm.c
/***************************************************************************/
/*                                                                         */
/*  ftmm.c                                                                 */
/*                                                                         */
/*    Multiple Master font support (body).                                 */
/*                                                                         */
/*  Copyright 1996-2001, 2003, 2004, 2009, 2013, 2014 by                   */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* documentation is in ftmm.h */
/* check of `face' delayed to `ft_face_get_mm_service' */
/* documentation is in ftmm.h */
/* check of `face' delayed to `ft_face_get_mm_service' */
/* documentation is in ftmm.h */
/* check of `face' delayed to `ft_face_get_mm_service' */
/* documentation is in ftmm.h */
/* check of `face' delayed to `ft_face_get_mm_service' */
/* documentation is in ftmm.h */
/* check of `face' delayed to `ft_face_get_mm_service' */
/* documentation is in ftmm.h */
/* This is exactly the same as the previous function.  It exists for */
/* orthogonality.                                                    */
/* check of `face' delayed to `ft_face_get_mm_service' */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftobjs.c
/***************************************************************************/
/*                                                                         */
/*  ftobjs.c                                                               */
/*                                                                         */
/*    The FreeType private base classes (body).                            */
/*                                                                         */
/*  Copyright 1996-2014 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* for SFNT_Load_Table_Func */
/* Visual C++ (and Intel C++)   */
/* We disable the warning `conversion from XXX to YYY,     */
/* possible loss of data' in order to compile cleanly with */
/* the maximum level of warnings: `md5.c' is non-FreeType  */
/* code, and it gets used during development builds only.  */
/* _MSC_VER */
/* it's easiest to include `md5.c' directly */
/* FT_DEBUG_LEVEL_TRACE */
/* This function doesn't work!  None should call it. */
/* since the cast below also disables the compiler's */
/* type check, we introduce a dummy variable, which  */
/* will be optimized away                            */
/* throw away volatileness; use `jump_buffer' or the  */
/* compiler may warn about an unused local variable   */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                                                                 ****/
/****                           S T R E A M                           ****/
/****                                                                 ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* create a new input stream from an FT_Open_Args structure */
/*                                                          */
/* create a memory-based stream */
/* create a normal system stream */
/* use an existing, user-provided stream */
/* in this case, we do not need to allocate a new stream object */
/* since the caller is responsible for closing it himself       */
/* just to be certain */
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                                                                 ****/
/****               FACE, SIZE & GLYPH SLOT OBJECTS                   ****/
/****                                                                 ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* assume that the bitmap buffer was stolen or not */
/* allocated from the heap                         */
/* free bitmap if needed */
/* clear all public fields in the glyph slot */
/* `slot->bitmap.buffer' has been handled by ft_glyphslot_free_bitmap */
/* free bitmap buffer if needed */
/* slot->internal might be NULL in out-of-memory situations */
/* free glyph loader */
/* documentation is in ftobjs.h */
/* documentation is in ftobjs.h */
/* Remove slot from its parent face's list */
/* finalize client-specific data */
/* documentation is in freetype.h */
/* set transform_flags bit flag 0 if `matrix' isn't the identity */
/* set transform_flags bit flag 1 if `delta' isn't the null vector */
/* GRID_FIT_METRICS */
/* documentation is in freetype.h */
/* The validity test for `glyph_index' is performed by the */
/* font drivers.                                           */
/* resolve load flags dependencies */
/*
/* the check for `num_locations' assures that we actually    */
/* test for instructions in a TTF and not in a CFF-based OTF */
/*                                                           */
/* since `maxSizeOfInstructions' might be unreliable, we     */
/* check the size of the `fpgm' and `prep' tables, too --    */
/* the assumption is that there don't exist real TTFs where  */
/* both `fpgm' and `prep' tables are missing                 */
/* try to load embedded bitmaps first if available            */
/*                                                            */
/* XXX: This is really a temporary hack that should disappear */
/*      promptly with FreeType 2.1!                           */
/*                                                            */
/* since the auto-hinter calls FT_Load_Glyph by itself, */
/* make sure that glyphs aren't transformed             */
/* load auto-hinted outline */
/* check that the loaded outline is correct */
/* compute the advance */
/* compute the linear advance in 16.16 pixels */
/* it's tricky! */
/* now, transform the glyph image if needed */
/* get renderer */
/* apply `standard' transformation if no renderer is available */
/* transform advance */
/* do we need to render the image now? */
/* documentation is in freetype.h */
/* destructor for sizes list */
/* finalize client-specific data */
/* finalize format-specific stuff */
/* destructor for faces list */
/* discard auto-hinting data */
/* Discard glyph slots for this face.                           */
/* Beware!  FT_Done_GlyphSlot() changes the field `face->glyph' */
/* discard all sizes for this face */
/* now discard client data */
/* discard charmaps */
/* finalize format-specific stuff */
/* close the stream for this face if needed */
/* get rid of it */
/* check whether we need to drop the driver's glyph loader */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    find_unicode_charmap                                               */
/*                                                                       */
/* <Description>                                                         */
/*    This function finds a Unicode charmap, if there is one.            */
/*    And if there is more than one, it tries to favour the more         */
/*    extensive one, i.e., one that supports UCS-4 against those which   */
/*    are limited to the BMP (said UCS-2 encoding.)                      */
/*                                                                       */
/*    This function is called from open_face() (just below), and also    */
/*    from FT_Select_Charmap( ..., FT_ENCODING_UNICODE ).                */
/*                                                                       */
/* caller should have already checked that `face' is valid */
/*
/* Since the `interesting' table, with IDs (3,10), is normally the */
/* last one, we loop backwards.  This loses with type1 fonts with  */
/* non-BMP characters (<.0001%), this wins with .ttf with non-BMP  */
/* chars (.01% ?), and this is the same about 99.99% of the time!  */
/* points after the last one */
/* XXX If some new encodings to represent UCS-4 are added, */
/*     they should be added here.                          */
/* We do not have any UCS-4 charmap.                */
/* Do the loop again and search for UCS-2 charmaps. */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    find_variant_selector_charmap                                      */
/*                                                                       */
/* <Description>                                                         */
/*    This function finds the variant selector charmap, if there is one. */
/*    There can only be one (platform=0, specific=5, format=14).         */
/*                                                                       */
/* caller should have already checked that `face' is valid */
/* points after the last one */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    open_face                                                          */
/*                                                                       */
/* <Description>                                                         */
/*    This function does some work for FT_Open_Face().                   */
/*                                                                       */
/* allocate the face object and perform basic initialization */
/* set the FT_FACE_FLAG_EXTERNAL_STREAM bit for FT_Done_Face */
/* Stream may have been changed. */
/* select Unicode charmap by default */
/* if no Unicode charmap can be found, FT_Err_Invalid_CharMap_Handle */
/* is returned.                                                      */
/* no error should happen, but we want to play safe */
/* there's a Mac-specific extended implementation of FT_New_Face() */
/* in src/base/ftmac.c                                             */
/* documentation is in freetype.h */
/* test for valid `library' and `aface' delayed to `FT_Open_Face' */
/* documentation is in freetype.h */
/* test for valid `library' and `face' delayed to `FT_Open_Face' */
/* The behavior here is very similar to that in base/ftmac.c, but it     */
/* is designed to work on non-mac systems, so no mac specific calls.     */
/*                                                                       */
/* We look at the file and determine if it is a mac dfont file or a mac  */
/* resource file, or a macbinary file containing a mac resource file.    */
/*                                                                       */
/* Unlike ftmac I'm not going to look at a `FOND'.  I don't really see   */
/* the point, especially since there may be multiple `FOND' resources.   */
/* Instead I'll just look for `sfnt' and `POST' resources, ordered as    */
/* they occur in the file.                                               */
/*                                                                       */
/* Note that multiple `POST' resources do not mean multiple postscript   */
/* fonts; they all get jammed together to make what is essentially a     */
/* pfb file.                                                             */
/*                                                                       */
/* We aren't interested in `NFNT' or `FONT' bitmap resources.            */
/*                                                                       */
/* As soon as we get an `sfnt' load it into memory and pass it off to    */
/* FT_Open_Face.                                                         */
/*                                                                       */
/* If we have a (set of) `POST' resources, massage them into a (memory)  */
/* pfb file and pass that to FT_Open_Face.  (As with ftmac.c I'm not     */
/* going to try to save the kerning info.  After all that lives in the   */
/* `FOND' which isn't in the file containing the `POST' resources so     */
/* we don't really have access to it.                                    */
/* Finalizer for a memory stream; gets called by FT_Done_Face(). */
/* It frees the memory it uses.                                  */
/* From ftmac.c.                                                 */
/* Create a new memory stream from a buffer and a size. */
/* From ftmac.c.                                        */
/* Create a new FT_Face given a buffer and a driver name. */
/* from ftmac.c */
/* At this point, face_index has served its purpose;      */
/* whoever calls this function has already used it to     */
/* locate the correct font data.  We should not propagate */
/* this index to FT_Open_Face() (unless it is negative).  */
/* Look up `TYP1' or `CID ' table from sfnt table directory.       */
/* `offset' and `length' must exclude the binary header in tables. */
/* Type 1 and CID-keyed font drivers should recognize sfnt-wrapped */
/* format too.  Here, since we can't expect that the TrueType font */
/* driver is loaded unconditially, we must parse the font by       */
/* ourselves.  We are only interested in the name of the table and */
/* the offset.                                                     */
/* TODO: support for sfnt-wrapped PS/CID in TTC format */
/* version check for 'typ1' (should be ignored?) */
/* skip binary search header */
/* The resource header says we've got resource_cnt `POST' (type1) */
/* resources in this file.  They all need to be coalesced into    */
/* one lump which gets passed on to the type1 driver.             */
/* Here can be only one PostScript font in a file so face_index   */
/* must be 0 (or -1).                                             */
/*                                                                */
/* Find the length of all the POST resources, concatenated.  Assume */
/* worst case (each resource in its own section).                   */
/* FT2 allocator takes signed long buffer length,
/* Ascii section */
/* 4-byte length, fill in later */
/* FT2 allocator takes signed long buffer length,
/* postpone the check of rlen longer than buffer until FT_Stream_Read() */
/* Comment, should not be loaded */
/* the flags are part of the resource, so rlen >= 2.  */
/* but some fonts declare rlen = 0 for empty fragment */
/* End of font mark */
/* 4-byte length, fill in later */
/* The resource header says we've got resource_cnt `sfnt'      */
/* (TrueType/OpenType) resources in this file.  Look through   */
/* them for the one indicated by face_index, load it into mem, */
/* pass it on the the truetype driver and return it.           */
/*                                                             */
/* rewind sfnt stream before open_face_PS_from_sfnt_stream() */
/* Check for a valid resource fork header, or a valid dfont    */
/* header.  In a resource fork the first 16 bytes are repeated */
/* at the location specified by bytes 4-7.  In a dfont bytes   */
/* 4-7 point to 16 bytes of zeroes instead.                    */
/*                                                             */
/* POST resources must be sorted to concatenate properly */
/* POST exists in an LWFN providing a single face */
/* sfnt resources should not be sorted to preserve the face order by
/* Check for a valid macbinary header, and if we find one   */
/* check that the (flattened) resource fork in it is valid. */
/*                                                          */
/* 0 */
/* not tested */
/* Caller (load_mac_face) requires FT_Err_Unknown_File_Format. */
/* Check for some macintosh formats without Carbon framework.    */
/* Is this a macbinary file?  If so look at the resource fork.   */
/* Is this a mac dfont file?                                     */
/* Is this an old style resource fork? (in data)                 */
/* Else call load_face_in_embedded_rfork to try extra rules      */
/* (defined in `ftrfork.c').                                     */
/*                                                               */
/* !FT_MACINTOSH && FT_CONFIG_OPTION_MAC_FONTS */
/* documentation is in freetype.h */
/* test for valid `library' delayed to `FT_Stream_New' */
/* create input stream */
/* If the font driver is specified in the `args' structure, use */
/* it.  Otherwise, we scan the list of registered drivers.      */
/* not all modules are drivers, so check... */
/* check each font driver for an appropriate format */
/* not all modules are font drivers, so check... */
/* TrueType but essential tables are missing */
/* If we are on the mac, and we get an                          */
/* FT_Err_Invalid_Stream_Operation it may be because we have an */
/* empty data fork, so we need to check the resource fork.      */
/* We don't want to go to Success here.  We've already done that. */
/* On the other hand, if we succeeded we still need to close this */
/* stream (we opened a different stream which extracted the       */
/* interesting information out of this stream here.  That stream  */
/* will still be open and the face will point to it).             */
/* !FT_MACINTOSH && FT_CONFIG_OPTION_MAC_FONTS */
/* no driver is able to handle this format */
/* add the face object to its driver's list */
/* don't assume driver is the same as face->driver, so use */
/* face->driver instead.                                   */
/* now allocate a glyph slot object for the face */
/* finally, allocate a size object for the face */
/* some checks */
/* initialize internal face data */
/* face must be in the driver's list */
/* documentation is in freetype.h */
/* test for valid `face' delayed to `FT_Attach_Stream' */
/* documentation is in freetype.h */
/* test for valid `parameters' delayed to `FT_Stream_New' */
/* we implement FT_Attach_Stream in each driver through the */
/* `attach_file' interface                                  */
/* close the attached stream */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* find face in driver's list */
/* remove face object from the driver's list */
/* now destroy the object proper */
/* documentation is in ftobjs.h */
/* Allocate new size object and perform basic initialisation */
/* for now, do not use any internal fields in size objects */
/* in case of success, add to the face's list */
/* documentation is in ftobjs.h */
/* documentation is in ftobjs.h */
/* FT_Bitmap_Size doesn't provide enough info... */
/* documentation is in ftobjs.h */
/* compensate for glyph with bbox above/below the baseline */
/* the factor 1.2 is a heuristical value */
/* Compute root ascender, descender, test height, and max_advance */
/* !GRID_FIT_METRICS */
/* !GRID_FIT_METRICS */
/* to be on the safe side */
/* determine scales */
/* calculate the ppems */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/*
/* documentation is in freetype.h */
/* check of `face' delayed to `FT_Request_Size' */
/* documentation is in freetype.h */
/* check of `face' delayed to `FT_Request_Size' */
/* use `>=' to avoid potential compiler warning on 16bit platforms */
/* documentation is in freetype.h */
/* we scale down kerning values for small ppem values */
/* to avoid that rounding makes them too big.         */
/* `25' has been determined heuristically.            */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* FT_ENCODING_UNICODE is special.  We try to find the `best' Unicode */
/* charmap available, i.e., one with UCS-4 characters, if possible.   */
/*                                                                    */
/* This is done by find_unicode_charmap() above, to share code.       */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* remove it from our list of charmaps */
/* add it to our list of charmaps */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* only do something if we have a charmap, and we have glyphs at all */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* clean up buffer */
/* documentation is in freetype.h */
/* documentation is in tttables.h */
/* documentation is in tttables.h */
/* documentation is in tttables.h */
/* test for valid `length' delayed to `service->table_info' */
/* documentation is in tttables.h */
/* documentation is in tttables.h */
/* documentation is in ftsizes.h */
/* we don't need anything more complex than that; all size objects */
/* are already listed by the face                                  */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                                                                 ****/
/****                        R E N D E R E R S                        ****/
/****                                                                 ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* lookup a renderer by glyph format in the library's list */
/* allocate raster object if needed */
/* add to list */
/* release raster object, if any */
/* remove from list */
/* documentation is in ftrender.h */
/* test for valid `library' delayed to `FT_Lookup_Renderer' */
/* documentation is in ftrender.h */
/* if it is already a bitmap, no need to do anything */
/* already a bitmap, don't do anything */
/* small shortcut for the very common case */
/* FT_Err_Cannot_Render_Glyph is returned if the render mode   */
/* is unsupported by the current renderer for this glyph image */
/* format.                                                     */
/* now, look for another renderer that supports the same */
/* format.                                               */
/* if we changed the current renderer for the glyph image format */
/* we need to select it as the next current one                  */
/* we convert to a single bitmap format for computing the checksum */
/* this also converts the bitmap flow to `down' (i.e., pitch > 0) */
/* FT_DEBUG_LEVEL_TRACE */
/* documentation is in freetype.h */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                                                                 ****/
/****                         M O D U L E S                           ****/
/****                                                                 ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Destroy_Module                                                     */
/*                                                                       */
/* <Description>                                                         */
/*    Destroys a given module object.  For drivers, this also destroys   */
/*    all child faces.                                                   */
/*                                                                       */
/* <InOut>                                                               */
/*    module :: A handle to the target driver object.                    */
/*                                                                       */
/* <Note>                                                                */
/*    The driver _must_ be LOCKED!                                       */
/*                                                                       */
/* if the module is a renderer */
/* if the module is a font driver, add some steps */
/* finalize the module object */
/* discard it */
/* documentation is in ftmodapi.h */
/* check freetype version */
/* look for a module with the same name in the library's table */
/* this installed module has the same name, compare their versions */
/* remove the module from our list, then exit the loop to replace */
/* it by our new version..                                        */
/* allocate module object */
/* base initialization */
/* check whether the module is a renderer - this must be performed */
/* before the normal module initialization                         */
/* add to the renderers list */
/* is the module a auto-hinter? */
/* if the module is a font driver */
/* allocate glyph loader if needed */
/* add module to the library's table */
/* documentation is in ftmodapi.h */
/* documentation is in ftobjs.h */
/* test for valid `library' delayed to FT_Get_Module() */
/* first, look for the service in the module */
/* we didn't find it, look in all other modules then */
/* documentation is in ftmodapi.h */
/* try to find the module from the table, then remove it from there */
/* remove it from the table */
/* destroy the module */
/* search module */
/* check whether we have a service interface */
/* search property service */
/* documentation is in ftmodapi.h */
/* documentation is in ftmodapi.h */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                                                                 ****/
/****                         L I B R A R Y                           ****/
/****                                                                 ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* documentation is in ftmodapi.h */
/* documentation is in ftmodapi.h */
/* init debugging support */
/* first of all, allocate the library object */
/* initialize position independent code containers */
/* allocate the render pool */
/* That's ok now */
/* documentation is in freetype.h */
/* documentation is in ftmodapi.h */
/*
/* Close all other modules in the library */
/* XXX Modules are removed in the reversed order so that  */
/* type42 module is removed before truetype module.  This */
/* avoids double free in some occasions.  It is a hack.   */
/* Destroy raster objects */
/* Destroy pic container contents */
/* documentation is in ftmodapi.h */
/* documentation is in ftmodapi.h */
/* documentation is in freetype.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftotval.c
/***************************************************************************/
/*                                                                         */
/*  ftotval.c                                                              */
/*                                                                         */
/*    FreeType API for validating OpenType tables (body).                  */
/*                                                                         */
/*  Copyright 2004, 2006, 2008, 2010, 2013 by                              */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* documentation is in ftotval.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftoutln.c
/***************************************************************************/
/*                                                                         */
/*  ftoutln.c                                                              */
/*                                                                         */
/*    FreeType outline management (body).                                  */
/*                                                                         */
/*  Copyright 1996-2008, 2010, 2012-2014 by                                */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* All functions are declared in freetype.h.                             */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* documentation is in ftoutln.h */
/* index of contour in outline     */
/* index of first point in contour */
/* current point's state           */
/* index of last point in contour */
/* A contour cannot start with a cubic control point! */
/* check first point to determine origin */
/* first point is conic control.  Yes, this happens. */
/* start at last point if it is on the curve */
/* if both first and last points are conic,         */
/* start at their middle and record its position    */
/* for closure                                      */
/* v_last = v_start; */
/* emit a single line_to */
/* consume conic arcs */
/* FT_CURVE_TAG_CUBIC */
/* close the contour with a line segment */
/* documentation is in ftoutln.h */
/* documentation is in ftoutln.h */
/* empty glyph? */
/* check point and contour counts */
/* note that we don't accept empty contours */
/* XXX: check the tags array */
/* documentation is in ftoutln.h */
/* copy all flags, except the `FT_OUTLINE_OWNER' one */
/* documentation is in ftoutln.h */
/* check for valid `outline' in FT_Outline_Done_Internal() */
/* documentation is in ftoutln.h */
/* documentation is in ftoutln.h */
/* documentation is in ftoutln.h */
/* reverse point table */
/* reverse tags table */
/* documentation is in ftoutln.h */
/* FT_Err_Cannot_Render_Glyph is returned if the render mode   */
/* is unsupported by the current renderer for this glyph image */
/* format                                                      */
/* now, look for another renderer that supports the same */
/* format                                                */
/* if we changed the current renderer for the glyph image format */
/* we need to select it as the next current one                  */
/* documentation is in ftoutln.h */
/* other checks are delayed to `FT_Outline_Render' */
/* documentation is in freetype.h */
/* documentation is in ftoutln.h */
/* Is a point in some contour?                     */
/*                                                 */
/* We treat every point of the contour as if it    */
/* it were ON.  That is, we allow false positives, */
/* but disallow false negatives.  (XXX really?)    */
/* a and b are on the same side */
/* This version differs from the public one in that each */
/* part (contour not enclosed in another contour) of the */
/* outline is checked for orientation.  This is          */
/* necessary for some buggy CJK fonts.                   */
/* skip degenerate contours */
/* check the orientation of the contour */
/* 0 */
/* documentation is in ftoutln.h */
/* documentation is in ftoutln.h */
/* compute incoming normalized vector */
/* compute outgoing normalized vector */
/* shift only if turn is less than ~160 degrees */
/* shift components are aligned along lateral bisector */
/* and directed according to the outline orientation.  */
/* restrict shift magnitude to better handle collapsing segments */
/* non-strict inequalities avoid divide-by-zero when q == l == 0 */
/* documentation is in ftoutln.h */
/* We use the nonzero winding rule to find the orientation.       */
/* Since glyph outlines behave much more `regular' than arbitrary */
/* cubic or quadratic curves, this test deals with the polygon    */
/* only which is spanned up by the control points.                */
/* Handle collapsed outlines to avoid undefined FT_MSB. */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftpatent.c
/***************************************************************************/
/*                                                                         */
/*  ftpatent.c                                                             */
/*                                                                         */
/*    FreeType API for checking patented TrueType bytecode instructions    */
/*    (body).                                                              */
/*                                                                         */
/*  Copyright 2007, 2008, 2010 by David Turner.                            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
// */
/* SPvTL // */
/* SPvTL +  */
// */
/* SFvTL // */
/* SFvTL +  */
/* SPvFS    */
/* SFvFS    */
/* DELTAP2 */
/* DELTAP3 */
/* DELTAC0 */
/* DELTAC1 */
/* DELTAC2 */
/* simple glyph */
/* compound glyph */
/* now read each component */
/* ARGS_ARE_WORDS */
/* WE_HAVE_A_SCALE */
/* WE_HAVE_X_Y_SCALE */
/* WE_HAVE_A_2x2 */
/* WE_HAVE_INSTRUCTIONS */
/* MORE_COMPONENTS */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftpfr.c
/***************************************************************************/
/*                                                                         */
/*  ftpfr.c                                                                */
/*                                                                         */
/*    FreeType API for accessing PFR-specific data (body).                 */
/*                                                                         */
/*  Copyright 2002-2004, 2008, 2010, 2013, 2014 by                         */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* check the format */
/* documentation is in ftpfr.h */
/* this is not a PFR font */
/* documentation is in ftpfr.h */
/* documentation is in ftpfr.h */
/* XXX: TODO: PROVIDE ADVANCE-LOADING METHOD TO ALL FONT DRIVERS */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftpic.c
/***************************************************************************/
/*                                                                         */
/*  ftpic.c                                                                */
/*                                                                         */
/*    The FreeType position independent code services (body).              */
/*                                                                         */
/*  Copyright 2009, 2013 by                                                */
/*  Oran Agra and Mickey Gabel.                                            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* documentation is in ftpic.h */
/* Destroy the contents of the container. */
/* FT_CONFIG_OPTION_PIC */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftrfork.c
/***************************************************************************/
/*                                                                         */
/*  ftrfork.c                                                              */
/*                                                                         */
/*    Embedded resource forks accessor (body).                             */
/*                                                                         */
/*  Copyright 2004-2010, 2013, 2014 by                                     */
/*  Masatake YAMATO and Redhat K.K.                                        */
/*                                                                         */
/*  FT_Raccess_Get_HeaderInfo() and raccess_guess_darwin_hfsplus() are     */
/*  derived from ftobjs.c.                                                 */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/* Development of the code in this file is support of                      */
/* Information-technology Promotion Agency, Japan.                         */
/***************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                                                                 ****/
/****               Resource fork directory access                    ****/
/****                                                                 ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* map_len = head[12] .. head[15] */
/* make it be different */
/* If we have reached this point then it is probably a mac resource */
/* file.  Now, does it contain any interesting resources?           */
/* Skip handle to next resource map, the file resource number, and  */
/* attributes.                                                      */
/* skip handle to next resource map */
/* skip file resource number */
/* skip attributes */
/* resource name */
/* mbz */
/* XXX: duplicated reference ID,
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                                                                 ****/
/****                     Guessing functions                          ****/
/****                                                                 ****/
/****            When you add a new guessing function,                ****/
/****           update FT_RACCESS_N_RULES in ftrfork.h.               ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                       Helper functions                          ****/
/****                                                                 ****/
/*************************************************************************/
/*
/*
/*
/* filler */
/* offset + length */
/* !FT_CONFIG_OPTION_GUESSING_EMBEDDED_RFORK */
/*************************************************************************/
/*                  Dummy function; just sets errors                     */
/*************************************************************************/
/* !FT_CONFIG_OPTION_GUESSING_EMBEDDED_RFORK */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftsnames.c
/***************************************************************************/
/*                                                                         */
/*  ftsnames.c                                                             */
/*                                                                         */
/*    Simple interface to access SFNT name tables (which are used          */
/*    to hold font names, copyright info, notices, etc.) (body).           */
/*                                                                         */
/*    This is _not_ used to retrieve glyph names!                          */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2009 by                                     */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* documentation is in ftsnames.h */
/* documentation is in ftsnames.h */
/* load name on demand */
/* TT_CONFIG_OPTION_SFNT_NAMES */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftstream.c
/***************************************************************************/
/*                                                                         */
/*  ftstream.c                                                             */
/*                                                                         */
/*    I/O stream support (body).                                           */
/*                                                                         */
/*  Copyright 2000-2002, 2004-2006, 2008-2011, 2013 by                     */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* note that seeking to the first position after the file is valid */
/* equivalent to FT_Stream_ExitFrame(), with no memory block release */
/* check for nested frame access */
/* allocate the frame in memory */
/* simple sanity check */
/* assume _ft_debug_file and _ft_debug_lineno are already set */
/* read it */
/* check current and new position */
/* set cursor */
/* IMPORTANT: The assertion stream->cursor != 0 was removed, given    */
/*            that it is possible to access a frame of length 0 in    */
/*            some weird fonts (usually, when accessing an array of   */
/*            0 records, like in some strange kern tables).           */
/*                                                                    */
/*  In this case, the loader code handles the 0-length table          */
/*  gracefully; however, stream.cursor is really set to 0 by the      */
/*  FT_Stream_EnterFrame() call, and this is not an error.            */
/*                                                                    */
/* access a new frame */
/* loop! */
/* read a byte sequence */
/* skip some bytes      */
/* read a single byte */
/* read a 2-byte big-endian short */
/* read a 2-byte little-endian short */
/* read a 4-byte big-endian long */
/* read a 4-byte little-endian long */
/* read a 3-byte big-endian long */
/* read a 3-byte little-endian long */
/* otherwise, exit the loop */
/* now, compute the signed value is necessary */
/* finally, store the value in the object */
/* for 64-bit systems */
/* go to next field */
/* close the frame if it was opened by this read */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftstroke.c
/***************************************************************************/
/*                                                                         */
/*  ftstroke.c                                                             */
/*                                                                         */
/*    FreeType path stroker (body).                                        */
/*                                                                         */
/*  Copyright 2002-2006, 2008-2011, 2013, 2014 by                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* documentation is in ftstroke.h */
/* documentation is in ftstroke.h */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      BEZIER COMPUTATIONS                      *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* basically a point;                      */
/* do nothing to retain original direction */
/* !close1 */
/* Return the average of `angle1' and `angle2'.            */
/* This gives correct result even if `angle1' and `angle2' */
/* have opposite signs.                                    */
/* basically a point;                      */
/* do nothing to retain original direction */
/* !close3 */
/* !close2 */
/* !close3 */
/* !close1 */
/* !close3 */
/* !close2 */
/* !close3 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                       STROKE BORDERS                          *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* on-curve point  */
/* cubic off-point */
/* sub-path start  */
/* sub-path end    */
/* TRUE for ends of lineto borders */
/* index of current sub-path start point */
/* don't record empty paths! */
/* copy the last point to the start of this sub-path, since */
/* it contains the `adjusted' starting coordinates          */
/* reverse the points */
/* then the tags */
/* move last point */
/* don't add zero-length lineto */
/* add one point */
/* compute start point */
/* compute end point */
/* compute first and second control points */
/* add cubic arc */
/* process the rest of the arc ?? */
/* close current open path if any ? */
/* copy point locations */
/* copy tags */
/* copy contours */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                           STROKER                             *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* direction into curr join */
/* direction out of join  */
/* current position */
/* length of last lineto */
/* is this the start? */
/* is the subpath open? */
/* subpath start direction */
/* subpath start position */
/* subpath start lineto len */
/* use wide strokes logic? */
/* documentation is in ftstroke.h */
/* assigned in FT_NEW */
/* documentation is in ftstroke.h */
/* ensure miter limit has sensible value */
/* save line join style:                                           */
/* line join style can be temporarily changed when stroking curves */
/* documentation is in ftstroke.h */
/* documentation is in ftstroke.h */
/* create a circular arc at a corner or cap */
/* add a cap at the end of an opened path */
/* add a round cap */
/* add a square cap */
/* add a butt ending */
/* process an inside corner, i.e. compute intersection */
/* use intersection of lines? */
/* Only intersect borders if between two lineto's and both */
/* lines are long enough (line_length is zero for curves). */
/* compute minimum required length of lines */
/* compute median angle */
/* process an outside corner, i.e. compute bevel/miter/round */
/* this is a mitered (pointed) or beveled (truncated) corner */
/* is miter limit exceeded? */
/* don't create variable bevels for very small deviations; */
/* FT_Sin(x) = 0 for x <= 57                               */
/* this is a bevel (broken angle) */
/* the outer corners are simply joined together */
/* add bevel */
/* variable bevel */
/* the miter is truncated */
/* compute middle point */
/* compute first angle point */
/* compute second angle point */
/* finally, add an end point; only needed if not lineto */
/* (line_length is zero for curves)                     */
/* this is a miter (intersection) */
/* now add an end point; only needed if not lineto */
/* (line_length is zero for curves)                */
/* no specific corner processing is required if the turn is 0 */
/* when we turn to the right, the inside side is 0 */
/* otherwise, the inside side is 1 */
/* process the inside side */
/* process the outside side */
/* add two points to the left and right borders corresponding to the */
/* start of the subpath                                              */
/* save angle, position, and line length for last join */
/* (line_length is zero for curves)                    */
/* documentation is in ftstroke.h */
/* a zero-length lineto is a no-op; avoid creating a spurious corner */
/* compute length of line */
/* process corner if necessary */
/* This is the first segment of a subpath.  We need to     */
/* add a point to each border at their respective starting */
/* point locations.                                        */
/* process the current corner */
/* now add a line segment to both the `inside' and `outside' paths */
/* the ends of lineto borders are movable */
/* documentation is in ftstroke.h */
/* if all control points are coincident, this is a no-op; */
/* avoid creating a spurious corner                       */
/* initialize with current direction */
/* process corner if necessary */
/* if the deviation from one arc to the next is too great, */
/* add a round corner                                      */
/* reinstate line join style */
/* the arc's angle is small enough; we can add it directly to each */
/* border                                                          */
/* compute direction of original arc */
/* compute control point */
/* compute end point */
/* determine whether the border radius is greater than the */
/* radius of curvature of the original arc                 */
/* is the direction of the border arc opposite to */
/* that of the original arc? */
/* use the sine rule to find the intersection point */
/* circumnavigate the negative sector backwards */
/* and then move to the endpoint */
/* else fall through */
/* simply add an arc */
/* documentation is in ftstroke.h */
/* if all control points are coincident, this is a no-op; */
/* avoid creating a spurious corner */
/* initialize with current direction */
/* process corner if necessary */
/* if the deviation from one arc to the next is too great, */
/* add a round corner                                      */
/* reinstate line join style */
/* the arc's angle is small enough; we can add it directly to each */
/* border                                                          */
/* compute direction of original arc */
/* compute control points */
/* compute end point */
/* determine whether the border radius is greater than the */
/* radius of curvature of the original arc                 */
/* is the direction of the border arc opposite to */
/* that of the original arc? */
/* use the sine rule to find the intersection point */
/* circumnavigate the negative sector backwards */
/* and then move to the endpoint */
/* else fall through */
/* simply add an arc */
/* documentation is in ftstroke.h */
/* We cannot process the first point, because there is not enough      */
/* information regarding its corner/cap.  The latter will be processed */
/* in the `FT_Stroker_EndSubPath' routine.                             */
/*                                                                     */
/* Determine if we need to check whether the border radius is greater */
/* than the radius of curvature of a curve, to handle this case       */
/* specially.  This is only required if bevel joins or butt caps may  */
/* be created, because round & miter joins and round & square caps    */
/* cover the negative sector created with wide strokes.               */
/* record the subpath start point for each border */
/* switch begin/end tags if necessary */
/* documentation is in ftstroke.h */
/* there's a lot of magic in this function! */
/* All right, this is an opened path, we need to add a cap between */
/* right & left, add the reverse of left, then add a final cap     */
/* between left & right.                                           */
/* add reversed points from `left' to `right' */
/* now add the final cap */
/* Now end the right subpath accordingly.  The left one is */
/* rewind and doesn't need further processing.             */
/* close the path if needed */
/* process the corner */
/* no specific corner processing is required if the turn is 0 */
/* when we turn to the right, the inside side is 0 */
/* otherwise, the inside side is 1 */
/* process the outside side */
/* then end our two subpaths */
/* documentation is in ftstroke.h */
/* documentation is in ftstroke.h */
/* documentation is in ftstroke.h */
/* documentation is in ftstroke.h */
/* documentation is in ftstroke.h */
/*
/* index of contour in outline     */
/* index of first point in contour */
/* current point's state           */
/* index of last point in contour */
/* skip empty points; we don't stroke these */
/* A contour cannot start with a cubic control point! */
/* check first point to determine origin */
/* First point is conic control.  Yes, this happens. */
/* start at last point if it is on the curve */
/* if both first and last points are conic, */
/* start at their middle                    */
/* emit a single line_to */
/* consume conic arcs */
/* FT_CURVE_TAG_CUBIC */
/* don't try to end the path if no segments have been generated */
/* declare an extern to access `ft_outline_glyph_class' globally     */
/* allocated  in `ftglyph.c', and use the FT_OUTLINE_GLYPH_CLASS_GET */
/* macro to access it when FT_CONFIG_OPTION_PIC is defined           */
/* documentation is in ftstroke.h */
/* for FT_OUTLINE_GLYPH_CLASS_GET (in PIC mode) */
/* documentation is in ftstroke.h */
/* for FT_OUTLINE_GLYPH_CLASS_GET (in PIC mode) */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftsynth.c
/***************************************************************************/
/*                                                                         */
/*  ftsynth.c                                                              */
/*                                                                         */
/*    FreeType synthesizing code for emboldening and slanting (body).      */
/*                                                                         */
/*  Copyright 2000-2006, 2010, 2012-2014 by                                */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****   EXPERIMENTAL OBLIQUING SUPPORT                                ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/* documentation is in ftsynth.h */
/* only oblique outline glyphs */
/* we don't touch the advance width */
/* For italic, simply apply a shear transform, with an angle */
/* of about 12 degrees.                                      */
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****   EXPERIMENTAL EMBOLDENING SUPPORT                              ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/* documentation is in ftsynth.h */
/* some reasonable strength */
/* slot->format == FT_GLYPH_FORMAT_BITMAP */
/* round to full pixels */
/*
/* XXX: 16-bit overflow case must be excluded before here */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftsystem.c
/***************************************************************************/
/*                                                                         */
/*  ftsystem.c                                                             */
/*                                                                         */
/*    ANSI-specific FreeType low-level system interface (body).            */
/*                                                                         */
/*  Copyright 1996-2002, 2006, 2008-2011, 2013 by                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* This file contains the default interface used by FreeType to access   */
/* low-level, i.e. memory management, i/o access as well as thread       */
/* synchronisation.  It can be replaced by user-specific routines if     */
/* necessary.                                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/*                       MEMORY MANAGEMENT INTERFACE                     */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* It is not necessary to do any error checking for the                  */
/* allocation-related functions.  This will be done by the higher level  */
/* routines like ft_mem_alloc() or ft_mem_realloc().                     */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    ft_alloc                                                           */
/*                                                                       */
/* <Description>                                                         */
/*    The memory allocation function.                                    */
/*                                                                       */
/* <Input>                                                               */
/*    memory :: A pointer to the memory object.                          */
/*                                                                       */
/*    size   :: The requested size in bytes.                             */
/*                                                                       */
/* <Return>                                                              */
/*    The address of newly allocated block.                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    ft_realloc                                                         */
/*                                                                       */
/* <Description>                                                         */
/*    The memory reallocation function.                                  */
/*                                                                       */
/* <Input>                                                               */
/*    memory   :: A pointer to the memory object.                        */
/*                                                                       */
/*    cur_size :: The current size of the allocated memory block.        */
/*                                                                       */
/*    new_size :: The newly requested size in bytes.                     */
/*                                                                       */
/*    block    :: The current address of the block in memory.            */
/*                                                                       */
/* <Return>                                                              */
/*    The address of the reallocated memory block.                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    ft_free                                                            */
/*                                                                       */
/* <Description>                                                         */
/*    The memory release function.                                       */
/*                                                                       */
/* <Input>                                                               */
/*    memory  :: A pointer to the memory object.                         */
/*                                                                       */
/*    block   :: The address of block in memory to be freed.             */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/*                     RESOURCE MANAGEMENT INTERFACE                     */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* We use the macro STREAM_FILE for convenience to extract the       */
/* system-specific stream handle from a given FreeType stream object */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    ft_ansi_stream_close                                               */
/*                                                                       */
/* <Description>                                                         */
/*    The function to close a stream.                                    */
/*                                                                       */
/* <Input>                                                               */
/*    stream :: A pointer to the stream object.                          */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    ft_ansi_stream_io                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    The function to open a stream.                                     */
/*                                                                       */
/* <Input>                                                               */
/*    stream :: A pointer to the stream object.                          */
/*                                                                       */
/*    offset :: The position in the data stream to start reading.        */
/*                                                                       */
/*    buffer :: The address of buffer to store the read data.            */
/*                                                                       */
/*    count  :: The number of bytes to read from the stream.             */
/*                                                                       */
/* <Return>                                                              */
/*    The number of bytes actually read.  If `count' is zero (this is,   */
/*    the function is used for seeking), a non-zero return value         */
/*    indicates an error.                                                */
/*                                                                       */
/* documentation is in ftstream.h */
/* !FT_CONFIG_OPTION_DISABLE_STREAM_SUPPORT */
/* documentation is in ftobjs.h */
/* documentation is in ftobjs.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\fttrigon.c
/***************************************************************************/
/*                                                                         */
/*  fttrigon.c                                                             */
/*                                                                         */
/*    FreeType trigonometric functions (body).                             */
/*                                                                         */
/*  Copyright 2001-2005, 2012-2014 by                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* This is a fixed-point CORDIC implementation of trigonometric          */
/* functions as well as transformations between Cartesian and polar      */
/* coordinates.  The angles are represented as 16.16 fixed-point values  */
/* in degrees, i.e., the angular resolution is 2^-16 degrees.  Note that */
/* only vectors longer than 2^16*180/pi (or at least 22 bits) on a       */
/* discrete Cartesian grid can have the same or better angular           */
/* resolution.  Therefore, to maintain this precision, some functions    */
/* require an interim upscaling of the vectors, whereas others operate   */
/* with 24-bit long vectors directly.                                    */
/*                                                                       */
/*************************************************************************/
/* the Cordic shrink factor 0.858785336480436 * 2^32 */
/* the highest bit in overflow-safe vector components, */
/* MSB of 0.858785336480436 * sqrt(0.5) * 2^30         */
/* this table was generated for FT_PI = 180L << 16, i.e. degrees */
/* multiply a given value by the CORDIC shrink factor */
/* 0x40000000 comes from regression analysis between true */
/* and CORDIC hypotenuse, so it minimizes the error       */
/* !FT_LONG64 */
/* multiply a given value by the CORDIC shrink factor */
/* Check carry overflow of i1 + i2 */
/* Check carry overflow of i1 + lo */
/* 0x40000000 comes from regression analysis between true */
/* and CORDIC hypotenuse, so it minimizes the error       */
/* Check carry overflow of lo + 0x40000000 */
/* !FT_LONG64 */
/* undefined and never called for zero vector */
/* Rotate inside [-PI/4,PI/4] sector */
/* Pseudorotations, with right shifts */
/* Get the vector into [-PI/4,PI/4] sector */
/* Pseudorotations, with right shifts */
/* round theta to acknowledge its error that mostly comes */
/* from accumulated rounding errors in the arctan table   */
/* documentation is in fttrigon.h */
/* documentation is in fttrigon.h */
/* documentation is in fttrigon.h */
/* documentation is in fttrigon.h */
/* documentation is in fttrigon.h */
/* these macros return 0 for positive numbers,
/* documentation is in fttrigon.h */
/* documentation is in fttrigon.h */
/* handle trivial cases */
/* general case */
/* documentation is in fttrigon.h */
/* documentation is in fttrigon.h */
/* documentation is in fttrigon.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\fttype1.c
/***************************************************************************/
/*                                                                         */
/*  fttype1.c                                                              */
/*                                                                         */
/*    FreeType utility file for PS names support (body).                   */
/*                                                                         */
/*  Copyright 2002-2004, 2011, 2014 by                                     */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* documentation is in t1tables.h */
/* documentation is in t1tables.h */
/* documentation is in t1tables.h */
/* documentation is in t1tables.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftutil.c
/***************************************************************************/
/*                                                                         */
/*  ftutil.c                                                               */
/*                                                                         */
/*    FreeType utility file for memory and list management (body).         */
/*                                                                         */
/*  Copyright 2002, 2004-2007, 2013 by                                     */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                                                               *****/
/*****               M E M O R Y   M A N A G E M E N T               *****/
/*****                                                               *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* may help catch/prevent security issues */
/* Note that we now accept `item_size == 0' as a valid parameter, in
/* may help catch/prevent nasty security issues */
/* always zero-terminate */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                                                               *****/
/*****            D O U B L Y   L I N K E D   L I S T S              *****/
/*****                                                               *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* documentation is in ftlist.h */
/* documentation is in ftlist.h */
/* documentation is in ftlist.h */
/* documentation is in ftlist.h */
/* documentation is in ftlist.h */
/* check whether we are already on top of the list */
/* documentation is in ftlist.h */
/* documentation is in ftlist.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftwinfnt.c
/***************************************************************************/
/*                                                                         */
/*  ftwinfnt.c                                                             */
/*                                                                         */
/*    FreeType API for accessing Windows FNT specific info (body).         */
/*                                                                         */
/*  Copyright 2003, 2004, 2014 by                                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* documentation is in ftwinfnt.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\ftxf86.c
/***************************************************************************/
/*                                                                         */
/*  ftxf86.c                                                               */
/*                                                                         */
/*    FreeType utility file for X11 support (body).                        */
/*                                                                         */
/*  Copyright 2002, 2003, 2004 by                                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* documentation is in ftxf86.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\base\md5.c
/*
//openwall.info/wiki/people/solar/software/public-domain-source-code/md5
/*
/*
/*
/*
/* Round 1 */
/* Round 2 */
/* Round 3 */
/* Round 4 */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\bdf\bdf.c
/*  bdf.c
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\bdf\bdfdrivr.c
/*  bdfdrivr.c
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* ftobjs.h: FT_CMap->clazz->size */
/* num_encodings */
/* encodings->glyph */
/* increase glyph index by 1 --              */
/* we reserve slot 0 for the undefined glyph */
/* num_encodings */
/* encodings->glyph */
/* same as BDF_encoding_el.enc */
/* increase glyph index by 1 --              */
/* we reserve slot 0 for the undefined glyph */
/* XXX: result should be changed to indicate an overflow error */
/* separate elements with a space */
/* need to convert spaces to dashes for */
/* add_style_name and setwidth_name     */
/* BDF_Face */
/* BDF_Face */
/* FZ XXX: options semantics */
/* we have a bdf font: let's construct the face object */
/* BDF could not have multiple face in single font file.
/* FZ XXX: TO DO: FT_FACE_FLAGS_VERTICAL   */
/* FZ XXX: I need a font to implement this */
/* the number of glyphs (with one slot for the undefined glyph */
/* at position 0 and all unencoded glyphs)                     */
/* convert from 722.7 decipoints to 72 points per inch */
/* encoding table */
/* charmaps */
/* Uh, oh, compare first letters manually to avoid dependency */
/* on locales.                                                */
/* initial platform/encoding should indicate unset status? */
/* Select default charmap */
/* otherwise assume Adobe standard encoding */
/* Select default charmap */
/* index 0 is the undefined glyph */
/* slot, bitmap => freetype, glyph => bdflib */
/* same as FT_Bitmap.pitch */
/* note: we don't allocate a new array to hold the bitmap; */
/*       we can simply point to it                         */
/*
/*
/*
/* FT_Module_Constructor */
/* FT_Module_Destructor  */
/* FT_Size_InitFunc */
/* FT_Size_DoneFunc */
/* FT_Slot_InitFunc */
/* FT_Slot_DoneFunc */
/* FT_Face_GetKerningFunc  */
/* FT_Face_AttachFunc      */
/* FT_Face_GetAdvancesFunc */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\bdf\bdflib.c
/*
/*************************************************************************/
/*                                                                       */
/*  This file is based on bdf.c,v 1.22 2000/03/16 20:08:50               */
/*                                                                       */
/*  taken from Mark Leisher's xmbdfed package                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* Default BDF font options.                                             */
/*                                                                       */
/*************************************************************************/
/* Correct metrics.               */
/* Preserve unencoded glyphs.     */
/* Preserve comments.             */
/* Default spacing.               */
/*************************************************************************/
/*                                                                       */
/* Builtin BDF font properties.                                          */
/*                                                                       */
/*************************************************************************/
/* List of most properties that might appear in a font.  Doesn't include */
/* the RAW_* and AXIS_* properties in X11R6 polymorphic fonts.           */
/* An auxiliary macro to parse properties, to be used in conditionals. */
/* It behaves like `strncmp' but also tests the following character    */
/* whether it is a whitespace or NULL.                                 */
/* `property' is a constant string of length `n' to compare with.      */
/* Auto correction messages. */
/* Error messages. */
/* Debug messages. */
/* no \n */
/*************************************************************************/
/*                                                                       */
/* Hash table utilities for the properties.                              */
/*                                                                       */
/*************************************************************************/
/* XXX: Replace this with FreeType's hash functions */
/* Mocklisp hash function. */
/*************************************************************************/
/*                                                                       */
/* Utility types and functions.                                          */
/*                                                                       */
/*************************************************************************/
/* Function type for parsing lines of a BDF font. */
/* List structure for splitting lines into fields. */
/* Structure used while loading BDF fonts. */
/* must be in sync with `nmod' and `umod' */
/* arrays from `bdf_font_t' structure     */
/* same as _bdf_list_t.used */
/* same as _bdf_list_t.size */
/* An empty string for empty fields. */
/* XXX eliminate this */
/* The code below ensures that we have at least 4 + 1 `field' */
/* elements in `list' (which are possibly NULL) so that we    */
/* don't have to check the number of fields in most cases.    */
/* Initialize the list. */
/* If the line is empty, then simply return. */
/* In the original code, if the `separators' parameter is NULL or */
/* empty, the list is split into individual bytes.  We don't need */
/* this, so an error is signaled.                                 */
/* Prepare the separator bitmap. */
/* If the very last character of the separator string is a plus, then */
/* set the `mult' flag to indicate that multiple separators should be */
/* collapsed into one.                                                */
/* Break the line up into fields. */
/* Collect everything that is not a separator. */
/* Resize the list if necessary. */
/* Assign the field appropriately. */
/* If multiple separators should be collapsed, do it now by */
/* setting all the separator characters to 0.               */
/* Don't collapse multiple separators by making them 0, so just */
/* make the one encountered 0.                                  */
/* Finally, NULL-terminate the list. */
/* this value cannot be stored in a 'char' */
/* initial size and allocation of the input buffer */
/* make compiler happy */
/* should we skip an optional character like \n or \r? */
/* try to find the end of the line */
/* if we hit the end of the buffer, try shifting its content */
/* or even resizing it                                       */
/* last line in file doesn't end in \r or \n */
/* ignore it then exit                       */
/* this line is definitely too long; try resizing the input */
/* buffer a bit to handle it.                               */
/* limit ourselves to 64KByte */
/* Temporarily NUL-terminate the line. */
/* XXX: Use encoding independent value for 0x1A */
/* Redo if we have encountered CHARS without properties. */
/* XXX: make this work with EBCDIC also */
/* Routine to convert an ASCII string into an unsigned long integer. */
/* Make sure the radix is something recognizable.  Default to 10. */
/* Check for the special hex prefix. */
/* Routine to convert an ASCII string into an signed long integer. */
/* Make sure the radix is something recognizable.  Default to 10. */
/* Check for a minus sign. */
/* Check for the special hex prefix. */
/* Routine to convert an ASCII string into an signed short integer. */
/* Make sure the radix is something recognizable.  Default to 10. */
/* Check for a minus. */
/* Check for the special hex prefix. */
/* Routine to compare two glyphs by encoding so they can be sorted. */
/* First check whether the property has        */
/* already been added or not.  If it has, then */
/* simply ignore it.                           */
/*************************************************************************/
/*                                                                       */
/* BDF font file parsing flags and functions.                            */
/*                                                                       */
/*************************************************************************/
/* Parse flags. */
/* Set the spacing from the font name if it exists, or set it to the */
/* default specified in the options.                                 */
/* only used in debug mode */
/* Limit ourselves to 256 characters in the font name. */
/* Determine whether the property is an atom or not.  If it is, then */
/* clean it up so the double quotes are removed if they exist.       */
/* Restore the character that was saved before any return can happen. */
/* If the property exists and is not an atom, just return here. */
/* The property is an atom.  Trim all leading and trailing whitespace */
/* and double quotes for the atom value.                              */
/* Trim the leading whitespace if it exists. */
/* Trim the leading double quote if it exists. */
/* Trim the trailing whitespace if it exists. */
/* Trim the trailing double quote if it exists. */
/* only used in debug mode */
/* First, check whether the property already exists in the font. */
/* The property already exists in the font, so simply replace */
/* the value of the property with the current value.          */
/* Delete the current atom if it exists. */
/* See whether this property type exists yet or not. */
/* If not, create it.                                */
/* Allocate another property if this is overflow. */
/* If the property happens to be a comment, then it doesn't need */
/* to be added to the internal hash table.                       */
/* Add the property to the font property table. */
/* Some special cases need to be handled here.  The DEFAULT_CHAR       */
/* property needs to be located if it exists in the property list, the */
/* FONT_ASCENT and FONT_DESCENT need to be assigned if they are        */
/* present, and the SPACING property should override the default       */
/* spacing.                                                            */
/* Actually parse the glyph info and bitmaps. */
/* only used in debug mode */
/* Check for a comment. */
/* The very first thing expected is the number of glyphs. */
/* Make sure the number of glyphs is non-zero. */
/* Limit ourselves to 1,114,112 glyphs in the font (this is the */
/* number of code points available in Unicode).                 */
/* Check for the ENDFONT field. */
/* Missing ENDCHAR field. */
/* Sort the glyphs by encoding. */
/* Check for the ENDCHAR field. */
/* Check whether a glyph is being scanned but should be */
/* ignored because it is an unencoded glyph.            */
/* Check for the STARTCHAR field. */
/* Set the character name in the parse info first until the */
/* encoding can be checked for an unencoded character.      */
/* Check for the ENCODING field. */
/* Missing STARTCHAR field. */
/* Normalize negative encoding values.  The specification only */
/* allows -1, but we can be more generous here.                */
/* Check for alternative encoding format. */
/* Check that the encoding is in the Unicode range because  */
/* otherwise p->have (a bitmap with static size) overflows. */
/* Check whether this encoding has already been encountered. */
/* If it has then change it to unencoded so it gets added if */
/* indicated.                                                */
/* Emit a message saying a glyph has been moved to the */
/* unencoded area.                                     */
/* Make sure there are enough glyphs allocated in case the */
/* number of characters happen to be wrong.                */
/* Reset the initial glyph info. */
/* Unencoded glyph.  Check whether it should */
/* be added or not.                          */
/* Allocate the next unencoded glyph. */
/* Free up the glyph name if the unencoded shouldn't be */
/* kept.                                                */
/* Clear the flags that might be added when width and height are */
/* checked for consistency.                                      */
/* Point at the glyph being constructed. */
/* Check whether a bitmap is being constructed. */
/* If there are more rows than are specified in the glyph metrics, */
/* ignore the remaining lines.                                     */
/* Only collect the number of nibbles indicated by the glyph     */
/* metrics.  If there are more columns, they are simply ignored. */
/* If any line has not enough columns,            */
/* indicate they have been padded with zero bits. */
/* Remove possible garbage at the right. */
/* If any line has extra columns, indicate they have been removed. */
/* Expect the SWIDTH (scalable width) field next. */
/* Expect the DWIDTH (scalable width) field next. */
/* Missing SWIDTH field.  Emit an auto correction message and set */
/* the scalable width from the device width.                      */
/* Expect the BBX field next. */
/* Generate the ascent and descent of the character. */
/* Determine the overall font bounding box as the characters are */
/* loaded so corrections can be done later if indicated.         */
/* Missing DWIDTH field.  Emit an auto correction message and set */
/* the device width to the glyph width.                           */
/* If the BDF_CORRECT_METRICS flag is set, then adjust the SWIDTH */
/* value if necessary.                                            */
/* Determine the point size of the glyph. */
/* And finally, gather up the bitmap. */
/* Missing BBX field. */
/* Allocate enough space for the bitmap. */
/* Missing ENCODING field. */
/* Load the font properties. */
/* Check for the end of the properties. */
/* If the FONT_ASCENT or FONT_DESCENT properties have not been      */
/* encountered yet, then make sure they are added as properties and */
/* make sure they are set from the font bounding box info.          */
/*                                                                  */
/* This is *always* done regardless of the options, because X11     */
/* requires these two fields to compile fonts.                      */
/* Ignore the _XFREE86_GLYPH_RANGES properties. */
/* Handle COMMENT fields and properties in a special way to preserve */
/* the spacing.                                                      */
/* Load the font header. */
/* only used in debug mode */
/* Check for a comment.  This is done to handle those fonts that have */
/* comments before the STARTFONT line for some reason.                */
/* here font is not defined! */
/* we don't emit an error message since this code gets */
/* explicitly caught one level higher                  */
/* setup */
/* Check for the start of the properties. */
/* Missing the FONTBOUNDINGBOX field. */
/* at this point, `p->font' can't be NULL */
/* Check for the FONTBOUNDINGBOX field. */
/* Missing the SIZE field. */
/* The next thing to check for is the FONT field. */
/* Allowing multiple `FONT' lines (which is invalid) doesn't hurt... */
/* If the font name is an XLFD name, set the spacing to the one in  */
/* the font name.  If there is no spacing fall back on the default. */
/* Check for the SIZE field. */
/* Missing the FONT field. */
/* Check for the bits per pixel field. */
/* Only values 1, 2, 4, 8 are allowed. */
/* select next higher value */
/* Check for the CHARS field -- font properties are optional */
/* Missing the FONTBOUNDINGBOX field. */
/* Add the two standard X11 properties which are required */
/* for compiling fonts.                                   */
/* A special return value. */
/*************************************************************************/
/*                                                                       */
/* API.                                                                  */
/*                                                                       */
/*************************************************************************/
/* make compiler happy */
/* needed for FT_NEW */
/* only during font creation */
/* If the font is not proportional, set the font's monowidth */
/* field to the width of the font bounding box.              */
/* If the number of glyphs loaded is not that of the original count, */
/* indicate the difference.                                          */
/* Once the font has been loaded, adjust the overall font metrics if */
/* necessary.                                                        */
/* The ENDFONT field was never reached or did not exist. */
/* Error happened while parsing header. */
/* Error happened when parsing glyphs. */
/* Make sure the comments are NULL terminated if they exist. */
/* Free up the internal hash table of property names. */
/* Free up the comment info. */
/* Free up the properties. */
/* Free up the character info. */
/* Free up the overflow storage if it was used. */
/* bdf_cleanup */
/* Free up the user defined properties. */
/* FREE( font ); */ /* XXX Fixme */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\bzip2\ftbzip2.c
/***************************************************************************/
/*                                                                         */
/*  ftbzip2.c                                                              */
/*                                                                         */
/*    FreeType support for .bz2 compressed files.                          */
/*                                                                         */
/*  This optional component relies on libbz2.  It should mainly be used to */
/*  parse compressed PCF fonts, as found with many X11 server              */
/*  distributions.                                                         */
/*                                                                         */
/*  Copyright 2010, 2012-2014 by                                           */
/*  Joel Klinghed.                                                         */
/*                                                                         */
/*  Based on src/gzip/ftgzip.c, Copyright 2002 - 2010 by                   */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* Do not need FILE */
/***************************************************************************/
/***************************************************************************/
/*****                                                                 *****/
/*****           B Z I P 2   M E M O R Y   M A N A G E M E N T         *****/
/*****                                                                 *****/
/***************************************************************************/
/***************************************************************************/
/* it is better to use FreeType memory routines instead of raw
/***************************************************************************/
/***************************************************************************/
/*****                                                                 *****/
/*****              B Z I P 2   F I L E   D E S C R I P T O R          *****/
/*****                                                                 *****/
/***************************************************************************/
/***************************************************************************/
/* parent/source stream        */
/* embedding stream            */
/* memory allocator            */
/* bzlib input stream          */
/* input read buffer  */
/* output buffer      */
/* position in output */
/* check and skip .bz2 header - we don't support `transparent' compression */
/* head[0] && head[1] are the magic numbers;    */
/* head[2] is the version, and head[3] the blocksize */
/* only support bzip2 (huffman) */
/* check .bz2 header */
/* initialize bzlib */
/* clear the rest */
/* fill output buffer; `count' must be <= FT_BZIP2_BUFFER_SIZE */
/* Reset inflate stream if we're seeking backwards.        */
/* Yes, that is not too efficient, but it saves memory :-) */
/* skip unwanted bytes */
/* now read the data */
/***************************************************************************/
/***************************************************************************/
/*****                                                                 *****/
/*****               B Z   E M B E D D I N G   S T R E A M             *****/
/*****                                                                 *****/
/***************************************************************************/
/***************************************************************************/
/* finalize bzip file descriptor */
/*
/* don't know the real size! */
/* !FT_CONFIG_OPTION_USE_BZIP2 */
/* !FT_CONFIG_OPTION_USE_BZIP2 */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cache\ftcache.c
/***************************************************************************/
/*                                                                         */
/*  ftcache.c                                                              */
/*                                                                         */
/*    The FreeType Caching sub-system (body only).                         */
/*                                                                         */
/*  Copyright 2000-2001, 2003 by                                           */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cache\ftcbasic.c
/***************************************************************************/
/*                                                                         */
/*  ftcbasic.c                                                             */
/*                                                                         */
/*    The FreeType basic cache interface (body).                           */
/*                                                                         */
/*  Copyright 2003-2007, 2009-2011, 2013, 2014 by                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*
/* we will now load the glyph image */
/* ok, copy it */
/* we must call this function to avoid this node from appearing
/*
/* FTC_MruNode_ResetFunc */
/* FTC_MruNode_DoneFunc  */
/* documentation is in ftcache.h */
/* documentation is in ftcache.h */
/* make compiler happy */
/* some argument checks are delayed to `FTC_Cache_Lookup' */
/* make compilers happy */
/* inlining is about 50% faster! */
/* documentation is in ftcache.h */
/* make compiler happy */
/* some argument checks are delayed to `FTC_Cache_Lookup' */
/* `FT_Load_Glyph' and `FT_Load_Char' take FT_UInt flags */
/*
/* FTC_MruNode_ResetFunc */
/* FTC_MruNode_DoneFunc  */
/* documentation is in ftcache.h */
/* documentation is in ftcache.h */
/* make compiler happy */
/* other argument checks delayed to `FTC_Cache_Lookup' */
/* make compilers happy */
/* beware, the hash must be the same for all glyph ranges! */
/* inlining is about 50% faster! */
/* documentation is in ftcache.h */
/* make compiler happy */
/* other argument checks delayed to `FTC_Cache_Lookup' */
/* `FT_Load_Glyph' and `FT_Load_Char' take FT_UInt flags */
/* beware, the hash must be the same for all glyph ranges! */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cache\ftccache.c
/***************************************************************************/
/*                                                                         */
/*  ftccache.c                                                             */
/*                                                                         */
/*    The FreeType internal cache interface (body).                        */
/*                                                                         */
/*  Copyright 2000-2007, 2009-2011, 2013 by                                */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* this one _must_ be a power of 2! */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                   CACHE NODE DEFINITIONS                      *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* add a new node to the head of the manager's circular MRU list */
/* remove a node from the manager's MRU list */
/* move a node to the head of the manager's MRU list */
/* get a top bucket for specified hash from cache,
/* !FTC_INLINE */
/* Note that this function cannot fail.  If we cannot re-size the
/* number of buckets */
/* do we need to shrink the buckets array? */
/* try to expand the buckets array _before_ splitting
/* if we can't expand the array, leave immediately */
/* split a single bucket */
/* do we need to expand the buckets array? */
/* if we can't shrink the array, leave immediately */
/* otherwise, the hash table is balanced */
/* remove a node from its cache's hash table */
/* add a node to the `top' of its cache's hash table */
/* remove a node from the cache manager */
/* find node's cache */
/* remove node from mru list */
/* remove node from cache's hash table */
/* now finalize it */
/* check, just in case of general corruption :-) */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    ABSTRACT CACHE CLASS                       *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* remove node from mru list */
/* now finalize it */
/*
/* don't assume that the cache has the same number of buckets, since
/* Go to the `top' node of the list sharing same masked hash */
/* Lookup a node with exactly same hash and queried properties.  */
/* NOTE: _nodcomp() may change the linked list to reduce memory. */
/* Update bucket by modified linked list */
/* Update pnode by modified linked list */
/* Reorder the list to move the found node to the `top' */
/* move to head of MRU list */
/* !FTC_INLINE */
/* remove all nodes in the free list */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cache\ftccmap.c
/***************************************************************************/
/*                                                                         */
/*  ftccmap.c                                                              */
/*                                                                         */
/*    FreeType CharMap cache (body)                                        */
/*                                                                         */
/*  Copyright 2000-2014 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* Each FTC_CMapNode contains a simple array to map a range of character */
/* codes to equivalent glyph indices.                                    */
/*                                                                       */
/* For now, the implementation is very basic: Each node maps a range of  */
/* 128 consecutive character codes to their corresponding glyph indices. */
/*                                                                       */
/* We could do more complex things, but I don't think it is really very  */
/* useful.                                                               */
/*                                                                       */
/*************************************************************************/
/* number of glyph indices / character code per node */
/* compute a query/node hash */
/* the charmap query */
/* the cmap cache node */
/* first character in node */
/* array of glyph indices  */
/* if (indices[n] == FTC_CMAP_UNKNOWN), we assume that the corresponding */
/* glyph indices haven't been queried through FT_Get_Glyph_Index() yet   */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                        CHARMAP NODES                          *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* initialize a new cmap node */
/* compute the weight of a given cmap node */
/* compare a cmap node to a given query */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    GLYPH IMAGE CACHE                          *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* documentation is in ftcache.h */
/* documentation is in ftcache.h */
/* Treat a negative cmap index as a special value, meaning that you */
/* don't want to change the FT_Face's character map through this    */
/* call.  This can be useful if the face requester callback already */
/* sets the face's charmap to the appropriate value.                */
/* something rotten can happen with rogue clients */
/* XXX: should return appropriate error */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cache\ftcglyph.c
/***************************************************************************/
/*                                                                         */
/*  ftcglyph.c                                                             */
/*                                                                         */
/*    FreeType Glyph Image (FT_Glyph) cache (body).                        */
/*                                                                         */
/*  Copyright 2000-2001, 2003, 2004, 2006, 2009, 2011 by                   */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* create a new chunk node, setting its cache index and ref count */
/* finalize the node */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      CHUNK SETS                               *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* no maximum here! */
/* 0 */
/* 0 */
/* prevent the family from being destroyed too early when an        */
/* out-of-memory condition occurs during glyph node initialization. */
/* !FTC_INLINE */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cache\ftcimage.c
/***************************************************************************/
/*                                                                         */
/*  ftcimage.c                                                             */
/*                                                                         */
/*    FreeType Image cache (body).                                         */
/*                                                                         */
/*  Copyright 2000-2001, 2003, 2004, 2006, 2010 by                         */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* finalize a given glyph image node */
/* initialize a new glyph image node */
/* initialize its inner fields */
/* we will now load the glyph image */
/* 0 */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cache\ftcmanag.c
/***************************************************************************/
/*                                                                         */
/*  ftcmanag.c                                                             */
/*                                                                         */
/*    FreeType Cache Manager (body).                                       */
/*                                                                         */
/*  Copyright 2000-2006, 2008-2010, 2013, 2014 by                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* helper function used by ftc_face_node_done */
/* documentation is in ftcache.h */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    FACE MRU IMPLEMENTATION                    *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* destroy initial size object; it will be re-created later */
/* we must begin by removing all scalers for the target face */
/* from the manager's list                                   */
/* all right, we can discard the face now */
/* FTC_MruNode_ResetFunc */
/* documentation is in ftcache.h */
/* we break encapsulation for the sake of speed */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    CACHE MANAGER ROUTINES                     *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* documentation is in ftcache.h */
/* documentation is in ftcache.h */
/* now discard all caches */
/* discard faces and sizes */
/* documentation is in ftcache.h */
/* check node weights */
/* check circular list */
/* FT_DEBUG_ERROR */
/* `Compress' the manager's data, i.e., get rid of old cache nodes */
/* that are not referenced anymore in order to limit the total     */
/* memory used by the cache.                                       */
/* documentation is in ftcmanag.h */
/* go to last node -- it's a circular list */
/* documentation is in ftcmanag.h */
/* THIS IS VERY IMPORTANT!  IT WILL WRETCH THE MANAGER */
/* IF IT IS NOT SET CORRECTLY                          */
/* try to remove `count' nodes from the list */
/* empty list! */
/* go to last node - it's a circular list */
/* don't touch locked nodes */
/* documentation is in ftcache.h */
/* this will remove all FTC_SizeNode that correspond to
/* documentation is in ftcache.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cache\ftcmru.c
/***************************************************************************/
/*                                                                         */
/*  ftcmru.c                                                               */
/*                                                                         */
/*    FreeType MRU support (body).                                         */
/*                                                                         */
/*  Copyright 2003, 2004, 2006, 2009 by                                    */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* FTC_INLINE */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cache\ftcsbits.c
/***************************************************************************/
/*                                                                         */
/*  ftcsbits.c                                                             */
/*                                                                         */
/*    FreeType sbits manager (body).                                       */
/*                                                                         */
/*  Copyright 2000-2006, 2009-2011, 2013, 2014 by                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     SBIT CACHE NODES                          *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*
/* FT_GlyphSlot->advance.{x|y} */
/* Check whether our values fit into 8-bit containers!    */
/* If this is not the case, our bitmap is too large       */
/* and we will leave it as `missing' with sbit.buffer = 0 */
/* horizontal advance in pixels */
/* copy the bitmap into a new buffer -- ignore error */
/* now, compute size */
/* glyph loading successful */
/* ignore the errors that might have occurred --   */
/* we mark unloaded glyphs with `sbit.buffer == 0' */
/* and `width == 255', `height == 0'               */
/*                                                 */
/* the node itself */
/* add the size of a given glyph image */
/* 0 */
/* check if we need to load the glyph bitmap now */
/*
/* lock node to prevent flushing */
/* in retry loop                 */
/* unlock the node */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cff\cf2arrst.c
/***************************************************************************/
/*                                                                         */
/*  cf2arrst.c                                                             */
/*                                                                         */
/*    Adobe's code for Array Stacks (body).                                */
/*                                                                         */
/*  Copyright 2007-2013 Adobe Systems Incorporated.                        */
/*                                                                         */
/*  This software, and all works of authorship, whether in source or       */
/*  object code form as indicated by the copyright notice(s) included      */
/*  herein (collectively, the "Work") is made available, and may only be   */
/*  used, modified, and distributed under the FreeType Project License,    */
/*  LICENSE.TXT.  Additionally, subject to the terms and conditions of the */
/*  FreeType Project License, each contributor to the Work hereby grants   */
/*  to any individual or legal entity exercising permissions granted by    */
/*  the FreeType Project License and this section (hereafter, "You" or     */
/*  "Your") a perpetual, worldwide, non-exclusive, no-charge,              */
/*  royalty-free, irrevocable (except as stated in this section) patent    */
/*  license to make, have made, use, offer to sell, sell, import, and      */
/*  otherwise transfer the Work, where such license applies only to those  */
/*  patent claims licensable by such contributor that are necessarily      */
/*  infringed by their contribution(s) alone or by combination of their    */
/*  contribution(s) with the Work to which such contribution(s) was        */
/*  submitted.  If You institute patent litigation against any entity      */
/*  (including a cross-claim or counterclaim in a lawsuit) alleging that   */
/*  the Work or a contribution incorporated within the Work constitutes    */
/*  direct or contributory patent infringement, then any patent licenses   */
/*  granted to You under this License for that Work shall terminate as of  */
/*  the date such litigation is filed.                                     */
/*                                                                         */
/*  By using, modifying, or distributing the Work you indicate that you    */
/*  have read and understood the terms and conditions of the               */
/*  FreeType Project License as well as those provided in this section,    */
/*  and you accept them fully.                                             */
/*                                                                         */
/***************************************************************************/
/*
/* initialize the structure */
/* chunks of 10 items */
/* for FT_FREE */
/* free the data buffer */
/* allocate or reallocate the buffer size; */
/* return false on memory error */
/* for FT_REALLOC */
/* for FT_REALLOC */
/* avoid realloc with zero size */
/* we truncated the list! */
/* success */
/* if there's not already an error, store this one */
/* set the count, ensuring allocation is sufficient */
/* expand the allocation first */
/* clear the count */
/* current number of items */
/* return pointer to the given element */
/* overflow */
/* choose safe default */
/* push (append) an element at the end of the list;         */
/* return false on memory error                             */
/* TODO: should there be a length param for extra checking? */
/* grow the buffer by one chunk */
/* on error, ignore the push */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cff\cf2blues.c
/***************************************************************************/
/*                                                                         */
/*  cf2blues.c                                                             */
/*                                                                         */
/*    Adobe's code for handling Blue Zones (body).                         */
/*                                                                         */
/*  Copyright 2009-2014 Adobe Systems Incorporated.                        */
/*                                                                         */
/*  This software, and all works of authorship, whether in source or       */
/*  object code form as indicated by the copyright notice(s) included      */
/*  herein (collectively, the "Work") is made available, and may only be   */
/*  used, modified, and distributed under the FreeType Project License,    */
/*  LICENSE.TXT.  Additionally, subject to the terms and conditions of the */
/*  FreeType Project License, each contributor to the Work hereby grants   */
/*  to any individual or legal entity exercising permissions granted by    */
/*  the FreeType Project License and this section (hereafter, "You" or     */
/*  "Your") a perpetual, worldwide, non-exclusive, no-charge,              */
/*  royalty-free, irrevocable (except as stated in this section) patent    */
/*  license to make, have made, use, offer to sell, sell, import, and      */
/*  otherwise transfer the Work, where such license applies only to those  */
/*  patent claims licensable by such contributor that are necessarily      */
/*  infringed by their contribution(s) alone or by combination of their    */
/*  contribution(s) with the Work to which such contribution(s) was        */
/*  submitted.  If You institute patent litigation against any entity      */
/*  (including a cross-claim or counterclaim in a lawsuit) alleging that   */
/*  the Work or a contribution incorporated within the Work constitutes    */
/*  direct or contributory patent infringement, then any patent licenses   */
/*  granted to You under this License for that Work shall terminate as of  */
/*  the date such litigation is filed.                                     */
/*                                                                         */
/*  By using, modifying, or distributing the Work you indicate that you    */
/*  have read and understood the terms and conditions of the               */
/*  FreeType Project License as well as those provided in this section,    */
/*  and you accept them fully.                                             */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*
/* pointer to parsed font object */
/*
/* get em box from OS/2 typoAscender/Descender                      */
/* TODO: FreeType does not parse these metrics.  Skip them for now. */
/*
/* enable the heuristic */
/* copy `BlueValues' and `OtherBlues' to a combined array of top and */
/* bottom zones                                                      */
/* reject this zone */
/* take maximum before darkening adjustment      */
/* so overshoot suppression point doesn't change */
/* adjust both edges of top zone upward by twice darkening amount */
/* first `BlueValue' is bottom zone; others are top */
/* reject this zone */
/* take maximum before darkening adjustment      */
/* so overshoot suppression point doesn't change */
/* Note: bottom zones are not adjusted for darkening amount */
/* all OtherBlues are bottom zone */
/* Adjust for FamilyBlues */
/* Search for the nearest flat edge in `FamilyBlues' or                */
/* `FamilyOtherBlues'.  According to the Black Book, any matching edge */
/* must be within one device pixel                                     */
/* loop on all zones in this font */
/* value for this font */
/* In a bottom zone, the top edge is the flat edge.             */
/* Search `FamilyOtherBlues' for bottom zones; look for closest */
/* Family edge that is within the one pixel threshold.          */
/* top edge */
/* check the first member of FamilyBlues, which is a bottom zone */
/* top edge */
/* In a top zone, the bottom edge is the flat edge.                */
/* Search `FamilyBlues' for top zones; skip first zone, which is a */
/* bottom zone; look for closest Family edge that is within the    */
/* one pixel threshold                                             */
/* bottom edge */
/* adjust edges of top zone upward by twice darkening amount */
/* bottom edge */
/* TODO: enforce separation of zones, including BlueFuzz */
/* Adjust BlueScale; similar to AdjustBlueScale() in coretype */
/* `bcsetup.c'.                                               */
/* clamp at maximum scale */
/*
/* clamp at minimum scale, per bug 0613448 fix */
/*
/* Change rounding threshold for `dsFlatEdge'.                    */
/* Note: constant changed from 0.5 to 0.6 to avoid a problem with */
/*       10ppem Arial                                             */
/* boost must remain less than 0.5, or baseline could go negative */
/* boost and darkening have similar effects; don't do both */
/* set device space alignment for each zone;    */
/* apply boost amount before rounding flat edge */
/*
/* TODO: validate? */
/* new position of captured edge */
/* amount that hint is moved when positioned */
/* assert edge flags are consistent */
/* TODO: search once without blue fuzz for compatibility with coretype? */
/* bottom edge captured by bottom zone */
/* guarantee minimum of 1 pixel overshoot */
/* simply round captured edge */
/* top edge captured by top zone */
/* guarantee minimum of 1 pixel overshoot */
/* simply round captured edge */
/* move both edges and flag them `locked' */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cff\cf2error.c
/***************************************************************************/
/*                                                                         */
/*  cf2error.c                                                             */
/*                                                                         */
/*    Adobe's code for error handling (body).                              */
/*                                                                         */
/*  Copyright 2006-2013 Adobe Systems Incorporated.                        */
/*                                                                         */
/*  This software, and all works of authorship, whether in source or       */
/*  object code form as indicated by the copyright notice(s) included      */
/*  herein (collectively, the "Work") is made available, and may only be   */
/*  used, modified, and distributed under the FreeType Project License,    */
/*  LICENSE.TXT.  Additionally, subject to the terms and conditions of the */
/*  FreeType Project License, each contributor to the Work hereby grants   */
/*  to any individual or legal entity exercising permissions granted by    */
/*  the FreeType Project License and this section (hereafter, "You" or     */
/*  "Your") a perpetual, worldwide, non-exclusive, no-charge,              */
/*  royalty-free, irrevocable (except as stated in this section) patent    */
/*  license to make, have made, use, offer to sell, sell, import, and      */
/*  otherwise transfer the Work, where such license applies only to those  */
/*  patent claims licensable by such contributor that are necessarily      */
/*  infringed by their contribution(s) alone or by combination of their    */
/*  contribution(s) with the Work to which such contribution(s) was        */
/*  submitted.  If You institute patent litigation against any entity      */
/*  (including a cross-claim or counterclaim in a lawsuit) alleging that   */
/*  the Work or a contribution incorporated within the Work constitutes    */
/*  direct or contributory patent infringement, then any patent licenses   */
/*  granted to You under this License for that Work shall terminate as of  */
/*  the date such litigation is filed.                                     */
/*                                                                         */
/*  By using, modifying, or distributing the Work you indicate that you    */
/*  have read and understood the terms and conditions of the               */
/*  FreeType Project License as well as those provided in this section,    */
/*  and you accept them fully.                                             */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cff\cf2font.c
/***************************************************************************/
/*                                                                         */
/*  cf2font.c                                                              */
/*                                                                         */
/*    Adobe's code for font instances (body).                              */
/*                                                                         */
/*  Copyright 2007-2014 Adobe Systems Incorporated.                        */
/*                                                                         */
/*  This software, and all works of authorship, whether in source or       */
/*  object code form as indicated by the copyright notice(s) included      */
/*  herein (collectively, the "Work") is made available, and may only be   */
/*  used, modified, and distributed under the FreeType Project License,    */
/*  LICENSE.TXT.  Additionally, subject to the terms and conditions of the */
/*  FreeType Project License, each contributor to the Work hereby grants   */
/*  to any individual or legal entity exercising permissions granted by    */
/*  the FreeType Project License and this section (hereafter, "You" or     */
/*  "Your") a perpetual, worldwide, non-exclusive, no-charge,              */
/*  royalty-free, irrevocable (except as stated in this section) patent    */
/*  license to make, have made, use, offer to sell, sell, import, and      */
/*  otherwise transfer the Work, where such license applies only to those  */
/*  patent claims licensable by such contributor that are necessarily      */
/*  infringed by their contribution(s) alone or by combination of their    */
/*  contribution(s) with the Work to which such contribution(s) was        */
/*  submitted.  If You institute patent litigation against any entity      */
/*  (including a cross-claim or counterclaim in a lawsuit) alleging that   */
/*  the Work or a contribution incorporated within the Work constitutes    */
/*  direct or contributory patent infringement, then any patent licenses   */
/*  granted to You under this License for that Work shall terminate as of  */
/*  the date such litigation is filed.                                     */
/*                                                                         */
/*  By using, modifying, or distributing the Work you indicate that you    */
/*  have read and understood the terms and conditions of the               */
/*  FreeType Project License as well as those provided in this section,    */
/*  and you accept them fully.                                             */
/*                                                                         */
/***************************************************************************/
/* Compute a stem darkening amount in character space. */
/*
/* Internal calculations are done in units per thousand for */
/* convenience. The x axis is scaled stem width in          */
/* thousandths of a pixel. That is, 1000 is 1 pixel.        */
/* The y axis is darkening amount in thousandths of a pixel.*/
/* In the code, below, dividing by ppem and                 */
/* adjusting for emRatio converts darkenAmount to character */
/* space (font units).                                      */
/* protect against range problems and divide by zero */
/* convert from true character space to 1000 unit character space; */
/* add synthetic emboldening effect                                */
/* `stemWidthPer1000' will not overflow for a legitimate font      */
/* `scaledStem' can easily overflow, so we must clamp its maximum  */
/* value; the test doesn't need to be precise, but must be         */
/* conservative.  The clamp value (default 2333) where             */
/* `darkenAmount' is zero is well below the overflow value of      */
/* 32767.                                                          */
/*                                                                 */
/* FT_MSB computes the integer part of the base 2 logarithm.  The  */
/* number of bits for the product is 1 or 2 more than the sum of   */
/* logarithms; remembering that the 16 lowest bits of the fraction */
/* are dropped this is correct to within a factor of almost 4.     */
/* For example, 0x80.0000 * 0x80.0000 = 0x4000.0000 is 23+23 and   */
/* is flagged as possible overflow because 0xFF.FFFF * 0xFF.FFFF = */
/* 0xFFFF.FE00 is also 23+23.                                      */
/* possible overflow */
/* now apply the darkening parameters */
/* use half the amount on each side and convert back to true */
/* character space                                           */
/* add synthetic emboldening effect in character space */
/* set up values for the current FontDict and matrix */
/* caller's transform is adjusted for subpixel positioning */
/* pointer to parsed font object */
/* character space units */
/* clear previous error */
/* if a CID fontDict has changed, we need to recompute some cached */
/* data                                                            */
/* if ppem has changed, we need to recompute some cached data         */
/* note: because of CID font matrix concatenation, ppem and transform */
/*       do not necessarily track.                                    */
/* copy hinted flag on each call */
/* determine if transform has changed;       */
/* include Fontmatrix but ignore translation */
/* save `key' information for `cache of one' matrix data; */
/* save client transform, without the translation         */
/* TODO: FreeType transform is simple scalar; for now, use identity */
/*       for outer                                                  */
/*
/* blue zones depend on darkened flag */
/* recompute variables that are dependent on transform or FontDict or */
/* darken flag                                                        */
/* StdVW is found in the private dictionary;                       */
/* recompute darkening amounts whenever private dictionary or      */
/* transform change                                                */
/* Note: a rendering flag turns darkening on or off, so we want to */
/*       store the `on' amounts;                                   */
/*       darkening amount is computed in character space           */
/* TODO: testing size-dependent darkening here;                    */
/*       what to do for rotations?                                 */
/* use minimum ppem of 4 */
/* since vstem is measured in the x-direction, we use the `a' member */
/* of the fontMatrix                                                 */
/* Freetype does not preserve the fontMatrix when parsing; use */
/* unitsPerEm instead.                                         */
/* TODO: check precision of this                               */
/* Ensure that boldenX is at least 1 pixel for synthetic bold font */
/* (similar to what Avalon does)                                   */
/* Synthetic emboldening adds at least 1 pixel to darkenX, while */
/* stem darkening adds at most half pixel.  Since the purpose of */
/* stem darkening (readability at small sizes) is met with       */
/* synthetic emboldening, no need to add stem darkening for a    */
/* synthetic bold font.                                          */
/* since hstem is measured in the y-direction, we use the `d' member */
/* of the fontMatrix                                                 */
/* TODO: use the same units per em as above; check this              */
/* set the default stem width, because it must be the same for all */
/* family members;                                                 */
/* choose a constant for StdHW that depends on font contrast       */
/* low contrast font gets less hstem darkening */
/* initial expectation is CCW */
/* compute blue zones for this instance */
/* equivalent to AdobeGetOutline */
/* Note: use both integer and fraction for outlines.  This allows bbox */
/*       to come out directly.                                         */
/* set up values based on transform */
/* setup encountered an error */
/* reset darken direction */
/* winding order only affects darkening */
/* reset output buffer */
/* build the outline, passing the full translation */
/* check winding order */
/* CFF is CCW */
/* invert darkening and render again                            */
/* TODO: this should be a parameter to getOutline-computeOffset */
/* exit after next iteration */
/* finish storing client outline */
/* FreeType just wants the advance width; there is no translation */
/* free resources and collect errors from objects we've used */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cff\cf2ft.c
/***************************************************************************/
/*                                                                         */
/*  cf2ft.c                                                                */
/*                                                                         */
/*    FreeType Glue Component to Adobe's Interpreter (body).               */
/*                                                                         */
/*  Copyright 2013-2014 Adobe Systems Incorporated.                        */
/*                                                                         */
/*  This software, and all works of authorship, whether in source or       */
/*  object code form as indicated by the copyright notice(s) included      */
/*  herein (collectively, the "Work") is made available, and may only be   */
/*  used, modified, and distributed under the FreeType Project License,    */
/*  LICENSE.TXT.  Additionally, subject to the terms and conditions of the */
/*  FreeType Project License, each contributor to the Work hereby grants   */
/*  to any individual or legal entity exercising permissions granted by    */
/*  the FreeType Project License and this section (hereafter, "You" or     */
/*  "Your") a perpetual, worldwide, non-exclusive, no-charge,              */
/*  royalty-free, irrevocable (except as stated in this section) patent    */
/*  license to make, have made, use, offer to sell, sell, import, and      */
/*  otherwise transfer the Work, where such license applies only to those  */
/*  patent claims licensable by such contributor that are necessarily      */
/*  infringed by their contribution(s) alone or by combination of their    */
/*  contribution(s) with the Work to which such contribution(s) was        */
/*  submitted.  If You institute patent litigation against any entity      */
/*  (including a cross-claim or counterclaim in a lawsuit) alleging that   */
/*  the Work or a contribution incorporated within the Work constitutes    */
/*  direct or contributory patent infringement, then any patent licenses   */
/*  granted to You under this License for that Work shall terminate as of  */
/*  the date such litigation is filed.                                     */
/*                                                                         */
/*  By using, modifying, or distributing the Work you indicate that you    */
/*  have read and understood the terms and conditions of the               */
/*  FreeType Project License as well as those provided in this section,    */
/*  and you accept them fully.                                             */
/*                                                                         */
/***************************************************************************/
/* max ppem */
/*
/* Clean up font instance. */
/********************************************/
/*                                          */
/* functions for handling client outline;   */
/* FreeType uses coordinates in 26.6 format */
/*                                          */
/********************************************/
/* downcast the object pointer */
/* only used in debug mode */
/* note: two successive moves simply close the contour twice */
/* downcast the object pointer */
/* record the move before the line; also check points and set */
/* `path_begun'                                               */
/* `cff_builder_add_point1' includes a check_points call for one point */
/* downcast the object pointer */
/* record the move before the line; also check points and set */
/* `path_begun'                                               */
/* prepare room for 3 points: 2 off-curve, 1 on-curve */
/* get scaling and hint flag from GlyphSlot */
/* note: FreeType scale includes a factor of 64 */
/* for unhinted outlines, `cff_slot_load' does the scaling, */
/* thus render at `unity' scale                             */
/* 1/64 as 16.16 */
/* get units per em from `FT_Face' */
/* TODO: should handle font matrix concatenation? */
/* Main entry point: Render one glyph. */
/* CF2 data is saved here across glyphs */
/* on first glyph, allocate instance structure */
/* initialize a client outline, to be shared by each glyph rendered */
/* save decoder; it is a stack variable and will be different on each */
/* call                                                               */
/* build parameters for Adobe engine */
/* local error */
/* FreeType has already looked up the GID; convert to         */
/* `RegionBuffer', assuming that the input has been validated */
/* now get an outline for this glyph;      */
/* also get units per em to validate scale */
/* get pointer to current FreeType subfont (based on current glyphID) */
/* get `y_ppem' from `CFF_Size' */
/*
/* get standard stem widths for the current subfont; */
/* FreeType stores these as integer font units       */
/* (note: variable names seem swapped)               */
/* note: FreeType stores 1000 times the actual value for `BlueScale' */
/* get blue values counts and arrays; the FreeType parser has validated */
/* the counts and verified that each is an even number                  */
/* convert unbiased subroutine index to `CF2_Buffer' and */
/* return 0 on success                                   */
/* error */
/* success */
/* convert AdobeStandardEncoding code to CF2_Buffer; */
/* used for seac component                           */
/* TODO: for now, just pass the FreeType error through */
/* assume input has been validated */
/* error */
/* success */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cff\cf2hints.c
/***************************************************************************/
/*                                                                         */
/*  cf2hints.c                                                             */
/*                                                                         */
/*    Adobe's code for handling CFF hints (body).                          */
/*                                                                         */
/*  Copyright 2007-2014 Adobe Systems Incorporated.                        */
/*                                                                         */
/*  This software, and all works of authorship, whether in source or       */
/*  object code form as indicated by the copyright notice(s) included      */
/*  herein (collectively, the "Work") is made available, and may only be   */
/*  used, modified, and distributed under the FreeType Project License,    */
/*  LICENSE.TXT.  Additionally, subject to the terms and conditions of the */
/*  FreeType Project License, each contributor to the Work hereby grants   */
/*  to any individual or legal entity exercising permissions granted by    */
/*  the FreeType Project License and this section (hereafter, "You" or     */
/*  "Your") a perpetual, worldwide, non-exclusive, no-charge,              */
/*  royalty-free, irrevocable (except as stated in this section) patent    */
/*  license to make, have made, use, offer to sell, sell, import, and      */
/*  otherwise transfer the Work, where such license applies only to those  */
/*  patent claims licensable by such contributor that are necessarily      */
/*  infringed by their contribution(s) alone or by combination of their    */
/*  contribution(s) with the Work to which such contribution(s) was        */
/*  submitted.  If You institute patent litigation against any entity      */
/*  (including a cross-claim or counterclaim in a lawsuit) alleging that   */
/*  the Work or a contribution incorporated within the Work constitutes    */
/*  direct or contributory patent infringement, then any patent licenses   */
/*  granted to You under this License for that Work shall terminate as of  */
/*  the date such litigation is filed.                                     */
/*                                                                         */
/*  By using, modifying, or distributing the Work you indicate that you    */
/*  have read and understood the terms and conditions of the               */
/*  FreeType Project License as well as those provided in this section,    */
/*  and you accept them fully.                                             */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* index of upper hint map edge   */
/* adjustment to optimum position */
/* Compute angular momentum for winding order detection.  It is called */
/* for all lines and curves, but not necessarily in element order.     */
/* cross product of pt1 position from origin with pt2 position from  */
/* pt1; we reduce the precision so that the result fits into 32 bits */
/*
/* ghost bottom */
/* ghost top */
/* inverted pair */
/*
/* normal pair */
/* Now that ghost hints have been detected, adjust this edge for      */
/* darkening.  Bottoms are not changed; tops are incremented by twice */
/* `darkenY'.                                                         */
/* index in original stem hint array */
/* if original stem hint has been used, use the same position */
/* initialize an invalid hint map element */
/* copy parameters from font instance */
/* will clear in `cf2_hintmap_adjustHints' */
/* transform character space coordinate to device space using hint map */
/* there are no hints; use uniform scale and zero offset */
/* start linear search from last hit */
/* search up */
/* search down */
/* special case for points below first edge: use uniform scale */
/*
/*
/* working storage */
/*
/* index of upper edge (same value for ghost hint) */
/* hint edge is not locked, we can adjust it */
/* calculate all four possibilities; moves down are negative */
/* smallest move up */
/* smallest move down */
/* final amount to move edge or edge pair */
/* minimum counter constraint doesn't apply when adjacent edges */
/* are synthetic                                                */
/* TODO: doesn't seem a big effect; for now, reduce the code    */
/* is there room to move up?                                    */
/* there is if we are at top of array or the next edge is at or */
/* beyond proposed move up?                                     */
/* there is room to move up; is there also room to move down? */
/* move smaller absolute amount */
/* optimum */
/* is there room to move down? */
/* true if non-optimum move */
/* no room to move either way without overlapping or reducing */
/* the counter too much                                       */
/* Identify non-moves and moves down that aren't optimal, and save */
/* them for second pass.                                           */
/* Do this only if there is an unlocked edge above (which could    */
/* possibly move).                                                 */
/* desired adjustment in second pass */
/* move the edge(s) */
/* assert there are no overlaps in device space */
/* adjust the scales, avoiding divide by zero */
/* skip upper edge on next loop */
/* second pass tries to move non-optimal hints up, in case there is */
/* room now                                                         */
/* this was tested before the push, above */
/* is there room to move up? */
/* there is more room now, move edge up */
/* insert hint edges into map, sorted by csCoord */
/* set default values, then check for edge hints */
/* one or none of the input params may be invalid when dealing with */
/* edge hints; at least one edge must be valid                      */
/* determine how many and which edges to insert */
/* insert only the top edge */
/* insert only the bottom edge */
/* paired edges must be in proper order */
/* linear search to find index value of insertion point */
/*
/* we are inserting before an existing edge:    */
/* verify that an existing edge is not the same */
/* ignore overlapping stem hint */
/* verify that a new pair does not straddle the next edge */
/* ignore overlapping stem hint */
/* verify that we are not inserting between paired edges */
/* ignore overlapping stem hint */
/* recompute device space locations using initial hint map */
/* Use hint map to position the center of stem, and nominal scale */
/* to position the two edges.  This preserves the stem width.     */
/*
/* we are inserting after an existing edge */
/* we are inserting before an existing edge */
/* make room to insert */
/* insert first edge */
/* copy struct */
/* insert second edge */
/* copy struct */
/*
/* check whether initial map is constructed */
/* make recursive call with initialHintMap and temporary mask; */
/* temporary mask will get all bits set, below */
/* without a hint mask, assume all hints are active */
/* too many stem hints */
/* begin by clearing the map */
/* make a copy of the hint mask so we can modify it */
/* use the hStem hints only, which are first in the mask */
/* Defense-in-depth.  Should never return here. */
/* synthetic embox hints get highest priority */
/* invalid hint map element */
/* ghost bottom */
/* ghost top */
/* insert hints captured by a blue zone or already locked (higher */
/* priority)                                                      */
/* expand StemHint into two `CF2_Hint' elements */
/* bottom */ );
/* top */ );
/* insert captured hint into map */
/* turn off the bit for this hint */
/* move to next mask byte */
/* initial hint map includes only captured hints plus maybe one at 0 */
/*
/* Apply a heuristic that inserts a point for (0,0), unless it's     */
/* already covered by a mapping.  This locks the baseline for glyphs */
/* that have no baseline hints.                                      */
/* all edges are above 0 or all edges are below 0; */
/* construct a locked edge hint at 0               */
/* insert remaining hints */
/* bottom */ );
/* top */ );
/* move to next mask byte */
/*
/* adjust positions of hint edges that are not locked to blue zones */
/* save the position of all hints that were used in this hint map; */
/* if we use them again, we'll locate them in the same position    */
/* Note: include both valid and invalid edges            */
/* Note: top and bottom edges are copied back separately */
/* hint map is ready to use */
/* remember this mask has been used */
/* CF2_Fixed  hShift, */
/* for fauxing */
/* ptr to current mask */
/* TODO: should we make copies? */
/* .1 character space unit */
/*
/* hinted point in upright DS */
/*
/*
//mathworld.wolfram.com/PerpDotProduct.html.
//softsurfer.com/Archive/algorithm_0104/algorithm_0104B.htm.
/* round and divide by 32 */
/* scaled vectors */
/* parallel or coincident lines */
/*
/* limit the intersection distance from midpoint of u2 and v1 */
/*
/* optimization: if previous and next elements are offset by the same */
/* amount, then there will be no gap, and no need to compute an       */
/* intersection.                                                      */
/* previous element does not join next element:             */
/* adjust end point of previous element to the intersection */
/* modify the last point of the cached element (either line or */
/* curve)                                                      */
/* note: pt2 and pt3 are unused */
/* use first hint map if closing */
/* output only non-zero length lines */
/* TODO: should we intersect the interior joins (p1-p2 and p2-p3)? */
/* insert connecting line between end of previous element and start */
/* of current one                                                   */
/* note: at the end of a subpath, we might do both, so use `nextP0' */
/* before we change it, below                                       */
/* if we are closing the subpath, then nextP0 is in the first     */
/* hint zone                                                      */
/* length is nonzero */
/* note: pt2 and pt3 are unused */
/* return intersection point to caller */
/* push a MoveTo element based on current point and offset of current */
/* element                                                            */
/* Test if move has really happened yet; it would have called */
/* `cf2_hintmap_build' to set `isValid'.                   */
/* we are here iff first subpath is missing a moveto operator: */
/* synthesize first moveTo to finish initialization of hintMap */
/* note: pt2 and pt3 are unused */
/*
/* note: negative offsets don't work here; negate deltas to change */
/* quadrants, below                                                */
/* add momentum for this path element */
/* note: allow mixed integer and fixed multiplication here */
/* first quadrant, +x +y */
/* +x */
/* +y */
/* +x +y */
/* fourth quadrant, +x -y */
/* +x */
/* -y */
/* +x -y */
/* second quadrant, -x +y */
/* -x */
/* +y */
/* -x +y */
/* third quadrant, -x -y */
/* -x */
/* -y */
/* -x -y */
/*
/* save the parameters of the move for later, when we'll know how to */
/* offset it;                                                        */
/* also save last move point */
/* ensure we have a valid map with current mask */
/* save a copy of current HintMap to use when drawing initial point */
/* structure copy */
/*
/* true if new hint map not on close */
/*
/*
/*
/* construct offset points */
/* emit offset 1st point as MoveTo */
/* adjust state machine */
/* record second point */
/* queue the current element with offset points */
/* update current map */
/* pre-offset current point */
/* TODO: ignore zero length portions of curve?? */
/* add momentum from the middle segment */
/* construct offset points */
/* note: preserve angle of final segment by using offset3 at both ends */
/* emit offset 1st point as MoveTo */
/* record second point */
/* queue the current element with offset points */
/* update current map */
/* pre-offset current point */
/*
/* empty the final element from the queue and close the path */
/* reset state machine */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cff\cf2intrp.c
/***************************************************************************/
/*                                                                         */
/*  cf2intrp.c                                                             */
/*                                                                         */
/*    Adobe's CFF Interpreter (body).                                      */
/*                                                                         */
/*  Copyright 2007-2014 Adobe Systems Incorporated.                        */
/*                                                                         */
/*  This software, and all works of authorship, whether in source or       */
/*  object code form as indicated by the copyright notice(s) included      */
/*  herein (collectively, the "Work") is made available, and may only be   */
/*  used, modified, and distributed under the FreeType Project License,    */
/*  LICENSE.TXT.  Additionally, subject to the terms and conditions of the */
/*  FreeType Project License, each contributor to the Work hereby grants   */
/*  to any individual or legal entity exercising permissions granted by    */
/*  the FreeType Project License and this section (hereafter, "You" or     */
/*  "Your") a perpetual, worldwide, non-exclusive, no-charge,              */
/*  royalty-free, irrevocable (except as stated in this section) patent    */
/*  license to make, have made, use, offer to sell, sell, import, and      */
/*  otherwise transfer the Work, where such license applies only to those  */
/*  patent claims licensable by such contributor that are necessarily      */
/*  infringed by their contribution(s) alone or by combination of their    */
/*  contribution(s) with the Work to which such contribution(s) was        */
/*  submitted.  If You institute patent litigation against any entity      */
/*  (including a cross-claim or counterclaim in a lawsuit) alleging that   */
/*  the Work or a contribution incorporated within the Work constitutes    */
/*  direct or contributory patent infringement, then any patent licenses   */
/*  granted to You under this License for that Work shall terminate as of  */
/*  the date such litigation is filed.                                     */
/*                                                                         */
/*  By using, modifying, or distributing the Work you indicate that you    */
/*  have read and understood the terms and conditions of the               */
/*  FreeType Project License as well as those provided in this section,    */
/*  and you accept them fully.                                             */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* some operators are not implemented yet */
/* clients call `getMaskPtr' in order to iterate */
/* through hint mask                             */
/* total of h and v stems must be <= 96 */
/* consume the hintmask bytes from the charstring, advancing the src */
/* pointer                                                           */
/* these are the bits in the final mask byte that should be zero  */
/* Note: this variable is only used in an assert expression below */
/* and then only if CF2_NDEBUG is not defined                     */
/* initialize counts and isValid */
/* set mask and advance interpreter's charstring pointer */
/* assert any unused bits in last byte are zero unless there's a prior */
/* error                                                               */
/* bitCount -> mask, 0 -> 0, 1 -> 7f, 2 -> 3f, ... 6 -> 3, 7 -> 1      */
/* initialize counts and isValid */
/* set mask to all ones */
/* clear unused bits                                              */
/* bitCount -> mask, 0 -> 0, 1 -> 7f, 2 -> 3f, ... 6 -> 3, 7 -> 1 */
/* Type2 charstring opcodes */
/* 0 */
/* 1 */
/* 2 */
/* 3 */
/* 4 */
/* 5 */
/* 6 */
/* 7 */
/* 8 */
/* 9 */
/* 10 */
/* 11 */
/* 12 */
/* 13 */
/* 14 */
/* 15 */
/* 16 */
/* 17 */
/* 18 */
/* 19 */
/* 20 */
/* 21 */
/* 22 */
/* 23 */
/* 24 */
/* 25 */
/* 26 */
/* 27 */
/* 28 */
/* 29 */
/* 30 */
/* 31 */
/* 0 */
/* 1 */
/* 2 */
/* 3 */
/* 4 */
/* 5 */
/* 6 */
/* 7 */
/* 8 */
/* 9 */
/* 10     like otherADD */
/* 11     like otherSUB */
/* 12 */
/* 13 */
/* 14 */
/* 15 */
/* 16 */
/* 17 */
/* 18 */
/* 19 */
/* 20     like otherPUT    */
/* 21     like otherGET    */
/* 22     like otherIFELSE */
/* 23     like otherRANDOM */
/* 24     like otherMUL    */
/* 25 */
/* 26 */
/* 27     like otherDUP    */
/* 28     like otherEXCH   */
/* 29 */
/* 30 */
/* 31 */
/* 32 */
/* 33 */
/* 34 */
/* 35 */
/* 36 */
/* 37 */
/* `stemHintArray' does not change once we start drawing the outline. */
/* variable accumulates delta values from operand stack */
/* construct a CF2_StemHint and push it onto the list */
/* defer error check */
/* cf2_doStems must define a width (may be default) */
/*
/* lastError is used for errors that are immediately tested */
/* pointer to parsed font object */
/* save this for hinting seac accents */
/* first opcode byte */
/* instruction limit; 20,000,000 matches Avalon */
/* initialize to empty */
/* TODO: placeholders for hint structures */
/* objects used for hinting */
/* initialize the remaining objects */
/* initialize CF2_StemHint arrays */
/* initialize path map to manage drawing operations */
/* Note: last 4 params are used to handle `MoveToPermissive', which */
/*       may need to call `hintMap.Build'                           */
/* TODO: MoveToPermissive is gone; are these still needed?          */
/* hShift, */
/*
/*
/* allocate an operand stack */
/* initialize subroutine stack by placing top level charstring as */
/* first element (max depth plus one for the charstring)          */
/* Note: Caller owns and must finalize the first charstring.      */
/*       Our copy of it does not change that requirement.         */
/* structure copy */
/* entry is valid now */
/* catch errors so far */
/* main interpreter loop */
/* If we've reached the end of the charstring, simulate a */
/* cf2_cmdRETURN or cf2_cmdENDCHAR.                       */
/* end of buffer for subroutine */
/* end of buffer for top level charstring */
/* check for errors once per loop */
/* we may get here if we have a prior error */
/* never add hints after the mask is computed */
/* never add hints after the mask is computed */
/* width is defined or default after this */
/* no need to clear stack again */
/* no need to clear stack again */
/* max subr plus one for charstring */
/* overflow of stack */
/* push our current CFF charstring region on subrStack */
/* set up the new CFF region and pointer */
/* subroutine lookup or stream error */
/* cf2_cmdCALLSUBR */
/* subroutine lookup or stream error */
/* entry is valid now */
/* do not clear the stack */
/* Note: cannot return from top charstring */
/* underflow of stack */
/* restore position in previous charstring */
/* do not clear the stack */
/* something about `flip type of locking' -- ignore it */
/* TODO: should these operators be supported? */
/* in spec */
/* in spec */
/* in spec */
/* in spec */
/* in spec */
/* in spec */
/* in spec */
/* in spec */
/* in spec */
/* in spec */
/* in spec */
/* in spec */
/* in spec */
/* in spec */
/* in spec */
/* in spec */
/* in spec */
/* in spec */
/* in spec */
/* in spec */
/* dx1 */, FALSE /* dy1 */,
/* dx2 */, TRUE  /* dy2 */,
/* dx3 */, FALSE /* dy3 */,
/* dx4 */, FALSE /* dy4 */,
/* dx5 */, FALSE /* dy5 */,
/* dx6 */, FALSE /* dy6 */
/* doConditionalLastRead */ );
/* dx1 */, TRUE /* dy1 */,
/* dx2 */, TRUE /* dy2 */,
/* dx3 */, TRUE /* dy3 */,
/* dx4 */, TRUE /* dy4 */,
/* dx5 */, TRUE /* dy5 */,
/* dx6 */, TRUE /* dy6 */
/* doConditionalLastRead */ );
/* TODO: why is this not a continue? */
/* dx1 */, TRUE  /* dy1 */,
/* dx2 */, TRUE  /* dy2 */,
/* dx3 */, FALSE /* dy3 */,
/* dx4 */, FALSE /* dy4 */,
/* dx5 */, TRUE  /* dy5 */,
/* dx6 */, FALSE /* dy6 */
/* doConditionalLastRead */ );
/* dx1 */, TRUE  /* dy1 */,
/* dx2 */, TRUE  /* dy2 */,
/* dx3 */, TRUE  /* dy3 */,
/* dx4 */, TRUE  /* dy4 */,
/* dx5 */, TRUE  /* dy5 */,
/* dx6 */, FALSE /* dy6 */
/* doConditionalLastRead */ );
/* end of switch statement checking `op2' */
/* case cf2_cmdESC */
/* width is defined or default after this */
/* close path if still open */
/* must be either 4 or 5 --                       */
/* this is a (deprecated) implied `seac' operator */
/* ignore component width */
/* nested seac */
/* pass FreeType error through */
/* pass FreeType error through */
/* the final \n in the tracing message gets added in      */
/* `cf2_hintmask_read' (which also traces the mask bytes) */
/* never add hints after the mask is computed */
/* if there are arguments on the stack, there this is an */
/* implied cf2_cmdVSTEMHM                                */
/* consume the hint mask bytes which follow the operator */
/*
/* width is defined or default after this */
/* width is defined or default after this */
/* no need to clear stack again */
/* no need to clear stack again */
/* no need to clear stack again */
/* no need to clear stack again */
/* numbers */
/* op1 >= 32 && */ op1 <= 246 )
/* -107 .. 107 */
/* op1 >= 247 && */ op1 <= 250 )
/* 108 .. 1131 */
/* op1 >= 251 && */ op1 <= 254 )
/* -1131 .. -108 */
/* op1 == 255 */
/* don't clear stack */
/* end of switch statement checking `op1' */
/* end of main interpreter loop */
/* we get here if the charstring ends without cf2_cmdENDCHAR */
/* check whether last error seen is also the first one */
/* free resources from objects we've used */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cff\cf2read.c
/***************************************************************************/
/*                                                                         */
/*  cf2read.c                                                              */
/*                                                                         */
/*    Adobe's code for stream handling (body).                             */
/*                                                                         */
/*  Copyright 2007-2013 Adobe Systems Incorporated.                        */
/*                                                                         */
/*  This software, and all works of authorship, whether in source or       */
/*  object code form as indicated by the copyright notice(s) included      */
/*  herein (collectively, the "Work") is made available, and may only be   */
/*  used, modified, and distributed under the FreeType Project License,    */
/*  LICENSE.TXT.  Additionally, subject to the terms and conditions of the */
/*  FreeType Project License, each contributor to the Work hereby grants   */
/*  to any individual or legal entity exercising permissions granted by    */
/*  the FreeType Project License and this section (hereafter, "You" or     */
/*  "Your") a perpetual, worldwide, non-exclusive, no-charge,              */
/*  royalty-free, irrevocable (except as stated in this section) patent    */
/*  license to make, have made, use, offer to sell, sell, import, and      */
/*  otherwise transfer the Work, where such license applies only to those  */
/*  patent claims licensable by such contributor that are necessarily      */
/*  infringed by their contribution(s) alone or by combination of their    */
/*  contribution(s) with the Work to which such contribution(s) was        */
/*  submitted.  If You institute patent litigation against any entity      */
/*  (including a cross-claim or counterclaim in a lawsuit) alleging that   */
/*  the Work or a contribution incorporated within the Work constitutes    */
/*  direct or contributory patent infringement, then any patent licenses   */
/*  granted to You under this License for that Work shall terminate as of  */
/*  the date such litigation is filed.                                     */
/*                                                                         */
/*  By using, modifying, or distributing the Work you indicate that you    */
/*  have read and understood the terms and conditions of the               */
/*  FreeType Project License as well as those provided in this section,    */
/*  and you accept them fully.                                             */
/*                                                                         */
/***************************************************************************/
/* Define CF2_IO_FAIL as 1 to enable random errors and random */
/* value errors in I/O.                                       */
/* set the .00 value to a nonzero probability */
/* for region buffer ReadByte (interp) function */
/* set the .00 value to a nonzero probability */
/* CF2_IO_FAIL */
/* Region Buffer                                      */
/*                                                    */
/* Can be constructed from a copied buffer managed by */
/* `FCM_getDatablock'.                                */
/* Reads bytes with check for end of buffer.          */
/* reading past the end of the buffer sets error and returns zero */
/* note: end condition can occur without error */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cff\cf2stack.c
/***************************************************************************/
/*                                                                         */
/*  cf2stack.c                                                             */
/*                                                                         */
/*    Adobe's code for emulating a CFF stack (body).                       */
/*                                                                         */
/*  Copyright 2007-2013 Adobe Systems Incorporated.                        */
/*                                                                         */
/*  This software, and all works of authorship, whether in source or       */
/*  object code form as indicated by the copyright notice(s) included      */
/*  herein (collectively, the "Work") is made available, and may only be   */
/*  used, modified, and distributed under the FreeType Project License,    */
/*  LICENSE.TXT.  Additionally, subject to the terms and conditions of the */
/*  FreeType Project License, each contributor to the Work hereby grants   */
/*  to any individual or legal entity exercising permissions granted by    */
/*  the FreeType Project License and this section (hereafter, "You" or     */
/*  "Your") a perpetual, worldwide, non-exclusive, no-charge,              */
/*  royalty-free, irrevocable (except as stated in this section) patent    */
/*  license to make, have made, use, offer to sell, sell, import, and      */
/*  otherwise transfer the Work, where such license applies only to those  */
/*  patent claims licensable by such contributor that are necessarily      */
/*  infringed by their contribution(s) alone or by combination of their    */
/*  contribution(s) with the Work to which such contribution(s) was        */
/*  submitted.  If You institute patent litigation against any entity      */
/*  (including a cross-claim or counterclaim in a lawsuit) alleging that   */
/*  the Work or a contribution incorporated within the Work constitutes    */
/*  direct or contributory patent infringement, then any patent licenses   */
/*  granted to You under this License for that Work shall terminate as of  */
/*  the date such litigation is filed.                                     */
/*                                                                         */
/*  By using, modifying, or distributing the Work you indicate that you    */
/*  have read and understood the terms and conditions of the               */
/*  FreeType Project License as well as those provided in this section,    */
/*  and you accept them fully.                                             */
/*                                                                         */
/***************************************************************************/
/* Allocate and initialize an instance of CF2_Stack.       */
/* Note: This function returns NULL on error (does not set */
/* `error').                                               */
/* for FT_QNEW */
/* initialize the structure; FT_QNEW zeroes it */
/* empty stack */
/* free the main structure */
/* stack overflow */
/* stack overflow */
/* this function is only allowed to pop an integer type */
/* underflow */
/* type mismatch */
/* Note: type mismatch is silently cast */
/* TODO: check this */
/* underflow */
/* Note: type mismatch is silently cast */
/* TODO: check this */
/* bounds error */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cff\cff.c
/***************************************************************************/
/*                                                                         */
/*  cff.c                                                                  */
/*                                                                         */
/*    FreeType OpenType driver component (body only).                      */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2013 by                                     */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cff\cffcmap.c
/***************************************************************************/
/*                                                                         */
/*  cffcmap.c                                                              */
/*                                                                         */
/*    CFF character mapping table (cmap) support (body).                   */
/*                                                                         */
/*  Copyright 2002-2007, 2010, 2013 by                                     */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****           CFF STANDARD (AND EXPERT) ENCODING CMAPS            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****              CFF SYNTHETIC UNICODE ENCODING CMAP              *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* can't build Unicode map for CID-keyed font */
/* because we don't know glyph names.         */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cff\cffdrivr.c
/***************************************************************************/
/*                                                                         */
/*  cffdrivr.c                                                             */
/*                                                                         */
/*    OpenType font driver implementation (body).                          */
/*                                                                         */
/*  Copyright 1996-2014 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                                                                 ****/
/****                          F A C E S                              ****/
/****                                                                 ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    cff_get_kerning                                                    */
/*                                                                       */
/* <Description>                                                         */
/*    A driver method used to return the kerning vector between two      */
/*    glyphs of the same face.                                           */
/*                                                                       */
/* <Input>                                                               */
/*    face        :: A handle to the source face object.                 */
/*                                                                       */
/*    left_glyph  :: The index of the left glyph in the kern pair.       */
/*                                                                       */
/*    right_glyph :: The index of the right glyph in the kern pair.      */
/*                                                                       */
/* <Output>                                                              */
/*    kerning     :: The kerning vector.  This is in font units for      */
/*                   scalable formats, and in pixels for fixed-sizes     */
/*                   formats.                                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* <Note>                                                                */
/*    Only horizontal layouts (left-to-right & right-to-left) are        */
/*    supported by this function.  Other layouts, or more sophisticated  */
/*    kernings, are out of scope of this method (the basic driver        */
/*    interface is meant to be simple).                                  */
/*                                                                       */
/*    They can be implemented by format-specific interfaces.             */
/*                                                                       */
/* TT_Face */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    cff_glyph_load                                                     */
/*                                                                       */
/* <Description>                                                         */
/*    A driver method used to load a glyph within a given glyph slot.    */
/*                                                                       */
/* <Input>                                                               */
/*    slot        :: A handle to the target slot object where the glyph  */
/*                   will be loaded.                                     */
/*                                                                       */
/*    size        :: A handle to the source face size at which the glyph */
/*                   must be scaled, loaded, etc.                        */
/*                                                                       */
/*    glyph_index :: The index of the glyph in the font file.            */
/*                                                                       */
/*    load_flags  :: A flag indicating what to load for this glyph.  The */
/*                   FT_LOAD_??? constants can be used to control the    */
/*                   glyph loading process (e.g., whether the outline    */
/*                   should be scaled, whether to load bitmaps or not,   */
/*                   whether to hint the outline, etc).                  */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* CFF_GlyphSlot */
/* CFF_Size      */
/* check whether we want a scaled outline or bitmap */
/* reset the size object if necessary */
/* these two objects must have the same parent */
/* now load the glyph outline if necessary */
/* force drop-out mode to 2 - irrelevant now */
/* slot->outline.dropout_mode = 2; */
/*
/* first, locate the sid in the charset table */
/* now, lookup the name itself */
/*
/* unsupported with CFF fonts */
/* not implemented            */
/*
/*
/*
/*
/*
/* CFF_Driver */
/* CFF_Driver */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                                                                 ****/
/****                D R I V E R  I N T E R F A C E                   ****/
/****                                                                 ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* CFF_Driver */
/* CFF_SERVICES_GET dereferences `library' in PIC mode */
/* `driver' is not yet evaluated in non-PIC mode */
/* we pass our request to the `sfnt' module */
/* The FT_DriverInterface structure is defined in ftdriver.h. */
/* module-specific interface */
/* now the specific driver fields */
/* FT_Face_AttachFunc */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cff\cffgload.c
/***************************************************************************/
/*                                                                         */
/*  cffgload.c                                                             */
/*                                                                         */
/*    OpenType Glyph Loader (body).                                        */
/*                                                                         */
/*  Copyright 1996-2014 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* for cf2_decoder_parse_charstrings */
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* deprecated, acts as no-op */
/* Type 1 opcodes: invalid but seen in real life */
/* do not remove */
/* count values which have the `CFF_COUNT_CHECK_WIDTH' flag set are  */
/* used for checking the width and requested numbers of arguments    */
/* only; they are set to zero afterwards                             */
/* the other two flags are informative only and unused currently     */
/* unknown */
/* rmoveto */
/* rlineto */
/* rrcurveto */
/* flex */
/* endchar */
/* hstem */
/* hintmask */
/* cntrmask */
/* dotsection */
/* abs */
/* blend */
/* drop */
/* put */
/* and */
/* callsubr */
/* hsbw */
/* seac */
/* sbw */
/* setcurrentpoint */
/* CFF_CONFIG_OPTION_OLD_ENGINE */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/**********                                                      *********/
/**********                                                      *********/
/**********             GENERIC CHARSTRING PARSING               *********/
/**********                                                      *********/
/**********                                                      *********/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    cff_builder_init                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Initializes a given glyph builder.                                 */
/*                                                                       */
/* <InOut>                                                               */
/*    builder :: A pointer to the glyph builder to initialize.           */
/*                                                                       */
/* <Input>                                                               */
/*    face    :: The current face object.                                */
/*                                                                       */
/*    size    :: The current size object.                                */
/*                                                                       */
/*    glyph   :: The current glyph object.                               */
/*                                                                       */
/*    hinting :: Whether hinting is active.                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    cff_builder_done                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Finalizes a given glyph builder.  Its contents can still be used   */
/*    after the call, but the function saves important information       */
/*    within the corresponding glyph slot.                               */
/*                                                                       */
/* <Input>                                                               */
/*    builder :: A pointer to the glyph builder to finalize.             */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    cff_compute_bias                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Computes the bias value in dependence of the number of glyph       */
/*    subroutines.                                                       */
/*                                                                       */
/* <Input>                                                               */
/*    in_charstring_type :: The `CharstringType' value of the top DICT   */
/*                          dictionary.                                  */
/*                                                                       */
/*    num_subrs          :: The number of glyph subroutines.             */
/*                                                                       */
/* <Return>                                                              */
/*    The bias value.                                                    */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    cff_decoder_init                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Initializes a given glyph decoder.                                 */
/*                                                                       */
/* <InOut>                                                               */
/*    decoder :: A pointer to the glyph builder to initialize.           */
/*                                                                       */
/* <Input>                                                               */
/*    face      :: The current face object.                              */
/*                                                                       */
/*    size      :: The current size object.                              */
/*                                                                       */
/*    slot      :: The current glyph object.                             */
/*                                                                       */
/*    hinting   :: Whether hinting is active.                            */
/*                                                                       */
/*    hint_mode :: The hinting mode.                                     */
/*                                                                       */
/* clear everything */
/* initialize builder */
/* initialize Type2 decoder */
/* this function is used to select the subfont */
/* and the locals subrs array                  */
/* manage CID fonts */
/* for CFFs without subfonts, this value has already been set */
/* for Adobe's CFF handler */
/* check that there is enough space for `count' more points */
/* add a new point, do not check space */
/* cf2_decoder_parse_charstrings uses 16.16 coordinates */
/* check space for a new on-curve point, then add it */
/* check space for a new contour, then add it */
/* if a path was begun, add its first on-curve point */
/* test whether we are building a new contour */
/* close the current contour */
/* We must not include the last point in the path if it */
/* is located on the first point.                       */
/* `delete' last point only if it coincides with the first    */
/* point and if it is not a control point (which can happen). */
/* Don't add contours only consisting of one point, i.e., */
/* check whether begin point and last point are the same. */
/* CID-keyed fonts don't have glyph names */
/* check range of standard char code */
/* Get code to SID mapping from `cff_standard_encoding'. */
/* For incremental fonts get the character data using the */
/* callback function.                                     */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* For incremental fonts get the character data using the */
/* callback function.                                     */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* Incremental fonts don't necessarily have valid charsets.        */
/* They use the character code, not the glyph index, in this case. */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* If we are trying to load a composite glyph, do not load the */
/* accent character and return the array of subglyphs.         */
/* reallocate subglyph array if necessary */
/* subglyph 0 = base character */
/* subglyph 1 = accent character */
/* set up remaining glyph fields */
/* First load `bchar' in builder */
/* the seac operator must not be nested */
/* Save the left bearing, advance and glyph width of the base */
/* character as they will be erased by the next load.         */
/* Now load `achar' on top of the base outline. */
/* the seac operator must not be nested */
/* Restore the left side bearing, advance and glyph width */
/* of the base character.                                 */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    cff_decoder_parse_charstrings                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Parses a given Type 2 charstrings program.                         */
/*                                                                       */
/* <InOut>                                                               */
/*    decoder         :: The current Type 1 decoder.                     */
/*                                                                       */
/* <Input>                                                               */
/*    charstring_base :: The base of the charstring stream.              */
/*                                                                       */
/*    charstring_len  :: The length in bytes of the charstring stream.   */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* set default width */
/* compute random seed from stack address of parameter */
/* initialize the decoder */
/* begin hints recording session, if any */
/* now execute loop */
/********************************************************************/
/*                                                                  */
/* Decode operator or operand                                       */
/*                                                                  */
/* this is an operand, push it on the stack */
/* if we use shifts, all computations are done with unsigned */
/* values; the conversion to a signed value is the last step */
/* The specification says that normally arguments are to be taken */
/* from the bottom of the stack.  However, this seems not to be   */
/* correct, at least for Acroread 7.0.8 on GNU/Linux: It pops the */
/* arguments similar to a PS interpreter.                         */
/* find operator */
/* this is actually the Type1 vstem3 operator */
/* this is actually the Type1 hstem3 operator */
/* check arguments */
/* If `nominal_width' is non-zero, the number is really a      */
/* difference against `nominal_width'.  Else, the number here  */
/* is truly a width, not a difference against `nominal_width'. */
/* If the font does not set `nominal_width', then              */
/* `nominal_width' defaults to zero, and so we can set         */
/* `glyph_width' to `nominal_width' plus number on the stack   */
/* -- for either case.                                         */
/* If there is a width specified for endchar, we either have */
/* 1 argument or 5 arguments.  We like to argue.             */
/* we only want the advance width; stop here */
/* Consumed an argument. */
/* At this point, `args' points to the first argument of the  */
/* operand in case `req_args' isn't zero.  Otherwise, we have */
/* to adjust `args' manually.                                 */
/* Note that we only pop arguments from the stack which we    */
/* really need and can digest so that we can continue in case */
/* of superfluous stack elements.                             */
/* the number of arguments is always even here */
/* implement vstem when needed --                        */
/* the specification doesn't say it, but this also works */
/* with the 'cntrmask' operator                          */
/*                                                       */
/* In a valid charstring there must be at least one byte */
/* after `hintmask' or `cntrmask' (e.g., for a `return'  */
/* instruction).  Additionally, there must be space for  */
/* `num_hints' bits.                                     */
/* there exist subsetted fonts (found in PDFs) */
/* which call `hlineto' without arguments      */
/* if num_args isn't of the form 4n or 4n+1, */
/* we enforce it by clearing the second bit  */
/* if num_args isn't of the form 4n or 4n+1, */
/* we enforce it by clearing the second bit  */
/* if num_args isn't of the form 8n, 8n+1, 8n+4, or 8n+5, */
/* we enforce it by clearing the second bit               */
/* first, add the line segments */
/* then the curve */
/* first, add the curves */
/* then the final line */
/* adding five more points: 4 control points, 1 on-curve point */
/* -- make sure we have enough space for the start point if it */
/* needs to be added                                           */
/* record the starting point's y position for later use */
/* first control point */
/* second control point */
/* join point; on curve, with y-value the same as the last */
/* control point's y-value                                 */
/* third control point, with y-value the same as the join */
/* point's y-value                                        */
/* fourth control point */
/* ending point, with y-value the same as the start   */
/* adding six more points; 4 control points, 2 on-curve points */
/* record the starting point's y-position for later use */
/* first control point */
/* second control point */
/* join point; on curve, with y-value the same as the last */
/* control point's y-value                                 */
/* third control point, with y-value the same as the join */
/* point's y-value                                        */
/* fourth control point */
/* ending point, with y-value the same as the start point's */
/* y-value -- we don't add this point, though               */
/* record start x, y values for */
/* alter use                    */
/* used in horizontal/vertical  */
/* algorithm below              */
/* adding six more points; 4 control points, 2 on-curve points */
/* record the starting point's x, y position for later use */
/* XXX: figure out whether this is supposed to be a horizontal */
/*      or vertical flex; the Type 2 specification is vague... */
/* grab up to the last argument */
/* strange test, but here it is... */
/* is last operand an x- or y-delta? */
/* add current outline to the glyph slot */
/* return now! */
/* We are going to emulate the seac operator. */
/* Save glyph width so that the subglyphs don't overwrite it. */
/* close hints recording session */
/* apply hints to the loaded glyph outline now */
/* add current outline to the glyph slot */
/* return now! */
/* nothing */
/* this operator is deprecated and ignored by the parser */
/* this is an invalid Type 2 operator; however, there        */
/* exist fonts which are incorrectly converted from probably */
/* Type 1 to CFF, and some parsers seem to accept it         */
/* this is an invalid Type 2 operator; however, there        */
/* exist fonts which are incorrectly converted from probably */
/* Type 1 to CFF, and some parsers seem to accept it         */
/* this is an invalid Type 2 operator; however, there        */
/* exist fonts which are incorrectly converted from probably */
/* Type 1 to CFF, and some parsers seem to accept it         */
/* this is an invalid Type 2 operator; however, there        */
/* exist fonts which are incorrectly converted from probably */
/* Type 1 to CFF, and some parsers seem to accept it         */
/* this is an invalid Type 2 operator; however, there        */
/* exist fonts which are incorrectly converted from probably */
/* Type 1 to CFF, and some parsers seem to accept it         */
/* subsequent `pop' operands should add the arguments,       */
/* this is the implementation described for `unknown' other  */
/* subroutines in the Type1 spec.                            */
/*                                                           */
/* XXX Fix return arguments (see discussion below).          */
/* this is an invalid Type 2 operator; however, there        */
/* exist fonts which are incorrectly converted from probably */
/* Type 1 to CFF, and some parsers seem to accept it         */
/* XXX Increasing `args' is wrong: After a certain number of */
/* `pop's we get a stack overflow.  Reason for doing it is   */
/* code like this (actually found in a CFF font):            */
/*                                                           */
/*   17 1 3 callothersubr                                    */
/*   pop                                                     */
/*   callsubr                                                */
/*                                                           */
/* Since we handle `callothersubr' as a no-op, and           */
/* `callsubr' needs at least one argument, `pop' can't be a  */
/* no-op too as it basically should be.                      */
/*                                                           */
/* The right solution would be to provide real support for   */
/* `callothersubr' as done in `t1decode.c', however, given   */
/* the fact that CFF fonts with `pop' are invalid, it is     */
/* questionable whether it is worth the time.                */
/* save current instruction pointer */
/* save current instruction pointer */
/* general operator processing */
/* while ip < limit */
/* CFF_CONFIG_OPTION_OLD_ENGINE */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/**********                                                      *********/
/**********                                                      *********/
/**********            COMPUTE THE MAXIMUM ADVANCE WIDTH         *********/
/**********                                                      *********/
/**********    The following code is in charge of computing      *********/
/**********    the maximum advance width of the font.  It        *********/
/**********    quickly processes each glyph charstring to        *********/
/**********    extract the value from either a `sbw' or `seac'   *********/
/**********    operator.                                         *********/
/**********                                                      *********/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* unused until we support pure CFF fonts */
/* Initialize load decoder */
/* For each glyph, parse the glyph charstring and extract */
/* the advance width.                                     */
/* now get load the unscaled outline */
/* ignore the error if one has occurred -- skip to next glyph */
/* 0 */
/* in a CID-keyed font, consider `glyph_index' as a CID and map */
/* it immediately to the real glyph_index -- if it isn't a      */
/* subsetted font, glyph_indices and CIDs are identical, though */
/* don't handle CID 0 (.notdef) which is directly mapped to GID 0 */
/* try to load embedded bitmap if any              */
/*                                                 */
/* XXX: The convention should be emphasized in     */
/*      the documents because it can be confusing. */
/* compute linear advance widths */
/* get the vertical metrics from the vtmx table if we have one */
/* make up vertical ones */
/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
/* return immediately if we only want the embedded bitmaps */
/* if we have a CID subfont, use its matrix (which has already */
/* been multiplied with the root matrix)                       */
/* this scaling is only relevant if the PS hinter isn't active */
/* top-level code ensures that FT_LOAD_NO_HINTING is set */
/* if FT_LOAD_NO_SCALE is active                         */
/* by default */
/* now load the unscaled outline */
/* choose which CFF renderer to use */
/* Adobe's engine uses 16.16 numbers everywhere;              */
/* as a consequence, glyphs larger than 2000ppem get rejected */
/* this time, we retry unhinted and scale up the glyph later on */
/* (the engine uses and sets the hardcoded value 0x10000 / 64 = */
/* 0x400 for both `x_scale' and `y_scale' in this case)         */
/* Control data and length may not be available for incremental */
/* fonts.                                                       */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* We set control_data and control_len if charstrings is loaded. */
/* See how charstring loads at cff_index_access_element() in     */
/* cffload.c.                                                    */
/* save new glyph tables, if no error */
/* XXX: anything to do for broken glyph entry? */
/* Incremental fonts can optionally override the metrics. */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* Now, set the metrics -- this is rather simple, as   */
/* the left side bearing is the xMin, and the top side */
/* bearing the yMax.                                   */
/* For composite glyphs, return only left side bearing and */
/* advance width.                                          */
/* copy the _unscaled_ advance width */
/* get the vertical metrics from the vtmx table if we have one */
/* make up vertical ones */
/* scale the outline and the metrics */
/* First of all, scale the points */
/* Then scale the metrics */
/* compute the other metrics */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cff\cffload.c
/***************************************************************************/
/*                                                                         */
/*  cffload.c                                                              */
/*                                                                         */
/*    OpenType and CFF data/program tables loader (body).                  */
/*                                                                         */
/*  Copyright 1996-2014 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* 1 */
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* read an offset from the index's stream current position */
/* there is at least one element; read the offset size,           */
/* then access the offset table to compute the index's total size */
/* load the data */
/* skip the data */
/* Allocate a table containing pointers to an index's elements. */
/* The `pool' argument makes this function convert the index    */
/* entries to C-style strings (this is, NULL-terminated).       */
/* at this point, `idx->offsets' can't be NULL */
/* sanity check */
/* two sanity checks for invalid offset tables */
/* compute start and end offsets */
/* load offsets from file or the offset table */
/* use offsets table */
/* XXX: should check off2 does not exceed the end of this entry; */
/*      at present, only truncate off2 at the end of this stream */
/* access element */
/* this index was completely loaded in memory, that's easy */
/* this index is still on disk/file, access it through a frame */
/* empty index element */
/* get an entry from Name INDEX */
/* get an entry from String INDEX */
/* value 0xFFFFU indicates a missing dictionary entry */
/* if it is not a standard string, return it */
/* CID-keyed CFF fonts don't have glyph names */
/* this is a standard string */
/*************************************************************************/
/*************************************************************************/
/***                                                                   ***/
/***   FD Select table support                                         ***/
/***                                                                   ***/
/*************************************************************************/
/*************************************************************************/
/* read format */
/* clear cache */
/* format 0, that's simple */
/* format 3, a tad more complex */
/* hmm... that's wrong */
/* first, compare to the cache */
/* then, look up the ranges array */
/* update cache */
/*************************************************************************/
/*************************************************************************/
/***                                                                   ***/
/***   CFF font support                                                ***/
/***                                                                   ***/
/*************************************************************************/
/*************************************************************************/
/* When multiple GIDs map to the same CID, we choose the lowest */
/* GID.  This is not described in any spec, but it matches the  */
/* behaviour of recent Acroread versions.                       */
/* If the the offset is greater than 2, we have to parse the */
/* charset table.                                            */
/* Get the format of the table. */
/* Allocate memory for sids. */
/* assign the .notdef glyph */
/* Read the first glyph sid of the range. */
/* Read the number of glyphs in the range.  */
/* try to rescue some of the SIDs if `nleft' is too large */
/* Fill in the range of sids -- `nleft + 1' glyphs. */
/* Parse default tables corresponding to offset == 0, 1, or 2.  */
/* CFF specification intimates the following:                   */
/*                                                              */
/* In order to use a predefined charset, the following must be  */
/* true: The charset constructed for the glyphs in the font's   */
/* charstrings dictionary must match the predefined charset in  */
/* the first num_glyphs.                                        */
/* record charset type */
/* Allocate memory for sids. */
/* Copy the predefined charset into the allocated memory. */
/* Allocate memory for sids. */
/* Copy the predefined charset into the allocated memory.     */
/* Allocate memory for sids. */
/* Copy the predefined charset into the allocated memory.     */
/* we have to invert the `sids' array for subsetted CID-keyed fonts */
/* Clean up if there was an error. */
/* Check for charset->sids.  If we do not have this, we fail. */
/* Zero out the code to gid/sid mappings. */
/* Note: The encoding table in a CFF font is indexed by glyph index;  */
/* the first encoded glyph index is 1.  Hence, we read the character  */
/* code (`glyph_code') at index j and make the assignment:            */
/*                                                                    */
/*    encoding->codes[glyph_code] = j + 1                             */
/*                                                                    */
/* We also make the assignment:                                       */
/*                                                                    */
/*    encoding->sids[glyph_code] = charset->sids[j + 1]               */
/*                                                                    */
/* This gives us both a code to GID and a code to SID mapping.        */
/* we need to parse the table to determine its size */
/* By convention, GID 0 is always ".notdef" and is never */
/* coded in the font.  Hence, the number of codes found  */
/* in the table is `count+1'.                            */
/*                                                       */
/* Make sure j is not too big. */
/* Assign code to GID mapping. */
/* Assign code to SID mapping. */
/* Parse the Format1 ranges. */
/* Read the first glyph code of the range. */
/* Read the number of codes in the range. */
/* Increment nleft, so we read `nleft + 1' codes/sids. */
/* compute max number of character codes */
/* Fill in the range of codes/sids. */
/* Make sure k is not too big. */
/* Assign code to GID mapping. */
/* Assign code to SID mapping. */
/* simple check; one never knows what can be found in a font */
/* Parse supplemental encodings, if any. */
/* count supplements */
/* Read supplemental glyph code. */
/* Read the SID associated with this glyph code. */
/* Assign code to SID mapping. */
/* First, look up GID which has been assigned to */
/* SID glyph_sid.                                */
/* We take into account the fact a CFF font can use a predefined */
/* encoding without containing all of the glyphs encoded by this */
/* encoding (see the note at the end of section 12 in the CFF    */
/* specification).                                               */
/* First, copy the code to SID mapping. */
/* First, copy the code to SID mapping. */
/* Construct code to GID mapping from code to SID mapping */
/* and charset.                                           */
/* Clean up if there was an error. */
/* set defaults */
/* we use the implementation specific SID value 0xFFFF to indicate */
/* missing entries                                                 */
/* if it is a CID font, we stop there */
/* parse the private dictionary, if any */
/* set defaults */
/* ensure that `num_blue_values' is even */
/* read the local subrs, if any */
/* read CFF font header */
/* check format */
/* skip the rest of the header */
/* read the name, top dict, string and global subrs index */
/* well, we don't really forget the `disabled' fonts... */
/* in case of a font format check, simply exit now */
/* now, parse the top-level font dictionary */
/* now, check for a CID font */
/* this is a CID-keyed font, we must now allocate a table of */
/* sub-fonts, then load each of them separately              */
/* allocate & read each font dict independently */
/* set up pointer table */
/* now load each subfont independently */
/* now load the FD Select array */
/* read the charstrings index now */
/* read the Charset and Encoding tables if available */
/* CID-keyed CFFs don't have an encoding */
/* get the font name (/CIDFontName for CID-keyed fonts, */
/* /FontName otherwise)                                 */
/* release font dictionaries, but only if working with */
/* a CID keyed CFF font                                */
/* the subfonts array has been allocated as a single block */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cff\cffobjs.c
/***************************************************************************/
/*                                                                         */
/*  cffobjs.c                                                              */
/*                                                                         */
/*    OpenType objects manager (body).                                     */
/*                                                                         */
/*  Copyright 1996-2014 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/*                            SIZE FUNCTIONS                             */
/*                                                                       */
/*  Note that we store the global hints in the size's `internal' root    */
/*  field.                                                               */
/*                                                                       */
/*************************************************************************/
/* CFF_Size */
/* `internal' is freed by destroy_size (in ftobjs.c) */
/* CFF and Type 1 private dictionaries have slightly different      */
/* structures; we need to synthesize a Type 1 dictionary on the fly */
/* CFF_Size */
/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
/*************************************************************************/
/*                                                                       */
/*                            SLOT  FUNCTIONS                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/*                           FACE  FUNCTIONS                             */
/*                                                                       */
/*************************************************************************/
/* Strip all subset prefixes of the form `ABCDEF+'.  Usually, there */
/* is only one, but font names like `APCOOG+JFABTD+FuturaBQ-Bold'   */
/* have been seen in the wild.                                      */
/* ASCII uppercase letters */
/* Remove the style part from the family name (if present). */
/* family_name ends with style_name; remove it */
/* also remove special characters     */
/* between real family name and style */
/* CFF_Face */
/* create input stream from resource */
/* check whether we have a valid OpenType file */
/* `OTTO'; OpenType/CFF font */
/* if we are performing a simple font format check, exit immediately */
/* now, the font can be either an OpenType/CFF font, or an SVG CEF */
/* font; in the latter case it doesn't have a `head' table         */
/* load font directory */
/* load the `cmap' table explicitly */
/* now load the CFF part of the file */
/* rewind to start of file; we are going to load a pure-CFF font */
/* now load and parse the CFF table in the file */
/* Complement the root flags with some interesting information. */
/* Note that this is only necessary for pure CFF and CEF fonts; */
/* SFNT based fonts use the `name' table instead.               */
/* we need the `PSNames' module for CFF and CEF formats */
/* which aren't CID-keyed                               */
/* dump string index, including default strings for convenience */
/* FT_DEBUG_LEVEL_TRACE */
/* Normalize the font matrix so that `matrix->xx' is 1; the */
/* scaling is done with `units_per_em' then (at this point, */
/* it already contains the scaling factor, but without      */
/* normalization of the matrix).                            */
/*                                                          */
/* Note that the offsets must be expressed in integer font  */
/* units.                                                   */
/* if we have a top-level matrix, */
/* concatenate the subfont matrix */
/* set up num_faces */
/* compute number of glyphs */
/* set global bbox, as well as EM size */
/* no `U' suffix here to 0xFFFF! */
/* retrieve font family & style name */
/* We try to extract the style name from the full name.   */
/* We need to ignore spaces and dashes during the search. */
/* skip common characters at the start of both strings */
/* ignore spaces and dashes in full name during comparison */
/* ignore spaces and dashes in family name during comparison */
/* The full name begins with the same characters as the  */
/* family name, with spaces and dashes removed.  In this */
/* case, the remaining string in `fullp' will be used as */
/* the style name.                                       */
/* remove the style part from the family name (if present) */
/* do we have a `/FontName' for a CID-keyed font? */
/* assume "Regular" style if we don't know better */
/*******************************************************************/
/*                                                                 */
/* Compute face flags.                                             */
/*                                                                 */
/* scalable outlines */
/* horizontal data   */
/* has native hinter */
/* fixed width font? */
/* XXX: WE DO NOT SUPPORT KERNING METRICS IN THE GPOS TABLE FOR NOW */
/* kerning available? */
/*******************************************************************/
/*                                                                 */
/* Compute style flags.                                            */
/*                                                                 */
/* double check */
/* CID-keyed CFF fonts don't have glyph names -- the SFNT loader */
/* has unset this flag because of the 3.0 `post' table.          */
/*******************************************************************/
/*                                                                 */
/* Compute char maps.                                              */
/*                                                                 */
/* Try to synthesize a Unicode charmap if there is none available */
/* already.  If an OpenType font contains a Unicode "cmap", we    */
/* will use it, whatever be in the CFF part of the file.          */
/* Windows Unicode? */
/* Apple Unicode platform id? */
/* Apple Unicode */
/* since CID-keyed fonts don't contain glyph names, we can't */
/* construct a cmap                                          */
/* we didn't find a Unicode charmap -- synthesize one */
/* if no Unicode charmap was previously selected, select this one */
/* Adobe platform id */
/* CFF_Face */
/* CFF_Driver */
/* set default property values, cf. `ftcffdrv.h' */
/* CFF_Driver */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cff\cffparse.c
/***************************************************************************/
/*                                                                         */
/*  cffparse.c                                                             */
/*                                                                         */
/*    CFF token stream parser (body)                                       */
/*                                                                         */
/*  Copyright 1996-2004, 2007-2014 by                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* read an integer */
/* read a real */
/* First of all, read the integer part. */
/* If we entered this iteration with phase == 4, we need to */
/* read a new byte.  This also skips past the initial 0x1E. */
/* Make sure we don't read past the end. */
/* Get the nibble. */
/* Increase exponent if we can't add the digit. */
/* Skip leading zeros. */
/* Read fraction part, if any. */
/* If we entered this iteration with phase == 4, we need */
/* to read a new byte.                                   */
/* Make sure we don't read past the end. */
/* Get the nibble. */
/* Skip leading zeros if possible. */
/* Only add digit if we don't overflow. */
/* Read exponent, if any. */
/* If we entered this iteration with phase == 4, */
/* we need to read a new byte.                   */
/* Make sure we don't read past the end. */
/* Get the nibble. */
/* Arbitrarily limit exponent. */
/* We don't check `power_ten' and `exponent_add'. */
/* Only use `fraction_length'. */
/* Make `scaling' as small as possible. */
/* Remove non-significant digits. */
/* this can only happen if exponent was non-zero */
/* Convert into 16.16 format. */
/* read a number, either integer or real */
/* read a floating point number, either integer or real */
/* read a floating point number, either integer or real */
/* read a floating point number, either integer or real, */
/* but return `10^scaling' times the number read in      */
/* read a floating point number, either integer or real,     */
/* and return it as precise as possible -- `scaling' returns */
/* the scaling factor (as a power of 10)                     */
/* We expect a well-formed font matrix, this is, the matrix elements */
/* `xx' and `yy' are of approximately the same magnitude.  To avoid  */
/* loss of precision, we use the magnitude of element `xx' to scale  */
/* all other elements.  The scaling factor is then contained in the  */
/* `units_per_em' value.                                             */
/* Return default matrix in case of unlikely values. */
/* FT_DEBUG_LEVEL_TRACE */
/* FT_DEBUG_LEVEL_TRACE */
/* FT_CONFIG_OPTION_PIC */
/* { 0, 0, 0, 0, 0, 0, 0 } */
/* FT_DEBUG_LEVEL_TRACE */
/* FT_DEBUG_LEVEL_TRACE */
/* FT_CONFIG_OPTION_PIC */
/* it's a number; we will push its position on the stack */
/* now, skip it */
/* skip real number */
/* An unterminated floating point number at the */
/* end of a dictionary is invalid but harmless. */
/* This is not a number, hence it's an operator.  Compute its code */
/* and look for it in our current list.                            */
/* two byte operator */
/* we found our field's handler; read it */
/* check that we have enough arguments -- except for */
/* delta encoded arrays, which can be empty          */
/* for 64-bit systems */
/* never reached */
/* store count */
/* for 64-bit systems */
/* callback */
/* this is an unknown operator, or it is unsupported; */
/* we will ignore it for now.                         */
/* clear stack */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cff\cffpic.c
/***************************************************************************/
/*                                                                         */
/*  cffpic.c                                                               */
/*                                                                         */
/*    The FreeType position independent code services for cff module.      */
/*                                                                         */
/*  Copyright 2009, 2010, 2012, 2013 by                                    */
/*  Oran Agra and Mickey Gabel.                                            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* forward declaration of PIC init functions from cffdrivr.c */
/* forward declaration of PIC init functions from cffparse.c */
/* allocate pointer, clear and set global container pointer */
/* initialize pointer table -                       */
/* this is how the module usually expects this data */
/* FT_CONFIG_OPTION_PIC */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cid\cidgload.c
/***************************************************************************/
/*                                                                         */
/*  cidgload.c                                                             */
/*                                                                         */
/*    CID-keyed Type1 Glyph Loader (body).                                 */
/*                                                                         */
/*  Copyright 1996-2007, 2009, 2010, 2013 by                               */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* For incremental fonts get the character data using */
/* the callback function.                             */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* For ordinary fonts read the CID font dictionary index */
/* and charstring offset from the CIDMap.                */
/* Now set up the subrs array and parse the charstrings. */
/* Set up subrs */
/* Set up font matrix */
/* Decode the charstring. */
/* Adjustment for seed bytes. */
/* Decrypt only if lenIV >= 0. */
/* Incremental fonts can optionally override the metrics. */
/* FT_CONFIG_OPTION_INCREMENTAL */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/**********                                                      *********/
/**********                                                      *********/
/**********            COMPUTE THE MAXIMUM ADVANCE WIDTH         *********/
/**********                                                      *********/
/**********    The following code is in charge of computing      *********/
/**********    the maximum advance width of the font.  It        *********/
/**********    quickly processes each glyph charstring to        *********/
/**********    extract the value from either a `sbw' or `seac'   *********/
/**********    operator.                                         *********/
/**********                                                      *********/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* Initialize load decoder */
/* size       */
/* glyph slot */
/* glyph names! XXX */
/* blend == 0 */
/* hinting == 0 */
/* TODO: initialize decoder.len_buildchar and decoder.buildchar */
/*       if we ever support CID-keyed multiple master fonts     */
/* for each glyph, parse the glyph charstring and extract */
/* the advance width                                      */
/* now get load the unscaled outline */
/* ignore the error if one occurred - skip to next glyph */
/* 0 */
/* CID_GlyphSlot */
/* CID_Size      */
/* glyph names -- XXX */
/* blend == 0 */
/* TODO: initialize decoder.len_buildchar and decoder.buildchar */
/*       if we ever support CID-keyed multiple master fonts     */
/* set up the decoder */
/* save new glyph tables */
/* now set the metrics -- this is rather simple, as    */
/* the left side bearing is the xMin, and the top side */
/* bearing the yMax                                    */
/* for composite glyphs, return only left side bearing and */
/* advance width                                           */
/* copy the _unscaled_ advance width */
/* make up vertical ones */
/* apply the font matrix */
/* scale the outline and the metrics */
/* First of all, scale the points */
/* Then scale the metrics */
/* compute the other metrics */
/* make up vertical ones */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cid\cidload.c
/***************************************************************************/
/*                                                                         */
/*  cidload.c                                                              */
/*                                                                         */
/*    CID-keyed Type1 font loader (body).                                  */
/*                                                                         */
/*  Copyright 1996-2006, 2009, 2011-2014 by                                */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* read a single offset */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    TYPE 1 SYMBOL PARSING                      *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* if the keyword has a dedicated callback, call it */
/* we must now compute the address of our target object */
/* now, load the keyword data in the object's field(s) */
/* Set Units per EM based on FontMatrix values.  We set the value to */
/* 1000 / temp_scale, because temp_scale was already multiplied by   */
/* 1000 (in t1_tofixed, from psobjs.c).                              */
/* we need to scale the values by 1.0/temp[3] */
/* note that the font offsets are expressed in integer font units */
/* don't forget to set a few defaults */
/* default value for lenIV */
/* by mistake, `expansion_factor' appears both in PS_PrivateRec */
/* and CID_FaceDictRec (both are public header files and can't  */
/* changed); we simply copy the value                           */
/* look for `%ADOBeginFontDict' */
/* if /FDArray was found, then cid->num_dicts is > 0, and */
/* we can start increasing parser->num_dict               */
/* no error can occur in cid_parser_skip_spaces */
/* look for immediates */
/* now compare the immediate name to the keyword table */
/* we found it - run the parsing callback */
/* read the subrmap and the subrs of each font dict */
/* Check for possible overflow. */
/* reallocate offsets array if needed */
/* read the subrmap's offsets */
/* offsets must be ordered */
/* now, compute the size of subrs charstrings, */
/* allocate, and read them                     */
/* set up pointers */
/* decrypt subroutines, but only if lenIV >= 0 */
/* finalize parser */
/* we must convert the data section from hexadecimal to binary */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cid\cidobjs.c
/***************************************************************************/
/*                                                                         */
/*  cidobjs.c                                                              */
/*                                                                         */
/*    CID objects manager (body).                                          */
/*                                                                         */
/*  Copyright 1996-2006, 2008, 2010-2011, 2013 by                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/*                            SLOT  FUNCTIONS                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/*                           SIZE  FUNCTIONS                             */
/*                                                                       */
/*************************************************************************/
/* CID_Size */
/* CID_Size */
/*************************************************************************/
/*                                                                       */
/*                           FACE  FUNCTIONS                             */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    cid_face_done                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Finalizes a given face object.                                     */
/*                                                                       */
/* <Input>                                                               */
/*    face :: A pointer to the face object to destroy.                   */
/*                                                                       */
/* CID_Face */
/* release subrs */
/* release FontInfo strings */
/* release font dictionaries */
/* release other strings */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    cid_face_init                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Initializes a given CID face object.                               */
/*                                                                       */
/* <Input>                                                               */
/*    stream     :: The source font stream.                              */
/*                                                                       */
/*    face_index :: The index of the font face in the resource.          */
/*                                                                       */
/*    num_params :: Number of additional generic parameters.  Ignored.   */
/*                                                                       */
/*    params     :: Additional generic parameters.  Ignored.             */
/*                                                                       */
/* <InOut>                                                               */
/*    face       :: The newly built face object.                         */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* CID_Face */
/* open the tokenizer; this will also check the font format */
/* if we just wanted to check the format, leave successfully now */
/* check the face index */
/* XXX: handle CID fonts with more than a single face */
/* now load the font program into the face object */
/* initialize the face object fields */
/* set up root face fields */
/* scalable outlines */
/* horizontal data   */
/* has native hinter */
/* XXX: TODO: add kerning with .afm support */
/* get style name -- be careful, some broken fonts only */
/* have a /FontName dictionary entry!                   */
/* assume "Regular" style if we don't know better */
/* do we have a `/FontName'? */
/* compute style flags */
/* no embedded bitmap support */
/* no `U' suffix here to 0xFFFF! */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    cid_driver_init                                                    */
/*                                                                       */
/* <Description>                                                         */
/*    Initializes a given CID driver object.                             */
/*                                                                       */
/* <Input>                                                               */
/*    driver :: A handle to the target driver object.                    */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    cid_driver_done                                                    */
/*                                                                       */
/* <Description>                                                         */
/*    Finalizes a given CID driver.                                      */
/*                                                                       */
/* <Input>                                                               */
/*    driver :: A handle to the target CID driver.                       */
/*                                                                       */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cid\cidparse.c
/***************************************************************************/
/*                                                                         */
/*  cidparse.c                                                             */
/*                                                                         */
/*    CID-keyed Type1 parser (body).                                       */
/*                                                                         */
/*  Copyright 1996-2007, 2009, 2013, 2014 by                               */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    INPUT STREAM PARSER                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* first of all, check the font format in the header */
/* now, read the rest of the file until we find */
/* `StartData' or `/sfnts'                      */
/* same as signed FT_Stream->size */
/* same as signed FT_Stream->size */
/* save offset of binary data after `StartData' */
/* We have found the start of the binary data or the `/sfnts' token. */
/* Now rewind and extract the frame corresponding to this PostScript */
/* section.                                                          */
/* Finally, we check whether `StartData' or `/sfnts' was real --  */
/* it could be in a comment or string.  We also get the arguments */
/* of `StartData' to find out whether the data is represented in  */
/* binary or hex format.                                          */
/* we haven't found the correct `StartData'; go back and continue */
/* searching                                                      */
/* always free the private dictionary */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cid\cidriver.c
/***************************************************************************/
/*                                                                         */
/*  cidriver.c                                                             */
/*                                                                         */
/*    CID driver interface (body).                                         */
/*                                                                         */
/*  Copyright 1996-2004, 2006, 2008, 2009, 2011, 2013 by                   */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*
/*
/* unsupported with CID fonts */
/* unsupported                */
/* not implemented            */
/*
/* cid driver is only used for CID keyed fonts */
/* identity mapping */
/*
/* first of all, the FT_Module_Class fields */
/* module name           */
/* version 1.0 of driver */
/* requires FreeType 2.0 */
/* then the other font drivers fields */
/* FT_Face_GetKerningFunc  */
/* FT_Face_AttachFunc      */
/* FT_Face_GetAdvancesFunc */
/* FT_Size_SelectFunc      */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\cid\type1cid.c
/***************************************************************************/
/*                                                                         */
/*  type1cid.c                                                             */
/*                                                                         */
/*    FreeType OpenType driver component (body only).                      */
/*                                                                         */
/*  Copyright 1996-2001 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gxvalid\gxvalid.c
/***************************************************************************/
/*                                                                         */
/*  gxvalid.c                                                              */
/*                                                                         */
/*    FreeType validator for TrueTypeGX/AAT tables (body only).            */
/*                                                                         */
/*  Copyright 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K.,       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gxvalid\gxvbsln.c
/***************************************************************************/
/*                                                                         */
/*  gxvbsln.c                                                              */
/*                                                                         */
/*    TrueTypeGX/AAT bsln table validation (body).                         */
/*                                                                         */
/*  Copyright 2004, 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K., */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      Data and Types                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      UTILITY FUNCTIONS                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*
/* XXX: check range ? */
/* deltas */
/* No ctlPoints here. */
/* deltas */
/* mappingData */
/* stdGlyph */
/* Record the position of ctlPoints */
/* ctlPoints */
/* stdGlyph + ctlPoints */
/* mappingData */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                         bsln TABLE                            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* only version 1.0 is defined (1996) */
/* only format 1, 2, 3 are defined (1996) */
/* arch-tag: ebe81143-fdaa-4c68-a4d1-b57227daa3bc
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gxvalid\gxvcommn.c
/***************************************************************************/
/*                                                                         */
/*  gxvcommn.c                                                             */
/*                                                                         */
/*    TrueTypeGX/AAT common tables validation (body).                      */
/*                                                                         */
/*  Copyright 2004, 2005, 2009, 2010, 2013                                 */
/*  by suzuki toshiya, Masatake YAMATO, Red Hat K.K.,                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                       16bit offset sorter                     *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                       32bit offset sorter                     *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****               scan value array and get min & max              *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                       BINSEARCHHEADER                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                         LOOKUP TABLE                          *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* ================= Simple Array Format 0 Lookup Table ================ */
/* some fonts have too-short fmt0 array */
/* ================= Segment Single Format 2 Loolup Table ============== */
/*
/* lastGlyph */
/* firstGlyph */
/* ftxvalidator silently skips such an entry */
/* ================= Segment Array Format 4 Lookup Table =============== */
/* ftxvalidator silently skips such an entry */
/* ================= Segment Table Format 6 Lookup Table =============== */
/* ================= Trimmed Array Format 8 Lookup Table =============== */
/* firstGlyph + glyphCount */
/* valueArray */
/* 0 */
/* 1 */
/* 2 */
/* 3 */
/* 4 */
/* 5 */
/* 6 */
/* 7 */
/* 8 */
/* lookuptbl_head may be used in fmt4 transit function. */
/* format */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          Glyph ID                             *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                        CONTROL POINT                          *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          SFNT NAME                            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* make compiler happy */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          STATE TABLE                          *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* -------------------------- Class Table --------------------------- */
/*
/* Classes 0, 2, and 3 are predefined */
/* following classes should not appear in class array */
/* end of text */
/* out of bounds */
/* end of line */
/* out of bounds */
/* user-defined: 4 - ( stateSize - 1 ) */
/* assign glyph to undefined state */
/* scan max ClassID in use */
/* XXX: Check Range? */
/* --------------------------- State Array ----------------------------- */
/* for the non-debugging case */
/*
/* read if enough to read another state */
/* --------------------------- Entry Table ----------------------------- */
/* ftxvalidator and FontValidator both warn and continue */
/* make compiler happy */
/* =========================== State Table ============================= */
/* offset to Class(Sub)Table */
/* offset to StateArray */
/* offset to EntryTable */
/* 0:start of text, 1:start of line are predefined */
/* ================= eXtended State Table (for morx) =================== */
/*
/* XXX: check range? */
/* for the non-debugging case */
/*
/* read if enough to read another state */
/* make compiler happy */
/* StateHeader members */
/* offset to Class(Sub)Table */
/* offset to StateArray */
/* offset to EntryTable */
/* XXX: check range? */
/* 0:start of text, 1:start of line are predefined */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                        Table overlapping                      *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gxvalid\gxvfeat.c
/***************************************************************************/
/*                                                                         */
/*  gxvfeat.c                                                              */
/*                                                                         */
/*    TrueTypeGX/AAT feat table validation (body).                         */
/*                                                                         */
/*  Copyright 2004, 2005, 2008, 2012 by                                    */
/*  suzuki toshiya, Masatake YAMATO, Red Hat K.K.,                         */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      Data and Types                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      UTILITY FUNCTIONS                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* Don't use here. Apple is reserved. */
/* If we have exclusive setting, the setting should be odd. */
/* feature + nSettings + settingTable + featureFlags */
/* If exclusive, check whether default setting is in the range. */
/* setting + nameIndex */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                         feat TABLE                            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* version + featureNameCount + none_0 + none_1  */
/* Version */
/* skip (none) and (none) */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gxvalid\gxvfgen.c
/***************************************************************************/
/*                                                                         */
/*  gxfgen.c                                                               */
/*                                                                         */
/*    Generate feature registry data for gxv `feat' validator.             */
/*    This program is derived from gxfeatreg.c in gxlayout.                */
/*                                                                         */
/*  Copyright 2004, 2005, 2006 by Masatake YAMATO and Redhat K.K.          */
/*                                                                         */
/*  This file may only be used,                                            */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/*  gxfeatreg.c                                                            */
/*                                                                         */
/*    Database of font features pre-defined by Apple Computer, Inc.        */
//developer.apple.com/fonts/Registry/                           */
/*    http://developer.apple.com/fonts/Registry/                           */
/*    (body).                                                              */
/*                                                                         */
/*  Copyright 2003 by                                                      */
/*  Masatake YAMATO and Redhat K.K.                                        */
/*                                                                         */
/*  This file may only be used,                                            */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* Development of gxfeatreg.c is supported by                              */
/* Information-technology Promotion Agency, Japan.                         */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* This file is compiled as a stand-alone executable.                      */
/* This file is never compiled into `libfreetype2'.                        */
/* The output of this file is used in `gxvfeat.c'.                         */
/* ----------------------------------------------------------------------- */
/* Compile: gcc `pkg-config --cflags freetype2` gxvfgen.c -o gxvfgen       */
/* Run: ./gxvfgen > tmp.c                                                  */
/*                                                                         */
/***************************************************************************/
/*******************************************************************/
/* WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING */
/*******************************************************************/
/*
/*******************************************************************/
/* WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING */
/*******************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      Data and Types                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* 0 */
/* 1 */
/* 2 */
/* 3 */
/* 4 */
/* "Substitute Vertical Forms", */
/* 5 */
/* "Linguistic Rearrangement", */
/* 6 */
/* 7 */
/* 8 */
/* 9 */
/* 10 */
/* "Normal Position", */
/* 11 */
/* 12 */
/* 13 */
/* "Prevent Overlap", */
/* 14 */
/* 15 */
/* 16 */
/* 17 */
/* TODO */
/* 18 */
/* TODO */
/* 19 */
/* 20 */
/* count => 12 */
/* 21 */
/* 22 */
/* Here after Newer */  { /* 23 */
/* 24 */
/* 25 */
/* 26 */
/* 27-30 */
/* 31-35 */
/* 36-40 */
/* 40-45 */
/* 46-50 */
/* 51-55 */
/* 56-60 */
/* 61-65 */
/* 66-70 */
/* 71-75 */
/* 76-80 */
/* 81-85 */
/* 86-90 */
/* 91-95 */
/* 96-98 */
/* 99 */ {                   /* 100 => 22 */
/* 101 => 25 */
/* 102 => 26 */
/* 103 */
/* 104 => 1 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                         Generator                             *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* Generated from %s */\n", __FILE__ );
/* Do nothing */
/* %s */\n",
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gxvalid\gxvjust.c
/***************************************************************************/
/*                                                                         */
/*  gxvjust.c                                                              */
/*                                                                         */
/*    TrueTypeGX/AAT just table validation (body).                         */
/*                                                                         */
/*  Copyright 2005, 2014 by suzuki toshiya, Masatake YAMATO, Red Hat K.K., */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*
//developer.apple.com/fonts/TTRefMan/RM06/Chap6just.html
/* GX just table does not define their subset of GID */
/* According to Apple spec, only 7bits in justClass is used */
/* Apple misspelled "Threshhold" */
/* 'duct' */
/* parse single actSubrecord */
/* actionClass is related with justClass using 7bit only */
/* Stretch glyph action: no actionData */
/* subtable_length is set by gxv_LookupTable_validate() */
/* TODO: validate markClass & currentClass */
/* subtable_length is set by gxv_LookupTable_validate() */
/* subtable_length is set by gxv_LookupTable_validate() */
/*
/*
/* Version 1.0 (always:2000) */
/* format 0 (always:2000) */
/* validate justData */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gxvalid\gxvkern.c
/***************************************************************************/
/*                                                                         */
/*  gxvkern.c                                                              */
/*                                                                         */
/*    TrueTypeGX/AAT kern table validation (body).                         */
/*                                                                         */
/*  Copyright 2004-2007, 2013                                              */
/*  by suzuki toshiya, Masatake YAMATO, Red Hat K.K.,                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      Data and Types                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      SUBTABLE VALIDATORS                      *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* ============================= format 0 ============================== */
/* left */
/* right */
/* Pairs of left and right GIDs must be unique and sorted. */
/* skip the kern value */
/* nPairs, searchRange, entrySelector, rangeShift */
/* ============================= format 1 ============================== */
/*
/*
/* ================ Data for Class-Based Subtables 2, 3 ================ */
/* ============================= format 2 ============================== */
/* ---------------------- format 2 specific data ----------------------- */
/* -------------------------- utility functions ----------------------- */
/* ============================= format 3 ============================== */
/*
/*
/*
/*
/* new Apple-dialect */
/* reserved bits = 0 */
/* classic Apple-dialect */
/* check expected flags, but don't check if MS-dialect is impossible */
/* reserved bits = 0 */
/* format 1 requires GX State Machine, too new for classic */
/* classic Microsoft-dialect */
/* reserved bits = 0 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                            MAIN                               *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* MS only: subtable version, unused */
/* MS: 16bit, Apple: 32bit*/
/* Apple only */
/* subtable format */
/* Apple: length_hi MS: version */
/* Apple: length_lo MS: length */
/* formats 1, 2, 3 require the position of the start of this subtable */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                         kern TABLE                            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* p should be 32bit-aligned? */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gxvalid\gxvlcar.c
/***************************************************************************/
/*                                                                         */
/*  gxvlcar.c                                                              */
/*                                                                         */
/*    TrueTypeGX/AAT lcar table validation (body).                         */
/*                                                                         */
/*  Copyright 2004, 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K., */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      Data and Types                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      UTILITY FUNCTIONS                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*
/* XXX: check range? */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          lcar TABLE                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gxvalid\gxvmod.c
/***************************************************************************/
/*                                                                         */
/*  gxvmod.c                                                               */
/*                                                                         */
/*    FreeType's TrueTypeGX/AAT validation module implementation (body).   */
/*                                                                         */
/*  Copyright 2004-2006, 2013                                              */
/*  by suzuki toshiya, Masatake YAMATO, Red Hat K.K.,                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* load tables */
/* validate tables */
/* Set results */
/* without volatile on `error' GCC 4.1.1. emits:                         */
/*  warning: variable 'error' might be clobbered by 'longjmp' or 'vfork' */
/* this warning seems spurious but ---                                   */
/* module-specific interface */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gxvalid\gxvmort.c
/***************************************************************************/
/*                                                                         */
/*  gxvmort.c                                                              */
/*                                                                         */
/*    TrueTypeGX/AAT mort table validation (body).                         */
/*                                                                         */
/*  Copyright 2005, 2013 by suzuki toshiya, Masatake YAMATO, Red Hat K.K., */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* nSettings in gxvfeat.c is halved for exclusive on/off settings */
/* TODO: enableFlags must be unique value in specified chain?  */
/*
/* 0 */
/* 1 */
/* 2 */
/* 3 */
/* 4 */
/* 5 */
/* TODO: validate subFeatureFlags */
/* TODO: validate defaultFlags */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gxvalid\gxvmort0.c
/***************************************************************************/
/*                                                                         */
/*  gxvmort0.c                                                             */
/*                                                                         */
/*    TrueTypeGX/AAT mort table validation                                 */
/*    body for type0 (Indic Script Rearrangement) subtable.                */
/*                                                                         */
/*  Copyright 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K.,       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* for the non-debugging */
/* case                  */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gxvalid\gxvmort1.c
/***************************************************************************/
/*                                                                         */
/*  gxvmort1.c                                                             */
/*                                                                         */
/*    TrueTypeGX/AAT mort table validation                                 */
/*    body for type1 (Contextual Substitution) subtable.                   */
/*                                                                         */
/*  Copyright 2005, 2007 by suzuki toshiya, Masatake YAMATO, Red Hat K.K., */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* XXX: check range? */
/* TODO: min_gid & max_gid comparison with ClassTable contents */
/*
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gxvalid\gxvmort2.c
/***************************************************************************/
/*                                                                         */
/*  gxvmort2.c                                                             */
/*                                                                         */
/*    TrueTypeGX/AAT mort table validation                                 */
/*    body for type2 (Ligature Substitution) subtable.                     */
/*                                                                         */
/*  Copyright 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K.,       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* access ligActionTable */
/* FontValidator, ftxvalidator, ftxdumperfuser warn but continue */
/* FontValidator, ftxvalidator, ftxdumperfuser warn but continue */
/* validate entry in ligActionTable */
/* Apple spec defines this offset as a word offset */
/* Apple does not give specification of ligatureTable format */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gxvalid\gxvmort4.c
/***************************************************************************/
/*                                                                         */
/*  gxvmort4.c                                                             */
/*                                                                         */
/*    TrueTypeGX/AAT mort table validation                                 */
/*    body for type4 (Non-Contextual Glyph Substitution) subtable.         */
/*                                                                         */
/*  Copyright 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K.,       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*
/* XXX: check range? */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gxvalid\gxvmort5.c
/***************************************************************************/
/*                                                                         */
/*  gxvmort5.c                                                             */
/*                                                                         */
/*    TrueTypeGX/AAT mort table validation                                 */
/*    body for type5 (Contextual Glyph Insertion) subtable.                */
/*                                                                         */
/*  Copyright 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K.,       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*
/*
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gxvalid\gxvmorx.c
/***************************************************************************/
/*                                                                         */
/*  gxvmorx.c                                                              */
/*                                                                         */
/*    TrueTypeGX/AAT morx table validation (body).                         */
/*                                                                         */
/*  Copyright 2005, 2008, 2013 by                                          */
/*  suzuki toshiya, Masatake YAMATO, Red Hat K.K.,                         */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* 0 */
/* 1 */
/* 2 */
/* 3 */
/* 4 */
/* 5 */
/* morx coverage consists of mort_coverage & 16bit padding */
/* TODO: subFeatureFlags should be unique in a table? */
/* feature-array of morx is same with that of mort */
/* TODO: defaultFlags should be compared with the flags in tables */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gxvalid\gxvmorx0.c
/***************************************************************************/
/*                                                                         */
/*  gxvmorx0.c                                                             */
/*                                                                         */
/*    TrueTypeGX/AAT morx table validation                                 */
/*    body for type0 (Indic Script Rearrangement) subtable.                */
/*                                                                         */
/*  Copyright 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K.,       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gxvalid\gxvmorx1.c
/***************************************************************************/
/*                                                                         */
/*  gxvmorx1.c                                                             */
/*                                                                         */
/*    TrueTypeGX/AAT morx table validation                                 */
/*    body for type1 (Contextual Substitution) subtable.                   */
/*                                                                         */
/*  Copyright 2005, 2007 by suzuki toshiya, Masatake YAMATO, Red Hat K.K., */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* for the non-debugging case */
/* XXX: check range? */
/*
/* TODO: calculate offset/length for each lookupTables */
/* TODO: overlapping of lookupTables in substitutionTable */
/*
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gxvalid\gxvmorx2.c
/***************************************************************************/
/*                                                                         */
/*  gxvmorx2.c                                                             */
/*                                                                         */
/*    TrueTypeGX/AAT morx table validation                                 */
/*    body for type2 (Ligature Substitution) subtable.                     */
/*                                                                         */
/*  Copyright 2005, 2013 by suzuki toshiya, Masatake YAMATO, Red Hat K.K., */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* access ligActionTable */
/* validate entry in ligActionTable */
/* this offset is 30-bit signed value to add to GID */
/* it is different from the location offset in mort */
/* negative offset */
/* positive offset */
/* Apple does not give specification of ligatureTable format */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gxvalid\gxvmorx4.c
/***************************************************************************/
/*                                                                         */
/*  gxvmorx4.c                                                             */
/*                                                                         */
/*    TrueTypeGX/AAT morx table validation                                 */
/*    body for "morx" type4 (Non-Contextual Glyph Substitution) subtable.  */
/*                                                                         */
/*  Copyright 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K.,       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gxvalid\gxvmorx5.c
/***************************************************************************/
/*                                                                         */
/*  gxvmorx5.c                                                             */
/*                                                                         */
/*    TrueTypeGX/AAT morx table validation                                 */
/*    body for type5 (Contextual Glyph Insertion) subtable.                */
/*                                                                         */
/*  Copyright 2005, 2007 by suzuki toshiya, Masatake YAMATO, Red Hat K.K., */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gxvalid\gxvopbd.c
/***************************************************************************/
/*                                                                         */
/*  gxvopbd.c                                                              */
/*                                                                         */
/*    TrueTypeGX/AAT opbd table validation (body).                         */
/*                                                                         */
/*  Copyright 2004, 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K., */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      Data and Types                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      UTILITY FUNCTIONS                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* offset in LookupTable is measured from the head of opbd table */
/* format 1, value is ctrl pt. */
/* format 0, value is distance */
/*
/* XXX: check range? */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                         opbd TABLE                            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* only 0x00010000 is defined (1996) */
/* only values 0 and 1 are defined (1996) */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gxvalid\gxvprop.c
/***************************************************************************/
/*                                                                         */
/*  gxvprop.c                                                              */
/*                                                                         */
/*    TrueTypeGX/AAT prop table validation (body).                         */
/*                                                                         */
/*  Copyright 2004, 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K., */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      Data and Types                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      UTILITY FUNCTIONS                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* Pass 0 as GLYPH to check the default property */
/* Top bit is set: negative */
/* Calculate the absolute offset */
/* The gid for complement must be greater than 0 */
/* The gid for complement must be the face. */
/* this is introduced in version 2.0 */
/* TODO: Too restricted. Use the validation level. */
/*
/* XXX: check range? */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                         prop TABLE                            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* only versions 1.0, 2.0, 3.0 are defined (1996) */
/* only formats 0x0000, 0x0001 are defined (1996) */
/* format == 1 */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gxvalid\gxvtrak.c
/***************************************************************************/
/*                                                                         */
/*  gxvtrak.c                                                              */
/*                                                                         */
/*    TrueTypeGX/AAT trak table validation (body).                         */
/*                                                                         */
/*  Copyright 2004, 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K., */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      Data and Types                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*
//developer.apple.com/fonts/TTRefMan/RM06/Chap6trak.html
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      UTILITY FUNCTIONS                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* read the header of trackData */
/* validate trackTable */
/* sizeTable is array of FT_Fixed, don't check contents */
/* validate trackValueOffet */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          trak TABLE                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* Version 1.0 (always:1996) */
/* format 0 (always:1996) */
/* Reserved Fixed Value (always) */
/* validate trackData */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gzip\adler32.c
/* adler32.c -- compute the Adler-32 checksum of a data stream
/* @(#) $Id$ */
/* largest prime smaller than 65536 */
/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
/* ========================================================================= */
/* adler, buf, len) */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gzip\ftgzip.c
/***************************************************************************/
/*                                                                         */
/*  ftgzip.c                                                               */
/*                                                                         */
/*    FreeType support for .gz compressed files.                           */
/*                                                                         */
/*  This optional component relies on zlib.  It should mainly be used to   */
/*  parse compressed PCF fonts, as found with many X11 server              */
/*  distributions.                                                         */
/*                                                                         */
/*  Copyright 2002-2006, 2009-2014 by                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* !FT_CONFIG_OPTION_SYSTEM_ZLIB */
/* In this case, we include our own modified sources of the ZLib    */
/* within the "ftgzip" component.  The modifications were necessary */
/* to #include all files without conflicts, as well as preventing   */
/* the definition of "extern" functions that may cause linking      */
/* conflicts when a program is linked with both FreeType and the    */
/* original ZLib.                                                   */
/* prevent all zcalloc() & zfree() in zutils.c */
/* we can't use asm-optimized sources here! */
/* Visual C++ (and Intel C++)   */
/* We disable the warning `conversion from XXX to YYY,     */
/* possible loss of data' in order to compile cleanly with */
/* the maximum level of warnings: zlib is non-FreeType     */
/* code.                                                   */
/* _MSC_VER */
/* Urgh.  `inflate_mask' must not be declared twice -- C++ doesn't like
/* infutil.c must be included before infcodes.c */
/* !FT_CONFIG_OPTION_SYSTEM_ZLIB */
/***************************************************************************/
/***************************************************************************/
/*****                                                                 *****/
/*****            Z L I B   M E M O R Y   M A N A G E M E N T          *****/
/*****                                                                 *****/
/***************************************************************************/
/***************************************************************************/
/* it is better to use FreeType memory routines instead of raw
/* !SYSTEM_ZLIB && !USE_ZLIB_ZCALLOC */
/***************************************************************************/
/***************************************************************************/
/*****                                                                 *****/
/*****               Z L I B   F I L E   D E S C R I P T O R           *****/
/*****                                                                 *****/
/***************************************************************************/
/***************************************************************************/
/* parent/source stream        */
/* embedding stream            */
/* memory allocator            */
/* zlib input stream           */
/* starting position, after .gz header */
/* input read buffer  */
/* output buffer      */
/* position in output */
/* gzip flag byte */
/* bit 0 set: file probably ascii text */
/* bit 1 set: header CRC present */
/* bit 2 set: extra field present */
/* bit 3 set: original file name present */
/* bit 4 set: file comment present */
/* bits 5..7: reserved */
/* check and skip .gz header - we don't support `transparent' compression */
/* head[0] && head[1] are the magic numbers;    */
/* head[2] is the method, and head[3] the flags */
/* skip time, xflags and os code */
/* skip the extra field */
/* skip original file name */
/* skip .gz comment */
/* skip CRC */
/* check and skip .gz header */
/* initialize zlib -- there is no zlib header in the compressed stream */
/* clear the rest */
/* fill output buffer; `count' must be <= FT_GZIP_BUFFER_SIZE */
/* Reset inflate stream if we're seeking backwards.        */
/* Yes, that is not too efficient, but it saves memory :-) */
/* skip unwanted bytes */
/* now read the data */
/***************************************************************************/
/***************************************************************************/
/*****                                                                 *****/
/*****               G Z   E M B E D D I N G   S T R E A M             *****/
/*****                                                                 *****/
/***************************************************************************/
/***************************************************************************/
/* finalize gzip file descriptor */
/* documentation is in ftgzip.h */
/*
/*
/* don't know the real size! */
/* documentation is in ftgzip.h */
/* check for `input' delayed to `inflate' */
/* this function is modeled after zlib's `uncompress' function */
/* !FT_CONFIG_OPTION_USE_ZLIB */
/* !FT_CONFIG_OPTION_USE_ZLIB */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gzip\infblock.c
/* infblock.c -- interpret and process block types to last block
/* simplify the use of the inflate_huft type with some defines */
/* Table for deflate from PKZIP's appnote.txt. */
/* Order of the bit length code lengths */
/*
/* s, z, c) */
/* z, c, w) */
/* s, z, r) */
/* temporary storage */
/* bit buffer */
/* bits in bit buffer */
/* input data pointer */
/* bytes available there */
/* output window write pointer */
/* bytes to end of window or read pointer */
/* copy input/output information to locals (UPDATE macro restores) */
/* process input based on current state */
/* stored */
/* go to byte boundary */
/* get length of stored block */
/* fixed */
/* dynamic */
/* illegal */
/* dump bits */
/* c == 16..18 */
/* must be <= 9 for lookahead assumptions */
/* must be <= 9 for lookahead assumptions */
/* s, z) */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gzip\infcodes.c
/* infcodes.c -- process literals and length/distance pairs
/* simplify the use of the inflate_huft type with some defines */
/* waiting for "i:"=input, "o:"=output, "x:"=nothing */
/* x: set up for LEN */
/* i: get length/literal/eob next */
/* i: getting length extra (have base) */
/* i: get distance next */
/* i: getting distance extra */
/* o: copying bytes in window, waiting for space */
/* o: got literal, waiting for output space */
/* o: got eob, possibly still output waiting */
/* x: got eob and all data flushed */
/* x: got error */
/* inflate codes private state */
/* mode */
/* current inflate_codes mode */
/* mode dependent information */
/* pointer into tree */
/* bits needed */
/* if LEN or DIST, where in tree */
/* if LIT, literal */
/* bits to get for extra */
/* distance back to copy from */
/* if EXT or COPY, where and how much */
/* submode */
/* mode independent information */
/* ltree bits decoded per branch */
/* dtree bits decoder per branch */
/* literal/length/eob tree */
/* distance tree */
/* bl, bd, tl, td, z) */
/* need separate declaration for Borland C++ */
/* s, z, r) */
/* temporary storage */
/* temporary pointer */
/* extra bits or operation */
/* bit buffer */
/* bits in bit buffer */
/* input data pointer */
/* bytes available there */
/* output window write pointer */
/* bytes to end of window or read pointer */
/* pointer to copy strings from */
/* codes state */
/* copy input/output information to locals (UPDATE macro restores) */
/* process input and output based on current state */
/* waiting for "i:"=input, "o:"=output, "x:"=nothing */
/* x: set up for LEN */
/* !SLOW */
/* i: get length/literal/eob next */
/* literal */
/* length */
/* next table */
/* end of block */
/* invalid code */
/* i: getting length extra (have base) */
/* i: get distance next */
/* distance */
/* next table */
/* invalid code */
/* i: getting distance extra */
/* o: copying bytes in window, waiting for space */
/* modulo window size-"while" instead */
/* of "if" handles invalid distances */
/* o: got literal, waiting for output space */
/* o: got eob, possibly more output */
/* return unused byte, if any */
/* can always return one */
/* x: got error */
/* Some dumb compilers complain without this */
/* c, z) */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gzip\inflate.c
/* inflate.c -- zlib interface to inflate modules
/* waiting for method byte */
/* waiting for flag byte */
/* four dictionary check bytes to go */
/* three dictionary check bytes to go */
/* two dictionary check bytes to go */
/* one dictionary check byte to go */
/* waiting for inflateSetDictionary */
/* decompressing blocks */
/* four check bytes to go */
/* three check bytes to go */
/* two check bytes to go */
/* one check byte to go */
/* finished check, done */
/* got an error--stay here */
/* inflate private state */
/* mode */
/* current inflate mode */
/* mode dependent information */
/* if FLAGS, method byte */
/* computed check value */
/* stream check value */
/* if CHECK, check values to compare */
/* if BAD, inflateSync's marker bytes count */
/* submode */
/* mode independent information */
/* flag for no wrapper */
/* log2(window size)  (8..15, defaults to 15) */
/* current inflate_blocks state */
/* z) */
/* z) */
/* z, w, version, stream_size) */
/* initialize state */
/* handle undocumented nowrap option (no zlib header or check) */
/* set window size */
/* create inflate_blocks state */
/* reset state */
/* z, f) */
/* can't try inflateSync */
/* can't try inflateSync */
/* can't try inflateSync */
/* can try inflateSync */
/* can try inflateSync */
/* can't try inflateSync */
/* Some dumb compilers complain without this */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gzip\inftrees.c
/* inftrees.c -- generate Huffman trees for efficient decoding
/* non ANSI compilers may not accept inffixed.h */
/*
/* simplify the use of the inflate_huft type with some defines */
/* code lengths in bits */
/* number of codes */
/* number of "simple" codes */
/* list of base values for non-simple codes */
/* list of extra bits for non-simple codes */
/* result: starting table */
/* maximum lookup bits (returns actual) */
/* space for trees */
/* hufts used in space */
/* space for values */
/* Tables for deflate from PKZIP's appnote.txt. */
/* Copy lengths for literal codes 257..285 */
/* see note #13 above about 258 */
/* Extra bits for literal codes 257..285 */
/* 112==invalid */
/* Copy offsets for distance codes 0..29 */
/* Extra bits for distance codes */
/*
/* If BMAX needs to be larger than 16, then h and x[] should be uLong. */
/* maximum bit length of any code */
/* b, n, s, d, e, t, m, hp, hn, v) */
/* code lengths in bits (all assumed <= BMAX) */
/* number of codes (assumed <= 288) */
/* number of simple-valued codes (0..s-1) */
/* list of base values for non-simple codes */
/* list of extra bits for non-simple codes */
/* result: starting table */
/* maximum lookup bits, returns actual */
/* space for trees */
/* hufts used in space */
/* working area: values in order of bit length */
/* Given a list of code lengths and a maximum table size, make a set of
/* counter for codes of length k */
/* bit length count table */
/* i repeats in table every f entries */
/* maximum code length */
/* table level */
/* counter, current code */
/* counter */
/* number of bits in current code */
/* bits per table (returned in m) */
/* (1 << w) - 1, to avoid cc -O bug on HP */
/* pointer into c[], b[], or v[] */
/* points to current table */
/* table entry for structure assignment */
/* table stack */
/* bits before this table == (l * h) */
/* bit offsets, then code stack */
/* pointer into x */
/* number of dummy codes added */
/* number of entries in current table */
/* Make compiler happy */
/* Generate counts for each bit length */
/* clear c[]--assume BMAX+1 is 16 */
/* assume all entries <= BMAX */
/* null input--all zero length codes */
/* Find minimum and maximum length, bound *m by those */
/* minimum code length */
/* maximum code length */
/* Adjust last length count to fill out codes, if needed */
/* Generate starting offsets into the value table for each length */
/* note that i == g from above */
/* Make a table of values in order of bit lengths */
/* set n to length of v */
/* Generate the Huffman codes and for each, make the table entries */
/* first Huffman code is zero */
/* grab values in bit order */
/* no tables yet--level -1 */
/* bits decoded == (l * h) */
/* just to keep compilers happy */
/* ditto */
/* ditto */
/* go through the bit lengths (k already is bits in shortest code) */
/* here i is the Huffman code of length k bits for value *p */
/* make tables up to required level */
/* previous table always l bits */
/* compute minimum size table less than or equal to l bits */
/* table size upper limit */
/* try a k-w bit table */
/* too few codes for k-w bit table */
/* deduct codes from patterns left */
/* try smaller tables up to z bits */
/* enough codes to use up j bits */
/* else deduct codes from patterns */
/* table entries for j-bit table */
/* allocate new table */
/* (note: doesn't matter for fixed) */
/* overflow of MANY */
/* connect to last table, if there is one */
/* save pattern for backing up */
/* bits to dump before this table */
/* bits in this table */
/* offset to this table */
/* connect to last table */
/* first table is returned result */
/* set up table entry in r */
/* out of values--invalid code */
/* 256 is end-of-block */
/* simple code is just the value */
/* non-simple--look up in lists */
/* fill code-like entries with r */
/* backwards increment the k-bit code i */
/* backup over finished tables */
/* needed on HP, cc -O bug */
/* don't need to update q */
/* Return Z_BUF_ERROR if we were given an incomplete table */
/* c, bb, tb, hp, z) */
/* 19 code lengths */
/* bits tree desired/actual depth */
/* bits tree result */
/* space for trees */
/* for messages */
/* hufts used in space */
/* work area for huft_build */
/* nl, nd, c, bl, bd, tl, td, hp, z) */
/* number of literal/length codes */
/* number of distance codes */
/* that many (total) code lengths */
/* literal desired/actual bit depth */
/* distance desired/actual bit depth */
/* literal/length tree result */
/* distance tree result */
/* space for trees */
/* for messages */
/* hufts used in space */
/* work area for huft_build */
/* allocate work area */
/* build literal/length tree */
/* build distance tree */
/* done */
/* build fixed tables only once--keep them here */
/* number of hufts used by fixed tables */
/* bl, bd, tl, td, z) */
/* literal desired/actual bit depth */
/* distance desired/actual bit depth */
/* literal/length tree result */
/* distance tree result */
/* for memory allocation */
/* build fixed tables if not already */
/* temporary variable */
/* number of hufts used in fixed_mem */
/* length list for huft_build */
/* work area for huft_build */
/* allocate memory */
/* literal table */
/* distance table */
/* done */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gzip\infutil.c
/* inflate_util.c -- data and routines common to blocks and codes
/* And'ing with mask[n] masks the lower n bits */
/* copy as much as possible from the sliding window to the output area */
/* s, z, r) */
/* local copies of source and destination pointers */
/* compute number of bytes to copy as far as end of window */
/* update counters */
/* update check information */
/* copy as far as end of window */
/* see if more to copy at beginning of window */
/* wrap pointers */
/* compute bytes to copy */
/* update counters */
/* update check information */
/* copy */
/* update pointers */
/* done */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\gzip\zutil.c
/* zutil.c -- target dependent utility functions for the compression library
/* @(#) $Id$ */
/* ??? to be unrolled */
/* ??? to be unrolled */
/* Small and medium model in Turbo C are for now limited to near allocation
/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
/* 10*64K = 640K */
/* This table is used to remember the original form of pointers
/* just to make some compilers happy */
/* If we allocate less than 65520 bytes, we assume that farmalloc
/* Normalize the pointer to seg:0 */
/* object < 64K */
/* Find the original pointer */
/* just to make some compilers happy */
/* MSDOS && __TURBOC__ */
/* Microsoft C in 16-bit mode */
/* to make compiler happy */
/* to make compiler happy */
/* MSC */
/* Any system without a special alloc function */
/* make compiler happy */
/* make compiler happy */
/* MY_ZCALLOC */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\lzw\ftlzw.c
/***************************************************************************/
/*                                                                         */
/*  ftlzw.c                                                                */
/*                                                                         */
/*    FreeType support for .Z compressed files.                            */
/*                                                                         */
/*  This optional component relies on NetBSD's zopen().  It should mainly  */
/*  be used to parse compressed PCF fonts, as found with many X11 server   */
/*  distributions.                                                         */
/*                                                                         */
/*  Copyright 2004-2006, 2009, 2010, 2012-2014 by                          */
/*  Albert Chin-A-Young.                                                   */
/*                                                                         */
/*  Based on code in src/gzip/ftgzip.c, Copyright 2004 by                  */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/*****                                                                 *****/
/*****                  M E M O R Y   M A N A G E M E N T              *****/
/*****                                                                 *****/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/*****                                                                 *****/
/*****                   F I L E   D E S C R I P T O R                 *****/
/*****                                                                 *****/
/***************************************************************************/
/***************************************************************************/
/* parent/source stream        */
/* embedding stream            */
/* memory allocator            */
/* lzw decompressor state      */
/* output buffer      */
/* position in output */
/* check and skip .Z header */
/* head[0] && head[1] are the magic numbers */
/* check and skip .Z header */
/* initialize internal lzw variable */
/* clear the rest */
/* fill output buffer; `count' must be <= FT_LZW_BUFFER_SIZE */
/* first, we skip what we can from the output buffer */
/* next, we skip as many bytes remaining as possible */
/* not enough bytes */
/* seeking backwards. */
/* If the new position is within the output buffer, simply       */
/* decrement pointers, otherwise we reset the stream completely! */
/* skip unwanted bytes */
/* now read the data */
/***************************************************************************/
/***************************************************************************/
/*****                                                                 *****/
/*****            L Z W   E M B E D D I N G   S T R E A M              *****/
/*****                                                                 *****/
/***************************************************************************/
/***************************************************************************/
/* finalize lzw file descriptor */
/*
/* don't know the real size! */
/* !FT_CONFIG_OPTION_USE_LZW */
/* !FT_CONFIG_OPTION_USE_LZW */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\lzw\ftzopen.c
/***************************************************************************/
/*                                                                         */
/*  ftzopen.c                                                              */
/*                                                                         */
/*    FreeType support for .Z compressed files.                            */
/*                                                                         */
/*  This optional component relies on NetBSD's zopen().  It should mainly  */
/*  be used to parse compressed PCF fonts, as found with many X11 server   */
/*  distributions.                                                         */
/*                                                                         */
/*  Copyright 2005-2007, 2009, 2011 by David Turner.                       */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* WHY? */
/* end of file */
/* grow the character stack */
/* requirement of the character stack larger than 1<<LZW_MAX_BITS */
/* implies bug in the decompression code                          */
/* grow the prefix/suffix arrays */
/* first allocation -> 9 bits */
/* don't grow too fast */
/*
/* now adjust `suffix' and move the data accordingly */
/* skip magic bytes, and read max_bits + block_flag */
/* fall-through */
/* why not LZW_FIRST-256 ? */
/* not quite right, but at least more predictable */
/* save code for later */
/* special case for KwKwKwK */
/* corrupted LZW stream */
/* fall-through */
/* now create new entry */
/* state == EOF */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\otvalid\otvalid.c
/***************************************************************************/
/*                                                                         */
/*  otvalid.c                                                              */
/*                                                                         */
/*    FreeType validator for OpenType tables (body only).                  */
/*                                                                         */
/*  Copyright 2004, 2007 by                                                */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\otvalid\otvbase.c
/***************************************************************************/
/*                                                                         */
/*  otvbase.c                                                              */
/*                                                                         */
/*    OpenType BASE table validation (body).                               */
/*                                                                         */
/*  Copyright 2004, 2007 by                                                */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* skip Coordinate */
/* BaseCoordFormat1 */
/* BaseCoordFormat2 */
/* ReferenceGlyph, BaseCoordPoint */
/* BaseCoordFormat3 */
/* DeviceTable */
/* BaselineTag */
/* skip DefaultIndex */
/* BaseCoord */
/* FeatMinMaxRecord */
/* skip FeatureTableTag */
/* BaseLangSysRecord */
/* skip BaseLangSysTag */
/* BaseScriptRecord */
/* skip BaseScriptTag */
/* BaseScript */
/* BaseScriptList */
/* Version */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\otvalid\otvcommn.c
/***************************************************************************/
/*                                                                         */
/*  otvcommn.c                                                             */
/*                                                                         */
/*    OpenType common tables validation (body).                            */
/*                                                                         */
/*  Copyright 2004, 2005, 2006, 2007 by                                    */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                       COVERAGE TABLE                          *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* CoverageFormat1 */
/* GlyphArray */
/* CoverageFormat2 */
/* RangeRecord */
/* Generally, a coverage table offset has an associated count field.  */
/* The number of glyphs in the table should match this field.  If     */
/* there is no associated count, a value of -1 tells us not to check. */
/* skip CoverageFormat and Glyph/RangeCount */
/* Glyph/RangeCount */
/* Glyph/RangeCount */
/* skip StartCoverageIndex */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                   CLASS DEFINITION TABLE                      *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* ClassDefFormat1 */
/* ClassValueArray */
/* ClassDefFormat2 */
/* ClassRangeRecord */
/* skip Class */
/* no need to check glyph indices used as input to class definition   */
/* tables since even invalid glyph indices return a meaningful result */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      DEVICE TABLE                             *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* DeltaValue */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                         LOOKUPS                               *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* uses otvalid->type_count */
/* uses otvalid->type_funcs */
/* skip LookupFlag */
/* SubTable */
/* uses valid->lookup_count */
/* Lookup */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                        FEATURES                               *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* uses otvalid->lookup_count */
/* skip FeatureParams (unused) */
/* LookupListIndex */
/* sets otvalid->lookup_count */
/* FeatureRecord */
/* skip FeatureTag */
/* Feature */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                       LANGUAGE SYSTEM                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* uses otvalid->extra1 (number of features) */
/* skip LookupOrder (unused) */
/* FeatureIndex */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                           SCRIPTS                             *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* LangSysRecord */
/* skip LangSysTag */
/* LangSys */
/* sets otvalid->extra1 (number of features) */
/* ScriptRecord */
/* skip ScriptTag */
/* Script */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      UTILITY FUNCTIONS                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*
/* skip Format */
/* uses otvalid->extra1 (if > 0: array value limit) */
/* `ux' in the function's name is not really correct since only x-1 */
/* elements are tested                                              */
/* uses otvalid->extra1 (array value limit) */
/* `uy' in the function's name is not really correct since only y-1 */
/* elements are tested                                              */
/* uses otvalid->extra1 (array value limit) */
/* sets otvalid->extra1 (valid->lookup_count) */
/* skip Format */
/* uses otvalid->lookup_count */
/* skip Format */
/* sets otvalid->extra1 (valid->lookup_count)    */
/* skip Format */
/* uses otvalid->lookup_count */
/* skip Format */
/* LookupList */
/* LookupCount */
/* Lookup */
/* LookupFlag */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\otvalid\otvgdef.c
/***************************************************************************/
/*                                                                         */
/*  otvgdef.c                                                              */
/*                                                                         */
/*    OpenType GDEF table validation (body).                               */
/*                                                                         */
/*  Copyright 2004, 2005, 2007 by                                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      UTILITY FUNCTIONS                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets valid->extra1 (0)           */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                       LIGATURE CARETS                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* CaretValueFormat1 */
/* skip Coordinate, no test */
/* CaretValueFormat2 */
/* skip CaretValuePoint, no test */
/* CaretValueFormat3 */
/* skip Coordinate */
/* DeviceTable */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                         GDEF TABLE                            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets otvalid->glyph_count */
/* Version */
/* MarkAttachClassDef has been added to the OpenType */
/* specification without increasing GDEF's version,  */
/* so we use this ugly hack to find out whether the  */
/* table is needed actually.                         */
/* OpenType >= 1.2 */
/* OpenType < 1.2  */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\otvalid\otvgpos.c
/***************************************************************************/
/*                                                                         */
/*  otvgpos.c                                                              */
/*                                                                         */
/*    OpenType GPOS table validation (body).                               */
/*                                                                         */
/*  Copyright 2002, 2004, 2005, 2006, 2007, 2008 by                        */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      UTILITY FUNCTIONS                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* uses valid->extra1 (counter)                             */
/* uses valid->extra2 (boolean to handle NULL anchor field) */
/* sets otvalid->extra1 (class count) */
/* skip PosFormat */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                        VALUE RECORDS                          *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* uses otvalid->extra3 (pointer to base table) */
/* display `format' in dual representation */
/* XPlacement, YPlacement, XAdvance, YAdvance */
/* XPlaDevice, YPlaDevice, XAdvDevice, YAdvDevice */
/* XXX: this value is usually too small, especially if the current */
/* ValueRecord is part of an array -- getting the correct table    */
/* size is probably not worth the trouble                          */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                           ANCHORS                             *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* skip XCoordinate and YCoordinate */
/* AnchorPoint */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                         MARK ARRAYS                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* MarkRecord */
/* skip Class */
/* MarkAnchor */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     GPOS LOOKUP TYPE 1                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets otvalid->extra3 (pointer to base table) */
/* SinglePosFormat1 */
/* Value */
/* SinglePosFormat2 */
/* Value */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     GPOS LOOKUP TYPE 2                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* PairValueRecord */
/* skip SecondGlyph */
/* Value1 */
/* Value2 */
/* sets otvalid->extra3 (pointer to base table) */
/* PairPosFormat1 */
/* PairSetOffset */
/* PairPosFormat2 */
/* Class1Record */
/* Class2Record */
/* Value1 */
/* Value2 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     GPOS LOOKUP TYPE 3                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* CursivePosFormat1 */
/* EntryExitRecord */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     GPOS LOOKUP TYPE 4                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* UNDOCUMENTED (in OpenType 1.5):              */
/* BaseRecord tables can contain NULL pointers. */
/* sets otvalid->extra2 (1) */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     GPOS LOOKUP TYPE 5                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets otvalid->extra2 (1) */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     GPOS LOOKUP TYPE 6                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets otvalid->extra2 (0) */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     GPOS LOOKUP TYPE 7                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets otvalid->extra1 (lookup count) */
/* no need to check glyph indices/classes used as input for these */
/* context rules since even invalid glyph indices/classes return  */
/* meaningful results                                             */
/* no need to check glyph indices/classes used as input for these */
/* context rules since even invalid glyph indices/classes return  */
/* meaningful results                                             */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     GPOS LOOKUP TYPE 8                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets otvalid->extra1 (lookup count) */
/* no need to check glyph indices/classes used as input for these */
/* context rules since even invalid glyph indices/classes return  */
/* meaningful results                                             */
/* no need to check glyph indices/classes used as input for these */
/* context rules since even invalid glyph indices/classes return  */
/* meaningful results                                             */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     GPOS LOOKUP TYPE 9                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* uses otvalid->type_funcs */
/* ExtensionPosFormat1 */
/* sets otvalid->type_count */
/* sets otvalid->type_funcs */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          GPOS TABLE                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets otvalid->glyph_count */
/* Version */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\otvalid\otvgsub.c
/***************************************************************************/
/*                                                                         */
/*  otvgsub.c                                                              */
/*                                                                         */
/*    OpenType GSUB table validation (body).                               */
/*                                                                         */
/*  Copyright 2004, 2005, 2007 by                                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                  GSUB LOOKUP TYPE 1                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* uses otvalid->glyph_count */
/* SingleSubstFormat1 */
/* SingleSubstFormat2 */
/* Substitute */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                  GSUB LOOKUP TYPE 2                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets otvalid->extra1 (glyph count) */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    GSUB LOOKUP TYPE 3                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets otvalid->extra1 (glyph count) */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    GSUB LOOKUP TYPE 4                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* uses otvalid->glyph_count */
/* Component */
/* no need to check the Component glyph indices */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                  GSUB LOOKUP TYPE 5                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets otvalid->extra1 (lookup count) */
/* no need to check glyph indices/classes used as input for these */
/* context rules since even invalid glyph indices/classes return  */
/* meaningful results                                             */
/* no need to check glyph indices/classes used as input for these */
/* context rules since even invalid glyph indices/classes return  */
/* meaningful results                                             */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    GSUB LOOKUP TYPE 6                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets otvalid->extra1 (lookup count)            */
/* no need to check glyph indices/classes used as input for these */
/* context rules since even invalid glyph indices/classes return  */
/* meaningful results                                             */
/* no need to check glyph indices/classes used as input for these */
/* context rules since even invalid glyph indices/classes return  */
/* meaningful results                                             */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    GSUB LOOKUP TYPE 7                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* uses otvalid->type_funcs */
/* ExtensionSubstFormat1 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    GSUB LOOKUP TYPE 8                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* uses otvalid->glyph_count */
/* ReverseChainSingleSubstFormat1 */
/* Substitute */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          GSUB TABLE                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets otvalid->type_count  */
/* sets otvalid->type_funcs  */
/* sets otvalid->glyph_count */
/* Version */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\otvalid\otvjstf.c
/***************************************************************************/
/*                                                                         */
/*  otvjstf.c                                                              */
/*                                                                         */
/*    OpenType JSTF table validation (body).                               */
/*                                                                         */
/*  Copyright 2004, 2007 by                                                */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* uses otvalid->extra1 (GSUB lookup count) */
/* uses otvalid->extra2 (GPOS lookup count) */
/* sets otvalid->extra1 (counter)           */
/* XXX: check lookup types? */
/* XXX: check lookup types? */
/* sets otvalid->extra (glyph count)               */
/* sets otvalid->func1 (otv_JstfPriority_validate) */
/* JstfLangSysRecord */
/* skip JstfLangSysTag */
/* sets otvalid->extra1 (GSUB lookup count) */
/* sets otvalid->extra2 (GPOS lookup count) */
/* sets otvalid->glyph_count                */
/* Version */
/* JstfScriptRecord */
/* skip JstfScriptTag */
/* JstfScript */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\otvalid\otvmath.c
/***************************************************************************/
/*                                                                         */
/*  otvmath.c                                                              */
/*                                                                         */
/*    OpenType MATH table validation (body).                               */
/*                                                                         */
/*  Copyright 2007, 2008 by                                                */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  Written by George Williams.                                            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                  MATH TYPOGRAPHIC CONSTANTS                   *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* 56 constants, 51 have device tables */
/* First 4 constants have no device tables */
/* skip the value */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                   MATH ITALICS CORRECTION                     *****/
/*****                 MATH TOP ACCENT ATTACHMENT                    *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* only used if tracing is active */
/* Skip the value */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                           MATH KERNING                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* OTV_NAME_ENTER( "MathKern" );*/
/* Heights */
/* Skip the value */
/* One more Kerning value */
/* Skip the value */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                         MATH GLYPH INFO                       *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* Italic correction and Top Accent Attachment have the same format */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    MATH GLYPH CONSTRUCTION                    *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* OTV_NAME_ENTER( "GlyphAssembly" ); */
/* Skip the Italics Correction value */
/* skip the Start, End, Full, and Flags fields */
/* OTV_EXIT; */
/* OTV_NAME_ENTER( "MathGlyphConstruction" ); */
/* skip the size */
/* OTV_EXIT; */
/* Skip the MinConnectorOverlap constant */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          MATH TABLE                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets otvalid->glyph_count */
/* Version */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\otvalid\otvmod.c
/***************************************************************************/
/*                                                                         */
/*  otvmod.c                                                               */
/*                                                                         */
/*    FreeType's OpenType validation module implementation (body).         */
/*                                                                         */
/*  Copyright 2004-2008, 2013 by                                           */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*
/* load tables */
/* validate tables */
/* Can't return this as API is frozen */
/* module-specific interface */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\pcf\pcf.c
/*  pcf.c
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\pcf\pcfdrivr.c
/*  pcfdrivr.c
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* PCF_CMap */
/* PCF_CMap */
/* PCF_CMap */
/* PCF_CMap */
/* XXX: result should be changed to indicate an overflow error */
/* PCF_Face */
/* free properties */
/* close compressed stream if any */
/* PCF_Face */
/* this didn't work, try gzip support! */
/* FT_CONFIG_OPTION_USE_ZLIB */
/* this didn't work, try LZW support! */
/* FT_CONFIG_OPTION_USE_LZW */
/* this didn't work, try Bzip2 support! */
/* FT_CONFIG_OPTION_USE_BZIP2 */
/* !(FT_CONFIG_OPTION_USE_ZLIB ||
/* PCF could not have multiple face in single font file.
/* set up charmap */
/* Uh, oh, compare first letters manually to avoid dependency
/* initial platform/encoding should indicate unset status? */
/* Select default charmap */
/* error */
/* XXX: to do: are there cases that need repadding the bitmap? */
/*
/* Apparently, the PCF driver loads all properties as signed integers!
/*
/* FT_Module_Constructor */
/* FT_Module_Destructor  */
/* FT_Size_InitFunc */
/* FT_Size_DoneFunc */
/* FT_Slot_InitFunc */
/* FT_Slot_DoneFunc */
/* FT_Face_GetKerningFunc  */
/* FT_Face_AttachFunc      */
/* FT_Face_GetAdvancesFunc */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\pcf\pcfread.c
/*  pcfread.c
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* rounded up to a multiple of 4 */
/* Sort tables and check for overlaps.  Because they are almost      */
/* always ordered already, an in-place bubble sort with simultaneous */
/* boundary checking seems appropriate.                              */
/*
/* we need two checks to avoid overflow */
/* only check `tables->offset' for last table element ... */
/* ... and adjust `tables->size' to the real value if necessary */
/* parsing normal metrics */
/* the following sets `error' but doesn't return in case of failure */
/* parsing compressed metrics */
/* same as PCF_Toc->count */
/* same as PCF_Toc->count */
/* rough estimate */
/* pad the property array                                            */
/*                                                                   */
/* clever here - nprops is the same as the number of odd-units read, */
/* as only isStringProp are odd length   (Keith Packard)             */
/*                                                                   */
/* rough estimate */
/* allocate one more byte so that we have a final null byte */
/* rough estimate */
/* sanity checks -- those values are used in `PCF_Glyph_Load' to     */
/* compute a glyph's bitmap dimensions, thus setting them to zero in */
/* case of an error disables this particular glyph only              */
/* XXX: PCF_Face->nmetrics is signed FT_Long, see pcf.h */
/* only used for debugging */
/* rough estimate */
/* sanity checks */
/* I'm not sure about this */
/* separate elements with a space */
/* need to convert spaces to dashes for */
/* add_style_name and setwidth_name     */
/* Use the old accelerators if no BDF accelerators are in the file. */
/* metrics */
/* bitmaps */
/* encodings */
/* BDF style accelerators (i.e. bounds based on encoded glyphs) */
/* XXX: TO DO: inkmetrics and glyph_names are missing */
/* now construct the face object */
/*
/* convert from 722.7 decipoints to 72 points per inch */
/* set up charset */
/* This is done to respect the behaviour of the original */
/* PCF font driver.                                      */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\pcf\pcfutil.c
/*
/* $XFree86: xc/lib/font/util/utilbitmap.c,v 1.3 1999/08/22 08:58:58 dawes Exp $ */
/*
/* Modified for use with FreeType */
/*
/*
/*
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\pfr\pfr.c
/***************************************************************************/
/*                                                                         */
/*  pfr.c                                                                  */
/*                                                                         */
/*    FreeType PFR driver component.                                       */
/*                                                                         */
/*  Copyright 2002 by                                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\pfr\pfrcmap.c
/***************************************************************************/
/*                                                                         */
/*  pfrcmap.c                                                              */
/*                                                                         */
/*    FreeType PFR cmap handling (body).                                   */
/*                                                                         */
/*  Copyright 2002, 2007, 2009, 2013 by                                    */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* just for safety, check that the character entries are correctly */
/* sorted in increasing character code order                       */
/* we didn't find it, but we have a pair just above it */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\pfr\pfrdrivr.c
/***************************************************************************/
/*                                                                         */
/*  pfrdrivr.c                                                             */
/*                                                                         */
/*    FreeType PFR driver interface (body).                                */
/*                                                                         */
/*  Copyright 2002-2004, 2006, 2008, 2010, 2011, 2013, 2014 by             */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* PFR_Face */
/* convert from metrics to outline units when necessary */
/*
/* PFR_Face */
/* PFR_Face */
/*
/* FT_Module_Constructor */
/* FT_Module_Destructor  */
/* FT_Size_InitFunc */
/* FT_Size_DoneFunc */
/* FT_Face_AttachFunc      */
/* FT_Face_GetAdvancesFunc */
/* FT_Size_RequestFunc     */
/* FT_Size_SelectFunc      */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\pfr\pfrgload.c
/***************************************************************************/
/*                                                                         */
/*  pfrgload.c                                                             */
/*                                                                         */
/*    FreeType PFR glyph loader (body).                                    */
/*                                                                         */
/*  Copyright 2002, 2003, 2005, 2007, 2010, 2013 by                        */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* for macro definitions */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      PFR GLYPH BUILDER                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* close current contour, if any */
/* compute first and last point indices in current glyph outline */
/* if the last point falls on the same location than the first one */
/* we need to delete it                                            */
/* don't add empty contours */
/* reset glyph to start the loading of a new glyph */
/* check that we have begun a new path */
/* check that we have begun a new path */
/* close current contour if any */
/* indicate that a new contour has started */
/* check that there is space for a new contour and a new point */
/* add new start point */
/* close current contour if any */
/* merge the current glyph into the stack */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      PFR GLYPH LOADER                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* load a simple glyph */
/* test for composite glyphs */
/* re-allocate array when necessary */
/* XXX: for now we ignore the secondary stroke and edge definitions */
/*      since we don't want to support native PFR hinting           */
/*                                                                  */
/* now load a simple glyph */
/***************************************************************/
/*  read instruction                                           */
/*                                                             */
/* end glyph */
/* general line operation */
/* move to inside contour  */
/* move to outside contour */
/* horizontal line to */
/* vertical line to */
/* horizontal to vertical curve */
/* vertical to horizontal curve */
/* general curve to */
/***********************************************************/
/*  now read arguments                                     */
/*                                                         */
/* read the X argument */
/* 8-bit index */
/* 16-bit value */
/* 8-bit delta */
/* read the Y argument */
/* 8-bit index */
/* 16-bit absolute value */
/* 8-bit delta */
/* read the additional format flag for the general curve */
/* save the previous point */
/***********************************************************/
/*  finally, execute instruction                           */
/*                                                         */
/* end glyph => EXIT */
/* line operations */
/* move to inside contour  */
/* move to outside contour */
/* curve operations */
/* test error condition */
/* for (;;) */
/* load a composite/compound glyph */
/* test for composite glyphs */
/* ignore extra items when present */
/*                                 */
/* we can't rely on the FT_GlyphLoader to load sub-glyphs, because   */
/* the PFR format is dumb, using direct file offsets to point to the */
/* sub-glyphs (instead of glyph indices).  Sigh.                     */
/*                                                                   */
/* For now, we load the list of sub-glyphs into a different array    */
/* but this will prevent us from using the auto-hinter at its best   */
/* quality.                                                          */
/*                                                                   */
/* we arbitrarily limit the number of subglyphs */
/* to avoid endless recursion                   */
/* read scale when available */
/* read offset */
/* read glyph position and size now */
/* this is a compound glyph - load it */
/* now, load each individual glyph */
/* note that `glyph->subs' might have been re-allocated */
/* translate and eventually scale the new glyph points */
/* proceed to next sub-glyph */
/* load a simple glyph */
/* initialize glyph loader */
/* load the glyph, recursively when needed */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\pfr\pfrload.c
/***************************************************************************/
/*                                                                         */
/*  pfrload.c                                                              */
/*                                                                         */
/*    FreeType PFR loader (body).                                          */
/*                                                                         */
/*  Copyright 2002-2005, 2007, 2009, 2010, 2013, 2014 by                   */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          EXTRA ITEMS                          *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          PFR HEADER                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* read header directly */
/* make a few adjustments to the header */
/* check signature and header size */
/* "PFR0" */
/* CR/LF  */
/***********************************************************************/
/***********************************************************************/
/*****                                                             *****/
/*****                    PFR LOGICAL FONTS                        *****/
/*****                                                             *****/
/***********************************************************************/
/***********************************************************************/
/* save logical font size and offset */
/* now, check the rest of the table before loading it */
/***********************************************************************/
/***********************************************************************/
/*****                                                             *****/
/*****                    PFR PHYSICAL FONTS                       *****/
/*****                                                             *****/
/***********************************************************************/
/***********************************************************************/
/* load bitmap strikes lists */
/* skip bctSize */
/* re-allocate when needed */
/* Load font ID.  This is a so-called "unique" name that is rather
/* copy font ID name, and terminate it for safety */
/* load stem snap tables */
/* load kerning pair data */
/* load first and last pairs into the item to speed up */
/* lookup later...                                     */
/* add new item to the current list */
/* empty item! */
/* Loads a name from the auxiliary data.  Since this extracts undocumented
/* check that each character is ASCII for making sure not to
/* get the standard advance for non-proportional fonts */
/* load the extra items when present */
/* In certain fonts, the auxiliary bytes contain interesting  */
/* information. These are not in the specification but can be */
/* guessed by looking at the content of a few PFR0 fonts.     */
/* this seems to correspond to the font's family name,
/* this seems to correspond to the font's style name,
/* read the blue values */
/* read the character descriptors */
/* that's it! */
/* save position of bitmap info */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\pfr\pfrobjs.c
/***************************************************************************/
/*                                                                         */
/*  pfrobjs.c                                                              */
/*                                                                         */
/*    FreeType PFR object methods (body).                                  */
/*                                                                         */
/*  Copyright 2002-2008, 2010-2011, 2013, 2014 by                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     FACE OBJECT METHODS                       *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* PFR_Face */
/* we don't want dangling pointers */
/* finalize the physical font record */
/* no need to finalize the logical font or the header */
/* load the header and check it */
/* check face index */
/* load the face */
/* now load the physical font descriptor */
/* now set up all root face fields */
/* if all characters point to the same gps_offset 0, we */
/* assume that the font only contains bitmaps           */
/* not scalable */
/* If no family name was found in the "undocumented" auxiliary
/* note that the style name can be NULL in certain PFR fonts,
/* now compute maximum advance width */
/* create charmap */
/* Select default charmap */
/* check whether we've loaded any kerning pairs */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    SLOT OBJECT METHOD                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* PFR_Slot */
/* PFR_Slot */
/* PFR_Slot */
/* PFR_Size */
/* try to load an embedded bitmap */
/* load the glyph outline (FT_LOAD_NO_RECURSE isn't supported) */
/* copy outline data */
/* compute the advance vector */
/* make-up vertical metrics(?) */
/* some fonts seem to be broken here! */
/* Apply the font matrix, if any.                 */
/* TODO: Test existing fonts with unusual matrix  */
/* whether we have to adjust Units per EM.        */
/* scale when needed */
/* scale outline points */
/* scale the advance */
/* compute the rest of the metrics */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      KERNING METHOD                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* PFR_Face */
/* convert glyph indices to character codes */
/* now search the list of kerning items */
/* we found an item, now parse it and find the value if any */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\pfr\pfrsbit.c
/***************************************************************************/
/*                                                                         */
/*  pfrsbit.c                                                              */
/*                                                                         */
/*    FreeType PFR bitmap loader (body).                                   */
/*                                                                         */
/*  Copyright 2002, 2003, 2006, 2009, 2010, 2013 by                        */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      PFR BIT WRITER                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* current line start                    */
/* line size in bytes                    */
/* width in pixels/bits                  */
/* number of remaining rows to scan      */
/* total number of bits to draw          */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                  BITMAP DATA DECODING                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* check that we are not outside of the table -- */
/* this is possible with broken fonts...         */
/* Not found */
/* load bitmap metrics.  "*padvance" must be set to the default value */
/* before calling this function...                                    */
/*                                                                    */
/* blank image */
/* packed bits */
/* RLE1 */
/* RLE2 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     BITMAP LOADING                            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* Look-up a bitmap strike corresponding to the current */
/* character dimensions                                 */
/* couldn't find it */
/* Now lookup the glyph's position within the file */
/* Access data directly in the frame to speed lookups */
/* Could not find a bitmap program string for this glyph */
/* get the bitmap metrics */
/* compute linear advance */
/* compute default advance, i.e., scaled advance.  This can be */
/* overridden in the bitmap header of certain glyphs.          */
/*
/* Set up glyph bitmap and metrics */
/* XXX: needs casts to fit FT_Bitmap.{width|rows|pitch} */
/* XXX: needs casts to fit FT_Glyph_Metrics.{width|height} */
/* XXX: needs casts fit FT_GlyphSlotRec.bitmap_{left|top} */
/* Allocate and read bitmap data */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\psaux\afmparse.c
/***************************************************************************/
/*                                                                         */
/*  afmparse.c                                                             */
/*                                                                         */
/*    AFM parser (body).                                                   */
/*                                                                         */
/*  Copyright 2006-2010, 2012, 2013 by                                     */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/*    AFM_Stream                                                           */
/*                                                                         */
/* The use of AFM_Stream is largely inspired by parseAFM.[ch] from t1lib.  */
/*                                                                         */
/*                                                                         */
/* this works because empty lines are ignored */
/* column separator; there is no `column' in the spec actually */
/* make stupid compiler happy */
/* read a key or value in current column */
/* read a string (i.e., read to EOL) */
/* scan to eol */
/*************************************************************************/
/*                                                                       */
/*    AFM_Parser                                                         */
/*                                                                       */
/*                                                                       */
/* all keys defined in Ch. 7-10 of 5004.AFM_Spec.pdf */
/*
/* make stupid compiler happy */
/* skip current line */
/* skip empty line */
/* skip current column */
/* skip empty column */
/* don't skip the first line during the first call */
/* compare two kerning pairs */
/* fall through since we only support kern data */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\psaux\psaux.c
/***************************************************************************/
/*                                                                         */
/*  psaux.c                                                                */
/*                                                                         */
/*    FreeType auxiliary PostScript driver component (body only).          */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2006 by                                     */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\psaux\psauxmod.c
/***************************************************************************/
/*                                                                         */
/*  psauxmod.c                                                             */
/*                                                                         */
/*    FreeType auxiliary PostScript module implementation (body).          */
/*                                                                         */
/*  Copyright 2000-2001, 2002, 2003, 2006 by                               */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* module-specific interface */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\psaux\psconv.c
/***************************************************************************/
/*                                                                         */
/*  psconv.c                                                               */
/*                                                                         */
/*    Some convenience conversions (body).                                 */
/*                                                                         */
/*  Copyright 2006, 2008, 2009, 2012-2013 by                               */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* The following array is used by various functions to quickly convert */
/* digits (both decimal and non-decimal) into numbers.                 */
/* ASCII */
/* 0x00 */
/* no character >= 0x80 can represent a valid number */
/* 'A' == 65 */
/* EBCDIC */
/* 0x80 */
/* no character < 0x80 can represent a valid number */
/* 'A' == 193 */
/* read the integer part */
/* read the decimal part */
/* only add digit if we don't overflow */
/* read exponent, if any */
/* arbitrarily limit exponent */
/* it's not necessary to check this addition for overflow */
/* due to the structure of the real number representation */
/* no break */
/* 0 */
/* we try to process two nibbles at a time to be as fast as possible */
/* 0 */
/* 0 */
/* 0 */
/* 0 */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\psaux\psobjs.c
/***************************************************************************/
/*                                                                         */
/*  psobjs.c                                                               */
/*                                                                         */
/*    Auxiliary functions for PostScript fonts (body).                     */
/*                                                                         */
/*  Copyright 1996-2014 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                             PS_TABLE                          *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    ps_table_new                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    Initializes a PS_Table.                                            */
/*                                                                       */
/* <InOut>                                                               */
/*    table  :: The address of the target table.                         */
/*                                                                       */
/* <Input>                                                               */
/*    count  :: The table size = the maximum number of elements.         */
/*                                                                       */
/*    memory :: The memory object to use for all subsequent              */
/*              reallocations.                                           */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* allocate new base block */
/* copy elements and shift offsets */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    ps_table_add                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    Adds an object to a PS_Table, possibly growing its memory block.   */
/*                                                                       */
/* <InOut>                                                               */
/*    table  :: The target table.                                        */
/*                                                                       */
/* <Input>                                                               */
/*    idx    :: The index of the object in the table.                    */
/*                                                                       */
/*    object :: The address of the object to copy in memory.             */
/*                                                                       */
/*    length :: The length in bytes of the source object.                */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.  An error is returned if a  */
/*    reallocation fails.                                                */
/*                                                                       */
/* grow the base block if needed */
/* increase size by 25% and round up to the nearest multiple
/* add the object to the base block and adjust offset */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    ps_table_done                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Finalizes a PS_TableRec (i.e., reallocate it to its current        */
/*    cursor).                                                           */
/*                                                                       */
/* <InOut>                                                               */
/*    table :: The target table.                                         */
/*                                                                       */
/* <Note>                                                                */
/*    This function does NOT release the heap's memory block.  It is up  */
/*    to the caller to clean it, or reference it in its own structures.  */
/*                                                                       */
/* should never fail, because rec.cursor <= rec.size */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                            T1 PARSER                          *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* first character must be already part of the comment */
/* According to the PLRM, a comment is equal to a space. */
/* first character must be `(';                               */
/* *acur is positioned at the character after the closing `)' */
/* Red Book 3rd ed., section `Literal Text Strings', p. 29:     */
/* A backslash can introduce three different types              */
/* of escape sequences:                                         */
/*   - a special escaped char like \r, \n, etc.                 */
/*   - a one-, two-, or three-digit octal number                */
/*   - none of the above in which case the backslash is ignored */
/* error (or to be ignored?) */
/* skip `special' escape */
/* skip octal escape or ignore backslash */
/* first character must be `<' */
/* All whitespace characters are ignored. */
/* first character must be the opening brace that */
/* starts the procedure                           */
/* NB: [ and ] need not match:                    */
/* `/foo {[} def' is a valid PostScript fragment, */
/* even within a Type1 font                       */
/***********************************************************************/
/*                                                                     */
/* All exported parsing routines handle leading whitespace and stop at */
/* the first character which isn't part of the just handled token.     */
/*                                                                     */
/***********************************************************************/
/* Note: PostScript allows any non-delimiting, non-whitespace        */
/*       character in a name (PS Ref Manual, 3rd ed, p31).           */
/*       PostScript delimiters are (, ), <, >, [, ], {, }, /, and %. */
/* this also skips comments */
/* self-delimiting, single-character tokens */
/* skip balanced expressions (procedures and strings) */
/* {...} */
/* (...) */
/* <...> */
/* << */
/* >> */
/* anything else */
/* *cur might be invalid (e.g., ')' or '}'), but this   */
/* is handled by the test `cur == parser->cursor' below */
/* `token' here means either something between balanced delimiters */
/* or the next token; the delimiters are not removed.              */
/* first of all, skip leading whitespace */
/************* check for literal string *****************/
/************* check for programs/array *****************/
/************* check for table/array ********************/
/* XXX: in theory we should also look for "<<"          */
/*      since this is semantically equivalent to "[";   */
/*      in practice it doesn't matter (?)               */
/* we need this to catch `[ ]' */
/* XXX: this is wrong because it does not      */
/*      skip comments, procedures, and strings */
/* we need this to catch `[XXX ]' */
/* ************ otherwise, it is any token **************/
/* NB: `tokens' can be NULL if we only want to count */
/* the number of array elements                      */
/* this also handles leading whitespace */
/* don't include outermost delimiters */
/* first character must be a delimiter or a part of a number */
/* NB: `coords' can be NULL if we just want to skip the      */
/*     array; in this case we ignore `max_coords'            */
/* check for the beginning of an array; otherwise, only one number */
/* will be read                                                    */
/* now, read the coordinates */
/* skip whitespace in front of data */
/* call PS_Conv_ToFixed() even if coords == NULL */
/* to properly parse number at `cur'             */
/* first character must be a delimiter or a part of a number */
/* NB: `values' can be NULL if we just want to skip the      */
/*     array; in this case we ignore `max_values'            */
/*                                                           */
/* return number of successfully parsed values               */
/* Check for the beginning of an array.  Otherwise, only one number */
/* will be read.                                                    */
/* now, read the values */
/* skip whitespace in front of data */
/* call PS_Conv_ToFixed() even if coords == NULL */
/* to properly parse number at `cur'             */
/* XXX: some stupid fonts have a `Notice' or `Copyright' string     */
/*      that simply doesn't begin with an opening parenthesis, even */
/*      though they have a closing one!  E.g. "amuncial.pfb"        */
/*                                                                  */
/*      We must deal with these ill-fated cases there.  Note that   */
/*      these fonts didn't work with the old Type 1 driver as the   */
/*      notice/copyright was not recognized as a valid string token */
/*      and made the old token parser commit errors.                */
/* skip the opening parenthesis, if there is one */
/* then, count its length */
/* now copy the string */
/* 0 */
/* return 1 if we find `true', 0 otherwise */
/* load a simple field (i.e. non-table) into the current list of objects */
/* this also skips leading whitespace */
/* we must detect arrays in /FontBBox */
/* don't include delimiters */
/* if this is an array and we have no blend, an error occurs */
/* don't include delimiters */
/* fall through */
/* for 64-bit systems */
/* we allow both a string or a name   */
/* for cases like /FontName (foo) def */
/* don't include leading `/' */
/* don't include delimiting parentheses    */
/* XXX we don't handle <<...>> here        */
/* XXX should we convert octal escapes?    */
/*     if so, what encoding should we use? */
/* for this to work (FT_String**)q must have been */
/* initialized to NULL                            */
/* an error occurred */
/* obsolete -- keep for reference */
/* we store the elements count if necessary;           */
/* we further assume that `count_offset' can't be zero */
/* we now load each element, adjusting the field.offset on each one */
/* obsolete -- keep for reference */
/* first character must be `<' if `delimiters' is non-zero */
/* 0 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                            T1 BUILDER                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    t1_builder_init                                                    */
/*                                                                       */
/* <Description>                                                         */
/*    Initializes a given glyph builder.                                 */
/*                                                                       */
/* <InOut>                                                               */
/*    builder :: A pointer to the glyph builder to initialize.           */
/*                                                                       */
/* <Input>                                                               */
/*    face    :: The current face object.                                */
/*                                                                       */
/*    size    :: The current size object.                                */
/*                                                                       */
/*    glyph   :: The current glyph object.                               */
/*                                                                       */
/*    hinting :: Whether hinting should be applied.                      */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    t1_builder_done                                                    */
/*                                                                       */
/* <Description>                                                         */
/*    Finalizes a given glyph builder.  Its contents can still be used   */
/*    after the call, but the function saves important information       */
/*    within the corresponding glyph slot.                               */
/*                                                                       */
/* <Input>                                                               */
/*    builder :: A pointer to the glyph builder to finalize.             */
/*                                                                       */
/* check that there is enough space for `count' more points */
/* add a new point, do not check space */
/* check space for a new on-curve point, then add it */
/* check space for a new contour, then add it */
/* this might happen in invalid fonts */
/* if a path was begun, add its first on-curve point */
/* test whether we are building a new contour */
/* close the current contour */
/* We must not include the last point in the path if it */
/* is located on the first point.                       */
/* `delete' last point only if it coincides with the first */
/* point and it is not a control point (which can happen). */
/* Don't add contours only consisting of one point, i.e.,  */
/* check whether the first and the last point is the same. */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                            OTHER                              *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\psaux\t1cmap.c
/***************************************************************************/
/*                                                                         */
/*  t1cmap.c                                                               */
/*                                                                         */
/*    Type 1 character map support (body).                                 */
/*                                                                         */
/*  Copyright 2002, 2003, 2006, 2007, 2012 by                              */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****          TYPE1 STANDARD (AND EXPERT) ENCODING CMAPS           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* convert character code to Adobe SID string */
/* look for the corresponding glyph name */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    TYPE1 CUSTOM ENCODING CMAP                 *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****            TYPE1 SYNTHETIC UNICODE ENCODING CMAP              *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\psaux\t1decode.c
/***************************************************************************/
/*                                                                         */
/*  t1decode.c                                                             */
/*                                                                         */
/*    PostScript Type 1 decoding routines (body).                          */
/*                                                                         */
/*  Copyright 2000-2014 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* ensure proper sign extension */
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* never remove this one */
/* none */
/* endchar */
/* hsbw */
/* seac */
/* sbw */
/* closepath */
/* hlineto */
/* hmoveto */
/* hvcurveto */
/* rlineto */
/* rmoveto */
/* rrcurveto */
/* vhcurveto */
/* vlineto */
/* vmoveto */
/* dotsection */
/* hstem */
/* hstem3 */
/* vstem */
/* vstem3 */
/* div */
/* callothersubr */
/* callsubr */
/* pop */
/* return */
/* setcurrentpoint */
/* opcode 15 (undocumented and obsolete) */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    t1_lookup_glyph_by_stdcharcode                                     */
/*                                                                       */
/* <Description>                                                         */
/*    Looks up a given glyph by its StandardEncoding charcode.  Used to  */
/*    implement the SEAC Type 1 operator.                                */
/*                                                                       */
/* <Input>                                                               */
/*    face     :: The current face object.                               */
/*                                                                       */
/*    charcode :: The character code to look for.                        */
/*                                                                       */
/* <Return>                                                              */
/*    A glyph index in the font face.  Returns -1 if the corresponding   */
/*    glyph wasn't found.                                                */
/*                                                                       */
/* check range of standard char code */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    t1operator_seac                                                    */
/*                                                                       */
/* <Description>                                                         */
/*    Implements the `seac' Type 1 operator for a Type 1 decoder.        */
/*                                                                       */
/* <Input>                                                               */
/*    decoder :: The current CID decoder.                                */
/*                                                                       */
/*    asb     :: The accent's side bearing.                              */
/*                                                                       */
/*    adx     :: The horizontal offset of the accent.                    */
/*                                                                       */
/*    ady     :: The vertical offset of the accent.                      */
/*                                                                       */
/*    bchar   :: The base character's StandardEncoding charcode.         */
/*                                                                       */
/*    achar   :: The accent character's StandardEncoding charcode.       */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* seac weirdness */
/* `glyph_names' is set to 0 for CID fonts which do not */
/* include an encoding.  How can we deal with these?    */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* the caller must handle the font encoding also */
/* if we are trying to load a composite glyph, do not load the */
/* accent character and return the array of subglyphs.         */
/* reallocate subglyph array if necessary */
/* subglyph 0 = base character */
/* subglyph 1 = accent character */
/* set up remaining glyph fields */
/* First load `bchar' in builder */
/* now load the unscaled outline */
/* prepare loader */
/* the seac operator must not be nested */
/* save the left bearing and width of the base character */
/* as they will be erased by the next load.              */
/* Now load `achar' on top of */
/* the base outline           */
/* the seac operator must not be nested */
/* restore the left side bearing and   */
/* advance width of the base character */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    t1_decoder_parse_charstrings                                       */
/*                                                                       */
/* <Description>                                                         */
/*    Parses a given Type 1 charstrings program.                         */
/*                                                                       */
/* <Input>                                                               */
/*    decoder         :: The current Type 1 decoder.                     */
/*                                                                       */
/*    charstring_base :: The base address of the charstring stream.      */
/*                                                                       */
/*    charstring_len  :: The length in bytes of the charstring stream.   */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* compute random seed from stack address of parameter */
/* First of all, initialize the decoder */
/* a font that reads BuildCharArray without setting */
/* its values first is buggy, but ...               */
/* begin hints recording session, if any */
/* now, execute loop */
/*********************************************************************/
/*                                                                   */
/* Decode operator or operand                                        */
/*                                                                   */
/*                                                                   */
/* first of all, decompress operator or value */
/* undocumented, obsolete operator */
/* four bytes integer */
/* According to the specification, values > 32000 or < -32000 must */
/* be followed by a `div' operator to make the result be in the    */
/* range [-32000;32000].  We expect that the second argument of    */
/* `div' is not a large number.  Additionally, we don't handle     */
/* stuff like `<large1> <large2> <num> div <num> div' or           */
/* <large1> <large2> <num> div div'.  This is probably not allowed */
/* anyway.                                                         */
/* all operands have been transferred by previous pops */
/*********************************************************************/
/*                                                                   */
/*  Push value on stack, or process operator                         */
/*                                                                   */
/*                                                                   */
/* callothersubr */
/***********************************************************/
/*                                                         */
/* remove all operands to callothersubr from the stack     */
/*                                                         */
/* for handled othersubrs, where we know the number of     */
/* arguments, we increase the stack by the value of        */
/* known_othersubr_result_cnt                              */
/*                                                         */
/* for unhandled othersubrs the following pops adjust the  */
/* stack pointer as necessary                              */
/* XXX TODO: The checks to `arg_count == <whatever>'       */
/* might not be correct; an othersubr expects a certain    */
/* number of operands on the PostScript stack (as opposed  */
/* to the T1 stack) but it doesn't have to put them there  */
/* by itself; previous othersubrs might have left the      */
/* operands there if they were not followed by an          */
/* appropriate number of pops                              */
/*                                                         */
/* On the other hand, Adobe Reader 7.0.8 for Linux doesn't */
/* accept a font that contains charstrings like            */
/*                                                         */
/*     100 200 2 20 callothersubr                          */
/*     300 1 20 callothersubr pop                          */
/*                                                         */
/* Perhaps this is the reason why BuildCharArray exists.   */
/* end flex feature */
/* the two `results' are popped by the following setcurrentpoint */
/* start flex feature */
/* add flex vectors */
/* note that we should not add a point for index 0; */
/* this will move our current position to the flex  */
/* point without adding any point to the outline    */
/* change hints */
/* counter control hints, clear stack */
/* multiple masters */
/* We want to compute                                    */
/*                                                       */
/*   a0*w0 + a1*w1 + ... + ak*wk                         */
/*                                                       */
/* but we only have a0, a1-a0, a2-a0, ..., ak-a0.        */
/*                                                       */
/* However, given that w0 + w1 + ... + wk == 1, we can   */
/* rewrite it easily as                                  */
/*                                                       */
/*   a0 + (a1-a0)*w1 + (a2-a0)*w2 + ... + (ak-a0)*wk     */
/*                                                       */
/* where k == num_designs-1.                             */
/*                                                       */
/* I guess that's why it's written in this `compact'     */
/* form.                                                 */
/*                                                       */
/* <idx> 1 19 callothersubr                             */
/* => replace elements starting from index cvi( <idx> ) */
/*    of BuildCharArray with WeightVector               */
/* <arg1> <arg2> 2 20 callothersubr pop   */
/* ==> push <arg1> + <arg2> onto T1 stack */
/* XXX (over|under)flow */
/* <arg1> <arg2> 2 21 callothersubr pop   */
/* ==> push <arg1> - <arg2> onto T1 stack */
/* XXX (over|under)flow */
/* <arg1> <arg2> 2 22 callothersubr pop   */
/* ==> push <arg1> * <arg2> onto T1 stack */
/* <arg1> <arg2> 2 23 callothersubr pop   */
/* ==> push <arg1> / <arg2> onto T1 stack */
/* <val> <idx> 2 24 callothersubr               */
/* ==> set BuildCharArray[cvi( <idx> )] = <val> */
/* <idx> 1 25 callothersubr pop        */
/* ==> push BuildCharArray[cvi( idx )] */
/*     onto T1 stack                   */
/* <val> mark <idx> ==> set BuildCharArray[cvi( <idx> )] = <val>, */
/*                      leave mark on T1 stack                    */
/* <val> <idx>      ==> set BuildCharArray[cvi( <idx> )] = <val>  */
/* <res1> <res2> <val1> <val2> 4 27 callothersubr pop */
/* ==> push <res1> onto T1 stack if <val1> <= <val2>, */
/*     otherwise push <res2>                          */
/* 0 28 callothersubr pop                               */
/* => push random value from interval [0, 1) onto stack */
/* fall through */
/* general operator */
/* XXX Operators usually take their operands from the        */
/*     bottom of the stack, i.e., the operands are           */
/*     decoder->stack[0], ..., decoder->stack[num_args - 1]; */
/*     only div, callsubr, and callothersubr are different.  */
/*     In practice it doesn't matter (?).                    */
/* FT_DEBUG_LEVEL_TRACE */
/* close hints recording session */
/* apply hints to the loaded glyph outline now */
/* add current outline to the glyph slot */
/* the compiler should optimize away this empty loop but ... */
/* FT_DEBUG_LEVEL_TRACE */
/* return now! */
/* the `metrics_only' indicates that we only want to compute */
/* the glyph's metrics (lsb + advance width), not load the   */
/* rest of it; so exit immediately                           */
/* the `metrics_only' indicates that we only want to compute */
/* the glyph's metrics (lsb + advance width), not load the   */
/* rest of it; so exit immediately                           */
/* if there is no path, `closepath' is a no-op */
/* if `large_int' is set, we divide unscaled numbers; */
/* otherwise, we divide numbers in 16.16 format --    */
/* in both cases, it is the same operation            */
/* save current instruction pointer */
/* The Type 1 driver stores subroutines without the seed bytes. */
/* The CID driver stores subroutines with seed bytes.  This     */
/* case is taken care of when decoder->subrs_len == 0.          */
/* We are using subroutines from a CID font.  We must adjust */
/* for the seed bytes.                                       */
/* ignore, we pushed the operands ourselves */
/* `push' the operand to callothersubr onto the stack */
/* record horizontal hint */
/* top[0] += builder->left_bearing.y; */
/* record horizontal counter-controlled hints */
/* record vertical hint */
/* record vertical counter-controlled hints */
/* From the T1 specification, section 6.4:                */
/*                                                        */
/*   The setcurrentpoint command is used only in          */
/*   conjunction with results from OtherSubrs procedures. */
/* known_othersubr_result_cnt != 0 is already handled     */
/* above.                                                 */
/* Note, however, that both Ghostscript and Adobe         */
/* Distiller handle this situation by silently ignoring   */
/* the inappropriate `setcurrentpoint' instruction.  So   */
/* we do the same.                                        */
/* nothing to do except to pop the two arguments */
/* XXX Operators usually clear the operand stack;  */
/*     only div, callsubr, callothersubr, pop, and */
/*     return are different.                       */
/*     In practice it doesn't matter (?).          */
/* general operator processing */
/* while ip < limit */
/* parse a single Type 1 glyph */
/* initialize T1 decoder */
/* retrieve PSNames interface from list of current modules */
/* decoder->buildchar and decoder->len_buildchar have to be  */
/* initialized by the caller since we cannot know the length */
/* of the BuildCharArray                                     */
/* finalize T1 decoder */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\pshinter\pshalgo.c
/***************************************************************************/
/*                                                                         */
/*  pshalgo.c                                                              */
/*                                                                         */
/*    PostScript hinting algorithm (body).                                 */
/*                                                                         */
/*  Copyright 2001-2010, 2012-2014 by                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used        */
/*  modified and distributed under the terms of the FreeType project       */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* compute inflection points to optimize `S' */
/* and similar glyphs                        */
/* slightly increase the contrast of smooth  */
/* hinting                                   */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                  BASIC HINTS RECORDINGS                       *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* return true if two stem hints overlap */
/* destroy hints table */
/* deactivate all hints in a table */
/* internal function to record a new hint */
/* ignore active hints */
/* now scan the current active hint set to check */
/* whether `hint' overlaps with another hint     */
/* create hints table */
/* allocate our tables */
/* initialize the `table->hints' array */
/* we now need to determine the initial `parent' stems; first  */
/* activate the hints that are given by the initial hint masks */
/* finally, do a linear parse in case some hints were left alone */
/* now, sort the hints; they are guaranteed to not overlap */
/* so we can compare their "org_pos" field directly        */
/* a simple bubble sort will do, since in 99% of cases, the hints */
/* will be already sorted -- and the sort will be linear          */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****               HINTS GRID-FITTING AND OPTIMIZATION             *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* 0 */
/* DEBUG_HINTER */
/* ignore stem alignments when requested through the hint flags */
/* perform stem snapping when requested - this is necessary
/* check blue zones for horizontal stems */
/* the top of the stem is aligned against a blue zone */
/* the bottom of the stem is aligned against a blue zone */
/* both edges of the stem are aligned against blue zones */
/* ensure that parent is already fitted */
/* keep original relation between hints, this is, use the */
/* scaled distance between the centers of the hints to    */
/* compute the new position                               */
/* Stem adjustment tries to snap stem widths to standard
/* the stem is less than one pixel; we will center it
/* This is a special case where we also widen the stem
/* This is a very small stem; we simply align it to the
/* this is a ghost stem; we simply round it */
/* now that we have a good hinted stem width, try to position */
/* the stem along a pixel grid integer coordinate             */
/* don't touch */
/* not used for now, experimental */
/*
/* ignore stem alignments when requested through the hint flags */
/* check blue zones for horizontal stems */
/* the top of the stem is aligned against a blue zone */
/* the bottom of the stem is aligned against a blue zone */
/* both edges of the stem are aligned against blue zones */
/* ensure that parent is already fitted */
/* Stems less than one pixel wide are easy -- we want to
/* Position stems other to minimize the amount of mid-grays.
/* len > 64 */
/* We choose between B) and C) above based on the amount
/* switch */
/* 0 */
/* DEBUG_HINTER*/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                POINTS INTERPOLATION ROUTINES                  *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* DEBUG_ZONES */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    HINTER GLYPH MANAGEMENT                    *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* deal with the trivial cases quickly */
/* general case */
/* !1 */
/* compute all inflex points in a given glyph */
/* we need at least 4 points to create an inflection point */
/* compute first segment in contour */
/* extend the segment start whenever possible */
/* now, process all segments in the contour */
/* first, extend current segment's end whenever possible */
/* COMPUTE_INFLEXS */
/* |dy| <<< |dx|  means a near-horizontal segment */
/* |dx| <<< |dy|  means a near-vertical segment */
/* load outline point coordinates into hinter glyph */
/* save hinted point coordinates back to outline */
/* clear all fields */
/* allocate and setup points + contours arrays */
/* detect smooth points */
/* COMPUTE_INFLEXS */
/* now deal with hints tables */
/* compute all extrema in a glyph for a given dimension */
/* first of all, compute all local extrema */
/* local maximum */
/* before->org_u > point->org_u */
/* local minimum */
/* for  */
/* for each extremum, determine its direction along the */
/* orthogonal axis                                      */
/* major_dir is the direction for points on the bottom/left of the stem; */
/* Points on the top/right of the stem will have a direction of          */
/* -major_dir.                                                           */
/* treat extrema as special cases for stem edge alignment */
/* 1 */
/* the accepted shift for strong points in fractional pixels */
/* the maximum shift value in font units */
/* find strong points in a glyph */
/* a point is `strong' if it is located on a stem edge and       */
/* has an `in' or `out' tangent parallel to the hint's direction */
/* process secondary hints to `selected' points */
/* the `endchar' op can reduce the number of points */
/* process primary hints for all points */
/* now, certain points may have been attached to a hint and */
/* not marked as strong; update their flags then            */
/* find points in a glyph which are in a blue zone and have `in' or */
/* `out' tangents parallel to the horizontal axis                   */
/* check tangents */
/* skip strong points */
/* look up top zones */
/* look up bottom zones */
/* interpolate strong points with the help of hinted coordinates */
/* hint->org_len > 0 */
/* first technique: a point is strong if it is a local extremum */
/* first count the number of strong points */
/* nothing to do here */
/* allocate an array to store a list of points, */
/* stored in increasing org_u order             */
/* now try to interpolate all normal points */
/* sometimes, some local extrema are smooth points */
/* find best enclosing point coordinates then interpolate */
/* point before the first strong point */
/* point is after last strong point */
/* now interpolate point between before and after */
/* 1 */
/* interpolate other points */
/* count the number of strong points in this contour */
/* if there are less than 2 fitted points in the contour, we */
/* simply scale and eventually translate the contour points  */
/* there are more than 2 strong points in this contour; we */
/* need to interpolate weak points between them            */
/* skip consecutive fitted points */
/* find next fitted point after unfitted one */
/* now interpolate between them */
/* on the left of the interpolation zone */
/* on the right on the interpolation zone */
/* within the interpolation zone */
/* keep going until all points in the contours have been processed */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     HIGH-LEVEL INTERFACE                      *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* something to do? */
/* DEBUG_HINTER */
/* try to optimize the y_scale so that the top of non-capital letters
/* load outline coordinates into glyph */
/* compute local extrema */
/* compute aligned stem/hints positions */
/* find strong points, align them, then interpolate others */
/* save hinted coordinates back to outline */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\pshinter\pshglob.c
/***************************************************************************/
/*                                                                         */
/*  pshglob.c                                                              */
/*                                                                         */
/*    PostScript hinter global hinting management (body).                  */
/*    Inspired by the new auto-hinter module.                              */
/*                                                                         */
/*  Copyright 2001-2004, 2006, 2010, 2012-2014 by                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used        */
/*  modified and distributed under the terms of the FreeType project       */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                       STANDARD WIDTHS                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* scale the widths/heights table */
/* standard width/height */
/* org_width is is font units, result in device pixels, 26.6 format */
/* 0 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                       BLUE ZONES                              *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* read blue zone entry, and select target top/bottom zone */
/* insert into sorted table */
/* we have two zones on the same reference position -- */
/* only keep the largest one                           */
/* Re-read blue zones from the original fonts and store them into out */
/* private structure.  This function re-orders, sanitizes and         */
/* fuzz-expands the zones as well.                                    */
/* read the input blue zones, and build two sorted tables  */
/* (one for the top zones, the other for the bottom zones) */
/* first, the blues */
/* sanitize top table */
/* sanitize bottom table */
/* expand top and bottom tables with blue fuzz */
/* expand the bottom of the lowest zone normally */
/* expand the top and bottom of intermediate zones;    */
/* checking that the interval is smaller than the fuzz */
/* expand the top of the highest zone normally */
/* reset the blues table when the device transform changes */
/*                                                        */
/* Determine whether we need to suppress overshoots or    */
/* not.  We simply need to compare the vertical scale     */
/* parameter to the raw bluescale value.  Here is why:    */
/*                                                        */
/*   We need to suppress overshoots for all pointsizes.   */
/*   At 300dpi that satisfies:                            */
/*                                                        */
/*      pointsize < 240*bluescale + 0.49                  */
/*                                                        */
/*   This corresponds to:                                 */
/*                                                        */
/*      pixelsize < 1000*bluescale + 49/24                */
/*                                                        */
/*      scale*EM_Size < 1000*bluescale + 49/24            */
/*                                                        */
/*   However, for normal Type 1 fonts, EM_Size is 1000!   */
/*   We thus only check:                                  */
/*                                                        */
/*      scale < bluescale + 49/24000                      */
/*                                                        */
/*   which we shorten to                                  */
/*                                                        */
/*      "scale < bluescale"                               */
/*                                                        */
/* Note that `blue_scale' is stored 1000 times its real   */
/* value, and that `scale' converts from font units to    */
/* fractional pixels.                                     */
/*                                                        */
/* 1000 / 64 = 125 / 8 */
/*                                                        */
/*  The blue threshold is the font units distance under   */
/*  which overshoots are suppressed due to the BlueShift  */
/*  even if the scale is greater than BlueScale.          */
/*                                                        */
/*  It is the smallest distance such that                 */
/*                                                        */
/*    dist <= BlueShift && dist*scale <= 0.5 pixels       */
/*                                                        */
/* round scaled reference position */
/* process the families now */
/* try to find a family zone whose reference position is less */
/* than 1 pixel far from the current zone                     */
/* calculate the maximum height of given blue zones */
/* look up stem top in top zones table */
/* look up stem bottom in bottom zones table */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                        GLOBAL HINTS                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* copy standard widths */
/* copy standard heights */
/* copy blue zones */
/* limit the BlueScale value to `1 / max_of_blue_zone_heights' */
/* BlueScale is scaled 1000 times */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\pshinter\pshinter.c
/***************************************************************************/
/*                                                                         */
/*  pshinter.c                                                             */
/*                                                                         */
/*    FreeType PostScript Hinting module                                   */
/*                                                                         */
/*  Copyright 2001, 2003 by                                                */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\pshinter\pshmod.c
/***************************************************************************/
/*                                                                         */
/*  pshmod.c                                                               */
/*                                                                         */
/*    FreeType PostScript hinter module implementation (body).             */
/*                                                                         */
/*  Copyright 2001, 2002, 2007, 2009, 2012 by                              */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* the Postscript Hinter module structure */
/* finalize module */
/* initialize module, create hints recorder and the interface */
/* returns global hints interface */
/* return Type 1 hints interface */
/* return Type 2 hints interface */
/* module-specific interface */
/* no additional interface for now */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\pshinter\pshpic.c
/***************************************************************************/
/*                                                                         */
/*  pshpic.c                                                               */
/*                                                                         */
/*    The FreeType position independent code services for pshinter module. */
/*                                                                         */
/*  Copyright 2009, 2010, 2012, 2013 by                                    */
/*  Oran Agra and Mickey Gabel.                                            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* forward declaration of PIC init functions from pshmod.c */
/* allocate pointer, clear and set global container pointer */
/* add call to initialization function when you add new scripts */
/* FT_CONFIG_OPTION_PIC */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\pshinter\pshrec.c
/***************************************************************************/
/*                                                                         */
/*  pshrec.c                                                               */
/*                                                                         */
/*    FreeType PostScript hints recorder (body).                           */
/*                                                                         */
/*  Copyright 2001-2004, 2007, 2009, 2013, 2014 by                         */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      PS_HINT MANAGEMENT                       *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* destroy hints table */
/* ensure that a table can contain "count" elements */
/* try to grow the table */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      PS_MASK MANAGEMENT                       *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* destroy mask */
/* ensure that a mask can contain "count" bits */
/* test a bit value in a given mask */
/* clear a given bit */
/* set a given bit, possibly grow the mask */
/* destroy mask table */
/* ensure that a mask table can contain "count" masks */
/* allocate a new mask in a table */
/* return last hint mask in a table, create one if the table is empty */
/* set a new mask to a given bit range */
/* now, copy bits */
/* test whether two masks in a table intersect */
/* merge two masks, used by ps_mask_table_merge_all */
/* swap index1 and index2 so that index1 < index2 */
/* we need to merge the bitsets of index1 and index2 with a */
/* simple union                                             */
/* if "count2" is greater than "count1", we need to grow the */
/* first bitset, and clear the highest bits                  */
/* merge (unite) the bitsets */
/* Now, remove "mask2" from the list.  We need to keep the masks */
/* sorted in order of importance, so move table elements.        */
/* number of masks to move */
/* move to end of table for reuse */
/* Try to merge all masks in a given table.  This is used to merge */
/* all counter masks into independent counter "paths".             */
/*                                                                 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    PS_DIMENSION MANAGEMENT                    *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* finalize a given dimension */
/* initialize a given dimension */
/* set a bit at a given index in the current hint mask */
/* get last hint mask */
/* set the end point in a mask, called from "End" & "Reset" methods */
/* set the end point in the current mask, then create a new empty one */
/* (called by "Reset" method)                                         */
/* end current mask */
/* allocate new one */
/* set a new mask, called from the "T2Stem" method */
/* reset current mask, if any */
/* set bits in new mask */
/* add a new single stem (called from "T1Stem" method) */
/* detect ghost stem */
/* now, lookup stem in the current hints table */
/* we need to create a new hint in the table */
/* now, store the hint in the current mask */
/* add a "hstem3/vstem3" counter to our dimension table */
/* try to find an existing counter mask that already uses */
/* one of these stems here                                */
/* create a new counter when needed */
/* now, set the bits for our hints in the counter mask */
/* end of recording session for a given dimension */
/* end hint mask table */
/* merge all counter masks into independent "paths" */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    PS_RECORDER MANAGEMENT                     *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* destroy hints */
/* initialize a hints for a new session */
/* add one or more stems to the current hints table */
/* limit "dimension" to 0..1 */
/* record the stems in the current hints/masks table */
/* Type 1 "hstem" or "vstem" operator */
/* Type 2 "hstem" or "vstem" operator */
/* add one Type1 counter stem to the current hints table */
/* limit "dimension" to 0..1 */
/* there must be 6 elements in the 'stem' array */
/* add the three stems to our hints/masks table */
/* now, add the hints to the counters table */
/* reset hints (only with Type 1 hints) */
/* invalid hint type */
/* Type2 "hintmask" operator, add a new hintmask to each direction */
/* check bit count; must be equal to current total hint count */
/* simply ignore the operator */
/* set-up new horizontal and vertical hint mask now */
/* check bit count, must be equal to current total hint count */
/* simply ignore the operator */
/* set-up new horizontal and vertical hint mask now */
/* end recording session */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                TYPE 1 HINTS RECORDING INTERFACE               *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                TYPE 2 HINTS RECORDING INTERFACE               *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* determine number of stems to write */
/* compute integer stem positions in font units */
/* compute lengths */
/* add them to the current dimension */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\psnames\psmodule.c
/***************************************************************************/
/*                                                                         */
/*  psmodule.c                                                             */
/*                                                                         */
/*    PSNames module implementation (body).                                */
/*                                                                         */
/*  Copyright 1996-2003, 2005-2008, 2012-2014 by                           */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* Return the Unicode value corresponding to a given glyph.  Note that */
/* we do deal with glyph variants by detecting a non-initial dot in    */
/* the name, as in `A.swash' or `e.final'; in this case, the           */
/* VARIANT_BIT is set in the return value.                             */
/*                                                                     */
/* If the name begins with `uni', then the glyph name may be a */
/* hard-coded unicode character code.                          */
/* determine whether the next four characters following are */
/* hexadecimal.                                             */
/* XXX: Add code to deal with ligatures, i.e. glyph names like */
/*      `uniXXXXYYYYZZZZ'...                                   */
/* Exit if a non-uppercase hexadecimal character was found   */
/* -- this also catches character codes below `0' since such */
/* negative numbers cast to `unsigned int' are far too big.  */
/* there must be exactly four hex digits */
/* If the name begins with `u', followed by four to six uppercase */
/* hexadecimal digits, it is a hard-coded unicode character code. */
/* Look for a non-initial dot in the glyph name in order to */
/* find variants like `A.swash', `e.final', etc.            */
/* now look up the glyph in the Adobe Glyph List */
/* ft_qsort callback to sort the unicode map */
/* sort base glyphs before glyph variants */
/* support for extra glyphs not handled (well) in AGL; */
/* we add extra mappings for them if necessary         */
/* WGL 4 */
/* Romanian */
/* mark this extra glyph as a candidate for the cmap */
/* disable this extra glyph from being added to the cmap */
/* Build a table that maps Unicode values to glyph indices. */
/* we first allocate the table */
/* This glyph name has an additional representation. */
/* Add it to the cmap.                               */
/* now compress the table a bit */
/* No unicode chars here! */
/* Reallocate if the number of used entries is much smaller. */
/* Sort the table in increasing order of unicode values, */
/* taking care of glyph variants.                        */
/* Perform a binary search on the table. */
/* remember match but continue search for base glyph */
/* we have a variant glyph */
/* we didn't find it; check whether we have a map just above it */
/* FT_CONFIG_OPTION_ADOBE_GLYPH_LIST */
/* FT_CONFIG_OPTION_ADOBE_GLYPH_LIST */
/* PSCMAPS_SERVICES_GET dereferences `library' in PIC mode */
/* FT_CONFIG_OPTION_POSTSCRIPT_NAMES */
/* this is not a font driver, nor a renderer */
/* driver name                         */
/* driver version                      */
/* driver requires FreeType 2 or above */
/* module specific interface */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\psnames\psnames.c
/***************************************************************************/
/*                                                                         */
/*  psnames.c                                                              */
/*                                                                         */
/*    FreeType PSNames module component (body only).                       */
/*                                                                         */
/*  Copyright 1996-2001 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\psnames\pspic.c
/***************************************************************************/
/*                                                                         */
/*  pspic.c                                                                */
/*                                                                         */
/*    The FreeType position independent code services for psnames module.  */
/*                                                                         */
/*  Copyright 2009, 2010, 2012, 2013 by                                    */
/*  Oran Agra and Mickey Gabel.                                            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* forward declaration of PIC init functions from psmodule.c */
/* allocate pointer, clear and set global container pointer */
/* initialize pointer table -                       */
/* this is how the module usually expects this data */
/* FT_CONFIG_OPTION_PIC */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\raster\ftraster.c
/***************************************************************************/
/*                                                                         */
/*  ftraster.c                                                             */
/*                                                                         */
/*    The FreeType glyph rasterizer (body).                                */
/*                                                                         */
/*  Copyright 1996-2003, 2005, 2007-2014 by                                */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* This file can be compiled without the rest of the FreeType engine, by */
/* defining the _STANDALONE_ macro when compiling it.  You also need to  */
/* put the files `ftimage.h' and `ftmisc.h' into the $(incdir)           */
/* directory.  Typically, you should do something like                   */
/*                                                                       */
/* - copy `src/raster/ftraster.c' (this file) to your current directory  */
/*                                                                       */
/* - copy `include/ftimage.h' and `src/raster/ftmisc.h' to your current  */
/*   directory                                                           */
/*                                                                       */
/* - compile `ftraster' with the _STANDALONE_ macro defined, as in       */
/*                                                                       */
/*     cc -c -D_STANDALONE_ ftraster.c                                   */
/*                                                                       */
/* The renderer can be initialized with a call to                        */
/* `ft_standard_raster.raster_new'; a bitmap can be generated            */
/* with a call to `ft_standard_raster.raster_render'.                    */
/*                                                                       */
/* See the comments and documentation in the file `ftimage.h' for more   */
/* details on how the raster works.                                      */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* This is a rewrite of the FreeType 1.x scan-line converter             */
/*                                                                       */
/*************************************************************************/
/* for memset */
/* !_STANDALONE_ */
/* for FT_MulDiv and FT_MulDiv_No_Round */
/* !_STANDALONE_ */
/*************************************************************************/
/*                                                                       */
/* A simple technical note on how the raster works                       */
/* -----------------------------------------------                       */
/*                                                                       */
/*   Converting an outline into a bitmap is achieved in several steps:   */
/*                                                                       */
/*   1 - Decomposing the outline into successive `profiles'.  Each       */
/*       profile is simply an array of scanline intersections on a given */
/*       dimension.  A profile's main attributes are                     */
/*                                                                       */
/*       o its scanline position boundaries, i.e. `Ymin' and `Ymax'      */
/*                                                                       */
/*       o an array of intersection coordinates for each scanline        */
/*         between `Ymin' and `Ymax'                                     */
/*                                                                       */
/*       o a direction, indicating whether it was built going `up' or    */
/*         `down', as this is very important for filling rules           */
/*                                                                       */
/*       o its drop-out mode                                             */
/*                                                                       */
/*   2 - Sweeping the target map's scanlines in order to compute segment */
/*       `spans' which are then filled.  Additionally, this pass         */
/*       performs drop-out control.                                      */
/*                                                                       */
/*   The outline data is parsed during step 1 only.  The profiles are    */
/*   built from the bottom of the render pool, used as a stack.  The     */
/*   following graphics shows the profile list under construction:       */
/*                                                                       */
/*     __________________________________________________________ _ _    */
/*    |         |                 |         |                 |          */
/*    | profile | coordinates for | profile | coordinates for |-->       */
/*    |    1    |  profile 1      |    2    |  profile 2      |-->       */
/*    |_________|_________________|_________|_________________|__ _ _    */
/*                                                                       */
/*    ^                                                       ^          */
/*    |                                                       |          */
/* start of render pool                                      top         */
/*                                                                       */
/*   The top of the profile stack is kept in the `top' variable.         */
/*                                                                       */
/*   As you can see, a profile record is pushed on top of the render     */
/*   pool, which is then followed by its coordinates/intersections.  If  */
/*   a change of direction is detected in the outline, a new profile is  */
/*   generated until the end of the outline.                             */
/*                                                                       */
/*   Note that when all profiles have been generated, the function       */
/*   Finalize_Profile_Table() is used to record, for each profile, its   */
/*   bottom-most scanline as well as the scanline above its upmost       */
/*   boundary.  These positions are called `y-turns' because they (sort  */
/*   of) correspond to local extrema.  They are stored in a sorted list  */
/*   built from the top of the render pool as a downwards stack:         */
/*                                                                       */
/*      _ _ _______________________________________                      */
/*                            |                    |                     */
/*                         <--| sorted list of     |                     */
/*                         <--|  extrema scanlines |                     */
/*      _ _ __________________|____________________|                     */
/*                                                                       */
/*                            ^                    ^                     */
/*                            |                    |                     */
/*                         maxBuff           sizeBuff = end of pool      */
/*                                                                       */
/*   This list is later used during the sweep phase in order to          */
/*   optimize performance (see technical note on the sweep below).       */
/*                                                                       */
/*   Of course, the raster detects whether the two stacks collide and    */
/*   handles the situation properly.                                     */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/**                                                                     **/
/**  CONFIGURATION MACROS                                               **/
/**                                                                     **/
/*************************************************************************/
/*************************************************************************/
/* define DEBUG_RASTER if you want to compile a debugging version */
/* #define DEBUG_RASTER */
/* define FT_RASTER_OPTION_ANTI_ALIASING if you want to support */
/* 5-levels anti-aliasing                                       */
/* #define FT_RASTER_OPTION_ANTI_ALIASING */
/* The size of the two-lines intermediate bitmap used */
/* for anti-aliasing, in bytes.                       */
/*************************************************************************/
/*************************************************************************/
/**                                                                     **/
/**  OTHER MACROS (do not change)                                       **/
/**                                                                     **/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* Auxiliary macros for token concatenation. */
/* This macro is used to indicate that a function parameter is unused. */
/* Its purpose is simply to reduce compiler warnings.  Note also that  */
/* simply defining it as `(void)x' doesn't avoid warnings with certain */
/* ANSI compilers (e.g. LCC).                                          */
/* Disable the tracing mechanism for simplicity -- developers can      */
/* activate it easily by redefining these macros.                      */
/* nothing */
/* nothing */
/* nothing */
/* nothing */
/* !_STANDALONE_ */
/* for FT_TRACE, FT_ERROR, and FT_THROW */
/* !_STANDALONE_ */
/* FMulDiv means `Fast MulDiv'; it is used in case where `b' is       */
/* typically a small value and the result of a*b is known to fit into */
/* 32 bits.                                                           */
/* On the other hand, SMulDiv means `Slow MulDiv', and is used typically */
/* for clipping computations.  It simply uses the FT_MulDiv() function   */
/* defined in `ftcalc.h'.                                                */
/* The rasterizer is a very general purpose component; please leave */
/* the following redefinitions there (you never know your target    */
/* environment).                                                    */
/* The maximum number of stacked Bezier curves. */
/* Setting this constant to more than 32 is a   */
/* pure waste of space.                         */
/* fractional bits of *input* coordinates */
/*************************************************************************/
/*************************************************************************/
/**                                                                     **/
/**  SIMPLE TYPE DECLARATIONS                                           **/
/**                                                                     **/
/*************************************************************************/
/*************************************************************************/
/* values for the `flags' bit field */
/* States of each line, arc, and profile */
/* current coordinate during sweep          */
/* link to next profile (various purposes)  */
/* start of profile's data in render pool   */
/* Bit 0-2: drop-out mode                   */
/* Bit 3: profile orientation (up/down)     */
/* Bit 4: is top profile?                   */
/* Bit 5: is bottom profile?                */
/* profile's height in scanlines            */
/* profile's starting scanline              */
/* number of lines to step before this      */
/* profile becomes drawable                 */
/* next profile in same contour, used       */
/* during drop-out control                  */
/* Simple record used to implement a stack of bands, required */
/* by the sub-banding mechanism                               */
/* band's minimum */
/* band's maximum */
/* void */
/* void */
/* void */
/* void */
/* !FT_STATIC_RASTER */
/* !FT_STATIC_RASTER */
/* prototypes used for sweep function dispatch */
/* NOTE: These operations are only valid on 2's complement processors */
/* The most used variables are positioned at the top of the structure. */
/* Thus, their offset can be coded with less opcodes, resulting in a   */
/* smaller executable.                                                 */
/* precision related variables         */
/* == precision_shift   for bitmaps    */
/* == precision_shift+1 for pixmaps    */
/* The profiles buffer                 */
/* Render pool size                    */
/* Profiles buffer size                */
/* Current cursor in buffer            */
/* number of Y-turns in outline        */
/* current Bezier arc pointer          */
/* target bitmap width                 */
/* target bitmap buffer                */
/* target pixmap buffer                */
/* current number of profiles          */
/* signals a fresh new profile which   */
/* `start' field must be completed     */
/* signals that the last arc ended     */
/* exactly on a scanline.  Allows      */
/* removal of doublets                 */
/* current profile                     */
/* head of linked list of profiles     */
/* contour's first profile in case     */
/* of impact                           */
/* rendering state                     */
/* description of target bit/pixmap    */
/* current offset in target bitmap     */
/* current offset in target pixmap     */
/* sweep's increment in target bitmap  */
/* current min x during gray rendering */
/* current max x during gray rendering */
/* dispatch variables */
/* current drop_out control method     */
/* indicates whether a horizontal pass */
/* should be performed to control      */
/* drop-out accurately when calling    */
/* Render_Glyph.  Note that there is   */
/* no horizontal pass during gray      */
/* rendering.                          */
/* The Bezier stack               */
/* band stack used for sub-banding     */
/* band stack top                      */
/* Intermediate table used to render the   */
/* graylevels pixmaps.                     */
/* gray_lines is a buffer holding two      */
/* monochrome scanlines                    */
/* width in bytes of one monochrome        */
/* intermediate scanline of gray_lines.    */
/* Each gray pixel takes 2 bits long there */
/* The gray_lines must hold 2 lines, thus with size */
/* in bytes of at least `gray_width*2'.             */
/* FT_RASTER_ANTI_ALIASING */
/* !FT_STATIC_RASTER */
/* !FT_STATIC_RASTER */
/* A lookup table used to quickly count set bits in four gray 2x2 */
/* cells.  The values of the table have been produced with the    */
/* following code:                                                */
/*                                                                */
/*   for ( i = 0; i < 256; i++ )                                  */
/*   {                                                            */
/*     l = 0;                                                     */
/*     j = i;                                                     */
/*                                                                */
/*     for ( c = 0; c < 4; c++ )                                  */
/*     {                                                          */
/*       l <<= 4;                                                 */
/*                                                                */
/*       if ( j & 0x80 ) l++;                                     */
/*       if ( j & 0x40 ) l++;                                     */
/*                                                                */
/*       j = ( j << 2 ) & 0xFF;                                   */
/*     }                                                          */
/*     printf( "0x%04X", l );                                     */
/*   }                                                            */
/*                                                                */
/* FT_RASTER_OPTION_ANTI_ALIASING */
/*************************************************************************/
/*************************************************************************/
/**                                                                     **/
/**  PROFILES COMPUTATION                                               **/
/**                                                                     **/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Set_High_Precision                                                 */
/*                                                                       */
/* <Description>                                                         */
/*    Set precision variables according to param flag.                   */
/*                                                                       */
/* <Input>                                                               */
/*    High :: Set to True for high precision (typically for ppem < 24),  */
/*            false otherwise.                                           */
/*                                                                       */
/*
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    New_Profile                                                        */
/*                                                                       */
/* <Description>                                                         */
/*    Create a new profile in the render pool.                           */
/*                                                                       */
/* <Input>                                                               */
/*    aState    :: The state/orientation of the new profile.             */
/*                                                                       */
/*    overshoot :: Whether the profile's unrounded start position        */
/*                 differs by at least a half pixel.                     */
/*                                                                       */
/* <Return>                                                              */
/*   SUCCESS on success.  FAILURE in case of overflow or of incoherent   */
/*   profile.                                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    End_Profile                                                        */
/*                                                                       */
/* <Description>                                                         */
/*    Finalize the current profile.                                      */
/*                                                                       */
/* <Input>                                                               */
/*    overshoot :: Whether the profile's unrounded end position differs  */
/*                 by at least a half pixel.                             */
/*                                                                       */
/* <Return>                                                              */
/*    SUCCESS on success.  FAILURE in case of overflow or incoherency.   */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Insert_Y_Turn                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Insert a salient into the sorted list placed on top of the render  */
/*    pool.                                                              */
/*                                                                       */
/* <Input>                                                               */
/*    New y scanline position.                                           */
/*                                                                       */
/* <Return>                                                              */
/*    SUCCESS on success.  FAILURE in case of overflow.                  */
/*                                                                       */
/* look for first y value that is <= */
/* if it is <, simply insert it, ignore if == */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Finalize_Profile_Table                                             */
/*                                                                       */
/* <Description>                                                         */
/*    Adjust all links in the profiles list.                             */
/*                                                                       */
/* <Return>                                                              */
/*    SUCCESS on success.  FAILURE in case of overflow.                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Split_Conic                                                        */
/*                                                                       */
/* <Description>                                                         */
/*    Subdivide one conic Bezier into two joint sub-arcs in the Bezier   */
/*    stack.                                                             */
/*                                                                       */
/* <Input>                                                               */
/*    None (subdivided Bezier is taken from the top of the stack).       */
/*                                                                       */
/* <Note>                                                                */
/*    This routine is the `beef' of this component.  It is  _the_ inner  */
/*    loop that should be optimized to hell to get the best performance. */
/*                                                                       */
/* hand optimized.  gcc doesn't seem to be too good at common      */
/* expression substitution and instruction scheduling ;-)          */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Split_Cubic                                                        */
/*                                                                       */
/* <Description>                                                         */
/*    Subdivide a third-order Bezier arc into two joint sub-arcs in the  */
/*    Bezier stack.                                                      */
/*                                                                       */
/* <Note>                                                                */
/*    This routine is the `beef' of the component.  It is one of _the_   */
/*    inner loops that should be optimized like hell to get the best     */
/*    performance.                                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Line_Up                                                            */
/*                                                                       */
/* <Description>                                                         */
/*    Compute the x-coordinates of an ascending line segment and store   */
/*    them in the render pool.                                           */
/*                                                                       */
/* <Input>                                                               */
/*    x1   :: The x-coordinate of the segment's start point.             */
/*                                                                       */
/*    y1   :: The y-coordinate of the segment's start point.             */
/*                                                                       */
/*    x2   :: The x-coordinate of the segment's end point.               */
/*                                                                       */
/*    y2   :: The y-coordinate of the segment's end point.               */
/*                                                                       */
/*    miny :: A lower vertical clipping bound value.                     */
/*                                                                       */
/*    maxy :: An upper vertical clipping bound value.                    */
/*                                                                       */
/* <Return>                                                              */
/*    SUCCESS on success, FAILURE on render pool overflow.               */
/*                                                                       */
/* XXX: is `Short' sufficient? */
/* Take care: miny-y1 can be a very large value; we use     */
/*            a slow MulDiv function to avoid clipping bugs */
/* x2 += FMulDiv( Dx, maxy - y2, Dy );  UNNECESSARY */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Line_Down                                                          */
/*                                                                       */
/* <Description>                                                         */
/*    Compute the x-coordinates of an descending line segment and store  */
/*    them in the render pool.                                           */
/*                                                                       */
/* <Input>                                                               */
/*    x1   :: The x-coordinate of the segment's start point.             */
/*                                                                       */
/*    y1   :: The y-coordinate of the segment's start point.             */
/*                                                                       */
/*    x2   :: The x-coordinate of the segment's end point.               */
/*                                                                       */
/*    y2   :: The y-coordinate of the segment's end point.               */
/*                                                                       */
/*    miny :: A lower vertical clipping bound value.                     */
/*                                                                       */
/*    maxy :: An upper vertical clipping bound value.                    */
/*                                                                       */
/* <Return>                                                              */
/*    SUCCESS on success, FAILURE on render pool overflow.               */
/*                                                                       */
/* A function type describing the functions used to split Bezier arcs */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Bezier_Up                                                          */
/*                                                                       */
/* <Description>                                                         */
/*    Compute the x-coordinates of an ascending Bezier arc and store     */
/*    them in the render pool.                                           */
/*                                                                       */
/* <Input>                                                               */
/*    degree   :: The degree of the Bezier arc (either 2 or 3).          */
/*                                                                       */
/*    splitter :: The function to split Bezier arcs.                     */
/*                                                                       */
/*    miny     :: A lower vertical clipping bound value.                 */
/*                                                                       */
/*    maxy     :: An upper vertical clipping bound value.                */
/*                                                                       */
/* <Return>                                                              */
/*    SUCCESS on success, FAILURE on render pool overflow.               */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Bezier_Down                                                        */
/*                                                                       */
/* <Description>                                                         */
/*    Compute the x-coordinates of an descending Bezier arc and store    */
/*    them in the render pool.                                           */
/*                                                                       */
/* <Input>                                                               */
/*    degree   :: The degree of the Bezier arc (either 2 or 3).          */
/*                                                                       */
/*    splitter :: The function to split Bezier arcs.                     */
/*                                                                       */
/*    miny     :: A lower vertical clipping bound value.                 */
/*                                                                       */
/*    maxy     :: An upper vertical clipping bound value.                */
/*                                                                       */
/* <Return>                                                              */
/*    SUCCESS on success, FAILURE on render pool overflow.               */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Line_To                                                            */
/*                                                                       */
/* <Description>                                                         */
/*    Inject a new line segment and adjust the Profiles list.            */
/*                                                                       */
/* <Input>                                                               */
/*   x :: The x-coordinate of the segment's end point (its start point   */
/*        is stored in `lastX').                                         */
/*                                                                       */
/*   y :: The y-coordinate of the segment's end point (its start point   */
/*        is stored in `lastY').                                         */
/*                                                                       */
/* <Return>                                                              */
/*   SUCCESS on success, FAILURE on render pool overflow or incorrect    */
/*   profile.                                                            */
/*                                                                       */
/* First, detect a change of direction */
/* Then compute the lines */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Conic_To                                                           */
/*                                                                       */
/* <Description>                                                         */
/*    Inject a new conic arc and adjust the profile list.                */
/*                                                                       */
/* <Input>                                                               */
/*   cx :: The x-coordinate of the arc's new control point.              */
/*                                                                       */
/*   cy :: The y-coordinate of the arc's new control point.              */
/*                                                                       */
/*   x  :: The x-coordinate of the arc's end point (its start point is   */
/*         stored in `lastX').                                           */
/*                                                                       */
/*   y  :: The y-coordinate of the arc's end point (its start point is   */
/*         stored in `lastY').                                           */
/*                                                                       */
/* <Return>                                                              */
/*   SUCCESS on success, FAILURE on render pool overflow or incorrect    */
/*   profile.                                                            */
/*                                                                       */
/* first, categorize the Bezier arc */
/* this arc has no given direction, split it! */
/* this arc is flat, ignore it and pop it from the Bezier stack */
/* the arc is y-monotonous, either ascending or descending */
/* detect a change of direction                            */
/* finalize current profile if any */
/* create a new profile */
/* now call the appropriate routine */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Cubic_To                                                           */
/*                                                                       */
/* <Description>                                                         */
/*    Inject a new cubic arc and adjust the profile list.                */
/*                                                                       */
/* <Input>                                                               */
/*   cx1 :: The x-coordinate of the arc's first new control point.       */
/*                                                                       */
/*   cy1 :: The y-coordinate of the arc's first new control point.       */
/*                                                                       */
/*   cx2 :: The x-coordinate of the arc's second new control point.      */
/*                                                                       */
/*   cy2 :: The y-coordinate of the arc's second new control point.      */
/*                                                                       */
/*   x   :: The x-coordinate of the arc's end point (its start point is  */
/*          stored in `lastX').                                          */
/*                                                                       */
/*   y   :: The y-coordinate of the arc's end point (its start point is  */
/*          stored in `lastY').                                          */
/*                                                                       */
/* <Return>                                                              */
/*   SUCCESS on success, FAILURE on render pool overflow or incorrect    */
/*   profile.                                                            */
/*                                                                       */
/* first, categorize the Bezier arc */
/* this arc has no given direction, split it! */
/* this arc is flat, ignore it and pop it from the Bezier stack */
/* detect a change of direction */
/* finalize current profile if any */
/* compute intersections */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Decompose_Curve                                                    */
/*                                                                       */
/* <Description>                                                         */
/*    Scan the outline arrays in order to emit individual segments and   */
/*    Beziers by calling Line_To() and Bezier_To().  It handles all      */
/*    weird cases, like when the first point is off the curve, or when   */
/*    there are simply no `on' points in the contour!                    */
/*                                                                       */
/* <Input>                                                               */
/*    first   :: The index of the first point in the contour.            */
/*                                                                       */
/*    last    :: The index of the last point in the contour.             */
/*                                                                       */
/*    flipped :: If set, flip the direction of the curve.                */
/*                                                                       */
/* <Return>                                                              */
/*    SUCCESS on success, FAILURE on error.                              */
/*                                                                       */
/* current point's state           */
/* set scan mode if necessary */
/* A contour cannot start with a cubic control point! */
/* check first point to determine origin */
/* first point is conic control.  Yes, this happens. */
/* start at last point if it is on the curve */
/* if both first and last points are conic,         */
/* start at their middle and record its position    */
/* for closure                                      */
/* v_last = v_start; */
/* emit a single line_to */
/* consume conic arcs */
/* FT_CURVE_TAG_CUBIC */
/* close the contour with a line segment */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Convert_Glyph                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Convert a glyph into a series of segments and arcs and make a      */
/*    profiles list with them.                                           */
/*                                                                       */
/* <Input>                                                               */
/*    flipped :: If set, flip the direction of curve.                    */
/*                                                                       */
/* <Return>                                                              */
/*    SUCCESS on success, FAILURE if any error was encountered during    */
/*    rendering.                                                         */
/*                                                                       */
/* we must now check whether the extreme arcs join or not */
/* Note that ras.gProfile can be nil if the contour was too small */
/* to be drawn.                                                   */
/* close the `next profile in contour' linked list */
/*************************************************************************/
/*************************************************************************/
/**                                                                     **/
/**  SCAN-LINE SWEEPS AND DRAWING                                       **/
/**                                                                     **/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/*  Init_Linked                                                          */
/*                                                                       */
/*    Initializes an empty linked list.                                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/*  InsNew                                                               */
/*                                                                       */
/*    Inserts a new profile in a linked list.                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/*  DelOld                                                               */
/*                                                                       */
/*    Removes an old profile from a linked list.                         */
/*                                                                       */
/* we should never get there, unless the profile was not part of */
/* the list.                                                     */
/*************************************************************************/
/*                                                                       */
/*  Sort                                                                 */
/*                                                                       */
/*    Sorts a trace list.  In 95%, the list is already sorted.  We need  */
/*    an algorithm which is fast in this case.  Bubble sort is enough    */
/*    and simple.                                                        */
/*                                                                       */
/* First, set the new X coordinate of each profile */
/* Then sort them */
/*************************************************************************/
/*                                                                       */
/*  Vertical Sweep Procedure Set                                         */
/*                                                                       */
/*  These four routines are used during the vertical black/white sweep   */
/*  phase by the generic Draw_Sweep() function.                          */
/*                                                                       */
/*************************************************************************/
/* Drop-out control */
/* memset() is slower than the following code on many platforms. */
/* This is due to the fact that, in the vast majority of cases,  */
/* the span length in bytes is relatively small.                 */
/* Drop-out control */
/*   e2            x2                    x1           e1   */
/*                                                         */
/*                 ^                     |                 */
/*                 |                     |                 */
/*   +-------------+---------------------+------------+    */
/*                 |                     |                 */
/*                 |                     v                 */
/*                                                         */
/* pixel         contour              contour       pixel  */
/* center                                           center */
/* drop-out mode    scan conversion rules (as defined in OpenType) */
/* --------------------------------------------------------------- */
/*  0                1, 2, 3                                       */
/*  1                1, 2, 4                                       */
/*  2                1, 2                                          */
/*  3                same as mode 2                                */
/*  4                1, 2, 5                                       */
/*  5                1, 2, 6                                       */
/*  6, 7             same as mode 2                                */
/* simple drop-outs including stubs */
/* smart drop-outs including stubs */
/* simple drop-outs excluding stubs */
/* smart drop-outs excluding stubs  */
/* Drop-out Control Rules #4 and #6 */
/* The specification neither provides an exact definition */
/* of a `stub' nor gives exact rules to exclude them.     */
/*                                                        */
/* Here the constraints we use to recognize a stub.       */
/*                                                        */
/*  upper stub:                                           */
/*                                                        */
/*   - P_Left and P_Right are in the same contour         */
/*   - P_Right is the successor of P_Left in that contour */
/*   - y is the top of P_Left and P_Right                 */
/*                                                        */
/*  lower stub:                                           */
/*                                                        */
/*   - P_Left and P_Right are in the same contour         */
/*   - P_Left is the successor of P_Right in that contour */
/*   - y is the bottom of P_Left                          */
/*                                                        */
/* We draw a stub if the following constraints are met.   */
/*                                                        */
/*   - for an upper or lower stub, there is top or bottom */
/*     overshoot, respectively                            */
/*   - the covered interval is greater or equal to a half */
/*     pixel                                              */
/* upper stub test */
/* lower stub test */
/* modes 2, 3, 6, 7 */
/* no drop-out control */
/* undocumented but confirmed: If the drop-out would result in a  */
/* pixel outside of the bounding box, use the pixel inside of the */
/* bounding box instead                                           */
/* check that the other pixel isn't set */
/***********************************************************************/
/*                                                                     */
/*  Horizontal Sweep Procedure Set                                     */
/*                                                                     */
/*  These four routines are used during the horizontal black/white     */
/*  sweep phase by the generic Draw_Sweep() function.                  */
/*                                                                     */
/***********************************************************************/
/* nothing, really */
/* During the horizontal sweep, we only take care of drop-outs */
/* e1     +       <-- pixel center */
/*        |                        */
/* x1  ---+-->    <-- contour      */
/*        |                        */
/*        |                        */
/* x2  <--+---    <-- contour      */
/*        |                        */
/*        |                        */
/* e2     +       <-- pixel center */
/* simple drop-outs including stubs */
/* smart drop-outs including stubs */
/* simple drop-outs excluding stubs */
/* smart drop-outs excluding stubs  */
/* see Vertical_Sweep_Drop for details */
/* rightmost stub test */
/* leftmost stub test */
/* modes 2, 3, 6, 7 */
/* no drop-out control */
/* undocumented but confirmed: If the drop-out would result in a  */
/* pixel outside of the bounding box, use the pixel inside of the */
/* bounding box instead                                           */
/* check that the other pixel isn't set */
/* Nothing, really */
/*************************************************************************/
/*                                                                       */
/*  Vertical Gray Sweep Procedure Set                                    */
/*                                                                       */
/*  These two routines are used during the vertical gray-levels sweep    */
/*  phase by the generic Draw_Sweep() function.                          */
/*                                                                       */
/*  NOTES                                                                */
/*                                                                       */
/*  - The target pixmap's width *must* be a multiple of 4.               */
/*                                                                       */
/*  - You have to use the function Vertical_Sweep_Span() for the gray    */
/*    span call.                                                         */
/*                                                                       */
/*************************************************************************/
/* nothing, really */
/* During the horizontal sweep, we only take care of drop-outs */
/* simple drop-outs including stubs */
/* smart drop-outs including stubs */
/* simple drop-outs excluding stubs */
/* smart drop-outs excluding stubs  */
/* see Vertical_Sweep_Drop for details */
/* rightmost stub test */
/* leftmost stub test */
/* modes 2, 3, 6, 7 */
/* no drop-out control */
/* FT_RASTER_OPTION_ANTI_ALIASING */
/*************************************************************************/
/*                                                                       */
/*  Generic Sweep Drawing routine                                        */
/*                                                                       */
/*************************************************************************/
/* initialize empty linked lists */
/* first, compute min and max Y */
/* check the Y-turns */
/* now initialize the sweep */
/* then compute the distance of each profile from min_Y */
/* let's go */
/* check waiting list for new activations */
/* sort the drawing lists */
/* let's trace */
/* a drop-out was detected */
/* mark profile for drop-out processing */
/* handle drop-outs _after_ the span drawing --       */
/* drop-out processing has been moved out of the loop */
/* for performance tuning                             */
/* now finalize the profiles that need it */
/* for gray-scaling, flush the bitmap scanline cache */
/* -- this is useful when debugging only */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Render_Single_Pass                                                 */
/*                                                                       */
/* <Description>                                                         */
/*    Perform one sweep with sub-banding.                                */
/*                                                                       */
/* <Input>                                                               */
/*    flipped :: If set, flip the direction of the outline.              */
/*                                                                       */
/* <Return>                                                              */
/*    Renderer error code.                                               */
/*                                                                       */
/* sub-banding */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Render_Glyph                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    Render a glyph in a bitmap.  Sub-banding if needed.                */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* Vertical Sweep */
/* Horizontal Sweep */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Render_Gray_Glyph                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Render a glyph with grayscaling.  Sub-banding if needed.           */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* Vertical Sweep */
/* Horizontal Sweep */
/* !FT_RASTER_OPTION_ANTI_ALIASING */
/* !FT_RASTER_OPTION_ANTI_ALIASING */
/* set default 5-levels gray palette */
/**** RASTER OBJECT CREATION: In standalone mode, we simply use *****/
/****                         a static object.                  *****/
/* nothing */
/* !_STANDALONE_ */
/* !_STANDALONE_ */
/* set 5-levels gray palette */
/* return immediately if the outline is empty */
/* this version of the raster does not support direct rendering, sorry */
/* nothing to do */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\raster\ftrend1.c
/***************************************************************************/
/*                                                                         */
/*  ftrend1.c                                                              */
/*                                                                         */
/*    The FreeType glyph rasterizer interface (body).                      */
/*                                                                         */
/*  Copyright 1996-2003, 2005, 2006, 2011, 2013 by                         */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* initialize renderer -- init its raster */
/* set render-specific mode */
/* we simply pass it to the raster */
/* transform a given glyph image */
/* return the glyph's control box */
/* convert a slot's glyph image into a bitmap */
/* check glyph image format */
/* check rendering mode */
/* raster1 is only capable of producing monochrome bitmaps */
/* raster5 is only capable of producing 5-gray-levels bitmaps */
/* FT_CONFIG_OPTION_PIC */
/* When PIC is enabled, we cannot get to the class object      */
/* so instead we check the final character in the class name   */
/* ("raster5" or "raster1"). Yes this is a hack.               */
/* The "correct" thing to do is have different render function */
/* for each of the classes.                                    */
/* raster1 is only capable of producing monochrome bitmaps */
/* raster5 is only capable of producing 5-gray-levels bitmaps */
/* FT_CONFIG_OPTION_PIC */
/* translate the outline to the new origin if needed */
/* compute the control box, and grid fit it */
/* undocumented but confirmed: bbox values get rounded */
/* release old bitmap buffer */
/* allocate new one, depends on pixel format */
/* we pad to 32 bits, only for backwards compatibility with FT 1.x */
/* translate outline to render it into the bitmap */
/* set up parameters */
/* render outline into the bitmap */
/* module specific interface */
/* This renderer is _NOT_ part of the default modules; you will need */
/* to register it by hand in your application.  It should only be    */
/* used for backwards-compatibility with FT 1.x anyway.              */
/*                                                                   */
/* module specific interface */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\raster\raster.c
/***************************************************************************/
/*                                                                         */
/*  raster.c                                                               */
/*                                                                         */
/*    FreeType monochrome rasterer module component (body only).           */
/*                                                                         */
/*  Copyright 1996-2001 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\raster\rastpic.c
/***************************************************************************/
/*                                                                         */
/*  rastpic.c                                                              */
/*                                                                         */
/*    The FreeType position independent code services for raster module.   */
/*                                                                         */
/*  Copyright 2009, 2010, 2012, 2013 by                                    */
/*  Oran Agra and Mickey Gabel.                                            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* forward declaration of PIC init functions from ftraster.c */
/* since this function also serves raster5 renderer, */
/* it implements reference counting                  */
/* allocate pointer, clear and set global container pointer */
/* initialize pointer table -                       */
/* this is how the module usually expects this data */
/* re-route these init and free functions to the above functions */
/* FT_CONFIG_OPTION_PIC */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\sfnt\pngshim.c
/***************************************************************************/
/*                                                                         */
/*  pngshim.c                                                              */
/*                                                                         */
/*    PNG Bitmap glyph support.                                            */
/*                                                                         */
/*  Copyright 2013, 2014 by Google, Inc.                                   */
/*  Written by Stuart Gill and Behdad Esfahbod.                            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* We always include <stjmp.h>, so make libpng shut up! */
/* This code is freely based on cairo-png.c.  There's so many ways */
/* to call libpng, and the way cairo does it is defacto standard.  */
/* Premultiplies data and converts RGBA bytes => native endian. */
/* Converts RGBx bytes to BGRA. */
/* Use error callback to avoid png writing to stderr. */
/* if we get here, then we have no choice but to abort ... */
/* Use warning callback to avoid png writing to stderr. */
/* Just ignore warnings. */
/* pacify compiler */
/* reject too large bitmaps similarly to the rasterizer */
/* this doesn't overflow: 0x7FFF * 0x7FFF * 4 < 2^32 */
/* convert palette/gray image to rgb */
/* expand gray bit depth if needed */
/* transform transparency to alpha */
/* convert grayscale to RGB */
/* recheck header after setting EXPAND options */
/* Shouldn't happen, but fall through. */
/* Humm, this smells.  Carry on though. */
/* FT_CONFIG_OPTION_USE_PNG */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\sfnt\sfdriver.c
/***************************************************************************/
/*                                                                         */
/*  sfdriver.c                                                             */
/*                                                                         */
/*    High-level SFNT driver interface (body).                             */
/*                                                                         */
/*  Copyright 1996-2007, 2009-2014 by                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*
/*
/* TT_CONFIG_OPTION_POSTSCRIPT_NAMES */
/*
/* shouldn't happen, but just in case to avoid memory leaks */
/* scan the name table to see whether we have a Postscript name here, */
/* either in Macintosh or Windows platform encodings                  */
/*
/* XXX: I don't know whether this is correct, since
/* TT_CONFIG_OPTION_BDF */
/*
/* SFNT_SERVICES_GET dereferences `library' in PIC mode */
/* see `ttload.h' */
/* see `ttpost.h' */
/* since version 2.1.8 */
/* since version 2.2 */
/* see `ttsbit.h' and `sfnt.h' */
/* not a font driver or renderer */
/* driver name                            */
/* driver version 1.0                     */
/* driver requires FreeType 2.0 or higher */
/* module specific interface */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\sfnt\sfnt.c
/***************************************************************************/
/*                                                                         */
/*  sfnt.c                                                                 */
/*                                                                         */
/*    Single object library component.                                     */
/*                                                                         */
/*  Copyright 1996-2006, 2013 by                                           */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\sfnt\sfntpic.c
/***************************************************************************/
/*                                                                         */
/*  sfntpic.c                                                              */
/*                                                                         */
/*    The FreeType position independent code services for sfnt module.     */
/*                                                                         */
/*  Copyright 2009, 2010, 2012, 2013 by                                    */
/*  Oran Agra and Mickey Gabel.                                            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* forward declaration of PIC init functions from sfdriver.c */
/* forward declaration of PIC init functions from ttcmap.c */
/* allocate pointer, clear and set global container pointer */
/* initialize pointer table -                       */
/* this is how the module usually expects this data */
/* FT_CONFIG_OPTION_PIC */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\sfnt\sfobjs.c
/***************************************************************************/
/*                                                                         */
/*  sfobjs.c                                                               */
/*                                                                         */
/*    SFNT object management (base).                                       */
/*                                                                         */
/*  Copyright 1996-2008, 2010-2014 by                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* convert a UTF-16 name entry to ASCII */
/* convert an Apple Roman or symbol name entry to ASCII */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_get_name                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Returns a given ENGLISH name record in ASCII.                      */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: A handle to the source face object.                      */
/*                                                                       */
/*    nameid :: The name id of the name record to return.                */
/*                                                                       */
/* <InOut>                                                               */
/*    name   :: The address of a string pointer.  NULL if no name is     */
/*              present.                                                 */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* According to the OpenType 1.3 specification, only Microsoft or  */
/* Apple platform IDs might be used in the `name' table.  The      */
/* `Unicode' platform is reserved for the `cmap' table, and the    */
/* `ISO' one is deprecated.                                        */
/*                                                                 */
/* However, the Apple TrueType specification doesn't say the same  */
/* thing and goes to suggest that all Unicode `name' table entries */
/* should be coded in UTF-16 (in big-endian format I suppose).     */
/*                                                                 */
/* there is `languageID' to check there.  We should use this */
/* field only as a last solution when nothing else is        */
/* available.                                                */
/*                                                           */
/* This is a bit special because some fonts will use either    */
/* an English language id, or a Roman encoding id, to indicate */
/* the English version of its font name.                       */
/*                                                             */
/* we only take a non-English name when there is nothing */
/* else available in the font                            */
/*                                                       */
/* some fonts contain invalid Unicode or Macintosh formatted entries; */
/* we will thus favor names encoded in Windows formats if available   */
/* (provided it is an English name)                                   */
/*                                                                    */
/* all Unicode strings are encoded using UTF-16BE */
/* Apparently, if this value is found in a name table entry, it is */
/* documented as `full Unicode repertoire'.  Experience with the   */
/* MsGothic font shipped with Windows Vista shows that this really */
/* means UTF-16 encoded names (UCS-4 values are only used within   */
/* charmaps).                                                      */
/* Replace `face->root.stream' with a stream containing the extracted */
/* SFNT of a WOFF font.                                               */
/* Make sure we don't recurse back here or hit TTC code. */
/* Miscellaneous checks. */
/* Write sfnt header. */
/* While the entries in the sfnt header must be sorted by the */
/* tag value, the tables themselves are not.  We thus have to */
/* sort them by offset and check that they don't overlap.     */
/* Sort by offset. */
/* Check offsets and lengths. */
/* The offsets must be multiples of 4. */
/*
/* We have padding only ... */
/* ... if it isn't the last block. */
/* No padding for the last block. */
/* Write the tables. */
/* Write SFNT table entry. */
/* Write table data. */
/* Uncompressed data; just copy. */
/* Uncompress with zlib. */
/* !FT_CONFIG_OPTION_USE_ZLIB */
/* !FT_CONFIG_OPTION_USE_ZLIB */
/* We don't check whether the padding bytes in the WOFF file are     */
/* actually '\0'.  For the output, however, we do set them properly. */
/* Ok!  Finally ready.  Swap out stream and return. */
/* Fill in face->ttc_header.  If the font is not a TTC, it is */
/* synthesized into a TTC with one offset table.              */
/* this is ULong in the specs */
/* Swap out stream and retry! */
/* a rough size estimate: let's conservatively assume that there   */
/* is just a single table info in each subfont header (12 + 16*1 = */
/* 28 bytes), thus we have (at least) `12 + 4*count' bytes for the */
/* size of the TTC header plus `28*count' bytes for all subfont    */
/* headers                                                         */
/* now read the offsets of each font in the file */
/* for now, parameters are unused */
/* Stream may have changed in sfnt_open_font. */
/* check that we have a valid TrueType file */
/* Check parameters */
/* Load tables */
/* We now support two SFNT-based bitmapped font formats.  They */
/* are recognized easily as they do not include a `glyf'       */
/* table.                                                      */
/*                                                             */
/* The first format comes from Apple, and uses a table named   */
/* `bhed' instead of `head' to store the font header (using    */
/* the same format).  It also doesn't include horizontal and   */
/* vertical metrics tables (i.e. `hhea' and `vhea' tables are  */
/* missing).                                                   */
/*                                                             */
/* The other format comes from Microsoft, and is used with     */
/* WinCE/PocketPC.  It looks like a standard TTF, except that  */
/* it doesn't contain outlines.                                */
/*                                                             */
/* do we have outlines in there? */
/* Apple 'sbix' color bitmaps are rendered scaled and then the 'glyf'
/* if this font doesn't contain outlines, we try to load */
/* a `bhed' table                                        */
/* load the font header (`head' table) if this isn't an Apple */
/* sbit font file                                             */
/* the following tables are often not present in embedded TrueType */
/* fonts within PDF documents, so don't check for them.            */
/* the following tables are optional in PCL fonts -- */
/* don't check for errors                            */
/* do not load the metrics headers and tables if this is an Apple */
/* sbit font file                                                 */
/* load the `hhea' and `hmtx' tables */
/* If this is an incrementally loaded font and there are */
/* overriding metrics, tolerate a missing `hmtx' table.  */
/* No `hhea' table necessary for SFNT Mac fonts. */
/* If this is an incrementally loaded font and there are */
/* overriding metrics, tolerate a missing `hhea' table.  */
/* try to load the `vhea' and `vmtx' tables */
/* we treat the table as missing if there are any errors */
/* the optional tables */
/* embedded bitmap support */
/* a font which contains neither bitmaps nor outlines is */
/* still valid (although rather useless in most cases);  */
/* however, you can find such stripped fonts in PDFs     */
/* consider the kerning and gasp tables as optional */
/* Bit 8 of the `fsSelection' field in the `OS/2' table denotes  */
/* a WWS-only font face.  `WWS' stands for `weight', width', and */
/* `slope', a term used by Microsoft's Windows Presentation      */
/* Foundation (WPF).  This flag has been introduced in version   */
/* 1.5 of the OpenType specification (May 2008).                 */
/* now set up root fields */
/*********************************************************************/
/*                                                                   */
/* Compute face flags.                                               */
/*                                                                   */
/* color glyphs */
/* scalable outlines */
/* The sfnt driver only supports bitmap fonts natively, thus we */
/* don't set FT_FACE_FLAG_HINTER.                               */
/* SFNT file format  */
/* horizontal data   */
/* fixed width font? */
/* vertical information? */
/* kerning available ? */
/* Don't bother to load the tables unless somebody asks for them. */
/* No need to do work which will (probably) not be used.          */
/*********************************************************************/
/*                                                                   */
/* Compute style flags.                                              */
/*                                                                   */
/* We have an OS/2 table; use the `fsSelection' field.  Bit 9 */
/* indicates an oblique font face.  This flag has been        */
/* introduced in version 1.5 of the OpenType specification.   */
/* bit 9 */
/* bit 0 */
/* bit 5 */
/* this is an old Mac font, use the header field */
/*********************************************************************/
/*                                                                   */
/* Polish the charmaps.                                              */
/*                                                                   */
/*   Try to set the charmap encoding according to the platform &     */
/*   encoding ID of each charmap.                                    */
/*                                                                   */
/* ignore errors */
/* set the encoding fields */
/* set 'root->charmap' to the first Unicode encoding we find */
/*
/* assume 72dpi */
/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
/* a font with no bitmaps and no outlines is scalable; */
/* it has only empty glyphs then                       */
/*********************************************************************/
/*                                                                   */
/*  Set up metrics.                                                  */
/*                                                                   */
/* XXX What about if outline header is missing */
/*     (e.g. sfnt wrapped bitmap)?             */
/* XXX: Computing the ascender/descender/height is very different */
/*      from what the specification tells you.  Apparently, we    */
/*      must be careful because                                   */
/*                                                                */
/*      - not all fonts have an OS/2 table; in this case, we take */
/*        the values in the horizontal header.  However, these    */
/*        values very often are not reliable.                     */
/*                                                                */
/*      - otherwise, the correct typographic values are in the    */
/*        sTypoAscender, sTypoDescender & sTypoLineGap fields.    */
/*                                                                */
/*        However, certain fonts have these fields set to 0.      */
/*        Rather, they have usWinAscent & usWinDescent correctly  */
/*        set (but with different values).                        */
/*                                                                */
/*      As an example, Arial Narrow is implemented through four   */
/*      files ARIALN.TTF, ARIALNI.TTF, ARIALNB.TTF & ARIALNBI.TTF */
/*                                                                */
/*      Strangely, all fonts have the same values in their        */
/*      sTypoXXX fields, except ARIALNB which sets them to 0.     */
/*                                                                */
/*      On the other hand, they all have different                */
/*      usWinAscent/Descent values -- as a conclusion, the OS/2   */
/*      table cannot be used to compute the text height reliably! */
/*                                                                */
/* The ascender and descender are taken from the `hhea' table. */
/* If zero, they are taken from the `OS/2' table.              */
//www.microsoft.com/OpenType/OTSpec/post.htm -- */
/* See http://www.microsoft.com/OpenType/OTSpec/post.htm -- */
/* Adjust underline position from top edge to centre of     */
/* stroke to convert TrueType meaning to FreeType meaning.  */
/* destroy the postscript names table if it is loaded */
/* destroy the embedded bitmaps table if it is loaded */
/* freeing the embedded BDF properties */
/* freeing the kerning table */
/* freeing the collection table */
/* freeing table directory */
/* simply release the 'cmap' table frame */
/* freeing the horizontal metrics */
/* freeing the vertical ones, if any */
/* freeing the gasp table */
/* freeing the name table */
/* freeing family and style name */
/* freeing sbit size table */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\sfnt\ttbdf.c
/***************************************************************************/
/*                                                                         */
/*  ttbdf.c                                                                */
/*                                                                         */
/*    TrueType and OpenType embedded BDF properties (body).                */
/*                                                                         */
/*  Copyright 2005, 2006, 2010, 2013 by                                    */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*
/* be a bit paranoid for invalid entries here */
/* string */
/* atoms */
/* check that the content is really 0-terminated */
/* TT_CONFIG_OPTION_BDF */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\sfnt\ttcmap.c
/***************************************************************************/
/*                                                                         */
/*  ttcmap.c                                                               */
/*                                                                         */
/*    TrueType character mapping table (cmap) support (body).              */
/*                                                                         */
/*  Copyright 2002-2010, 2012-2014 by                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* must come before FT_INTERNAL_VALIDATE_H */
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                           FORMAT 0                            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* TABLE OVERVIEW                                                        */
/* --------------                                                        */
/*                                                                       */
/*   NAME        OFFSET         TYPE          DESCRIPTION                */
/*                                                                       */
/*   format      0              USHORT        must be 0                  */
/*   length      2              USHORT        table length in bytes      */
/*   language    4              USHORT        Mac language code          */
/*   glyph_ids   6              BYTE[256]     array of glyph indices     */
/*               262                                                     */
/*                                                                       */
/* skip format */
/* check glyph indices whenever necessary */
/* go to glyph IDs */
/* TT_CONFIG_CMAP_FORMAT_0 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          FORMAT 2                             *****/
/*****                                                               *****/
/***** This is used for certain CJK encodings that encode text in a  *****/
/***** mixed 8/16 bits encoding along the following lines:           *****/
/*****                                                               *****/
/***** * Certain byte values correspond to an 8-bit character code   *****/
/*****   (typically in the range 0..127 for ASCII compatibility).    *****/
/*****                                                               *****/
/***** * Certain byte values signal the first byte of a 2-byte       *****/
/*****   character code (but these values are also valid as the      *****/
/*****   second byte of a 2-byte character).                         *****/
/*****                                                               *****/
/***** The following charmap lookup and iteration functions all      *****/
/***** assume that the value "charcode" correspond to following:     *****/
/*****                                                               *****/
/*****   - For one byte characters, "charcode" is simply the         *****/
/*****     character code.                                           *****/
/*****                                                               *****/
/*****   - For two byte characters, "charcode" is the 2-byte         *****/
/*****     character code in big endian format.  More exactly:       *****/
/*****                                                               *****/
/*****       (charcode >> 8)    is the first byte value              *****/
/*****       (charcode & 0xFF)  is the second byte value             *****/
/*****                                                               *****/
/***** Note that not all values of "charcode" are valid according    *****/
/***** to these rules, and the function moderately check the         *****/
/***** arguments.                                                    *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* TABLE OVERVIEW                                                        */
/* --------------                                                        */
/*                                                                       */
/*   NAME        OFFSET         TYPE            DESCRIPTION              */
/*                                                                       */
/*   format      0              USHORT          must be 2                */
/*   length      2              USHORT          table length in bytes    */
/*   language    4              USHORT          Mac language code        */
/*   keys        6              USHORT[256]     sub-header keys          */
/*   subs        518            SUBHEAD[NSUBS]  sub-headers array        */
/*   glyph_ids   518+NSUB*8     USHORT[]        glyph ID array           */
/*                                                                       */
/* The `keys' table is used to map charcode high-bytes to sub-headers.   */
/* The value of `NSUBS' is the number of sub-headers defined in the      */
/* table and is computed by finding the maximum of the `keys' table.     */
/*                                                                       */
/* Note that for any n, `keys[n]' is a byte offset within the `subs'     */
/* table, i.e., it is the corresponding sub-header index multiplied      */
/* by 8.                                                                 */
/*                                                                       */
/* Each sub-header has the following format:                             */
/*                                                                       */
/*   NAME        OFFSET      TYPE            DESCRIPTION                 */
/*                                                                       */
/*   first       0           USHORT          first valid low-byte        */
/*   count       2           USHORT          number of valid low-bytes   */
/*   delta       4           SHORT           see below                   */
/*   offset      6           USHORT          see below                   */
/*                                                                       */
/* A sub-header defines, for each high-byte, the range of valid          */
/* low-bytes within the charmap.  Note that the range defined by `first' */
/* and `count' must be completely included in the interval [0..255]      */
/* according to the specification.                                       */
/*                                                                       */
/* If a character code is contained within a given sub-header, then      */
/* mapping it to a glyph index is done as follows:                       */
/*                                                                       */
/* * The value of `offset' is read.  This is a _byte_ distance from the  */
/*   location of the `offset' field itself into a slice of the           */
/*   `glyph_ids' table.  Let's call it `slice' (it is a USHORT[] too).   */
/*                                                                       */
/* * The value `slice[char.lo - first]' is read.  If it is 0, there is   */
/*   no glyph for the charcode.  Otherwise, the value of `delta' is      */
/*   added to it (modulo 65536) to form a new glyph index.               */
/*                                                                       */
/* It is up to the validation routine to check that all offsets fall     */
/* within the glyph IDs table (and not within the `subs' table itself or */
/* outside of the CMap).                                                 */
/*                                                                       */
/* keys table     */
/* sub-headers    */
/* glyph ID array */
/* skip format */
/* parse keys to compute sub-headers count */
/* value must be multiple of 8 */
/* parse sub-headers */
/* many Dynalab fonts have empty sub-headers */
/* check range within 0..255 */
/* check offset */
/* check glyph IDs */
/* return sub header corresponding to a given character code */
/* NULL on invalid charcode                                  */
/* keys table */
/* subheaders table */
/* an 8-bit character code -- we use subHeader 0 in this case */
/* to test whether the character code is in the charmap       */
/*                                                            */
/* jump to first sub-header */
/* check that the sub-header for this byte is 0, which */
/* indicates that it is really a valid one-byte value  */
/* Otherwise, return 0                                 */
/*                                                     */
/* a 16-bit character code */
/* jump to key entry  */
/* jump to sub-header */
/* check that the high byte isn't a valid one-byte value */
/* jump to next sub-header, i.e. higher byte value */
/* TT_CONFIG_CMAP_FORMAT_2 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                           FORMAT 4                            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* TABLE OVERVIEW                                                        */
/* --------------                                                        */
/*                                                                       */
/*   NAME          OFFSET         TYPE              DESCRIPTION          */
/*                                                                       */
/*   format        0              USHORT            must be 4            */
/*   length        2              USHORT            table length         */
/*                                                  in bytes             */
/*   language      4              USHORT            Mac language code    */
/*                                                                       */
/*   segCountX2    6              USHORT            2*NUM_SEGS           */
/*   searchRange   8              USHORT            2*(1 << LOG_SEGS)    */
/*   entrySelector 10             USHORT            LOG_SEGS             */
/*   rangeShift    12             USHORT            segCountX2 -         */
/*                                                    searchRange        */
/*                                                                       */
/*   endCount      14             USHORT[NUM_SEGS]  end charcode for     */
/*                                                  each segment; last   */
/*                                                  is 0xFFFF            */
/*                                                                       */
/*   pad           14+NUM_SEGS*2  USHORT            padding              */
/*                                                                       */
/*   startCount    16+NUM_SEGS*2  USHORT[NUM_SEGS]  first charcode for   */
/*                                                  each segment         */
/*                                                                       */
/*   idDelta       16+NUM_SEGS*4  SHORT[NUM_SEGS]   delta for each       */
/*                                                  segment              */
/*   idOffset      16+NUM_SEGS*6  SHORT[NUM_SEGS]   range offset for     */
/*                                                  each segment; can be */
/*                                                  zero                 */
/*                                                                       */
/*   glyphIds      16+NUM_SEGS*8  USHORT[]          array of glyph ID    */
/*                                                  ranges               */
/*                                                                       */
/* Character codes are modelled by a series of ordered (increasing)      */
/* intervals called segments.  Each segment has start and end codes,     */
/* provided by the `startCount' and `endCount' arrays.  Segments must    */
/* not overlap, and the last segment should always contain the value     */
/* 0xFFFF for `endCount'.                                                */
/*                                                                       */
/* The fields `searchRange', `entrySelector' and `rangeShift' are better */
/* ignored (they are traces of over-engineering in the TrueType          */
/* specification).                                                       */
/*                                                                       */
/* Each segment also has a signed `delta', as well as an optional offset */
/* within the `glyphIds' table.                                          */
/*                                                                       */
/* If a segment's idOffset is 0, the glyph index corresponding to any    */
/* charcode within the segment is obtained by adding the value of        */
/* `idDelta' directly to the charcode, modulo 65536.                     */
/*                                                                       */
/* Otherwise, a glyph index is taken from the glyph IDs sub-array for    */
/* the segment, and the value of `idDelta' is added to it.               */
/*                                                                       */
/*                                                                       */
/* Finally, note that a lot of fonts contain an invalid last segment,    */
/* where `start' and `end' are correctly set to 0xFFFF but both `delta'  */
/* and `offset' are incorrect (e.g., `opens___.ttf' which comes with     */
/* OpenOffice.org).  We need special code to deal with them correctly.   */
/*                                                                       */
/* current charcode */
/* current glyph index */
/* some fonts have an incorrect last segment; */
/* we have to catch it                        */
/* we skip empty segments */
/* search the index of the charcode next to cmap->cur_charcode; */
/* caller should call tt_cmap4_set_range with proper range      */
/* before calling this function                                 */
/*                                                              */
/* we need to find another range */
/* skip format */
/* in certain fonts, the `length' field is invalid and goes */
/* out of bound.  We try to correct this here...            */
/* read segCountX2 */
/* check that we have an even value here */
/* check the search parameters - even though we never use them */
/*                                                             */
/* check the values of `searchRange', `entrySelector', `rangeShift' */
/* must be even values */
/* `search range' is the greatest power of 2 that is <= num_segs */
/* check last segment; its end count value must be 0xFFFF */
/* this test should be performed at default validation level; */
/* unfortunately, some popular Asian fonts have overlapping   */
/* ranges in their charmaps                                   */
/*                                                            */
/* allow overlapping segments, provided their start points */
/* and end points, respectively, are in ascending order    */
/*                                                         */
/* start of glyph ID array */
/* check that we point within the glyph IDs table only */
/* Some fonts handle the last segment incorrectly.  In */
/* theory, 0xFFFF might point to an ordinary glyph --  */
/* a cmap 4 is versatile and could be used for any     */
/* encoding, not only Unicode.  However, reality shows */
/* that far too many fonts are sloppy and incorrectly  */
/* set all fields but `start' and `end' for the last   */
/* segment if it contains only a single character.     */
/*                                                     */
/* We thus omit the test here, delaying it to the      */
/* routines which actually access the cmap.            */
/* check glyph indices within the segment range */
/* some fonts (erroneously?) use a range offset of 0xFFFF */
/* to mean missing glyph in cmap table                    */
/*                                                        */
/* linear search */
/* ends table   */
/* starts table */
/* some fonts have an incorrect last segment; */
/* we have to catch it                        */
/* make compiler happy */
/* binary search */
/* some fonts have an incorrect last segment; */
/* we have to catch it                        */
/* search the first segment containing `charcode' */
/* call the current segment `max' */
/* search in segments before the current segment */
/* no luck */
/* search in segments after the current segment */
/* still no luck */
/* end, start, delta, and offset are for the i'th segment */
/* if `charcode' is not in any segment, then `mid' is */
/* the segment nearest to `charcode'                  */
/*                                                    */
/* no need to search */
/* TT_CONFIG_CMAP_FORMAT_4 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          FORMAT 6                             *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* TABLE OVERVIEW                                                        */
/* --------------                                                        */
/*                                                                       */
/*   NAME        OFFSET          TYPE             DESCRIPTION            */
/*                                                                       */
/*   format       0              USHORT           must be 4              */
/*   length       2              USHORT           table length in bytes  */
/*   language     4              USHORT           Mac language code      */
/*                                                                       */
/*   first        6              USHORT           first segment code     */
/*   count        8              USHORT           segment size in chars  */
/*   glyphIds     10             USHORT[count]    glyph IDs              */
/*                                                                       */
/* A very simplified segment mapping.                                    */
/*                                                                       */
/* skip language and start index */
/* check glyph indices */
/* TT_CONFIG_CMAP_FORMAT_6 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          FORMAT 8                             *****/
/*****                                                               *****/
/***** It is hard to completely understand what the OpenType spec    *****/
/***** says about this format, but here is my conclusion.            *****/
/*****                                                               *****/
/***** The purpose of this format is to easily map UTF-16 text to    *****/
/***** glyph indices.  Basically, the `char_code' must be in one of  *****/
/***** the following formats:                                        *****/
/*****                                                               *****/
/*****   - A 16-bit value that isn't part of the Unicode Surrogates  *****/
/*****     Area (i.e. U+D800-U+DFFF).                                *****/
/*****                                                               *****/
/*****   - A 32-bit value, made of two surrogate values, i.e.. if    *****/
/*****     `char_code = (char_hi << 16) | char_lo', then both        *****/
/*****     `char_hi' and `char_lo' must be in the Surrogates Area.   *****/
/*****      Area.                                                    *****/
/*****                                                               *****/
/***** The `is32' table embedded in the charmap indicates whether a  *****/
/***** given 16-bit value is in the surrogates area or not.          *****/
/*****                                                               *****/
/***** So, for any given `char_code', we can assert the following:   *****/
/*****                                                               *****/
/*****   If `char_hi == 0' then we must have `is32[char_lo] == 0'.   *****/
/*****                                                               *****/
/*****   If `char_hi != 0' then we must have both                    *****/
/*****   `is32[char_hi] != 0' and `is32[char_lo] != 0'.              *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* TABLE OVERVIEW                                                        */
/* --------------                                                        */
/*                                                                       */
/*   NAME        OFFSET         TYPE        DESCRIPTION                  */
/*                                                                       */
/*   format      0              USHORT      must be 8                    */
/*   reserved    2              USHORT      reserved                     */
/*   length      4              ULONG       length in bytes              */
/*   language    8              ULONG       Mac language code            */
/*   is32        12             BYTE[8192]  32-bitness bitmap            */
/*   count       8204           ULONG       number of groups             */
/*                                                                       */
/* This header is followed by `count' groups of the following format:    */
/*                                                                       */
/*   start       0              ULONG       first charcode               */
/*   end         4              ULONG       last charcode                */
/*   startId     8              ULONG       start glyph ID for the group */
/*                                                                       */
/* skip `is32' array */
/* p + num_groups * 12 > valid->limit ? */
/* check groups, they must be in increasing order */
/* start_id + end - start >= TT_VALID_GLYPH_COUNT( valid ) ? */
/* start_hi != 0; check that is32[i] is 1 for each i in */
/* the `hi' and `lo' of the range [start..end]          */
/* start_hi == 0; check that is32[i] is 0 for each i in */
/* the range [start..end]                               */
/* end_hi cannot be != 0! */
/* TT_CONFIG_CMAP_FORMAT_8 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          FORMAT 10                            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* TABLE OVERVIEW                                                        */
/* --------------                                                        */
/*                                                                       */
/*   NAME      OFFSET  TYPE               DESCRIPTION                    */
/*                                                                       */
/*   format     0      USHORT             must be 10                     */
/*   reserved   2      USHORT             reserved                       */
/*   length     4      ULONG              length in bytes                */
/*   language   8      ULONG              Mac language code              */
/*                                                                       */
/*   start     12      ULONG              first char in range            */
/*   count     16      ULONG              number of chars in range       */
/*   glyphIds  20      USHORT[count]      glyph indices covered          */
/*                                                                       */
/* length < 20 + count * 2 ? */
/* check glyph indices */
/* TT_CONFIG_CMAP_FORMAT_10 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          FORMAT 12                            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* TABLE OVERVIEW                                                        */
/* --------------                                                        */
/*                                                                       */
/*   NAME        OFFSET     TYPE       DESCRIPTION                       */
/*                                                                       */
/*   format      0          USHORT     must be 12                        */
/*   reserved    2          USHORT     reserved                          */
/*   length      4          ULONG      length in bytes                   */
/*   language    8          ULONG      Mac language code                 */
/*   count       12         ULONG      number of groups                  */
/*               16                                                      */
/*                                                                       */
/* This header is followed by `count' groups of the following format:    */
/*                                                                       */
/*   start       0          ULONG      first charcode                    */
/*   end         4          ULONG      last charcode                     */
/*   startId     8          ULONG      start glyph ID for the group      */
/*                                                                       */
/* length < 16 + 12 * num_groups ? */
/* check groups, they must be in increasing order */
/* start_id + end - start >= TT_VALID_GLYPH_COUNT( valid ) ? */
/* search the index of the charcode next to cmap->cur_charcode */
/* cmap->cur_group should be set up properly by caller         */
/*                                                             */
/* make compiler happy */
/* binary search */
/* if `char_code' is not in any group, then `mid' is */
/* the group nearest to `char_code'                  */
/*                                                   */
/* no need to search */
/* XXX: check cur_charcode overflow is expected */
/* XXX: check gindex overflow is expected */
/* TT_CONFIG_CMAP_FORMAT_12 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          FORMAT 13                            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* TABLE OVERVIEW                                                        */
/* --------------                                                        */
/*                                                                       */
/*   NAME        OFFSET     TYPE       DESCRIPTION                       */
/*                                                                       */
/*   format      0          USHORT     must be 13                        */
/*   reserved    2          USHORT     reserved                          */
/*   length      4          ULONG      length in bytes                   */
/*   language    8          ULONG      Mac language code                 */
/*   count       12         ULONG      number of groups                  */
/*               16                                                      */
/*                                                                       */
/* This header is followed by `count' groups of the following format:    */
/*                                                                       */
/*   start       0          ULONG      first charcode                    */
/*   end         4          ULONG      last charcode                     */
/*   glyphId     8          ULONG      glyph ID for the whole group      */
/*                                                                       */
/* length < 16 + 12 * num_groups ? */
/* check groups, they must be in increasing order */
/* search the index of the charcode next to cmap->cur_charcode */
/* cmap->cur_group should be set up properly by caller         */
/*                                                             */
/* make compiler happy */
/* binary search */
/* if `char_code' is not in any group, then `mid' is */
/* the group nearest to `char_code'                  */
/* no need to search */
/* TT_CONFIG_CMAP_FORMAT_13 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                           FORMAT 14                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* TABLE OVERVIEW                                                        */
/* --------------                                                        */
/*                                                                       */
/*   NAME         OFFSET  TYPE    DESCRIPTION                            */
/*                                                                       */
/*   format         0     USHORT  must be 14                             */
/*   length         2     ULONG   table length in bytes                  */
/*   numSelector    6     ULONG   number of variation sel. records       */
/*                                                                       */
/* Followed by numSelector records, each of which looks like             */
/*                                                                       */
/*   varSelector    0     UINT24  Unicode codepoint of sel.              */
/*   defaultOff     3     ULONG   offset to a default UVS table          */
/*                                describing any variants to be found in */
/*                                the normal Unicode subtable.           */
/*   nonDefOff      7     ULONG   offset to a non-default UVS table      */
/*                                describing any variants not in the     */
/*                                standard cmap, with GIDs here          */
/* (either offset may be 0 NULL)                                         */
/*                                                                       */
/* Selectors are sorted by code point.                                   */
/*                                                                       */
/* A default Unicode Variation Selector (UVS) subtable is just a list of */
/* ranges of code points which are to be found in the standard cmap.  No */
/* glyph IDs (GIDs) here.                                                */
/*                                                                       */
/*   numRanges      0     ULONG   number of ranges following             */
/*                                                                       */
/* A range looks like                                                    */
/*                                                                       */
/*   uniStart       0     UINT24  code point of the first character in   */
/*                                this range                             */
/*   additionalCnt  3     UBYTE   count of additional characters in this */
/*                                range (zero means a range of a single  */
/*                                character)                             */
/*                                                                       */
/* Ranges are sorted by `uniStart'.                                      */
/*                                                                       */
/* A non-default Unicode Variation Selector (UVS) subtable is a list of  */
/* mappings from codepoint to GID.                                       */
/*                                                                       */
/*   numMappings    0     ULONG   number of mappings                     */
/*                                                                       */
/* A range looks like                                                    */
/*                                                                       */
/*   uniStart       0     UINT24  code point of the first character in   */
/*                                this range                             */
/*   GID            3     USHORT  and its GID                            */
/*                                                                       */
/* Ranges are sorted by `uniStart'.                                      */
/* This array is used to store the results of various
/* length < 10 + 11 * num_selectors ? */
/* check selectors, they must be in increasing order */
/* we start lastVarSel at 1 because a variant selector value of 0
/* check the default table (these glyphs should be reached     */
/* through the normal Unicode cmap, no GIDs, just check order) */
/* defp + numRanges * 4 > valid->limit ? */
/* end of Unicode */
/* and the non-default table (these glyphs are specified here) */
/* numMappings * 4 > (FT_ULong)( valid->limit - ndp ) ? */
/* end of Unicode */
/* This can't happen */
/* This can't happen */
/* subtable 14 does not define a language field */
/* binary search */
/* binary search */
/* binary search */
/* This is the default variant of this charcode.  GID not stored */
/* here; stored in the normal Unicode charmap instead.           */
/* point to the first `cnt' field */
/* Both a default and a non-default glyph set?  That's probably not */
/* good font design, but the spec allows for it...                  */
/* If it is within the default range then ignore it -- */
/* that should not have happened                       */
/* If we get here then we have run out of all default ranges.   */
/* We have read one non-default mapping which we haven't stored */
/* and there may be others that need to be read.                */
/* If we get here then we have run out of all non-default     */
/* mappings.  We have read one default range which we haven't */
/* stored and there may be others that need to be read.       */
/* Format 14 extension functions */
/* TT_CONFIG_CMAP_FORMAT_14 */
/*FT_CONFIG_OPTION_PIC*/
/* allocate enough space for both the pointers */
/* plus terminator and the class instances     */
/* the location of the class instances follows the array of pointers */
/*FT_CONFIG_OPTION_PIC*/
/* parse the `cmap' table and build the corresponding TT_CMap objects */
/* in the current face                                                */
/*                                                                    */
/* only recognize format 0 */
/* will be filled later */
/* validate this cmap sub-table */
/* It might make sense to store the single variation         */
/* selector cmap somewhere special.  But it would have to be */
/* in the public FT_FaceRec, and we can't change that.       */
/* it is simpler to directly set `flags' than adding */
/* a parameter to FT_CMap_New                        */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\sfnt\ttkern.c
/***************************************************************************/
/*                                                                         */
/*  ttkern.c                                                               */
/*                                                                         */
/*    Load the basic TrueType kerning table.  This doesn't handle          */
/*    kerning data within the GPOS table at the moment.                    */
/*                                                                         */
/*  Copyright 1996-2007, 2009, 2010, 2013 by                               */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* the kern table is optional; exit silently if it is missing */
/* the case of a malformed table */
/* skip version */
/* we only support up to 32 sub-tables */
/* skip version */
/* handle broken table */
/* only use horizontal kerning tables */
/* handle broken count */
/*
/* handle broken table */
/* handle broken count  */
/* binary search */
/* linear search */
/*
/* override or add */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\sfnt\ttload.c
/***************************************************************************/
/*                                                                         */
/*  ttload.c                                                               */
/*                                                                         */
/*    Load the basic TrueType tables, i.e., tables that can be either in   */
/*    TTF or OTF fonts (body).                                             */
/*                                                                         */
/*  Copyright 1996-2010, 2012-2014 by                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_lookup_table                                               */
/*                                                                       */
/* <Description>                                                         */
/*    Looks for a TrueType table by name.                                */
/*                                                                       */
/* <Input>                                                               */
/*    face :: A face object handle.                                      */
/*                                                                       */
/*    tag  :: The searched tag.                                          */
/*                                                                       */
/* <Return>                                                              */
/*    A pointer to the table directory entry.  0 if not found.           */
/*                                                                       */
/* For compatibility with Windows, we consider    */
/* zero-length tables the same as missing tables. */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_goto_table                                                 */
/*                                                                       */
/* <Description>                                                         */
/*    Looks for a TrueType table by name, then seek a stream to it.      */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: A face object handle.                                    */
/*                                                                       */
/*    tag    :: The searched tag.                                        */
/*                                                                       */
/*    stream :: The stream to seek when the table is found.              */
/*                                                                       */
/* <Output>                                                              */
/*    length :: The length of the table if found, undefined otherwise.   */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* Here, we                                                         */
/*                                                                  */
/* - check that `num_tables' is valid (and adjust it if necessary)  */
/*                                                                  */
/* - look for a `head' table, check its size, and parse it to check */
/*   whether its `magic' field is correctly set                     */
/*                                                                  */
/* - errors (except errors returned by stream handling)             */
/*                                                                  */
/*     SFNT_Err_Unknown_File_Format:                                */
/*       no table is defined in directory, it is not sfnt-wrapped   */
/*       data                                                       */
/*     SFNT_Err_Table_Missing:                                      */
/*       table directory is valid, but essential tables             */
/*       (head/bhed/SING) are missing                               */
/*                                                                  */
/* we ignore invalid tables */
/* table.Offset + table.Length > stream->size ? */
/*
/* if `sing' and `meta' tables are present, there is no `head' table */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_font_dir                                              */
/*                                                                       */
/* <Description>                                                         */
/*    Loads the header of a SFNT font file.                              */
/*                                                                       */
/* <Input>                                                               */
/*    face       :: A handle to the target face object.                  */
/*                                                                       */
/*    stream     :: The input stream.                                    */
/*                                                                       */
/* <Output>                                                              */
/*    sfnt       :: The SFNT header.                                     */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* <Note>                                                                */
/*    The stream cursor must be at the beginning of the font directory.  */
/*                                                                       */
/* read the offset table */
/* many fonts don't have these fields set correctly */
/* load the table directory */
/* check first */
/* ignore invalid tables */
/* entry->Offset + entry->Length > stream->size ? */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_any                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Loads any font table into client memory.                           */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: The face object to look for.                             */
/*                                                                       */
/*    tag    :: The tag of table to load.  Use the value 0 if you want   */
/*              to access the whole font file, else set this parameter   */
/*              to a valid TrueType table tag that you can forge with    */
/*              the MAKE_TT_TAG macro.                                   */
/*                                                                       */
/*    offset :: The starting offset in the table (or the file if         */
/*              tag == 0).                                               */
/*                                                                       */
/*    length :: The address of the decision variable:                    */
/*                                                                       */
/*                If length == NULL:                                     */
/*                  Loads the whole table.  Returns an error if          */
/*                  `offset' == 0!                                       */
/*                                                                       */
/*                If *length == 0:                                       */
/*                  Exits immediately; returning the length of the given */
/*                  table or of the font file, depending on the value of */
/*                  `tag'.                                               */
/*                                                                       */
/*                If *length != 0:                                       */
/*                  Loads the next `length' bytes of table or font,      */
/*                  starting at offset `offset' (in table or font too).  */
/*                                                                       */
/* <Output>                                                              */
/*    buffer :: The address of target buffer.                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* look for tag in font directory */
/* tag == 0 -- the user wants to access the font file directly */
/* the `if' is syntactic sugar for picky compilers */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_generic_header                                        */
/*                                                                       */
/* <Description>                                                         */
/*    Loads the TrueType table `head' or `bhed'.                         */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/*    stream :: The input stream.                                        */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_max_profile                                           */
/*                                                                       */
/* <Description>                                                         */
/*    Loads the maximum profile into a face object.                      */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/*    stream :: The input stream.                                        */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* XXX: an adjustment that is necessary to load certain */
/*      broken fonts like `Keystrokes MT' :-(           */
/*                                                      */
/*   We allocate 64 function entries by default when    */
/*   the maxFunctionDefs value is smaller.              */
/* we add 4 phantom points later */
/* we arbitrarily limit recursion to avoid stack exhaustion */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_name                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Loads the name records.                                            */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/*    stream :: The input stream.                                        */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* no FT_FRAME_START */
/* Some popular Asian fonts have an invalid `storageOffset' value   */
/* (it should be at least "6 + 12*num_names").  However, the string */
/* offsets, computed as "storageOffset + entry->stringOffset", are  */
/* valid pointers within the name table...                          */
/*                                                                  */
/* We thus can't check `storageOffset' right now.                   */
/*                                                                  */
/* Allocate the array of name records. */
/* Load the name records and determine how much storage is needed */
/* to hold the strings themselves.                                */
/* check that the name is not empty */
/* check that the name string is within the table */
/* invalid entry - ignore it */
/* everything went well, update face->num_names */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_free_names                                                 */
/*                                                                       */
/* <Description>                                                         */
/*    Frees the name records.                                            */
/*                                                                       */
/* <Input>                                                               */
/*    face :: A handle to the target face object.                        */
/*                                                                       */
/* free strings table */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_cmap                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Loads the cmap directory in a face object.  The cmaps themselves   */
/*    are loaded on demand in the `ttcmap.c' module.                     */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/*    stream :: A handle to the input stream.                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_os2                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Loads the OS2 table.                                               */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/*    stream :: A handle to the input stream.                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* `OS/2' version 1 and newer */
/* `OS/2' version 2 and newer */
/* `OS/2' version 5 and newer */
/* We now support old Mac fonts where the OS/2 table doesn't  */
/* exist.  Simply put, we set the `version' field to 0xFFFF   */
/* and test this value each time we need to access the table. */
/* only version 1 tables */
/* only version 2 tables */
/* only version 5 tables */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_postscript                                            */
/*                                                                       */
/* <Description>                                                         */
/*    Loads the Postscript table.                                        */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/*    stream :: A handle to the input stream.                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* we don't load the glyph names, we do that in another */
/* module (ttpost).                                     */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_pclt                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Loads the PCL 5 Table.                                             */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/*    stream :: A handle to the input stream.                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* optional table */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_gasp                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Loads the `gasp' table into a face object.                         */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/*    stream :: The input stream.                                        */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* the gasp table is optional */
/* only support versions 0 and 1 of the table */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\sfnt\ttmtx.c
/***************************************************************************/
/*                                                                         */
/*  ttmtx.c                                                                */
/*                                                                         */
/*    Load the metrics tables common to TTF and OTF fonts (body).          */
/*                                                                         */
/*  Copyright 2006-2009, 2011-2014 by                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_hmtx                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Load the `hmtx' or `vmtx' table into a face object.                */
/*                                                                       */
/* <Input>                                                               */
/*    face     :: A handle to the target face object.                    */
/*                                                                       */
/*    stream   :: The input stream.                                      */
/*                                                                       */
/*    vertical :: A boolean flag.  If set, load `vmtx'.                  */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_hhea                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Load the `hhea' or 'vhea' table into a face object.                */
/*                                                                       */
/* <Input>                                                               */
/*    face     :: A handle to the target face object.                    */
/*                                                                       */
/*    stream   :: The input stream.                                      */
/*                                                                       */
/*    vertical :: A boolean flag.  If set, load `vhea'.                  */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_get_metrics                                                */
/*                                                                       */
/* <Description>                                                         */
/*    Return the horizontal or vertical metrics in font units for a      */
/*    given glyph.  The values are the left side bearing (top side       */
/*    bearing for vertical metrics) and advance width (advance height    */
/*    for vertical metrics).                                             */
/*                                                                       */
/* <Input>                                                               */
/*    face     :: A pointer to the TrueType face structure.              */
/*                                                                       */
/*    vertical :: If set to TRUE, get vertical metrics.                  */
/*                                                                       */
/*    gindex   :: The glyph index.                                       */
/*                                                                       */
/* <Output>                                                              */
/*    abearing :: The bearing, either left side or top side.             */
/*                                                                       */
/*    aadvance :: The advance width or advance height, depending on      */
/*                the `vertical' flag.                                   */
/*                                                                       */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\sfnt\ttpost.c
/***************************************************************************/
/*                                                                         */
/*  ttpost.c                                                               */
/*                                                                         */
/*    Postcript name table processing for TrueType and OpenType fonts      */
/*    (body).                                                              */
/*                                                                         */
/*  Copyright 1996-2003, 2006-2010, 2013, 2014 by                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The post table is not completely loaded by the core engine.  This     */
/* file loads the missing PS glyph names and implements an API to access */
/* them.                                                                 */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* If this configuration macro is defined, we rely on the `PSNames' */
/* module to grab the glyph names.                                  */
/* FT_CONFIG_OPTION_POSTSCRIPT_NAMES */
/* Otherwise, we ignore the `PSNames' module, and provide our own  */
/* table of Mac names.  Thus, it is possible to build a version of */
/* FreeType without the Type 1 driver & PSNames module.            */
/* the 258 default Mac PS glyph names; see file `tools/glnames.py' */
/*   0 */
/*  10 */
/*  20 */
/*  30 */
/*  40 */
/*  50 */
/*  60 */
/*  70 */
/*  80 */
/*  90 */
/* 100 */
/* 110 */
/* 120 */
/* 130 */
/* 140 */
/* 150 */
/* 160 */
/* 170 */
/* 180 */
/* 190 */
/* 200 */
/* 210 */
/* 220 */
/* 230 */
/* 240 */
/* 250 */
/* FT_CONFIG_OPTION_POSTSCRIPT_NAMES */
/* UNDOCUMENTED!  The number of glyphs in this table can be smaller */
/* than the value in the maxp table (cf. cyberbit.ttf).             */
/* There already exist fonts which have more than 32768 glyph names */
/* in this table, so the test for this threshold has been dropped.  */
/* load the indices */
/* compute number of names stored in table */
/* now load the name strings */
/* all right, set table fields and exit successfully */
/* UNDOCUMENTED!  This value appears only in the Apple TT specs. */
/* check the number of glyphs */
/* now check the offset table */
/* OK, set table fields and exit successfully */
/* get a stream for the face's resource */
/* seek to the beginning of the PS names table */
/* go to beginning of subtable */
/* now read postscript table */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_get_ps_name                                                */
/*                                                                       */
/* <Description>                                                         */
/*    Get the PostScript glyph name of a glyph.                          */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: A handle to the parent face.                             */
/*                                                                       */
/*    idx    :: The glyph index.                                         */
/*                                                                       */
/* <InOut>                                                               */
/*    PSname :: The address of a string pointer.  Will be NULL in case   */
/*              of error, otherwise it is a pointer to the glyph name.   */
/*                                                                       */
/*              You must not modify the returned string!                 */
/*                                                                       */
/* <Output>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* `.notdef' by default */
/* paranoid checking */
/* paranoid checking */
/* nothing to do for format == 0x00030000L */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\sfnt\ttsbit.c
/***************************************************************************/
/*                                                                         */
/*  ttsbit.c                                                               */
/*                                                                         */
/*    TrueType and OpenType embedded bitmap support (body).                */
/*                                                                         */
/*  Copyright 2005-2009, 2013, 2014 by                                     */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  Copyright 2013 by Google, Inc.                                         */
/*  Google Author(s): Behdad Esfahbod.                                     */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*
/* Bit 0 must always be `1'.                            */
/* Bit 1 controls the overlay of bitmaps with outlines. */
/* All other bits should be zero.                       */
/* we currently don't support bit 1; however, it is better to */
/* draw at least something...                                 */
/*
/* hori.ascender  */
/* hori.descender */
/* Is this correct? */
/* min_origin_SB  */
/* max_width      */
/* min_advance_SB */
/* What to do with this? */
/* now find the strike corresponding to the index */
/* decoder->strike_index_array +                               */
/*   8 * decoder->strike_index_count > face->sbit_table_size ? */
/* check that there is no empty image */
/* exit successfully! */
/* avoid uninitialized data in case there is no vertical info -- */
/* forward declaration */
/* check that we can write the glyph into the bitmap */
/* now do the blit */
/* the easy one */
/* x_pos > 0 */
/* all bits read and there are `x_pos + w' bits to be written */
/*
/* check that we can write the glyph into the bitmap */
/* now do the blit */
/* adjust `line' to point to the first byte of the bitmap */
/* the higher byte of `rval' is used as a buffer */
/* handle initial byte (in target bitmap) specially if necessary */
/* handle medial bytes */
/* handle final byte if necessary */
/* NB: a recursive call */
/* FT_CONFIG_OPTION_USE_PNG */
/* seek into the EBDT table now */
/* read the data, depending on the glyph format */
/* Don't trust `glyph_format'.  For example, Apple's main Korean */
/* system font, `AppleMyungJo.ttf' (version 7.0d2e6), uses glyph */
/* format 7, but the data is format 6.  We check whether we have */
/* an excessive number of bytes in the image: If it is equal to  */
/* the value for a byte-aligned glyph, use the other loading     */
/* routine.                                                      */
/*                                                               */
/* Note that for some (width,height) combinations, where the     */
/* width is not a multiple of 8, the sizes for bit- and          */
/* byte-aligned data are equal, for example (7,7) or (15,6).  We */
/* then prefer what `glyph_format' specifies.                    */
/* skip padding */
/* fall-through */
/* small metrics, PNG image data   */
/* big metrics, PNG image data     */
/* metrics in EBLC, PNG image data */
/* FT_CONFIG_OPTION_USE_PNG */
/*
/* ignore index offset */
/* overflow check */
/* now find the glyph's location and extend within the ebdt table */
/* 4-byte offsets relative to `image_offset' */
/* missing glyph */
/* big metrics, constant image size */
/* 2-byte offsets relative to 'image_offset' */
/* missing glyph */
/* sparse glyph array with (glyph,offset) pairs */
/* overflow check for p + ( num_glyphs + 1 ) * 4 */
/* constant metrics with sparse glyph codes */
/* overflow check for p + 2 * num_glyphs */
/* used on iOS 7.1 */
/* Flatten color bitmaps if color was not requested. */
/* Convert to 8bit grayscale. */
/* EOF */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\smooth\ftgrays.c
/***************************************************************************/
/*                                                                         */
/*  ftgrays.c                                                              */
/*                                                                         */
/*    A new `perfect' anti-aliasing renderer (body).                       */
/*                                                                         */
/*  Copyright 2000-2003, 2005-2014 by                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* This file can be compiled without the rest of the FreeType engine, by */
/* defining the _STANDALONE_ macro when compiling it.  You also need to  */
/* put the files `ftgrays.h' and `ftimage.h' into the current            */
/* compilation directory.  Typically, you could do something like        */
/*                                                                       */
/* - copy `src/smooth/ftgrays.c' (this file) to your current directory   */
/*                                                                       */
/* - copy `include/ftimage.h' and `src/smooth/ftgrays.h' to the same     */
/*   directory                                                           */
/*                                                                       */
/* - compile `ftgrays' with the _STANDALONE_ macro defined, as in        */
/*                                                                       */
/*     cc -c -D_STANDALONE_ ftgrays.c                                    */
/*                                                                       */
/* The renderer can be initialized with a call to                        */
/* `ft_gray_raster.raster_new'; an anti-aliased bitmap can be generated  */
/* with a call to `ft_gray_raster.raster_render'.                        */
/*                                                                       */
/* See the comments and documentation in the file `ftimage.h' for more   */
/* details on how the raster works.                                      */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* This is a new anti-aliasing scan-converter for FreeType 2.  The       */
/* algorithm used here is _very_ different from the one in the standard  */
/* `ftraster' module.  Actually, `ftgrays' computes the _exact_          */
/* coverage of the outline on each pixel cell.                           */
/*                                                                       */
/* It is based on ideas that I initially found in Raph Levien's          */
//www.levien.com/libart   */
/* excellent LibArt graphics library (see http://www.levien.com/libart   */
/* for more information, though the web pages do not tell anything       */
/* about the renderer; you'll have to dive into the source code to       */
/* understand how it works).                                             */
/*                                                                       */
/* Note, however, that this is a _very_ different implementation         */
/* compared to Raph's.  Coverage information is stored in a very         */
/* different way, and I don't use sorted vector paths.  Also, it doesn't */
/* use floating point values.                                            */
/*                                                                       */
/* This renderer has the following advantages:                           */
/*                                                                       */
/* - It doesn't need an intermediate bitmap.  Instead, one can supply a  */
/*   callback function that will be called by the renderer to draw gray  */
/*   spans on any target surface.  You can thus do direct composition on */
/*   any kind of bitmap, provided that you give the renderer the right   */
/*   callback.                                                           */
/*                                                                       */
/* - A perfect anti-aliaser, i.e., it computes the _exact_ coverage on   */
/*   each pixel cell.                                                    */
/*                                                                       */
/* - It performs a single pass on the outline (the `standard' FT2        */
/*   renderer makes two passes).                                         */
/*                                                                       */
/* - It can easily be modified to render to _any_ number of gray levels  */
/*   cheaply.                                                            */
/*                                                                       */
/* - For small (< 20) pixel sizes, it is faster than the standard        */
/*   renderer.                                                           */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* Auxiliary macros for token concatenation. */
/* define this to dump debugging information */
/* #define FT_DEBUG_LEVEL_TRACE */
/* This macro is used to indicate that a function parameter is unused. */
/* Its purpose is simply to reduce compiler warnings.  Note also that  */
/* simply defining it as `(void)x' doesn't avoid warnings with certain */
/* ANSI compilers (e.g. LCC).                                          */
/* we only use level 5 & 7 tracing messages; cf. ftdebug.h */
/* empty function useful for setting a breakpoint to catch errors */
/* we don't handle tracing levels in stand-alone mode; */
/* !FT_DEBUG_LEVEL_TRACE */
/* nothing */
/* nothing */
/* nothing */
/* !FT_DEBUG_LEVEL_TRACE */
/* !_STANDALONE_ */
/* !_STANDALONE_ */
/* as usual, for the speed hungry :-) */
/* FT_STATIC_RASTER */
/* empty */
/* empty */
/* empty */
/* empty */
/* FT_STATIC_RASTER */
/* must be at least 6 bits! */
/* Compute `dividend / divisor' and return both its quotient and     */
/* remainder, cast to a specific type.  This macro also ensures that */
/* the remainder is always positive.                                 */
/* Work around a bug specific to GCC which make the compiler fail to */
/* optimize a division and modulo operation on the same parameters   */
/* into a single call to `__aeabi_idivmod'.  See                     */
/*                                                                   */
//gcc.gnu.org/bugzilla/show_bug.cgi?id=43721                */
/*  http://gcc.gnu.org/bugzilla/show_bug.cgi?id=43721                */
/* __arm__ */
/*************************************************************************/
/*                                                                       */
/*   TYPE DEFINITIONS                                                    */
/*                                                                       */
/* don't change the following types to FT_Int or FT_Pos, since we might */
/* need to define them to "float" or "double" when experimenting with   */
/* new algorithms                                                       */
/* integer scanline/pixel coordinate */
/* sub-pixel coordinate              */
/* determine the type used to store cell areas.  This normally takes at */
/* least PIXEL_BITS*2 + 1 bits.  On 16-bit systems, we need to use      */
/* `long' instead of `int', otherwise bad things happen                 */
/* PIXEL_BITS >= 8 */
/* approximately determine the size of integers using an ANSI-C header */
/* PIXEL_BITS >= 8 */
/* maximum number of gray spans in a call to the span callback */
/* same with gray_TWorker.ex    */
/* same with gray_TWorker.cover */
/* Visual C++ (and Intel C++) */
/* We disable the warning `structure was padded due to   */
/* __declspec(align())' in order to compile cleanly with */
/* the maximum level of warnings.                        */
/* _MSC_VER */
/*************************************************************************/
/*                                                                       */
/* Initialize the cells table.                                           */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* Compute the outline bounding box.                                     */
/*                                                                       */
/* truncate the bounding box to integer pixels */
/*************************************************************************/
/*                                                                       */
/* Record the current cell in the table.                                 */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* Set the current cell to a new position.                               */
/*                                                                       */
/* Move the cell pointer to a new position.  We set the `invalid'      */
/* flag to indicate that the cell isn't part of those we're interested */
/* in during the render phase.  This means that:                       */
/*                                                                     */
/* . the new vertical position must be within min_ey..max_ey-1.        */
/* . the new horizontal position must be strictly less than max_ex     */
/*                                                                     */
/* Note that if a cell is to the left of the clipping region, it is    */
/* actually set to the (min_ex-1) horizontal position.                 */
/* All cells that are on the left of the clipping region go to the */
/* min_ex - 1 horizontal position.                                 */
/* are we moving to a different cell ? */
/* record the current one if it is valid */
/*************************************************************************/
/*                                                                       */
/* Start a new contour at a given cell.                                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* Render a scanline as one or more cells.                               */
/*                                                                       */
/* trivial case.  Happens often */
/* everything is located in a single cell.  That is easy! */
/*                                                        */
/* ok, we'll have to render a run of adjacent cells on the same */
/* scanline...                                                  */
/*                                                              */
/*************************************************************************/
/*                                                                       */
/* Render a given line as a series of scanlines.                         */
/*                                                                       */
/* if (ey2 >= ras.max_ey) ey2 = ras.max_ey-1; */
/* perform vertical clipping */
/* everything is on a single scanline */
/* vertical line - avoid calling gray_render_scanline */
/* ok, we have to render several scanlines */
/* short-cut the arc that crosses the current band */
/* Short-cut the arc that crosses the current band. */
/* Decide whether to split or draw. See `Rapid Termination          */
/* Evaluation for Recursive Subdivision of Bezier Curves' by Thomas */
/* F. Hain, at                                                      */
//www.cis.southalabama.edu/~hain/general/Publications/Bezier/Camera-ready%20CISST02%202.pdf */
/* http://www.cis.southalabama.edu/~hain/general/Publications/Bezier/Camera-ready%20CISST02%202.pdf */
/* dx and dy are x and y components of the P0-P3 chord vector. */
/* Avoid possible arithmetic overflow below by splitting. */
/* Max deviation may be as much as (s/L) * 3/4 (if Hain's v = 1). */
/* s is L * the perpendicular distance from P1 to the line P0-P3. */
/* s is L * the perpendicular distance from P2 to the line P0-P3. */
/* Split super curvy segments where the off points are so far
/* No reason to split. */
/* record current cell, if any */
/* start to a new position */
/* first of all, compute the scanline offset */
/* For small-spans it is faster to do it by ourselves than
/* compute the coverage line's coverage, depending on the    */
/* outline fill rule                                         */
/*                                                           */
/* the coverage percentage is area/(PIXEL_BITS*PIXEL_BITS*2) */
/*                                                           */
/* use range 0..256 */
/* normal non-zero winding rule */
/* FT_Span.x is a 16-bit short, so limit our coordinates appropriately */
/* FT_Span.y is an integer, so limit our coordinates appropriately */
/* see whether we can add this span to the current list */
/* FT_DEBUG_LEVEL_TRACE */
/* add a gray span to the current list */
/* to be called while in the debugger --                                */
/* this function causes a compiler warning since it is unused otherwise */
/* FT_DEBUG_LEVEL_TRACE */
/* FT_DEBUG_LEVEL_TRACE */
/*************************************************************************/
/*                                                                       */
/*  The following function should only compile in stand-alone mode,      */
/*  i.e., when building this component without the rest of FreeType.     */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    FT_Outline_Decompose                                               */
/*                                                                       */
/* <Description>                                                         */
/*    Walk over an outline's structure to decompose it into individual   */
/*    segments and Bézier arcs.  This function is also able to emit      */
/*    `move to' and `close to' operations to indicate the start and end  */
/*    of new contours in the outline.                                    */
/*                                                                       */
/* <Input>                                                               */
/*    outline        :: A pointer to the source target.                  */
/*                                                                       */
/*    func_interface :: A table of `emitters', i.e., function pointers   */
/*                      called during decomposition to indicate path     */
/*                      operations.                                      */
/*                                                                       */
/* <InOut>                                                               */
/*    user           :: A typeless pointer which is passed to each       */
/*                      emitter during the decomposition.  It can be     */
/*                      used to store the state during the               */
/*                      decomposition.                                   */
/*                                                                       */
/* <Return>                                                              */
/*    Error code.  0 means success.                                      */
/*                                                                       */
/* index of contour in outline     */
/* index of first point in contour */
/* current point's state           */
/* index of last point in contour */
/* A contour cannot start with a cubic control point! */
/* check first point to determine origin */
/* first point is conic control.  Yes, this happens. */
/* start at last point if it is on the curve */
/* if both first and last points are conic,         */
/* start at their middle and record its position    */
/* for closure                                      */
/* emit a single line_to */
/* consume conic arcs */
/* FT_CURVE_TAG_CUBIC */
/* close the contour with a line segment */
/* _STANDALONE_ */
/* Set up state in the raster object */
/* clip to target bitmap, exit if nothing to do */
/* set up vertical bands */
/* render pool overflow; we will reduce the render band by half */
/* This is too complex for a single scanline; there must */
/* be some problems.                                     */
/* return immediately if the outline is empty */
/* if direct mode is not set, we must have a target bitmap */
/* nothing to do */
/* this version does not support monochrome rendering */
/* compute clipping box */
/* compute clip box from target pixmap */
/**** RASTER OBJECT CREATION: In stand-alone mode, we simply use *****/
/****                         a static object.                   *****/
/* nothing */
/* !_STANDALONE_ */
/* !_STANDALONE_ */
/* nothing to do */
/* END */
/* Local Variables: */
/* coding: utf-8    */
/* End:             */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\smooth\ftsmooth.c
/***************************************************************************/
/*                                                                         */
/*  ftsmooth.c                                                             */
/*                                                                         */
/*    Anti-aliasing renderer interface (body).                             */
/*                                                                         */
/*  Copyright 2000-2006, 2009-2013 by                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* initialize renderer -- init its raster */
/* sets render-specific mode */
/* we simply pass it to the raster */
/* transform a given glyph image */
/* return the glyph's control box */
/* convert a slot's glyph image into a bitmap */
/* check glyph image format */
/* check mode */
/* compute the control box, and grid fit it */
/* taking into account the origin shift     */
/*
/* Required check is (pitch * height < FT_ULONG_MAX),        */
/* but we care realistic cases only.  Always pitch <= width. */
/* release old bitmap buffer */
/* allocate new one */
/* translate outline to render it into the bitmap */
/* set up parameters */
/* implode outline if needed */
/* render outline into the bitmap */
/* deflate outline if needed */
/* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
/* render outline into bitmap */
/* expand it horizontally */
/* expand it vertically */
/* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
/* everything is fine; don't deallocate buffer */
/* convert a slot's glyph image into a bitmap */
/* convert a slot's glyph image into a horizontal LCD bitmap */
/* convert a slot's glyph image into a vertical LCD bitmap */
/* module specific interface */
/* module specific interface */
/* module specific interface */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\smooth\ftspic.c
/***************************************************************************/
/*                                                                         */
/*  ftspic.c                                                               */
/*                                                                         */
/*    The FreeType position independent code services for smooth module.   */
/*                                                                         */
/*  Copyright 2009, 2010, 2012, 2013 by                                    */
/*  Oran Agra and Mickey Gabel.                                            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* forward declaration of PIC init functions from ftgrays.c */
/* since this function also serve smooth_lcd and smooth_lcdv renderers,
/* allocate pointer, clear and set global container pointer */
/* initialize pointer table -                       */
/* this is how the module usually expects this data */
/* re-route these init and free functions to the above functions */
/* FT_CONFIG_OPTION_PIC */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\smooth\smooth.c
/***************************************************************************/
/*                                                                         */
/*  smooth.c                                                               */
/*                                                                         */
/*    FreeType anti-aliasing rasterer module component (body only).        */
/*                                                                         */
/*  Copyright 1996-2001 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\tools\apinames.c
/*
/* output the list of names, one per line             */
/* output a Windows .DEF file for Visual C++ or Mingw */
/* output a Windows .DEF file for Borland C++         */
/* output a Watcom Linker Command File                */
/* output a NetWare ImportFile                        */
/* compute hash value */
/* check for an pre-existing name */
/* add new name */
/* we must omit the .dll suffix from the library name */
/* LIST */
/* states of the line parser */
/* waiting for FT_EXPORT keyword and return type */
/* type was read, waiting for function name      */
/* skip leading whitespace */
/* skip empty lines */
/* sometimes, the name is just after the FT_EXPORT(...), so
/* fall-through */
/* the default */
/* '-' used as a single argument means read source file from stdin */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\tools\chktrcmp.py
#!/usr/bin/env python
#
# Check trace components in FreeType 2 source.
# Author: suzuki toshiya, 2009, 2013
#
# This code is explicitly into the public domain.
# --------------------------------------------------------------
# Parse command line options
#
# --------------------------------------------------------------
# Scan C source and header files using trace macros.
#
#define[ \t]+FT_COMPONENT[ \t]+trace_' )
# --------------------------------------------------------------
# Scan header file(s) defining trace macros.
#
# --------------------------------------------------------------
# Compare the used and defined trace macros.
#
# Trace component used in the implementations but not defined in fttrace.h."
# Trace component is defined but not used in the implementations."
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\tools\cordic.py
# compute arctangent table for CORDIC computations in fttrigon.c
#units  = 64*65536.0   # don't change !!
# tangent value
# arctangent
# arctangent in FT_Angle units
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\tools\glnames.py
#!/usr/bin/env python
#
#
# FreeType 2 glyph name builder
#
# Copyright 1996-2000, 2003, 2005, 2007, 2008, 2011 by
# David Turner, Robert Wilhelm, and Werner Lemberg.
#
# This file is part of the FreeType project, and may only be used, modified,
# and distributed under the terms of the FreeType project license,
# LICENSE.TXT.  By continuing to use, modify, or distribute this file you
# indicate that you have read the license and understand and accept it
# fully.
# This table lists the glyphs according to the Macintosh specification.
# It is used by the TrueType Postscript names table.
#
# See
#
#   http://fonts.apple.com/TTRefMan/RM06/Chap6post.html
#
# for the official list.
#
# 0
# 10
# 20
# 30
# 40
# 50
# 60
# 70
# 80
# 90
# 100
# 110
# 120
# 130
# 140
# 150
# 160
# 170
# 180
# 190
# 200
# 210
# 220
# 230
# 240
# 250
# The list of standard `SID' glyph names.  For the official list,
# see Annex A of document at
#
#   http://partners.adobe.com/public/developer/en/font/5176.CFF.pdf  .
#
# 0
# 10
# 20
# 30
# 40
# 50
# 60
# 70
# 80
# 90
# 100
# 110
# 120
# 130
# 140
# 150
# 160
# 170
# 180
# 190
# 200
# 210
# 220
# 230
# 240
# 250
# 260
# 270
# 280
# 290
# 300
# 310
# 320
# 330
# 340
# 350
# 360
# 370
# 380
# 390
# This table maps character codes of the Adobe Standard Type 1
# encoding to glyph indices in the sid_standard_names table.
#
# This table maps character codes of the Adobe Expert Type 1
# encoding to glyph indices in the sid_standard_names table.
#
# This data has been taken literally from the files `glyphlist.txt'
# and `zapfdingbats.txt' version 2.0, Sept 2002.  It is available from
#
#   http://sourceforge.net/adobe/aglfn/
#
# string table management
#
#define " + macro_name + "  " + repr( len( sublist ) ) + "\n\n" )
# We now store the Adobe Glyph List in compressed form.  The list is put
# into a data structure called `trie' (because it has a tree-like
# appearance).  Consider, for example, that you want to store the
# following name mapping:
#
#   A        => 1
#   Aacute   => 6
#   Abalon   => 2
#   Abstract => 4
#
# It is possible to store the entries as follows.
#
#   A => 1
#   |
#   +-acute => 6
#   |
#   +-b
#     |
#     +-alon => 2
#     |
#     +-stract => 4
#
# We see that each node in the trie has:
#
# - one or more `letters'
# - an optional value
# - zero or more child nodes
#
# The first step is to call
#
#   root = StringNode( "", 0 )
#   for word in map.values():
#     root.add( word, map[word] )
#
# which creates a large trie where each node has only one children.
#
# Executing
#
#   root = root.optimize()
#
# optimizes the trie by merging the letters of successive nodes whenever
# possible.
#
# Each node of the trie is stored as follows.
#
# - First the node's letter, according to the following scheme.  We
#   use the fact that in the AGL no name contains character codes > 127.
#
#     name         bitsize     description
#     ----------------------------------------------------------------
#     notlast            1     Set to 1 if this is not the last letter
#                              in the word.
#     ascii              7     The letter's ASCII value.
#
# - The letter is followed by a children count and the value of the
#   current key (if any).  Again we can do some optimization because all
#   AGL entries are from the BMP; this means that 16 bits are sufficient
#   to store its Unicode values.  Additionally, no node has more than
#   127 children.
#
#     name         bitsize     description
#     -----------------------------------------
#     hasvalue           1     Set to 1 if a 16-bit Unicode value follows.
#     num_children       7     Number of children.  Can be 0 only if
#                              `hasvalue' is set to 1.
#     value             16     Optional Unicode value.
#
# - A node is finished by a list of 16bit absolute offsets to the
#   children, which must be sorted in increasing order of their first
#   letter.
#
# For simplicity, all 16bit quantities are stored in big-endian order.
#
# The root node has first letter = 0, and no value.
#
# optimize all children first
# don't optimize if there's a value,
# if we don't have any child or if we
# have more than one child
# this is used during debugging
# write the letters
# write the count
#     print fields[1] + ' - ' + fields[0]
# `mac_extras' contains the list of glyph names in the Macintosh standard
# encoding which are not in the SID Standard Names.
#
# `base_list' contains the names of our final glyph names table.
# It consists of the `mac_extras' glyph names, followed by the SID
# standard names.
#
# dump final glyph list (mac extras + sid standard names)
#
# dump the AGL in its compressed form
#
#ifdef FT_CONFIG_OPTION_ADOBE_GLYPH_LIST
# write the lookup routine now
#
#endif /* FT_CONFIG_OPTION_ADOBE_GLYPH_LIST */
# generate unit test, or don't
#
# now write the unit test to check that everything works OK
#
#ifdef TEST\n\n" )
#include <stdlib.h>
#include <stdio.h>
#endif /* TEST */\n" )
# Now run the main routine
#
# END
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\tools\test_afm.c
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\tools\test_bbox.c
/* for clock() */
/* SunOS 4.1.* does not define CLOCKS_PER_SEC, so include <sys/param.h> */
/* to get the HZ macro which is the equivalent.                         */
/* test bbox computations */
/* dummy outline #1 */
/* 408.9111, 535.3164 */
/* 455.8887, 634.3960 */
/* -37.8765, 786.2207 */
/* 164.6074, 535.3164 */
/* dummy outline #2 */
/* dummy outline #3 with bbox of [0 100 128 128] precisely */
/* compute and display cbox */
/* compute and display bbox */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\tools\test_trig.c
/* the precision in 16.16 fixed-point checks. Expect between 2 and 5 */
/* noise LSB bits during operations, due to rounding errors..        */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\tools\docmaker\content.py
#
#  content.py
#
#    Parse comment blocks to build content blocks (library file).
#
#  Copyright 2002, 2004, 2006-2009, 2012-2014 by
#  David Turner.
#
#  This file is part of the FreeType project, and may only be used,
#  modified, and distributed under the terms of the FreeType project
#  license, LICENSE.TXT.  By continuing to use, modify, or distribute
#  this file you indicate that you have read the license and
#  understand and accept it fully.
#
# This file contains routines to parse documentation comment blocks,
# building more structured objects out of them.
#
#
# Regular expressions to detect code sequences.  `Code sequences' are simply
# code fragments embedded in '{' and '}', as demonstrated in the following
# example.
#
#   {
#     x = y + z;
#     if ( zookoo == 2 )
#     {
#       foobar();
#     }
#   }
#
# Note that the indentation of the first opening brace and the last closing
# brace must be exactly the same.  The code sequence itself should have a
# larger indentation than the surrounding braces.
#
#
# A regular expression to isolate identifiers from other text.
#
#
# We collect macro names ending in `_H' (group 1), as defined in
# `config/ftheader.h'.  While outputting the object data, we use this info
# together with the object's file location (group 2) to emit the appropriate
# header file macro and its associated file name before the object itself.
#
# Example:
#
#   #define FT_FREETYPE_H <freetype.h>
#
#define\s{1,}(\w{1,}_H)\s{1,}<(.*)>' )
################################################################
##
##  DOC CODE CLASS
##
##  The `DocCode' class is used to store source code lines.
##
##  `self.lines' contains a set of source code lines that will be dumped as
##  HTML in a <PRE> tag.
##
##  The object is filled line by line by the parser; it strips the leading
##  `margin' space from each input line before storing it in `self.lines'.
##
# remove margin spaces
################################################################
##
##  DOC PARA CLASS
##
##  `Normal' text paragraphs are stored in the `DocPara' class.
##
##  `self.words' contains the list of words that make up the paragraph.
##
# current line
# current width
################################################################
##
##  DOC FIELD CLASS
##
##  The `DocField' class stores a list containing either `DocPara' or
##  `DocCode' objects.  Each DocField object also has an optional `name'
##  that is used when the object corresponds to a field or value definition.
##
# can be `None' for normal paragraphs/sources
# list of items
# start parsing mode
# parsing code sequences
# parsing normal paragraph
# current code sequence indentation
# analyze the markup lines to check whether they contain paragraphs,
# code sequences, or fields definitions
#
# are we parsing a code sequence?
# that's it, we finished the code sequence
# otherwise continue the code sequence
# start of code sequence?
# save current lines
# switch to code extraction mode
# if the line is empty, we end the current paragraph,
# if any
# otherwise, simply add the line to the current
# paragraph
# unexpected end of code sequence
#
# A regular expression to detect field definitions.
#
# Examples:
#
#   foo     ::
#   foo.bar ::
#
################################################################
##
##  DOC MARKUP CLASS
##
# We detected the start of a new field definition.
# first, save the current one
# record field name
################################################################
##
##  DOC CHAPTER CLASS
##
################################################################
##
##  DOC SECTION CLASS
##
# ordered block names in section
# look up one block that contains a valid section description
################################################################
##
##  CONTENT PROCESSOR CLASS
##
# dictionary of documentation sections
# current documentation section
# list of chapters
# dictionary of header macros
# get rid of last line of markup if it's empty
# remove markup from line
# is it the start of a new markup section ?
# add current markup content
# this is a documentation comment, we need to catch
# all following normal blocks in the "follow" list
#
# process all sections to extract their abstract, description
# and ordered list of items
#
# process chapters to check that all sections are correctly
# listed there
# check that all sections are in a chapter
#
# create a new special chapter for all remaining sections
# when necessary
#
################################################################
##
##  DOC BLOCK CLASS
##
# compute block type from first markup tag
# compute block name from first markup paragraph
# detect new section starts
# detect new chapter
# now, compute the source lines relevant to this documentation
# block. We keep normal comments in for obvious reasons (??)
# collect header macro definitions
# we use "/* */" as a separator
# now strip the leading and trailing empty lines from the sources
# We honour empty lines in an `<Order>' section element by
# adding the sentinel `/empty/'.  The formatter should then
# convert it to an appropriate representation in the
# `section_enter' function.
# eof
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\tools\docmaker\docbeauty.py
#!/usr/bin/env python
#
#  DocBeauty (c) 2003, 2004, 2008 David Turner <david@freetype.org>
#
# This program is used to beautify the documentation comments used
# in the FreeType 2 public headers.
#
# now beautify the documentation "borders" themselves
# process options
#
# create context and processor
# retrieve the list of files to process
# if called from the command line
#
# eof
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\tools\docmaker\docmaker.py
#!/usr/bin/env python
#
#  docmaker.py
#
#    Convert source code markup to HTML documentation.
#
#  Copyright 2002, 2004, 2008, 2013, 2014 by
#  David Turner.
#
#  This file is part of the FreeType project, and may only be used,
#  modified, and distributed under the terms of the FreeType project
#  license, LICENSE.TXT.  By continuing to use, modify, or distribute
#  this file you indicate that you have read the license and
#  understand and accept it fully.
#
# This program is a re-write of the original DocMaker tool used to generate
# the API Reference of the FreeType font rendering engine by converting
# in-source comments into structured HTML.
#
# This new version is capable of outputting XML data as well as accepting
# more liberal formatting options.  It also uses regular expression matching
# and substitution to speed up operation significantly.
#
# process options
# create context and processor
# retrieve the list of files to process
# process sections
# if called from the command line
# eof
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\tools\docmaker\formatter.py
#
#  formatter.py
#
#    Convert parsed content blocks to a structured document (library file).
#
#  Copyright 2002, 2004, 2007, 2008, 2014 by
#  David Turner.
#
#  This file is part of the FreeType project, and may only be used,
#  modified, and distributed under the terms of the FreeType project
#  license, LICENSE.TXT.  By continuing to use, modify, or distribute
#  this file you indicate that you have read the license and
#  understand and accept it fully.
#
# This is the base Formatter class.  Its purpose is to convert a content
# processor's data into specific documents (i.e., table of contents, global
# index, and individual API reference indices).
#
# You need to sub-class it to output anything sensible.  For example, the
# file `tohtml.py' contains the definition of the `HtmlFormatter' sub-class
# to output HTML.
#
################################################################
##
##  FORMATTER CLASS
##
# store all blocks in a dictionary
# add enumeration values to the index, since this is useful
# duplicate name!
#
# formatting the table of contents
#
#
# formatting the index
#
#
# formatting a section
#
# `block_names' can contain field names also,
# which we filter out
# this happens e.g. for `/empty/' entries
# always ignore first markup!
# eof
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\tools\docmaker\sources.py
#
#  sources.py
#
#    Convert source code comments to multi-line blocks (library file).
#
#  Copyright 2002-2004, 2006-2009, 2012-2014 by
#  David Turner.
#
#  This file is part of the FreeType project, and may only be used,
#  modified, and distributed under the terms of the FreeType project
#  license, LICENSE.TXT.  By continuing to use, modify, or distribute
#  this file you indicate that you have read the license and
#  understand and accept it fully.
#
# This library file contains definitions of classes needed to decompose C
# source code files into a series of multi-line `blocks'.  There are two
# kinds of blocks.
#
#   - Normal blocks, which contain source code or ordinary comments.
#
#   - Documentation blocks, which have restricted formatting, and whose text
#     always start with a documentation markup tag like `<Function>',
#     `<Type>', etc.
#
# The routines to process the content of documentation blocks are contained
# in file `content.py'; the classes and methods found here only deal with
# text parsing and basic documentation block extraction.
#
################################################################
##
##  SOURCE BLOCK FORMAT CLASS
##
##  A simple class containing compiled regular expressions to detect
##  potential documentation format block comments within C source code.
##
##  The `column' pattern must contain a group to `unbox' the content of
##  documentation comment blocks.
##
##  Later on, paragraphs are converted to long lines, which simplifies the
##  regular expressions that act upon the text.
##
#
# Format 1 documentation comment blocks.
#
#    /************************************/ (at least 2 asterisks)
#    /*                                  */
#    /*                                  */
#    /*                                  */
#    /************************************/ (at least 2 asterisks)
#
# any number of whitespace
# followed by '/' and at least two asterisks then '/'
# probably followed by whitespace
# any number of whitespace
# followed by '/' and precisely one asterisk
# followed by anything (group 1)
# followed by one asterisk and a '/'
# probably followed by whitespace
#
# Format 2 documentation comment blocks.
#
#    /************************************ (at least 2 asterisks)
#     *
#     *                                    (1 asterisk)
#     *
#     */                                   (1 or more asterisks)
#
# any number of whitespace
# followed by '/' and at least two asterisks
# probably followed by whitespace
# any number of whitespace
# followed by precisely one asterisk not followed by `/'
# then anything (group1)
# any number of whitespace
# followed by at least one asterisk, then '/'
#
# The list of supported documentation block formats.  We could add new ones
# quite easily.
#
#
# The following regular expressions correspond to markup tags within the
# documentation comment blocks.  They are equivalent despite their different
# syntax.
#
# A markup tag consists of letters or character `-', to be found in group 1.
#
# Notice that a markup tag _must_ begin a new paragraph.
#
# <xxxx> format
# @xxxx: format
#
# The list of supported markup tags.  We could add new ones quite easily.
#
#
# A regular expression to detect a cross reference, after markup tags have
# been stripped off.  Group 1 is the reference, group 2 the rest of the
# line.
#
# A cross reference consists of letters, digits, or characters `-' and `_'.
#
#  @foo
#
# Two regular expressions to detect italic and bold markup, respectively.
# Group 1 is the markup, group 2 the rest of the line.
#
# Note that the markup is limited to words consisting of letters, digits,
# the character `_', or an apostrophe (but not as the first character).
#
#  _italic_
#  *bold*
#
# This regular expression code to identify an URL has been taken from
#
#   http://mail.python.org/pipermail/tutor/2002-September/017228.html
#
# (with slight modifications).
#
#~:.?+=&%@!\-'
# start at word boundary
# need resource and a colon
# followed by one or more of any valid
# character, but be conservative and
# take only what you need to...
# [look-ahead non-consumptive assertion]
# either 0 or more punctuation
# [non-grouping parentheses]
# followed by a non-url char
# or end of the string
#
# A regular expression that stops collection of comments for the current
# block.
#
#  /* */
#
# A regular expression to find possible C identifiers while outputting
# source code verbatim, covering things like `*foo' or `(bar'.  Group 1 is
# the prefix, group 2 the identifier -- since we scan lines from left to
# right, sequentially splitting the source code into prefix and identifier
# is fully sufficient for our purposes.
#
#
# A regular expression that matches a list of reserved C source keywords.
#
#include |
#define  |
#undef   |
#if      |
#ifdef   |
#ifndef  |
#else    |
#endif   ) \\b''', re.VERBOSE )
################################################################
##
##  SOURCE BLOCK CLASS
##
##  There are two important fields in a `SourceBlock' object.
##
##    self.lines
##      A list of text lines for the corresponding block.
##
##    self.content
##      For documentation comment blocks only, this is the block content
##      that has been `unboxed' from its decoration.  This is `None' for all
##      other blocks (i.e., sources or ordinary comments with no starting
##      markup tag)
##
# extract comment lines
# now, look for a markup tag
# debugging only -- not used in normal operations
################################################################
##
##  SOURCE PROCESSOR CLASS
##
##  The `SourceProcessor' is in charge of reading a C source file and
##  decomposing it into a series of different `SourceBlock' objects.
##
##  A SourceBlock object consists of the following data.
##
##    - A documentation comment block using one of the layouts above.  Its
##      exact format will be discussed later.
##
##    - Normal sources lines, including comments.
##
##
# strip trailing newlines, important on Windows machines!
# A normal block end.  Add it to `lines' and create a
# new block
# A normal column line.  Add it to `lines'.
# An unexpected block end.  Create a new block, but
# don't process the line.
# we need to process the line again
# record the last lines
# debugging only, not used in normal operations
# eof
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\tools\docmaker\tohtml.py
#
#  tohtml.py
#
#    A sub-class container of the `Formatter' class to produce HTML.
#
#  Copyright 2002, 2003, 2005-2008, 2013, 2014 by
#  David Turner.
#
#  This file is part of the FreeType project, and may only be used,
#  modified, and distributed under the terms of the FreeType project
#  license, LICENSE.TXT.  By continuing to use, modify, or distribute
#  this file you indicate that you have read the license and
#  understand and accept it fully.
# The parent class is contained in file `formatter.py'.
# The following strings define the HTML header used by all generated pages.
#0000EF; }
#51188E; }
#FF0000; }
#000000;
#FFFFFF;
#EEEEFF;
#D6E8FF;
# The HTML footer used by all generated pages.
# The header and footer used for each section.
# The header and footer used for code segments.
# Paragraph header and footer.
# Block header and footer.
#">Top</a>]</td>\
# Description header/footer.
# Marker header/inter/footer combination.
# Header location header/footer.
# Source code extracts header/footer.
# Chapter header/inter/footer.
# Index footer.
# TOC footer.
# Source language keyword coloration and styling.
# Translate a single line of source to HTML.  This converts `<', `>', and
# `&' into `&lt;',`&gt;', and `&amp;'.
#
################################################################
##
##  HTML FORMATTER CLASS
##
#" + name
# handle cross-references
# we detected a cross-reference to an unknown item
# handle markup for italic and bold
# handle hyperlinks
# convert `...' quotations into real left and right single quotes
# convert tilde into non-breakable space
# this is the current block name, if any
# this is a C keyword
# this is a known identifier
# link to a field ID if possible
# We begin a new series of field or value definitions.  We
# record them in the `table_fields' list before outputting
# all of them as a single table.
#
# formatting the index
#
# `block_index' already contains the sorted list of index names
#
# formatting the table of contents
#
#
# formatting sections
#
# XXX magic number
# print section synopsis
# don't handle last entry if it is empty
# it can happen that a complete row is empty, and
# without a proper `filler' the browser might
# collapse the row to a much smaller height (or
# even omit it completely)
#' + name + '">'
# place html anchor if needed
# dump the block C source lines now
#           if not header:
#               sys.stderr.write(
#                 "WARNING: No header macro for"
#                 + " '" + block.source.filename + "'.\n" )
# eof
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\tools\docmaker\utils.py
#
#  utils.py
#
#    Auxiliary functions for the `docmaker' tool (library file).
#
#  Copyright 2002, 2004, 2007, 2008, 2014 by
#  David Turner.
#
#  This file is part of the FreeType project, and may only be used,
#  modified, and distributed under the terms of the FreeType project
#  license, LICENSE.TXT.  By continuing to use, modify, or distribute
#  this file you indicate that you have read the license and
#  understand and accept it fully.
# current output directory
#
# A function that generates a sorting key.  We want lexicographical order
# (primary key) except that capital letters are sorted before lowercase
# ones (secondary key).
#
# The primary key is implemented by lowercasing the input.  The secondary
# key is simply the original data appended, character by character.  For
# example, the sort key for `FT_x' is `fFtT__xx', while the sort key for
# `ft_X' is `fftt__xX'.  Since ASCII codes of uppercase letters are
# numerically smaller than the codes of lowercase letters, `fFtT__xx' gets
# sorted before `fftt__xX'.
#
# Sort `input_list', placing the elements of `order_list' in front.
#
# Divert standard output to a given project documentation file.  Use
# `output_dir' to determine the filename location if necessary and save the
# old stdout handle in a tuple that is returned by this function.
#
# Close the output that was returned by `open_output'.
#
# Check output directory.
#
# sys.stderr.write( repr( sys.argv[1 :] ) + '\n' )
# sort files -- this is important because
# of the order of files
# now filter the file list to remove non-existing ones
# eof
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\tools\ftrandom\ftrandom.c
/* Copyright (C) 2005, 2007, 2008, 2013 by George Williams */
/*
/* modified by Werner Lemberg <wl@gnu.org>       */
/* This file is now part of the FreeType library */
/* No shift, no delta */
/* The font is erroneous, so if this fails that's ok. */
/* Try to guess the file type from the first few characters... */
/* ttf, otf, ttc files */
/* PFB header */
/* Random PostScript */
/* Bare CFF */
/* BDF */
/* PFR */
/* Windows FON */
/* If a time-out happens, then kill the child */
/* Anything that takes more than 20 seconds */
/* to parse and/or rasterize is an error.   */
/* This should never return */
/* EOF */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\truetype\truetype.c
/***************************************************************************/
/*                                                                         */
/*  truetype.c                                                             */
/*                                                                         */
/*    FreeType TrueType driver component (body only).                      */
/*                                                                         */
/*  Copyright 1996-2001, 2004, 2006, 2012 by                               */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* driver interface    */
/* tables loader       */
/* glyph loader        */
/* object manager      */
/* gx distortable font */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\truetype\ttdriver.c
/***************************************************************************/
/*                                                                         */
/*  ttdriver.c                                                             */
/*                                                                         */
/*    TrueType font driver implementation (body).                          */
/*                                                                         */
/*  Copyright 1996-2014 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*
/* TT_Driver */
/* TT_Driver */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                                                                 ****/
/****                          F A C E S                              ****/
/****                                                                 ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_get_kerning                                                     */
/*                                                                       */
/* <Description>                                                         */
/*    A driver method used to return the kerning vector between two      */
/*    glyphs of the same face.                                           */
/*                                                                       */
/* <Input>                                                               */
/*    face        :: A handle to the source face object.                 */
/*                                                                       */
/*    left_glyph  :: The index of the left glyph in the kern pair.       */
/*                                                                       */
/*    right_glyph :: The index of the right glyph in the kern pair.      */
/*                                                                       */
/* <Output>                                                              */
/*    kerning     :: The kerning vector.  This is in font units for      */
/*                   scalable formats, and in pixels for fixed-sizes     */
/*                   formats.                                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* <Note>                                                                */
/*    Only horizontal layouts (left-to-right & right-to-left) are        */
/*    supported by this function.  Other layouts, or more sophisticated  */
/*    kernings, are out of scope of this method (the basic driver        */
/*    interface is meant to be simple).                                  */
/*                                                                       */
/*    They can be implemented by format-specific interfaces.             */
/*                                                                       */
/* TT_Face */
/* XXX: TODO: check for sbits */
/* since we don't need `tsb', we use zero for `yMax' parameter */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                                                                 ****/
/****                           S I Z E S                             ****/
/****                                                                 ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* use the scaled metrics, even when tt_size_reset fails */
/* ignore return value */
/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_glyph_load                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    A driver method used to load a glyph within a given glyph slot.    */
/*                                                                       */
/* <Input>                                                               */
/*    slot        :: A handle to the target slot object where the glyph  */
/*                   will be loaded.                                     */
/*                                                                       */
/*    size        :: A handle to the source face size at which the glyph */
/*                   must be scaled, loaded, etc.                        */
/*                                                                       */
/*    glyph_index :: The index of the glyph in the font file.            */
/*                                                                       */
/*    load_flags  :: A flag indicating what to load for this glyph.  The */
/*                   FT_LOAD_XXX constants can be used to control the    */
/*                   glyph loading process (e.g., whether the outline    */
/*                   should be scaled, whether to load bitmaps or not,   */
/*                   whether to hint the outline, etc).                  */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* TT_GlyphSlot */
/* TT_Size      */
/* both FT_LOAD_NO_HINTING and FT_LOAD_NO_AUTOHINT   */
/* are necessary to disable hinting for tricky fonts */
/* now load the glyph outline if necessary */
/* force drop-out mode to 2 - irrelevant now */
/* slot->outline.dropout_mode = 2; */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                                                                 ****/
/****                D R I V E R  I N T E R F A C E                   ****/
/****                                                                 ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* !TT_USE_BYTECODE_INTERPRETER */
/* TT_USE_BYTECODE_INTERPRETER */
/* TT_Driver */
/* TT_SERVICES_GET dereferences `library' in PIC mode */
/* only return the default interface from the SFNT module */
/* The FT_DriverInterface structure is defined in ftdriver.h. */
/* driver name                           */
/* driver version == 1.0                 */
/* driver requires FreeType 2.0 or above */
/* driver specific interface */
/* FT_Slot_DoneFunc */
/* FT_Face_AttachFunc */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\truetype\ttgload.c
/***************************************************************************/
/*                                                                         */
/*  ttgload.c                                                              */
/*                                                                         */
/*    TrueType Glyph Loader (body).                                        */
/*                                                                         */
/*  Copyright 1996-2014                                                    */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* Composite glyph flags.                                                */
/*                                                                       */
/* reserved                        0x0010 */
/*************************************************************************/
/*                                                                       */
/* Return the horizontal metrics in font units for a given glyph.        */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* Return the vertical metrics in font units for a given glyph.          */
/* See macro `TT_LOADER_SET_PP' below for explanations.                  */
/*                                                                       */
/* we must preserve the stream position          */
/* (which gets altered by the metrics functions) */
/* this may not be the right place for this, but it works */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* If this is an incrementally loaded font check whether there are */
/* overriding metrics for this glyph.                              */
/* GWW: Do I do the same for vertical metrics? */
/* 0 */
/* FT_CONFIG_OPTION_INCREMENTAL */
/*************************************************************************/
/*                                                                       */
/* Translates an array of coordinates.                                   */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* The following functions are used by default with TrueType fonts.      */
/* However, they can be replaced by alternatives if we need to support   */
/* TrueType-compressed formats (like MicroType) in the future.           */
/*                                                                       */
/*************************************************************************/
/* for non-debug mode */
/* the following line sets the `error' variable through macros! */
/* check that we can add the contours to the glyph */
/* reading the contours' endpoints & number of points */
/* check space for contours array + instructions count */
/* unordered contours: this is invalid */
/* note that we will add four phantom points later */
/* reading the bytecode instructions */
/* check it */
/* we don't trust `maxSizeOfInstructions' in the `maxp' table */
/* and thus update the bytecode array size by ourselves       */
/* TT_USE_BYTECODE_INTERPRETER */
/* reading the point tags */
/* reading the X coordinates */
/* the cast is for stupid compilers */
/* reading the Y coordinates */
/* the cast is for stupid compilers */
/* check that we can load a new subglyph */
/* check space */
/* check space */
/* read arguments */
/* read transform */
/* we must undo the FT_FRAME_ENTER in order to point */
/* to the composite instructions, if we find some.   */
/* We will process them later.                       */
/*                                                   */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Hint_Glyph                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Hint the glyph using the zone prepared by the caller.  Note that   */
/*    the zone is supposed to include four phantom points.               */
/*                                                                       */
/* save original point position in org */
/* Reset graphics state. */
/* XXX: UNDOCUMENTED! Hinting instructions of a composite glyph */
/*      completely refer to the (already) hinted subglyphs.     */
/* round phantom points */
/* store drop-out mode in bits 5-7; set bit 2 also as a marker */
/* save glyph phantom points */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Process_Simple_Glyph                                            */
/*                                                                       */
/* <Description>                                                         */
/*    Once a simple glyph has been loaded, it needs to be processed.     */
/*    Usually, this means scaling and hinting through bytecode           */
/*    interpretation.                                                    */
/*                                                                       */
/* set phantom points */
/* Deltas apply to the unscaled data. */
/* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
/* pacify compiler */
/* scale, but only if enabled and only if TT hinting is being used */
/* scale the glyph */
/* compensate for any scaling by de/emboldening; */
/* the amount was determined via experimentation */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* scale the glyph */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Process_Composite_Component                                     */
/*                                                                       */
/* <Description>                                                         */
/*    Once a composite component has been loaded, it needs to be         */
/*    processed.  Usually, this means transforming and translating.      */
/*                                                                       */
/* perform the transform required for this subglyph */
/* get offset */
/* match l-th point of the newly loaded component to the k-th point */
/* of the previously loaded components.                             */
/* change to the point numbers used by our outline */
/* Use a default value dependent on                                  */
/* TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED.  This is useful for old */
/* TT fonts which don't set the xxx_COMPONENT_OFFSET bit.            */
/*******************************************************************/
/*                                                                 */
/* This algorithm is what Apple documents.  But it doesn't work.   */
/*                                                                 */
/* 1 */
/*******************************************************************/
/*                                                                 */
/* This algorithm is a guess and works much better than the above. */
/*                                                                 */
/* 1 */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Process_Composite_Glyph                                         */
/*                                                                       */
/* <Description>                                                         */
/*    This is slightly different from TT_Process_Simple_Glyph, in that   */
/*    its sole purpose is to hint the glyph.  Thus this function is      */
/*    only available when bytecode interpreter is enabled.               */
/*                                                                       */
/* make room for phantom points */
/* TT_Load_Composite_Glyph only gives us the offset of instructions */
/* so we read them here                                             */
/* check it */
/* don't trust `maxSizeOfInstructions'; */
/* only do a rough safety check         */
/* Some points are likely touched during execution of  */
/* instructions on components.  So let's untouch them. */
/*
/* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    load_truetype_glyph                                                */
/*                                                                       */
/* <Description>                                                         */
/*    Loads a given truetype glyph.  Handles composites and uses a       */
/*    TT_Loader object.                                                  */
/*                                                                       */
/* some fonts have an incorrect value of `maxComponentDepth', */
/* thus we allow depth 1 to catch the majority of them        */
/* check glyph index */
/* Set `offset' to the start of the glyph relative to the start of */
/* the `glyf' table, and `byte_len' to the length of the glyph in  */
/* bytes.                                                          */
/* If we are loading glyph data via the incremental interface, set */
/* the loader stream to a memory stream reading the data returned  */
/* by the interface.                                               */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* for the incremental interface, `glyf_offset' is always zero */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* read glyph header first */
/* the metrics must be computed after loading the glyph header */
/* since we need the glyph's `yMax' value in case the vertical */
/* metrics must be emulated                                    */
/* must initialize points before (possibly) overriding */
/* glyph metrics from the incremental interface        */
/* this must be done before scaling */
/* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
/* scale phantom points, if necessary; */
/* they get rounded in `TT_Hint_Glyph' */
/* pp1.y and pp2.y are always zero */
/* must initialize phantom points before (possibly) overriding */
/* glyph metrics from the incremental interface                */
/***********************************************************************/
/***********************************************************************/
/***********************************************************************/
/* if it is a simple glyph, load it */
/* all data have been read */
/***********************************************************************/
/***********************************************************************/
/***********************************************************************/
/* otherwise, load a composite! */
/* position of composite instructions, if any */
/* for each subglyph, read composite header */
/* store the offset of instructions */
/* all data we need are read */
/* this provides additional offsets */
/* for each component's translation */
/* XXX: overflow check for subglyph->{arg1,arg2}.   */
/* deltas[i].{x,y} must be within signed 16-bit,    */
/* but the restriction of summed delta is not clear */
/* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
/* scale phantom points, if necessary; */
/* they get rounded in `TT_Hint_Glyph' */
/* pp1.y and pp2.y are always zero */
/* if the flag FT_LOAD_NO_RECURSE is set, we return the subglyph */
/* `as is' in the glyph slot (the client application will be     */
/* responsible for interpreting these data)...                   */
/*********************************************************************/
/*********************************************************************/
/*********************************************************************/
/* read each subglyph independently */
/* Each time we call load_truetype_glyph in this loop, the   */
/* value of `gloader.base.subglyphs' can change due to table */
/* reallocations.  We thus need to recompute the subglyph    */
/* pointer on each iteration.                                */
/* restore subglyph pointer */
/* restore phantom points if necessary */
/* gloader->base.outline consists of three parts:               */
/* 0 -(1)-> start_point -(2)-> num_base_points -(3)-> n_points. */
/*                                                              */
/* (1): exists from the beginning                               */
/* (2): components that have been loaded so far                 */
/* (3): the newly loaded component                              */
/* process the glyph */
/* invalid composite count (negative but not -1) */
/***********************************************************************/
/***********************************************************************/
/***********************************************************************/
/* get the device-independent horizontal advance; it is scaled later */
/* by the base layer.                                                */
/* adjust advance width to the value contained in the hdmx table */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* set glyph dimensions */
/* Now take care of vertical metrics.  In the case where there is */
/* no vertical information within the font (relatively common),   */
/* create some metrics manually                                   */
/* scaled vertical top side bearing  */
/* scaled vertical advance height    */
/* Get the unscaled top bearing and advance height. */
/* XXX Compute top side bearing and advance height in  */
/*     Get_VMetrics instead of here.                   */
/* NOTE: The OS/2 values are the only `portable' ones, */
/*       which is why we use them, if there is an OS/2 */
/*       table in the font.  Otherwise, we use the     */
/*       values defined in the horizontal header.      */
/* If this is an incrementally loaded font see if there are */
/* overriding metrics for this glyph.                       */
/* GWW: Do vertical metrics get loaded incrementally too? */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* scale the metrics */
/* XXX: for now, we have no better algorithm for the lsb, but it */
/*      should work fine.                                        */
/*                                                               */
/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
/* load execution context */
/* not used yet */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* query new execution context */
/* 0 */
/* 0 */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* a change from mono to subpixel rendering (and vice versa) */
/* requires a re-execution of the CVT program                */
/* a change from mono to grayscale rendering (and vice versa) */
/* requires a re-execution of the CVT program                 */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* a change from mono to grayscale rendering (and vice versa) */
/* requires a re-execution of the CVT program                 */
/* see whether the cvt program has disabled hinting */
/* load default graphics state -- if needed */
/* TT_USE_BYTECODE_INTERPRETER */
/* seek to the beginning of the glyph table -- for Type 42 fonts     */
/* the table might be accessed from a Postscript stream or something */
/* else...                                                           */
/* get face's glyph loader */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Load_Glyph                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    A function used to load a single glyph within a given glyph slot,  */
/*    for a given size.                                                  */
/*                                                                       */
/* <Input>                                                               */
/*    glyph       :: A handle to a target slot object where the glyph    */
/*                   will be loaded.                                     */
/*                                                                       */
/*    size        :: A handle to the source face size at which the glyph */
/*                   must be scaled/loaded.                              */
/*                                                                       */
/*    glyph_index :: The index of the glyph in the font file.            */
/*                                                                       */
/*    load_flags  :: A flag indicating what to load for this glyph.  The */
/*                   FT_LOAD_XXX constants can be used to control the    */
/*                   glyph loading process (e.g., whether the outline    */
/*                   should be scaled, whether to load bitmaps or not,   */
/*                   whether to hint the outline, etc).                  */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* try to load embedded bitmap if any              */
/*                                                 */
/* XXX: The convention should be emphasized in     */
/*      the documents because it can be confusing. */
/* for the bbox we need the header only */
/* sanity checks: if `xxxAdvance' in the sbit metric */
/* structure isn't set, use `linearXXXAdvance'      */
/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
/* if FT_LOAD_NO_SCALE is not set, `ttmetrics' must be valid */
/* main loading loop */
/* Translate array so that (0,0) is the glyph's origin.  Note  */
/* that this behaviour is independent on the value of bit 1 of */
/* the `flags' field in the `head' table -- at least major     */
/* applications like Acroread indicate that.                   */
/* convert scan conversion mode to FT_OUTLINE_XXX flags */
/* simple drop-outs including stubs */
/* simple drop-outs excluding stubs */
/* nothing; it's the default rendering mode */
/* smart drop-outs including stubs */
/* smart drop-outs excluding stubs  */
/* no drop-out control */
/* TT_USE_BYTECODE_INTERPRETER */
/* Set the `high precision' bit flag.                           */
/* This is _critical_ to get correct output for monochrome      */
/* TrueType glyphs at all sizes using the bytecode interpreter. */
/*                                                              */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\truetype\ttgxvar.c
/***************************************************************************/
/*                                                                         */
/*  ttgxvar.c                                                              */
/*                                                                         */
/*    TrueType GX Font Variation loader                                    */
/*                                                                         */
/*  Copyright 2004-2014 by                                                 */
/*  David Turner, Robert Wilhelm, Werner Lemberg, and George Williams.     */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* Apple documents the `fvar', `gvar', `cvar', and `avar' tables at      */
/*                                                                       */
//developer.apple.com/fonts/TTRefMan/RM06/Chap6[fgca]var.html  */
/*   http://developer.apple.com/fonts/TTRefMan/RM06/Chap6[fgca]var.html  */
/*                                                                       */
/* The documentation for `fvar' is inconsistent.  At one point it says   */
/* that `countSizePairs' should be 3, at another point 2.  It should     */
/* be 2.                                                                 */
/*                                                                       */
/* The documentation for `gvar' is not intelligible; `cvar' refers you   */
/* to `gvar' and is thus also incomprehensible.                          */
/*                                                                       */
/* The documentation for `avar' appears correct, but Apple has no fonts  */
/* with an `avar' table, so it is hard to test.                          */
/*                                                                       */
/* Many thanks to John Jenkins (at Apple) in figuring this out.          */
/*                                                                       */
/*                                                                       */
/* Apple's `kern' table has some references to tuple indices, but as     */
/* there is no indication where these indices are defined, nor how to    */
/* interpolate the kerning values (different tuples have different       */
/* classes) this issue is ignored.                                       */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                       Internal Routines                       *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro ALL_POINTS is used in `ft_var_readpackedpoints'.  It        */
/* indicates that there is a delta for every point without needing to    */
/* enumerate all of them.                                                */
/*                                                                       */
/* ensure that value `0' has the same width as a pointer */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    ft_var_readpackedpoints                                            */
/*                                                                       */
/* <Description>                                                         */
/*    Read a set of points to which the following deltas will apply.     */
/*    Points are packed with a run length encoding.                      */
/*                                                                       */
/* <Input>                                                               */
/*    stream    :: The data stream.                                      */
/*                                                                       */
/* <Output>                                                              */
/*    point_cnt :: The number of points read.  A zero value means that   */
/*                 all points in the glyph will be affected, without     */
/*                 enumerating them individually.                        */
/*                                                                       */
/* <Return>                                                              */
/*    An array of FT_UShort containing the affected points or the        */
/*    special value ALL_POINTS.                                          */
/*                                                                       */
/* first point not included in runcount */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    ft_var_readpackeddeltas                                            */
/*                                                                       */
/* <Description>                                                         */
/*    Read a set of deltas.  These are packed slightly differently than  */
/*    points.  In particular there is no overall count.                  */
/*                                                                       */
/* <Input>                                                               */
/*    stream    :: The data stream.                                      */
/*                                                                       */
/*    delta_cnt :: The number of to be read.                             */
/*                                                                       */
/* <Return>                                                              */
/*    An array of FT_Short containing the deltas for the affected        */
/*    points.  (This only gets the deltas for one dimension.  It will    */
/*    generally be called twice, once for x, once for y.  When used in   */
/*    cvt table, it will only be called once.)                           */
/*                                                                       */
/* runcnt zeroes get added */
/* runcnt shorts from the stack */
/* runcnt signed bytes from the stack */
/* Bad format */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    ft_var_load_avar                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Parse the `avar' table if present.  It need not be, so we return   */
/*    nothing.                                                           */
/*                                                                       */
/* <InOut>                                                               */
/*    face :: The font face.                                             */
/*                                                                       */
/* Failure.  Free everything we have done so far.  We must do */
/* it right now since loading the `avar' table is optional.   */
/* convert to Fixed */
/* convert to Fixed */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    ft_var_load_gvar                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Parses the `gvar' table if present.  If `fvar' is there, `gvar'    */
/*    had better be there too.                                           */
/*                                                                       */
/* <InOut>                                                               */
/*    face :: The font face.                                             */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* long offsets (one more offset than glyphs, to mark size of last) */
/* short offsets (one more offset than glyphs, to mark size of last) */
/* XXX: Undocumented: `*2'! */
/* convert to FT_Fixed */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    ft_var_apply_tuple                                                 */
/*                                                                       */
/* <Description>                                                         */
/*    Figure out whether a given tuple (design) applies to the current   */
/*    blend, and if so, what is the scaling factor.                      */
/*                                                                       */
/* <Input>                                                               */
/*    blend           :: The current blend of the font.                  */
/*                                                                       */
/*    tupleIndex      :: A flag saying whether this is an intermediate   */
/*                       tuple or not.                                   */
/*                                                                       */
/*    tuple_coords    :: The coordinates of the tuple in normalized axis */
/*                       units.                                          */
/*                                                                       */
/*    im_start_coords :: The initial coordinates where this tuple starts */
/*                       to apply (for intermediate coordinates).        */
/*                                                                       */
/*    im_end_coords   :: The final coordinates after which this tuple no */
/*                       longer applies (for intermediate coordinates).  */
/*                                                                       */
/* <Return>                                                              */
/*    An FT_Fixed value containing the scaling factor.                   */
/*                                                                       */
/* It's not clear why (for intermediate tuples) we don't need     */
/* to check against start/end -- the documentation says we don't. */
/* Similarly, it's unclear why we don't need to scale along the   */
/* axis.                                                          */
/* not an intermediate tuple */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****               MULTIPLE MASTERS SERVICE FUNCTIONS              *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Get_MM_Var                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Check that the font's `fvar' table is valid, parse it, and return  */
/*    those data.                                                        */
/*                                                                       */
/* <InOut>                                                               */
/*    face   :: The font face.                                           */
/*              TT_Get_MM_Var initializes the blend structure.           */
/*                                                                       */
/* <Output>                                                              */
/*    master :: The `fvar' data (must be freed by caller).               */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* both `fvar' and `gvar' must be present */
/* axisCount limit implied by 16-bit instanceSize */
/* instanceCount limit implied by limited range of name IDs */
/* cannot overflow 32-bit arithmetic because of limits above */
/* meaningless in this context; each glyph */
/* may have a different number of designs  */
/* (or tuples, as called by Apple)         */
/* A Fixed */
/* A Fixed */
/* A Fixed */
/* flags = */ FT_GET_USHORT();
/* A Fixed */
/* standard PostScript names for some standard apple tags */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Set_MM_Blend                                                    */
/*                                                                       */
/* <Description>                                                         */
/*    Set the blend (normalized) coordinates for this instance of the    */
/*    font.  Check that the `gvar' table is reasonable and does some     */
/*    initial preparation.                                               */
/*                                                                       */
/* <InOut>                                                               */
/*    face       :: The font.                                            */
/*                  Initialize the blend structure with `gvar' data.     */
/*                                                                       */
/* <Input>                                                               */
/*    num_coords :: Must be the axis count of the font.                  */
/*                                                                       */
/*    coords     :: An array of num_coords, each between [-1,1].         */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* If we have not set the blend coordinates before this, then the  */
/* cvt table will still be what we read from the `cvt ' table and  */
/* we don't need to reload it.  We may need to change it though... */
/* If we don't change the blend coords then we don't need to do  */
/* anything to the cvt table.  It will be correct.  Otherwise we */
/* no longer have the original cvt (it was modified when we set  */
/* the blend last time), so we must reload and then modify it.   */
/* The cvt table has been loaded already; every time we change the */
/* blend we may need to reload and remodify the cvt table.         */
/* The original cvt table is in memory.  All we need to do is */
/* apply the `cvar' table (if any).                           */
/* The cvt table is correct for this set of coordinates. */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Set_Var_Design                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Set the coordinates for the instance, measured in the user         */
/*    coordinate system.  Parse the `avar' table (if present) to convert */
/*    from user to normalized coordinates.                               */
/*                                                                       */
/* <InOut>                                                               */
/*    face       :: The font face.                                       */
/*                  Initialize the blend struct with `gvar' data.        */
/*                                                                       */
/* <Input>                                                               */
/*    num_coords :: This must be the axis count of the font.             */
/*                                                                       */
/*    coords     :: A coordinate array with `num_coords' elements.       */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* Axis normalization is a two stage process.  First we normalize */
/* based on the [min,def,max] values for the axis to be [-1,0,1]. */
/* Then, if there's an `avar' table, we renormalize this range.   */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     GX VAR PARSING ROUTINES                   *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_vary_cvt                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Modify the loaded cvt table according to the `cvar' table and the  */
/*    font's blend.                                                      */
/*                                                                       */
/* <InOut>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/* <Input>                                                               */
/*    stream :: A handle to the input stream.                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/*    Most errors are ignored.  It is perfectly valid not to have a      */
/*    `cvar' table even if there is a `gvar' and `fvar' table.           */
/*                                                                       */
/* The documentation implies there are flags packed into the        */
/* tuplecount, but John Jenkins says that shared points don't apply */
/* to `cvar', and no other flags are defined.                       */
/* There is no provision here for a global tuple coordinate section, */
/* so John says.  There are no tuple indices, just embedded tuples.  */
/* convert from        */
/* short frac to fixed */
/* skip this tuple; it makes no sense */
/* tuple isn't active for our blend */
/* global points not allowed,           */
/* if they aren't local, makes no sense */
/* failure, ignore it */;
/* this means that there are deltas for every entry in cvt */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Vary_Get_Glyph_Deltas                                           */
/*                                                                       */
/* <Description>                                                         */
/*    Load the appropriate deltas for the current glyph.                 */
/*                                                                       */
/* <Input>                                                               */
/*    face        :: A handle to the target face object.                 */
/*                                                                       */
/*    glyph_index :: The index of the glyph being modified.              */
/*                                                                       */
/*    n_points    :: The number of the points in the glyph, including    */
/*                   phantom points.                                     */
/*                                                                       */
/* <Output>                                                              */
/*    deltas      :: The array of points to change.                      */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* to be freed by the caller */
/* no variation data for this glyph */
/* each set of glyph variation data is formatted similarly to `cvar' */
/* (except we get shared points and global tuples)                   */
/* convert from        */
/* short frac to fixed */
/* tuple isn't active for our blend */
/* failure, ignore it */
/* this means that there are deltas for every point in the glyph */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_done_blend                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Frees the blend internal data structure.                           */
/*                                                                       */
/* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\truetype\ttinterp.c
/***************************************************************************/
/*                                                                         */
/*  ttinterp.c                                                             */
/*                                                                         */
/*    TrueType bytecode interpreter (body).                                */
/*                                                                         */
/*  Copyright 1996-2014                                                    */
/*  by David Turner, Robert Wilhelm, and Werner Lemberg.                   */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* Greg Hitchcock from Microsoft has helped a lot in resolving unclear */
/* issues; many thanks!                                                */
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* In order to detect infinite loops in the code, we set up a counter    */
/* within the run loop.  A single stroke of interpretation is now        */
/* limited to a maximum number of opcodes defined below.                 */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* There are two kinds of implementations:                               */
/*                                                                       */
/* a. static implementation                                              */
/*                                                                       */
/*    The current execution context is a static variable, which fields   */
/*    are accessed directly by the interpreter during execution.  The    */
/*    context is named `cur'.                                            */
/*                                                                       */
/*    This version is non-reentrant, of course.                          */
/*                                                                       */
/* b. indirect implementation                                            */
/*                                                                       */
/*    The current execution context is passed to _each_ function as its  */
/*    first argument, and each field is thus accessed indirectly.        */
/*                                                                       */
/*    This version is fully re-entrant.                                  */
/*                                                                       */
/* The idea is that an indirect implementation may be slower to execute  */
/* on low-end processors that are used in some systems (like 386s or     */
/* even 486s).                                                           */
/*                                                                       */
/* As a consequence, the indirect implementation is now the default, as  */
/* its performance costs can be considered negligible in our context.    */
/* Note, however, that we kept the same source with macros because:      */
/*                                                                       */
/* - The code is kept very close in design to the Pascal code used for   */
/*   development.                                                        */
/*                                                                       */
/* - It's much more readable that way!                                   */
/*                                                                       */
/* - It's still open to experimentation and tuning.                      */
/*                                                                       */
/*************************************************************************/
/* indirect implementation */
/* see ttobjs.h */
/*************************************************************************/
/*                                                                       */
/* This macro is used whenever `exec' is unused in a function, to avoid  */
/* stupid warnings from pedantic compilers.                              */
/*                                                                       */
/* static implementation */
/* static exec. context variable */
/* apparently, we have a _lot_ of direct indexing when accessing  */
/* the static `cur', which makes the code bigger (due to all the  */
/* four bytes addresses).                                         */
/* TT_CONFIG_OPTION_STATIC_INTERPRETER */
/*************************************************************************/
/*                                                                       */
/* The instruction argument stack.                                       */
/*                                                                       */
/* see ttobjs.h for EXEC_OP_ */
/*************************************************************************/
/*                                                                       */
/* This macro is used whenever `args' is unused in a function, to avoid  */
/* stupid warnings from pedantic compilers.                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* The following macros hide the use of EXEC_ARG and EXEC_ARG_ to        */
/* increase readability of the code.                                     */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* Instruction dispatch function, as used by the interpreter.            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* Two simple bounds-checking macros.                                    */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* This macro computes (a*2^14)/b and complements TT_MulFix14.           */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/*                        CODERANGE FUNCTIONS                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Goto_CodeRange                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Switches to a new code range (updates the code related elements in */
/*    `exec', and `IP').                                                 */
/*                                                                       */
/* <Input>                                                               */
/*    range :: The new execution code range.                             */
/*                                                                       */
/*    IP    :: The new IP in the new code range.                         */
/*                                                                       */
/* <InOut>                                                               */
/*    exec  :: The target execution context.                             */
/*                                                                       */
/* NOTE: Because the last instruction of a program may be a CALL */
/*       which will return to the first byte *after* the code    */
/*       range, we test for IP <= Size instead of IP < Size.     */
/*                                                               */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Set_CodeRange                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Sets a code range.                                                 */
/*                                                                       */
/* <Input>                                                               */
/*    range  :: The code range index.                                    */
/*                                                                       */
/*    base   :: The new code base.                                       */
/*                                                                       */
/*    length :: The range size in bytes.                                 */
/*                                                                       */
/* <InOut>                                                               */
/*    exec   :: The target execution context.                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Clear_CodeRange                                                 */
/*                                                                       */
/* <Description>                                                         */
/*    Clears a code range.                                               */
/*                                                                       */
/* <Input>                                                               */
/*    range :: The code range index.                                     */
/*                                                                       */
/* <InOut>                                                               */
/*    exec  :: The target execution context.                             */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/*                   EXECUTION CONTEXT ROUTINES                          */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Done_Context                                                    */
/*                                                                       */
/* <Description>                                                         */
/*    Destroys a given context.                                          */
/*                                                                       */
/* <Input>                                                               */
/*    exec   :: A handle to the target execution context.                */
/*                                                                       */
/*    memory :: A handle to the parent memory object.                    */
/*                                                                       */
/* <Note>                                                                */
/*    Only the glyph loader and debugger should call this function.      */
/*                                                                       */
/* points zone */
/* free stack */
/* free call stack */
/* free glyph code range */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Init_Context                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    Initializes a context object.                                      */
/*                                                                       */
/* <Input>                                                               */
/*    memory :: A handle to the parent memory object.                    */
/*                                                                       */
/* <InOut>                                                               */
/*    exec   :: A handle to the target execution context.                */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* all values in the context are set to 0 already, but this is */
/* here as a remainder                                         */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Update_Max                                                         */
/*                                                                       */
/* <Description>                                                         */
/*    Checks the size of a buffer and reallocates it if necessary.       */
/*                                                                       */
/* <Input>                                                               */
/*    memory     :: A handle to the parent memory object.                */
/*                                                                       */
/*    multiplier :: The size in bytes of each element in the buffer.     */
/*                                                                       */
/*    new_max    :: The new capacity (size) of the buffer.               */
/*                                                                       */
/* <InOut>                                                               */
/*    size       :: The address of the buffer's current size expressed   */
/*                  in elements.                                         */
/*                                                                       */
/*    buff       :: The address of the buffer base pointer.              */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Load_Context                                                    */
/*                                                                       */
/* <Description>                                                         */
/*    Prepare an execution context for glyph hinting.                    */
/*                                                                       */
/* <Input>                                                               */
/*    face :: A handle to the source face object.                        */
/*                                                                       */
/*    size :: A handle to the source size object.                        */
/*                                                                       */
/* <InOut>                                                               */
/*    exec :: A handle to the target execution context.                  */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* <Note>                                                                */
/*    Only the glyph loader and debugger should call this function.      */
/*                                                                       */
/* set graphics state */
/* In case of multi-threading it can happen that the old size object */
/* no longer exists, thus we must clear all glyph zone references.   */
/* XXX: We reserve a little more elements on the stack to deal safely */
/*      with broken fonts like arialbs, courbs, timesbs, etc.         */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Save_Context                                                    */
/*                                                                       */
/* <Description>                                                         */
/*    Saves the code ranges in a `size' object.                          */
/*                                                                       */
/* <Input>                                                               */
/*    exec :: A handle to the source execution context.                  */
/*                                                                       */
/* <InOut>                                                               */
/*    size :: A handle to the target size object.                        */
/*                                                                       */
/* <Note>                                                                */
/*    Only the glyph loader and debugger should call this function.      */
/*                                                                       */
/* XXX: Will probably disappear soon with all the code range */
/*      management, which is now rather obsolete.            */
/*                                                           */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Run_Context                                                     */
/*                                                                       */
/* <Description>                                                         */
/*    Executes one or more instructions in the execution context.        */
/*                                                                       */
/* <Input>                                                               */
/*    debug :: A Boolean flag.  If set, the function sets some internal  */
/*             variables and returns immediately, otherwise TT_RunIns()  */
/*             is called.                                                */
/*                                                                       */
/*             This is commented out currently.                          */
/*                                                                       */
/* <Input>                                                               */
/*    exec  :: A handle to the target execution context.                 */
/*                                                                       */
/* <Return>                                                              */
/*    TrueType error code.  0 means success.                             */
/*                                                                       */
/* <Note>                                                                */
/*    Only the glyph loader and debugger should call this function.      */
/*                                                                       */
/* some glyphs leave something on the stack. so we clean it */
/* before a new execution.                                  */
/* The default value for `scan_control' is documented as FALSE in the */
/* TrueType specification.  This is confusing since it implies a      */
/* Boolean value.  However, this is not the case, thus both the       */
/* default values of our `scan_type' and `scan_control' fields (which */
/* the documentation's `scan_control' variable is split into) are     */
/* zero.                                                              */
/* documentation is in ttinterp.h */
/* allocate object */
/* initialize it; in case of error this deallocates `exec' too */
/* store it into the driver */
/*************************************************************************/
/*                                                                       */
/* Before an opcode is executed, the interpreter verifies that there are */
/* enough arguments on the stack, with the help of the `Pop_Push_Count'  */
/* table.                                                                */
/*                                                                       */
/* For each opcode, the first column gives the number of arguments that  */
/* are popped from the stack; the second one gives the number of those   */
/* that are pushed in result.                                            */
/*                                                                       */
/* Opcodes which have a varying number of parameters in the data stream  */
/* (NPUSHB, NPUSHW) are handled specially; they have a negative value in */
/* the `opcode_length' table, and the value in `Pop_Push_Count' is set   */
/* to zero.                                                              */
/*                                                                       */
/*************************************************************************/
/* opcodes are gathered in groups of 16 */
/* please keep the spaces as they are   */
/*  SVTCA  y  */  PACK( 0, 0 ),
/*  SVTCA  x  */  PACK( 0, 0 ),
/*  SPvTCA y  */  PACK( 0, 0 ),
/*  SPvTCA x  */  PACK( 0, 0 ),
/*  SFvTCA y  */  PACK( 0, 0 ),
/*  SFvTCA x  */  PACK( 0, 0 ),
//  */  PACK( 2, 0 ),
/*  SPvTL //  */  PACK( 2, 0 ),
/*  SPvTL +   */  PACK( 2, 0 ),
//  */  PACK( 2, 0 ),
/*  SFvTL //  */  PACK( 2, 0 ),
/*  SFvTL +   */  PACK( 2, 0 ),
/*  SPvFS     */  PACK( 2, 0 ),
/*  SFvFS     */  PACK( 2, 0 ),
/*  GPV       */  PACK( 0, 2 ),
/*  GFV       */  PACK( 0, 2 ),
/*  SFvTPv    */  PACK( 0, 0 ),
/*  ISECT     */  PACK( 5, 0 ),
/*  SRP0      */  PACK( 1, 0 ),
/*  SRP1      */  PACK( 1, 0 ),
/*  SRP2      */  PACK( 1, 0 ),
/*  SZP0      */  PACK( 1, 0 ),
/*  SZP1      */  PACK( 1, 0 ),
/*  SZP2      */  PACK( 1, 0 ),
/*  SZPS      */  PACK( 1, 0 ),
/*  SLOOP     */  PACK( 1, 0 ),
/*  RTG       */  PACK( 0, 0 ),
/*  RTHG      */  PACK( 0, 0 ),
/*  SMD       */  PACK( 1, 0 ),
/*  ELSE      */  PACK( 0, 0 ),
/*  JMPR      */  PACK( 1, 0 ),
/*  SCvTCi    */  PACK( 1, 0 ),
/*  SSwCi     */  PACK( 1, 0 ),
/*  SSW       */  PACK( 1, 0 ),
/*  DUP       */  PACK( 1, 2 ),
/*  POP       */  PACK( 1, 0 ),
/*  CLEAR     */  PACK( 0, 0 ),
/*  SWAP      */  PACK( 2, 2 ),
/*  DEPTH     */  PACK( 0, 1 ),
/*  CINDEX    */  PACK( 1, 1 ),
/*  MINDEX    */  PACK( 1, 0 ),
/*  AlignPTS  */  PACK( 2, 0 ),
/*  INS_$28   */  PACK( 0, 0 ),
/*  UTP       */  PACK( 1, 0 ),
/*  LOOPCALL  */  PACK( 2, 0 ),
/*  CALL      */  PACK( 1, 0 ),
/*  FDEF      */  PACK( 1, 0 ),
/*  ENDF      */  PACK( 0, 0 ),
/*  MDAP[0]   */  PACK( 1, 0 ),
/*  MDAP[1]   */  PACK( 1, 0 ),
/*  IUP[0]    */  PACK( 0, 0 ),
/*  IUP[1]    */  PACK( 0, 0 ),
/*  SHP[0]    */  PACK( 0, 0 ),
/*  SHP[1]    */  PACK( 0, 0 ),
/*  SHC[0]    */  PACK( 1, 0 ),
/*  SHC[1]    */  PACK( 1, 0 ),
/*  SHZ[0]    */  PACK( 1, 0 ),
/*  SHZ[1]    */  PACK( 1, 0 ),
/*  SHPIX     */  PACK( 1, 0 ),
/*  IP        */  PACK( 0, 0 ),
/*  MSIRP[0]  */  PACK( 2, 0 ),
/*  MSIRP[1]  */  PACK( 2, 0 ),
/*  AlignRP   */  PACK( 0, 0 ),
/*  RTDG      */  PACK( 0, 0 ),
/*  MIAP[0]   */  PACK( 2, 0 ),
/*  MIAP[1]   */  PACK( 2, 0 ),
/*  NPushB    */  PACK( 0, 0 ),
/*  NPushW    */  PACK( 0, 0 ),
/*  WS        */  PACK( 2, 0 ),
/*  RS        */  PACK( 1, 1 ),
/*  WCvtP     */  PACK( 2, 0 ),
/*  RCvt      */  PACK( 1, 1 ),
/*  GC[0]     */  PACK( 1, 1 ),
/*  GC[1]     */  PACK( 1, 1 ),
/*  SCFS      */  PACK( 2, 0 ),
/*  MD[0]     */  PACK( 2, 1 ),
/*  MD[1]     */  PACK( 2, 1 ),
/*  MPPEM     */  PACK( 0, 1 ),
/*  MPS       */  PACK( 0, 1 ),
/*  FlipON    */  PACK( 0, 0 ),
/*  FlipOFF   */  PACK( 0, 0 ),
/*  DEBUG     */  PACK( 1, 0 ),
/*  LT        */  PACK( 2, 1 ),
/*  LTEQ      */  PACK( 2, 1 ),
/*  GT        */  PACK( 2, 1 ),
/*  GTEQ      */  PACK( 2, 1 ),
/*  EQ        */  PACK( 2, 1 ),
/*  NEQ       */  PACK( 2, 1 ),
/*  ODD       */  PACK( 1, 1 ),
/*  EVEN      */  PACK( 1, 1 ),
/*  IF        */  PACK( 1, 0 ),
/*  EIF       */  PACK( 0, 0 ),
/*  AND       */  PACK( 2, 1 ),
/*  OR        */  PACK( 2, 1 ),
/*  NOT       */  PACK( 1, 1 ),
/*  DeltaP1   */  PACK( 1, 0 ),
/*  SDB       */  PACK( 1, 0 ),
/*  SDS       */  PACK( 1, 0 ),
/*  ADD       */  PACK( 2, 1 ),
/*  SUB       */  PACK( 2, 1 ),
/*  DIV       */  PACK( 2, 1 ),
/*  MUL       */  PACK( 2, 1 ),
/*  ABS       */  PACK( 1, 1 ),
/*  NEG       */  PACK( 1, 1 ),
/*  FLOOR     */  PACK( 1, 1 ),
/*  CEILING   */  PACK( 1, 1 ),
/*  ROUND[0]  */  PACK( 1, 1 ),
/*  ROUND[1]  */  PACK( 1, 1 ),
/*  ROUND[2]  */  PACK( 1, 1 ),
/*  ROUND[3]  */  PACK( 1, 1 ),
/*  NROUND[0] */  PACK( 1, 1 ),
/*  NROUND[1] */  PACK( 1, 1 ),
/*  NROUND[2] */  PACK( 1, 1 ),
/*  NROUND[3] */  PACK( 1, 1 ),
/*  WCvtF     */  PACK( 2, 0 ),
/*  DeltaP2   */  PACK( 1, 0 ),
/*  DeltaP3   */  PACK( 1, 0 ),
/*  DeltaCn[0] */ PACK( 1, 0 ),
/*  DeltaCn[1] */ PACK( 1, 0 ),
/*  DeltaCn[2] */ PACK( 1, 0 ),
/*  SROUND    */  PACK( 1, 0 ),
/*  S45Round  */  PACK( 1, 0 ),
/*  JROT      */  PACK( 2, 0 ),
/*  JROF      */  PACK( 2, 0 ),
/*  ROFF      */  PACK( 0, 0 ),
/*  INS_$7B   */  PACK( 0, 0 ),
/*  RUTG      */  PACK( 0, 0 ),
/*  RDTG      */  PACK( 0, 0 ),
/*  SANGW     */  PACK( 1, 0 ),
/*  AA        */  PACK( 1, 0 ),
/*  FlipPT    */  PACK( 0, 0 ),
/*  FlipRgON  */  PACK( 2, 0 ),
/*  FlipRgOFF */  PACK( 2, 0 ),
/*  INS_$83   */  PACK( 0, 0 ),
/*  INS_$84   */  PACK( 0, 0 ),
/*  ScanCTRL  */  PACK( 1, 0 ),
/*  SDPVTL[0] */  PACK( 2, 0 ),
/*  SDPVTL[1] */  PACK( 2, 0 ),
/*  GetINFO   */  PACK( 1, 1 ),
/*  IDEF      */  PACK( 1, 0 ),
/*  ROLL      */  PACK( 3, 3 ),
/*  MAX       */  PACK( 2, 1 ),
/*  MIN       */  PACK( 2, 1 ),
/*  ScanTYPE  */  PACK( 1, 0 ),
/*  InstCTRL  */  PACK( 2, 0 ),
/*  INS_$8F   */  PACK( 0, 0 ),
/*  INS_$90  */   PACK( 0, 0 ),
/*  INS_$91  */   PACK( 0, 0 ),
/*  INS_$92  */   PACK( 0, 0 ),
/*  INS_$93  */   PACK( 0, 0 ),
/*  INS_$94  */   PACK( 0, 0 ),
/*  INS_$95  */   PACK( 0, 0 ),
/*  INS_$96  */   PACK( 0, 0 ),
/*  INS_$97  */   PACK( 0, 0 ),
/*  INS_$98  */   PACK( 0, 0 ),
/*  INS_$99  */   PACK( 0, 0 ),
/*  INS_$9A  */   PACK( 0, 0 ),
/*  INS_$9B  */   PACK( 0, 0 ),
/*  INS_$9C  */   PACK( 0, 0 ),
/*  INS_$9D  */   PACK( 0, 0 ),
/*  INS_$9E  */   PACK( 0, 0 ),
/*  INS_$9F  */   PACK( 0, 0 ),
/*  INS_$A0  */   PACK( 0, 0 ),
/*  INS_$A1  */   PACK( 0, 0 ),
/*  INS_$A2  */   PACK( 0, 0 ),
/*  INS_$A3  */   PACK( 0, 0 ),
/*  INS_$A4  */   PACK( 0, 0 ),
/*  INS_$A5  */   PACK( 0, 0 ),
/*  INS_$A6  */   PACK( 0, 0 ),
/*  INS_$A7  */   PACK( 0, 0 ),
/*  INS_$A8  */   PACK( 0, 0 ),
/*  INS_$A9  */   PACK( 0, 0 ),
/*  INS_$AA  */   PACK( 0, 0 ),
/*  INS_$AB  */   PACK( 0, 0 ),
/*  INS_$AC  */   PACK( 0, 0 ),
/*  INS_$AD  */   PACK( 0, 0 ),
/*  INS_$AE  */   PACK( 0, 0 ),
/*  INS_$AF  */   PACK( 0, 0 ),
/*  PushB[0]  */  PACK( 0, 1 ),
/*  PushB[1]  */  PACK( 0, 2 ),
/*  PushB[2]  */  PACK( 0, 3 ),
/*  PushB[3]  */  PACK( 0, 4 ),
/*  PushB[4]  */  PACK( 0, 5 ),
/*  PushB[5]  */  PACK( 0, 6 ),
/*  PushB[6]  */  PACK( 0, 7 ),
/*  PushB[7]  */  PACK( 0, 8 ),
/*  PushW[0]  */  PACK( 0, 1 ),
/*  PushW[1]  */  PACK( 0, 2 ),
/*  PushW[2]  */  PACK( 0, 3 ),
/*  PushW[3]  */  PACK( 0, 4 ),
/*  PushW[4]  */  PACK( 0, 5 ),
/*  PushW[5]  */  PACK( 0, 6 ),
/*  PushW[6]  */  PACK( 0, 7 ),
/*  PushW[7]  */  PACK( 0, 8 ),
/*  MDRP[00]  */  PACK( 1, 0 ),
/*  MDRP[01]  */  PACK( 1, 0 ),
/*  MDRP[02]  */  PACK( 1, 0 ),
/*  MDRP[03]  */  PACK( 1, 0 ),
/*  MDRP[04]  */  PACK( 1, 0 ),
/*  MDRP[05]  */  PACK( 1, 0 ),
/*  MDRP[06]  */  PACK( 1, 0 ),
/*  MDRP[07]  */  PACK( 1, 0 ),
/*  MDRP[08]  */  PACK( 1, 0 ),
/*  MDRP[09]  */  PACK( 1, 0 ),
/*  MDRP[10]  */  PACK( 1, 0 ),
/*  MDRP[11]  */  PACK( 1, 0 ),
/*  MDRP[12]  */  PACK( 1, 0 ),
/*  MDRP[13]  */  PACK( 1, 0 ),
/*  MDRP[14]  */  PACK( 1, 0 ),
/*  MDRP[15]  */  PACK( 1, 0 ),
/*  MDRP[16]  */  PACK( 1, 0 ),
/*  MDRP[17]  */  PACK( 1, 0 ),
/*  MDRP[18]  */  PACK( 1, 0 ),
/*  MDRP[19]  */  PACK( 1, 0 ),
/*  MDRP[20]  */  PACK( 1, 0 ),
/*  MDRP[21]  */  PACK( 1, 0 ),
/*  MDRP[22]  */  PACK( 1, 0 ),
/*  MDRP[23]  */  PACK( 1, 0 ),
/*  MDRP[24]  */  PACK( 1, 0 ),
/*  MDRP[25]  */  PACK( 1, 0 ),
/*  MDRP[26]  */  PACK( 1, 0 ),
/*  MDRP[27]  */  PACK( 1, 0 ),
/*  MDRP[28]  */  PACK( 1, 0 ),
/*  MDRP[29]  */  PACK( 1, 0 ),
/*  MDRP[30]  */  PACK( 1, 0 ),
/*  MDRP[31]  */  PACK( 1, 0 ),
/*  MIRP[00]  */  PACK( 2, 0 ),
/*  MIRP[01]  */  PACK( 2, 0 ),
/*  MIRP[02]  */  PACK( 2, 0 ),
/*  MIRP[03]  */  PACK( 2, 0 ),
/*  MIRP[04]  */  PACK( 2, 0 ),
/*  MIRP[05]  */  PACK( 2, 0 ),
/*  MIRP[06]  */  PACK( 2, 0 ),
/*  MIRP[07]  */  PACK( 2, 0 ),
/*  MIRP[08]  */  PACK( 2, 0 ),
/*  MIRP[09]  */  PACK( 2, 0 ),
/*  MIRP[10]  */  PACK( 2, 0 ),
/*  MIRP[11]  */  PACK( 2, 0 ),
/*  MIRP[12]  */  PACK( 2, 0 ),
/*  MIRP[13]  */  PACK( 2, 0 ),
/*  MIRP[14]  */  PACK( 2, 0 ),
/*  MIRP[15]  */  PACK( 2, 0 ),
/*  MIRP[16]  */  PACK( 2, 0 ),
/*  MIRP[17]  */  PACK( 2, 0 ),
/*  MIRP[18]  */  PACK( 2, 0 ),
/*  MIRP[19]  */  PACK( 2, 0 ),
/*  MIRP[20]  */  PACK( 2, 0 ),
/*  MIRP[21]  */  PACK( 2, 0 ),
/*  MIRP[22]  */  PACK( 2, 0 ),
/*  MIRP[23]  */  PACK( 2, 0 ),
/*  MIRP[24]  */  PACK( 2, 0 ),
/*  MIRP[25]  */  PACK( 2, 0 ),
/*  MIRP[26]  */  PACK( 2, 0 ),
/*  MIRP[27]  */  PACK( 2, 0 ),
/*  MIRP[28]  */  PACK( 2, 0 ),
/*  MIRP[29]  */  PACK( 2, 0 ),
/*  MIRP[30]  */  PACK( 2, 0 ),
/*  MIRP[31]  */  PACK( 2, 0 )
/* FT_DEBUG_LEVEL_TRACE */
/* (lo=t2,hi=t) = a*b */
/* a   = (hi >> 31) */
/* a  += 0x2000 */
/* t2 += a */
/* t  += carry */
/* a   = t2 >> 14 */
/* a  |= t << 18 */
/* (lo=%1,hi=%2) = a*b */
/* %0  = (hi >> 31) */
/* %0 += 0x2000 */
/* %0 += 0x2000 */
/* %1 += %0 */
/* %2 += carry */
/* %0  = %1 >> 16 */
/* %0 |= %2 << 16 */
/* __arm__ && ( __thumb2__ || !__thumb__ ) */
/* !FT_CONFIG_OPTION_NO_ASSEMBLER */
/* Temporarily disable the warning that C90 doesn't support `long long'. */
/* This is declared `noinline' because inlining the function results */
/* in slower code.  The `pure' attribute indicates that the result   */
/* only depends on the parameters.                                   */
/* The following line assumes that right shifting of signed values */
/* will actually preserve the sign bit.  The exact behaviour is    */
/* undefined, but this is true on x86 and x86_64.                  */
/* __GNUC__ && ( __i386__ || __x86_64__ ) */
/* Compute (a*b)/2^14 with maximum accuracy and rounding.  */
/* This is optimized to be faster than calling FT_MulFix() */
/* for platforms where sizeof(int) == 2.                   */
/* rounding */
/* !TT_MulFix14 */
/* Temporarily disable the warning that C90 doesn't support */
/* `long long'.                                             */
/* __GNUC__ && (__arm__ || __i386__ || __x86_64__) */
/* compute (ax*bx+ay*by)/2^14 with maximum accuracy and rounding */
/* compute ax*bx as 64-bit value */
/* compute ay*by as 64-bit value */
/* add them */
/* divide the result by 2^14 with rounding */
/* TT_DotFix14 */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Current_Ratio                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Returns the current aspect ratio scaling factor depending on the   */
/*    projection vector's state and device resolutions.                  */
/*                                                                       */
/* <Return>                                                              */
/*    The aspect ratio in 16.16 format, always <= 1.0 .                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* Functions related to the control value table (CVT).                   */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    GetShortIns                                                        */
/*                                                                       */
/* <Description>                                                         */
/*    Returns a short integer taken from the instruction stream at       */
/*    address IP.                                                        */
/*                                                                       */
/* <Return>                                                              */
/*    Short read at code[IP].                                            */
/*                                                                       */
/* <Note>                                                                */
/*    This one could become a macro.                                     */
/*                                                                       */
/* Reading a byte stream so there is no endianess (DaveP) */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Ins_Goto_CodeRange                                                 */
/*                                                                       */
/* <Description>                                                         */
/*    Goes to a certain code range in the instruction stream.            */
/*                                                                       */
/* <Input>                                                               */
/*    aRange :: The index of the code range.                             */
/*                                                                       */
/*    aIP    :: The new IP address in the code range.                    */
/*                                                                       */
/* <Return>                                                              */
/*    SUCCESS or FAILURE.                                                */
/*                                                                       */
/* invalid coderange */
/* NOTE: Because the last instruction of a program may be a CALL */
/*       which will return to the first byte *after* the code    */
/*       range, we test for aIP <= Size, instead of aIP < Size.  */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Direct_Move                                                        */
/*                                                                       */
/* <Description>                                                         */
/*    Moves a point by a given distance along the freedom vector.  The   */
/*    point will be `touched'.                                           */
/*                                                                       */
/* <Input>                                                               */
/*    point    :: The index of the point to move.                        */
/*                                                                       */
/*    distance :: The distance to apply.                                 */
/*                                                                       */
/* <InOut>                                                               */
/*    zone     :: The affected glyph zone.                               */
/*                                                                       */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Direct_Move_Orig                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Moves the *original* position of a point by a given distance along */
/*    the freedom vector.  Obviously, the point will not be `touched'.   */
/*                                                                       */
/* <Input>                                                               */
/*    point    :: The index of the point to move.                        */
/*                                                                       */
/*    distance :: The distance to apply.                                 */
/*                                                                       */
/* <InOut>                                                               */
/*    zone     :: The affected glyph zone.                               */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* Special versions of Direct_Move()                                     */
/*                                                                       */
/*   The following versions are used whenever both vectors are both      */
/*   along one of the coordinate unit vectors, i.e. in 90% of the cases. */
/*                                                                       */
/*************************************************************************/
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/*************************************************************************/
/*                                                                       */
/* Special versions of Direct_Move_Orig()                                */
/*                                                                       */
/*   The following versions are used whenever both vectors are both      */
/*   along one of the coordinate unit vectors, i.e. in 90% of the cases. */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Round_None                                                         */
/*                                                                       */
/* <Description>                                                         */
/*    Does not round, but adds engine compensation.                      */
/*                                                                       */
/* <Input>                                                               */
/*    distance     :: The distance (not) to round.                       */
/*                                                                       */
/*    compensation :: The engine compensation.                           */
/*                                                                       */
/* <Return>                                                              */
/*    The compensated distance.                                          */
/*                                                                       */
/* <Note>                                                                */
/*    The TrueType specification says very few about the relationship    */
/*    between rounding and engine compensation.  However, it seems from  */
/*    the description of super round that we should add the compensation */
/*    before rounding.                                                   */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Round_To_Grid                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Rounds value to grid after adding engine compensation.             */
/*                                                                       */
/* <Input>                                                               */
/*    distance     :: The distance to round.                             */
/*                                                                       */
/*    compensation :: The engine compensation.                           */
/*                                                                       */
/* <Return>                                                              */
/*    Rounded distance.                                                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Round_To_Half_Grid                                                 */
/*                                                                       */
/* <Description>                                                         */
/*    Rounds value to half grid after adding engine compensation.        */
/*                                                                       */
/* <Input>                                                               */
/*    distance     :: The distance to round.                             */
/*                                                                       */
/*    compensation :: The engine compensation.                           */
/*                                                                       */
/* <Return>                                                              */
/*    Rounded distance.                                                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Round_Down_To_Grid                                                 */
/*                                                                       */
/* <Description>                                                         */
/*    Rounds value down to grid after adding engine compensation.        */
/*                                                                       */
/* <Input>                                                               */
/*    distance     :: The distance to round.                             */
/*                                                                       */
/*    compensation :: The engine compensation.                           */
/*                                                                       */
/* <Return>                                                              */
/*    Rounded distance.                                                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Round_Up_To_Grid                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Rounds value up to grid after adding engine compensation.          */
/*                                                                       */
/* <Input>                                                               */
/*    distance     :: The distance to round.                             */
/*                                                                       */
/*    compensation :: The engine compensation.                           */
/*                                                                       */
/* <Return>                                                              */
/*    Rounded distance.                                                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Round_To_Double_Grid                                               */
/*                                                                       */
/* <Description>                                                         */
/*    Rounds value to double grid after adding engine compensation.      */
/*                                                                       */
/* <Input>                                                               */
/*    distance     :: The distance to round.                             */
/*                                                                       */
/*    compensation :: The engine compensation.                           */
/*                                                                       */
/* <Return>                                                              */
/*    Rounded distance.                                                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Round_Super                                                        */
/*                                                                       */
/* <Description>                                                         */
/*    Super-rounds value to grid after adding engine compensation.       */
/*                                                                       */
/* <Input>                                                               */
/*    distance     :: The distance to round.                             */
/*                                                                       */
/*    compensation :: The engine compensation.                           */
/*                                                                       */
/* <Return>                                                              */
/*    Rounded distance.                                                  */
/*                                                                       */
/* <Note>                                                                */
/*    The TrueType specification says very few about the relationship    */
/*    between rounding and engine compensation.  However, it seems from  */
/*    the description of super round that we should add the compensation */
/*    before rounding.                                                   */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Round_Super_45                                                     */
/*                                                                       */
/* <Description>                                                         */
/*    Super-rounds value to grid after adding engine compensation.       */
/*                                                                       */
/* <Input>                                                               */
/*    distance     :: The distance to round.                             */
/*                                                                       */
/*    compensation :: The engine compensation.                           */
/*                                                                       */
/* <Return>                                                              */
/*    Rounded distance.                                                  */
/*                                                                       */
/* <Note>                                                                */
/*    There is a separate function for Round_Super_45() as we may need   */
/*    greater precision.                                                 */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Compute_Round                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Sets the rounding mode.                                            */
/*                                                                       */
/* <Input>                                                               */
/*    round_mode :: The rounding mode to be used.                        */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    SetSuperRound                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Sets Super Round parameters.                                       */
/*                                                                       */
/* <Input>                                                               */
/*    GridPeriod :: The grid period.                                     */
/*                                                                       */
/*    selector   :: The SROUND opcode.                                   */
/*                                                                       */
/* This opcode is reserved, but... */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Project                                                            */
/*                                                                       */
/* <Description>                                                         */
/*    Computes the projection of vector given by (v2-v1) along the       */
/*    current projection vector.                                         */
/*                                                                       */
/* <Input>                                                               */
/*    v1 :: First input vector.                                          */
/*    v2 :: Second input vector.                                         */
/*                                                                       */
/* <Return>                                                              */
/*    The distance in F26dot6 format.                                    */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Dual_Project                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    Computes the projection of the vector given by (v2-v1) along the   */
/*    current dual vector.                                               */
/*                                                                       */
/* <Input>                                                               */
/*    v1 :: First input vector.                                          */
/*    v2 :: Second input vector.                                         */
/*                                                                       */
/* <Return>                                                              */
/*    The distance in F26dot6 format.                                    */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Project_x                                                          */
/*                                                                       */
/* <Description>                                                         */
/*    Computes the projection of the vector given by (v2-v1) along the   */
/*    horizontal axis.                                                   */
/*                                                                       */
/* <Input>                                                               */
/*    v1 :: First input vector.                                          */
/*    v2 :: Second input vector.                                         */
/*                                                                       */
/* <Return>                                                              */
/*    The distance in F26dot6 format.                                    */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Project_y                                                          */
/*                                                                       */
/* <Description>                                                         */
/*    Computes the projection of the vector given by (v2-v1) along the   */
/*    vertical axis.                                                     */
/*                                                                       */
/* <Input>                                                               */
/*    v1 :: First input vector.                                          */
/*    v2 :: Second input vector.                                         */
/*                                                                       */
/* <Return>                                                              */
/*    The distance in F26dot6 format.                                    */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Compute_Funcs                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Computes the projection and movement function pointers according   */
/*    to the current graphics state.                                     */
/*                                                                       */
/* If both vectors point rightwards along the x axis, set             */
/* `both-x-axis' true, otherwise set it false.  The x values only     */
/* need be tested because the vector has been normalised to a unit    */
/* vector of length 0x4000 = unity.                                   */
/* Throw away projection and freedom vector information */
/* because the patents don't allow them to be stored.   */
/* The relevant US Patents are 5155805 and 5325479.     */
/* Force recalculation of cached aspect ratio */
/* TT_CONFIG_OPTION_UNPATENTED_HINTING */
/* at small sizes, F_dot_P can become too small, resulting   */
/* in overflows and `spikes' in a number of glyphs like `w'. */
/* Disable cached aspect ratio */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Normalize                                                          */
/*                                                                       */
/* <Description>                                                         */
/*    Norms a vector.                                                    */
/*                                                                       */
/* <Input>                                                               */
/*    Vx :: The horizontal input vector coordinate.                      */
/*    Vy :: The vertical input vector coordinate.                        */
/*                                                                       */
/* <Output>                                                              */
/*    R  :: The normed unit vector.                                      */
/*                                                                       */
/* <Return>                                                              */
/*    Returns FAILURE if a vector parameter is zero.                     */
/*                                                                       */
/* <Note>                                                                */
/*    In case Vx and Vy are both zero, Normalize() returns SUCCESS, and  */
/*    R is undefined.                                                    */
/*                                                                       */
/* XXX: UNDOCUMENTED! It seems that it is possible to try   */
/*      to normalize the vector (0,0).  Return immediately. */
/*************************************************************************/
/*                                                                       */
/* Here we start with the implementation of the various opcodes.         */
/*                                                                       */
/*************************************************************************/
/* If p1 == p2, SPVTL and SFVTL behave the same as */
/* SPVTCA[X] and SFVTCA[X], respectively.          */
/*                                                 */
/* Confirmed by Greg Hitchcock.                    */
/* counter clockwise rotation */
/* When not using the big switch statements, the interpreter uses a */
/* call table defined later below in this source.  Each opcode must */
/* thus have a corresponding function, even trivial ones.           */
/*                                                                  */
/* They are all defined there.                                      */
/* Only use low 16bits, then sign extend */ \
/* Only use low 16bits, then sign extend */ \
/* nothing */
/* Note: The pointSize should be irrelevant in a given font program; */
/*       we thus decide to return only the ppem.                     */
/* 0 */
/* subpixel hinting - avoid Typeman Dstroke and */ \
/* IStroke and Vacuform rounds                  */ \
/* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/*************************************************************************/
/*                                                                       */
/* SVTCA[a]:     Set (F and P) Vectors to Coordinate Axis                */
/* Opcode range: 0x00-0x01                                               */
/* Stack:        -->                                                     */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SPVTCA[a]:    Set PVector to Coordinate Axis                          */
/* Opcode range: 0x02-0x03                                               */
/* Stack:        -->                                                     */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SFVTCA[a]:    Set FVector to Coordinate Axis                          */
/* Opcode range: 0x04-0x05                                               */
/* Stack:        -->                                                     */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SPVTL[a]:     Set PVector To Line                                     */
/* Opcode range: 0x06-0x07                                               */
/* Stack:        uint32 uint32 -->                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SFVTL[a]:     Set FVector To Line                                     */
/* Opcode range: 0x08-0x09                                               */
/* Stack:        uint32 uint32 -->                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SFVTPV[]:     Set FVector To PVector                                  */
/* Opcode range: 0x0E                                                    */
/* Stack:        -->                                                     */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SPVFS[]:      Set PVector From Stack                                  */
/* Opcode range: 0x0A                                                    */
/* Stack:        f2.14 f2.14 -->                                         */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SFVFS[]:      Set FVector From Stack                                  */
/* Opcode range: 0x0B                                                    */
/* Stack:        f2.14 f2.14 -->                                         */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* GPV[]:        Get Projection Vector                                   */
/* Opcode range: 0x0C                                                    */
/* Stack:        ef2.14 --> ef2.14                                       */
/*                                                                       */
/*************************************************************************/
/* GFV[]:        Get Freedom Vector                                      */
/* Opcode range: 0x0D                                                    */
/* Stack:        ef2.14 --> ef2.14                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SRP0[]:       Set Reference Point 0                                   */
/* Opcode range: 0x10                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SRP1[]:       Set Reference Point 1                                   */
/* Opcode range: 0x11                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SRP2[]:       Set Reference Point 2                                   */
/* Opcode range: 0x12                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* RTHG[]:       Round To Half Grid                                      */
/* Opcode range: 0x19                                                    */
/* Stack:        -->                                                     */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* RTG[]:        Round To Grid                                           */
/* Opcode range: 0x18                                                    */
/* Stack:        -->                                                     */
/*                                                                       */
/*************************************************************************/
/* RTDG[]:       Round To Double Grid                                    */
/* Opcode range: 0x3D                                                    */
/* Stack:        -->                                                     */
/*                                                                       */
/*************************************************************************/
/* RUTG[]:       Round Up To Grid                                        */
/* Opcode range: 0x7C                                                    */
/* Stack:        -->                                                     */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* RDTG[]:       Round Down To Grid                                      */
/* Opcode range: 0x7D                                                    */
/* Stack:        -->                                                     */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* ROFF[]:       Round OFF                                               */
/* Opcode range: 0x7A                                                    */
/* Stack:        -->                                                     */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SROUND[]:     Super ROUND                                             */
/* Opcode range: 0x76                                                    */
/* Stack:        Eint8 -->                                               */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* S45ROUND[]:   Super ROUND 45 degrees                                  */
/* Opcode range: 0x77                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SLOOP[]:      Set LOOP variable                                       */
/* Opcode range: 0x17                                                    */
/* Stack:        int32? -->                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SMD[]:        Set Minimum Distance                                    */
/* Opcode range: 0x1A                                                    */
/* Stack:        f26.6 -->                                               */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SCVTCI[]:     Set Control Value Table Cut In                          */
/* Opcode range: 0x1D                                                    */
/* Stack:        f26.6 -->                                               */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SSWCI[]:      Set Single Width Cut In                                 */
/* Opcode range: 0x1E                                                    */
/* Stack:        f26.6 -->                                               */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SSW[]:        Set Single Width                                        */
/* Opcode range: 0x1F                                                    */
/* Stack:        int32? -->                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* FLIPON[]:     Set auto-FLIP to ON                                     */
/* Opcode range: 0x4D                                                    */
/* Stack:        -->                                                     */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* FLIPOFF[]:    Set auto-FLIP to OFF                                    */
/* Opcode range: 0x4E                                                    */
/* Stack: -->                                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SANGW[]:      Set ANGle Weight                                        */
/* Opcode range: 0x7E                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/* instruction not supported anymore */
/*************************************************************************/
/*                                                                       */
/* SDB[]:        Set Delta Base                                          */
/* Opcode range: 0x5E                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SDS[]:        Set Delta Shift                                         */
/* Opcode range: 0x5F                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* MPPEM[]:      Measure Pixel Per EM                                    */
/* Opcode range: 0x4B                                                    */
/* Stack:        --> Euint16                                             */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* MPS[]:        Measure Point Size                                      */
/* Opcode range: 0x4C                                                    */
/* Stack:        --> Euint16                                             */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* DUP[]:        DUPlicate the top stack's element                       */
/* Opcode range: 0x20                                                    */
/* Stack:        StkElt --> StkElt StkElt                                */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* POP[]:        POP the stack's top element                             */
/* Opcode range: 0x21                                                    */
/* Stack:        StkElt -->                                              */
/*                                                                       */
/* nothing to do */
/*************************************************************************/
/*                                                                       */
/* CLEAR[]:      CLEAR the entire stack                                  */
/* Opcode range: 0x22                                                    */
/* Stack:        StkElt... -->                                           */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SWAP[]:       SWAP the stack's top two elements                       */
/* Opcode range: 0x23                                                    */
/* Stack:        2 * StkElt --> 2 * StkElt                               */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* DEPTH[]:      return the stack DEPTH                                  */
/* Opcode range: 0x24                                                    */
/* Stack:        --> uint32                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* CINDEX[]:     Copy INDEXed element                                    */
/* Opcode range: 0x25                                                    */
/* Stack:        int32 --> StkElt                                        */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* EIF[]:        End IF                                                  */
/* Opcode range: 0x59                                                    */
/* Stack:        -->                                                     */
/*                                                                       */
/* nothing to do */
/*************************************************************************/
/*                                                                       */
/* JROT[]:       Jump Relative On True                                   */
/* Opcode range: 0x78                                                    */
/* Stack:        StkElt int32 -->                                        */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* JMPR[]:       JuMP Relative                                           */
/* Opcode range: 0x1C                                                    */
/* Stack:        int32 -->                                               */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* JROF[]:       Jump Relative On False                                  */
/* Opcode range: 0x79                                                    */
/* Stack:        StkElt int32 -->                                        */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* LT[]:         Less Than                                               */
/* Opcode range: 0x50                                                    */
/* Stack:        int32? int32? --> bool                                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* LTEQ[]:       Less Than or EQual                                      */
/* Opcode range: 0x51                                                    */
/* Stack:        int32? int32? --> bool                                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* GT[]:         Greater Than                                            */
/* Opcode range: 0x52                                                    */
/* Stack:        int32? int32? --> bool                                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* GTEQ[]:       Greater Than or EQual                                   */
/* Opcode range: 0x53                                                    */
/* Stack:        int32? int32? --> bool                                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* EQ[]:         EQual                                                   */
/* Opcode range: 0x54                                                    */
/* Stack:        StkElt StkElt --> bool                                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* NEQ[]:        Not EQual                                               */
/* Opcode range: 0x55                                                    */
/* Stack:        StkElt StkElt --> bool                                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* ODD[]:        Is ODD                                                  */
/* Opcode range: 0x56                                                    */
/* Stack:        f26.6 --> bool                                          */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* EVEN[]:       Is EVEN                                                 */
/* Opcode range: 0x57                                                    */
/* Stack:        f26.6 --> bool                                          */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* AND[]:        logical AND                                             */
/* Opcode range: 0x5A                                                    */
/* Stack:        uint32 uint32 --> uint32                                */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* OR[]:         logical OR                                              */
/* Opcode range: 0x5B                                                    */
/* Stack:        uint32 uint32 --> uint32                                */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* NOT[]:        logical NOT                                             */
/* Opcode range: 0x5C                                                    */
/* Stack:        StkElt --> uint32                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* ADD[]:        ADD                                                     */
/* Opcode range: 0x60                                                    */
/* Stack:        f26.6 f26.6 --> f26.6                                   */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SUB[]:        SUBtract                                                */
/* Opcode range: 0x61                                                    */
/* Stack:        f26.6 f26.6 --> f26.6                                   */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* DIV[]:        DIVide                                                  */
/* Opcode range: 0x62                                                    */
/* Stack:        f26.6 f26.6 --> f26.6                                   */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* MUL[]:        MULtiply                                                */
/* Opcode range: 0x63                                                    */
/* Stack:        f26.6 f26.6 --> f26.6                                   */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* ABS[]:        ABSolute value                                          */
/* Opcode range: 0x64                                                    */
/* Stack:        f26.6 --> f26.6                                         */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* NEG[]:        NEGate                                                  */
/* Opcode range: 0x65                                                    */
/* Stack: f26.6 --> f26.6                                                */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* FLOOR[]:      FLOOR                                                   */
/* Opcode range: 0x66                                                    */
/* Stack:        f26.6 --> f26.6                                         */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* CEILING[]:    CEILING                                                 */
/* Opcode range: 0x67                                                    */
/* Stack:        f26.6 --> f26.6                                         */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* RS[]:         Read Store                                              */
/* Opcode range: 0x43                                                    */
/* Stack:        uint32 --> uint32                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* WS[]:         Write Store                                             */
/* Opcode range: 0x42                                                    */
/* Stack:        uint32 uint32 -->                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* WCVTP[]:      Write CVT in Pixel units                                */
/* Opcode range: 0x44                                                    */
/* Stack:        f26.6 uint32 -->                                        */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* WCVTF[]:      Write CVT in Funits                                     */
/* Opcode range: 0x70                                                    */
/* Stack:        uint32 uint32 -->                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* RCVT[]:       Read CVT                                                */
/* Opcode range: 0x45                                                    */
/* Stack:        uint32 --> f26.6                                        */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* AA[]:         Adjust Angle                                            */
/* Opcode range: 0x7F                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/* intentionally no longer supported */
/*************************************************************************/
/*                                                                       */
/* DEBUG[]:      DEBUG.  Unsupported.                                    */
/* Opcode range: 0x4F                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/* Note: The original instruction pops a value from the stack.           */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* ROUND[ab]:    ROUND value                                             */
/* Opcode range: 0x68-0x6B                                               */
/* Stack:        f26.6 --> f26.6                                         */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* NROUND[ab]:   No ROUNDing of value                                    */
/* Opcode range: 0x6C-0x6F                                               */
/* Stack:        f26.6 --> f26.6                                         */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* MAX[]:        MAXimum                                                 */
/* Opcode range: 0x68                                                    */
/* Stack:        int32? int32? --> int32                                 */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* MIN[]:        MINimum                                                 */
/* Opcode range: 0x69                                                    */
/* Stack:        int32? int32? --> int32                                 */
/*                                                                       */
/* !TT_CONFIG_OPTION_INTERPRETER_SWITCH */
/*************************************************************************/
/*                                                                       */
/* The following functions are called as is within the switch statement. */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* MINDEX[]:     Move INDEXed element                                    */
/* Opcode range: 0x26                                                    */
/* Stack:        int32? --> StkElt                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* ROLL[]:       ROLL top three elements                                 */
/* Opcode range: 0x8A                                                    */
/* Stack:        3 * StkElt --> 3 * StkElt                               */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* MANAGING THE FLOW OF CONTROL                                          */
/*                                                                       */
/*   Instructions appear in the specification's order.                   */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* IF[]:         IF test                                                 */
/* Opcode range: 0x58                                                    */
/* Stack:        StkElt -->                                              */
/*                                                                       */
/* IF */
/* ELSE */
/* EIF */
/*************************************************************************/
/*                                                                       */
/* ELSE[]:       ELSE                                                    */
/* Opcode range: 0x1B                                                    */
/* Stack:        -->                                                     */
/*                                                                       */
/* IF */
/* EIF */
/*************************************************************************/
/*                                                                       */
/* DEFINING AND USING FUNCTIONS AND INSTRUCTIONS                         */
/*                                                                       */
/*   Instructions appear in the specification's order.                   */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* FDEF[]:       Function DEFinition                                     */
/* Opcode range: 0x2C                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/* arguments to opcodes are skipped by `SKIP_Code' */
/* #0 inline delta function 1 */
/* PPEM    */
/* GTEQ    */
/* SWAP    */
/* PPEM    */
/* LTEQ    */
/* AND     */
/* IF      */
/*   SHPIX */
/* ELSE    */
/*   POP   */
/*   POP   */
/* EIF     */
/* #1 inline delta function 2 */
/* PPEM    */
/* EQ      */
/* IF      */
/*   SHPIX */
/* ELSE    */
/*   POP   */
/*   POP   */
/* EIF     */
/* #2 diagonal stroke function */
/* DUP     */
/* DUP     */
/* PUSHB_1 */
/*   1     */
/* ADD     */
/* GC_cur  */
/* PUSHB_1 */
/*   64    */
/* SWAP    */
/* WS      */
/* #3 VacuFormRound function */
/* RCVT    */
/* SWAP    */
/* GC_cur  */
/* ADD     */
/* DUP     */
/* PUSHB_1 */
/*   38    */
/* #4 TTFautohint bytecode (old) */
/* DUP     */
/* ABS     */
/* PUSHB_1 */
/*   32    */
/* ADD     */
/* FLOOR   */
/* SWAP    */
/* PUSHB_1 */
/* #5 spacing function 1 */
/* SVTCA_x */
/* PUSHB_1 */
/*   24    */
/* RS      */
/* IF      */
/* #6 spacing function 2 */
/* SVTCA_x */
/* RTG     */
/* PUSHB_1 */
/*   24    */
/* RS      */
/* IF      */
/* #7 TypeMan Talk DiagEndCtrl function */
/* SVTCA_x */
/* DUP     */
/* PUSHB_1 */
/*   3     */
/* CINDEX  */
/* #8 TypeMan Talk Align */
/* SPVTL   */
/* RDTG    */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* some font programs are broken enough to redefine functions! */
/* We will then parse the current table.                       */
/* check that there is enough room for new functions */
/* Although FDEF takes unsigned 32-bit integer,  */
/* func # must be within unsigned 16-bit integer */
/* We don't know for sure these are typeman functions, */
/* however they are only active when RS 22 is called   */
/* Now skip the whole function definition. */
/* We don't allow nested IDEFS & FDEFs.    */
/* needs to be implemented still */
/* probably not necessary to detect anymore */
/* Set sph_compatibility_mode only when deltas are detected */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* IDEF */
/* FDEF */
/* ENDF */
/*************************************************************************/
/*                                                                       */
/* ENDF[]:       END Function definition                                 */
/* Opcode range: 0x2D                                                    */
/* Stack:        -->                                                     */
/*                                                                       */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* We encountered an ENDF without a call */
/* Loop through the current function */
/* Exit the current call frame.                      */
/* NOTE: If the last instruction of a program is a   */
/*       CALL or LOOPCALL, the return address is     */
/*       always out of the code range.  This is a    */
/*       valid address, and it is why we do not test */
/*       the result of Ins_Goto_CodeRange() here!    */
/*************************************************************************/
/*                                                                       */
/* CALL[]:       CALL function                                           */
/* Opcode range: 0x2B                                                    */
/* Stack:        uint32? -->                                             */
/*                                                                       */
/* first of all, check the index */
/* Except for some old Apple fonts, all functions in a TrueType */
/* font are defined in increasing order, starting from 0.  This */
/* means that we normally have                                  */
/*                                                              */
/*    CUR.maxFunc+1 == CUR.numFDefs                             */
/*    CUR.FDefs[n].opc == n for n in 0..CUR.maxFunc             */
/*                                                              */
/* If this isn't true, we need to look up the function table.   */
/* look up the FDefs table */
/* check that the function is active */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* check the call stack */
/*************************************************************************/
/*                                                                       */
/* LOOPCALL[]:   LOOP and CALL function                                  */
/* Opcode range: 0x2A                                                    */
/* Stack:        uint32? Eint16? -->                                     */
/*                                                                       */
/* first of all, check the index */
/* Except for some old Apple fonts, all functions in a TrueType */
/* font are defined in increasing order, starting from 0.  This */
/* means that we normally have                                  */
/*                                                              */
/*    CUR.maxFunc+1 == CUR.numFDefs                             */
/*    CUR.FDefs[n].opc == n for n in 0..CUR.maxFunc             */
/*                                                              */
/* If this isn't true, we need to look up the function table.   */
/* look up the FDefs table */
/* check that the function is active */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* check stack */
/*************************************************************************/
/*                                                                       */
/* IDEF[]:       Instruction DEFinition                                  */
/* Opcode range: 0x89                                                    */
/* Stack:        Eint8 -->                                               */
/*                                                                       */
/*  First of all, look for the same function in our table */
/* check that there is enough room for a new instruction */
/* opcode must be unsigned 8-bit integer */
/* Now skip the whole function definition. */
/* We don't allow nested IDEFs & FDEFs.    */
/* IDEF */
/* FDEF */
/* ENDF */
/*************************************************************************/
/*                                                                       */
/* PUSHING DATA ONTO THE INTERPRETER STACK                               */
/*                                                                       */
/*   Instructions appear in the specification's order.                   */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* NPUSHB[]:     PUSH N Bytes                                            */
/* Opcode range: 0x40                                                    */
/* Stack:        --> uint32...                                           */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* NPUSHW[]:     PUSH N Words                                            */
/* Opcode range: 0x41                                                    */
/* Stack:        --> int32...                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* PUSHB[abc]:   PUSH Bytes                                              */
/* Opcode range: 0xB0-0xB7                                               */
/* Stack:        --> uint32...                                           */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* PUSHW[abc]:   PUSH Words                                              */
/* Opcode range: 0xB8-0xBF                                               */
/* Stack:        --> int32...                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* MANAGING THE GRAPHICS STATE                                           */
/*                                                                       */
/*  Instructions appear in the specs' order.                             */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* GC[a]:        Get Coordinate projected onto                           */
/* Opcode range: 0x46-0x47                                               */
/* Stack:        uint32 --> f26.6                                        */
/*                                                                       */
/* XXX: UNDOCUMENTED: Measures from the original glyph must be taken     */
/*      along the dual projection vector!                                */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SCFS[]:       Set Coordinate From Stack                               */
/* Opcode range: 0x48                                                    */
/* Stack:        f26.6 uint32 -->                                        */
/*                                                                       */
/* Formula:                                                              */
/*                                                                       */
/*   OA := OA + ( value - OA.p )/( f.p ) * f                             */
/*                                                                       */
/* UNDOCUMENTED!  The MS rasterizer does that with */
/* twilight points (confirmed by Greg Hitchcock)   */
/*************************************************************************/
/*                                                                       */
/* MD[a]:        Measure Distance                                        */
/* Opcode range: 0x49-0x4A                                               */
/* Stack:        uint32 uint32 --> f26.6                                 */
/*                                                                       */
/* XXX: UNDOCUMENTED: Measure taken in the original glyph must be along  */
/*                    the dual projection vector.                        */
/*                                                                       */
/* XXX: UNDOCUMENTED: Flag attributes are inverted!                      */
/*                      0 => measure distance in original outline        */
/*                      1 => measure distance in grid-fitted outline     */
/*                                                                       */
/* XXX: UNDOCUMENTED: `zp0 - zp1', and not `zp2 - zp1!                   */
/*                                                                       */
/* XXX: UNDOCUMENTED: twilight zone special case */
/* this should be faster */
/* Disable Type 2 Vacuform Rounds - e.g. Arial Narrow */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/*************************************************************************/
/*                                                                       */
/* SDPVTL[a]:    Set Dual PVector to Line                                */
/* Opcode range: 0x86-0x87                                               */
/* Stack:        uint32 uint32 -->                                       */
/*                                                                       */
/* was FT_Int in pas type ERROR */
/* If v1 == v2, SDPVTL behaves the same as */
/* SVTCA[X], respectively.                 */
/*                                         */
/* Confirmed by Greg Hitchcock.            */
/* counter clockwise rotation */
/* counter clockwise rotation */
/*************************************************************************/
/*                                                                       */
/* SZP0[]:       Set Zone Pointer 0                                      */
/* Opcode range: 0x13                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SZP1[]:       Set Zone Pointer 1                                      */
/* Opcode range: 0x14                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SZP2[]:       Set Zone Pointer 2                                      */
/* Opcode range: 0x15                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SZPS[]:       Set Zone PointerS                                       */
/* Opcode range: 0x16                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* INSTCTRL[]:   INSTruction ConTRoL                                     */
/* Opcode range: 0x8E                                                    */
/* Stack:        int32 int32 -->                                         */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SCANCTRL[]:   SCAN ConTRoL                                            */
/* Opcode range: 0x85                                                    */
/* Stack:        uint32? -->                                             */
/*                                                                       */
/* Get Threshold */
/*************************************************************************/
/*                                                                       */
/* SCANTYPE[]:   SCAN TYPE                                               */
/* Opcode range: 0x8D                                                    */
/* Stack:        uint32? -->                                             */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* MANAGING OUTLINES                                                     */
/*                                                                       */
/*   Instructions appear in the specification's order.                   */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* FLIPPT[]:     FLIP PoinT                                              */
/* Opcode range: 0x80                                                    */
/* Stack:        uint32... -->                                           */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* FLIPRGON[]:   FLIP RanGe ON                                           */
/* Opcode range: 0x81                                                    */
/* Stack:        uint32 uint32 -->                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* FLIPRGOFF:    FLIP RanGe OFF                                          */
/* Opcode range: 0x82                                                    */
/* Stack:        uint32 uint32 -->                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SHP[a]:       SHift Point by the last point                           */
/* Opcode range: 0x32-0x33                                               */
/* Stack:        uint32... -->                                           */
/*                                                                       */
/* doesn't follow Cleartype spec but produces better result */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/*************************************************************************/
/*                                                                       */
/* SHC[a]:       SHift Contour                                           */
/* Opcode range: 0x34-35                                                 */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/* UNDOCUMENTED: According to Greg Hitchcock, there is one (virtual)     */
/*               contour in the twilight zone, namely contour number     */
/*               zero which includes all points of it.                   */
/*                                                                       */
/* we use the number of points if in the twilight zone */
/*************************************************************************/
/*                                                                       */
/* SHZ[a]:       SHift Zone                                              */
/* Opcode range: 0x36-37                                                 */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/* XXX: UNDOCUMENTED! SHZ doesn't move the phantom points.     */
/*      Twilight zone has no real contours, so use `n_points'. */
/*      Normal zone's `n_points' includes phantoms, so must    */
/*      use end of last contour.                               */
/* XXX: UNDOCUMENTED! SHZ doesn't touch the points */
/*************************************************************************/
/*                                                                       */
/* SHPIX[]:      SHift points by a PIXel amount                          */
/* Opcode range: 0x38                                                    */
/* Stack:        f26.6 uint32... -->                                     */
/*                                                                       */
/*  If not using ignore_x_mode rendering, allow ZP2 move.          */
/*  If inline deltas aren't allowed, skip ZP2 move.                */
/*  If using ignore_x_mode rendering, allow ZP2 point move if:     */
/*   - freedom vector is y and sph_compatibility_mode is off       */
/*   - the glyph is composite and the move is in the Y direction   */
/*   - the glyph is specifically set to allow SHPIX moves          */
/*   - the move is on a previously Y-touched point                 */
/* save point for later comparison */
/* save new point */
/* reverse any disallowed moves */
/* skip post-iup deltas */
/* save new point */
/* reverse any disallowed moves */
/* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/*************************************************************************/
/*                                                                       */
/* MSIRP[a]:     Move Stack Indirect Relative Position                   */
/* Opcode range: 0x3A-0x3B                                               */
/* Stack:        f26.6 uint32 -->                                        */
/*                                                                       */
/* pacify compiler */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* UNDOCUMENTED!  The MS rasterizer does that with */
/* twilight points (confirmed by Greg Hitchcock)   */
/* subpixel hinting - make MSIRP respect CVT cut-in; */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/*************************************************************************/
/*                                                                       */
/* MDAP[a]:      Move Direct Absolute Point                              */
/* Opcode range: 0x2E-0x2F                                               */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* MIAP[a]:      Move Indirect Absolute Point                            */
/* Opcode range: 0x3E-0x3F                                               */
/* Stack:        uint32 uint32 -->                                       */
/*                                                                       */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* UNDOCUMENTED!                                                      */
/*                                                                    */
/* The behaviour of an MIAP instruction is quite different when used  */
/* in the twilight zone.                                              */
/*                                                                    */
/* First, no control value cut-in test is performed as it would fail  */
/* anyway.  Second, the original point, i.e. (org_x,org_y) of         */
/* zp0.point, is set to the absolute, unrounded distance found in the */
/* CVT.                                                               */
/*                                                                    */
/* This is used in the CVT programs of the Microsoft fonts Arial,     */
/* Times, etc., in order to re-adjust some key font heights.  It      */
/* allows the use of the IP instruction in the twilight zone, which   */
/* otherwise would be invalid according to the specification.         */
/*                                                                    */
/* We implement it with a special sequence for the twilight zone.     */
/* This is a bad hack, but it seems to work.                          */
/*                                                                    */
/* Confirmed by Greg Hitchcock.                                       */
/* If in twilight zone */
/* Only adjust if not in sph_compatibility_mode or ignore_x_mode. */
/* Determined via experimentation and may be incorrect...         */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* rounding and control cut-in flag */
/*************************************************************************/
/*                                                                       */
/* MDRP[abcde]:  Move Direct Relative Point                              */
/* Opcode range: 0xC0-0xDF                                               */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* XXX: Is there some undocumented feature while in the */
/*      twilight zone?                                  */
/* XXX: UNDOCUMENTED: twilight zone special case */
/* this should be faster */
/* single width cut-in test */
/* round flag */
/* minimum distance flag */
/* now move the point */
/*************************************************************************/
/*                                                                       */
/* MIRP[abcde]:  Move Indirect Relative Point                            */
/* Opcode range: 0xE0-0xFF                                               */
/* Stack:        int32? uint32 -->                                       */
/*                                                                       */
/* pacify compiler */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* XXX: UNDOCUMENTED! cvt[-1] = 0 always */
/* single width test */
/* UNDOCUMENTED!  The MS rasterizer does that with */
/* twilight points (confirmed by Greg Hitchcock)   */
/* auto-flip test */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* control value cut-in and round */
/* XXX: UNDOCUMENTED!  Only perform cut-in test when both points */
/*      refer to the same zone.                                  */
/* XXX: According to Greg Hitchcock, the following wording is */
/*      the right one:                                        */
/*                                                            */
/*        When the absolute difference between the value in   */
/*        the table [CVT] and the measurement directly from   */
/*        the outline is _greater_ than the cut_in value, the */
/*        outline measurement is used.                        */
/*                                                            */
/*      This is from `instgly.doc'.  The description in       */
/*      `ttinst2.doc', version 1.66, is thus incorrect since  */
/*      it implies `>=' instead of `>'.                       */
/* do cvt cut-in always in MIRP for sph */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* minimum distance test */
/* Round moves if necessary */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* Reverse move if necessary */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/*************************************************************************/
/*                                                                       */
/* ALIGNRP[]:    ALIGN Relative Point                                    */
/* Opcode range: 0x3C                                                    */
/* Stack:        uint32 uint32... -->                                    */
/*                                                                       */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/*************************************************************************/
/*                                                                       */
/* ISECT[]:      moves point to InterSECTion                             */
/* Opcode range: 0x0F                                                    */
/* Stack:        5 * uint32 -->                                          */
/*                                                                       */
/* Cramer's rule */
/* The discriminant above is actually a cross product of vectors     */
/* da and db. Together with the dot product, they can be used as     */
/* surrogates for sine and cosine of the angle between the vectors.  */
/* Indeed,                                                           */
/*       dotproduct   = |da||db|cos(angle)                           */
/*       discriminant = |da||db|sin(angle)     .                     */
/* We use these equations to reject grazing intersections by         */
/* thresholding abs(tan(angle)) at 1/19, corresponding to 3 degrees. */
/* else, take the middle of the middles of A and B */
/*************************************************************************/
/*                                                                       */
/* ALIGNPTS[]:   ALIGN PoinTS                                            */
/* Opcode range: 0x27                                                    */
/* Stack:        uint32 uint32 -->                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* IP[]:         Interpolate Point                                       */
/* Opcode range: 0x39                                                    */
/* Stack:        uint32... -->                                           */
/*                                                                       */
/* SOMETIMES, DUMBER CODE IS BETTER CODE */
/*
/* XXX: There are some glyphs in some braindead but popular */
/*      fonts out there (e.g. [aeu]grave in monotype.ttf)   */
/*      calling IP[] with bad values of rp[12].             */
/*      Do something sane when this odd thing happens.      */
/* check point bounds */
/* This is the same as what MS does for the invalid case:  */
/*                                                         */
/*   delta = (Original_Pt - Original_RP1) -                */
/*           (Current_Pt - Current_RP1)         ;          */
/*                                                         */
/* In FreeType speak:                                      */
/*                                                         */
/*   delta = org_dist - cur_dist          .                */
/*                                                         */
/* We move `point' by `new_dist - cur_dist' after leaving  */
/* this block, thus we have                                */
/*                                                         */
/*   new_dist - cur_dist = delta                   ,       */
/*   new_dist - cur_dist = org_dist - cur_dist     ,       */
/*              new_dist = org_dist                .       */
/*************************************************************************/
/*                                                                       */
/* UTP[a]:       UnTouch Point                                           */
/* Opcode range: 0x29                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/* Local variables for Ins_IUP: */
/* original and current coordinate */
/* arrays                          */
/* simple shift of untouched points */
/* interpolation */
/*************************************************************************/
/*                                                                       */
/* IUP[a]:       Interpolate Untouched Points                            */
/* Opcode range: 0x30-0x31                                               */
/* Stack:        -->                                                     */
/*                                                                       */
/* first point of contour        */
/* end point (last+1) of contour */
/* first touched point in contour   */
/* current touched point in contour */
/* current point   */
/* current contour */
/* ignore empty outlines */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/*************************************************************************/
/*                                                                       */
/* DELTAPn[]:    DELTA exceptions P1, P2, P3                             */
/* Opcode range: 0x5D,0x71,0x72                                          */
/* Stack:        uint32 (2 * uint32)... -->                              */
/*                                                                       */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* Delta hinting is covered by US Patent 5159668. */
/* some points theoretically may occur more
/* XXX: Because some popular fonts contain some invalid DeltaP */
/*      instructions, we simply ignore them when the stacked   */
/*      point reference is off limit, rather than returning an */
/*      error.  As a delta instruction doesn't change a glyph  */
/*      in great ways, this shouldn't be a problem.            */
/*
/* Otherwise, apply subpixel hinting and compatibility mode */
/* rules, always skipping deltas in subpixel direction.     */
/* save the y value of the point now; compare after move */
/* Standard subpixel hinting: Allow y move for y-touched */
/* points.  This messes up DejaVu ...                    */
/* compatibility mode */
/* Allow delta move if using sph_compatibility_mode,   */
/* IUP has not been called, and point is touched on Y. */
/* Reverse this move if it results in a disallowed move */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/*************************************************************************/
/*                                                                       */
/* DELTACn[]:    DELTA exceptions C1, C2, C3                             */
/* Opcode range: 0x73,0x74,0x75                                          */
/* Stack:        uint32 (2 * uint32)... -->                              */
/*                                                                       */
/* Delta hinting is covered by US Patent 5159668. */
/*************************************************************************/
/*                                                                       */
/* MISC. INSTRUCTIONS                                                    */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* GETINFO[]:    GET INFOrmation                                         */
/* Opcode range: 0x88                                                    */
/* Stack:        uint32 --> uint32                                       */
/*                                                                       */
/********************************/
/* RASTERIZER VERSION           */
/* Selector Bit:  0             */
/* Return Bit(s): 0-7           */
/*                              */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/********************************/
/* GLYPH ROTATED                */
/* Selector Bit:  1             */
/* Return Bit(s): 8             */
/*                              */
/********************************/
/* GLYPH STRETCHED              */
/* Selector Bit:  2             */
/* Return Bit(s): 9             */
/*                              */
/********************************/
/* HINTING FOR GRAYSCALE        */
/* Selector Bit:  5             */
/* Return Bit(s): 12            */
/*                              */
/********************************/
/* HINTING FOR SUBPIXEL         */
/* Selector Bit:  6             */
/* Return Bit(s): 13            */
/*                              */
/********************************/
/* COMPATIBLE WIDTHS ENABLED    */
/* Selector Bit:  7             */
/* Return Bit(s): 14            */
/*                              */
/* Functionality still needs to be added */
/********************************/
/* SYMMETRICAL SMOOTHING        */
/* Selector Bit:  8             */
/* Return Bit(s): 15            */
/*                              */
/* Functionality still needs to be added */
/********************************/
/* HINTING FOR BGR?             */
/* Selector Bit:  9             */
/* Return Bit(s): 16            */
/*                              */
/* Functionality still needs to be added */
/********************************/
/* SUBPIXEL POSITIONED?         */
/* Selector Bit:  10            */
/* Return Bit(s): 17            */
/*                              */
/* Functionality still needs to be added */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* Opcodes are gathered in groups of 16. */
/* Please keep the spaces as they are.   */
/*  SVTCA  y  */  Ins_SVTCA,
/*  SVTCA  x  */  Ins_SVTCA,
/*  SPvTCA y  */  Ins_SPVTCA,
/*  SPvTCA x  */  Ins_SPVTCA,
/*  SFvTCA y  */  Ins_SFVTCA,
/*  SFvTCA x  */  Ins_SFVTCA,
//  */  Ins_SPVTL,
/*  SPvTL //  */  Ins_SPVTL,
/*  SPvTL +   */  Ins_SPVTL,
//  */  Ins_SFVTL,
/*  SFvTL //  */  Ins_SFVTL,
/*  SFvTL +   */  Ins_SFVTL,
/*  SPvFS     */  Ins_SPVFS,
/*  SFvFS     */  Ins_SFVFS,
/*  GPV       */  Ins_GPV,
/*  GFV       */  Ins_GFV,
/*  SFvTPv    */  Ins_SFVTPV,
/*  ISECT     */  Ins_ISECT,
/*  SRP0      */  Ins_SRP0,
/*  SRP1      */  Ins_SRP1,
/*  SRP2      */  Ins_SRP2,
/*  SZP0      */  Ins_SZP0,
/*  SZP1      */  Ins_SZP1,
/*  SZP2      */  Ins_SZP2,
/*  SZPS      */  Ins_SZPS,
/*  SLOOP     */  Ins_SLOOP,
/*  RTG       */  Ins_RTG,
/*  RTHG      */  Ins_RTHG,
/*  SMD       */  Ins_SMD,
/*  ELSE      */  Ins_ELSE,
/*  JMPR      */  Ins_JMPR,
/*  SCvTCi    */  Ins_SCVTCI,
/*  SSwCi     */  Ins_SSWCI,
/*  SSW       */  Ins_SSW,
/*  DUP       */  Ins_DUP,
/*  POP       */  Ins_POP,
/*  CLEAR     */  Ins_CLEAR,
/*  SWAP      */  Ins_SWAP,
/*  DEPTH     */  Ins_DEPTH,
/*  CINDEX    */  Ins_CINDEX,
/*  MINDEX    */  Ins_MINDEX,
/*  AlignPTS  */  Ins_ALIGNPTS,
/*  INS_0x28  */  Ins_UNKNOWN,
/*  UTP       */  Ins_UTP,
/*  LOOPCALL  */  Ins_LOOPCALL,
/*  CALL      */  Ins_CALL,
/*  FDEF      */  Ins_FDEF,
/*  ENDF      */  Ins_ENDF,
/*  MDAP[0]   */  Ins_MDAP,
/*  MDAP[1]   */  Ins_MDAP,
/*  IUP[0]    */  Ins_IUP,
/*  IUP[1]    */  Ins_IUP,
/*  SHP[0]    */  Ins_SHP,
/*  SHP[1]    */  Ins_SHP,
/*  SHC[0]    */  Ins_SHC,
/*  SHC[1]    */  Ins_SHC,
/*  SHZ[0]    */  Ins_SHZ,
/*  SHZ[1]    */  Ins_SHZ,
/*  SHPIX     */  Ins_SHPIX,
/*  IP        */  Ins_IP,
/*  MSIRP[0]  */  Ins_MSIRP,
/*  MSIRP[1]  */  Ins_MSIRP,
/*  AlignRP   */  Ins_ALIGNRP,
/*  RTDG      */  Ins_RTDG,
/*  MIAP[0]   */  Ins_MIAP,
/*  MIAP[1]   */  Ins_MIAP,
/*  NPushB    */  Ins_NPUSHB,
/*  NPushW    */  Ins_NPUSHW,
/*  WS        */  Ins_WS,
/*  RS        */  Ins_RS,
/*  WCvtP     */  Ins_WCVTP,
/*  RCvt      */  Ins_RCVT,
/*  GC[0]     */  Ins_GC,
/*  GC[1]     */  Ins_GC,
/*  SCFS      */  Ins_SCFS,
/*  MD[0]     */  Ins_MD,
/*  MD[1]     */  Ins_MD,
/*  MPPEM     */  Ins_MPPEM,
/*  MPS       */  Ins_MPS,
/*  FlipON    */  Ins_FLIPON,
/*  FlipOFF   */  Ins_FLIPOFF,
/*  DEBUG     */  Ins_DEBUG,
/*  LT        */  Ins_LT,
/*  LTEQ      */  Ins_LTEQ,
/*  GT        */  Ins_GT,
/*  GTEQ      */  Ins_GTEQ,
/*  EQ        */  Ins_EQ,
/*  NEQ       */  Ins_NEQ,
/*  ODD       */  Ins_ODD,
/*  EVEN      */  Ins_EVEN,
/*  IF        */  Ins_IF,
/*  EIF       */  Ins_EIF,
/*  AND       */  Ins_AND,
/*  OR        */  Ins_OR,
/*  NOT       */  Ins_NOT,
/*  DeltaP1   */  Ins_DELTAP,
/*  SDB       */  Ins_SDB,
/*  SDS       */  Ins_SDS,
/*  ADD       */  Ins_ADD,
/*  SUB       */  Ins_SUB,
/*  DIV       */  Ins_DIV,
/*  MUL       */  Ins_MUL,
/*  ABS       */  Ins_ABS,
/*  NEG       */  Ins_NEG,
/*  FLOOR     */  Ins_FLOOR,
/*  CEILING   */  Ins_CEILING,
/*  ROUND[0]  */  Ins_ROUND,
/*  ROUND[1]  */  Ins_ROUND,
/*  ROUND[2]  */  Ins_ROUND,
/*  ROUND[3]  */  Ins_ROUND,
/*  NROUND[0] */  Ins_NROUND,
/*  NROUND[1] */  Ins_NROUND,
/*  NROUND[2] */  Ins_NROUND,
/*  NROUND[3] */  Ins_NROUND,
/*  WCvtF     */  Ins_WCVTF,
/*  DeltaP2   */  Ins_DELTAP,
/*  DeltaP3   */  Ins_DELTAP,
/*  DeltaCn[0] */ Ins_DELTAC,
/*  DeltaCn[1] */ Ins_DELTAC,
/*  DeltaCn[2] */ Ins_DELTAC,
/*  SROUND    */  Ins_SROUND,
/*  S45Round  */  Ins_S45ROUND,
/*  JROT      */  Ins_JROT,
/*  JROF      */  Ins_JROF,
/*  ROFF      */  Ins_ROFF,
/*  INS_0x7B  */  Ins_UNKNOWN,
/*  RUTG      */  Ins_RUTG,
/*  RDTG      */  Ins_RDTG,
/*  SANGW     */  Ins_SANGW,
/*  AA        */  Ins_AA,
/*  FlipPT    */  Ins_FLIPPT,
/*  FlipRgON  */  Ins_FLIPRGON,
/*  FlipRgOFF */  Ins_FLIPRGOFF,
/*  INS_0x83  */  Ins_UNKNOWN,
/*  INS_0x84  */  Ins_UNKNOWN,
/*  ScanCTRL  */  Ins_SCANCTRL,
/*  SDPVTL[0] */  Ins_SDPVTL,
/*  SDPVTL[1] */  Ins_SDPVTL,
/*  GetINFO   */  Ins_GETINFO,
/*  IDEF      */  Ins_IDEF,
/*  ROLL      */  Ins_ROLL,
/*  MAX       */  Ins_MAX,
/*  MIN       */  Ins_MIN,
/*  ScanTYPE  */  Ins_SCANTYPE,
/*  InstCTRL  */  Ins_INSTCTRL,
/*  INS_0x8F  */  Ins_UNKNOWN,
/*  INS_0x90  */   Ins_UNKNOWN,
/*  INS_0x91  */   Ins_UNKNOWN,
/*  INS_0x92  */   Ins_UNKNOWN,
/*  INS_0x93  */   Ins_UNKNOWN,
/*  INS_0x94  */   Ins_UNKNOWN,
/*  INS_0x95  */   Ins_UNKNOWN,
/*  INS_0x96  */   Ins_UNKNOWN,
/*  INS_0x97  */   Ins_UNKNOWN,
/*  INS_0x98  */   Ins_UNKNOWN,
/*  INS_0x99  */   Ins_UNKNOWN,
/*  INS_0x9A  */   Ins_UNKNOWN,
/*  INS_0x9B  */   Ins_UNKNOWN,
/*  INS_0x9C  */   Ins_UNKNOWN,
/*  INS_0x9D  */   Ins_UNKNOWN,
/*  INS_0x9E  */   Ins_UNKNOWN,
/*  INS_0x9F  */   Ins_UNKNOWN,
/*  INS_0xA0  */   Ins_UNKNOWN,
/*  INS_0xA1  */   Ins_UNKNOWN,
/*  INS_0xA2  */   Ins_UNKNOWN,
/*  INS_0xA3  */   Ins_UNKNOWN,
/*  INS_0xA4  */   Ins_UNKNOWN,
/*  INS_0xA5  */   Ins_UNKNOWN,
/*  INS_0xA6  */   Ins_UNKNOWN,
/*  INS_0xA7  */   Ins_UNKNOWN,
/*  INS_0xA8  */   Ins_UNKNOWN,
/*  INS_0xA9  */   Ins_UNKNOWN,
/*  INS_0xAA  */   Ins_UNKNOWN,
/*  INS_0xAB  */   Ins_UNKNOWN,
/*  INS_0xAC  */   Ins_UNKNOWN,
/*  INS_0xAD  */   Ins_UNKNOWN,
/*  INS_0xAE  */   Ins_UNKNOWN,
/*  INS_0xAF  */   Ins_UNKNOWN,
/*  PushB[0]  */  Ins_PUSHB,
/*  PushB[1]  */  Ins_PUSHB,
/*  PushB[2]  */  Ins_PUSHB,
/*  PushB[3]  */  Ins_PUSHB,
/*  PushB[4]  */  Ins_PUSHB,
/*  PushB[5]  */  Ins_PUSHB,
/*  PushB[6]  */  Ins_PUSHB,
/*  PushB[7]  */  Ins_PUSHB,
/*  PushW[0]  */  Ins_PUSHW,
/*  PushW[1]  */  Ins_PUSHW,
/*  PushW[2]  */  Ins_PUSHW,
/*  PushW[3]  */  Ins_PUSHW,
/*  PushW[4]  */  Ins_PUSHW,
/*  PushW[5]  */  Ins_PUSHW,
/*  PushW[6]  */  Ins_PUSHW,
/*  PushW[7]  */  Ins_PUSHW,
/*  MDRP[00]  */  Ins_MDRP,
/*  MDRP[01]  */  Ins_MDRP,
/*  MDRP[02]  */  Ins_MDRP,
/*  MDRP[03]  */  Ins_MDRP,
/*  MDRP[04]  */  Ins_MDRP,
/*  MDRP[05]  */  Ins_MDRP,
/*  MDRP[06]  */  Ins_MDRP,
/*  MDRP[07]  */  Ins_MDRP,
/*  MDRP[08]  */  Ins_MDRP,
/*  MDRP[09]  */  Ins_MDRP,
/*  MDRP[10]  */  Ins_MDRP,
/*  MDRP[11]  */  Ins_MDRP,
/*  MDRP[12]  */  Ins_MDRP,
/*  MDRP[13]  */  Ins_MDRP,
/*  MDRP[14]  */  Ins_MDRP,
/*  MDRP[15]  */  Ins_MDRP,
/*  MDRP[16]  */  Ins_MDRP,
/*  MDRP[17]  */  Ins_MDRP,
/*  MDRP[18]  */  Ins_MDRP,
/*  MDRP[19]  */  Ins_MDRP,
/*  MDRP[20]  */  Ins_MDRP,
/*  MDRP[21]  */  Ins_MDRP,
/*  MDRP[22]  */  Ins_MDRP,
/*  MDRP[23]  */  Ins_MDRP,
/*  MDRP[24]  */  Ins_MDRP,
/*  MDRP[25]  */  Ins_MDRP,
/*  MDRP[26]  */  Ins_MDRP,
/*  MDRP[27]  */  Ins_MDRP,
/*  MDRP[28]  */  Ins_MDRP,
/*  MDRP[29]  */  Ins_MDRP,
/*  MDRP[30]  */  Ins_MDRP,
/*  MDRP[31]  */  Ins_MDRP,
/*  MIRP[00]  */  Ins_MIRP,
/*  MIRP[01]  */  Ins_MIRP,
/*  MIRP[02]  */  Ins_MIRP,
/*  MIRP[03]  */  Ins_MIRP,
/*  MIRP[04]  */  Ins_MIRP,
/*  MIRP[05]  */  Ins_MIRP,
/*  MIRP[06]  */  Ins_MIRP,
/*  MIRP[07]  */  Ins_MIRP,
/*  MIRP[08]  */  Ins_MIRP,
/*  MIRP[09]  */  Ins_MIRP,
/*  MIRP[10]  */  Ins_MIRP,
/*  MIRP[11]  */  Ins_MIRP,
/*  MIRP[12]  */  Ins_MIRP,
/*  MIRP[13]  */  Ins_MIRP,
/*  MIRP[14]  */  Ins_MIRP,
/*  MIRP[15]  */  Ins_MIRP,
/*  MIRP[16]  */  Ins_MIRP,
/*  MIRP[17]  */  Ins_MIRP,
/*  MIRP[18]  */  Ins_MIRP,
/*  MIRP[19]  */  Ins_MIRP,
/*  MIRP[20]  */  Ins_MIRP,
/*  MIRP[21]  */  Ins_MIRP,
/*  MIRP[22]  */  Ins_MIRP,
/*  MIRP[23]  */  Ins_MIRP,
/*  MIRP[24]  */  Ins_MIRP,
/*  MIRP[25]  */  Ins_MIRP,
/*  MIRP[26]  */  Ins_MIRP,
/*  MIRP[27]  */  Ins_MIRP,
/*  MIRP[28]  */  Ins_MIRP,
/*  MIRP[29]  */  Ins_MIRP,
/*  MIRP[30]  */  Ins_MIRP,
/*  MIRP[31]  */  Ins_MIRP
/* !TT_CONFIG_OPTION_INTERPRETER_SWITCH */
/*************************************************************************/
/*                                                                       */
/* RUN                                                                   */
/*                                                                       */
/*  This function executes a run of opcodes.  It will exit in the        */
/*  following cases:                                                     */
/*                                                                       */
/*  - Errors (in which case it returns FALSE).                           */
/*                                                                       */
/*  - Reaching the end of the main code range (returns TRUE).            */
/*    Reaching the end of a code range within a function call is an      */
/*    error.                                                             */
/*                                                                       */
/*  - After executing one single opcode, if the flag `Instruction_Trap'  */
/*    is set to TRUE (returns TRUE).                                     */
/*                                                                       */
/*  On exit with TRUE, test IP < CodeSize to know whether it comes from  */
/*  an instruction trap or a normal termination.                         */
/*                                                                       */
/*                                                                       */
/*  Note: The documented DEBUG opcode pops a value from the stack.  This */
/*        behaviour is unsupported; here a DEBUG opcode is always an     */
/*        error.                                                         */
/*                                                                       */
/*                                                                       */
/* THIS IS THE INTERPRETER'S MAIN LOOP.                                  */
/*                                                                       */
/*  Instructions appear in the specification's order.                    */
/*                                                                       */
/*************************************************************************/
/* documentation is in ttinterp.h */
/* executed instructions counter */
/* #8 TypeMan Talk Align */
/* SPVTL   */
/* RDTG    */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* set PPEM and CVT functions */
/* non-square pixels, use the stretched routines */
/* square pixels, use normal routines */
/* First, let's check for empty stack and overflow */
/* `args' is the top of the stack once arguments have been popped. */
/* One can also interpret it as the index of the last argument.    */
/* push zeroes onto the stack */
/* `new_top' is the new top of the stack, after the instruction's */
/* execution.  `top' will be set to `new_top' after the `switch'  */
/* statement.                                                     */
/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* SVTCA y  */
/* SVTCA x  */
/* SPvTCA y */
/* SPvTCA x */
/* SFvTCA y */
/* SFvTCA x */
// */
/* SPvTL // */
/* SPvTL +  */
// */
/* SFvTL // */
/* SFvTL +  */
/* SPvFS */
/* SFvFS */
/* GPV */
/* GFV */
/* SFvTPv */
/* ISECT  */
/* SRP0 */
/* SRP1 */
/* SRP2 */
/* SZP0 */
/* SZP1 */
/* SZP2 */
/* SZPS */
/* SLOOP */
/* RTG */
/* RTHG */
/* SMD */
/* ELSE */
/* JMPR */
/* SCVTCI */
/* SSWCI */
/* SSW */
/* DUP */
/* POP */
/* nothing :-) */
/* CLEAR */
/* SWAP */
/* DEPTH */
/* CINDEX */
/* MINDEX */
/* ALIGNPTS */
/* ???? */
/* UTP */
/* LOOPCALL */
/* CALL */
/* FDEF */
/* ENDF */
/* MDAP */
/* MDAP */
/* IUP */
/* IUP */
/* SHP */
/* SHP */
/* SHC */
/* SHC */
/* SHZ */
/* SHZ */
/* SHPIX */
/* IP    */
/* MSIRP */
/* MSIRP */
/* AlignRP */
/* RTDG */
/* MIAP */
/* MIAP */
/* NPUSHB */
/* NPUSHW */
/* WS */
/* RS */
/* WCVTP */
/* RCVT */
/* GC */
/* GC */
/* SCFS */
/* MD */
/* MD */
/* MPPEM */
/* MPS */
/* FLIPON */
/* FLIPOFF */
/* DEBUG */
/* LT */
/* LTEQ */
/* GT */
/* GTEQ */
/* EQ */
/* NEQ */
/* ODD */
/* EVEN */
/* IF */
/* EIF */
/* do nothing */
/* AND */
/* OR */
/* NOT */
/* DELTAP1 */
/* SDB */
/* SDS */
/* ADD */
/* SUB */
/* DIV */
/* MUL */
/* ABS */
/* NEG */
/* FLOOR */
/* CEILING */
/* ROUND */
/* ROUND */
/* ROUND */
/* ROUND */
/* NROUND */
/* NROUND */
/* NRRUND */
/* NROUND */
/* WCVTF */
/* DELTAP2 */
/* DELTAP3 */
/* DELTAC0 */
/* DELTAC1 */
/* DELTAC2 */
/* SROUND */
/* S45Round */
/* JROT */
/* JROF */
/* ROFF */
/* ???? */
/* RUTG */
/* RDTG */
/* SANGW */
/* AA    */
/* nothing - obsolete */
/* FLIPPT */
/* FLIPRGON */
/* FLIPRGOFF */
/* UNKNOWN */
/* UNKNOWN */
/* SCANCTRL */
/* SDPVTL */
/* SDPVTL */
/* GETINFO */
/* IDEF */
/* ROLL */
/* MAX */
/* MIN */
/* SCANTYPE */
/* INSTCTRL */
/* TT_CONFIG_OPTION_INTERPRETER_SWITCH */
/* looking for redefined instructions */
/* Unreachable code warning suppression.             */
/* Leave to remind in case a later change the editor */
/* to consider break;                                */
/* increment instruction counter and check if we didn't */
/* run this program for too long (e.g. infinite loops). */
/* If any errors have occurred, function tables may be broken. */
/* Force a re-execution of `prep' and `fpgm' tables if no      */
/* bytecode debugger is run.                                   */
/* TT_USE_BYTECODE_INTERPRETER */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\truetype\ttobjs.c
/***************************************************************************/
/*                                                                         */
/*  ttobjs.c                                                               */
/*                                                                         */
/*    Objects manager (body).                                              */
/*                                                                         */
/*  Copyright 1996-2013                                                    */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/*                       GLYPH ZONE FUNCTIONS                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_glyphzone_done                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Deallocate a glyph zone.                                           */
/*                                                                       */
/* <Input>                                                               */
/*    zone :: A pointer to the target glyph zone.                        */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_glyphzone_new                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Allocate a new glyph zone.                                         */
/*                                                                       */
/* <Input>                                                               */
/*    memory      :: A handle to the current memory object.              */
/*                                                                       */
/*    maxPoints   :: The capacity of glyph zone in points.               */
/*                                                                       */
/*    maxContours :: The capacity of glyph zone in contours.             */
/*                                                                       */
/* <Output>                                                              */
/*    zone        :: A pointer to the target glyph zone record.          */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* TT_USE_BYTECODE_INTERPRETER */
/* Compare the face with a list of well-known `tricky' fonts. */
/* This list shall be expanded as we find more of them.       */
/* dfkaisb.ttf */
/* kaiu.ttf */
/* htkt2.ttf */
/* htst3.ttf */
/* hkscsiic.ttf & iicore.ttf */
/* mingliu.ttf & mingliu.ttc */
/* mingliu.ttc */
/* mingli.ttf */
/* XXX: This function should be in the `sfnt' module. */
/* Some PDF generators clear the checksums in the TrueType header table. */
/* For example, Quartz ContextPDF clears all entries, or Bullzip PDF     */
/* Printer clears the entries for subsetted subtables.  We thus have to  */
/* recalculate the checksums  where necessary.                           */
/* XXX: This function should be in the `sfnt' module. */
/* if we believe the written value, use following part. */
/* MingLiU 1995 */
/* cvt  */
/* fpgm */
/* prep */
/* MingLiU 1996- */
/* cvt  */
/* fpgm */
/* prep */
/* DFKaiShu */
/* cvt  */
/* fpgm */
/* prep */
/* HuaTianKaiTi */
/* cvt  */
/* fpgm */
/* prep */
/* HuaTianSongTi */
/* cvt  */
/* fpgm */
/* prep */
/* NEC fadpop7.ttf */
/* cvt  */
/* fpgm */
/* prep */
/* NEC fadrei5.ttf */
/* cvt  */
/* fpgm */
/* prep */
/* NEC fangot7.ttf */
/* cvt  */
/* fpgm */
/* prep */
/* NEC fangyo5.ttf */
/* cvt  */
/* fpgm */
/* prep */
/* NEC fankyo5.ttf */
/* cvt  */
/* fpgm */
/* prep */
/* NEC fanrgo5.ttf */
/* cvt  */
/* fpgm */
/* prep */
/* NEC fangot5.ttc */
/* cvt  */
/* fpgm */
/* prep */
/* NEC fanmin3.ttc */
/* cvt  */
/* fpgm */
/* prep */
/* NEC FA-Gothic, 1996 */
/* cvt  */
/* fpgm */
/* prep */
/* NEC FA-Minchou, 1996 */
/* cvt  */
/* fpgm */
/* prep */
/* NEC FA-RoundGothicB, 1996 */
/* cvt  */
/* fpgm */
/* prep */
/* NEC FA-RoundGothicM, 1996 */
/* cvt  */
/* fpgm */
/* prep */
/* For first, check the face name for quick check. */
/* Type42 fonts may lack `name' tables, we thus try to identify */
/* tricky fonts by checking the checksums of Type42-persistent  */
/* sfnt tables (`cvt', `fpgm', and `prep').                     */
/* Check whether `.notdef' is the only glyph in the `loca' table. */
/* Only have a single outline. */
/* FIXME: Need to test glyphname == .notdef ? */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_init                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    Initialize a given TrueType face object.                           */
/*                                                                       */
/* <Input>                                                               */
/*    stream     :: The source font stream.                              */
/*                                                                       */
/*    face_index :: The index of the font face in the resource.          */
/*                                                                       */
/*    num_params :: Number of additional generic parameters.  Ignored.   */
/*                                                                       */
/*    params     :: Additional generic parameters.  Ignored.             */
/*                                                                       */
/* <InOut>                                                               */
/*    face       :: The newly built face object.                         */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* TT_Face */
/* create input stream from resource */
/* check that we have a valid TrueType file */
/* Stream may have changed. */
/* We must also be able to accept Mac/GX fonts, as well as OT ones. */
/* The 0x00020000 tag is completely undocumented; some fonts from   */
/* Arphic made for Chinese Windows 3.1 have this.                   */
/* MS fonts  */
/* CJK fonts for Win 3.1 */
/* Mac fonts */
/* If we are performing a simple font format check, exit immediately. */
/* Load font directory */
/* Check the scalable flag based on `loca'. */
/* Check the scalable flag based on `loca'. */
/* Determine whether unpatented hinting is to be used for this face. */
/* TT_CONFIG_OPTION_UNPATENTED_HINTING &&
/* initialize standard glyph loading routines */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_done                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    Finalize a given face object.                                      */
/*                                                                       */
/* <Input>                                                               */
/*    face :: A pointer to the face object to destroy.                   */
/*                                                                       */
/* TT_Face */
/* for `extended TrueType formats' (i.e. compressed versions) */
/* freeing the locations table */
/* freeing the CVT */
/* freeing the programs */
/*************************************************************************/
/*                                                                       */
/*                           SIZE  FUNCTIONS                             */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_size_run_fpgm                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Run the font program.                                              */
/*                                                                       */
/* <Input>                                                               */
/*    size     :: A handle to the size object.                           */
/*                                                                       */
/*    pedantic :: Set if bytecode execution should be pedantic.          */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* debugging instances have their own context */
/* allow font program execution */
/* disable CVT and glyph programs coderange */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_size_run_prep                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Run the control value program.                                     */
/*                                                                       */
/* <Input>                                                               */
/*    size     :: A handle to the size object.                           */
/*                                                                       */
/*    pedantic :: Set if bytecode execution should be pedantic.          */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* debugging instances have their own context */
/* UNDOCUMENTED!  The MS rasterizer doesn't allow the following */
/* graphics state variables to be modified by the CVT program.  */
/* save as default graphics state */
/* the debug context must be deleted by the debugger itself */
/* free storage area */
/* twilight zone */
/* Initialize bytecode-related fields in the size object.       */
/* We do this only if bytecode interpretation is really needed. */
/* Set default metrics */
/* set default engine compensation */
/* gray     */
/* black    */
/* white    */
/* reserved */
/* allocate function defs, instruction defs, cvt, and storage area */
/* reserve twilight zone */
/* there are 4 phantom points (do we need this?) */
/* set `face->interpreter' according to the debug hook present */
/* Fine, now run the font program! */
/* rescale CVT when needed */
/* Scale the cvt values to the new ppem.          */
/* We use by default the y ppem to scale the CVT. */
/* all twilight points are originally zero */
/* clear storage area */
/* TT_USE_BYTECODE_INTERPRETER */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_size_init                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    Initialize a new TrueType size object.                             */
/*                                                                       */
/* <InOut>                                                               */
/*    size :: A handle to the size object.                               */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* TT_Size */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_size_done                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    The TrueType size object finalizer.                                */
/*                                                                       */
/* <Input>                                                               */
/*    size :: A handle to the target size object.                        */
/*                                                                       */
/* TT_Size */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_size_reset                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Reset a TrueType size when resolutions and character dimensions    */
/*    have been changed.                                                 */
/*                                                                       */
/* <Input>                                                               */
/*    size :: A handle to the target size object.                        */
/*                                                                       */
/* copy the result from base layer */
/* This bit flag, if set, indicates that the ppems must be       */
/* rounded to integers.  Nearly all TrueType fonts have this bit */
/* set, as hinting won't work really well otherwise.             */
/*                                                               */
/* compute new transformation */
/* TT_USE_BYTECODE_INTERPRETER */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_driver_init                                                     */
/*                                                                       */
/* <Description>                                                         */
/*    Initialize a given TrueType driver object.                         */
/*                                                                       */
/* <Input>                                                               */
/*    driver :: A handle to the target driver object.                    */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* TT_Driver */
/* !TT_USE_BYTECODE_INTERPRETER */
/* !TT_USE_BYTECODE_INTERPRETER */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_driver_done                                                     */
/*                                                                       */
/* <Description>                                                         */
/*    Finalize a given TrueType driver.                                  */
/*                                                                       */
/* <Input>                                                               */
/*    driver :: A handle to the target TrueType driver.                  */
/*                                                                       */
/* TT_Driver */
/* destroy the execution context */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_slot_init                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    Initialize a new slot object.                                      */
/*                                                                       */
/* <InOut>                                                               */
/*    slot :: A handle to the slot object.                               */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\truetype\ttpic.c
/***************************************************************************/
/*                                                                         */
/*  ttpic.c                                                                */
/*                                                                         */
/*    The FreeType position independent code services for truetype module. */
/*                                                                         */
/*  Copyright 2009, 2010, 2012, 2013 by                                    */
/*  Oran Agra and Mickey Gabel.                                            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* forward declaration of PIC init functions from ttdriver.c */
/* allocate pointer, clear and set global container pointer */
/* initialize pointer table - this is how the module usually */
/* expects this data                                         */
/* FT_CONFIG_OPTION_PIC */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\truetype\ttpload.c
/***************************************************************************/
/*                                                                         */
/*  ttpload.c                                                              */
/*                                                                         */
/*    TrueType-specific tables loader (body).                              */
/*                                                                         */
/*  Copyright 1996-2002, 2004-2013 by                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_loca                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Load the locations table.                                          */
/*                                                                       */
/* <InOut>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/* <Input>                                                               */
/*    stream :: The input stream.                                        */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* we need the size of the `glyf' table for malformed `loca' tables */
/* it is possible that a font doesn't have a glyf table at all */
/* or its size is zero                                         */
/* we only handle the case where `maxp' gives a larger value */
/* compute the distance to next table in font file */
/* `loca' is the last table */
/*
/* Check broken location data */
/* The `loca' table must be ordered; it refers to the length of */
/* an entry as the difference between the current and the next  */
/* position.  However, there do exist (malformed) fonts which   */
/* don't obey this rule, so we are only able to provide an      */
/* upper bound for the size.                                    */
/*                                                              */
/* We get (intentionally) a wrong, non-zero result in case the  */
/* `glyf' table is missing.                                     */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_cvt                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Load the control value table into a face object.                   */
/*                                                                       */
/* <InOut>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/* <Input>                                                               */
/*    stream :: A handle to the input stream.                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* !TT_USE_BYTECODE_INTERPRETER */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_fpgm                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Load the font program.                                             */
/*                                                                       */
/* <InOut>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/* <Input>                                                               */
/*    stream :: A handle to the input stream.                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* The font program is optional */
/* !TT_USE_BYTECODE_INTERPRETER */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_prep                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Load the cvt program.                                              */
/*                                                                       */
/* <InOut>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/* <Input>                                                               */
/*    stream :: A handle to the input stream.                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* !TT_USE_BYTECODE_INTERPRETER */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_hdmx                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Load the `hdmx' table into the face object.                        */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/*    stream :: A handle to the input stream.                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* this table is optional */
/* The maximum number of bytes in an hdmx device record is the */
/* maximum number of glyphs + 2; this is 0xFFFF + 2, thus      */
/* explaining why `record_size' is a long (which we read as    */
/* unsigned long for convenience).  In practice, two bytes are */
/* sufficient to hold the size value.                          */
/*                                                             */
/* There are at least two fonts, HANNOM-A and HANNOM-B version */
/* 2.0 (2005), which get this wrong: The upper two bytes of    */
/* the size value are set to 0xFF instead of 0x00.  We catch   */
/* and fix this.                                               */
/* The limit for `num_records' is a heuristic value. */
/*************************************************************************/
/*                                                                       */
/* Return the advance width table for a given pixel size if it is found  */
/* in the font's `hdmx' table (if any).                                  */
/*                                                                       */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\truetype\ttsubpix.c
/***************************************************************************/
/*                                                                         */
/*  ttsubpix.c                                                             */
/*                                                                         */
/*    TrueType Subpixel Hinting.                                           */
/*                                                                         */
/*  Copyright 2010-2013 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* These rules affect how the TT Interpreter does hinting, with the      */
/* goal of doing subpixel hinting by (in general) ignoring x moves.      */
/* Some of these rules are fixes that go above and beyond the            */
/* stated techniques in the MS whitepaper on Cleartype, due to           */
/* artifacts in many glyphs.  So, these rules make some glyphs render    */
/* better than they do in the MS rasterizer.                             */
/*                                                                       */
/* "" string or 0 int/char indicates to apply to all glyphs.             */
/* "-" used as dummy placeholders, but any non-matching string works.    */
/*                                                                       */
/* Some of this could arguably be implemented in fontconfig, however:    */
/*                                                                       */
/*  - Fontconfig can't set things on a glyph-by-glyph basis.             */
/*  - The tweaks that happen here are very low-level, from an average    */
/*    user's point of view and are best implemented in the hinter.       */
/*                                                                       */
/* The goal is to make the subpixel hinting techniques as generalized    */
/* as possible across all fonts to prevent the need for extra rules such */
/* as these.                                                             */
/*                                                                       */
/* The rule structure is designed so that entirely new rules can easily  */
/* be added when a new compatibility feature is discovered.              */
/*                                                                       */
/* The rule structures could also use some enhancement to handle ranges. */
/*                                                                       */
/*     ****************** WORK IN PROGRESS *******************           */
/*                                                                       */
/* These are `classes' of fonts that can be grouped together and used in */
/* rules below.  A blank entry "" is required at the end of these!       */
/* Define this to force natural (i.e. not bitmap-compatible) widths.     */
/* The default leans strongly towards natural widths except for a few    */
/* legacy fonts where a selective combination produces nicer results.    */
/* #define FORCE_NATURAL_WIDTHS   */
/* Define `classes' of styles that can be grouped together and used in   */
/* rules below.  A blank entry "" is required at the end of these!       */
/* Force special legacy fixes for fonts.                                 */
/* Don't do subpixel (ignore_x_mode) hinting; do normal hinting.         */
/* these characters are almost always safe */
/* Subpixel hinting ignores SHPIX rules on X.  Force SHPIX for these.    */
/* Skip Y moves that start with a point that is not on a Y pixel         */
/* boundary and don't move that point to a Y pixel boundary.             */
/* fix vwxyz thinness*/
/* Fix thin middle stems */
/* Cyrillic small letter I */
/* Fix artifacts with some Regular & Bold */
/* Fixes < and > */
/* Skip Y moves that start with a point that is not on a Y pixel         */
/* boundary and don't move that point to a Y pixel boundary.             */
/* Maintain thickness of diagonal in 'N' */
/* Skip Y moves that move a point off a Y pixel boundary.                */
/* Round moves that don't move a point to a Y pixel boundary.            */
/* Droid font instructions don't snap Y to pixels */
/* Allow a Direct_Move along X freedom vector if matched.                */
/* Fixes vanishing diagonal in 4 */
/* Return MS rasterizer version 35 if matched.                           */
/* This seems to be the only way to make these look good */
/* Don't round to the subpixel grid.  Round to pixel grid.               */
/* Fix serif thickness for certain ppems */
/* Can probably be generalized somehow   */
/* Skip IUP instructions if matched.                                     */
/* Skip MIAP Twilight hack if matched.                                   */
/* Skip DELTAP instructions if matched.                                  */
/* fix various problems with e in different versions */
/* prevent problems with '3' and others */
/* Cyrillic small letter short I */
/* Make horizontal stems consistent with the rest */
/* Always do DELTAP instructions if matched.                             */
/* Don't allow ALIGNRP after IUP.                                        */
/* Prevent creation of dents in outline */
/* Don't allow DELTAP after IUP.                                         */
/* Don't allow CALL after IUP.                                           */
/* Prevent creation of dents in outline */
/* De-embolden these glyphs slightly.                                    */
/* Embolden these glyphs slightly.                                       */
/* This is a CVT hack that makes thick horizontal stems on 2, 5, 7       */
/* similar to Windows XP.                                                */
/* This fudges distance on 2 to get rid of the vanishing stem issue.     */
/* A real solution to this is certainly welcome.                         */
/* Use compatible widths with these glyphs.  Compatible widths is always */
/* on when doing B/W TrueType instructing, but is used selectively here, */
/* typically on glyphs with 3 or more vertical stems.                    */
/* Cyrillic small letter sha */
/* Cyrillic small letter sha */
/* Cyrillic small letter sha */
/* Cyrillic small letter sha */
/* Scaling slightly in the x-direction prior to hinting results in       */
/* more visually pleasing glyphs in certain cases.                       */
/* This sometimes needs to be coordinated with compatible width rules.   */
/* A value of 1000 corresponds to a scaled value of 1.0.                 */
/* Cyrillic small letter el */
/* Cyrillic small letter el */
/* FORCE_NATURAL_WIDTHS */
/* Does font name match rule family? */
/* Is font name a wildcard ""? */
/* Is font name contained in a class list? */
/* Does font style match rule style? */
/* Is font style a wildcard ""? */
/* Is font style contained in a class list? */
/* rule checks may be able to be optimized further */
/* rule checks may be able to be optimized further */
/* don't apply rules if style isn't set */
/* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* ANSI C doesn't like empty source files */
/* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\type1\t1afm.c
/***************************************************************************/
/*                                                                         */
/*  t1afm.c                                                                */
/*                                                                         */
/*    AFM support for Type 1 fonts (body).                                 */
/*                                                                         */
/*  Copyright 1996-2011, 2013 by                                           */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* read a glyph name and return the equivalent glyph index */
/* PS string/name length must be < 16-bit */
/* compare two kerning pairs */
/* parse a PFM file -- for now, only read the kerning pairs */
/* Figure out how long the width table is.          */
/* This info is a little-endian short at offset 99. */
/* extension table is probably optional */
/* Kerning offset is 14 bytes from start of extensions table. */
/* zero offset means no table */
/* Actually, kerning pairs are simply optional! */
/* allocate the pairs */
/* now, read each kern pair */
/* PFM kerning data are stored by encoding rather than glyph index, */
/* so find the PostScript charmap of this font and install it       */
/* temporarily.  If we find no PostScript charmap, then just use    */
/* the default and hope it is the right one.                        */
/* check against PostScript pseudo platform */
/* Kerning info is stored as:             */
/*                                        */
/*   encoding of first glyph (1 byte)     */
/*   encoding of second glyph (1 byte)    */
/*   offset (little-endian short)         */
/* now, sort the kern pairs according to their glyph indices */
/* parse a metrics file -- either AFM or PFM depending on what */
/* it turns out to be                                          */
/* MS Windows allows versions up to 0x3FF without complaining */
/* no `U' suffix here to 0xFFFF! */
/* no `U' suffix here to 0x8000! */
/* find the kerning for a given glyph pair */
/* simple binary search */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\type1\t1driver.c
/***************************************************************************/
/*                                                                         */
/*  t1driver.c                                                             */
/*                                                                         */
/*    Type 1 driver interface (body).                                      */
/*                                                                         */
/*  Copyright 1996-2004, 2006, 2007, 2009, 2011, 2013, 2014 by             */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*
/*
/*
/*
/*
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Get_Kerning                                                        */
/*                                                                       */
/* <Description>                                                         */
/*    A driver method used to return the kerning vector between two      */
/*    glyphs of the same face.                                           */
/*                                                                       */
/* <Input>                                                               */
/*    face        :: A handle to the source face object.                 */
/*                                                                       */
/*    left_glyph  :: The index of the left glyph in the kern pair.       */
/*                                                                       */
/*    right_glyph :: The index of the right glyph in the kern pair.      */
/*                                                                       */
/* <Output>                                                              */
/*    kerning     :: The kerning vector.  This is in font units for      */
/*                   scalable formats, and in pixels for fixed-sizes     */
/*                   formats.                                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* <Note>                                                                */
/*    Only horizontal layouts (left-to-right & right-to-left) are        */
/*    supported by this function.  Other layouts, or more sophisticated  */
/*    kernings are out of scope of this method (the basic driver         */
/*    interface is meant to be simple).                                  */
/*                                                                       */
/*    They can be implemented by format-specific interfaces.             */
/*                                                                       */
/* T1_Face */
/* T1_CONFIG_OPTION_NO_AFM */
/* format interface */
/* FT_Face_GetKerningFunc */
/* FT_Face_AttachFunc     */
/* FT_Size_SelectFunc     */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\type1\t1gload.c
/***************************************************************************/
/*                                                                         */
/*  t1gload.c                                                              */
/*                                                                         */
/*    Type 1 Glyph Loader (body).                                          */
/*                                                                         */
/*  Copyright 1996-2006, 2008-2010, 2013, 2014 by                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/**********                                                      *********/
/**********            COMPUTE THE MAXIMUM ADVANCE WIDTH         *********/
/**********                                                      *********/
/**********    The following code is in charge of computing      *********/
/**********    the maximum advance width of the font.  It        *********/
/**********    quickly processes each glyph charstring to        *********/
/**********    extract the value from either a `sbw' or `seac'   *********/
/**********    operator.                                         *********/
/**********                                                      *********/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* For incremental fonts get the character data using the */
/* callback function.                                     */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* For ordinary fonts get the character data stored in the face record. */
/* Incremental fonts can optionally override the metrics. */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* initialize load decoder */
/* size       */
/* glyph slot */
/* for each glyph, parse the glyph charstring and extract */
/* the advance width                                      */
/* now get load the unscaled outline */
/* ignore the error if one occurred - skip to next glyph */
/* T1_Face */
/* size       */
/* glyph slot */
/* T1_GlyphSlot */
/* T1_Size      */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* now load the unscaled outline */
/* save new glyph tables */
/* now, set the metrics -- this is rather simple, as   */
/* the left side bearing is the xMin, and the top side */
/* bearing the yMax                                    */
/* for composite glyphs, return only left side bearing and */
/* advance width                                           */
/* copy the _unscaled_ advance width */
/* make up vertical ones */
/* apply the font matrix, if any */
/* scale the outline and the metrics */
/* First of all, scale the points, if we are not hinting */
/* Then scale the metrics */
/* compute the other metrics */
/* make up vertical ones */
/* Set control data to the glyph charstrings.  Note that this is */
/* _not_ zero-terminated.                                        */
/* Set the control data to null - it is no longer available if   */
/* loaded incrementally.                                         */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\type1\t1load.c
/***************************************************************************/
/*                                                                         */
/*  t1load.c                                                               */
/*                                                                         */
/*    Type 1 font loader (body).                                           */
/*                                                                         */
/*  Copyright 1996-2014 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* This is the new and improved Type 1 data loader for FreeType 2.  The  */
/* old loader has several problems: it is slow, complex, difficult to    */
/* maintain, and contains incredible hacks to make it accept some        */
/* ill-formed Type 1 fonts without hiccup-ing.  Moreover, about 5% of    */
/* the Type 1 fonts on my machine still aren't loaded correctly by it.   */
/*                                                                       */
/* This version is much simpler, much faster and also easier to read and */
/* maintain by a great order of magnitude.  The idea behind it is to     */
/* _not_ try to read the Type 1 token stream with a state machine (i.e.  */
/* a Postscript-like interpreter) but rather to perform simple pattern   */
/* matching.                                                             */
/*                                                                       */
/* Indeed, nearly all data definitions follow a simple pattern like      */
/*                                                                       */
/*  ... /Field <data> ...                                                */
/*                                                                       */
/* where <data> can be a number, a boolean, a string, or an array of     */
/* numbers.  There are a few exceptions, namely the encoding, font name, */
/* charstrings, and subrs; they are handled with a special pattern       */
/* matching routine.                                                     */
/*                                                                       */
/* All other common cases are handled very simply.  The matching rules   */
/* are defined in the file `t1tokens.h' through the use of several       */
/* macros calls PARSE_XXX.  This file is included twice here; the first  */
/* time to generate parsing callback functions, the second time to       */
/* generate a table of keywords (with pointers to the associated         */
/* callback functions).                                                  */
/*                                                                       */
/* The function `parse_dict' simply scans *linearly* a given dictionary  */
/* (either the top-level or private one) and calls the appropriate       */
/* callback when it encounters an immediate keyword.                     */
/*                                                                       */
/* This is by far the fastest way one can find to parse and read all     */
/* data.                                                                 */
/*                                                                       */
/* This led to tremendous code size reduction.  Note that later, the     */
/* glyph loader will also be _greatly_ simplified, and the automatic     */
/* hinter will replace the clumsy `t1hinter'.                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    MULTIPLE MASTERS SUPPORT                   *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* allocate design data if needed */
/* allocate the blend `private' and `font_info' dictionaries */
/* allocate axis data if needed */
/* allocate the blend design pos table if needed */
/*************************************************************************/
/*                                                                       */
/* Given a normalized (blend) coordinate, figure out the design          */
/* coordinate appropriate for that value.                                */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* Given a vector of weights, one for each design, figure out the        */
/* normalized axis coordinates which gave rise to those weights.         */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* Just a wrapper around T1_Get_Multi_Master to support the different    */
/*  arguments needed by the GX var distortable fonts.                    */
/*                                                                       */
/* Does not apply */
/* Point to axes after MM_Var struct */
/* Does not apply.  But this value is in range */
/* Does not apply */
/* Does not apply */
/* recompute the weight vector from the blend coordinates */
/* 1.0 fixed */
/* get current blend axis position */
/* compute the blend coordinates through the blend design map */
/* exact match? */
/* now interpolate if necessary */
/*************************************************************************/
/*                                                                       */
/* Just a wrapper around T1_Set_MM_Design to support the different       */
/* arguments needed by the GX var distortable fonts.                     */
/*                                                                       */
/* maximum axis count is 4 */
/* release design pos table */
/* release blend `private' and `font info' dictionaries */
/* release weight vectors */
/* release axis names */
/* release design map */
/* take an array of objects */
/* allocate blend if necessary */
/* each token is an immediate containing the name of the axis */
/* skip first slash, if any */
/* get the array of design tokens -- compute number of designs */
/* make compiler happy */
/* read axis/coordinates tokens */
/* now read each axis token into the design position */
/* now read each axis design map */
/* allocate design map data */
/* don't include delimiting brackets */
/* e.g., /BuildCharArray [0 0 0 0 0 0 0 0] def           */
/* we're only interested in the number of array elements */
/* !T1_CONFIG_OPTION_NO_MM_SUPPORT */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      TYPE 1 SYMBOL PARSING                    *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* if the keyword has a dedicated callback, call it */
/* now, the keyword is either a simple field, or a table of fields; */
/* we are now going to take care of it                              */
/* the binary data has one of the following formats */
/*                                                  */
/*   `size' [white*] RD white ....... ND            */
/*   `size' [white*] -| white ....... |-            */
/*                                                  */
/* `RD' or `-|' or something else */
/* there is only one whitespace char after the */
/* `RD' or `-|' token                          */
/* We now define the routines to handle the `/Encoding', `/Subrs', */
/* and `/CharStrings' dictionaries.                                */
/* Set Units per EM based on FontMatrix values.  We set the value to */
/* 1000 / temp_scale, because temp_scale was already multiplied by   */
/* 1000 (in t1_tofixed, from psobjs.c).                              */
/* we need to scale the values by 1.0/temp_scale */
/* note that the offsets must be expressed in integer font units */
/* if we have a number or `[', the encoding is an array, */
/* and we must load it now                               */
/* read the number of entries in the encoding; should be 256 */
/* we use a T1_Table to store our charnames */
/* We need to `zero' out encoding_table.elements */
/* Now we need to read records of the form                */
/*                                                        */
/*   ... charcode /charname ...                           */
/*                                                        */
/* for each entry in our table.                           */
/*                                                        */
/* We simply look for a number followed by an immediate   */
/* name.  Note that this ignores correctly the sequence   */
/* that is often seen in type1 fonts:                     */
/*                                                        */
/*   0 1 255 { 1 index exch /.notdef put } for dup        */
/*                                                        */
/* used to clean the encoding array before anything else. */
/*                                                        */
/* Alternatively, if the array is directly given as       */
/*                                                        */
/*   /Encoding [ ... ]                                    */
/*                                                        */
/* we only read immediates.                               */
/* we stop when we encounter a `def' or `]' */
/* check whether we've found an entry */
/* protect against invalid charcode */
/* Since the current position is not updated for           */
/* immediates-only mode we would get an infinite loop if   */
/* we don't do anything here.                              */
/*                                                         */
/* This encoding array is not valid according to the type1 */
/* specification (it might be an encoding for a CID type1  */
/* font, however), so we conclude that this font is NOT a  */
/* type1 font.                                             */
/* Otherwise, we should have either `StandardEncoding', */
/* `ExpertEncoding', or `ISOLatin1Encoding'             */
/* test for empty array */
/* position the parser right before the `dup' of the first subr */
/* `array' */
/* initialize subrs array -- with synthetic fonts it is possible */
/* we get here twice                                             */
/* the format is simple:   */
/*                         */
/*   `index' + binary data */
/*                         */
/* If we are out of data, or if the next token isn't `dup', */
/* we are done.                                             */
/* `dup' */
/* The binary string is followed by one token, e.g. `NP' */
/* (bound to `noaccess put') or by two separate tokens:  */
/* `noaccess' & `put'.  We position the parser right     */
/* before the next `dup', if any.                        */
/* `NP' or `|' or `noaccess' */
/* skip `put' */
/* with synthetic fonts it is possible we get here twice */
/* some fonts use a value of -1 for lenIV to indicate that */
/* the charstrings are unencoded                           */
/*                                                         */
/* thanks to Tom Kacvinsky for pointing this out           */
/*                                                         */
/* some fonts define empty subr records -- this is not totally */
/* compliant to the specification (which says they should at   */
/* least contain a `return'), but we support them anyway       */
/* t1_decrypt() shouldn't write to base -- make temporary copy */
/* some fonts like Optima-Oblique not only define the /CharStrings */
/* array but access it also                                        */
/* initialize tables, leaving space for addition of .notdef, */
/* if necessary, and a few other glyphs to handle buggy      */
/* fonts which have more glyphs than specified.              */
/* for some non-standard fonts like `Optima' which provides  */
/* different outlines depending on the resolution it is      */
/* possible to get here twice                                */
/* Initialize table for swapping index notdef_index and */
/* index 0 names and codes (if necessary).              */
/* the format is simple:        */
/*   `/glyphname' + binary data */
/* we stop when we find a `def' or `end' keyword */
/* There are fonts which have this: */
/*                                  */
/*   /CharStrings 118 dict def      */
/*   Private begin                  */
/*   CharStrings begin              */
/*   ...                            */
/*                                  */
/* To catch this we ignore `def' if */
/* no charstring has actually been  */
/* seen.                            */
/* skip `/' */
/* for some non-standard fonts like `Optima' which provides */
/* different outlines depending on the resolution it is     */
/* possible to get here twice                               */
/* add a trailing zero to the name table */
/* record index of /.notdef */
/* t1_decrypt() shouldn't write to base -- make temporary copy */
/* if /.notdef is found but does not occupy index 0, do our magic. */
/* Swap glyph in index 0 with /.notdef glyph.  First, add index 0  */
/* name and code entries to swap_table.  Then place notdef_index   */
/* name and code entries into swap_table.  Then swap name and code */
/* entries at indices notdef_index and 0 using values stored in    */
/* swap_table.                                                     */
/* Index 0 name */
/* Index 0 code */
/* Index notdef_index name */
/* Index notdef_index code */
/* notdef_index is already 0, or /.notdef is undefined in   */
/* charstrings dictionary.  Worry about /.notdef undefined. */
/* We take index 0 and add it to the end of the table(s)    */
/* and add our own /.notdef glyph to index 0.               */
/* 0 333 hsbw endchar */
/* we added a glyph. */
/*************************************************************************/
/*                                                                       */
/* Define the token field static variables.  This is a set of            */
/* T1_FieldRec variables.                                                */
/*                                                                       */
/*************************************************************************/
/* now add the special functions... */
/* look for `eexec' */
/* look for `closefile' which ends the eexec section */
/* in a synthetic font the base font starts after a           */
/* `FontDictionary' token that is placed after a Private dict */
/* check whether we have an integer */
/* in valid Type 1 fonts we don't see `RD' or `-|' directly */
/* since those tokens are handled by parse_subrs and        */
/* parse_charstrings                                        */
/* look for immediates */
/* now compare the immediate name to the keyword table */
/* We found it -- run the parsing callback!     */
/* We record every instance of every field      */
/* (until we reach the base font of a           */
/* synthetic font) to deal adequately with      */
/* multiple master fonts; this is also          */
/* necessary because later PostScript           */
/* definitions override earlier ones.           */
/* Once we encounter `FontDirectory' after      */
/* `/Private', we know that this is a synthetic */
/* font; except for `/CharStrings' we are not   */
/* interested in anything that follows this     */
/* `FontDirectory'.                             */
/* MM fonts have more than one /Private token at */
/* the top level; let's hope that all the junk   */
/* that follows the first /Private token is not  */
/* interesting to us.                            */
/* According to Adobe Tech Note #5175 (CID-Keyed */
/* Font Installation for ATM Software) a `begin' */
/* must be followed by exactly one `end', and    */
/* `begin' -- `end' pairs must be accurately     */
/* paired.  We could use this to distinguish     */
/* between the global Private and the Private    */
/* dict that is a member of the Blend dict.      */
/* initialize the tables -- simply set their `init' field to 0 */
/* finalize tables */
/* finalize parser */
/* default values */
/* ensure even-ness of `num_blue_values' */
/* we don't use it currently so just warn, reset, and ignore */
/* the following can happen for MM instances; we then treat the */
/* font as a normal PS font                                     */
/* another safety check */
/* !T1_CONFIG_OPTION_NO_MM_SUPPORT */
/* now, propagate the subrs, charstrings, and glyphnames tables */
/* to the Type1 data                                            */
/* we copy the glyph names `block' and `elements' fields; */
/* the `lengths' field must be released later             */
/* we must now build type1.encoding when we have a custom array */
/* OK, we do the following: for each element in the encoding  */
/* table, look up the index of the glyph having the same name */
/* the index is then stored in type1.encoding.char_index, and */
/* the name to type1.encoding.char_name                       */
/* Change min/max encoded char only if glyph name is */
/* not /.notdef                                      */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\type1\t1objs.c
/***************************************************************************/
/*                                                                         */
/*  t1objs.c                                                               */
/*                                                                         */
/*    Type 1 objects manager (body).                                       */
/*                                                                         */
/*  Copyright 1996-2009, 2011, 2013 by                                     */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/*                            SIZE FUNCTIONS                             */
/*                                                                       */
/*  note that we store the global hints in the size's "internal" root    */
/*  field                                                                */
/*                                                                       */
/*************************************************************************/
/* T1_Size */
/* T1_Size */
/* T1_Size */
/*************************************************************************/
/*                                                                       */
/*                            SLOT  FUNCTIONS                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/*                            FACE  FUNCTIONS                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    T1_Face_Done                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    The face object destructor.                                        */
/*                                                                       */
/* <Input>                                                               */
/*    face :: A typeless pointer to the face object to destroy.          */
/*                                                                       */
/* T1_Face */
/* release multiple masters information */
/* release font info strings */
/* release top dictionary */
/* release afm data if present */
/* release unicode map, if any */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    T1_Face_Init                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    The face object constructor.                                       */
/*                                                                       */
/* <Input>                                                               */
/*    stream     ::  input stream where to load font data.               */
/*                                                                       */
/*    face_index :: The index of the font face in the resource.          */
/*                                                                       */
/*    num_params :: Number of additional generic parameters.  Ignored.   */
/*                                                                       */
/*    params     :: Additional generic parameters.  Ignored.             */
/*                                                                       */
/* <InOut>                                                               */
/*    face       :: The face record to build.                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* T1_Face */
/* open the tokenizer; this will also check the font format */
/* if we just wanted to check the format, leave successfully now */
/* check the face index */
/* now load the font program into the face object */
/* initialize the face object fields */
/* set up root face fields */
/* XXX: TODO -- add kerning with .afm support */
/* The following code to extract the family and the style is very   */
/* simplistic and might get some things wrong.  For a full-featured */
/* algorithm you might have a look at the whitepaper given at       */
/*                                                                  */
//blogs.msdn.com/text/archive/2007/04/23/wpf-font-selection-model.aspx */
/*   http://blogs.msdn.com/text/archive/2007/04/23/wpf-font-selection-model.aspx */
/* get style name -- be careful, some broken fonts only */
/* have a `/FontName' dictionary entry!                 */
/* do we have a `/FontName'? */
/* assume `Regular' style because we don't know better */
/* compute style flags */
/* no embedded bitmap support */
/* no `U' suffix here to 0xFFFF! */
/* Set units_per_EM if we didn't set it in t1_parse_font_matrix. */
/* now compute the maximum advance width */
/* in case of error, keep the standard width */
/* clear error */
/* first of all, try to synthesize a Unicode charmap */
/* now, generate an Adobe Standard encoding when appropriate */
/* Select default charmap */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    T1_Driver_Init                                                     */
/*                                                                       */
/* <Description>                                                         */
/*    Initializes a given Type 1 driver object.                          */
/*                                                                       */
/* <Input>                                                               */
/*    driver :: A handle to the target driver object.                    */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    T1_Driver_Done                                                     */
/*                                                                       */
/* <Description>                                                         */
/*    Finalizes a given Type 1 driver.                                   */
/*                                                                       */
/* <Input>                                                               */
/*    driver :: A handle to the target Type 1 driver.                    */
/*                                                                       */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\type1\t1parse.c
/***************************************************************************/
/*                                                                         */
/*  t1parse.c                                                              */
/*                                                                         */
/*    Type 1 parser (body).                                                */
/*                                                                         */
/*  Copyright 1996-2005, 2008, 2009, 2012-2014 by                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The Type 1 parser is in charge of the following:                      */
/*                                                                       */
/*  - provide an implementation of a growing sequence of objects called  */
/*    a `T1_Table' (used to build various tables needed by the loader).  */
/*                                                                       */
/*  - opening .pfb and .pfa files to extract their top-level and private */
/*    dictionaries.                                                      */
/*                                                                       */
/*  - read numbers, arrays & strings from any dictionary.                */
/*                                                                       */
/* See `t1load.c' to see how data is loaded from the font file.          */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                   INPUT STREAM PARSER                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* see Adobe Technical Note 5040.Download_Fonts.pdf */
/* We assume that the first segment in a PFB is always encoded as   */
/* text.  This might be wrong (and the specification doesn't insist */
/* on that), but we have never seen a counterexample.               */
/* check the header format */
/******************************************************************/
/*                                                                */
/* Here a short summary of what is going on:                      */
/*                                                                */
/*   When creating a new Type 1 parser, we try to locate and load */
/*   the base dictionary if this is possible (i.e., for PFB       */
/*   files).  Otherwise, we load the whole font into memory.      */
/*                                                                */
/*   When `loading' the base dictionary, we only setup pointers   */
/*   in the case of a memory-based stream.  Otherwise, we         */
/*   allocate and load the base dictionary in it.                 */
/*                                                                */
/*   parser->in_pfb is set if we are in a binary (`.pfb') font.   */
/*   parser->in_memory is set if we have a memory stream.         */
/*                                                                */
/* try to compute the size of the base dictionary;     */
/* look for a Postscript binary file tag, i.e., 0x8001 */
/* assume that this is a PFA file for now; an error will */
/* be produced later when more things are checked        */
/* now, try to load `size' bytes of the `base' dictionary we */
/* found previously                                          */
/* if it is a memory-based resource, set up pointers */
/* check that the `size' field is valid */
/* read segment in memory -- this is clumsy, but so does the format */
/* always free the private dictionary */
/* free the base dictionary only when we have a disk stream */
/* in the case of the PFB format, the private dictionary can be  */
/* made of several segments.  We thus first read the number of   */
/* segments to compute the total size of the private dictionary  */
/* then re-read them into memory.                                */
/* Check that we have a private dictionary there */
/* and allocate private dictionary buffer        */
/* We have already `loaded' the whole PFA font file into memory; */
/* if this is a memory resource, allocate a new block to hold    */
/* the private dict.  Otherwise, simply overwrite into the base  */
/* dictionary block in the heap.                                 */
/* first of all, look at the `eexec' keyword */
/* 9 = 5 letters for `eexec' + */
/* whitespace + 4 chars        */
/* check whether `eexec' was real -- it could be in a comment */
/* or string (as e.g. in u003043t.gsf from ghostscript)       */
/* set limit to `eexec' + whitespace + 4 characters */
/* we haven't found the correct `eexec'; go back and continue */
/* searching                                                  */
/* now determine where to write the _encrypted_ binary private  */
/* dictionary.  We overwrite the base dictionary for disk-based */
/* resources and allocate a new block otherwise                 */
/* According to the Type 1 spec, the first cipher byte must not be */
/* an ASCII whitespace character code (blank, tab, carriage return */
/* or line feed).  We have seen Type 1 fonts with two line feed    */
/* characters...  So skip now all whitespace character codes.      */
/*                                                                 */
/* On the other hand, Adobe's Type 1 parser handles fonts just     */
/* fine that are violating this limitation, so we add a heuristic  */
/* test to stop at \r only if it is not used for EOL.              */
/* note that we allocate one more byte to put a terminating `0' */
/* now determine whether the private dictionary is encoded in binary */
/* or hexadecimal ASCII format -- decode it accordingly              */
/* we need to access the next 4 bytes (after the final whitespace */
/* following the `eexec' keyword); if they all are hexadecimal    */
/* digits, then we have a case of ASCII storage                   */
/* ASCII hexadecimal encoding */
/* put a safeguard */
/* binary encoding -- copy the private dict */
/* we now decrypt the encoded binary private dictionary */
/* replace the four random bytes at the beginning with whitespace */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\type1\type1.c
/***************************************************************************/
/*                                                                         */
/*  type1.c                                                                */
/*                                                                         */
/*    FreeType Type 1 driver component (body only).                        */
/*                                                                         */
/*  Copyright 1996-2001 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\type42\t42drivr.c
/***************************************************************************/
/*                                                                         */
/*  t42drivr.c                                                             */
/*                                                                         */
/*    High-level Type 42 driver interface (body).                          */
/*                                                                         */
/*  Copyright 2002-2004, 2006, 2007, 2009, 2011, 2013 by                   */
/*  Roberto Alameda.                                                       */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* This driver implements Type42 fonts as described in the               */
/* Technical Note #5012 from Adobe, with these limitations:              */
/*                                                                       */
/* 1) CID Fonts are not currently supported.                             */
/* 2) Incremental fonts making use of the GlyphDirectory keyword         */
/*    will be loaded, but the rendering will be using the TrueType       */
/*    tables.                                                            */
/* 3) As for Type1 fonts, CDevProc is not supported.                     */
/* 4) The Metrics dictionary is not supported.                           */
/* 5) AFM metrics are not supported.                                     */
/*                                                                       */
/* In other words, this driver supports Type42 fonts derived from        */
/* TrueType fonts in a non-CID manner, as done by usual conversion       */
/* programs.                                                             */
/*                                                                       */
/*************************************************************************/
/*
/*
/*
/* not implemented */
/*
/* format interface */
/* FT_Face_GetKerningFunc  */
/* FT_Face_AttachFunc      */
/* FT_Face_GetAdvancesFunc */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\type42\t42objs.c
/***************************************************************************/
/*                                                                         */
/*  t42objs.c                                                              */
/*                                                                         */
/*    Type 42 objects manager (body).                                      */
/*                                                                         */
/*  Copyright 2002-2009, 2011, 2013                                        */
/*  by Roberto Alameda.                                                    */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* while parsing the font we always update `face->ttf_size' so that */
/* even in case of buggy data (which might lead to premature end of */
/* scanning without causing an error) the call to `FT_Open_Face' in */
/* `T42_Face_Init' passes the correct size                          */
/* now, propagate the charstrings and glyphnames tables */
/* to the Type1 data                                    */
/* we copy the glyph names `block' and `elements' fields; */
/* the `lengths' field must be released later             */
/* we must now build type1.encoding when we have a custom array */
/* OK, we do the following: for each element in the encoding   */
/* table, look up the index of the glyph having the same name  */
/* as defined in the CharStrings array.                        */
/* The index is then stored in type1.encoding.char_index, and  */
/* the name in type1.encoding.char_name                        */
/* Change min/max encoded char only if glyph name is */
/* not /.notdef                                      */
/***************** Driver Functions *************/
/* T42_Face */
/* open the tokenizer, this will also check the font format */
/* if we just wanted to check the format, leave successfully now */
/* check the face index */
/* Now load the font program into the face object */
/* Init the face object fields */
/* Now set up root face fields */
/* We only set this flag if we have the patented bytecode interpreter. */
/* There are no known `tricky' Type42 fonts that could be loaded with  */
/* the unpatented interpreter.                                         */
/* XXX: TODO -- add kerning with .afm support */
/* get style name -- be careful, some broken fonts only */
/* have a `/FontName' dictionary entry!                 */
/* assume "Regular" style if we don't know better */
/* do we have a `/FontName'? */
/* no embedded bitmap support */
/* Load the TTF font embedded in the T42 font */
/* Ignore info in FontInfo dictionary and use the info from the  */
/* loaded TTF font.  The PostScript interpreter also ignores it. */
/* compute style flags */
/* first of all, try to synthesize a Unicode charmap */
/* now, generate an Adobe Standard encoding when appropriate */
/* Select default charmap */
/* delete internal ttf face prior to freeing face->ttf_data */
/* release font info strings */
/* release top dictionary */
/* release afm data if present */
/* release unicode map, if any */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    T42_Driver_Init                                                    */
/*                                                                       */
/* <Description>                                                         */
/*    Initializes a given Type 42 driver object.                         */
/*                                                                       */
/* <Input>                                                               */
/*    driver :: A handle to the target driver object.                    */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* T42_Driver */
/* T42_Size */
/* T42_Size */
/* T42_Size */
/* T42_Size */
/* T42_GlyphSlot */
/* First glyph slot for this face */
/* T42_GlyphSlot */
/* free bitmap if needed */
/* clear all public fields in the glyph slot */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\type42\t42parse.c
/***************************************************************************/
/*                                                                         */
/*  t42parse.c                                                             */
/*                                                                         */
/*    Type 42 font parser (body).                                          */
/*                                                                         */
/*  Copyright 2002-2014 by                                                 */
/*  Roberto Alameda.                                                       */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* as Type42 fonts have no Private dict,         */
/* we set the last argument of T1_FIELD_XXX to 0 */
/********************* Parsing Functions ******************/
/*******************************************************************/
/*                                                                 */
/* Here a short summary of what is going on:                       */
/*                                                                 */
/*   When creating a new Type 42 parser, we try to locate and load */
/*   the base dictionary, loading the whole font into memory.      */
/*                                                                 */
/*   When `loading' the base dictionary, we only set up pointers   */
/*   in the case of a memory-based stream.  Otherwise, we allocate */
/*   and load the base dictionary in it.                           */
/*                                                                 */
/*   parser->in_memory is set if we have a memory stream.          */
/*                                                                 */
/* now, try to load `size' bytes of the `base' dictionary we */
/* found previously                                          */
/* if it is a memory-based resource, set up pointers */
/* check that the `size' field is valid */
/* read segment in memory */
/* free the base dictionary only when we have a disk stream */
/* Set Units per EM based on FontMatrix values.  We set the value to */
/* 1000 / temp_scale, because temp_scale was already multiplied by   */
/* 1000 (in t1_tofixed, from psobjs.c).                              */
/* we need to scale the values by 1.0/temp_scale */
/* note that the offsets must be expressed in integer font units */
/* if we have a number or `[', the encoding is an array, */
/* and we must load it now                               */
/* read the number of entries in the encoding; should be 256 */
/* we use a T1_Table to store our charnames */
/* We need to `zero' out encoding_table.elements */
/* Now we need to read records of the form                */
/*                                                        */
/*   ... charcode /charname ...                           */
/*                                                        */
/* for each entry in our table.                           */
/*                                                        */
/* We simply look for a number followed by an immediate   */
/* name.  Note that this ignores correctly the sequence   */
/* that is often seen in type42 fonts:                    */
/*                                                        */
/*   0 1 255 { 1 index exch /.notdef put } for dup        */
/*                                                        */
/* used to clean the encoding array before anything else. */
/*                                                        */
/* Alternatively, if the array is directly given as       */
/*                                                        */
/*   /Encoding [ ... ]                                    */
/*                                                        */
/* we only read immediates.                               */
/* we stop when we encounter `def' or `]' */
/* check whether we have found an entry */
/* Since the current position is not updated for           */
/* immediates-only mode we would get an infinite loop if   */
/* we don't do anything here.                              */
/*                                                         */
/* This encoding array is not valid according to the type1 */
/* specification (it might be an encoding for a CID type1  */
/* font, however), so we conclude that this font is NOT a  */
/* type1 font.                                             */
/* Otherwise, we should have either `StandardEncoding', */
/* `ExpertEncoding', or `ISOLatin1Encoding'             */
/* The format is                                */
/*                                              */
/*   /sfnts [ <hexstring> <hexstring> ... ] def */
/*                                              */
/* or                                           */
/*                                              */
/*   /sfnts [                                   */
/*      <num_bin_bytes> RD <binary data>        */
/*      <num_bin_bytes> RD <binary data>        */
/*      ...                                     */
/*   ] def                                      */
/*                                              */
/* with exactly one space after the `RD' token. */
/* don't include delimiters */
/* `RD' */
/* one space after `RD' */
/* A string can have a trailing zero (odd) byte for padding. */
/* Ignore it.                                                */
/* load offset table, 12 bytes */
/* fall through */
/* the offset table is read; read the table directory */
/* Pad to a 4-byte boundary length */
/* there are no more than 256 tables, so no size check here */
/* fall through */
/* all other tables are just copied */
/* if control reaches this point, the format was not valid */
/* We have `<< ... >>'.  Count the number of `/' in the dictionary */
/* to get its size.                                                */
/* rewind */
/* initialize tables */
/* Initialize table for swapping index notdef_index and */
/* index 0 names and codes (if necessary).              */
/* The format is simple:                   */
/*   `/glyphname' + index [+ def]          */
/* We stop when we find an `end' keyword or '>' */
/* skip `/' */
/* add a trailing zero to the name table */
/* record index of /.notdef */
/* if /.notdef does not occupy index 0, do our magic. */
/* Swap glyph in index 0 with /.notdef glyph.  First, add index 0  */
/* name and code entries to swap_table.  Then place notdef_index   */
/* name and code entries into swap_table.  Then swap name and code */
/* entries at indices notdef_index and 0 using values stored in    */
/* swap_table.                                                     */
/* Index 0 name */
/* Index 0 code */
/* Index notdef_index name */
/* Index notdef_index code */
/* if the keyword has a dedicated callback, call it */
/* now the keyword is either a simple field or a table of fields; */
/* we are now going to take care of it                            */
/* look for `FontDirectory' which causes problems for some fonts */
/* skip the `FontDirectory' keyword */
/* look up the `known' keyword */
/* skip the `known' keyword and the token following it */
/* if the last token was an array, skip it! */
/* look for immediates */
/* now compare the immediate name to the keyword table */
/* loop through all known keywords */
/* we found it -- run the parsing callback! */
/* initialize the tables -- simply set their `init' field to 0 */
/* finalize tables */
/* finalize parser */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\type42\type42.c
/***************************************************************************/
/*                                                                         */
/*  type42.c                                                               */
/*                                                                         */
/*    FreeType Type 42 driver component.                                   */
/*                                                                         */
/*  Copyright 2002 by                                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\freetype\src\winfonts\winfnt.c
/***************************************************************************/
/*                                                                         */
/*  winfnt.c                                                               */
/*                                                                         */
/*    FreeType font driver for Windows FNT/FON files                       */
/*                                                                         */
/*  Copyright 1996-2004, 2006-2014 by                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*  Copyright 2003 Huw D M Davies for Codeweavers                          */
/*  Copyright 2007 Dmitry Timoshkov for Codeweavers                        */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* PE00 */
/* 0x014C - i386 */
/* 0x10B */
/* first of all, read the FNT header */
/* check header */
/* Version 2 doesn't have these fields */
/* this is a FNT file/table; extract its frame */
/* does it begin with an MZ header? */
/* yes, now look for an NE header in the file */
/* good, now look into the resource table for each FNT resource */
/* loading `winfnt_header_fields' needs at least 118 bytes;    */
/* use this as a rough measure to check the expected font size */
/* check full signature */ ||
/* i386 */                        ||
/* FIXME */         ||
/* DataIsDirectory */ )
/* DataIsDirectory */ )
/* DataIsDirectory */ )
/* RT_FONT */ )
/* we artificially increase the glyph index; */
/* FNT_Load_Glyph reverts to the right one   */
/* FNT_Face */
/* FNT_Face */
/* try to load font from a DLL */
/* this didn't work; try to load a single FNT font */
/* we now need to fill the root FT_Face fields */
/* with relevant information                   */
/* set up the `fixed_sizes' array */
/*
/* initial platform/encoding should indicate unset status? */
/*        charmap.encoding_id = TT_MAC_ID_ROMAN; */
/* Select default charmap */
/* set up remaining flags */
/* reserve one slot for the .notdef glyph at index 0 */
/* Some broken fonts don't delimit the face name with a final */
/* NULL byte -- the frame is erroneously one byte too small.  */
/* We thus allocate one more byte, setting it explicitly to   */
/* zero.                                                      */
/* revert to real index */
/* the `.notdef' glyph  */
/* get glyph width and offset */
/* jump to glyph entry */
/* jump to glyph data */
/* font->header.bits_offset */ + offset;
/* allocate and build bitmap */
/* note: since glyphs are stored in columns and not in rows we */
/*       can't use ft_glyphslot_set_bitmap                     */
/* now set up metrics */
/*
/* FT_Module_Constructor */
/* FT_Module_Destructor  */
/* FT_Size_InitFunc */
/* FT_Size_DoneFunc */
/* FT_Slot_InitFunc */
/* FT_Slot_DoneFunc */
/* FT_Face_GetKerningFunc  */
/* FT_Face_AttachFunc      */
/* FT_Face_GetAdvancesFunc */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jaricom.c
/*
/* The following #define specifies the packing of the four components
/*
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jcapimin.c
/*
/*
/* Guard against version mismatches between library and caller. */
/* so jpeg_destroy knows mem mgr not called */
/* For debugging purposes, we zero the whole master structure.
/* ignore Purify complaint here */
/* Initialize a memory manager instance for this object */
/* Zero out pointers to permanent structures. */
/* Must do it here for emit_dqt in case jpeg_write_tables is used */
/* in case application forgets */
/* OK, I'm ready */
/*
/* use common routine */
/*
/* use common routine */
/*
/*
/* Terminate first pass */
/* Perform any remaining passes */
/* We bypass the main controller and invoke coef controller directly;
/* Write EOI, do final cleanup */
/* We can use jpeg_abort to release memory and reset global_state */
/*
/* copy for speed */
/* Same, but piecemeal. */
/*
/* (Re)initialize error mgr and destination modules */
/* Initialize the marker writer ... bit of a crock to do it here. */
/* Write them tables! */
/* And clean up. */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jcapistd.c
/*
/*
/* mark all tables to be written */
/* (Re)initialize error mgr and destination modules */
/* Perform master selection of active modules */
/* Set up for the first pass */
/* Ready for application to drive first pass through jpeg_write_scanlines
/*
/* Call progress monitor hook if present */
/* Give master control module another chance if this is first call to
/* Ignore any extra scanlines at bottom of image. */
/*
/* Call progress monitor hook if present */
/* Give master control module another chance if this is first call to
/* Verify that at least one iMCU row has been passed. */
/* Directly compress the row. */
/* If compressor did not consume the whole row, suspend processing. */
/* OK, we processed one iMCU row. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jcarith.c
/*
/* Expanded entropy encoder object for arithmetic encoding. */
/* public fields */
/* C register, base of coding interval, layout as in sec. D.1.3 */
/* A register, normalized size of coding interval */
/* counter for stacked 0xFF values which might overflow */
/* counter for pending 0x00 output values which might *
/* bit shift counter, determines when next byte will be written */
/* buffer for most recent output byte != 0xFF */
/* last DC coef for each component */
/* context index for DC conditioning */
/* MCUs left in this restart interval */
/* next restart number to write (0-7) */
/* Pointers to statistics areas (these workspaces have image lifespan) */
/* Statistics bin for coding with fixed probability 0.5 */
/* The following two definitions specify the allocation chunk size
/* NOTE: Uncomment the following #define if you want to use the
/* IRIGHT_SHIFT is like RIGHT_SHIFT, but works on int rather than INT32.
/* Write next output byte; we do not support suspension in this module. */
/*
/* Section D.1.8: Termination of encoding */
/* Find the e->c in the coding interval with the largest
/* Send remaining bytes to output */
/* One final overflow has to be handled */
/* carry-over converts stacked 0xFF bytes to 0x00 */
/* Output final bytes only if they are not 0x00 */
/* output final pending zero bytes */
/*
/* Fetch values from our compact representation of Table D.3(D.2):
/* => Qe_Value */
/* Next_Index_LPS + Switch_MPS */
/* Next_Index_MPS */
/* Encode & estimation procedures per sections D.1.4 & D.1.5 */
/* Encode the less probable symbol */
/* If the interval size (qe) for the less probable symbol (LPS)
/* Estimate_after_LPS */
/* Encode the more probable symbol */
/* A >= 0x8000 -> ready, no renormalization required */
/* If the interval size (qe) for the less probable symbol (LPS)
/* Estimate_after_MPS */
/* Renormalization & data output per section D.1.6 */
/* Another byte is ready for output */
/* Handle overflow over all stacked 0xFF bytes */
/* carry-over converts stacked 0xFF bytes to 0x00 */
/* Note: The 3 spacer bits in the C register guarantee
/* new output byte, might overflow later */
/* stack 0xFF byte (which might overflow later) */
/* Output all stacked 0xFF bytes, they will not overflow any more */
/* new output byte (can still overflow) */
/*
/* Re-initialize statistics areas */
/* DC needs no table for refinement scan */
/* Reset DC predictions to 0 */
/* AC needs no table when not present */
/* Reset arithmetic encoding variables */
/* empty */
/*
/* Emit restart marker if needed */
/* Encode the MCU data blocks */
/* Compute the DC value after the required point transform by Al.
/* Sections F.1.4.1 & F.1.4.4.1: Encoding of DC coefficients */
/* Table F.4: Point to statistics bin S0 for DC coefficient coding */
/* Figure F.4: Encode_DC_DIFF */
/* zero diff category */
/* Figure F.6: Encoding nonzero value v */
/* Figure F.7: Encoding the sign of v */
/* Table F.4: SS = S0 + 1 */
/* Table F.4: SP = S0 + 2 */
/* small positive diff category */
/* Table F.4: SS = S0 + 1 */
/* Table F.4: SN = S0 + 3 */
/* small negative diff category */
/* Figure F.8: Encoding the magnitude category of v */
/* Table F.4: X1 = 20 */
/* Section F.1.4.4.1.2: Establish dc_context conditioning category */
/* zero diff category */
/* large diff category */
/* Figure F.9: Encoding the magnitude bit pattern of v */
/*
/* Emit restart marker if needed */
/* Encode the MCU data block */
/* Sections F.1.4.2 & F.1.4.4.2: Encoding of AC coefficients */
/* Establish EOB (end-of-block) index */
/* We must apply the point transform by Al.  For AC coefficients this
/* Figure F.5: Encode_AC_Coefficients */
/* EOB decision */
/* Figure F.8: Encoding the magnitude category of v */
/* Figure F.9: Encoding the magnitude bit pattern of v */
/* Encode EOB decision only if k <= cinfo->Se */
/*
/* Emit restart marker if needed */
/* use fixed probability estimation */
/* Encode the MCU data blocks */
/* We simply emit the Al'th bit of the DC coefficient value. */
/*
/* Emit restart marker if needed */
/* Encode the MCU data block */
/* Section G.1.3.3: Encoding of AC coefficients */
/* Establish EOB (end-of-block) index */
/* We must apply the point transform by Al.  For AC coefficients this
/* Establish EOBx (previous stage end-of-block) index */
/* Figure G.10: Encode_AC_Coefficients_SA */
/* EOB decision */
/* previously nonzero coef */
/* newly nonzero coef */
/* previously nonzero coef */
/* newly nonzero coef */
/* Encode EOB decision only if k <= cinfo->Se */
/*
/* Emit restart marker if needed */
/* Encode the MCU data blocks */
/* Sections F.1.4.1 & F.1.4.4.1: Encoding of DC coefficients */
/* Table F.4: Point to statistics bin S0 for DC coefficient coding */
/* Figure F.4: Encode_DC_DIFF */
/* zero diff category */
/* Figure F.6: Encoding nonzero value v */
/* Figure F.7: Encoding the sign of v */
/* Table F.4: SS = S0 + 1 */
/* Table F.4: SP = S0 + 2 */
/* small positive diff category */
/* Table F.4: SS = S0 + 1 */
/* Table F.4: SN = S0 + 3 */
/* small negative diff category */
/* Figure F.8: Encoding the magnitude category of v */
/* Table F.4: X1 = 20 */
/* Section F.1.4.4.1.2: Establish dc_context conditioning category */
/* zero diff category */
/* large diff category */
/* Figure F.9: Encoding the magnitude bit pattern of v */
/* Sections F.1.4.2 & F.1.4.4.2: Encoding of AC coefficients */
/* Establish EOB (end-of-block) index */
/* Figure F.5: Encode_AC_Coefficients */
/* EOB decision */
/* Figure F.6: Encoding nonzero value v */
/* Figure F.7: Encoding the sign of v */
/* Figure F.8: Encoding the magnitude category of v */
/* Figure F.9: Encoding the magnitude bit pattern of v */
/* Encode EOB decision only if k < cinfo->lim_Se */
/*
/* Make sure to avoid that in the master control logic!
/* We assume jcmaster.c already validated the progressive scan parameters. */
/* Select execution routines */
/* Allocate & initialize requested statistics areas */
/* DC needs no table for refinement scan */
/* Initialize DC predictions to 0 */
/* AC needs no table when not present */
/* Section G.1.3.2: Set appropriate arithmetic conditioning value Kx */
/* Initialize arithmetic encoding variables */
/* empty */
/* Initialize restart stuff */
/*
/* Mark tables unallocated */
/* Initialize index for fixed probability estimation */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jccoefct.c
/*
/* We use a full-image coefficient buffer when doing Huffman optimization,
/* Private buffer controller object */
/* public fields */
/* iMCU row # within image */
/* counts MCUs processed in current row */
/* counts MCU rows within iMCU row */
/* number of such rows needed */
/* For single-pass compression, it's sufficient to buffer just one MCU
/* In multi-pass modes, we need a virtual block array for each component. */
/* Forward declarations */
/* Reset within-iMCU-row counters for a new row */
/* In an interleaved scan, an MCU row is the same as an iMCU row.
/*
/*
/* index of current MCU within row */
/* Loop to write as much as one whole iMCU row */
/* Determine where data comes from in input_buf and do the DCT thing.
/* ypos == (yoffset+yindex) * DCTSIZE */
/* Create some dummy blocks at the right edge of the image. */
/* Create a row of dummy blocks at the bottom of the image. */
/* Try to write the MCU.  In event of a suspension failure, we will
/* Suspension forced; update state counters and exit */
/* Completed an MCU row, but perhaps not an iMCU row */
/* Completed the iMCU row, advance counters for next one */
/*
/* Align the virtual buffer for this component. */
/* Count non-dummy DCT block rows in this iMCU row. */
/* NB: can't use last_row_height here, since may not be set! */
/* Count number of dummy blocks to be added at the right margin. */
/* Perform DCT for all non-dummy blocks in this iMCU row.  Each call
/* Create dummy blocks at the right edge of the image. */
/* => first dummy block */
/* If at end of image, create dummy block rows as needed.
/* include lower right corner */
/* advance to next MCU in row */
/* NB: compress_output will increment iMCU_row_num if successful.
/* Emit data to the entropy encoder, sharing code with subsequent passes */
/*
/* index of current MCU within row */
/* Align the virtual buffers for the components used in this scan.
/* Loop to process one whole iMCU row */
/* Construct list of pointers to DCT blocks belonging to this MCU */
/* index of current DCT block within MCU */
/* Try to write the MCU. */
/* Suspension forced; update state counters and exit */
/* Completed an MCU row, but perhaps not an iMCU row */
/* Completed the iMCU row, advance counters for next one */
/* FULL_COEF_BUFFER_SUPPORTED */
/*
/* Create the coefficient buffer. */
/* Allocate a full-image virtual array for each component, */
/* padded to a multiple of samp_factor DCT blocks in each direction. */
/* We only need a single-MCU buffer. */
/* flag for no virtual arrays */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jccolor.c
/*
/* Private subobject */
/* public fields */
/* Private state for RGB->YCC conversion */
/* => table for RGB to YCbCr conversion */
/**************** RGB -> YCbCr conversion: most common case **************/
/*
/* speediest right-shift on some machines */
/* We allocate one big table and divide it up into eight parts, instead of
/* offset to R => Y section */
/* offset to G => Y section */
/* etc. */
/* B=>Cb, R=>Cr are the same */
/*
/* Allocate and fill in the conversion tables. */
/* We use a rounding fudge-factor of 0.5-epsilon for Cb and Cr.
/*  B=>Cb and R=>Cr tables are the same
/*
/* If the inputs are 0..MAXJSAMPLE, the outputs of these equations
/* Y */
/* Cb */
/* Cr */
/**************** Cases other than RGB -> YCbCr **************/
/*
/* Y */
/*
/* K passes through as-is */
/* don't need GETJSAMPLE here */
/* If the inputs are 0..MAXJSAMPLE, the outputs of these equations
/* Y */
/* Cb */
/* Cr */
/*
/* don't need GETJSAMPLE() here */
/*
/* We can dispense with GETJSAMPLE() here */
/*
/* It seems fastest to make a separate pass for each component. */
/* don't need GETJSAMPLE() here */
/*
/* no work needed */
/*
/* set start_pass to null method until we find out differently */
/* Make sure input_components agrees with in_color_space */
/* JCS_UNKNOWN can be anything */
/* Check num_components, set conversion method based on requested space */
/* allow null conversion of JCS_UNKNOWN */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jcdctmgr.c
/*
/* Private declarations for DCT subsystem */
/* Private subobject for this module */
/* public fields */
/* Pointer to the DCT routine actually in use */
/* The actual post-DCT divisors --- not identical to the quant table
/* Same as above for the floating-point case. */
/* The current scaled-DCT routines require ISLOW-style divisor tables,
/*
/* This version is used for integer DCT implementations. */
/* This routine is heavily used, so it's worth coding it tightly. */
/* work area for FDCT subroutine */
/* fold in the vertical offset once */
/* Perform the DCT */
/* Quantize/descale the coefficients, and store into coef_blocks[] */
/* Divide the coefficient value by qval, ensuring proper rounding.
/* for rounding */
/* for rounding */
/* This version is used for floating-point DCT implementations. */
/* This routine is heavily used, so it's worth coding it tightly. */
/* work area for FDCT subroutine */
/* fold in the vertical offset once */
/* Perform the DCT */
/* Quantize/descale the coefficients, and store into coef_blocks[] */
/* Apply the quantization and scaling factor */
/* Round to nearest integer.
/* DCT_FLOAT_SUPPORTED */
/*
/* Select the proper DCT routine for this component's scaling */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* jfdctint uses islow-style table */
/* Make sure specified quantization table is present */
/* Compute divisors for this quant table */
/* We may do this more than once for same table, but it's not a big deal */
/* For LL&M IDCT method, divisors are equal to raw quantization
/* For AA&N IDCT method, divisors are equal to quantization
/* precomputed values scaled up by 14 bits */
/* For float AA&N IDCT method, divisors are equal to quantization
/*
/* Mark divisor tables unallocated */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jchuff.c
/*
/* The legal range of a DCT coefficient is
/* Derived data constructed for each Huffman table */
/* code for each symbol */
/* length of code for each symbol */
/* If no code has been allocated for a symbol S, ehufsi[S] contains 0 */
/* Expanded entropy encoder object for Huffman encoding.
/* current bit-accumulation buffer */
/* # of bits now in it */
/* last DC coef for each component */
/* This macro is to work around compilers with missing or broken
/* public fields */
/* Bit buffer & DC state at start of MCU */
/* These fields are NOT loaded into local working state. */
/* MCUs left in this restart interval */
/* next restart number to write (0-7) */
/* Pointers to derived tables (these workspaces have image lifespan) */
/* Statistics tables for optimization */
/* Following fields used only in progressive mode */
/* Mode flag: TRUE for optimization, FALSE for actual data output */
/* next_output_byte/free_in_buffer are local copies of cinfo->dest fields.
/* => next byte to write in buffer */
/* # of byte spaces remaining in buffer */
/* link to cinfo (needed for dump_buffer) */
/* Coding status for AC components */
/* the table number of the single component */
/* run length of EOBs */
/* # of buffered correction bits before MCU */
/* buffer for correction bits (1 per char) */
/* packing correction bits tightly would save some space but cost time... */
/* Working state while writing an MCU (sequential mode).
/* => next byte to write in buffer */
/* # of byte spaces remaining in buffer */
/* Current bit buffer & DC state */
/* dump_buffer needs access to this */
/* MAX_CORR_BITS is the number of bits the AC refinement correction-bit
/* Max # of correction bits I can buffer */
/* IRIGHT_SHIFT is like RIGHT_SHIFT, but works on int rather than INT32.
/*
/* Note that huffsize[] and huffcode[] are filled in code-length order,
/* Find the input Huffman table */
/* Allocate a workspace if we haven't already done so. */
/* Figure C.1: make table of Huffman code length for each symbol */
/* protect against table overrun */
/* Figure C.2: generate the codes themselves */
/* We also validate that the counts represent a legal Huffman code tree. */
/* code is now 1 more than the last code used for codelength si; but
/* Figure C.3: generate encoding tables */
/* These are code and size indexed by symbol value */
/* Set all codeless symbols to have code length 0;
/* This is also a convenient place to check for out-of-range
/* Outputting bytes to the file.
/* Emit a byte, taking 'action' if must suspend. */
/* Emit a byte */
/* Empty the output buffer; return TRUE if successful, FALSE if must suspend */
/* After a successful buffer dump, must reset buffer pointers */
/* Empty the output buffer; we do not support suspension in this case. */
/* After a successful buffer dump, must reset buffer pointers */
/* Outputting bits to the file */
/* Only the right 24 bits of put_buffer are used; the valid bits are
/* Emit some bits; return TRUE if successful, FALSE if must suspend */
/* This routine is heavily used, so it's worth coding tightly. */
/* if size is 0, caller used an invalid Huffman table entry */
/* mask off any extra bits in code */
/* new number of bits in buffer */
/* align incoming bits */
/* and merge with old buffer contents */
/* need to stuff a zero byte? */
/* update state variables */
/* Emit some bits, unless we are in gather mode */
/* This routine is heavily used, so it's worth coding tightly. */
/* if size is 0, caller used an invalid Huffman table entry */
/* do nothing if we're only getting stats */
/* mask off any extra bits in code */
/* new number of bits in buffer */
/* align incoming bits */
/* and merge with old buffer contents */
/* need to stuff a zero byte? */
/* update variables */
/* fill any partial byte with ones */
/* and reset bit-buffer to empty */
/* fill any partial byte with ones */
/* and reset bit-buffer to empty */
/*
/*
/* no real work */
/*
/* if there is any pending EOBRUN */
/* safety check: shouldn't happen given limited correction-bit buffer */
/* Emit any buffered correction bits */
/*
/* Re-initialize DC predictions to 0 */
/* The restart counter is not updated until we successfully write the MCU. */
/* Re-initialize DC predictions to 0 */
/* Re-initialize all AC-related fields to 0 */
/*
/* Emit restart marker if needed */
/* Encode the MCU data blocks */
/* Compute the DC value after the required point transform by Al.
/* DC differences are figured on the point-transformed values. */
/* Encode the DC coefficient difference per section G.1.2.1 */
/* temp is abs value of input */
/* For a negative input, want temp2 = bitwise complement of abs(input) */
/* This code assumes we are on a two's complement machine */
/* Find the number of bits needed for the magnitude of the coefficient */
/* Check for out-of-range coefficient values.
/* Count/emit the Huffman-coded symbol for the number of bits */
/* Emit that number of bits of the value, if positive, */
/* or the complement of its magnitude, if negative. */
/* emit_bits rejects calls with size 0 */
/* Update restart-interval state too */
/*
/* Emit restart marker if needed */
/* Encode the MCU data block */
/* Encode the AC coefficients per section G.1.2.2, fig. G.3 */
/* r = run length of zeros */
/* We must apply the point transform by Al.  For AC coefficients this
/* temp is abs value of input */
/* apply the point transform */
/* For a negative coef, want temp2 = bitwise complement of abs(coef) */
/* apply the point transform */
/* Watch out for case that nonzero coef is zero after point transform */
/* Emit any pending EOBRUN */
/* if run length > 15, must emit special run-length-16 codes (0xF0) */
/* Find the number of bits needed for the magnitude of the coefficient */
/* there must be at least one 1 bit */
/* Check for out-of-range coefficient values */
/* Count/emit Huffman symbol for run length / number of bits */
/* Emit that number of bits of the value, if positive, */
/* or the complement of its magnitude, if negative. */
/* reset zero run length */
/* If there are trailing zeroes, */
/* count an EOB */
/* force it out to avoid overflow */
/* Update restart-interval state too */
/*
/* Emit restart marker if needed */
/* Encode the MCU data blocks */
/* We simply emit the Al'th bit of the DC coefficient value. */
/* Update restart-interval state too */
/*
/* Emit restart marker if needed */
/* Encode the MCU data block */
/* It is convenient to make a pre-pass to determine the transformed
/* We must apply the point transform by Al.  For AC coefficients this
/* temp is abs value of input */
/* apply the point transform */
/* save abs value for main pass */
/* EOB = index of last newly-nonzero coef */
/* Encode the AC coefficients per section G.1.2.3, fig. G.7 */
/* r = run length of zeros */
/* BR = count of buffered bits added now */
/* Append bits to buffer */
/* Emit any required ZRLs, but not if they can be folded into EOB */
/* emit any pending EOBRUN and the BE correction bits */
/* Emit ZRL */
/* Emit buffered correction bits that must be associated with ZRL */
/* BE bits are gone now */
/* If the coef was previously nonzero, it only needs a correction bit.
/* The correction bit is the next bit of the absolute value. */
/* Emit any pending EOBRUN and the BE correction bits */
/* Count/emit Huffman symbol for run length / number of bits */
/* Emit output bit for newly-nonzero coef */
/* Emit buffered correction bits that must be associated with this code */
/* BE bits are gone now */
/* reset zero run length */
/* If there are trailing zeroes, */
/* count an EOB */
/* concat my correction bits to older ones */
/* We force out the EOB if we risk either:
/* Update restart-interval state too */
/* Encode a single block's worth of coefficients */
/* Encode the DC coefficient difference per section F.1.2.1 */
/* temp is abs value of input */
/* For a negative input, want temp2 = bitwise complement of abs(input) */
/* This code assumes we are on a two's complement machine */
/* Find the number of bits needed for the magnitude of the coefficient */
/* Check for out-of-range coefficient values.
/* Emit the Huffman-coded symbol for the number of bits */
/* Emit that number of bits of the value, if positive, */
/* or the complement of its magnitude, if negative. */
/* emit_bits rejects calls with size 0 */
/* Encode the AC coefficients per section F.1.2.2 */
/* r = run length of zeros */
/* if run length > 15, must emit special run-length-16 codes (0xF0) */
/* temp is abs value of input */
/* This code assumes we are on a two's complement machine */
/* Find the number of bits needed for the magnitude of the coefficient */
/* there must be at least one 1 bit */
/* Check for out-of-range coefficient values */
/* Emit Huffman symbol for run length / number of bits */
/* Emit that number of bits of the value, if positive, */
/* or the complement of its magnitude, if negative. */
/* If the last coef(s) were zero, emit an end-of-block code */
/*
/* Load up working state */
/* Emit restart marker if needed */
/* Encode the MCU data blocks */
/* Update last_dc_val */
/* Completed MCU, so update state */
/* Update restart-interval state too */
/*
/* Flush out any buffered data */
/* Load up working state ... flush_bits needs it */
/* Flush out the last data */
/* Update state */
/*
/* Process a single block's worth of coefficients */
/* Encode the DC coefficient difference per section F.1.2.1 */
/* Find the number of bits needed for the magnitude of the coefficient */
/* Check for out-of-range coefficient values.
/* Count the Huffman symbol for the number of bits */
/* Encode the AC coefficients per section F.1.2.2 */
/* r = run length of zeros */
/* if run length > 15, must emit special run-length-16 codes (0xF0) */
/* Find the number of bits needed for the magnitude of the coefficient */
/* Find the number of bits needed for the magnitude of the coefficient */
/* there must be at least one 1 bit */
/* Check for out-of-range coefficient values */
/* Count Huffman symbol for run length / number of bits */
/* If the last coef(s) were zero, emit an end-of-block code */
/*
/* Take care of restart intervals if needed */
/* Re-initialize DC predictions to 0 */
/* Update restart state */
/*
/* assumed maximum initial code length */
/* bits[k] = # of symbols with code length k */
/* codesize[k] = code length of symbol k */
/* next symbol in current branch of tree */
/* This algorithm is explained in section K.2 of the JPEG standard */
/* init links to empty */
/* make sure 256 has a nonzero count */
/* Including the pseudo-symbol 256 in the Huffman procedure guarantees
/* Huffman's basic algorithm to assign optimal code lengths to symbols */
/* Find the smallest nonzero frequency, set c1 = its symbol */
/* In case of ties, take the larger symbol number */
/* Find the next smallest nonzero frequency, set c2 = its symbol */
/* In case of ties, take the larger symbol number */
/* Done if we've merged everything into one frequency */
/* Else merge the two counts/trees */
/* Increment the codesize of everything in c1's tree branch */
/* chain c2 onto c1's tree branch */
/* Increment the codesize of everything in c2's tree branch */
/* Now count the number of symbols of each code length */
/* The JPEG standard seems to think that this can't happen, */
/* but I'm paranoid... */
/* JPEG doesn't allow symbols with code lengths over 16 bits, so if the pure
/* find length of new prefix to be used */
/* remove two symbols */
/* one goes in this length */
/* two new symbols in this length */
/* symbol of this length is now a prefix */
/* Remove the count for the pseudo-symbol 256 from the largest codelength */
/* find largest codelength still in use */
/* Return final symbol counts (only for lengths 0..16) */
/* Return a list of the symbols sorted by code length */
/* It's not real clear to me why we don't need to consider the codelength
/* Set sent_table FALSE so updated table will be written to JPEG file. */
/*
/* It's important not to apply jpeg_gen_optimal_table more than once
/* Flush out buffered data (all we care about is counting the EOB symbol) */
/* DC needs no table for refinement scan */
/* AC needs no table when not present */
/*
/* We assume jcmaster.c already validated the scan parameters. */
/* Select execution routine */
/* AC refinement needs a correction bit buffer */
/* Initialize AC stuff */
/* DC needs no table for refinement scan */
/* Check for invalid table index */
/* (make_c_derived_tbl does this in the other path) */
/* Allocate and zero the statistics tables */
/* Note that jpeg_gen_optimal_table expects 257 entries in each table! */
/* Compute derived values for Huffman tables */
/* We may do this more than once for a table, but it's not expensive */
/* Initialize DC predictions to 0 */
/* AC needs no table when not present */
/* Initialize bit buffer to empty */
/* Initialize restart stuff */
/*
/* Mark tables unallocated */
/* needed only in AC refinement scan */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jcinit.c
/*
/*
/* Initialize master control (includes parameter checking/processing) */
/* full compression */);
/* Preprocessing */
/* never need full buffer here */);
/* Forward DCT */
/* Entropy encoding: either Huffman or arithmetic coding. */
/* Need a full-image coefficient buffer in any multi-pass mode. */
/* never need full buffer here */);
/* We can now tell the memory manager to allocate virtual arrays. */
/* Write the datastream header (SOI) immediately.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jcmainct.c
/*
/* Note: currently, there is no operating mode in which a full-image buffer
/* Private buffer controller object */
/* public fields */
/* number of current iMCU row */
/* counts row groups received in iMCU row */
/* remember if we suspended output */
/* current operating mode */
/* If using just a strip buffer, this points to the entire set of buffers
/* If using full-image storage, this array holds pointers to virtual-array
/* Forward declarations */
/*
/* Do nothing in raw-data mode. */
/* initialize counters */
/* save mode for use by process_data */
/*
/* Read input data if we haven't filled the main buffer yet */
/* If we don't have a full iMCU row buffered, return to application for
/* Send the completed row to the compressor */
/* If compressor did not consume the whole row, then we must need to
/* We did finish the row.  Undo our little suspension hack if a previous
/*
/* Realign the virtual buffers if at the start of an iMCU row. */
/* In a read pass, pretend we just read some source data. */
/* If a write pass, read input data until the current iMCU row is full. */
/* Note: preprocessor will pad if necessary to fill the last iMCU row. */
/* Return to application if we need more data to fill the iMCU row. */
/* Emit data, unless this is a sink-only pass. */
/* If compressor did not consume the whole row, then we must need to
/* We did finish the row.  Undo our little suspension hack if a previous
/* If get here, we are done with this iMCU row.  Mark buffer empty. */
/* FULL_MAIN_BUFFER_SUPPORTED */
/*
/* We don't need to create a buffer in raw-data mode. */
/* Create the buffer.  It holds downsampled data, so each component
/* Allocate a full-image virtual array for each component */
/* Note we pad the bottom to a multiple of the iMCU height */
/* flag for no virtual arrays */
/* Allocate a strip buffer for each component */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jcmarker.c
/*
/* JPEG marker codes */
/* Private state */
/* public fields */
/* last DRI value emitted; 0 after SOI */
/*
/* Emit a byte */
/* Emit a marker code */
/* Emit a 2-byte integer; these are always MSB first in JPEG files */
/*
/* Emit a DQT marker */
/* Returns the precision used (0 = 8bits, 1 = 16bits) for baseline checking */
/* The table entries must be emitted in zigzag order. */
/* Emit a DHT marker */
/* output index has AC bit set */
/* Emit a DAC marker */
/* Since the useful info is so small, we want to emit all the tables in */
/* one DAC marker.  Therefore this routine does its own scan of the table. */
/* DC needs no table for refinement scan */
/* AC needs no table when not present */
/* C_ARITH_CODING_SUPPORTED */
/* Emit a DRI marker */
/* fixed length */
/* Emit a SOF marker */
/* length */
/* Make sure image isn't bigger than SOF field can handle */
/* Emit a SOS marker */
/* length */
/* We emit 0 for unused field(s); this is recommended by the P&M text
/* DC needs no table for refinement scan */
/* AC needs no table when not present */
/* Emit a pseudo SOS marker */
/* length */
/* Ns */
/* Ss */
/* Se */
/* Ah/Al */
/* Emit a JFIF-compliant APP0 marker */
/*
/* length */
/* Identifier: ASCII "JFIF" */
/* Version fields */
/* Pixel size information */
/* No thumbnail image */
/* Emit an Adobe APP14 marker */
/*
/* length */
/* Identifier: ASCII "Adobe" */
/* Version */
/* Flags0 */
/* Flags1 */
/* Color transform = 1 */
/* Color transform = 2 */
/* Color transform = 0 */
/*
/* Emit an arbitrary marker header */
/* safety check */
/* total length */
/* Emit one byte of marker parameters following write_marker_header */
/*
/* first the SOI */
/* SOI is defined to reset restart interval to 0 */
/* next an optional JFIF APP0 */
/* next an optional Adobe APP14 */
/*
/* Emit DQT for each quantization table.
/* now prec is nonzero iff there are any 16-bit quant tables. */
/* Check for a non-baseline specification.
/* If it's baseline except for quantizer size, warn the user */
/* Emit the proper SOF marker */
/* SOF code for progressive arithmetic */
/* SOF code for sequential arithmetic */
/* SOF code for progressive Huffman */
/* SOF code for baseline implementation */
/* SOF code for non-baseline Huffman file */
/* Check to emit pseudo SOS marker */
/*
/* Emit arith conditioning info.  We may have some duplication
/* Emit Huffman tables.
/* DC needs no table for refinement scan */
/* AC needs no table when not present */
/* Emit DRI if required --- note that DRI value could change for each scan.
/*
/*
/*
/* Create the subobject */
/* Initialize method pointers */
/* Initialize private state */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jcmaster.c
/*
/* Private state */
/* input data, also do first output step */
/* Huffman code optimization pass */
/* data output pass */
/* public fields */
/* the type of the current pass */
/* # of passes completed */
/* total # of passes needed */
/* current index in scan_info[] */
/*
/*
/* Do computations that are needed before master selection phase */
/* Sanity check on input image dimensions to prevent overflow in
/* Compute actual JPEG image dimensions and DCT scaling choices. */
/* Provide block_size/1 scaling */
/* Provide block_size/2 scaling */
/* Provide block_size/3 scaling */
/* Provide block_size/4 scaling */
/* Provide block_size/5 scaling */
/* Provide block_size/6 scaling */
/* Provide block_size/7 scaling */
/* Provide block_size/8 scaling */
/* Provide block_size/9 scaling */
/* Provide block_size/10 scaling */
/* Provide block_size/11 scaling */
/* Provide block_size/12 scaling */
/* Provide block_size/13 scaling */
/* Provide block_size/14 scaling */
/* Provide block_size/15 scaling */
/* Provide block_size/16 scaling */
/* !DCT_SCALING_SUPPORTED */
/* Hardwire it to "no scaling" */
/* DCT_SCALING_SUPPORTED */
/* Do computations that are needed before master selection phase */
/* Sanity check on block_size */
/* Derive natural_order from block_size */
/* Derive lim_Se from block_size */
/* Sanity check on image dimensions */
/* Make sure image isn't bigger than I can handle */
/* Width of an input scanline must be representable as JDIMENSION. */
/* For now, precision must match compiled-in value... */
/* Check that number of components won't exceed internal array sizes */
/* Compute maximum sampling factors; check factor validity */
/* Compute dimensions of components */
/* Fill in the correct component_index value; don't rely on application */
/* In selecting the actual DCT scaling for each component, we try to
/* We don't support DCT ratios larger than 2. */
/* Size in DCT blocks */
/* Size in samples */
/* Mark component needed (this flag isn't actually used for compression) */
/* Compute number of fully interleaved MCU rows (number of times that
/* Verify that the scan script in cinfo->scan_info[] is valid; also
/* -1 until that coefficient has been seen; then last Al for it */
/* For sequential JPEG, all scans must have Ss=0, Se=DCTSIZE2-1;
/* Validate component indexes */
/* Components must appear in SOF order within each scan */
/* Validate progression parameters */
/* The JPEG spec simply gives the ranges 0..13 for Ah and Al, but that
/* DC and AC together not OK */
/* AC scans must be for only one component */
/* AC without prior DC scan */
/* first scan of this coefficient */
/* not first scan */
/* For sequential JPEG, all progression parameters must be these: */
/* Make sure components are not sent twice */
/* Now verify that everything got sent. */
/* For progressive mode, we only check that at least some DC data
/* Adapt scan script for use with reduced block size;
/* Circumvent const declaration for this function */
/* After skipping, idxout becomes smaller than idxin */
/* Copy rest of data;
/* Entire scan out of range - skip this entry */
/* Limit scan to end of block */
/* C_MULTISCAN_FILES_SUPPORTED */
/* Set up the scan parameters for the current scan */
/* Prepare for current scan --- the script is already validated */
/* Prepare for single sequential-JPEG scan containing all components */
/* Do computations that are needed before processing a JPEG scan */
/* cinfo->comps_in_scan and cinfo->cur_comp_info[] are already set */
/* Noninterleaved (single-component) scan */
/* Overall image size in MCUs */
/* For noninterleaved scan, always one block per MCU */
/* For noninterleaved scans, it is convenient to define last_row_height
/* Prepare array describing MCU composition */
/* Interleaved (multi-component) scan */
/* Overall image size in MCUs */
/* Sampling factors give # of blocks of component in each MCU */
/* Figure number of non-dummy blocks in last MCU column & row */
/* Prepare array describing MCU composition */
/* Convert restart specified in rows to actual MCU count. */
/* Note that count must fit in 16 bits, so we provide limiting. */
/*
/* Initial pass: will collect input data, and do either Huffman
/* No immediate data output; postpone writing frame/scan headers */
/* Will write frame/scan headers at first jpeg_write_scanlines call */
/* Do Huffman optimization for a scan after the first one. */
/* Special case: Huffman DC refinement scans need no Huffman table
/*FALLTHROUGH*/
/* Do a data-output pass. */
/* We need not repeat per-scan setup if prior optimization pass did it. */
/* We emit frame/scan headers now */
/* Set up progress monitor's pass info if present */
/*
/* reset flag so call only once */
/*
/* The entropy coder always needs an end-of-pass call,
/* Update state for next pass */
/* next pass is either output of scan 0 (after optimization)
/* next pass is always output of current scan */
/* next pass is either optimization or output of next scan */
/*
/* Validate parameters, determine derived values */
/*  TEMPORARY HACK ??? */
/* assume default tables no good for progressive or downscale mode */
/* Initialize my private state */
/* no main pass in transcoding */
/* for normal compression, first pass is always this type: */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jcomapi.c
/*
/*
/* Do nothing if called on a not-initialized or destroyed JPEG object. */
/* Releasing pools in reverse order might help avoid fragmentation
/* Reset overall state for possible reuse of object */
/* Try to keep application from accessing now-deleted marker list.
/*
/* We need only tell the memory manager to release everything. */
/* NB: mem pointer is NULL if memory mgr failed to initialize. */
/* be safe if jpeg_destroy is called twice */
/* mark it destroyed */
/*
/* make sure this is false in any new table */
/* make sure this is false in any new table */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jcparam.c
/*
/*
/* Define a quantization table equal to the basic_table times
/* Safety check to ensure start_compress not called yet. */
/* limit the values to the valid range */
/* max quantizer needed for 12 bits */
/* limit to baseline range if requested */
/* Initialize sent_table FALSE so table will be written to JPEG file. */
/* These are the sample quantization tables given in JPEG spec section K.1.
/* Set or change the 'quality' (quantization) setting, using default tables
/* Set up two quantization tables using the specified scaling */
/* Set or change the 'quality' (quantization) setting, using default tables
/* Set up two quantization tables using the specified scaling */
/* Convert a user-specified quality rating to a percentage scaling factor
/* Safety limit on quality factor.  Convert 0 to 1 to avoid zero divide. */
/* The basic table is used as-is (scaling 100) for a quality of 50.
/* Set or change the 'quality' (quantization) setting, using default tables.
/* Convert user 0-100 rating to percentage scaling */
/* Set up standard quality tables */
/*
/* Define a Huffman table */
/* Copy the number-of-symbols-of-each-code-length counts */
/* Validate the counts.  We do this here mainly so we can copy the right
/* Initialize sent_table FALSE so table will be written to JPEG file. */
/* Set up the standard Huffman tables (cf. JPEG standard section K.3) */
/* IMPORTANT: these are only valid for 8-bit data precision! */
/* 0-base */ 0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
/* 0-base */ 0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 };
/* 0-base */ 0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d };
/* 0-base */ 0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77 };
/*
/* Safety check to ensure start_compress not called yet. */
/* Allocate comp_info array large enough for maximum component count.
/* Initialize everything not dependent on the color space */
/* 1:1 scaling */
/* Set up two quantization tables using default quality of 75 */
/* Set up two Huffman tables */
/* Initialize default arithmetic coding conditioning */
/* Default is no multiple-scan output */
/* Expect normal source image, not raw downsampled data */
/* Use Huffman coding, not arithmetic coding, by default */
/* By default, don't do extra passes to optimize entropy coding */
/* The standard Huffman tables are only valid for 8-bit data precision.
/* By default, use the simpler non-cosited sampling alignment */
/* By default, apply fancy downsampling */
/* No input smoothing */
/* DCT algorithm preference */
/* No restart markers */
/* Fill in default JFIF marker parameters.  Note that whether the marker
/* Default JFIF version = 1.01 */
/* Pixel size is unknown by default */
/* Pixel aspect ratio is square by default */
/* Choose JPEG colorspace based on input space, set defaults accordingly */
/*
/* By default, no translation */
/*
/* Safety check to ensure start_compress not called yet. */
/* For all colorspaces, we use Q and Huff tables 0 for luminance components,
/* No marker for non-JFIF colorspaces */
/* write no Adobe marker by default */
/* Write a JFIF marker */
/* JFIF specifies component ID 1 */
/* write Adobe marker to flag RGB */
/* 'R' */, 1,1, 0, 0,0);
/* 'G' */, 1,1, 0, 0,0);
/* 'B' */, 1,1, 0, 0,0);
/* Write a JFIF marker */
/* JFIF specifies component IDs 1,2,3 */
/* We default to 2x2 subsamples of chrominance */
/* write Adobe marker to flag CMYK */
/* 'C' */, 1,1, 0, 0,0);
/* 'M' */, 1,1, 0, 0,0);
/* 'Y' */, 1,1, 0, 0,0);
/* 'K' */, 1,1, 0, 0,0);
/* write Adobe marker to flag YCCK */
/* Support routine: generate one scan for specified component */
/* Support routine: generate one scan for each component */
/* Support routine: generate interleaved DC scan if possible, else N scans */
/* Single interleaved DC scan */
/* Noninterleaved DC scan for each component */
/*
/* Safety check to ensure start_compress not called yet. */
/* Figure space needed for script.  Calculation must match code below! */
/* Custom script for YCbCr color images. */
/* All-purpose script for other color spaces. */
/* 2 DC + 4 AC scans per component */
/* 2 DC scans; 4 AC scans per component */
/* Allocate space for script.
/* Custom script for YCbCr color images. */
/* Initial DC scan */
/* Initial AC scan: get some luma data out in a hurry */
/* Chroma data is too small to be worth expending many scans on */
/* Complete spectral selection for luma AC */
/* Refine next bit of luma AC */
/* Finish DC successive approximation */
/* Finish AC successive approximation */
/* Luma bottom bit comes last since it's usually largest scan */
/* All-purpose script for other color spaces. */
/* Successive approximation first pass */
/* Successive approximation second pass */
/* Successive approximation final pass */
/* C_PROGRESSIVE_SUPPORTED */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jcprepct.c
/*
/* At present, jcsample.c can request context rows only for smoothing.
/*
/* Private buffer controller object */
/* public fields */
/* Downsampling input buffer.  This buffer holds color-converted data
/* counts rows remaining in source image */
/* index of next row to store in color_buf */
/* only needed for context case */
/* starting row index of group to process */
/* downsample when we reach this index */
/*
/* Initialize total-height counter for detecting bottom of image */
/* Mark the conversion buffer empty */
/* Preset additional state variables for context mode.
/* Set next_buf_stop to stop after two row groups have been read in. */
/*
/*
/* Do color conversion to fill the conversion buffer. */
/* If at bottom of image, pad to fill the conversion buffer. */
/* If we've filled the conversion buffer, empty it. */
/* If at bottom of image, pad the output to a full iMCU height.
/* can exit outer loop without test */
/*
/* Do color conversion to fill the conversion buffer. */
/* Pad at top of image, if first time through */
/* Return for more data, unless we are at the bottom of the image. */
/* When at bottom of image, pad to fill the conversion buffer. */
/* If we've gotten enough data, downsample a row group. */
/* Advance pointers with wraparound as necessary. */
/*
/* Grab enough space for fake row pointers for all the components;
/* Allocate the actual buffer space (3 row groups) for this component.
/* Copy true buffer row pointers into the middle of the fake row array */
/* Fill in the above and below wraparound pointers */
/* point to space for next component */
/* CONTEXT_ROWS_SUPPORTED */
/*
/* safety check */
/* Allocate the color conversion buffer.
/* Set up to provide context rows */
/* No context, just make it tall enough for one row group */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jcsample.c
/*
/* Pointer to routine to downsample a single component */
/* Private subobject */
/* public fields */
/* Downsampling method pointers, one per component */
/* Height of an output row group for each component. */
/* These arrays save pixel expansion factors so that int_downsample need not
/*
/* no work for now */
/*
/* don't need GETJSAMPLE() here */
/*
/*
/* outcol_h == outcol*h_expand */
/* Expand input data enough to let all the output samples be generated
/*
/* Copy the data */
/* Edge-expand */
/*
/* Expand input data enough to let all the output samples be generated
/* bias = 0,1,0,1,... for successive samples */
/* 0=>1, 1=>0 */
/*
/* Expand input data enough to let all the output samples be generated
/* bias = 1,2,1,2,... for successive samples */
/* 1=>2, 2=>1 */
/*
/* Expand input data enough to let all the output samples be generated
/* We don't bother to form the individual "smoothed" input pixel values;
/* scaled (1-5*SF)/4 */
/* scaled SF/4 */
/* Special case for first column: pretend column -1 is same as column 0 */
/* sum of pixels directly mapped to this output element */
/* sum of edge-neighbor pixels */
/* The edge-neighbors count twice as much as corner-neighbors */
/* Add in the corner-neighbors */
/* form final output scaled up by 2^16 */
/* round, descale and output it */
/* Special case for last column */
/*
/* Expand input data enough to let all the output samples be generated
/* Each of the eight neighbor pixels contributes a fraction SF to the
/* scaled 1-8*SF */
/* scaled SF */
/* Special case for first column */
/* Special case for last column */
/* INPUT_SMOOTHING_SUPPORTED */
/*
/* Verify we can handle the sampling factors, and set up method pointers */
/* Compute size of an "output group" for DCT scaling.  This many samples
/* save for use later */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jctrans.c
/*
/* Forward declarations */
/*
/* Mark all tables to be written */
/* (Re)initialize error mgr and destination modules */
/* Perform master selection of active modules */
/* Wait for jpeg_finish_compress() call */
/* so jpeg_write_marker works */
/*
/* Safety check to ensure start_compress not called yet. */
/* Copy fundamental image dimensions */
/* Initialize all parameters to default values */
/* jpeg_set_defaults may choose wrong colorspace, eg YCbCr if input is RGB.
/* Copy the source's quantization tables. */
/* Copy the source's per-component info.
/* Make sure saved quantization table for component matches the qtable
/* Note: we do not copy the source's Huffman table assignments;
/* Also copy JFIF version and resolution information, if available.
/*
/* Initialize master control (includes parameter checking/processing) */
/* transcode only */);
/* Entropy encoding: either Huffman or arithmetic coding. */
/* We need a special coefficient buffer controller. */
/* We can now tell the memory manager to allocate virtual arrays. */
/* Write the datastream header (SOI, JFIF) immediately.
/*
/* Private buffer controller object */
/* public fields */
/* iMCU row # within image */
/* counts MCUs processed in current row */
/* counts MCU rows within iMCU row */
/* number of such rows needed */
/* Virtual block array for each component. */
/* Workspace for constructing dummy blocks at right/bottom edges. */
/* Reset within-iMCU-row counters for a new row */
/* In an interleaved scan, an MCU row is the same as an iMCU row.
/*
/*
/* index of current MCU within row */
/* Align the virtual buffers for the components used in this scan. */
/* Loop to process one whole iMCU row */
/* Construct list of pointers to DCT blocks belonging to this MCU */
/* index of current DCT block within MCU */
/* Fill in pointers to real blocks in this row */
/* At bottom of image, need a whole row of dummy blocks */
/* Fill in any dummy blocks needed in this row.
/* Try to write the MCU. */
/* Suspension forced; update state counters and exit */
/* Completed an MCU row, but perhaps not an iMCU row */
/* Completed the iMCU row, advance counters for next one */
/*
/* Save pointer to virtual arrays */
/* Allocate and pre-zero space for dummy DCT blocks. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jdapimin.c
/*
/*
/* Guard against version mismatches between library and caller. */
/* so jpeg_destroy knows mem mgr not called */
/* For debugging purposes, we zero the whole master structure.
/* ignore Purify complaint here */
/* Initialize a memory manager instance for this object */
/* Zero out pointers to permanent structures. */
/* Initialize marker processor so application can override methods
/* And initialize the overall input controller. */
/* OK, I'm ready */
/*
/* use common routine */
/*
/* use common routine */
/*
/* Guess the input colorspace, and set output colorspace accordingly. */
/* (Wish JPEG committee had provided a real way to specify this...) */
/* Note application may override our guesses. */
/* JFIF implies YCbCr */
/* assume it's YCbCr */
/* Saw no special markers, try to guess from the component IDs */
/* assume JFIF w/out marker */
/* ASCII 'R', 'G', 'B' */
/* assume it's YCbCr */
/* Always guess RGB is proper output colorspace. */
/* assume it's YCCK */
/* No special markers, assume straight CMYK. */
/* Set defaults for other decompression parameters. */
/* 1:1 scaling */
/* We set these in case application only sets quantize_colors. */
/* Initialize for no mode change in buffered-image mode. */
/*
/* Complain if application wanted an image */
/* Reset to start state; it would be safer to require the application to
/* sets state = DSTATE_START */
/* no work */
/*
/* NB: every possible DSTATE value should be listed in this switch */
/* Start-of-datastream actions: reset appropriate modules */
/* Initialize application's data source module */
/*FALLTHROUGH*/
/* Found SOS, prepare to decompress */
/* Set up default parameters based on header data */
/* Set global state: ready for start_decompress */
/* Can't advance past first SOS until start_decompress is called */
/*
/* Check for valid jpeg object */
/*
/* Only valid after jpeg_read_header completes */
/*
/* Terminate final pass of non-buffered mode */
/* Finishing after a buffered-image operation */
/* STOPPING = repeat call after a suspension, anything else is error */
/* Read until EOI */
/* Suspend, come back later */
/* Do final cleanup */
/* We can use jpeg_abort to release memory and reset global_state */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jdapistd.c
/*
/* Forward declarations */
/*
/* First call: initialize master control, select active modules */
/* No more work here; expecting jpeg_start_output next */
/* If file has multiple scans, absorb them all into the coef buffer */
/* Call progress monitor hook if present */
/* Absorb some more input */
/* Advance progress counter if appropriate */
/* jdmaster underestimated number of scans; ratchet up one scan */
/* D_MULTISCAN_FILES_SUPPORTED */
/* Perform any dummy output passes, and set up for the final pass */
/*
/* First call: do pass setup */
/* Loop over any required dummy passes */
/* Crank through the dummy pass */
/* Call progress monitor hook if present */
/* Process some data */
/* No progress made, must suspend */
/* Finish up dummy pass, and set up for another one */
/* QUANT_2PASS_SUPPORTED */
/* Ready for application to drive output pass through
/*
/* Call progress monitor hook if present */
/* Process some data */
/*
/* Call progress monitor hook if present */
/* Verify that at least one iMCU row can be returned. */
/* Decompress directly into user's buffer. */
/* suspension forced, can do nothing more */
/* OK, we processed one iMCU row. */
/* Additional entry points for buffered-image mode. */
/*
/* Limit scan number to valid range */
/* Perform any dummy output passes, and set up for the real pass */
/*
/* Terminate this pass. */
/* We do not require the whole pass to have been completed. */
/* BUFPOST = repeat call after a suspension, anything else is error */
/* Read markers looking for SOS or EOI */
/* Suspend, come back later */
/* D_MULTISCAN_FILES_SUPPORTED */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jdarith.c
/*
/* Expanded entropy decoder object for arithmetic decoding. */
/* public fields */
/* C register, base of coding interval + input bit buffer */
/* A register, normalized size of coding interval */
/* bit shift counter, # of bits left in bit buffer part of C */
/* init: ct = -16 */
/* run: ct = 0..7 */
/* error: ct = -1 */
/* last DC coef for each component */
/* context index for DC conditioning */
/* MCUs left in this restart interval */
/* Pointers to statistics areas (these workspaces have image lifespan) */
/* Statistics bin for coding with fixed probability 0.5 */
/* The following two definitions specify the allocation chunk size
/* Read next input byte; we do not support suspension in this module. */
/*
/* Renormalization & data input per section D.2.6 */
/* Need to fetch next data byte */
/* stuff zero data */
/* read next input byte */
/* zero stuff or marker code */
/* swallow extra 0xFF bytes */
/* discard stuffed zero byte */
/* Note: Different from the Huffman decoder, hitting
/* insert data into C register */
/* update bit shift counter */
/* Need more initial bytes */
/* Got 2 initial bytes -> re-init A and exit loop */
/* => e->a = 0x10000L after loop exit */
/* Fetch values from our compact representation of Table D.3(D.2):
/* => Qe_Value */
/* Next_Index_LPS + Switch_MPS */
/* Next_Index_MPS */
/* Decode & estimation procedures per sections D.2.4 & D.2.5 */
/* Conditional LPS (less probable symbol) exchange */
/* Estimate_after_MPS */
/* Estimate_after_LPS */
/* Exchange LPS/MPS */
/* Conditional MPS (more probable symbol) exchange */
/* Estimate_after_LPS */
/* Exchange LPS/MPS */
/* Estimate_after_MPS */
/*
/* Advance past the RSTn marker */
/* Re-initialize statistics areas */
/* Reset DC predictions to 0 */
/* Reset arithmetic decoding variables */
/* force reading 2 initial bytes to fill C */
/* Reset restart counter */
/*
/*
/* Process restart marker if needed */
/* if error do nothing */
/* Outer loop handles each block in the MCU */
/* Sections F.2.4.1 & F.1.4.4.1: Decoding of DC coefficients */
/* Table F.4: Point to statistics bin S0 for DC coefficient coding */
/* Figure F.19: Decode_DC_DIFF */
/* Figure F.21: Decoding nonzero value v */
/* Figure F.22: Decoding the sign of v */
/* Figure F.23: Decoding the magnitude category of v */
/* Table F.4: X1 = 20 */
/* magnitude overflow */
/* Section F.1.4.4.1.2: Establish dc_context conditioning category */
/* zero diff category */
/* large diff category */
/* small diff category */
/* Figure F.24: Decoding the magnitude bit pattern of v */
/* Scale and output the DC coefficient (assumes jpeg_natural_order[0]=0) */
/*
/* Process restart marker if needed */
/* if error do nothing */
/* There is always only one block per MCU */
/* Sections F.2.4.2 & F.1.4.4.2: Decoding of AC coefficients */
/* Figure F.20: Decode_AC_coefficients */
/* EOB flag */
/* spectral overflow */
/* Figure F.21: Decoding nonzero value v */
/* Figure F.22: Decoding the sign of v */
/* Figure F.23: Decoding the magnitude category of v */
/* magnitude overflow */
/* Figure F.24: Decoding the magnitude bit pattern of v */
/* Scale and output coefficient in natural (dezigzagged) order */
/*
/* Process restart marker if needed */
/* use fixed probability estimation */
/* 1 in the bit position being coded */
/* Outer loop handles each block in the MCU */
/* Encoded data is simply the next bit of the two's-complement DC value */
/*
/* Process restart marker if needed */
/* if error do nothing */
/* There is always only one block per MCU */
/* 1 in the bit position being coded */
/* -1 in the bit position being coded */
/* Establish EOBx (previous stage end-of-block) index */
/* EOB flag */
/* previously nonzero coef */
/* newly nonzero coef */
/* spectral overflow */
/*
/* Process restart marker if needed */
/* if error do nothing */
/* Outer loop handles each block in the MCU */
/* Sections F.2.4.1 & F.1.4.4.1: Decoding of DC coefficients */
/* Table F.4: Point to statistics bin S0 for DC coefficient coding */
/* Figure F.19: Decode_DC_DIFF */
/* Figure F.21: Decoding nonzero value v */
/* Figure F.22: Decoding the sign of v */
/* Figure F.23: Decoding the magnitude category of v */
/* Table F.4: X1 = 20 */
/* magnitude overflow */
/* Section F.1.4.4.1.2: Establish dc_context conditioning category */
/* zero diff category */
/* large diff category */
/* small diff category */
/* Figure F.24: Decoding the magnitude bit pattern of v */
/* Sections F.2.4.2 & F.1.4.4.2: Decoding of AC coefficients */
/* Figure F.20: Decode_AC_coefficients */
/* EOB flag */
/* spectral overflow */
/* Figure F.21: Decoding nonzero value v */
/* Figure F.22: Decoding the sign of v */
/* Figure F.23: Decoding the magnitude category of v */
/* magnitude overflow */
/* Figure F.24: Decoding the magnitude bit pattern of v */
/*
/* Validate progressive scan parameters */
/* need not check Ss/Se < 0 since they came from unsigned bytes */
/* AC scans may have only one component */
/* Successive approximation refinement scan: must have Al = Ah-1. */
/* need not check for < 0 */
/* Update progression status, and verify that scan order is legal.
/* AC without prior DC scan */
/* Select MCU decoding routine */
/* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.
/* Select MCU decoding routine */
/* Allocate & initialize requested statistics areas */
/* Initialize DC predictions to 0 */
/* Initialize arithmetic decoding variables */
/* force reading 2 initial bytes to fill C */
/* Initialize restart counter */
/*
/* Mark tables unallocated */
/* Initialize index for fixed probability estimation */
/* Create progression status table */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jdatadst.c
/*
/* this is not a core library module, so it doesn't define JPEG_INTERNALS */
/* <stdlib.h> should declare malloc(),free() */
/* Expanded data destination object for stdio output */
/* public fields */
/* target stream */
/* start of buffer */
/* choose an efficiently fwrite'able size */
/* Expanded data destination object for memory output */
/* public fields */
/* target buffer */
/* newly allocated buffer */
/* start of buffer */
/*
/* Allocate the output buffer --- it will be released when done with image */
/* no work necessary here */
/*
/* Try to allocate new buffer with double size */
/*
/* Write any data remaining in the buffer */
/* Make sure we wrote the output file OK */
/*
/* The destination object is made permanent so that multiple JPEG images
/* first time for this JPEG object? */
/*
/* sanity check */
/* The destination object is made permanent so that multiple JPEG images
/* first time for this JPEG object? */
/* Allocate initial buffer */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jdatasrc.c
/*
/* this is not a core library module, so it doesn't define JPEG_INTERNALS */
/* Expanded data source object for stdio input */
/* public fields */
/* source stream */
/* start of buffer */
/* have we gotten any data yet? */
/* choose an efficiently fread'able size */
/*
/* We reset the empty-input-file flag for each image,
/* no work necessary here */
/*
/* Treat empty input file as fatal error */
/* Insert a fake EOI marker */
/* The whole JPEG data is expected to reside in the supplied memory
/* Insert a fake EOI marker */
/*
/* Just a dumb implementation for now.  Could use fseek() except
/* note we assume that fill_input_buffer will never return FALSE,
/*
/*
/* no work necessary here */
/*
/* The source object and input buffer are made permanent so that a series
/* first time for this JPEG object? */
/* use default method */
/* forces fill_input_buffer on first read */
/* until buffer loaded */
/*
/* Treat empty input as fatal error */
/* The source object is made permanent so that a series of JPEG images
/* first time for this JPEG object? */
/* use default method */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jdcoefct.c
/*
/* Block smoothing is only applicable for progressive JPEG, so: */
/* Private buffer controller object */
/* public fields */
/* These variables keep track of the current location of the input side. */
/* cinfo->input_iMCU_row is also used for this. */
/* counts MCUs processed in current row */
/* counts MCU rows within iMCU row */
/* number of such rows needed */
/* The output side's location is represented by cinfo->output_iMCU_row. */
/* In single-pass modes, it's sufficient to buffer just one MCU.
/* In multi-pass modes, we need a virtual block array for each component. */
/* When doing block smoothing, we latch coefficient Al values here */
/* we save coef_bits[0..5] */
/* Forward declarations */
/* Reset within-iMCU-row counters for a new row (input side) */
/* In an interleaved scan, an MCU row is the same as an iMCU row.
/*
/*
/* If multipass, check to see whether to use block smoothing on this pass */
/*
/* index of current MCU within row */
/* Loop to process as much as one whole iMCU row */
/* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */
/* can bypass in DC only case */
/* Suspension forced; update state counters and exit */
/* Determine where data should go in output_buf and do the IDCT thing.
/* index of current DCT block within MCU */
/* Don't bother to IDCT an uninteresting component. */
/* Completed an MCU row, but perhaps not an iMCU row */
/* Completed the iMCU row, advance counters for next one */
/* Completed the scan */
/*
/* Always indicate nothing was done */
/*
/* index of current MCU within row */
/* Align the virtual buffers for the components used in this scan. */
/* Note: entropy decoder expects buffer to be zeroed,
/* Loop to process one whole iMCU row */
/* Construct list of pointers to DCT blocks belonging to this MCU */
/* index of current DCT block within MCU */
/* Try to fetch the MCU. */
/* Suspension forced; update state counters and exit */
/* Completed an MCU row, but perhaps not an iMCU row */
/* Completed the iMCU row, advance counters for next one */
/* Completed the scan */
/*
/* Force some input to be done if we are getting ahead of the input. */
/* OK, output from the virtual arrays. */
/* Don't bother to IDCT an uninteresting component. */
/* Align the virtual buffer for this component. */
/* Count non-dummy DCT block rows in this iMCU row. */
/* NB: can't use last_row_height here; it is input-side-dependent! */
/* Loop over all DCT blocks to be processed. */
/* D_MULTISCAN_FILES_SUPPORTED */
/*
/* Natural-order array positions of the first 5 zigzag-order coefficients */
/*
/* Allocate latch area if not already done */
/* All components' quantization values must already be latched. */
/* Verify DC & first 5 AC quantizers are nonzero to avoid zero-divide. */
/* DC values must be at least partly known for all components. */
/* Block smoothing is helpful if some AC coefficients remain inaccurate. */
/*
/* Force some input to be done if we are getting ahead of the input. */
/* If input is working on current scan, we ordinarily want it to
/* OK, output from the virtual arrays. */
/* Don't bother to IDCT an uninteresting component. */
/* Count non-dummy DCT block rows in this iMCU row. */
/* this and next iMCU row */
/* NB: can't use last_row_height here; it is input-side-dependent! */
/* this iMCU row only */
/* Align the virtual buffer for this component. */
/* prior iMCU row too */
/* point to current iMCU row */
/* Fetch component-dependent info */
/* Loop over all DCT blocks to be processed. */
/* We fetch the surrounding DC values using a sliding-register approach.
/* Fetch current DCT block into workspace so we can modify it. */
/* Update DC values */
/* Compute coefficient estimates per K.8.
/* AC01 */
/* AC10 */
/* AC20 */
/* AC11 */
/* AC02 */
/* OK, do the IDCT */
/* Advance for next column */
/* BLOCK_SMOOTHING_SUPPORTED */
/*
/* Create the coefficient buffer. */
/* Allocate a full-image virtual array for each component, */
/* padded to a multiple of samp_factor DCT blocks in each direction. */
/* Note we ask for a pre-zeroed array. */
/* If block smoothing could be used, need a bigger window */
/* link to virtual arrays */
/* We only need a single-MCU buffer. */
/* DC only case: want to bypass later */
/* flag for no virtual arrays */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jdcolor.c
/*
/* Private subobject */
/* public fields */
/* Private state for YCC->RGB conversion */
/* => table for Cr to R conversion */
/* => table for Cb to B conversion */
/* => table for Cr to G conversion */
/* => table for Cb to G conversion */
/* Private state for RGB->Y conversion */
/* => table for RGB to Y conversion */
/**************** YCbCr -> RGB conversion: most common case **************/
/****************   RGB -> Y   conversion: less common case **************/
/*
/* speediest right-shift on some machines */
/* We allocate one big table for RGB->Y conversion and divide it up into
/* offset to R => Y section */
/* offset to G => Y section */
/* etc. */
/*
/* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
/* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
/* Cr=>R value is nearest int to 1.40200 * x */
/* Cb=>B value is nearest int to 1.77200 * x */
/* Cr=>G value is scaled-up -0.71414 * x */
/* Cb=>G value is scaled-up -0.34414 * x */
/* We also add in ONE_HALF so that need not do it in inner loop */
/*
/* copy these pointers into registers if possible */
/* Range-limiting is essential due to noise introduced by DCT losses. */
/**************** Cases other than YCbCr -> RGB **************/
/*
/* Allocate and fill in the conversion tables. */
/*
/* Y */
/*
/* We can dispense with GETJSAMPLE() here */
/*
/* needn't bother with GETJSAMPLE() here */
/*
/*
/* We can dispense with GETJSAMPLE() here */
/*
/* copy these pointers into registers if possible */
/* Range-limiting is essential due to noise introduced by DCT losses. */
/* red */
/* green */
/* blue */
/* K passes through unchanged */
/* don't need GETJSAMPLE here */
/*
/* no work needed */
/*
/* Make sure num_components agrees with jpeg_color_space */
/* JCS_UNKNOWN can be anything */
/* Set out_color_components and conversion method based on requested space.
/* For color->grayscale conversion, only the Y (0) component is needed */
/* Permit null conversion to same output space */
/* unsupported non-null conversion */
/* single colormapped output component */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jddctmgr.c
/*
/* Private declarations for DCT subsystem */
/*
/* Private subobject for this module */
/* public fields */
/* This array contains the IDCT method code that each multiplier table
/* Allocated multiplier tables: big enough for any supported variant */
/* The current scaled-IDCT routines require ISLOW-style multiplier tables,
/*
/* Select the proper IDCT routine for this component's scaling */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* jidctint uses islow-style table */
/* Create multiplier table from quant table.
/* happens if no data yet for component */
/* For LL&M IDCT method, multipliers are equal to raw quantization
/* For AA&N IDCT method, multipliers are equal to quantization
/* precomputed values scaled up by 14 bits */
/* For float AA&N IDCT method, multipliers are equal to quantization
/*
/* Allocate and pre-zero a multiplier table for each component */
/* Mark multiplier table not yet set up for any method */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jdhuff.c
/*
/* Derived data constructed for each Huffman table */
/* # of bits of lookahead */
/* Basic tables: (element [0] of each array is unused) */
/* largest code of length k (-1 if none) */
/* (maxcode[17] is a sentinel to ensure jpeg_huff_decode terminates) */
/* huffval[] offset for codes of length k */
/* valoffset[k] = huffval[] index of 1st symbol of code length k, less
/* Link to public Huffman table (needed only in jpeg_huff_decode) */
/* Lookahead tables: indexed by the next HUFF_LOOKAHEAD bits of
/* # bits, or 0 if too long */
/* symbol, or unused */
/*
/* type of bit-extraction buffer */
/* size of buffer in bits */
/* If long is > 32 bits on your machine, and shifting/masking longs is
/* Bitreading state saved across MCUs */
/* current bit-extraction buffer */
/* # of unused bits in it */
/* Bitreading working state within an MCU */
/* Current data source location */
/* We need a copy, rather than munging the original, in case of suspension */
/* => next byte to read from source */
/* # of bytes remaining in source buffer */
/* Bit input buffer --- note these values are kept in register variables,
/* current bit-extraction buffer */
/* # of unused bits in it */
/* Pointer needed by jpeg_fill_bit_buffer. */
/* back link to decompress master record */
/* Macros to declare and load/save bitread local variables. */
/*
/*
/*
/* remaining EOBs in EOBRUN */
/* last DC coef for each component */
/* This macro is to work around compilers with missing or broken
/* public fields */
/* These fields are loaded into local variables at start of each MCU.
/* Bit buffer at start of MCU */
/* Other state at start of MCU */
/* These fields are NOT loaded into local working state. */
/* set TRUE after emitting warning */
/* MCUs left in this restart interval */
/* Following two fields used only in progressive mode */
/* Pointers to derived tables (these workspaces have image lifespan) */
/* active table during an AC scan */
/* Following fields used only in sequential mode */
/* Pointers to derived tables (these workspaces have image lifespan) */
/* Precalculated info set up by start_pass for use in decode_mcu: */
/* Pointers to derived tables to be used for each block within an MCU */
/* Whether we care about the DC and AC coefficient values for each block */
/*
/* Note that huffsize[] and huffcode[] are filled in code-length order,
/* Find the input Huffman table */
/* Allocate a workspace if we haven't already done so. */
/* fill in back link */
/* Figure C.1: make table of Huffman code length for each symbol */
/* protect against table overrun */
/* Figure C.2: generate the codes themselves */
/* We also validate that the counts represent a legal Huffman code tree. */
/* code is now 1 more than the last code used for codelength si; but
/* Figure F.15: generate decoding tables for bit-sequential decoding */
/* valoffset[l] = huffval[] index of 1st symbol of code length l,
/* maximum code of length l */
/* -1 if no codes of this length */
/* ensures jpeg_huff_decode terminates */
/* Compute lookahead tables to speed up decoding.
/* l = current code's length, p = its index in huffcode[] & huffval[]. */
/* Generate left-justified code followed by all possible bit sequences */
/* Validate symbols as being reasonable.
/*
/* minimum allowable value */
/* Load up the bit buffer to a depth of at least nbits */
/* Copy heavily used state fields into locals (hopefully registers) */
/* Attempt to load at least MIN_GET_BITS bits into get_buffer. */
/* (It is assumed that no request will be for more than that many bits.) */
/* We fail to do so only if we hit a marker or are forced to suspend. */
/* cannot advance past a marker */
/* Attempt to read a byte */
/* If it's 0xFF, check and discard stuffed zero byte */
/* Loop here to discard any padding FF's on terminating marker,
/* Found FF/00, which represents an FF data byte */
/* Oops, it's actually a marker indicating end of compressed data.
/* See if we need to insert some fake zero bits. */
/* OK, load c into get_buffer */
/* end while */
/* We get here if we've read the marker that terminates the compressed
/* Uh-oh.  Report corrupted data to user and stuff zeroes into
/* Fill the buffer with zero bits */
/* Unload the local registers */
/*
/* bmask[n] is mask for n rightmost bits */
/* AVOID_TABLES */
/*
/* HUFF_DECODE has determined that the code is at least min_bits */
/* bits long, so fetch that many bits in one swoop. */
/* Collect the rest of the Huffman code one bit at a time. */
/* This is per Figure F.16 in the JPEG spec. */
/* Unload the local registers */
/* With garbage input we may reach the sentinel value l = 17. */
/* fake a zero as the safest result */
/*
/* Throw away any unused bits remaining in bit buffer; */
/* include any full bytes in next_marker's count of discarded bytes */
/* Advance past the RSTn marker */
/* Re-initialize DC predictions to 0 */
/* Re-init EOB run count, too */
/* Reset restart counter */
/* Reset out-of-data flag, unless read_restart_marker left us smack up
/*
/*
/* Process restart marker if needed; may have to suspend */
/* If we've run out of data, just leave the MCU set to zeroes.
/* Load up working state */
/* Outer loop handles each block in the MCU */
/* Decode a single block's worth of coefficients */
/* Section F.2.2.1: decode the DC coefficient difference */
/* Convert DC difference to actual value, update last_dc_val */
/* Scale and output the coefficient (assumes jpeg_natural_order[0]=0) */
/* Completed MCU, so update state */
/* Account for restart interval (no-op if not using restarts) */
/*
/* Process restart marker if needed; may have to suspend */
/* If we've run out of data, just leave the MCU set to zeroes.
/* Load up working state.
/* only part of saved state we need */
/* There is always only one block per MCU */
/* if it's a band of zeroes... */
/* ...process it now (we do nothing) */
/* Scale and output coefficient in natural (dezigzagged) order */
/* ZRL */
/* skip 15 zeroes in band */
/* EOBr, run length is 2^r + appended bits */
/* EOBr, r > 0 */
/* this band is processed at this moment */
/* force end-of-band */
/* Completed MCU, so update state */
/* only part of saved state we need */
/* Account for restart interval (no-op if not using restarts) */
/*
/* 1 in the bit position being coded */
/* Process restart marker if needed; may have to suspend */
/* Not worth the cycles to check insufficient_data here,
/* Load up working state */
/* Outer loop handles each block in the MCU */
/* Encoded data is simply the next bit of the two's-complement DC value */
/* Note: since we use |=, repeating the assignment later is safe */
/* Completed MCU, so update state */
/* Account for restart interval (no-op if not using restarts) */
/*
/* Process restart marker if needed; may have to suspend */
/* If we've run out of data, don't modify the MCU.
/* 1 in the bit position being coded */
/* -1 in the bit position being coded */
/* Load up working state */
/* only part of saved state we need */
/* There is always only one block per MCU */
/* If we are forced to suspend, we must undo the assignments to any newly
/* initialize coefficient loop counter to start of band */
/* size of new coef should always be 1 */
/* newly nonzero coef is positive */
/* newly nonzero coef is negative */
/* EOBr, run length is 2^r + appended bits */
/* rest of block is handled by EOB logic */
/* note s = 0 for processing ZRL */
/* Advance over already-nonzero coefs and r still-zero coefs,
/* do nothing if already set it */
/* reached target zero coefficient */
/* Output newly nonzero coefficient */
/* Remember its position in case we have to suspend */
/* Scan any remaining coefficient positions after the end-of-band
/* do nothing if already changed it */
/* Count one block completed in EOB run */
/* Completed MCU, so update state */
/* only part of saved state we need */
/* Account for restart interval (no-op if not using restarts) */
/* Re-zero any output coefficients that we made newly nonzero */
/*
/* Process restart marker if needed; may have to suspend */
/* If we've run out of data, just leave the MCU set to zeroes.
/* Load up working state */
/* Outer loop handles each block in the MCU */
/* Decode a single block's worth of coefficients */
/* Section F.2.2.1: decode the DC coefficient difference */
/* Convert DC difference to actual value, update last_dc_val */
/* Output the DC coefficient */
/* Section F.2.2.2: decode the AC coefficients */
/* Since zeroes are skipped, output area must be cleared beforehand */
/* Output coefficient in natural (dezigzagged) order.
/* Section F.2.2.2: decode the AC coefficients */
/* In this path we just discard the values */
/* Completed MCU, so update state */
/* Account for restart interval (no-op if not using restarts) */
/*
/* Process restart marker if needed; may have to suspend */
/* If we've run out of data, just leave the MCU set to zeroes.
/* Load up working state */
/* Outer loop handles each block in the MCU */
/* Decode a single block's worth of coefficients */
/* Section F.2.2.1: decode the DC coefficient difference */
/* Convert DC difference to actual value, update last_dc_val */
/* Output the DC coefficient */
/* Section F.2.2.2: decode the AC coefficients */
/* Since zeroes are skipped, output area must be cleared beforehand */
/* Output coefficient in natural (dezigzagged) order.
/* Section F.2.2.2: decode the AC coefficients */
/* In this path we just discard the values */
/* Completed MCU, so update state */
/* Account for restart interval (no-op if not using restarts) */
/*
/* Validate progressive scan parameters */
/* need not check Ss/Se < 0 since they came from unsigned bytes */
/* AC scans may have only one component */
/* Successive approximation refinement scan: must have Al = Ah-1. */
/* need not check for < 0 */
/* Arguably the maximum Al value should be less than 13 for 8-bit precision,
/* Update progression status, and verify that scan order is legal.
/* AC without prior DC scan */
/* Select MCU decoding routine */
/* Make sure requested tables are present, and compute derived tables.
/* DC refinement needs no table */
/* remember the single active table */
/* Initialize DC predictions to 0 */
/* Initialize private state variables */
/* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.
/* Select MCU decoding routine */
/* We retain the hard-coded case for full-size blocks.
/* Compute derived values for Huffman tables */
/* We may do this more than once for a table, but it's not expensive */
/* AC needs no table when not present */
/* Initialize DC predictions to 0 */
/* Precalculate decoding info for each block in an MCU of this scan */
/* Precalculate which table to use for each block */
/* Decide whether we really care about the coefficient values */
/* Initialize bitread state variables */
/* unnecessary, but keeps Purify quiet */
/* Initialize restart counter */
/*
/* Create progression status table */
/* Mark derived tables unallocated */
/* Mark tables unallocated */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jdinput.c
/*
/* Private state */
/* public fields */
/* Nonzero until first SOS is reached */
/* Forward declarations */
/*
/*
/* Do computations that are needed before master selection phase.
/* Compute actual output image dimensions and DCT scaling choices. */
/* Provide 1/block_size scaling */
/* Provide 2/block_size scaling */
/* Provide 3/block_size scaling */
/* Provide 4/block_size scaling */
/* Provide 5/block_size scaling */
/* Provide 6/block_size scaling */
/* Provide 7/block_size scaling */
/* Provide 8/block_size scaling */
/* Provide 9/block_size scaling */
/* Provide 10/block_size scaling */
/* Provide 11/block_size scaling */
/* Provide 12/block_size scaling */
/* Provide 13/block_size scaling */
/* Provide 14/block_size scaling */
/* Provide 15/block_size scaling */
/* Provide 16/block_size scaling */
/* Recompute dimensions of components */
/* !IDCT_SCALING_SUPPORTED */
/* Hardwire it to "no scaling" */
/* jdinput.c has already initialized DCT_scaled_size,
/* IDCT_SCALING_SUPPORTED */
/* Called once, when first SOS marker is reached */
/* Make sure image isn't bigger than I can handle */
/* For now, precision must match compiled-in value... */
/* Check that number of components won't exceed internal array sizes */
/* Compute maximum sampling factors; check factor validity */
/* Derive block_size, natural_order, and lim_Se */
/* no pseudo SOS marker */
/* not needed */
/* We initialize DCT_scaled_size and min_DCT_scaled_size to block_size.
/* Compute dimensions of components */
/* Size in DCT blocks */
/* downsampled_width and downsampled_height will also be overridden by
/* Size in samples */
/* Mark component needed, until color conversion says otherwise */
/* Mark no quantization table yet saved for component */
/* Compute number of fully interleaved MCU rows. */
/* Decide whether file contains multiple scans */
/* Do computations that are needed before processing a JPEG scan */
/* cinfo->comps_in_scan and cinfo->cur_comp_info[] were set from SOS marker */
/* Noninterleaved (single-component) scan */
/* Overall image size in MCUs */
/* For noninterleaved scan, always one block per MCU */
/* For noninterleaved scans, it is convenient to define last_row_height
/* Prepare array describing MCU composition */
/* Interleaved (multi-component) scan */
/* Overall image size in MCUs */
/* Sampling factors give # of blocks of component in each MCU */
/* Figure number of non-dummy blocks in last MCU column & row */
/* Prepare array describing MCU composition */
/*
/* No work if we already saved Q-table for this component */
/* Make sure specified quantization table is present */
/* OK, save away the quantization table */
/*
/*
/*
/* After hitting EOI, read no further */
/* Loop to pass pseudo SOS marker */
/* Found SOS */
/* 1st SOS */
/* pseudo SOS marker */
/* Note: start_input_pass must be called by jdmaster.c
/* 2nd or later SOS marker */
/* Oops, I wasn't expecting this! */
/* unexpected pseudo SOS marker */
/* Found EOI */
/* Tables-only datastream, apparently */
/* Prevent infinite loop in coef ctlr's decompress_data routine
/*
/* "unknown" would be better */
/* Reset other modules */
/* Reset progression state -- would be cleaner if entropy decoder did this */
/*
/* Create subobject in permanent pool */
/* Initialize method pointers */
/* Initialize state: can't use reset_input_controller since we don't
/* "unknown" would be better */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jdmainct.c
/*
/*
/* Private buffer controller object */
/* public fields */
/* Pointer to allocated workspace (M or M+2 row groups). */
/* Have we gotten an iMCU row from decoder? */
/* counts row groups output to postprocessor */
/* Remaining fields are only used in the context case. */
/* These are the master pointers to the funny-order pointer lists. */
/* pointers to weird pointer lists */
/* indicates which pointer set is now in use */
/* process_data state machine status */
/* row groups available to postprocessor */
/* counts iMCU rows to detect image top/bot */
/* context_state values: */
/* need to prepare for MCU row */
/* feeding iMCU to postprocessor */
/* feeding postponed row group */
/* Forward declarations */
/* Allocate space for the funny pointer lists.
/* Get top-level space for component array pointers.
/* height of a row group of component */
/* Get space for pointer lists --- M+4 row groups in each list.
/* want one row group at negative offsets */
/* Create the funny pointer lists discussed in the comments above.
/* height of a row group of component */
/* First copy the workspace pointers as-is */
/* In the second list, put the last four row groups in swapped order */
/* The wraparound pointers at top and bottom will be filled later
/* Set up the "wraparound" pointers at top and bottom of the pointer lists.
/* height of a row group of component */
/* Change the pointer lists to duplicate the last sample row at the bottom
/* Count sample rows in one iMCU row and in one row group */
/* Count nondummy sample rows remaining for this component */
/* Count nondummy row groups.  Should get same answer for each component,
/* Duplicate the last real sample row rgroup*2 times; this pads out the
/*
/* Create the xbuffer[] lists */
/* Read first iMCU row into xbuffer[0] */
/* Simple case with no context needed */
/* Mark buffer empty */
/* For last pass of 2-pass quantization, just crank the postprocessor */
/*
/* Read input data if we haven't filled the main buffer yet */
/* suspension forced, can do nothing more */
/* OK, we have an iMCU row to work with */
/* There are always min_DCT_scaled_size row groups in an iMCU row. */
/* Note: at the bottom of the image, we may pass extra garbage row groups
/* Feed the postprocessor */
/* Has postprocessor consumed all the data yet? If so, mark buffer empty */
/*
/* Read input data if we haven't filled the main buffer yet */
/* suspension forced, can do nothing more */
/* OK, we have an iMCU row to work with */
/* count rows received */
/* Postprocessor typically will not swallow all the input data it is handed
/* Call postprocessor using previously set pointers for postponed row */
/* Need to suspend */
/* Postprocessor exactly filled output buf */
/*FALLTHROUGH*/
/* Prepare to process first M-1 row groups of this iMCU row */
/* Check for bottom of image: if so, tweak pointers to "duplicate"
/*FALLTHROUGH*/
/* Call postprocessor using previously set pointers */
/* Need to suspend */
/* After the first iMCU, change wraparound pointers to normal state */
/* Prepare to load new iMCU row using other xbuffer list */
/* 0=>1 or 1=>0 */
/* Still need to process last row group of this iMCU row, */
/* which is saved at index M+1 of the other xbuffer */
/*
/* QUANT_2PASS_SUPPORTED */
/*
/* shouldn't happen */
/* Allocate the workspace.
/* unsupported, see comments above */
/* Alloc space for xbuffer[] lists */
/* height of a row group of component */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jdmarker.c
/*
/* JPEG marker codes */
/* Private state */
/* public fields */
/* Application-overridable marker processing methods */
/* Limit on marker data length to save for each marker type */
/* Status of COM/APPn marker saving */
/* NULL if not processing a marker */
/* data bytes read so far in marker */
/* Note: cur_marker is not linked into marker_list until it's all read. */
/*
/* Declare and initialize local copies of input pointer/count */
/* Unload the local copies --- do this only at a restart boundary */
/* Reload the local copies --- used only in MAKE_BYTE_AVAIL */
/* Internal macro for INPUT_BYTE and INPUT_2BYTES: make a byte available.
/* Read a byte into variable V.
/* As above, but read two bytes interpreted as an unsigned 16-bit integer.
/*
/* Process an SOI marker */
/* Reset all parameters that are defined to be reset by SOI */
/* Set initial assumptions for colorspace etc */
/* Assume non-CCIR sampling??? */
/* set default JFIF APP0 values */
/* Process a SOFn marker */
/* We don't support files in which the image height is initially specified */
/* as 0 and is later redefined by DNL.  As long as we have to check that,  */
/* might as well have a general sanity check. */
/* do only once, even if suspend */
/* Process a SOS marker */
/* Number of components */
/* pseudo SOS marker only allowed in progressive mode */
/* Collect the component-spec parameters */
/* Collect the additional scan parameters Ss, Se, Ah/Al. */
/* Prepare to scan data & restart markers */
/* Count another (non-pseudo) SOS marker */
/* Process a DAC marker */
/* define AC table */
/* define DC table */
/* ! D_ARITH_CODING_SUPPORTED */
/* D_ARITH_CODING_SUPPORTED */
/* Process a DHT marker */
/* Here we just do minimal validation of the counts to avoid walking
/* AC table definition */
/* DC table definition */
/* Process a DQT marker */
/* Initialize full table for safety. */
/* Initialize full table for safety. */
/* We convert the zigzag-order table to natural array order. */
/* Process a DRI marker */
/*
/* Length of interesting data in APP0 */
/* Length of interesting data in APP14 */
/* Must be the largest of the above!! */
/* Examine first few bytes from an APP0.
/* Found JFIF APP0 marker: save info */
/* Check version.
/* Generate trace messages */
/* Validate thumbnail dimensions and issue appropriate messages */
/* Found JFIF "JFXX" extension APP0 marker */
/* The library doesn't actually do anything with these,
/* Start of APP0 does not match "JFIF" or "JFXX", or too short */
/* Examine first few bytes from an APP14.
/* Found Adobe APP14 marker */
/* Start of APP14 does not match "Adobe", or too short */
/* Process an APP0 or APP14 marker without saving it */
/* get the interesting part of the marker data */
/* process it */
/* can't get here unless jpeg_save_markers chooses wrong processor */
/* skip any remaining data -- could be lots */
/* Save an APPn or COM marker into the marker list */
/* begin reading a marker */
/* watch out for bogus length word */
/* figure out how much we want to save */
/* allocate and initialize the marker item */
/* data area is just beyond the jpeg_marker_struct */
/* deal with bogus length word */
/* resume reading a marker */
/* move the restart point to here */
/* If there's not at least one byte in buffer, suspend */
/* Copy bytes with reasonable rapidity */
/* Done reading what we want to read */
/* will be NULL if bogus length word */
/* Add new marker to end of list */
/* Reset pointer & calc remaining data length */
/* Reset to initial state for next marker */
/* Process the marker if interesting; else just make a generic trace msg */
/* skip any remaining data -- could be lots */
/* do before skip_input_data */
/* SAVE_MARKERS_SUPPORTED */
/* Skip over an unknown or uninteresting variable-length marker */
/* do before skip_input_data */
/*
/* Skip any non-FF bytes.
/* This loop swallows any duplicate FF bytes.  Extra FFs are legal as
/* found a valid marker, exit loop */
/* Reach here if we found a stuffed-zero data sequence (FF/00).
/* Like next_marker, but used to obtain the initial SOI marker. */
/* For this marker, we do not allow preceding garbage or fill; otherwise,
/*
/* Outer loop repeats once for each marker. */
/* Collect the marker proper, unless we already did. */
/* NB: first_marker() enforces the requirement that SOI appear first. */
/* At this point cinfo->unread_marker contains the marker code and the
/* Baseline */
/* Extended sequential, Huffman */
/* Progressive, Huffman */
/* Extended sequential, arithmetic */
/* Progressive, arithmetic */
/* Currently unsupported SOFn types */
/* Lossless, Huffman */
/* Differential sequential, Huffman */
/* Differential progressive, Huffman */
/* Differential lossless, Huffman */
/* Reserved for JPEG extensions */
/* Lossless, arithmetic */
/* Differential sequential, arithmetic */
/* Differential progressive, arithmetic */
/* Differential lossless, arithmetic */
/* processed the marker */
/* processed the marker */
/* these are all parameterless */
/* Ignore DNL ... perhaps the wrong thing */
/* must be DHP, EXP, JPGn, or RESn */
/* For now, we treat the reserved markers as fatal errors since they are
/* Successfully processed marker, so reset state variable */
/* end loop */
/*
/* Obtain a marker unless we already did. */
/* Note that next_marker will complain if it skips any data. */
/* Normal case --- swallow the marker and let entropy decoder continue */
/* Uh-oh, the restart markers have been messed up. */
/* Let the data source manager determine how to resync. */
/* Update next-restart state */
/*
/* Always put up a warning. */
/* Outer loop handles repeated decision after scanning forward. */
/* invalid marker */
/* valid non-restart marker */
/* one of the next two expected restarts */
/* a prior restart, so advance */
/* desired restart or too far away */
/* Discard marker and let entropy decoder resume processing. */
/* Scan to the next marker, and repeat the decision loop. */
/* Return without advancing past this marker. */
/* Entropy decoder will be forced to process an empty segment. */
/* end loop */
/*
/* until allocated by get_sof */
/* no SOS seen yet */
/* no pending marker */
/* set internal state too */
/*
/* Create subobject in permanent pool */
/* Initialize public method pointers */
/* Initialize COM/APPn processing.
/* Reset marker processing state */
/*
/* Length limit mustn't be larger than what we can allocate
/* Choose processor routine to use.
/* If saving APP0/APP14, save at least enough for our internal use. */
/* If discarding APP0/APP14, use our regular on-the-fly processor. */
/* SAVE_MARKERS_SUPPORTED */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jdmaster.c
/*
/* Private state */
/* public fields */
/* # of passes completed */
/* TRUE if using merged upsample/cconvert */
/* Saved references to initialized quantizer modules,
/*
/* Merging is the equivalent of plain box-filter upsampling */
/* jdmerge.c only supports YCC=>RGB color conversion */
/* and it only handles 2h1v or 2h2v sampling ratios */
/* furthermore, it doesn't work if we've scaled the IDCTs differently */
/* ??? also need to test for upsample-time rescaling, when & if supported */
/* by golly, it'll work... */
/*
/* Do computations that are needed before master selection phase.
/* Prevent application from calling me at wrong times */
/* Compute core output image dimensions and DCT scaling choices. */
/* In selecting the actual DCT scaling for each component, we try to
/* We don't support IDCT ratios larger than 2. */
/* Recompute downsampled dimensions of components;
/* Size in samples, after IDCT scaling */
/* IDCT_SCALING_SUPPORTED */
/* Report number of components in selected colorspace. */
/* Probably this should be in the color conversion module... */
/* else must be same colorspace as in file */
/* See if upsampler will want to emit more than one row at a time */
/*
/* Allocate and fill in the sample_range_limit table */
/* allow negative subscripts of simple table */
/* First segment of "simple" table: limit[x] = 0 for x < 0 */
/* Main part of "simple" table: limit[x] = x */
/* Point to where post-IDCT table starts */
/* End of simple table, rest of first half of post-IDCT table */
/* Second half of post-IDCT table */
/*
/* Initialize dimensions and other stuff */
/* Width of an output scanline must be representable as JDIMENSION. */
/* Initialize my private state */
/* Color quantizer selection */
/* No mode changes if not using buffered-image mode. */
/* 2-pass quantizer only works in 3-component color space. */
/* We use the 2-pass code to map to external colormaps. */
/* If both quantizers are initialized, the 2-pass one is left active;
/* Post-processing: in particular, color conversion first */
/* does color conversion too */
/* Inverse DCT */
/* Entropy decoding: either Huffman or arithmetic coding. */
/* Initialize principal buffer controllers. */
/* never need full buffer here */);
/* We can now tell the memory manager to allocate virtual arrays. */
/* Initialize input side of decompressor to consume first scan. */
/* If jpeg_start_decompress will read the whole file, initialize
/* Estimate number of scans to set pass_limit. */
/* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */
/* For a nonprogressive multiscan file, estimate 1 scan per component. */
/* Count the input pass as done */
/* D_MULTISCAN_FILES_SUPPORTED */
/*
/* Final pass of 2-pass quantization */
/* QUANT_2PASS_SUPPORTED */
/* Select new quantization method */
/* Set up progress monitor's pass info if present */
/* In buffered-image mode, we assume one more output pass if EOI not
/*
/*
/* Prevent application from calling me at wrong times */
/* Select 2-pass quantizer for external colormap use */
/* Notify quantizer of colormap change */
/* just in case */
/* D_MULTISCAN_FILES_SUPPORTED */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jdmerge.c
/*
/* Private subobject */
/* public fields */
/* Pointer to routine to do actual upsampling/conversion of one row group */
/* Private state for YCC->RGB conversion */
/* => table for Cr to R conversion */
/* => table for Cb to B conversion */
/* => table for Cr to G conversion */
/* => table for Cb to G conversion */
/* For 2:1 vertical sampling, we produce two output rows at a time.
/* T if spare buffer is occupied */
/* samples per output row */
/* counts rows remaining in image */
/* speediest right-shift on some machines */
/*
/* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
/* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
/* Cr=>R value is nearest int to 1.40200 * x */
/* Cb=>B value is nearest int to 1.77200 * x */
/* Cr=>G value is scaled-up -0.71414 * x */
/* Cb=>G value is scaled-up -0.34414 * x */
/* We also add in ONE_HALF so that need not do it in inner loop */
/*
/* Mark the spare buffer empty */
/* Initialize total-height counter for detecting bottom of image */
/*
/* 2:1 vertical sampling case: may need a spare row. */
/* number of rows returned to caller */
/* If we have a spare row saved from a previous cycle, just return it. */
/* Figure number of rows to return to caller. */
/* Not more than the distance to the end of the image. */
/* And not more than what the client can accept: */
/* Create output pointer array for upsampler. */
/* Now do the upsampling. */
/* Adjust counts */
/* When the buffer is emptied, declare this input row group consumed */
/* 1:1 vertical sampling case: much easier, never need a spare row. */
/* Just do the upsampling. */
/* Adjust counts */
/*
/*
/* copy these pointers into registers if possible */
/* Loop for each pair of output pixels */
/* Do the chroma part of the calculation */
/* Fetch 2 Y values and emit 2 pixels */
/* If image width is odd, do the last output column separately */
/*
/* copy these pointers into registers if possible */
/* Loop for each group of output pixels */
/* Do the chroma part of the calculation */
/* Fetch 4 Y values and emit 4 pixels */
/* If image width is odd, do the last output column separately */
/*
/* Allocate a spare row buffer */
/* No spare row needed */
/* UPSAMPLE_MERGING_SUPPORTED */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jdpostct.c
/*
/* Private buffer controller object */
/* public fields */
/* Color quantization source buffer: this holds output data from
/* virtual array, or NULL if one-pass */
/* strip buffer, or current strip of virtual */
/* buffer size in rows */
/* for two-pass mode only: */
/* row # of first row in current strip */
/* index of next row to fill/empty in strip */
/* Forward declarations */
/*
/* Single-pass processing with color quantization. */
/* We could be doing buffered-image output before starting a 2-pass
/* For single-pass processing without color quantization,
/* First pass of 2-pass quantization */
/* Second pass of 2-pass quantization */
/* QUANT_2PASS_SUPPORTED */
/*
/* Fill the buffer, but not more than what we can dump out in one go. */
/* Note we rely on the upsampler to detect bottom of image. */
/* Quantize and emit data. */
/*
/* Reposition virtual buffer if at start of strip. */
/* Upsample some data (up to a strip height's worth). */
/* Allow quantizer to scan new data.  No data is emitted, */
/* but we advance out_row_ctr so outer loop can tell when we're done. */
/* Advance if we filled the strip. */
/*
/* Reposition virtual buffer if at start of strip. */
/* Determine number of rows to emit. */
/* available in strip */
/* available in output area */
/* We have to check bottom of image here, can't depend on upsampler. */
/* Quantize and emit data. */
/* Advance if we filled the strip. */
/* QUANT_2PASS_SUPPORTED */
/*
/* flag for no virtual arrays */
/* flag for no strip buffer */
/* Create the quantization buffer, if needed */
/* The buffer strip height is max_v_samp_factor, which is typically
/* Two-pass color quantization: need full-image storage. */
/* We round up the number of rows to a multiple of the strip height. */
/* QUANT_2PASS_SUPPORTED */
/* One-pass color quantization: just make a strip buffer. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jdsample.c
/*
/* Pointer to routine to upsample a single component */
/* Private subobject */
/* public fields */
/* Color conversion buffer.  When using separate upsampling and color
/* Per-component upsampling method pointers */
/* counts rows emitted from color_buf */
/* counts rows remaining in image */
/* Height of an input row group for each component. */
/* These arrays save pixel expansion factors so that int_expand need not
/*
/* Mark the conversion buffer empty */
/* Initialize total-height counter for detecting bottom of image */
/*
/* Fill the conversion buffer, if it's empty */
/* Invoke per-component upsample method.  Notice we pass a POINTER
/* Color-convert and emit rows */
/* How many we have in the buffer: */
/* Not more than the distance to the end of the image.  Need this test
/* And not more than what the client can accept: */
/* Adjust counts */
/* When the buffer is emptied, declare this input row group consumed */
/*
/*
/*
/* safety check */
/*
/* Generate one output row with proper horizontal expansion */
/* don't need GETJSAMPLE() here */
/* Generate any additional output rows by duplicating the first one */
/*
/* don't need GETJSAMPLE() here */
/*
/* don't need GETJSAMPLE() here */
/*
/* until we find out differently */
/* this isn't supported */
/* Verify we can handle the sampling factors, select per-component methods,
/* Compute size of an "input group" after IDCT scaling.  This many samples
/* save for use later */
/* Don't bother to upsample an uninteresting component. */
/* Fullsize components can be processed without any work. */
/* Special case for 2h1v upsampling */
/* Special case for 2h2v upsampling */
/* Generic integral-factors upsampling method */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jdtrans.c
/*
/* Forward declarations */
/*
/* First call: initialize active modules */
/* Absorb whole file into the coef buffer */
/* Call progress monitor hook if present */
/* Absorb some more input */
/* Advance progress counter if appropriate */
/* startup underestimated number of scans; ratchet up one scan */
/* Set state so that jpeg_finish_decompress does the right thing */
/* At this point we should be in state DSTATE_STOPPING if being used
/* Oops, improper usage */
/* keep compiler happy */
/*
/* This is effectively a buffered-image operation. */
/* Compute output image dimensions and related values. */
/* Entropy decoding: either Huffman or arithmetic coding. */
/* Always get a full-image coefficient buffer. */
/* We can now tell the memory manager to allocate virtual arrays. */
/* Initialize input side of decompressor to consume first scan. */
/* Initialize progress monitoring. */
/* Estimate number of scans to set pass_limit. */
/* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */
/* For a nonprogressive multiscan file, estimate 1 scan per component. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jerror.c
/*
/* this is not a core library module, so it doesn't define JPEG_INTERNALS */
/* define exit() codes if not provided */
/*
/*
/* Always display the message */
/* Let the memory manager delete any temp files before we die */
/*
/* Create the message */
/* Display it in a message dialog box */
/* Send it to stderr, adding a newline */
/*
/* It's a warning message.  Since corrupt files may generate many warnings,
/* Always count warnings in num_warnings. */
/* It's a trace message.  Show it if trace_level >= msg_level. */
/*
/* Look up message string in proper table */
/* Defend against bogus message number */
/* Check for string parameter, as indicated by %s in the message text */
/* Format the message into the passed buffer */
/*
/* trace_level is not reset since it is an application-supplied parameter */
/* may be useful as a flag for "no error" */
/*
/* default = no tracing */
/* no warnings emitted yet */
/* may be useful as a flag for "no error" */
/* Initialize message table pointers */
/* for safety */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jfdctflt.c
/*
/* Private declarations for DCT subsystem */
/*
/* deliberate syntax err */
/*
/* Pass 1: process rows. */
/* Load data into workspace */
/* Even part */
/* phase 2 */
/* Apply unsigned->signed conversion */
/* phase 3 */
/* c4 */
/* phase 5 */
/* Odd part */
/* phase 2 */
/* The rotator is modified from fig 4-8 to avoid extra negations. */
/* c6 */
/* c2-c6 */
/* c2+c6 */
/* c4 */
/* phase 5 */
/* phase 6 */
/* advance pointer to next row */
/* Pass 2: process columns. */
/* Even part */
/* phase 2 */
/* phase 3 */
/* c4 */
/* phase 5 */
/* Odd part */
/* phase 2 */
/* The rotator is modified from fig 4-8 to avoid extra negations. */
/* c6 */
/* c2-c6 */
/* c2+c6 */
/* c4 */
/* phase 5 */
/* phase 6 */
/* advance pointer to next column */
/* DCT_FLOAT_SUPPORTED */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jfdctfst.c
/*
/* Private declarations for DCT subsystem */
/*
/* deliberate syntax err */
/* Scaling decisions are generally the same as in the LL&M algorithm;
/* Some C compilers fail to reduce "FIX(constant)" at compile time, thus
/* FIX(0.382683433) */
/* FIX(0.541196100) */
/* FIX(0.707106781) */
/* FIX(1.306562965) */
/* We can gain a little more speed, with a further compromise in accuracy,
/* Multiply a DCTELEM variable by an INT32 constant, and immediately
/*
/* Pass 1: process rows. */
/* Load data into workspace */
/* Even part */
/* phase 2 */
/* Apply unsigned->signed conversion */
/* phase 3 */
/* c4 */
/* phase 5 */
/* Odd part */
/* phase 2 */
/* The rotator is modified from fig 4-8 to avoid extra negations. */
/* c6 */
/* c2-c6 */
/* c2+c6 */
/* c4 */
/* phase 5 */
/* phase 6 */
/* advance pointer to next row */
/* Pass 2: process columns. */
/* Even part */
/* phase 2 */
/* phase 3 */
/* c4 */
/* phase 5 */
/* Odd part */
/* phase 2 */
/* The rotator is modified from fig 4-8 to avoid extra negations. */
/* c6 */
/* c2-c6 */
/* c2+c6 */
/* c4 */
/* phase 5 */
/* phase 6 */
/* advance pointer to next column */
/* DCT_IFAST_SUPPORTED */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jfdctint.c
/*
/* Private declarations for DCT subsystem */
/*
/* deliberate syntax err */
/*
/* lose a little precision to avoid overflow */
/* Some C compilers fail to reduce "FIX(constant)" at compile time, thus
/* FIX(0.298631336) */
/* FIX(0.390180644) */
/* FIX(0.541196100) */
/* FIX(0.765366865) */
/* FIX(0.899976223) */
/* FIX(1.175875602) */
/* FIX(1.501321110) */
/* FIX(1.847759065) */
/* FIX(1.961570560) */
/* FIX(2.053119869) */
/* FIX(2.562915447) */
/* FIX(3.072711026) */
/* Multiply an INT32 variable by an INT32 constant to yield an INT32 result.
/*
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT; */
/* furthermore, we scale the results by 2**PASS1_BITS. */
/* Even part per LL&M figure 1 --- note that published figure is faulty;
/* Apply unsigned->signed conversion */
/* Add fudge factor here for final descale. */
/* Odd part per figure 8 --- note paper omits factor of sqrt(2).
/*  c3 */
/* Add fudge factor here for final descale. */
/*  c1+c3-c5-c7 */
/*  c1+c3+c5-c7 */
/*  c1+c3-c5+c7 */
/* -c1+c3+c5-c7 */
/*  c7-c3 */
/* -c1-c3 */
/*  c5-c3 */
/* -c3-c5 */
/* advance pointer to next row */
/* Pass 2: process columns.
/* Even part per LL&M figure 1 --- note that published figure is faulty;
/* Add fudge factor here for final descale. */
/* Add fudge factor here for final descale. */
/* Odd part per figure 8 --- note paper omits factor of sqrt(2).
/*  c3 */
/* Add fudge factor here for final descale. */
/*  c1+c3-c5-c7 */
/*  c1+c3+c5-c7 */
/*  c1+c3-c5+c7 */
/* -c1+c3+c5-c7 */
/*  c7-c3 */
/* -c1-c3 */
/*  c5-c3 */
/* -c3-c5 */
/* advance pointer to next column */
/*
/* Pre-zero output coefficient block. */
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT; */
/* furthermore, we scale the results by 2**PASS1_BITS. */
/* cK represents sqrt(2) * cos(K*pi/14). */
/* Even part */
/* Apply unsigned->signed conversion */
/* (c2+c6-c4)/2 */
/* (c2+c4-c6)/2 */
/* c6 */
/* c4 */
/* c2+c6-c4 */
/* Odd part */
/* (c3+c1-c5)/2 */
/* (c3+c5-c1)/2 */
/* -c1 */
/* c5 */
/* c3+c1-c5 */
/* advance pointer to next row */
/* Pass 2: process columns.
/* Even part */
/* 64/49 */
/* (c2+c6-c4)/2 */
/* (c2+c4-c6)/2 */
/* c6 */
/* c4 */
/* c2+c6-c4 */
/* Odd part */
/* (c3+c1-c5)/2 */
/* (c3+c5-c1)/2 */
/* -c1 */
/* c5 */
/* c3+c1-c5 */
/* advance pointer to next column */
/*
/* Pre-zero output coefficient block. */
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT; */
/* furthermore, we scale the results by 2**PASS1_BITS. */
/* cK represents sqrt(2) * cos(K*pi/12). */
/* Even part */
/* Apply unsigned->signed conversion */
/* c2 */
/* c4 */
/* Odd part */
/* c5 */
/* advance pointer to next row */
/* Pass 2: process columns.
/* Even part */
/* 16/9 */
/* c2 */
/* c4 */
/* Odd part */
/* c5 */
/* 16/9 */
/* 16/9 */
/* 16/9 */
/* advance pointer to next column */
/*
/* Pre-zero output coefficient block. */
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT; */
/* furthermore, we scale the results by 2**PASS1_BITS. */
/* We scale the results further by 2 as part of output adaption */
/* scaling for different DCT size. */
/* cK represents sqrt(2) * cos(K*pi/10). */
/* Even part */
/* Apply unsigned->signed conversion */
/* (c2+c4)/2 */
/* (c2-c4)/2 */
/* Odd part */
/* c3 */
/* c1-c3 */
/* c1+c3 */
/* advance pointer to next row */
/* Pass 2: process columns.
/* Even part */
/* 32/25 */
/* (c2+c4)/2 */
/* (c2-c4)/2 */
/* Odd part */
/* c3 */
/* c1-c3 */
/* c1+c3 */
/* advance pointer to next column */
/*
/* Pre-zero output coefficient block. */
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT; */
/* furthermore, we scale the results by 2**PASS1_BITS. */
/* We must also scale the output by (8/4)**2 = 2**2, which we add here. */
/* cK represents sqrt(2) * cos(K*pi/16) [refers to 8-point FDCT]. */
/* Even part */
/* Apply unsigned->signed conversion */
/* Odd part */
/* c6 */
/* Add fudge factor here for final descale. */
/* c2-c6 */
/* c2+c6 */
/* advance pointer to next row */
/* Pass 2: process columns.
/* Even part */
/* Add fudge factor here for final descale. */
/* Odd part */
/* c6 */
/* Add fudge factor here for final descale. */
/* c2-c6 */
/* c2+c6 */
/* advance pointer to next column */
/*
/* Pre-zero output coefficient block. */
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT; */
/* furthermore, we scale the results by 2**PASS1_BITS. */
/* We scale the results further by 2**2 as part of output adaption */
/* scaling for different DCT size. */
/* cK represents sqrt(2) * cos(K*pi/6). */
/* Even part */
/* Apply unsigned->signed conversion */
/* c2 */
/* Odd part */
/* c1 */
/* advance pointer to next row */
/* Pass 2: process columns.
/* Even part */
/* 16/9 */
/* c2 */
/* Odd part */
/* c1 */
/* advance pointer to next column */
/*
/* Pre-zero output coefficient block. */
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT. */
/* Row 0 */
/* Row 1 */
/* Pass 2: process columns.
/* Column 0 */
/* Apply unsigned->signed conversion */
/* Column 1 */
/*
/* Pre-zero output coefficient block. */
/* We leave the result scaled up by an overall factor of 8. */
/* We must also scale the output by (8/1)**2 = 2**6. */
/* Apply unsigned->signed conversion */
/*
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT; */
/* we scale the results further by 2 as part of output adaption */
/* scaling for different DCT size. */
/* cK represents sqrt(2) * cos(K*pi/18). */
/* Even part */
/* Apply unsigned->signed conversion */
/* c6 */
/* c2 */
/* c6 */
/* c4 */
/* c8 */
/* Odd part */
/* c3 */
/* c3 */
/* c5 */
/* c7 */
/* c1 */
/* Done. */
/* advance pointer to next row */
/* switch pointer to extended workspace */
/* Pass 2: process columns.
/* Even part */
/* 128/81 */
/* c6 */
/* c2 */
/* c6 */
/* c4 */
/* c8 */
/* Odd part */
/* c3 */
/* c3 */
/* c5 */
/* c7 */
/* c1 */
/* advance pointer to next column */
/* advance pointer to next column */
/*
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT; */
/* we scale the results further by 2 as part of output adaption */
/* scaling for different DCT size. */
/* cK represents sqrt(2) * cos(K*pi/20). */
/* Even part */
/* Apply unsigned->signed conversion */
/* c4 */
/* c8 */
/* c6 */
/* c2-c6 */
/* c2+c6 */
/* Odd part */
/* c1 */
/* c3 */
/* c7 */
/* c9 */
/* (c3+c7)/2 */
/* (c1-c9)/2 */
/* (c3-c7)/2 */
/* Done. */
/* advance pointer to next row */
/* switch pointer to extended workspace */
/* Pass 2: process columns.
/* Even part */
/* 32/25 */
/* c4 */
/* c8 */
/* c6 */
/* c2-c6 */
/* c2+c6 */
/* Odd part */
/* 32/25 */
/* 32/25 */
/* c1 */
/* c3 */
/* c7 */
/* c9 */
/* (c3+c7)/2 */
/* (c1-c9)/2 */
/* (c3-c7)/2 */
/* 16/25 */
/* advance pointer to next column */
/* advance pointer to next column */
/*
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT; */
/* we scale the results further by 2 as part of output adaption */
/* scaling for different DCT size. */
/* cK represents sqrt(2) * cos(K*pi/22). */
/* Even part */
/* Apply unsigned->signed conversion */
/* c2 */
/* c10 */
/* c6 */
/* c4 */
/* c2+c8-c6 */
/* c4+c10 */
/* c4-c6-c10 */
/* c2 */
/* c8 */
/* c2+c4-c6 */
/* c8+c10 */
/* Odd part */
/* c3 */
/* c5 */
/* c7 */
/* c7+c5+c3-c1 */
/* c9 */
/* -c7 */
/* -c1 */
/* c9+c7+c1-c3 */
/* c5 */
/* c9 */
/* c9+c5+c3-c7 */
/* c1 */
/* c1+c5-c9-c7 */
/* c3 */
/* Done. */
/* advance pointer to next row */
/* switch pointer to extended workspace */
/* Pass 2: process columns.
/* Even part */
/* 128/121 */
/* c2 */
/* c10 */
/* c6 */
/* c4 */
/* c2+c8-c6 */
/* c4+c10 */
/* c4-c6-c10 */
/* c2 */
/* c8 */
/* c2+c4-c6 */
/* c8+c10 */
/* Odd part */
/* c3 */
/* c5 */
/* c7 */
/* c7+c5+c3-c1 */
/* c9 */
/* -c7 */
/* -c1 */
/* c9+c7+c1-c3 */
/* c5 */
/* c9 */
/* c9+c5+c3-c7 */
/* c1 */
/* c1+c5-c9-c7 */
/* c3 */
/* advance pointer to next column */
/* advance pointer to next column */
/*
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT. */
/* cK represents sqrt(2) * cos(K*pi/24). */
/* Even part */
/* Apply unsigned->signed conversion */
/* c4 */
/* c2 */
/* Odd part */
/* c9 */
/* c3-c9 */
/* c3+c9 */
/* c5 */
/* c7 */
/* c5+c7-c1 */
/* c11 */
/* -c11 */
/* c1+c5-c11 */
/* c7 */
/* c1+c11-c7 */
/* c5 */
/* c3 */
/* c9 */
/* Done. */
/* advance pointer to next row */
/* switch pointer to extended workspace */
/* Pass 2: process columns.
/* Even part */
/* 8/9 */
/* 8/9 */
/* c4 */
/* 8/9 */
/* c2 */
/* Odd part */
/* c9 */
/* c3-c9 */
/* c3+c9 */
/* c5 */
/* c7 */
/* c5+c7-c1 */
/* c11 */
/* -c11 */
/* c1+c5-c11 */
/* c7 */
/* c1+c11-c7 */
/* c5 */
/* c3 */
/* c9 */
/* advance pointer to next column */
/* advance pointer to next column */
/*
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT. */
/* cK represents sqrt(2) * cos(K*pi/26). */
/* Even part */
/* Apply unsigned->signed conversion */
/* c2 */
/* c6 */
/* c10 */
/* c12 */
/* c8 */
/* c4 */
/* (c4+c6)/2 */
/* (c2-c10)/2 */
/* (c8-c12)/2 */
/* (c4-c6)/2 */
/* (c2+c10)/2 */
/* (c8+c12)/2 */
/* Odd part */
/* c3 */
/* c5 */
/* c7 */
/* c11 */
/* c3+c5+c7-c1 */
/* c9-c11 */
/* c7 */
/* c11 */
/* -c5 */
/* c5+c9+c11-c3 */
/* c1+c7 */
/* -c9 */
/* c1+c5-c9-c11 */
/* c3+c7 */
/* c3+c5+c9-c7 */
/* c1+c11 */
/* Done. */
/* advance pointer to next row */
/* switch pointer to extended workspace */
/* Pass 2: process columns.
/* Even part */
/* 128/169 */
/* c2 */
/* c6 */
/* c10 */
/* c12 */
/* c8 */
/* c4 */
/* (c4+c6)/2 */
/* (c2-c10)/2 */
/* (c8-c12)/2 */
/* (c4-c6)/2 */
/* (c2+c10)/2 */
/* (c8+c12)/2 */
/* Odd part */
/* c3 */
/* c5 */
/* c7 */
/* c11 */
/* c3+c5+c7-c1 */
/* c9-c11 */
/* c7 */
/* c11 */
/* -c5 */
/* c5+c9+c11-c3 */
/* c1+c7 */
/* -c9 */
/* c1+c5-c9-c11 */
/* c3+c7 */
/* c3+c5+c9-c7 */
/* c1+c11 */
/* advance pointer to next column */
/* advance pointer to next column */
/*
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT. */
/* cK represents sqrt(2) * cos(K*pi/28). */
/* Even part */
/* Apply unsigned->signed conversion */
/* c4 */
/* c12 */
/* c8 */
/* c6 */
/* c2-c6 */
/* c10 */
/* c6+c10 */
/* c2 */
/* Odd part */
/* -c13 */
/* c1 */
/* c5 */
/* c9 */
/* c3+c5-c13 */
/* c1+c11-c9 */
/* c3 */
/* c11 */
/* c3-c9-c13 */
/* c1+c5+c11 */
/* c3+c5-c1 */
/* Done. */
/* advance pointer to next row */
/* switch pointer to extended workspace */
/* Pass 2: process columns.
/* Even part */
/* 32/49 */
/* c4 */
/* c12 */
/* c8 */
/* c6 */
/* c2-c6 */
/* c10 */
/* c6+c10 */
/* c2 */
/* Odd part */
/* 32/49 */
/* 32/49 */
/* -c13 */
/* c1 */
/* c5 */
/* c9 */
/* c3+c5-c13 */
/* c1+c11-c9 */
/* c3 */
/* c11 */
/* c3-c9-c13 */
/* c1+c5+c11 */
/* c3+c5-c1 */
/* c9-c11-c13 */
/* advance pointer to next column */
/* advance pointer to next column */
/*
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT. */
/* cK represents sqrt(2) * cos(K*pi/30). */
/* Even part */
/* Apply unsigned->signed conversion */
/* c6 */
/* c12 */
/* c2+c14 */
/* c4+c8 */
/* c8-c14 */
/* c2-c4 */
/* c2 */
/* c8 */
/* (c6+c12)/2 */
/* Odd part */
/* c5 */
/* c3 */
/* c9 */
/* c5 */
/* c1 */
/* c3 */
/* c11 */
/* c7-c11 */
/* c3-c9 */
/* c1+c13 */
/* -(c1-c7) */
/* c3+c9 */
/* c11+c13 */
/* Done. */
/* advance pointer to next row */
/* switch pointer to extended workspace */
/* Pass 2: process columns.
/* Even part */
/* 256/225 */
/* c6 */
/* c12 */
/* c2+c14 */
/* c4+c8 */
/* c8-c14 */
/* c2-c4 */
/* c2 */
/* c8 */
/* (c6+c12)/2 */
/* Odd part */
/* c5 */
/* c3 */
/* c9 */
/* c5 */
/* c1 */
/* c3 */
/* c11 */
/* c7-c11 */
/* c3-c9 */
/* c1+c13 */
/* -(c1-c7) */
/* c3+c9 */
/* c11+c13 */
/* advance pointer to next column */
/* advance pointer to next column */
/*
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT; */
/* furthermore, we scale the results by 2**PASS1_BITS. */
/* cK represents sqrt(2) * cos(K*pi/32). */
/* Even part */
/* Apply unsigned->signed conversion */
/* c4[16] = c2[8] */
/* c12[16] = c6[8] */
/* c14[16] = c7[8] */
/* c2[16] = c1[8] */
/* c6+c14 */
/* c2+c10 */
/* c2-c6 */
/* c10+c14 */
/* Odd part */
/* c3 */
/* c13 */
/* c5 */
/* c11 */
/* c7 */
/* c9 */
/* c15 */
/* c1 */
/* -c11 */
/* -c5 */
/* -c3 */
/* c13 */
/* c7+c5+c3-c1 */
/* c15+c13-c11+c9 */
/* c9-c3-c15+c11 */
/* c7+c13+c1-c5 */
/* c7+c5+c15-c3 */
/* c9-c11+c1-c13 */
/* c15+c3+c11-c7 */
/* c1+c13+c5-c9 */
/* Done. */
/* advance pointer to next row */
/* switch pointer to extended workspace */
/* Pass 2: process columns.
/* Even part */
/* c4[16] = c2[8] */
/* c12[16] = c6[8] */
/* c14[16] = c7[8] */
/* c2[16] = c1[8] */
/* c6+c14 */
/* c2+10 */
/* c2-c6 */
/* c10+c14 */
/* Odd part */
/* c3 */
/* c13 */
/* c5 */
/* c11 */
/* c7 */
/* c9 */
/* c15 */
/* c1 */
/* -c11 */
/* -c5 */
/* -c3 */
/* c13 */
/* c7+c5+c3-c1 */
/* c15+c13-c11+c9 */
/* c9-c3-c15+c11 */
/* c7+c13+c1-c5 */
/* c7+c5+c15-c3 */
/* c9-c11+c1-c13 */
/* c15+c3+c11-c7 */
/* c1+c13+c5-c9 */
/* advance pointer to next column */
/* advance pointer to next column */
/*
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT; */
/* furthermore, we scale the results by 2**PASS1_BITS. */
/* 16-point FDCT kernel, cK represents sqrt(2) * cos(K*pi/32). */
/* Even part */
/* Apply unsigned->signed conversion */
/* c4[16] = c2[8] */
/* c12[16] = c6[8] */
/* c14[16] = c7[8] */
/* c2[16] = c1[8] */
/* c6+c14 */
/* c2+c10 */
/* c2-c6 */
/* c10+c14 */
/* Odd part */
/* c3 */
/* c13 */
/* c5 */
/* c11 */
/* c7 */
/* c9 */
/* c15 */
/* c1 */
/* -c11 */
/* -c5 */
/* -c3 */
/* c13 */
/* c7+c5+c3-c1 */
/* c15+c13-c11+c9 */
/* c9-c3-c15+c11 */
/* c7+c13+c1-c5 */
/* c7+c5+c15-c3 */
/* c9-c11+c1-c13 */
/* c15+c3+c11-c7 */
/* c1+c13+c5-c9 */
/* advance pointer to next row */
/* Pass 2: process columns.
/* Even part per LL&M figure 1 --- note that published figure is faulty;
/* Odd part per figure 8 --- note paper omits factor of sqrt(2).
/*  c3 */
/*  c1+c3-c5-c7 */
/*  c1+c3+c5-c7 */
/*  c1+c3-c5+c7 */
/* -c1+c3+c5-c7 */
/*  c7-c3 */
/* -c1-c3 */
/*  c5-c3 */
/* -c3-c5 */
/* advance pointer to next column */
/*
/* Zero bottom row of output coefficient block. */
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT; */
/* furthermore, we scale the results by 2**PASS1_BITS. */
/* 14-point FDCT kernel, cK represents sqrt(2) * cos(K*pi/28). */
/* Even part */
/* Apply unsigned->signed conversion */
/* c4 */
/* c12 */
/* c8 */
/* c6 */
/* c2-c6 */
/* c10 */
/* c6+c10 */
/* c2 */
/* Odd part */
/* -c13 */
/* c1 */
/* c5 */
/* c9 */
/* c3+c5-c13 */
/* c1+c11-c9 */
/* c3 */
/* c11 */
/* c3-c9-c13 */
/* c1+c5+c11 */
/* c3+c5-c1 */
/* advance pointer to next row */
/* Pass 2: process columns.
/* Even part */
/* 64/49 */
/* (c2+c6-c4)/2 */
/* (c2+c4-c6)/2 */
/* c6 */
/* c4 */
/* c2+c6-c4 */
/* Odd part */
/* (c3+c1-c5)/2 */
/* (c3+c5-c1)/2 */
/* -c1 */
/* c5 */
/* c3+c1-c5 */
/* advance pointer to next column */
/*
/* Zero 2 bottom rows of output coefficient block. */
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT; */
/* furthermore, we scale the results by 2**PASS1_BITS. */
/* 12-point FDCT kernel, cK represents sqrt(2) * cos(K*pi/24). */
/* Even part */
/* Apply unsigned->signed conversion */
/* c4 */
/* c2 */
/* Odd part */
/* c9 */
/* c3-c9 */
/* c3+c9 */
/* c5 */
/* c7 */
/* c5+c7-c1 */
/* c11 */
/* -c11 */
/* c1+c5-c11 */
/* c7 */
/* c1+c11-c7 */
/* c5 */
/* c3 */
/* c9 */
/* advance pointer to next row */
/* Pass 2: process columns.
/* Even part */
/* 16/9 */
/* c2 */
/* c4 */
/* Odd part */
/* c5 */
/* 16/9 */
/* 16/9 */
/* 16/9 */
/* advance pointer to next column */
/*
/* Zero 3 bottom rows of output coefficient block. */
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT; */
/* furthermore, we scale the results by 2**PASS1_BITS. */
/* 10-point FDCT kernel, cK represents sqrt(2) * cos(K*pi/20). */
/* Even part */
/* Apply unsigned->signed conversion */
/* c4 */
/* c8 */
/* c6 */
/* c2-c6 */
/* c2+c6 */
/* Odd part */
/* c1 */
/* c3 */
/* c7 */
/* c9 */
/* (c3+c7)/2 */
/* (c1-c9)/2 */
/* (c3-c7)/2 */
/* advance pointer to next row */
/* Pass 2: process columns.
/* Even part */
/* 32/25 */
/* (c2+c4)/2 */
/* (c2-c4)/2 */
/* Odd part */
/* c3 */
/* c1-c3 */
/* c1+c3 */
/* advance pointer to next column */
/*
/* Zero 4 bottom rows of output coefficient block. */
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT; */
/* furthermore, we scale the results by 2**PASS1_BITS. */
/* We must also scale the output by 8/4 = 2, which we add here. */
/* Even part per LL&M figure 1 --- note that published figure is faulty;
/* Apply unsigned->signed conversion */
/* Add fudge factor here for final descale. */
/* Odd part per figure 8 --- note paper omits factor of sqrt(2).
/*  c3 */
/* Add fudge factor here for final descale. */
/*  c1+c3-c5-c7 */
/*  c1+c3+c5-c7 */
/*  c1+c3-c5+c7 */
/* -c1+c3+c5-c7 */
/*  c7-c3 */
/* -c1-c3 */
/*  c5-c3 */
/* -c3-c5 */
/* advance pointer to next row */
/* Pass 2: process columns.
/* Even part */
/* Add fudge factor here for final descale. */
/* Odd part */
/* c6 */
/* Add fudge factor here for final descale. */
/* c2-c6 */
/* c2+c6 */
/* advance pointer to next column */
/*
/* Pre-zero output coefficient block. */
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT; */
/* furthermore, we scale the results by 2**PASS1_BITS. */
/* We scale the results further by 2 as part of output adaption */
/* scaling for different DCT size. */
/* 6-point FDCT kernel, cK represents sqrt(2) * cos(K*pi/12). */
/* Even part */
/* Apply unsigned->signed conversion */
/* c2 */
/* c4 */
/* Odd part */
/* c5 */
/* advance pointer to next row */
/* Pass 2: process columns.
/* Even part */
/* 16/9 */
/* c2 */
/* Odd part */
/* c1 */
/* advance pointer to next column */
/*
/* Pre-zero output coefficient block. */
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT; */
/* furthermore, we scale the results by 2**PASS1_BITS. */
/* We must also scale the output by (8/4)*(8/2) = 2**3, which we add here. */
/* 4-point FDCT kernel, */
/* cK represents sqrt(2) * cos(K*pi/16) [refers to 8-point FDCT]. */
/* Even part */
/* Apply unsigned->signed conversion */
/* Odd part */
/* c6 */
/* Add fudge factor here for final descale. */
/* c2-c6 */
/* c2+c6 */
/* advance pointer to next row */
/* Pass 2: process columns.
/* Even part */
/* Add fudge factor here for final descale. */
/* Odd part */
/* advance pointer to next column */
/*
/* Pre-zero output coefficient block. */
/* We leave the results scaled up by an overall factor of 8.
/* Even part */
/* Apply unsigned->signed conversion */
/* Odd part */
/*
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT; */
/* furthermore, we scale the results by 2**PASS1_BITS. */
/* Even part per LL&M figure 1 --- note that published figure is faulty;
/* Apply unsigned->signed conversion */
/* Odd part per figure 8 --- note paper omits factor of sqrt(2).
/*  c3 */
/*  c1+c3-c5-c7 */
/*  c1+c3+c5-c7 */
/*  c1+c3-c5+c7 */
/* -c1+c3+c5-c7 */
/*  c7-c3 */
/* -c1-c3 */
/*  c5-c3 */
/* -c3-c5 */
/* Done. */
/* advance pointer to next row */
/* switch pointer to extended workspace */
/* Pass 2: process columns.
/* Even part */
/* c4[16] = c2[8] */
/* c12[16] = c6[8] */
/* c14[16] = c7[8] */
/* c2[16] = c1[8] */
/* c6+c14 */
/* c2+c10 */
/* c2-c6 */
/* c10+c14 */
/* Odd part */
/* c3 */
/* c13 */
/* c5 */
/* c11 */
/* c7 */
/* c9 */
/* c15 */
/* c1 */
/* -c11 */
/* -c5 */
/* -c3 */
/* c13 */
/* c7+c5+c3-c1 */
/* c15+c13-c11+c9 */
/* c9-c3-c15+c11 */
/* c7+c13+c1-c5 */
/* c7+c5+c15-c3 */
/* c9-c11+c1-c13 */
/* c15+c3+c11-c7 */
/* c1+c13+c5-c9 */
/* advance pointer to next column */
/* advance pointer to next column */
/*
/* Pre-zero output coefficient block. */
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT; */
/* furthermore, we scale the results by 2**PASS1_BITS. */
/* 7-point FDCT kernel, cK represents sqrt(2) * cos(K*pi/14). */
/* Even part */
/* Apply unsigned->signed conversion */
/* (c2+c6-c4)/2 */
/* (c2+c4-c6)/2 */
/* c6 */
/* c4 */
/* c2+c6-c4 */
/* Odd part */
/* (c3+c1-c5)/2 */
/* (c3+c5-c1)/2 */
/* -c1 */
/* c5 */
/* c3+c1-c5 */
/* Done. */
/* advance pointer to next row */
/* switch pointer to extended workspace */
/* Pass 2: process columns.
/* Even part */
/* 32/49 */
/* c4 */
/* c12 */
/* c8 */
/* c6 */
/* c2-c6 */
/* c10 */
/* c6+c10 */
/* c2 */
/* Odd part */
/* 32/49 */
/* 32/49 */
/* -c13 */
/* c1 */
/* c5 */
/* c9 */
/* c3+c5-c13 */
/* c1+c11-c9 */
/* c3 */
/* c11 */
/* c3-c9-c13 */
/* c1+c5+c11 */
/* c3+c5-c1 */
/* c9-c11-c13 */
/* advance pointer to next column */
/* advance pointer to next column */
/*
/* Pre-zero output coefficient block. */
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT; */
/* furthermore, we scale the results by 2**PASS1_BITS. */
/* 6-point FDCT kernel, cK represents sqrt(2) * cos(K*pi/12). */
/* Even part */
/* Apply unsigned->signed conversion */
/* c2 */
/* c4 */
/* Odd part */
/* c5 */
/* Done. */
/* advance pointer to next row */
/* switch pointer to extended workspace */
/* Pass 2: process columns.
/* Even part */
/* 8/9 */
/* 8/9 */
/* c4 */
/* 8/9 */
/* c2 */
/* Odd part */
/* c9 */
/* c3-c9 */
/* c3+c9 */
/* c5 */
/* c7 */
/* c5+c7-c1 */
/* c11 */
/* -c11 */
/* c1+c5-c11 */
/* c7 */
/* c1+c11-c7 */
/* c5 */
/* c3 */
/* c9 */
/* advance pointer to next column */
/* advance pointer to next column */
/*
/* Pre-zero output coefficient block. */
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT; */
/* furthermore, we scale the results by 2**PASS1_BITS. */
/* 5-point FDCT kernel, cK represents sqrt(2) * cos(K*pi/10). */
/* Even part */
/* Apply unsigned->signed conversion */
/* (c2+c4)/2 */
/* (c2-c4)/2 */
/* Odd part */
/* c3 */
/* c1-c3 */
/* c1+c3 */
/* Done. */
/* advance pointer to next row */
/* switch pointer to extended workspace */
/* Pass 2: process columns.
/* Even part */
/* 32/25 */
/* c4 */
/* c8 */
/* c6 */
/* c2-c6 */
/* c2+c6 */
/* Odd part */
/* 32/25 */
/* 32/25 */
/* c1 */
/* c3 */
/* c7 */
/* c9 */
/* (c3+c7)/2 */
/* (c1-c9)/2 */
/* (c3-c7)/2 */
/* 16/25 */
/* advance pointer to next column */
/* advance pointer to next column */
/*
/* Pre-zero output coefficient block. */
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT; */
/* furthermore, we scale the results by 2**PASS1_BITS. */
/* We must also scale the output by 8/4 = 2, which we add here. */
/* 4-point FDCT kernel, cK represents sqrt(2) * cos(K*pi/16). */
/* Even part */
/* Apply unsigned->signed conversion */
/* Odd part */
/* c6 */
/* Add fudge factor here for final descale. */
/* c2-c6 */
/* c2+c6 */
/* advance pointer to next row */
/* Pass 2: process columns.
/* Even part per LL&M figure 1 --- note that published figure is faulty;
/* Add fudge factor here for final descale. */
/* Add fudge factor here for final descale. */
/* Odd part per figure 8 --- note paper omits factor of sqrt(2).
/*  c3 */
/* Add fudge factor here for final descale. */
/*  c1+c3-c5-c7 */
/*  c1+c3+c5-c7 */
/*  c1+c3-c5+c7 */
/* -c1+c3+c5-c7 */
/*  c7-c3 */
/* -c1-c3 */
/*  c5-c3 */
/* -c3-c5 */
/* advance pointer to next column */
/*
/* Pre-zero output coefficient block. */
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT; */
/* furthermore, we scale the results by 2**PASS1_BITS. */
/* We scale the results further by 2 as part of output adaption */
/* scaling for different DCT size. */
/* 3-point FDCT kernel, cK represents sqrt(2) * cos(K*pi/6). */
/* Even part */
/* Apply unsigned->signed conversion */
/* c2 */
/* Odd part */
/* c1 */
/* advance pointer to next row */
/* Pass 2: process columns.
/* Even part */
/* 16/9 */
/* c2 */
/* c4 */
/* Odd part */
/* c5 */
/* 16/9 */
/* 16/9 */
/* 16/9 */
/* advance pointer to next column */
/*
/* Pre-zero output coefficient block. */
/* Pass 1: process rows. */
/* Note results are scaled up by sqrt(8) compared to a true DCT. */
/* We must also scale the output by (8/2)*(8/4) = 2**3, which we add here. */
/* Even part */
/* Apply unsigned->signed conversion */
/* Odd part */
/* advance pointer to next row */
/* Pass 2: process columns.
/* Even part */
/* Odd part */
/* c6 */
/* Add fudge factor here for final descale. */
/* c2-c6 */
/* c2+c6 */
/* advance pointer to next column */
/*
/* Pre-zero output coefficient block. */
/* We leave the results scaled up by an overall factor of 8.
/* Even part */
/* Apply unsigned->signed conversion */
/* Odd part */
/* DCT_SCALING_SUPPORTED */
/* DCT_ISLOW_SUPPORTED */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jidctflt.c
/*
/* Private declarations for DCT subsystem */
/*
/* deliberate syntax err */
/* Dequantize a coefficient by multiplying it by the multiplier-table
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array. */
/* Due to quantization, we will usually find that many of the input
/* AC terms all zero */
/* advance pointers to next column */
/* Even part */
/* phase 3 */
/* phases 5-3 */
/* 2*c4 */
/* phase 2 */
/* Odd part */
/* phase 6 */
/* phase 5 */
/* 2*c4 */
/* 2*c2 */
/* 2*(c2-c6) */
/* 2*(c2+c6) */
/* phase 2 */
/* advance pointers to next column */
/* Pass 2: process rows from work array, store into output array. */
/* Rows of zeroes can be exploited in the same way as we did with columns.
/* Even part */
/* Apply signed->unsigned and prepare float->int conversion */
/* Odd part */
/* 2*c2 */
/* 2*(c2-c6) */
/* 2*(c2+c6) */
/* Final output stage: float->int conversion and range-limit */
/* advance pointer to next row */
/* DCT_FLOAT_SUPPORTED */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jidctfst.c
/*
/* Private declarations for DCT subsystem */
/*
/* deliberate syntax err */
/* Scaling decisions are generally the same as in the LL&M algorithm;
/* lose a little precision to avoid overflow */
/* Some C compilers fail to reduce "FIX(constant)" at compile time, thus
/* FIX(1.082392200) */
/* FIX(1.414213562) */
/* FIX(1.847759065) */
/* FIX(2.613125930) */
/* We can gain a little more speed, with a further compromise in accuracy,
/* Multiply a DCTELEM variable by an INT32 constant, and immediately
/* Dequantize a coefficient by multiplying it by the multiplier-table
/* Like DESCALE, but applies to a DCTELEM and produces an int.
/* DCTELEM may be 16 or 32 bits */
/* DCTELEM must be 32 bits */
/*
/* buffers data between passes */
/* for DESCALE */
/* for IDESCALE */
/* Pass 1: process columns from input, store into work array. */
/* Due to quantization, we will usually find that many of the input
/* AC terms all zero */
/* advance pointers to next column */
/* Even part */
/* phase 3 */
/* phases 5-3 */
/* 2*c4 */
/* phase 2 */
/* Odd part */
/* phase 6 */
/* phase 5 */
/* 2*c4 */
/* 2*c2 */
/* 2*(c2-c6) */
/* -2*(c2+c6) */
/* phase 2 */
/* advance pointers to next column */
/* Pass 2: process rows from work array, store into output array. */
/* Note that we must descale the results by a factor of 8 == 2**3, */
/* and also undo the PASS1_BITS scaling. */
/* Rows of zeroes can be exploited in the same way as we did with columns.
/* AC terms all zero */
/* advance pointer to next row */
/* Even part */
/* Odd part */
/* phase 5 */
/* 2*c4 */
/* 2*c2 */
/* 2*(c2-c6) */
/* -2*(c2+c6) */
/* phase 2 */
/* Final output stage: scale down by a factor of 8 and range-limit */
/* advance pointer to next row */
/* DCT_IFAST_SUPPORTED */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jidctint.c
/*
/* Private declarations for DCT subsystem */
/*
/* deliberate syntax err */
/*
/* lose a little precision to avoid overflow */
/* Some C compilers fail to reduce "FIX(constant)" at compile time, thus
/* FIX(0.298631336) */
/* FIX(0.390180644) */
/* FIX(0.541196100) */
/* FIX(0.765366865) */
/* FIX(0.899976223) */
/* FIX(1.175875602) */
/* FIX(1.501321110) */
/* FIX(1.847759065) */
/* FIX(1.961570560) */
/* FIX(2.053119869) */
/* FIX(2.562915447) */
/* FIX(3.072711026) */
/* Multiply an INT32 variable by an INT32 constant to yield an INT32 result.
/* Dequantize a coefficient by multiplying it by the multiplier-table
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array. */
/* Note results are scaled up by sqrt(8) compared to a true IDCT; */
/* furthermore, we scale the results by 2**PASS1_BITS. */
/* Due to quantization, we will usually find that many of the input
/* AC terms all zero */
/* advance pointers to next column */
/* Even part: reverse the even part of the forward DCT. */
/* The rotator is sqrt(2)*c(-6). */
/* Add fudge factor here for final descale. */
/* Odd part per figure 8; the matrix is unitary and hence its
/* sqrt(2) * c3 */
/* sqrt(2) * (-c3-c5) */
/* sqrt(2) * (c5-c3) */
/* sqrt(2) * (c7-c3) */
/* sqrt(2) * (-c1+c3+c5-c7) */
/* sqrt(2) * ( c1+c3-c5-c7) */
/* sqrt(2) * (-c1-c3) */
/* sqrt(2) * ( c1+c3-c5+c7) */
/* sqrt(2) * ( c1+c3+c5-c7) */
/* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
/* advance pointers to next column */
/* Pass 2: process rows from work array, store into output array. */
/* Note that we must descale the results by a factor of 8 == 2**3, */
/* and also undo the PASS1_BITS scaling. */
/* Rows of zeroes can be exploited in the same way as we did with columns.
/* AC terms all zero */
/* advance pointer to next row */
/* Even part: reverse the even part of the forward DCT. */
/* The rotator is sqrt(2)*c(-6). */
/* Add fudge factor here for final descale. */
/* Odd part per figure 8; the matrix is unitary and hence its
/* sqrt(2) * c3 */
/* sqrt(2) * (-c3-c5) */
/* sqrt(2) * (c5-c3) */
/* sqrt(2) * (c7-c3) */
/* sqrt(2) * (-c1+c3+c5-c7) */
/* sqrt(2) * ( c1+c3-c5-c7) */
/* sqrt(2) * (-c1-c3) */
/* sqrt(2) * ( c1+c3-c5+c7) */
/* sqrt(2) * ( c1+c3+c5-c7) */
/* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
/* advance pointer to next row */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* c4 */
/* c6 */
/* c2+c4-c6 */
/* c2 */
/* c2-c4-c6 */
/* c2+c4+c6 */
/* c0 */
/* Odd part */
/* (c3+c1-c5)/2 */
/* (c3+c5-c1)/2 */
/* -c1 */
/* c5 */
/* c3+c1-c5 */
/* Final output stage */
/* Pass 2: process 7 rows from work array, store into output array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* c4 */
/* c6 */
/* c2+c4-c6 */
/* c2 */
/* c2-c4-c6 */
/* c2+c4+c6 */
/* c0 */
/* Odd part */
/* (c3+c1-c5)/2 */
/* (c3+c5-c1)/2 */
/* -c1 */
/* c5 */
/* c3+c1-c5 */
/* Final output stage */
/* advance pointer to next row */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* c4 */
/* c2 */
/* Odd part */
/* c5 */
/* Final output stage */
/* Pass 2: process 6 rows from work array, store into output array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* c4 */
/* c2 */
/* Odd part */
/* c5 */
/* Final output stage */
/* advance pointer to next row */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* (c2+c4)/2 */
/* (c2-c4)/2 */
/* Odd part */
/* c3 */
/* c1-c3 */
/* c1+c3 */
/* Final output stage */
/* Pass 2: process 5 rows from work array, store into output array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* (c2+c4)/2 */
/* (c2-c4)/2 */
/* Odd part */
/* c3 */
/* c1-c3 */
/* c1+c3 */
/* Final output stage */
/* advance pointer to next row */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array. */
/* Even part */
/* Odd part */
/* Same rotation as in the even part of the 8x8 LL&M IDCT */
/* c6 */
/* Add fudge factor here for final descale. */
/* c2-c6 */
/* c2+c6 */
/* Final output stage */
/* Pass 2: process 4 rows from work array, store into output array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* Odd part */
/* Same rotation as in the even part of the 8x8 LL&M IDCT */
/* c6 */
/* c2-c6 */
/* c2+c6 */
/* Final output stage */
/* advance pointer to next row */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* c2 */
/* Odd part */
/* c1 */
/* Final output stage */
/* Pass 2: process 3 rows from work array, store into output array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* c2 */
/* Odd part */
/* c1 */
/* Final output stage */
/* advance pointer to next row */
/*
/* Pass 1: process columns from input. */
/* Column 0 */
/* Add fudge factor here for final descale. */
/* Column 1 */
/* Pass 2: process 2 rows, store into output array. */
/* Row 0 */
/* Row 1 */
/*
/* 1x1 is trivial: just take the DC coefficient divided by 8. */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* c6 */
/* c6 */
/* c2 */
/* c4 */
/* c8 */
/* Odd part */
/* -c3 */
/* c5 */
/* c7 */
/* c1 */
/* c3 */
/* Final output stage */
/* Pass 2: process 9 rows from work array, store into output array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* c6 */
/* c6 */
/* c2 */
/* c4 */
/* c8 */
/* Odd part */
/* -c3 */
/* c5 */
/* c7 */
/* c1 */
/* c3 */
/* Final output stage */
/* advance pointer to next row */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* c4 */
/* c8 */
/* c0 = (c4-c8)*2 */
/* c6 */
/* c2-c6 */
/* c2+c6 */
/* Odd part */
/* (c3-c7)/2 */
/* (c3+c7)/2 */
/* c1 */
/* c9 */
/* (c1-c9)/2 */
/* c3 */
/* c7 */
/* Final output stage */
/* Pass 2: process 10 rows from work array, store into output array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* c4 */
/* c8 */
/* c0 = (c4-c8)*2 */
/* c6 */
/* c2-c6 */
/* c2+c6 */
/* Odd part */
/* (c3-c7)/2 */
/* (c3+c7)/2 */
/* c1 */
/* c9 */
/* (c1-c9)/2 */
/* c3 */
/* c7 */
/* Final output stage */
/* advance pointer to next row */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* c2+c4 */
/* c2-c6 */
/* -(c2-c10) */
/* c2 */
/* c2+c4+c10-c6 */
/* c4+c6 */
/* c6+c8 */
/* c8+c10 */
/* c2+c8 */
/* c4+c10 */
/* c0 */
/* Odd part */
/* c9 */
/* c3-c9 */
/* c5-c9 */
/* c7-c9 */
/* c7+c5+c3-c1-2*c9 */
/* c7+c9 */
/* c1+c7+3*c9-c3 */
/* c3+c5-c7-c9 */
/* -(c1+c9) */
/* c1+c5+c9-c7 */
/* -(c5+c9) */
/* c1-c9 */
/* c3+c9 */
/* Final output stage */
/* Pass 2: process 11 rows from work array, store into output array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* c2+c4 */
/* c2-c6 */
/* -(c2-c10) */
/* c2 */
/* c2+c4+c10-c6 */
/* c4+c6 */
/* c6+c8 */
/* c8+c10 */
/* c2+c8 */
/* c4+c10 */
/* c0 */
/* Odd part */
/* c9 */
/* c3-c9 */
/* c5-c9 */
/* c7-c9 */
/* c7+c5+c3-c1-2*c9 */
/* c7+c9 */
/* c1+c7+3*c9-c3 */
/* c3+c5-c7-c9 */
/* -(c1+c9) */
/* c1+c5+c9-c7 */
/* -(c5+c9) */
/* c1-c9 */
/* c3+c9 */
/* Final output stage */
/* advance pointer to next row */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* c4 */
/* c2 */
/* Odd part */
/* c3 */
/* -c9 */
/* c7 */
/* c5-c7 */
/* c1-c5 */
/* -(c7+c11) */
/* c1+c5-c7-c11 */
/* c1+c11 */
/* c7-c11 */
/* c5+c7 */
/* c9 */
/* c3-c9 */
/* c3+c9 */
/* Final output stage */
/* Pass 2: process 12 rows from work array, store into output array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* c4 */
/* c2 */
/* Odd part */
/* c3 */
/* -c9 */
/* c7 */
/* c5-c7 */
/* c1-c5 */
/* -(c7+c11) */
/* c1+c5-c7-c11 */
/* c1+c11 */
/* c7-c11 */
/* c5+c7 */
/* c9 */
/* c3-c9 */
/* c3+c9 */
/* Final output stage */
/* advance pointer to next row */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* (c4+c6)/2 */
/* (c4-c6)/2 */
/* c2 */
/* c10 */
/* (c8-c12)/2 */
/* (c8+c12)/2 */
/* c6 */
/* c4 */
/* (c2-c10)/2 */
/* (c2+c10)/2 */
/* c12 */
/* c8 */
/* c0 */
/* Odd part */
/* c3 */
/* c5 */
/* c7 */
/* c7+c5+c3-c1 */
/* -c11 */
/* c5+c9+c11-c3 */
/* c1+c5-c9-c11 */
/* -c5 */
/* c3+c5+c9-c7 */
/* -c9 */
/* c11 */
/* c9-c11 */
/* c1-c7 */
/* c7 */
/* c3-c7 */
/* c1+c11 */
/* Final output stage */
/* Pass 2: process 13 rows from work array, store into output array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* (c4+c6)/2 */
/* (c4-c6)/2 */
/* c2 */
/* c10 */
/* (c8-c12)/2 */
/* (c8+c12)/2 */
/* c6 */
/* c4 */
/* (c2-c10)/2 */
/* (c2+c10)/2 */
/* c12 */
/* c8 */
/* c0 */
/* Odd part */
/* c3 */
/* c5 */
/* c7 */
/* c7+c5+c3-c1 */
/* -c11 */
/* c5+c9+c11-c3 */
/* c1+c5-c9-c11 */
/* -c5 */
/* c3+c5+c9-c7 */
/* -c9 */
/* c11 */
/* c9-c11 */
/* c1-c7 */
/* c7 */
/* c3-c7 */
/* c1+c11 */
/* Final output stage */
/* advance pointer to next row */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* c4 */
/* c12 */
/* c8 */
/* c0 = (c4+c12-c8)*2 */
/* c6 */
/* c2-c6 */
/* c6+c10 */
/* c10 */
/* c2 */
/* Odd part */
/* c3 */
/* c5 */
/* c3+c5-c1 */
/* c9 */
/* c9+c11-c13 */
/* c11 */
/* -c13 */
/* c3-c9-c13 */
/* c3+c5-c13 */
/* c1 */
/* c1+c9-c11 */
/* c1+c11-c5 */
/* Final output stage */
/* Pass 2: process 14 rows from work array, store into output array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* c4 */
/* c12 */
/* c8 */
/* c0 = (c4+c12-c8)*2 */
/* c6 */
/* c2-c6 */
/* c6+c10 */
/* c10 */
/* c2 */
/* Odd part */
/* c3 */
/* c5 */
/* c3+c5-c1 */
/* c9 */
/* c9+c11-c13 */
/* c11 */
/* -c13 */
/* c3-c9-c13 */
/* c3+c5-c13 */
/* c1 */
/* c1+c9-c11 */
/* c1+c11-c5 */
/* Final output stage */
/* advance pointer to next row */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* c12 */
/* c6 */
/* c0 = (c6-c12)*2 */
/* (c2+c4)/2 */
/* (c2-c4)/2 */
/* c4+c14 */
/* (c8+c14)/2 */
/* (c8-c14)/2 */
/* (c6+c12)/2 */
/* (c6-c12)/2 */
/* c10 = c6-c12 */
/* c0 = (c6-c12)*2 */
/* Odd part */
/* c5 */
/* c9 */
/* c3-c9 */
/* c3+c9 */
/* -c9 */
/* -c3 */
/* c1 */
/* c1+c7 */
/* c1-c13 */
/* c5 */
/* c11 */
/* c7-c11 */
/* c11+c13 */
/* Final output stage */
/* Pass 2: process 15 rows from work array, store into output array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* c12 */
/* c6 */
/* c0 = (c6-c12)*2 */
/* (c2+c4)/2 */
/* (c2-c4)/2 */
/* c4+c14 */
/* (c8+c14)/2 */
/* (c8-c14)/2 */
/* (c6+c12)/2 */
/* (c6-c12)/2 */
/* c10 = c6-c12 */
/* c0 = (c6-c12)*2 */
/* Odd part */
/* c5 */
/* c9 */
/* c3-c9 */
/* c3+c9 */
/* -c9 */
/* -c3 */
/* c1 */
/* c1+c7 */
/* c1-c13 */
/* c5 */
/* c11 */
/* c7-c11 */
/* c11+c13 */
/* Final output stage */
/* advance pointer to next row */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* c4[16] = c2[8] */
/* c12[16] = c6[8] */
/* c14[16] = c7[8] */
/* c2[16] = c1[8] */
/* (c6+c2)[16] = (c3+c1)[8] */
/* (c6-c14)[16] = (c3-c7)[8] */
/* (c2-c10)[16] = (c1-c5)[8] */
/* (c10-c14)[16] = (c5-c7)[8] */
/* Odd part */
/* c3 */
/* c5 */
/* c7 */
/* c9 */
/* c11 */
/* c13 */
/* c7+c5+c3-c1 */
/* c9+c11+c13-c15 */
/* c15 */
/* c9+c11-c3-c15 */
/* c5+c7+c15-c3 */
/* c1 */
/* c1+c11-c9-c13 */
/* c1+c5+c13-c7 */
/* -c11 */
/* c3+c11+c15-c7 */
/* -c5 */
/* c1+c5+c9-c13 */
/* -c3 */
/* c13 */
/* Final output stage */
/* Pass 2: process 16 rows from work array, store into output array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* c4[16] = c2[8] */
/* c12[16] = c6[8] */
/* c14[16] = c7[8] */
/* c2[16] = c1[8] */
/* (c6+c2)[16] = (c3+c1)[8] */
/* (c6-c14)[16] = (c3-c7)[8] */
/* (c2-c10)[16] = (c1-c5)[8] */
/* (c10-c14)[16] = (c5-c7)[8] */
/* Odd part */
/* c3 */
/* c5 */
/* c7 */
/* c9 */
/* c11 */
/* c13 */
/* c7+c5+c3-c1 */
/* c9+c11+c13-c15 */
/* c15 */
/* c9+c11-c3-c15 */
/* c5+c7+c15-c3 */
/* c1 */
/* c1+c11-c9-c13 */
/* c1+c5+c13-c7 */
/* -c11 */
/* c3+c11+c15-c7 */
/* -c5 */
/* c1+c5+c9-c13 */
/* -c3 */
/* c13 */
/* Final output stage */
/* advance pointer to next row */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array. */
/* Note results are scaled up by sqrt(8) compared to a true IDCT; */
/* furthermore, we scale the results by 2**PASS1_BITS. */
/* Due to quantization, we will usually find that many of the input
/* AC terms all zero */
/* advance pointers to next column */
/* Even part: reverse the even part of the forward DCT. */
/* The rotator is sqrt(2)*c(-6). */
/* Add fudge factor here for final descale. */
/* Odd part per figure 8; the matrix is unitary and hence its
/* sqrt(2) * c3 */
/* sqrt(2) * (-c3-c5) */
/* sqrt(2) * (c5-c3) */
/* sqrt(2) * (c7-c3) */
/* sqrt(2) * (-c1+c3+c5-c7) */
/* sqrt(2) * ( c1+c3-c5-c7) */
/* sqrt(2) * (-c1-c3) */
/* sqrt(2) * ( c1+c3-c5+c7) */
/* sqrt(2) * ( c1+c3+c5-c7) */
/* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
/* advance pointers to next column */
/* Pass 2: process 8 rows from work array, store into output array.
/* Even part */
/* Add fudge factor here for final descale. */
/* c4[16] = c2[8] */
/* c12[16] = c6[8] */
/* c14[16] = c7[8] */
/* c2[16] = c1[8] */
/* (c6+c2)[16] = (c3+c1)[8] */
/* (c6-c14)[16] = (c3-c7)[8] */
/* (c2-c10)[16] = (c1-c5)[8] */
/* (c10-c14)[16] = (c5-c7)[8] */
/* Odd part */
/* c3 */
/* c5 */
/* c7 */
/* c9 */
/* c11 */
/* c13 */
/* c7+c5+c3-c1 */
/* c9+c11+c13-c15 */
/* c15 */
/* c9+c11-c3-c15 */
/* c5+c7+c15-c3 */
/* c1 */
/* c1+c11-c9-c13 */
/* c1+c5+c13-c7 */
/* -c11 */
/* c3+c11+c15-c7 */
/* -c5 */
/* c1+c5+c9-c13 */
/* -c3 */
/* c13 */
/* Final output stage */
/* advance pointer to next row */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array.
/* Even part */
/* Add fudge factor here for final descale. */
/* c4 */
/* c6 */
/* c2+c4-c6 */
/* c2 */
/* c2-c4-c6 */
/* c2+c4+c6 */
/* c0 */
/* Odd part */
/* (c3+c1-c5)/2 */
/* (c3+c5-c1)/2 */
/* -c1 */
/* c5 */
/* c3+c1-c5 */
/* Final output stage */
/* Pass 2: process 7 rows from work array, store into output array.
/* Even part */
/* Add fudge factor here for final descale. */
/* c4 */
/* c12 */
/* c8 */
/* c0 = (c4+c12-c8)*2 */
/* c6 */
/* c2-c6 */
/* c6+c10 */
/* c10 */
/* c2 */
/* Odd part */
/* c3 */
/* c5 */
/* c3+c5-c1 */
/* c9 */
/* c9+c11-c13 */
/* c11 */
/* -c13 */
/* c3-c9-c13 */
/* c3+c5-c13 */
/* c1 */
/* c1+c9-c11 */
/* c1+c11-c5 */
/* Final output stage */
/* advance pointer to next row */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array.
/* Even part */
/* Add fudge factor here for final descale. */
/* c4 */
/* c2 */
/* Odd part */
/* c5 */
/* Final output stage */
/* Pass 2: process 6 rows from work array, store into output array.
/* Even part */
/* Add fudge factor here for final descale. */
/* c4 */
/* c2 */
/* Odd part */
/* c3 */
/* -c9 */
/* c7 */
/* c5-c7 */
/* c1-c5 */
/* -(c7+c11) */
/* c1+c5-c7-c11 */
/* c1+c11 */
/* c7-c11 */
/* c5+c7 */
/* c9 */
/* c3-c9 */
/* c3+c9 */
/* Final output stage */
/* advance pointer to next row */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array.
/* Even part */
/* Add fudge factor here for final descale. */
/* (c2+c4)/2 */
/* (c2-c4)/2 */
/* Odd part */
/* c3 */
/* c1-c3 */
/* c1+c3 */
/* Final output stage */
/* Pass 2: process 5 rows from work array, store into output array.
/* Even part */
/* Add fudge factor here for final descale. */
/* c4 */
/* c8 */
/* c0 = (c4-c8)*2 */
/* c6 */
/* c2-c6 */
/* c2+c6 */
/* Odd part */
/* (c3-c7)/2 */
/* (c3+c7)/2 */
/* c1 */
/* c9 */
/* (c1-c9)/2 */
/* c3 */
/* c7 */
/* Final output stage */
/* advance pointer to next row */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array.
/* Even part */
/* Odd part */
/* Same rotation as in the even part of the 8x8 LL&M IDCT */
/* c6 */
/* Add fudge factor here for final descale. */
/* c2-c6 */
/* c2+c6 */
/* Final output stage */
/* Pass 2: process rows from work array, store into output array. */
/* Note that we must descale the results by a factor of 8 == 2**3, */
/* and also undo the PASS1_BITS scaling. */
/* Even part: reverse the even part of the forward DCT. */
/* The rotator is sqrt(2)*c(-6). */
/* Add fudge factor here for final descale. */
/* Odd part per figure 8; the matrix is unitary and hence its
/* sqrt(2) * c3 */
/* sqrt(2) * (-c3-c5) */
/* sqrt(2) * (c5-c3) */
/* sqrt(2) * (c7-c3) */
/* sqrt(2) * (-c1+c3+c5-c7) */
/* sqrt(2) * ( c1+c3-c5-c7) */
/* sqrt(2) * (-c1-c3) */
/* sqrt(2) * ( c1+c3-c5+c7) */
/* sqrt(2) * ( c1+c3+c5-c7) */
/* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
/* advance pointer to next row */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array.
/* Even part */
/* Add fudge factor here for final descale. */
/* c2 */
/* Odd part */
/* c1 */
/* Final output stage */
/* Pass 2: process 3 rows from work array, store into output array.
/* Even part */
/* Add fudge factor here for final descale. */
/* c4 */
/* c2 */
/* Odd part */
/* c5 */
/* Final output stage */
/* advance pointer to next row */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array. */
/* Even part */
/* Odd part */
/* Final output stage */
/* Pass 2: process 2 rows from work array, store into output array.
/* Even part */
/* Add fudge factor here for final descale. */
/* Odd part */
/* Same rotation as in the even part of the 8x8 LL&M IDCT */
/* c6 */
/* c2-c6 */
/* c2+c6 */
/* Final output stage */
/* advance pointer to next row */
/*
/* Pass 1: empty. */
/* Pass 2: process 1 row from input, store into output array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* Odd part */
/* Final output stage */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array.
/* Even part */
/* Add fudge factor here for final descale. */
/* c4[16] = c2[8] */
/* c12[16] = c6[8] */
/* c14[16] = c7[8] */
/* c2[16] = c1[8] */
/* (c6+c2)[16] = (c3+c1)[8] */
/* (c6-c14)[16] = (c3-c7)[8] */
/* (c2-c10)[16] = (c1-c5)[8] */
/* (c10-c14)[16] = (c5-c7)[8] */
/* Odd part */
/* c3 */
/* c5 */
/* c7 */
/* c9 */
/* c11 */
/* c13 */
/* c7+c5+c3-c1 */
/* c9+c11+c13-c15 */
/* c15 */
/* c9+c11-c3-c15 */
/* c5+c7+c15-c3 */
/* c1 */
/* c1+c11-c9-c13 */
/* c1+c5+c13-c7 */
/* -c11 */
/* c3+c11+c15-c7 */
/* -c5 */
/* c1+c5+c9-c13 */
/* -c3 */
/* c13 */
/* Final output stage */
/* Pass 2: process rows from work array, store into output array. */
/* Note that we must descale the results by a factor of 8 == 2**3, */
/* and also undo the PASS1_BITS scaling. */
/* Even part: reverse the even part of the forward DCT. */
/* The rotator is sqrt(2)*c(-6). */
/* Add fudge factor here for final descale. */
/* Odd part per figure 8; the matrix is unitary and hence its
/* sqrt(2) * c3 */
/* sqrt(2) * (-c3-c5) */
/* sqrt(2) * (c5-c3) */
/* sqrt(2) * (c7-c3) */
/* sqrt(2) * (-c1+c3+c5-c7) */
/* sqrt(2) * ( c1+c3-c5-c7) */
/* sqrt(2) * (-c1-c3) */
/* sqrt(2) * ( c1+c3-c5+c7) */
/* sqrt(2) * ( c1+c3+c5-c7) */
/* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
/* advance pointer to next row */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array.
/* Even part */
/* Add fudge factor here for final descale. */
/* c4 */
/* c12 */
/* c8 */
/* c0 = (c4+c12-c8)*2 */
/* c6 */
/* c2-c6 */
/* c6+c10 */
/* c10 */
/* c2 */
/* Odd part */
/* c3 */
/* c5 */
/* c3+c5-c1 */
/* c9 */
/* c9+c11-c13 */
/* c11 */
/* -c13 */
/* c3-c9-c13 */
/* c3+c5-c13 */
/* c1 */
/* c1+c9-c11 */
/* c1+c11-c5 */
/* Final output stage */
/* Pass 2: process 14 rows from work array, store into output array.
/* Even part */
/* Add fudge factor here for final descale. */
/* c4 */
/* c6 */
/* c2+c4-c6 */
/* c2 */
/* c2-c4-c6 */
/* c2+c4+c6 */
/* c0 */
/* Odd part */
/* (c3+c1-c5)/2 */
/* (c3+c5-c1)/2 */
/* -c1 */
/* c5 */
/* c3+c1-c5 */
/* Final output stage */
/* advance pointer to next row */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array.
/* Even part */
/* Add fudge factor here for final descale. */
/* c4 */
/* c2 */
/* Odd part */
/* c3 */
/* -c9 */
/* c7 */
/* c5-c7 */
/* c1-c5 */
/* -(c7+c11) */
/* c1+c5-c7-c11 */
/* c1+c11 */
/* c7-c11 */
/* c5+c7 */
/* c9 */
/* c3-c9 */
/* c3+c9 */
/* Final output stage */
/* Pass 2: process 12 rows from work array, store into output array.
/* Even part */
/* Add fudge factor here for final descale. */
/* c4 */
/* c2 */
/* Odd part */
/* c5 */
/* Final output stage */
/* advance pointer to next row */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array.
/* Even part */
/* Add fudge factor here for final descale. */
/* c4 */
/* c8 */
/* c0 = (c4-c8)*2 */
/* c6 */
/* c2-c6 */
/* c2+c6 */
/* Odd part */
/* (c3-c7)/2 */
/* (c3+c7)/2 */
/* c1 */
/* c9 */
/* (c1-c9)/2 */
/* c3 */
/* c7 */
/* Final output stage */
/* Pass 2: process 10 rows from work array, store into output array.
/* Even part */
/* Add fudge factor here for final descale. */
/* (c2+c4)/2 */
/* (c2-c4)/2 */
/* Odd part */
/* c3 */
/* c1-c3 */
/* c1+c3 */
/* Final output stage */
/* advance pointer to next row */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array. */
/* Note results are scaled up by sqrt(8) compared to a true IDCT; */
/* furthermore, we scale the results by 2**PASS1_BITS. */
/* Due to quantization, we will usually find that many of the input
/* AC terms all zero */
/* advance pointers to next column */
/* Even part: reverse the even part of the forward DCT. */
/* The rotator is sqrt(2)*c(-6). */
/* Add fudge factor here for final descale. */
/* Odd part per figure 8; the matrix is unitary and hence its
/* sqrt(2) * c3 */
/* sqrt(2) * (-c3-c5) */
/* sqrt(2) * (c5-c3) */
/* sqrt(2) * (c7-c3) */
/* sqrt(2) * (-c1+c3+c5-c7) */
/* sqrt(2) * ( c1+c3-c5-c7) */
/* sqrt(2) * (-c1-c3) */
/* sqrt(2) * ( c1+c3-c5+c7) */
/* sqrt(2) * ( c1+c3+c5-c7) */
/* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
/* advance pointers to next column */
/* Pass 2: process 8 rows from work array, store into output array.
/* Even part */
/* Add fudge factor here for final descale. */
/* Odd part */
/* Same rotation as in the even part of the 8x8 LL&M IDCT */
/* c6 */
/* c2-c6 */
/* c2+c6 */
/* Final output stage */
/* advance pointer to next row */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array.
/* Even part */
/* Add fudge factor here for final descale. */
/* c4 */
/* c2 */
/* Odd part */
/* c5 */
/* Final output stage */
/* Pass 2: process 6 rows from work array, store into output array.
/* Even part */
/* Add fudge factor here for final descale. */
/* c2 */
/* Odd part */
/* c1 */
/* Final output stage */
/* advance pointer to next row */
/*
/* buffers data between passes */
/* Pass 1: process columns from input, store into work array.
/* Even part */
/* Odd part */
/* Same rotation as in the even part of the 8x8 LL&M IDCT */
/* c6 */
/* c2-c6 */
/* c2+c6 */
/* Final output stage */
/* Pass 2: process 4 rows from work array, store into output array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* Odd part */
/* Final output stage */
/* advance pointer to next row */
/*
/* Process 1 column from input, store into output array. */
/* Even part */
/* Add fudge factor here for final descale. */
/* Odd part */
/* Final output stage */
/* IDCT_SCALING_SUPPORTED */
/* DCT_ISLOW_SUPPORTED */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jmemmgr.c
/*
/* we define jvirt_Xarray_control structs */
/* import the system-dependent declarations */
/* <stdlib.h> should declare getenv() */
/*
/*
/* so can override from jconfig.h */
/*
/* next in list of pools */
/* how many bytes already used within pool */
/* bytes still available in this pool */
/* included in union to ensure alignment */
/* next in list of pools */
/* how many bytes already used within pool */
/* bytes still available in this pool */
/* included in union to ensure alignment */
/*
/* public fields */
/* Each pool identifier (lifetime class) names a linked list of pools. */
/* Since we only have one lifetime class of virtual arrays, only one
/* This counts total space obtained from jpeg_get_small/large */
/* alloc_sarray and alloc_barray set this value for use by virtual
/* from most recent alloc_sarray/barray */
/*
/* => the in-memory buffer */
/* total virtual array height */
/* width of array (and of memory buffer) */
/* max rows accessed by access_virt_sarray */
/* height of memory buffer */
/* allocation chunk size in mem_buffer */
/* first logical row # in the buffer */
/* row # of first uninitialized row */
/* pre-zero mode requested? */
/* do current buffer contents need written? */
/* is backing-store data valid? */
/* link to next virtual sarray control block */
/* System-dependent control info */
/* => the in-memory buffer */
/* total virtual array height */
/* width of array (and of memory buffer) */
/* max rows accessed by access_virt_barray */
/* height of memory buffer */
/* allocation chunk size in mem_buffer */
/* first logical row # in the buffer */
/* row # of first uninitialized row */
/* pre-zero mode requested? */
/* do current buffer contents need written? */
/* is backing-store data valid? */
/* link to next virtual barray control block */
/* System-dependent control info */
/* optional extra stuff for statistics */
/* Since this is only a debugging stub, we can cheat a little by using
/* MEM_STATS */
/* Report an out-of-memory error and stop execution */
/* If we compiled MEM_STATS support, report alloc requests before dying */
/* force self_destruct to report stats */
/*
/* first PERMANENT pool */
/* first IMAGE pool */
/* additional PERMANENT pools */
/* additional IMAGE pools */
/* greater than 0 to avoid futile looping */
/* Allocate a "small" object */
/* Check for unsatisfiable request (do now to ensure no overflow below) */
/* request exceeds malloc's ability */
/* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
/* See if space is available in any existing pool */
/* safety check */
/* found pool with enough space */
/* Time to make a new pool? */
/* min_request is what we need now, slop is what will be leftover */
/* first pool in class? */
/* Don't ask for more than MAX_ALLOC_CHUNK */
/* Try to get space, if fail reduce slop and try again */
/* give up when it gets real small */
/* jpeg_get_small failed */
/* Success, initialize the new pool header and add to end of list */
/* first pool in class? */
/* OK, allocate the object from the current pool */
/* point to first data byte in pool */
/* point to place for object */
/*
/* Allocate a "large" object */
/* Check for unsatisfiable request (do now to ensure no overflow below) */
/* request exceeds malloc's ability */
/* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
/* Always make a new pool */
/* safety check */
/* jpeg_get_large failed */
/* Success, initialize the new pool header and add to list */
/* We maintain space counts in each pool header for statistical purposes,
/* point to first data byte in pool */
/*
/* Allocate a 2-D sample array */
/* Calculate max # of rows allowed in one allocation chunk */
/* Get space for row pointers (small object) */
/* Get the rows themselves (large objects) */
/*
/* Allocate a 2-D coefficient-block array */
/* Calculate max # of rows allowed in one allocation chunk */
/* Get space for row pointers (small object) */
/* Get the rows themselves (large objects) */
/*
/* Request a virtual 2-D sample array */
/* Only IMAGE-lifetime virtual arrays are currently supported */
/* safety check */
/* get control block */
/* marks array not yet realized */
/* no associated backing-store object */
/* add to list of virtual arrays */
/* Request a virtual 2-D coefficient-block array */
/* Only IMAGE-lifetime virtual arrays are currently supported */
/* safety check */
/* get control block */
/* marks array not yet realized */
/* no associated backing-store object */
/* add to list of virtual arrays */
/* Allocate the in-memory buffers for any unrealized virtual arrays */
/* Compute the minimum space needed (maxaccess rows in each buffer)
/* if not realized yet */
/* if not realized yet */
/* no unrealized arrays, no work */
/* Determine amount of memory to actually use; this is system-dependent. */
/* If the maximum space needed is available, make all the buffers full
/* If there doesn't seem to be enough space, try to get the minimum
/* Allocate the in-memory buffers and initialize backing store as needed. */
/* if not realized yet */
/* This buffer fits in memory */
/* It doesn't fit in memory, create backing store. */
/* if not realized yet */
/* This buffer fits in memory */
/* It doesn't fit in memory, create backing store. */
/* Do backing store read or write of a virtual sample array */
/* Loop to read or write each allocation chunk in mem_buffer */
/* One chunk, but check for short chunk at end of buffer */
/* Transfer no more than is currently defined */
/* Transfer no more than fits in file */
/* this chunk might be past end of file! */
/* Do backing store read or write of a virtual coefficient-block array */
/* Loop to read or write each allocation chunk in mem_buffer */
/* One chunk, but check for short chunk at end of buffer */
/* Transfer no more than is currently defined */
/* Transfer no more than fits in file */
/* this chunk might be past end of file! */
/* Access the part of a virtual sample array starting at start_row */
/* and extending for num_rows rows.  writable is true if  */
/* caller intends to modify the accessed area. */
/* debugging check */
/* Make the desired part of the virtual array accessible */
/* Flush old buffer contents if necessary */
/* Decide what part of virtual array to access.
/* use long arithmetic here to avoid overflow & unsigned problems */
/* don't fall off front end of file */
/* Read in the selected part of the array.
/* Ensure the accessed part of the array is defined; prezero if needed.
/* writer skipped over a section of array */
/* but reader is allowed to read ahead */
/* make indexes relative to buffer */
/* reader looking at undefined data */
/* Flag the buffer dirty if caller will write in it */
/* Return address of proper part of the buffer */
/* Access the part of a virtual block array starting at start_row */
/* and extending for num_rows rows.  writable is true if  */
/* caller intends to modify the accessed area. */
/* debugging check */
/* Make the desired part of the virtual array accessible */
/* Flush old buffer contents if necessary */
/* Decide what part of virtual array to access.
/* use long arithmetic here to avoid overflow & unsigned problems */
/* don't fall off front end of file */
/* Read in the selected part of the array.
/* Ensure the accessed part of the array is defined; prezero if needed.
/* writer skipped over a section of array */
/* but reader is allowed to read ahead */
/* make indexes relative to buffer */
/* reader looking at undefined data */
/* Flag the buffer dirty if caller will write in it */
/* Return address of proper part of the buffer */
/*
/* safety check */
/* print pool's memory usage statistics */
/* If freeing IMAGE pool, close any virtual arrays first */
/* there may be no backing store */
/* prevent recursive close if error */
/* there may be no backing store */
/* prevent recursive close if error */
/* Release large objects */
/* Release small objects */
/*
/* Close all backing store, release all memory.
/* Release the memory manager control block too. */
/* ensures I will be called only once */
/* system-dependent cleanup */
/*
/* for safety if init fails */
/* Check for configuration errors.
/* MAX_ALLOC_CHUNK must be representable as type size_t, and must be
/* system-dependent initialization */
/* Attempt to allocate memory manager's control block */
/* system-dependent cleanup */
/* OK, fill in the method pointers */
/* Make MAX_ALLOC_CHUNK accessible to other modules */
/* Initialize working state */
/* Declare ourselves open for business */
/* Check for an environment variable JPEGMEM; if found, override the
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jmemnobs.c
/*
/* import the system-dependent declarations */
/* <stdlib.h> should declare malloc(),free() */
/*
/*
/*
/*
/*
/* just set max_memory_to_use to 0 */
/* no work */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jquant1.c
/*
/*
/* Declarations for ordered dithering.
/* dimension of dither matrix */
/* NB: if ODITHER_SIZE is not a power of 2, ODITHER_MASK uses will break */
/* # cells in matrix */
/* mask for wrapping around counters */
/* Bayer's order-4 dither array.  Generated by the code given in
/* Declarations for Floyd-Steinberg dithering.
/* 16 bits should be enough */
/* use 'int' for calculation temps */
/* may need more than 16 bits */
/* be sure calculation temps are big enough */
/* pointer to error array (in FAR storage!) */
/* Private subobject */
/* max components I can handle */
/* public fields */
/* Initially allocated colormap is saved here */
/* The color map as a 2-D pixel array */
/* number of entries in use */
/* Precomputed mapping for speed */
/* colorindex[i][j] = index of color closest to pixel value j in component i,
/* is the colorindex padded for odither? */
/* # of values alloced to each component */
/* Variables for ordered dithering */
/* cur row's vertical index in dither matrix */
/* one dither array per component */
/* Variables for Floyd-Steinberg dithering */
/* accumulated errors */
/* flag to remember which row we are on */
/*
/* Determine allocation of desired colors to components, */
/* and fill in Ncolors[] array to indicate choice. */
/* Return value is total number of colors (product of Ncolors[] values). */
/* number of color components */
/* We can allocate at least the nc'th root of max_colors per component. */
/* Compute floor(nc'th root of max_colors). */
/* set temp = iroot ** nc */
/* repeat till iroot exceeds root */
/* now iroot = floor(root) */
/* Must have at least 2 color values per component */
/* Initialize to iroot color values for each component */
/* We may be able to increment the count for one or more components without
/* calculate new total_colors if Ncolors[j] is incremented */
/* done in long arith to avoid oflo */
/* won't fit, done with this pass */
/* OK, apply the increment */
/* Return j'th output value, where j will range from 0 to maxj */
/* The output values must fall in 0..MAXJSAMPLE in increasing order */
/* We always provide values 0 and MAXJSAMPLE for each component;
/* Return largest input value that should map to j'th output value */
/* Must have largest(j=0) >= 0, and largest(j=maxj) >= MAXJSAMPLE */
/* Breakpoints are halfway between values returned by output_value */
/*
/* Created colormap */
/* Number of distinct output colors */
/* Select number of colors for each component */
/* Report selected color counts */
/* Allocate and fill in the colormap. */
/* The colors are ordered in the map in standard row-major order, */
/* i.e. rightmost (highest-indexed) color changes most rapidly. */
/* blksize is number of adjacent repeated entries for a component */
/* blkdist is distance between groups of identical entries for a component */
/* fill in colormap entries for i'th color component */
/* # of distinct values for this color */
/* Compute j'th output value (out of nci) for component */
/* Fill in all colormap entries that have this value of this component */
/* fill in blksize entries beginning at ptr */
/* blksize of this color is blkdist of next */
/* Save the colormap in private storage,
/*
/* For ordered dither, we pad the color index tables by MAXJSAMPLE in
/* blksize is number of adjacent repeated entries for a component */
/* fill in colorindex entries for i'th color component */
/* # of distinct values for this color */
/* adjust colorindex pointers to provide padding at negative indexes. */
/* in loop, val = index of current output value, */
/* and k = largest j that maps to current val */
/* advance val if past boundary */
/* premultiply so that no multiplication needed in main processing */
/* Pad at both ends if necessary */
/*
/* The inter-value distance for this color is MAXJSAMPLE/(ncolors-1).
/* Ensure round towards zero despite C's lack of consistency
/*
/* # of distinct values for this color */
/* search for matching prior component */
/* need a new table? */
/*
/* General case, no dithering */
/* Fast path for out_color_components==3, no dithering */
/* General case, with ordered dithering */
/* points to active row of dither matrix */
/* current indexes into dither matrix */
/* Initialize output values to 0 so can process components separately */
/* Form pixel value + dither, range-limit to 0..MAXJSAMPLE,
/* Advance row index for next row */
/* Fast path for out_color_components==3, with ordered dithering */
/* points to active row of dither matrix */
/* current indexes into dither matrix */
/* General case, with Floyd-Steinberg dithering */
/* current error or pixel value */
/* error for pixel below cur */
/* error for below/prev col */
/* error for below/next col */
/* => fserrors[] at column before current */
/* 1 for left-to-right, -1 for right-to-left */
/* dir * nc */
/* Initialize output values to 0 so can process components separately */
/* work right to left in this row */
/* so point to rightmost pixel */
/* => entry after last column */
/* work left to right in this row */
/* => entry before first column */
/* Preset error values: no error propagated to first pixel from left */
/* and no error propagated to row below yet */
/* cur holds the error propagated from the previous pixel on the
/* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
/* Select output value, accumulate into output code for this pixel */
/* Compute actual representation error at this pixel */
/* Note: we can do this even though we don't have the final */
/* pixel code, because the colormap is orthogonal. */
/* Compute error fractions to be propagated to adjacent pixels.
/* form error * 3 */
/* form error * 5 */
/* form error * 7 */
/* At this point cur contains the 7/16 error value to be propagated
/* advance input ptr to next column */
/* advance output ptr to next column */
/* advance errorptr to current column */
/* Post-loop cleanup: we must unload the final error value into the
/* unload prev err into array */
/*
/*
/* Install my colormap. */
/* Initialize for desired dithering mode. */
/* initialize state for ordered dither */
/* If user changed to ordered dither from another mode,
/* Create ordered-dither tables if we didn't already. */
/* initialize state for F-S dither */
/* Allocate Floyd-Steinberg workspace if didn't already. */
/* Initialize the propagated errors to zero. */
/*
/* no work in 1-pass case */
/*
/*
/* Flag FS workspace not allocated */
/* Also flag odither arrays not allocated */
/* Make sure my internal arrays won't overflow */
/* Make sure colormap indexes can be represented by JSAMPLEs */
/* Create the colormap and color index table. */
/* Allocate Floyd-Steinberg workspace now if requested.
/* QUANT_1PASS_SUPPORTED */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jquant2.c
/*
/*
/* scale R distances by this much */
/* scale G distances by this much */
/* and B by this much */
/* Relabel R/G/B as components 0/1/2, respecting the RGB ordering defined
/*
/* maximum size of colormap */
/* These will do the right thing for either R,G,B or B,G,R color order,
/* bits of precision in R/B histogram */
/* bits of precision in G histogram */
/* bits of precision in B/R histogram */
/* Number of elements along histogram axes. */
/* These are the amounts to shift an input value to get a histogram index. */
/* histogram cell; prefer an unsigned type */
/* for pointers to histogram cells */
/* typedefs for the array */
/* type for the 2nd-level pointers */
/* type for top-level pointer */
/* Declarations for Floyd-Steinberg dithering.
/* 16 bits should be enough */
/* use 'int' for calculation temps */
/* may need more than 16 bits */
/* be sure calculation temps are big enough */
/* pointer to error array (in FAR storage!) */
/* Private subobject */
/* public fields */
/* Space for the eventually created colormap is stashed here */
/* colormap allocated at init time */
/* desired # of colors = size of colormap */
/* Variables for accumulating image statistics */
/* pointer to the histogram */
/* TRUE if next pass must zero histogram */
/* Variables for Floyd-Steinberg dithering */
/* accumulated errors */
/* flag to remember which row we are on */
/* table for clamping the applied error */
/*
/* get pixel value and index into the histogram */
/* increment, check for overflow and undo increment if so. */
/*
/* The bounds of the box (inclusive); expressed as histogram indexes */
/* The volume (actually 2-norm) of the box */
/* The number of nonzero histogram cells within this box */
/* Find the splittable box with the largest color population */
/* Returns NULL if no splittable boxes remain */
/* Find the splittable box with the largest (scaled) volume */
/* Returns NULL if no splittable boxes remain */
/* Shrink the min/max bounds of a box to enclose only nonzero elements, */
/* and recompute its volume and population */
/* Update box volume.
/* Now scan remaining volume of box and compute population */
/* Repeatedly select and split the largest box until we have enough boxes */
/* Select box to split.
/* no splittable boxes left! */
/* where new box will go */
/* Copy the color bounds to the new box. */
/* Choose which axis to split the box on.
/* We want to break any ties in favor of green, then red, blue last.
/* Choose split point along selected axis, and update box bounds.
/* Update stats for boxes */
/* Compute representative color for a box, put it in colormap[icolor] */
/* Current algorithm: mean weighted by pixels (not colors) */
/* Note it is important to get the rounding correct! */
/* Master routine for color selection */
/* Allocate workspace for box list */
/* Initialize one box containing whole space */
/* Shrink it to actually-used volume and set its statistics */
/* Perform median-cut to produce final box list */
/* Compute the representative color for each box, fill colormap */
/*
/* log2(histogram cells in update box) for each axis; this can be adjusted */
/* # of hist cells in update box */
/*
/* Locate the colormap entries close enough to an update box to be candidates
/* min distance to colormap entry i */
/* Compute true coordinates of update box's upper corner and center.
/* For each color in colormap, find:
/* We compute the squared-c0-distance term, then add in the other two. */
/* within cell range so no contribution to min_dist */
/* within cell range so no contribution to min_dist */
/* within cell range so no contribution to min_dist */
/* save away the results */
/* Now we know that no cell in the update box is more than minmaxdist
/* Find the closest colormap entry for each cell in the update box,
/* pointer into bestdist[] array */
/* pointer into bestcolor[] array */
/* initial distance values */
/* current distance in inner loop */
/* distance increments */
/* initial values for increments */
/* This array holds the distance to the nearest-so-far color for each cell */
/* Initialize best-distance for each cell of the update box */
/* For each color selected by find_nearby_colors,
/* Nominal steps between cell centers ("x" in Thomas article) */
/* Compute (square of) distance from minc0/c1/c2 to this color */
/* Form the initial difference increments */
/* Now loop over all cells in box, updating distance per Thomas method */
/* Fill the inverse-colormap entries in the update box that contains */
/* histogram cell c0/c1/c2.  (Only that one cell MUST be filled, but */
/* we can fill as many others as we wish.) */
/* lower left corner of update box */
/* pointer into bestcolor[] array */
/* pointer into main cache array */
/* This array lists the candidate colormap indexes. */
/* number of candidate colors */
/* This array holds the actually closest colormap index for each cell. */
/* Convert cell coordinates to update box ID */
/* Compute true coordinates of update box's origin corner.
/* Determine which colormap entries are close enough to be candidates
/* Determine the actually nearest colors. */
/* Save the best color numbers (plus 1) in the main cache array */
/* convert ID back to base cell indexes */
/*
/* This version performs no dithering */
/* get pixel value and index into the cache */
/* If we have not seen this color before, find nearest colormap entry */
/* and update the cache */
/* Now emit the colormap index for this cell */
/* This version performs Floyd-Steinberg dithering */
/* current error or pixel value */
/* error for pixel below cur */
/* error for below/prev col */
/* => fserrors[] at column before current */
/* => current input pixel */
/* => current output pixel */
/* +1 or -1 depending on direction */
/* 3*dir, for advancing inptr & errorptr */
/* work right to left in this row */
/* so point to rightmost pixel */
/* => entry after last column */
/* flip for next time */
/* work left to right in this row */
/* => entry before first real column */
/* flip for next time */
/* Preset error values: no error propagated to first pixel from left */
/* and no error propagated to row below yet */
/* curN holds the error propagated from the previous pixel on the
/* Limit the error using transfer function set by init_error_limit.
/* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
/* Index into the cache with adjusted pixel value */
/* If we have not seen this color before, find nearest colormap */
/* entry and update the cache */
/* Now emit the colormap index for this cell */
/* Compute representation error for this pixel */
/* Compute error fractions to be propagated to adjacent pixels.
/* Process component 0 */
/* form error * 3 */
/* form error * 5 */
/* form error * 7 */
/* Process component 1 */
/* form error * 3 */
/* form error * 5 */
/* form error * 7 */
/* Process component 2 */
/* form error * 3 */
/* form error * 5 */
/* form error * 7 */
/* At this point curN contains the 7/16 error value to be propagated
/* Advance pixel pointers to next column */
/* advance errorptr to current column */
/* Post-loop cleanup: we must unload the final error values into the
/* unload prev errs into array */
/*
/* Allocate and fill in the error_limiter table */
/* so can index -MAXJSAMPLE .. +MAXJSAMPLE */
/* Map errors 1:1 up to +- MAXJSAMPLE/16 */
/* Map errors 1:2 up to +- 3*MAXJSAMPLE/16 */
/* Clamp the rest to final out value (which is (MAXJSAMPLE+1)/8) */
/*
/* Select the representative colors and fill in cinfo->colormap */
/* Force next pass to zero the color index table */
/* no work */
/*
/* Only F-S dithering or no dithering is supported. */
/* If user asks for ordered dither, give him F-S. */
/* Set up method pointers */
/* Always zero histogram */
/* Set up method pointers */
/* Make sure color count is acceptable */
/* Allocate Floyd-Steinberg workspace if we didn't already. */
/* Initialize the propagated errors to zero. */
/* Make the error-limit table if we didn't already. */
/* Zero the histogram or inverse color map, if necessary */
/*
/* Reset the inverse color map */
/*
/* flag optional arrays not allocated */
/* Make sure jdmaster didn't give me a case I can't handle */
/* Allocate the histogram/inverse colormap storage */
/* histogram is garbage now */
/* Allocate storage for the completed colormap, if required.
/* Make sure color count is acceptable */
/* Lower bound on # of colors ... somewhat arbitrary as long as > 0 */
/* Make sure colormap indexes can be represented by JSAMPLEs */
/* Only F-S dithering or no dithering is supported. */
/* If user asks for ordered dither, give him F-S. */
/* Allocate Floyd-Steinberg workspace if necessary.
/* Might as well create the error-limiting table too. */
/* QUANT_2PASS_SUPPORTED */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\jutils.c
/*
/*
/* This table is not actually needed in v6a */
/*
/* extra entries for safety in decoder */
/* extra entries for safety in decoder */
/* extra entries for safety in decoder */
/* extra entries for safety in decoder */
/* extra entries for safety in decoder */
/* extra entries for safety in decoder */
/* extra entries for safety in decoder */
/*
/* Compute a/b rounded up to next integer, ie, ceil(a/b) */
/* Assumes a >= 0, b > 0 */
/* Compute a rounded up to next multiple of b, ie, ceil(a/b)*b */
/* Assumes a >= 0, b > 0 */
/* On normal machines we can apply MEMCOPY() and MEMZERO() to sample arrays
/* normal case, same as regular macro */
/* 80x86 case, define if we can */
/* This function is for use by the FMEMZERO macro defined in jpegint.h.
/* Zero out a chunk of FAR memory. */
/* This might be sample-array data, block-array data, or alloc_large data. */
/* Copy some rows of samples from one place to another.
/* needn't bother with GETJSAMPLE() here */
/* Copy a row of coefficient blocks from one place to another. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libjpeg\transupp.c
/*
/* Although this file really shouldn't have access to the library internals,
/* My own external interface */
/* to declare isdigit() */
/*
/* Crop.  This is only used when no rotate/flip is requested with the crop. */
/* We simply have to copy the right amount of data (the destination's
/* Horizontal flip; done in-place, so no separate dest array is required.
/* Horizontal mirroring of DCT blocks is accomplished by swapping
/* Do the mirroring */
/* this unrolled loop doesn't need to know which row it's on... */
/* swap even column */
/* swap odd column with sign change */
/* Now left-justify the portion of the data to be kept.
/* Horizontal flip in general cropping case */
/* Here we must output into a separate array because we can't touch
/* Do the mirrorable blocks */
/* this unrolled loop doesn't need to know which row it's on... */
/* copy even column */
/* copy odd column with sign change */
/* Copy last partial block(s) verbatim */
/* Vertical flip */
/* We output into a separate array because we can't touch different
/* Row is within the mirrorable area. */
/* Bottom-edge blocks will be copied verbatim. */
/* Row is within the mirrorable area. */
/* copy even row */
/* copy odd row with sign change */
/* Just copy row verbatim. */
/* Transpose source into destination */
/* Transposing pixels within a block just requires transposing the
/* 90 degree rotation is equivalent to
/* Because of the horizontal mirror step, we can't process partial iMCUs
/* Block is within the mirrorable area. */
/* Edge blocks are transposed but not mirrored. */
/* Block is within the mirrorable area. */
/* Edge blocks are transposed but not mirrored. */
/* 270 degree rotation is equivalent to
/* Because of the horizontal mirror step, we can't process partial iMCUs
/* Block is within the mirrorable area. */
/* Edge blocks are transposed but not mirrored. */
/* 180 degree rotation is equivalent to
/* Row is within the vertically mirrorable area. */
/* Bottom-edge rows are only mirrored horizontally. */
/* Row is within the mirrorable area. */
/* Process the blocks that can be mirrored both ways. */
/* For even row, negate every odd column. */
/* For odd row, negate every even column. */
/* Any remaining right-edge blocks are only mirrored vertically. */
/* Remaining rows are just mirrored horizontally. */
/* Process the blocks that can be mirrored. */
/* Any remaining right-edge blocks are only copied. */
/* Transverse transpose is equivalent to
/* Block is within the mirrorable area. */
/* Block is within the mirrorable area. */
/* Right-edge blocks are mirrored in y only */
/* Bottom-edge blocks are mirrored in x only */
/* At lower right corner, just transpose, no mirroring */
/* Parse an unsigned integer: subroutine for jtransform_parse_crop_spec.
/* oops, no digits */
/* Parse a crop specification (written in X11 geometry style).
/* fetch width */
/* fetch height */
/* fetch xoffset */
/* fetch yoffset */
/* We had better have gotten to the end of the string. */
/* Trim off any partial iMCUs on the indicated destination edge */
/* Request any required workspace.
/* Determine number of components in output image */
/* We'll only process the first component */
/* Process all the components */
/* Compute output image dimensions and related values. */
/* Return right away if -perfect is given and transformation is not perfect.
/* If there is only one output component, force the iMCU size to be 1;
/* If cropping has been requested, compute the crop area's position and
/* Insert default values for unset crop parameters */
/* default to +0 */
/* default to +0 */
/* Ensure parameters are valid */
/* Convert negative crop offsets into regular offsets */
/* Now adjust so that upper left corner falls at an iMCU boundary */
/* Save x/y offsets measured in iMCUs */
/* Figure out whether we need workspace arrays,
/* No workspace needed if neither cropping nor transforming */
/* do_flip_h_no_crop doesn't need a workspace array */
/* Need workspace arrays having same dimensions as source image. */
/* transpose does NOT have to trim anything */
/* Need workspace arrays having transposed dimensions. */
/* Need workspace arrays having transposed dimensions. */
/* Need workspace arrays having transposed dimensions. */
/* Need workspace arrays having same dimensions as source image. */
/* Need workspace arrays having transposed dimensions. */
/* Allocate workspace if needed.
/* we're going to force samp factors to 1x1 in this case */
/* Transpose destination image parameters */
/* Transpose image dimensions */
/* Transpose sampling factors */
/* Transpose quantization tables */
/* Adjust Exif image parameters.
/* Flag for byte order */
/* Length of an IFD entry */
/* Discover byte order */
/* Check Tag Mark */
/* Get first IFD offset (offset to IFD0) */
/* check end of data segment */
/* Get the number of directory entries contained in this IFD */
/* Search for ExifSubIFD offset Tag in IFD0 */
/* check end of data segment */
/* Get Tag number */
/* found ExifSubIFD offset Tag */
/* Get the ExifSubIFD offset */
/* check end of data segment */
/* Get the number of directory entries contained in this SubIFD */
/* Search for ExifImageWidth and ExifImageHeight Tags in this SubIFD */
/* check end of data segment */
/* Get Tag number */
/* ExifImageWidth Tag */
/* ExifImageHeight Tag */
/* Format = unsigned long (4 octets) */
/* Number Of Components = 1 */
/* Format = unsigned long (4 octets) */
/* Number Of Components = 1 */
/* Adjust output image parameters as needed.
/* If force-to-grayscale is requested, adjust destination parameters */
/* First, ensure we have YCbCr or grayscale data, and that the source's
/* We use jpeg_set_colorspace to make sure subsidiary settings get fixed
/* Sorry, can't do it */
/* For a single-component source, we force the destination sampling factors
/* Correct the destination's image dimensions as necessary
/* Transpose destination image parameters */
/* Adjust Exif properties */
/* Suppress output of JFIF marker */
/* Adjust Exif image parameters */
/* Align data segment to start of TIFF structure for parsing */
/* Return the appropriate output data set */
/* Execute the actual transformation, if any.
/* Note: conditions tested here should match those in switch statement
/* jtransform_perfect_transform
/* initialize TRUE */
/* TRANSFORMS_SUPPORTED */
/* Setup decompression object to save desired markers in memory.
/* Save comments except under NONE option */
/* Save all types of APPn markers iff ALL option */
/* SAVE_MARKERS_SUPPORTED */
/* Copy markers saved in the given source object to the destination object.
/* In the current implementation, we don't actually need to examine the
/* reject duplicate JFIF */
/* reject duplicate Adobe */
/* We could use jpeg_write_marker if the data weren't FAR... */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libogg\src\bitwise.c
/********************************************************************
//www.xiph.org/                  *
/* We're 'LSb' endian; if we write a word but read individual bits,
/* Takes only up to 32 bits. */
/* Takes only up to 32 bits. */
/* expand storage up-front */
/* copy whole octets */
/* unaligned copy.  Do it the hard way. */
/* aligned block copy */
/* copy trailing bits */
/* Read in bits without advancing the bitptr; bits <= 32 */
/* not the main path */
/* special case to avoid reading b->ptr[0], which might be past the end of
/* Read in bits without advancing the bitptr; bits <= 32 */
/* not the main path */
/* special case to avoid reading b->ptr[0], which might be past the end of
/* bits <= 32 */
/* not the main path */
/* special case to avoid reading b->ptr[0], which might be past the end of
/* bits <= 32 */
/* not the main path */
/* special case to avoid reading b->ptr[0], which might be past the end of
/* Self test of the bitwise routines; everything else is based on
/* prefill */
/* check buffers; verify end byte masking */
/* second copy */
/* check buffers; verify end byte masking */
/* prefill */
/* check buffers; verify end byte masking */
/* second copy */
/* check buffers; verify end byte masking */
/* Test read/write together */
/* Later we test against pregenerated bitstreams */
/* this is partly glassbox; we're mostly concerned about the allocation boundaries */
/********** lazy, cut-n-paste retest with MSb packing ***********/
/* Test read/write together */
/* Later we test against pregenerated bitstreams */
/* this is partly glassbox; we're mostly concerned about the allocation boundaries */
/* _V_SELFTEST */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libogg\src\framing.c
/********************************************************************
//www.xiph.org/                  *
/* A complete description of Ogg framing exists in docs/framing.html */
/* returns the number of packets that are completed on this page (if
/* NOTE:
/* helper to initialize lookup for direct-table CRC (illustrative; we
/* The same as the ethernet generator
/* init the encode/decode logical stream state */
/* async/delayed error detection for the ogg_stream_state */
/* _clear does not free os, only the non-flat storage within */
/* Helpers for ogg_stream_encode; this keeps the structure and
/* checksum the page */
/* Direct table CRC; note that this will be faster in the future if we
/* safety; needed for API behavior, but not framing code */
/* submit data to the internal buffer of the framing engine */
/* advance packet data according to the body_returned pointer. We
/* make sure we have the buffer storage */
/* Copy in the submitted packet.  Yes, the copy is a waste; this is
/* Store lacing vals for this packet */
/* flag the first segment as the beginning of the packet */
/* for the sake of completeness */
/* Conditionally flush a page; force==0 will only flush nominal-size
/* construct a page */
/* decide how many segments to include */
/* If this is the initial header case, the first page must only include
/* 'initial header page' case */
/* The extra packets_done, packet_just_done logic here attempts to do two things:
/* construct the header in temp storage */
/* stream structure version */
/* continued packet flag? */
/* first page flag? */
/* last page flag? */
/* 64 bits of PCM position */
/* 32 bits of stream serial number */
/* 32 bits of page counter (we have both counter and page header
/* because someone called
/* zero for computation; filled in later */
/* segment table */
/* set pointers in the ogg_page struct */
/* advance the lacing data and set the body_returned pointer */
/* calculate the checksum */
/* done */
/* This will flush remaining packets into a page (returning nonzero),
/* Like the above, but an argument is provided to adjust the nominal
/* This constructs pages from buffered packet segments.  The pointers
/* 'were done, now flush' case */
/* 'initial header page' case */
/* Like the above, but an argument is provided to adjust the nominal
/* 'were done, now flush' case */
/* 'initial header page' case */
/* DECODING PRIMITIVES: packet streaming layer **********************/
/* This has two layers to place more of the multi-serialno and paging
/* initialize the struct to a known state */
/* used as a readiness flag */
/* clear non-flat storage within */
/* first, clear out any space that has been previously returned */
/* We need to extend the internal buffer */
/* an extra page to be nice */
/* expose a segment at least as large as requested at the fill mark */
/* sync the stream.  This is meant to be useful for finding page
/* not enough for a header */
/* verify capture pattern */
/* not enough for header + seg table */
/* count up body length in the segment table */
/* The whole test page is buffered.  Verify the checksum */
/* Grab the checksum bytes, set the header field to zero */
/* set up a temp page struct and recompute the checksum */
/* Compare */
/* D'oh.  Mismatch! Corrupt page (or miscapture and not a page
/* replace the computed checksum with the one actually read in */
/* Bad checksum. Lose sync */
/* yes, have a whole page all ready to go */
/* search for possible capture */
/* sync the stream and get a page.  Keep trying until we find a page.
/* all we need to do is verify a page at the head of the stream
/* have a page */
/* need more data */
/* head did not start a synced page... skipped some bytes */
/* loop. keep looking */
/* add the incoming page to the stream state; we decompose the page
/* clean up 'returned data' */
/* body data */
/* segment table */
/* check the serial number */
/* are we in sequence? */
/* unroll previous partial packet (if any) */
/* make a note of dropped data in segment table */
/* are we a 'continued packet' page?  If so, we may need to skip
/* set the granulepos on the last granuleval of the last full packet */
/* clear things to an initial state.  Good to call, eg, before seeking */
/* The last part of decode. We have the stream broken into packet
/* we need to tell the codec there's a gap; it might need to
/* just using peek as an inexpensive way
/* Gather the whole packet. We'll have no holes or a partial packet */
/* last packet of the stream? */
/* first packet of the stream? */
/* packet number just follows sequence/gap; adjust the input number
/* Test data */
/* Test data */
/* Test header */
/* 17 only */
/* 17, 254, 255, 256, 500, 510, 600 byte, pad */
/* nil packets; beginning,middle,end */
/* large initial packet */
/* continuing packet test */
/* spill expansion test */
/* page with the 255 segment limit */
/* packet that overspans over an entire page */
/* packet that overspans over an entire page */
/* for scripted test cases only */
/* construct a test packet */
/* submit the test packet */
/* retrieve any finished pages */
/* We have a page.  Check it carefully */
/* have a complete page; submit it to sync/decode */
/* got a page.  Happy happy.  Verify that it's good. */
/* submit it to deconstitution */
/* packets out? */
/* just catching them all */
/* verify peek and out match */
/* verify the packet! */
/* check data */
/* check bos flag */
/* check eos flag */
/* check granulepos flag */
/* Exercise each code path in the framing code.  Also verify that
/* 17 only */
/* 17, 254, 255, 256, 500, 510, 600 byte, pad */
/* nil packets; beginning,middle,end */
/* large initial packet */
/* continuing packet test; with page spill expansion, we have to
/* spill expand packet test */
/* page with the 255 segment limit */
/* packet that overspans over an entire page */
/* test for the libogg 1.1.1 resync in large continuation bug
/* term only page.  why not? */
/* build a bunch of pages for testing */
/* retrieve finished pages */
/* Test lost pages on pagein/packetout: no rollback */
/* skip */
/* do we get the expected results/packets? */
/* Test lost pages on pagein/packetout: rollback with continuation */
/* skip */
/* do we get the expected results/packets? */
/* the rest only test sync */
/* Test fractional page inputs: incomplete capture */
/* Test fractional page inputs: incomplete fixed header */
/* Test fractional page inputs: incomplete header */
/* Test fractional page inputs: incomplete body */
/* Test fractional page inputs: page + incomplete capture */
/* Test recapture: garbage + page */
/* 'garbage' */
/* Test recapture: page + garbage + page */
/* Free page data that was previously copied */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libpng\png.c
/* png.c - location for general purpose libpng functions
/* Generate a compiler error if there is an old png.h in the search path. */
/* Tells libpng that we have already handled the first "num_bytes" bytes
/* Checks whether the supplied bytes match the PNG signature.  We allow
/* READ */
/* Function to allocate memory for zlib */
/* PRIVATE */,
/* Function to free memory for zlib */
/* PRIVATE */
/* Reset the CRC variable to 32 bits of 1's.  Care must be taken
/* PRIVATE */
/* The cast is safe because the crc is a 32 bit value. */
/* Calculate the CRC over a section of data.  We can only pass as
/* PRIVATE */
/* critical */
/* 'uLong' is defined in zlib.h as unsigned long; this means that on some
/* Should never issue a warning */
/* evil, but safe */
/* The following should never issue compiler warnings; if they do the
/* And the following is always safe because the crc is only 32 bits. */
/* Check a user supplied version number, called from both read and write
/* Libpng versions 1.0.0 and later are binary compatible if the version
/* Success return. */
/* Generic function to create a png_struct for either read or write - this
/* PRIVATE */,
/* This temporary stack-allocated structure is used to provide a place to
/* Added at libpng-1.2.6 */
/* Added at libpng-1.2.43 and 1.4.0 */
/* Added at libpng-1.2.43 and 1.4.1, required only for read but exists
/* The following two API calls simply set fields in png_struct, so it is safe
/* (*error_fn) can return control to the caller after the error_ptr is set,
/* Temporarily fake out the longjmp information until we have
/*stack allocation*/
/* Call the general version checker (shared with read and write code):
/* png_ptr->zstream holds a back-pointer to the png_struct, so
/* Eliminate the local error handling: */
/* This is the successful return point */
/* A longjmp because of a bug in the application storage allocator or a
/* Allocate the memory for an info_struct for the application. */
/* Use the internal API that does not (or at least should not) error out, so
/* This function frees the memory associated with a single info struct.
/* Do this first in case of an error below; if the app implements its own
/* Initialize the info structure.  This is now an internal function (0.89)
/* The following line is why this API should not be used: */
/* Set everything to 0 */
/* The following API is not called internally */
/* Free text item num or (if num == -1) all text items */
/* Free any tRNS entry */
/* Free any sCAL entry */
/* Free any pCAL entry */
/* Free any profile entry */
/* Free a given sPLT entry, or (if num == -1) all sPLT entries */
/* Free any hIST entry */
/* Free any PLTE entry that was internally allocated */
/* Free any image bits attached to the info structure */
/* READ || WRITE */
/* This function returns a pointer to the io_ptr associated with the user
/* Initialize the default input/output functions for the PNG file.  If you
/* The png_save_int_32 function assumes integers are stored in two's
/* Convert the supplied time into an RFC 1123 string suitable for use in
/* RFC1123 limitation */ ||
/* enough for a four-digit year */
/* This reliably terminates the buffer */
/* To do: remove the following from libpng-1.7 */
/* Original API that uses a private buffer in png_struct.
/* The only failure above if png_ptr != NULL is from an invalid ptime */
/* LIBPNG_VER < 10700 */
/* TIME_RFC1123 */
/* READ || WRITE */
/* Silence compiler warning about unused png_ptr */
/* The following return the library version as a short string in the
/* Version of *.c files used when building libpng */
/* Version of *.h files used when building libpng */
/* Silence compiler warning about unused png_ptr */
/* Returns longer string containing both version and date */
/* Silence compiler warning about unused png_ptr */
/* NOTE: this routine is not used internally! */
/* Build a grayscale palette.  Palette is assumed to be 1 << bit_depth
/* Check chunk_name and return "keep" value if it's on the list, else 0 */
/* beyond end */
/* The code is the fifth byte after each four byte string.  Historically this
/* num_chunk_list > 0, so at least one */
/* This means that known chunks should be processed and unknown chunks should
/* PRIVATE */
/* READ_UNKNOWN_CHUNKS || HANDLE_AS_UNKNOWN */
/* SET_UNKNOWN_CHUNKS */
/* This function, added to libpng-1.0.6g, is untested. */
/* WARNING: this resets the window bits to the maximum! */
/* READ */
/* This function was added to libpng-1.0.7 */
/* Version of *.c files used when building libpng */
/* Ensure that png_ptr->zstream.msg holds some appropriate error message string.
/* PRIVATE */
/* Translate 'ret' into an appropriate error string, priority is given to the
/* Normal exit */
/* This means the deflate stream did not have a dictionary; this
/* gz APIs only: should not happen */
/* internal libpng error */
/* End of input or output; not a problem if the caller is doing
/* Compile errors here mean that zlib now uses the value co-opted in
/* png_convert_size: a PNGAPI but no longer in png.h, so deleted
/* Added at libpng version 1.2.34 and 1.4.0 (moved from pngset.c) */
/* always set if COLORSPACE */
/* This is called to check a new gamma value against an existing one.  The
/* Either this is an sRGB image, in which case the calculated gamma
/* Do not overwrite an sRGB value */
/* sRGB tag not involved */
/* PRIVATE */
/* Changed in libpng-1.5.4 to limit the values to ensure overflow can't
/* Allow the application to set the gamma value more than once */
/* Do nothing if the colorspace is already invalid */
/*from gAMA*/) != 0)
/* Store this gamma value. */
/* At present if the check_gamma test fails the gamma of the colorspace is
/* Error exit - errmsg has been set. */
/* PRIVATE */
/* Everything is invalid */
/* Clean up the iCCP profile now if it won't be used. */
/*not used*/);
/* Leave the INFO_iCCP flag set if the pngset.c code has already set
/* PRIVATE */
/* reduce code size; check here not in the caller */
/* GAMMA */
/* Added at libpng-1.5.5 to support read and write of true CIEXYZ values for
/* The reference white is simply the sum of the end-point (X,Y,Z) vectors,
/* Check xy and, implicitly, z.  Note that wide gamut color spaces typically
/* The reverse calculation is more difficult because the original tristimulus
/* By the argument, above overflow should be impossible here. The return
/* Now find the red numerator. */
/* Overflow is possible here and it indicates an extreme set of PNG cHRM
/* r+g+b scales = white scale */)
/* Similarly for green_inverse: */
/* And the blue scale, the checks above guarantee this can't overflow but it
/* And fill in the png_XYZ: */
/*success*/
/* Normalize by scaling so the sum of the end-point Y values is PNG_FP_1.
/* Allow an error of +/-0.01 (absolute value) on each chromaticity */
/* Added in libpng-1.6.0, a different check for the validity of a set of cHRM
/* As a side-effect this routine also returns the XYZ endpoints. */
/*actually, the math is pretty accurate*/) != 0)
/* Too much slip */
/* This is the check going the other way.  The XYZ is modified to normalize it
/* Used to check for an endpoint match against sRGB */
/* From ITU-R BT.709-3 */
/* color      x       y */
/* red   */ 64000, 33000,
/* green */ 30000, 60000,
/* blue  */ 15000,  6000,
/* white */ 31270, 32900
/* The consistency check is performed on the chromaticities; this factors out
/* The end points must be reasonably close to any we already have.  The
/* failed */
/* Only overwrite with preferred values */
/* ok, but no change */
/* The end points are normally quoted to two decimal digits, so allow +/-0.01
/* ok and changed */
/* PRIVATE */
/* We must check the end points to ensure they are reasonable - in the past
/* success */
/* We can't invert the chromaticities so we can't produce value XYZ
/* libpng is broken; this should be a warning but if it happens we
/* failed */
/* PRIVATE */
/* End points are invalid. */
/* failed */
/* Error message generation */
/* checks all the top bits */ &&
/* see below for calculation */
/* 9 chars */
/* Truncate to 79 chars */
/* +2 = 90 */
/* So 'value' is at most 4 bytes and the following cast is safe */
/* total +8; less than the else clause */
/* +24 = 114*/
/*+2 = 116*/
/* The 'reason' is an arbitrary message, allow +79 maximum 195 */
/* This is recoverable, but make it unconditionally an app_error on write to
/* sRGB || iCCP */
/* PRIVATE */
/* sRGB sets known gamma, end points and (from the chunk) intent. */
/* IMPORTANT: these are not necessarily the values found in an ICC profile
/* D65 XYZ (*not* the D50 adapted values!) */
/* color      X      Y      Z */
/* red   */ 41239, 21264,  1933,
/* green */ 35758, 71517, 11919,
/* blue  */ 18048,  7219, 95053
/* Do nothing if the colorspace is already invalidated. */
/* Check the intent, then check for existing settings.  It is valid for the
/* If the standard sRGB cHRM chunk does not match the one from the PNG file
/* This check is just done for the error reporting - the routine always
/*from sRGB*/);
/* intent: bugs in GCC force 'int' to be used as the parameter type. */
/* endpoints */
/* gamma */
/* Finally record that we have an sRGB profile */
/* set */
/* sRGB */
/* Encoded value of D50 as an ICC XYZNumber.  From the ICC 2010 spec the value
/* PRIVATE */
/* PRIVATE */
/* first 132 bytes only */, int color_type)
/* Length check; this cannot be ignored in this code because profile_length
/* tag count: 12 bytes/tag */
/* (2^32-4-132)/12: maximum possible tag count */
/* truncated tag table */
/* The 'intent' must be valid or we can't store it, ICC limits the intent to
/* The ICC limit */
/* This is just a warning because the profile may be valid in future
/* At this point the tag table can't be checked because it hasn't necessarily
/* Data checks (could be skipped).  These checks must be independent of the
/* signature 'ascp' */
/* Currently the PCS illuminant/adopted white point (the computational
/*no tag value*/,
/* The PNG spec requires this:
/* data colour space field */
/* 'RGB ' */
/* 'GRAY' */
/* It is up to the application to check that the profile class matches the
/* profile/device class */
/* 'scnr' */
/* 'mntr' */
/* 'prtr' */
/* 'spac' */
/* All supported */
/* 'abst' */
/* May not be embedded in an image */
/* 'link' */
/* DeviceLink profiles cannot be interpreted in a non-device specific
/* 'nmcl' */
/* A NamedColor profile is also device specific, however it doesn't
/* To allow for future enhancements to the profile accept unrecognized
/* For any profile other than a device link one the PCS must be encoded
/* 'XYZ ' */
/* 'Lab ' */
/* PRIVATE */
/* header plus whole tag table */)
/* The first tag */
/* First scan all the tags in the table and add bits to the icc_info value
/* must be aligned */
/* not padded */
/* The ICC specification does not exclude zero length tags, therefore the
/* CNHP730S.icc shipped with Microsoft Windows 64 violates this, it is
/* This is a hard error; potentially it can cause read outside the
/* success, maybe with warnings */
/* Information about the known ICC sRGB profiles */
/* This data comes from contrib/tools/checksum-icc run on downloads of
/* adler32, crc32, MD5[4], intent, date, length, file-name */
/* ICC sRGB v2 perceptual no black-compensation: */
/* ICC sRGB v4 perceptual */
/* The following profiles have no known MD5 checksum. If there is a match
/* This is a 'mntr' (display) profile with a mediaWhitePointTag that does not
/*broken*/,
/*broken*/,
/* The quick check is to verify just the MD5 signature and trust the
/* invalid */
/* the value for 0 length data */
/* First see if PNG_SKIP_sRGB_CHECK_PROFILE has been set to "on" */
/* This may be one of the old HP profiles without an MD5, in that
/* Profile is unsigned or more checks have been configured in. */
/* Length *and* intent must match */
/* Now calculate the adler32 if not done already. */
/* These basic checks suggest that the data has not been
/* So this check must pass for the 'return' below to happen.
/* These profiles are known to have bad data that may cause
/* Warn that this being done; this isn't even an error since
/* The signature matched, but the profile had been changed in some
/* no match */
/* PNG_sRGB_PROFILE_CHECKS >= 0 */
/* PRIVATE */
/* Is this profile one of the known ICC sRGB profiles?  If it is, just set
/*already checked*/png_get_uint_32(profile+64));
/* sRGB */
/* PRIVATE */
/* If no sRGB support, don't try storing sRGB information */
/* Failure case */
/* iCCP */
/* PRIVATE */
/* Set the rgb_to_gray coefficients from the colorspace. */
/* png_set_background has not been called, get the coefficients from the Y
/* We allow 0 coefficients here.  r+g+b may be 32769 if two or
/* Check for an internal error. */
/* This is a png_error at present even though it could be ignored -
/* READ_RGB_TO_GRAY */
/* COLORSPACE */
/* This exists solely to work round a warning from GNU C. */
/* PRIVATE */
/* PRIVATE */
/* Check for width and height valid values */
/* big_row_buf hack */
/* filter byte */
/* 8-byte RGBA pixels */
/* extra max_pixel_depth pad */
/* The size of the row must be within the limits of this architecture.
/* Check other values */
/* Accept filter_method 64 (intrapixel differencing) only if
/* ASCII to fp functions */
/* Check an ASCII formated floating point value, see the more detailed
/* The following is used internally to preserve the sticky flags */
/* PRIVATE */
/* First find the type of the next character */
/* Now deal with this type according to the current
/* not a part of the number */
/* Ok as trailer, ok as lead of fraction. */
/* two dots */
/* trailing dot? */
/* delayed fraction */
/* case PNG_FP_FRACTION + PNG_FP_SAW_SIGN:
/* case PNG_FP_FRACTION + PNG_FP_SAW_DOT:
/* This is correct because the trailing '.' on an
/* not a part of the number */
/* case PNG_FP_EXPONENT + PNG_FP_SAW_DOT:
/* case PNG_FP_EXPONEXT + PNG_FP_SAW_E:
/* I.e. break 2 */
/* The character seems ok, continue. */
/* Here at the end, update the state and return the correct
/* The same but for a complete string. */
/* must be non-zero - see above */;
/* i.e. fail */
/* pCAL || sCAL */
/* Utility used below - a simple accurate power of ten from an integral
/* Handle negative exponent with a reciprocal at the end because
/* Decompose power bitwise. */
/* else power is 0 and d is 1 */
/* Function to format a floating point value in ASCII with a given
/* PRIVATE */
/* We use standard functions from math.h, but not printf because
/* Enforce the limit of the implementation precision too. */
/* Basic sanity checks */
/* See the requirements below. */
/* '-'  PLUS 1 TOTAL 1 */
/* A base 10 exponent */
/* 10^exp_b10 */
/* First extract a base 10 exponent of the number,
/* exponent to base 2 */
/* <= exponent to base 10 */
/* Avoid underflow here. */
/* May underflow */
/* And this may overflow. */
/* Normalize fp and correct exp_b10, after this fp is in the
/* Because of the code above fp may, at this point, be
/* Allow up to two leading zeros - this will not lengthen
/* PLUS 3 TOTAL 4 */
/* PLUS 2 digits: TOTAL 3 */
/* Dot added below before first output. */
/* No zeros to add */
/* Generate the digit list, stripping trailing zeros and
/* Count of leading zeros */
/* Count of digits in list. */
/* Use modf here, not floor and subtract, so that
/* Rounding up to 10, handle that here. */
/* Advance exp_b10 to '1', so that the
/* I.e. 1+(ch-48) */
/* Did we reach the beginning? If so adjust the
/* cdigits == 0 */
/* Leading decimal point (plus zeros?), if
/* Else lost a leading zero, so 'exp_b10' is
/* In all cases we output a '1' */
/* Guarantees termination below. */
/* Included embedded zeros in the digit count. */
/* exp_b10 == (-1) means we just output the decimal
/* PLUS 1: TOTAL 4 */
/* counted above */
/* The total output count (max) is now 4+precision */
/* Check for an exponent, if we don't need one we are
/* The following only happens if we didn't output the
/* Total buffer requirement (including the '\0') is
/* Here if an exponent is required, adjust size for
/* 'E': PLUS 1 TOTAL 2+precision */
/* The following use of an unsigned temporary avoids ambiguities in
/* '-': PLUS 1 TOTAL 3+precision */
/* Need another size check here for the exponent digits, so
/* '0' */
/* 'i' */
/* 'n' */
/* 'f' */
/* Here on buffer too small. */
/* FLOATING_POINT */
/* Function to format a fixed point value in ASCII.
/* PRIVATE */
/* Require space for 10 decimal digits, a decimal point, a minus sign and a
/* Avoid overflow here on the minimum integer. */
/* else overflowed */
/* flag value */;
/* Split the low digit off num: */
/* Record the first non-zero digit, note that this is a number
/* The remaining digits are fractional digits, ndigits is '5' or
/* decimal point */
/* ndigits may be <5 for small numbers, output leading zeros
/* Don't output the trailing zeros! */
/* And null terminate the string: */
/* Here on buffer too small. */
/* FIXED_POINT */
/* SCAL */
/* muldiv functions */
/* This API takes signed arguments and rounds the result to the nearest
/* Return a * times / divisor, rounded. */
/* A png_fixed_point is a 32-bit integer. */
/* Following can't overflow because the arguments only
/* Can't overflow because the a*times bit is only 30
/* carry */
/* else overflow */
/* s32.s00 is now the 64-bit product, do a standard
/* NOTE: signed */
/* carry */
/* Handle the rounding. */
/* Check for overflow. */
/* READ_GAMMA || INCH_CONVERSIONS */
/* The following is for when the caller doesn't much care about the
/* more fixed point functions for gamma */
/* Calculate a reciprocal, return 0 on div-by-zero or overflow. */
/* error/overflow */
/* This is the shared test on whether a gamma value is 'significant' - whether
/* PRIVATE */
/* A local convenience routine. */
/* The required result is 1/a * 1/b; the following preserves accuracy. */
/* overflow */
/* 16BIT */
/* The inverse of the above. */
/* The required result is 1/a * 1/b; the following preserves accuracy. */
/* This may overflow because the range of png_fixed_point isn't symmetric,
/* overflow */
/* READ_GAMMA */
/* gamma table code */
/* Fixed point gamma.
/* The following are the values for 16-bit tables - these work fine for the
/* Each time 'x' is multiplied by 2, 1 must be subtracted off the final log,
/* result is at most 19 bits, so this cast is safe: */
/* The above gives exact (to 16 binary places) log2 values for 8-bit images,
/* As above, but now the input has 16 bits. */
/* Calculate the base logarithm from the top 8 bits as a 28-bit fractional
/* Now we need to interpolate the factor, this requires a division by the top
/* Since we divided by the top 8 bits of 'x' there will be a '1' at 1<<24,
/* <= '257' */
/* Safe, because the result can't have more than 20 bits: */
/* 16BIT */
/* The 'exp()' case must invert the above, taking a 20-bit fixed point
/* NOTE: the first entry is deliberately set to the maximum 32-bit value. */
/* Adjustment table; provided to explain the numbers in the code below. */
/* Else overflow or zero (underflow) */
/* Obtain a 4-bit approximation */
/* Incorporate the low 12 bits - these decrease the returned value by
/* And handle the low 6 bits in a single block. */
/* Handle the upper bits of x. */
/* Check for overflow */
/* Else underflow */
/* Get a 32-bit value: */
/* Convert the 32-bit value to 0..255 by multiplying by 256-1. Note that the
/* Get a 32-bit value: */
/* Convert the 32-bit value to 0..65535 by multiplying by 65536-1: */
/* 16BIT */
/* FLOATING_ARITHMETIC */
/* 'value' is unsigned, ANSI-C90 requires the compiler to correctly
/*SAFE*/value/255.,gamma_val*.00001)+.5);
/* Overflow. */
/* The same (unsigned int)->(double) constraints apply here as above,
/* Overflow. */
/* 16BIT */
/* This does the right thing based on the bit_depth field of the
/* PRIVATE */
/* should not reach this */
/* 16BIT */
/* Internal function to build a single 16-bit table - the table consists of
/* Various values derived from 'shift': */
/* CSE the division and work round wacky GCC warnings (see the comments
/* The 'threshold' test is repeated here because it can arise for one of
/* The old code would overflow at the end and this would cause the
/* Inline the 'max' scaling operation: */
/* See png_gamma_8bit_correct for why the cast to (int) is
/* We must still build a table, but do it the fast way. */
/* NOTE: this function expects the *inverse* of the overall gamma transformation
/* 'num' is the number of tables and also the number of low bits of low
/* 'gamma_val' is set to the reciprocal of the value calculated above, so
/* 8-bit output value */
/* Find the corresponding maximum input value */
/* 16-bit output value */
/* Find the boundary value in 16 bits: */
/* Adjust (round) to (16-shift) bits: */
/* And fill in the final entries. */
/* 16BIT */
/* Build a single 8-bit table: same as the 16-bit case but much simpler (and
/* Used from png_read_destroy and below to release the memory used by the gamma
/* PRIVATE */
/* 16BIT */
/* 16BIT */
/* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
/* We build the 8- or 16-bit gamma tables here.  Note that for 16-bit
/* PRIVATE */
/* Remove any existing table; this copes with multiple calls to
/* Probably doing rgb_to_gray */);
/* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
/* 16-bit gamma code uses this equation:
/* shift == insignificant bits */
/* keep all 16 bits */
/* PNG_MAX_GAMMA_8 is the number of bits to keep - effectively
/* Guarantees at least one table! */
/* NOTE: prior to 1.5.4 this test used to include PNG_BACKGROUND (now
/* Notice that the '16 from 1' table should be full precision, however
/* Probably doing rgb_to_gray */);
/* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
/* 16BIT */
/* READ_GAMMA */
/* HARDWARE OR SOFTWARE OPTION SUPPORT */
/* sRGB support */
/* sRGB conversion tables; these are machine generated with the code in
//en.wikipedia.org/wiki/SRGB)
/* The convert-to-sRGB table is only currently required for read. */
/* SIMPLIFIED_READ */
/* The base/delta tables are required for both read and write (but currently
/* SIMPLIFIED READ/WRITE sRGB support */
/* SIMPLIFIED READ/WRITE SUPPORT */
/* Double check that we have a png_ptr - it should be impossible to get here
/* First free any data held in the control structure. */
/* Ignore errors here. */
/* Copy the control structure so that the original, allocated, version can be
/* Then the structures, calling the correct API. */
/* Success. */
/* Safely call the real function, but only if doing so is safe at this point
/* Ignore errors here: */
/* PRIVATE */
/* Utility to log an error. */
/* SIMPLIFIED READ/WRITE */
/* READ || WRITE */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libpng\pngerror.c
/* pngerror.c - stub functions for i/o and memory allocation
/* PRIVATE */
/* WARNINGS */
/* This function is called whenever there is a fatal error.  This function
/* Strip "#nnnn " from beginning of error message. */
/* If the custom handler doesn't exist, or if it returns,
/* Prior to 1.5.2 the error_fn received a NULL pointer, expressed
/* If the custom handler doesn't exist, or if it returns,
/* ERROR_TEXT */
/* Utility to safely appends strings to a buffer.  This never errors out so
/* Utility to dump an unsigned value into a buffer, given a start pointer and
/* number of digits output */
/* minimum number required */
/* digit output (for the fixed point format) */
/* This is written so that the loop always runs at least once, even with
/* Needs five digits (the fraction) */
/* Expects at least 2 digits. */
/* FALL THROUGH */
/* This format expects at least two digits */
/* FALL THROUGH */
/* an error */
/* Keep track of the number of digits added */
/* Float a fixed number here: */
/* End of the fraction, but maybe nothing was output?  In that case
/* and !output */
/* This function is called whenever there is a non-fatal error.  This function
/* These functions support 'formatted' warning messages with up to
/* Avoid overflow by doing the negate in a png_alloc_size_t: */
/* The internal buffer is just 192 bytes - enough for all our messages,
/* Index in the msg[] buffer: */
/* Each iteration through the following loop writes at most one character
/* '@' at end of string is now just printed (previously it was skipped);
/* Consume the '@' */
/* Search for the parameter digit, the index in the string is the
/* If the parameter digit is out of range it will just get printed. */
/* Append this parameter */
/* No need to copy the trailing '\0' here, but there is no guarantee
/* Consume the parameter digit too: */
/* else not a parameter and there is a character after the @ sign; just
/* At this point *message can't be '\0', even in the bad parameter case
/* i is always less than (sizeof msg), so: */
/* And this is the formatted message. It may be larger than
/* WARNINGS */
/* PRIVATE */
/* PRIVATE */
/* BENIGN_ERRORS */
/* Currently limited by profile_error in png.c */
/* These utilities are used internally to build an error message that relates
/* PRIVATE */
/* iin < PNG_MAX_ERROR_TEXT, so the following is safe: */
/* WARNINGS || ERROR_TEXT */
/* READ && ERROR_TEXT */
/* WARNINGS */
/* READ */
/* PRIVATE */
/* This is always supported, but for just read or just write it
/* This API only exists if ANSI-C style error handling is used,
/* From libpng 1.6.0 the app gets one chance to set a 'jmpbuf_size' value
/* not allocated */
/* new NULL return on OOM */
/* Already allocated: check the size */
/* This is an internal error in libpng: somehow we have been left
/* png_ptr->jmp_buf_ptr = &png_ptr->jmp_buf_local; */
/* caller will probably crash: no choice here */
/* Finally fill in the function, now we have a satisfactory buffer. It is
/* PRIVATE */
/* A size of 0 is used to indicate a local, stack, allocation of the
/* This stuff is so that a failure to free the error control structure
/* Make an internal, libpng, jmp_buf to return here */
/* come back here */
/* stack allocation */
/* Return to setjmp on error */
/* *Always* cancel everything out: */
/* This is the default error handling function.  Note that replacements for
/* PRIVATE */,
/* Check on NULL only added in 1.5.4 */
/* Strip "#nnnn " from beginning of error message. */
/* Make compiler happy */
/* If control reaches this point, png_longjmp() must not return. The only
/* This function is called when there is a warning, but the library thinks
/* PRIVATE */
/* Make compiler happy */
/* Make compiler happy */
/* WARNINGS */
/* This function is called when the application wants to use another method
/* This function returns a pointer to the error_ptr associated with the user
/* Currently the above both depend on SETJMP_SUPPORTED, however it would be
/* PRIVATE */, (PNGCBAPI
/* An error is always logged here, overwriting anything (typically a warning)
/* Retrieve the jmp_buf from within the png_control, making this work for
/* Missing longjmp buffer, the following is to help debugging: */
/* Here on an internal programming error. */
/* PRIVATE */ PNGCBAPI
/* A warning is only logged if there is no prior warning or error. */
/* PRIVATE */
/* Safely execute function(arg) with png_error returning to this function. */
/* And do the cleanup prior to any failure return. */
/* SIMPLIFIED READ || SIMPLIFIED_WRITE */
/* READ || WRITE */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libpng\pngget.c
/* pngget.c - retrieval of values from info struct
/* Easy access to info, added in libpng-0.99 */
/* The following casts work because a PNG 4 byte integer only has a valid
/* The conversion is *(2.54/100), in binary (32 digits):
/* .1 */
/* .1001 */
/* .1101 */
/* .000000000000000000001 */
/* .1101000000000001101 */
/* .000000000001001 */
/* .000000000001001000000001001 */
/* .000000000001001000001001001 */
/* .110100000001001110101001001 */
/* .00000110100000001001110101001001 */
/* The argument is a PNG unsigned integer, so it is not permitted
/* Overflow. */
/* Convert from metres * 1,000,000 to inches * 100,000, meters to
/* To avoid the overflow do the conversion directly in floating
/* To avoid the overflow do the conversion directly in floating
/* pHYs */
/* INCH_CONVERSIONS */
/* png_get_channels really belongs in here, too, but it's been around longer */
/* EASY_ACCESS */
/* The XYZ APIs were added in 1.5.5 to take advantage of the code added at the
/* Quiet API change: this code used to only return the end points if a cHRM
/* This is somewhat irrelevant since the profile data returned has
/* This is redundant if we can be sure that the info_ptr values were all
/*TODO: make this work without FP support; the API is currently eliminated
/* FLOATING_ARITHMETIC */
/* FIXED_POINT */
/* FLOATING POINT */
/* sCAL */
/* pHYs */
/* if (info_ptr->color_type != PNG_COLOR_TYPE_PALETTE) */
/* These functions were added to libpng 1.2.6 and were enabled
/* This function was added to libpng 1.4.0 */
/* This function was added to libpng 1.4.1 */
/* SET_USER_LIMITS */
/* These functions were added to libpng 1.4.0 */
/* IO_STATE */
/* READ || WRITE */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libpng\pngmem.c
/* pngmem.c - stub functions for memory allocation
/* Free a png_struct */
/* PRIVATE */
/* png_free might call png_error and may certainly call
/* We may have a jmp_buf left to deallocate. */
/* Allocate memory.  For reasonable files, size should never exceed
/* png_malloc_base, an internal function added at libpng 1.6.0, does the work of
/* PRIVATE */,
/* Moved to png_malloc_base from png_malloc_default in 1.6.0; the DOS
/* checked for truncation above */
/* This is really here only to work round a spurious warning in GCC 4.6 and 4.7
/* known to be > 0 */
/* The failure case when the request is too large */
/* PRIVATE */,
/* PRIVATE */,
/* These are internal errors: */
/* Check for overflow on the elements count (so the caller does not have to
/* Because png_malloc_array worked the size calculations below cannot
/* error */
/* TEXT || sPLT || STORE_UNKNOWN_CHUNKS */
/* Various functions that have different error handling are derived from this.
/* 'm' means png_malloc */
/* Passing 'NULL' here bypasses the application provided memory handler. */
/*use malloc*/, size);
/* 'M' means png_malloc_default */
/* USER_MEM */
/* This function was added at libpng version 1.2.3.  The png_malloc_warn()
/* Free a pointer allocated by png_malloc().  If ptr is NULL, return
/* USER_MEM */
/* This function is called when the application wants to use another method
/* This function returns a pointer to the mem_ptr associated with the user
/* USER_MEM */
/* READ || WRITE */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libpng\pngpread.c
/* pngpread.c - read a png file in push mode
/* Push model modes */
/* It's easiest for the caller if we do the save; then the caller doesn't
/* This includes any pending saved bytes: */
/* So subtract the saved buffer size, unless all the data
/* At the end of png_process_data the buffer size must be 0 (see the loop
/* If is impossible for there to be a saved buffer at this point -
/* What we do with the incoming data depends on what we were previously
/* PRIVATE */
/* Read any remaining signature bytes from the stream and compare them with
/* PRIVATE */
/* SAFE, does not exceed 8 */ 
/* PRIVATE */
/* unknown handling method */
/* First we make sure we have enough data for the 4-byte chunk name
/* If we reach an IDAT chunk, this means we have read all of the
/* PRIVATE */
/* PRIVATE */
/* We want the smaller of 'skip_length' and 'save_buffer_size', but
/* We want the smaller of 'skip_length' and 'current_buffer_size', here,
/* PRIVATE */
/* PRIVATE */
/* PRIVATE */
/* TODO: this code can be commoned up with the same code in push_read */
/* We want the smaller of 'idat_size' and 'current_buffer_size', but they
/* We want the smaller of 'idat_size' and 'current_buffer_size', but they
/* PRIVATE */
/* The caller checks for a non-zero buffer length. */
/* This routine must process all the data it has been given
/* TODO: WARNING: TRUNCATION ERROR: DANGER WILL ROBINSON: */
/* Keep going until the decompressed data is all processed
/* We have data for zlib, but we must check that zlib
/* TODO: WARNING: TRUNCATION ERROR: DANGER WILL ROBINSON: */
/* Using Z_SYNC_FLUSH here means that an unterminated
/* Check for any failure before proceeding. */
/* Terminate the decompression. */
/* This may be a truncated stream (missing or
/* Skip the check on unprocessed input */
/* Did inflate output any data? */
/* Is this unexpected data after the last row?
/* Extra data. */
/* Do no more processing; skip the unprocessed
/* Do we have a complete row? */
/* And check for the end of the stream. */
/* All the data should have been processed, if anything
/* PRIVATE */
/* 1.5.6: row_info moved out of png_struct to a local here. */
/* NOTE: width of current interlaced row */
/* libpng 1.5.6: the following line was copying png_ptr->rowbytes before
/* The transformed pixel depth should match the depth now in row_info. */
/* Expand interlaced rows to full size */
/* Updates png_ptr->pass */
/* Pass 1 might be empty */
/* Skip top 4 generated rows */
/* Pass 3 might be empty */
/* Skip top two generated rows */
/* Pass 5 might be empty */
/* Skip top generated row */
/* PRIVATE */
/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
/* Start of interlace block */
/* Offset to next interlace block */
/* Start of interlace block in the y direction */
/* Offset to next interlace block in the y direction */
/* Height of interlace block.  This is not currently used - if you need
/* READ_INTERLACING */
/* PRIVATE */
/* PRIVATE */
/* PRIVATE */
/* new_row is a flag here - if it is NULL then the app callback was called
/*blocky display*/);
/* READ_INTERLACING */
/* PROGRESSIVE_READ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libpng\pngread.c
/* pngread.c - read a PNG file
/* Create a PNG structure for reading, and allocate any memory needed. */
/* Alternate create PNG structure for reading, and allocate any memory
/* USER_MEM */
/* Added in libpng-1.6.0; this can be used to detect a read structure if
/* In stable builds only warn if an application error can be completely
/* TODO: delay this, it can be done in png_init_io (if the app doesn't
/* Read the information before the actual image data.  This has been
/* Read and check the PNG file signature. */
/* IDAT logic needs to happen here to simplify getting the two flags
/* This should be a binary subdivision search or a hash for
/* It has been consumed */
/* SEQUENTIAL_READ */
/* Optional call to update the users info_ptr structure */
/* New in 1.6.0 this avoids the bug of doing the initializations twice */
/* Initialize palette, background, etc, after transformations
/* New in 1.6.0 this avoids the bug of doing the initializations twice */
/* SEQUENTIAL_READ */
/* Undoes intrapixel differencing,
/* MNG_FEATURES */
/* png_read_start_row sets the information (in particular iwidth) for this
/* 1.5.6: row_info moved out of png_struct to a local here. */
/* NOTE: width of current interlaced row */
/* Check for transforms that have been set but were defined out */
/* WARNINGS */
/* If interlaced and we do not need a new row, combine row and return.
/*display*/);
/*display*/);
/*display*/);
/*display*/);
/*display*/);
/*display*/);
/* Fill the row with IDAT data: */
/* libpng 1.5.6: the following line was copying png_ptr->rowbytes before
/* Intrapixel differencing */
/* The transformed pixel depth should match the depth now in row_info. */
/* Expand interlaced rows to full size */
/*display*/);
/*row*/);
/*ignored*/);
/*ignored*/);
/* SEQUENTIAL_READ */
/* Read one or more rows of image data.  If the image is interlaced,
/* SEQUENTIAL_READ */
/* Read the entire image.  If the image has an alpha channel or a tRNS
/* And make sure transforms are initialized. */
/* Caller called png_start_read_image or png_read_update_info without
/* Make sure this is set correctly */
/* Obtain the pass number, which also turns on the PNG_INTERLACE flag in
/* SEQUENTIAL_READ */
/* Read the end of the PNG file.  Will not read past the end of the
/* If png_read_end is called in the middle of reading the rows there may
/* Report invalid palette index; added at libng-1.5.10 */
/* Zero length IDATs are legal after the last IDAT has been
/* SEQUENTIAL_READ */
/* Free all memory used in the read struct */
/* NOTE: the 'setjmp' buffer may still be allocated and the memory and error
/* Free all memory used by the read */
/* libpng 1.6.0: use the API to destroy info structs to ensure consistent
/* png_read_info() gives us all of the information from the
/* -------------- image transformations start here ------------------- */
/* libpng 1.6.10: add code to cause a png_app_error if a selected TRANSFORM
/* Tell libpng to strip 16-bit/color files down to 8 bits per color.
/* Added at libpng-1.5.4. "strip_16" produces the same result that it
/* If both SCALE and STRIP are required pngrtran will effectively cancel the
/* Strip alpha bytes from the input data without combining with
/* Extract multiple pixels with bit depths of 1, 2, or 4 from a single
/* Change the order of packed pixels to least significant bit first
/* Expand paletted colors into true RGB triplets
/* We don't handle background color or gamma transformation or quantizing.
/* Invert monochrome files to have 0 as white and 1 as black
/* If you want to shift the pixel values from the range [0,255] or
/* Flip the RGB pixels to BGR (or RGBA to BGRA) */
/* Swap the RGBA or GA data to ARGB or AG (or BGRA to ABGR) */
/* Swap bytes of 16-bit files to least significant byte first */
/* Added at libpng-1.2.41 */
/* Invert the alpha channel from opacity to transparency */
/* Added at libpng-1.2.41 */
/* Expand grayscale image to RGB */
/* Added at libpng-1.5.4 */
/* We don't handle adding filler bytes */
/* We use png_read_image and rely on that for interlace handling, but we also
/* Optional call to gamma correct and add the background to the palette
/* -------------- image transformations end here ------------------- */
/* Read rest of file, and get additional chunks in info_ptr - REQUIRED */
/* INFO_IMAGE */
/* SEQUENTIAL_READ */
/* SIMPLIFIED READ
/* Arguments to png_image_finish_read: */
/* Encoding of PNG data (used by the color-map code) */
/* File encoding not yet known */
/* 8-bit encoded to sRGB gamma */
/* 16-bit linear: not encoded, NOT pre-multiplied! */
/* 8-bit encoded to file gamma, not sRGB or linear */
/* 8-bit linear: only from a file value */
/* Color-map processing: after libpng has run on the PNG image further
/* Process GA data to a color-map with alpha */
/* Process GA data to a background index */
/* Process RGB data */
/* Process RGBA data */
/* The following document where the background is for each processing case. */
/* Arguments: */
/* Local variables: */
/* step between rows */
/* E_ values above */
/* For P_FILE, reciprocal of gamma */
/* PNG_CMAP_ values above */
/* Do all the *safe* initialization - 'safe' means that png_error won't be
/* And set the rest of the structure to NULL to ensure that the various
/* Error clean up */
/* Utility to find the base format of a PNG file from a png_struct. */
/* Use png_ptr here, not info_ptr, because by examination png_handle_tRNS
/* Is the given gamma significantly different from sRGB?  The test is the same
/* An uninitialized gamma is assumed to be sRGB for the simplified API. */
/* i.e. *2.2, rounded */);
/* Do the main body of a 'png_image_begin_read' function; read the PNG file
/*warn*/);
/* Do this the fast way; just read directly out of png_struct. */
/* Does the colorspace match sRGB?  If there is no color endpoint
/* We need the maximum number of entries regardless of the format the
/* This is slightly evil, but png_init_io doesn't do anything other
/* Clean up: just the opened file. */
/* STDIO */
/* Now set the IO functions to read from the memory buffer and
/* Utility function to skip chunks that are not used by the simplified image
/* Prepare the reader to ignore all recognized chunks whose data will not
/* bKGD */
/* cHRM */
/* gAMA */
/* iCCP */
/* sBIT */
/* sRGB */
/* Ignore unknown chunks and all other chunks except for the
/* But do not ignore image data handling chunks */
/*SAFE*/(sizeof chunks_to_process)/5);
/* HANDLE_AS_UNKNOWN */
/* The following macro gives the exact rounded answer for all values in the
/* Utility functions to make particular color-maps */
/* double check */
/* must be the file encoding */
/* The file value is composed on the background, the background has the given
/* The alpha is always an 8-bit value (it comes from the palette), the value
/* Scale to 65535; divide by 255, approximately (in fact this is extremely
/* Now scaled by 65535 */
/* P_sRGB */
/* NOTE: P_LINEAR values to this routine must be 16-bit, but P_FILE values must
/* Update the cache with whether the file gamma is significantly different
/* Note that the cached value may be P_FILE too, but if it is then the
/* This encoding occurs quite frequently in test cases because PngSuite
/* The values are 8-bit sRGB values, but must be converted to 16-bit
/* This is set if the color isn't gray but the output is. */
/* NOTE: these values are copied from png_do_rgb_to_gray */
/* y is scaled by 32768, we need it scaled by 255: */
/* Store the value. */
/* The linear 16-bit values must be pre-multiplied by the alpha channel
/* FALL THROUGH */
/* FALL THROUGH */
/* output encoding is P_sRGB */
/* Alpha is retained, the output will be a color-map with entries
// opaque
// The 231 entries are selected to make the math below work:
// transparent
// partially opaque
/* 255 is used here for the component values for consistency with the code
/* Build a 6x6x6 opaque RGB cube */
/* Return a palette index to the above palette given three 8-bit sRGB values. */
/* Output processing option */
/* Encoding libpng must produce */
/* Background information; the background color and the index of this color
/* Flags to accumulate things that need to be done to the input. */
/* Exclude the NYI feature of compositing onto a color-mapped buffer; it is
/* alpha in input */ &&
/* no alpha in output */)
/* compose on black */
/* no way to remove it */)
/* Get a copy of the background color (this avoids repeating the checks
/* Default the input file gamma if required - this is necessary because
/* Do this directly, not using the png_colorspace functions, to ensure
/* Decide what to do based on the PNG color type of the input data.  The
/* There at most 256 colors in the output, regardless of
/*ignore*/, back_alpha = 0;
/* If there is a tRNS chunk then this either selects a transparent
/* png_create_colormap_entry just takes an RGBA and writes the
/* 'i' is a file value.  While this will result in duplicated
/*8-bit with file gamma*/);
/* Else this entry is transparent.  The colors don't matter if
/* We need libpng to preserve the original encoding. */
/* The rows from libpng, while technically gray values, are now also
/* bit depth is 16 */
/* The 16-bit input values can be converted directly to 8-bit gamma
/* Background is gray; no special processing will be
/* And make sure the corresponding palette entry
/* The background passed to libpng, however, must be the
/*unused*/
/* NOTE: does this work without expanding tRNS to alpha?
/*need_expand*/,
/*gamma: not used*/);
/* Coverity claims that output_encoding cannot be 2 (P_LINEAR)
/* output_processing means that the libpng-processed row will be
/* And set (overwrite) color-map entry 254 to the actual
/* 8-bit or 16-bit PNG with two channels - gray and alpha.  A minimum
/* alpha is removed */
/* Alpha must be removed as the PNG data is processed when the
/* Background is gray; no special processing will be required. */
/* And make sure the corresponding palette entry matches. */
/* The background passed to libpng, however, must be the sRGB
/*unused*/
/*need_expand*/,
/*gamma: not used*/);
/* This is the same as png_make_ga_colormap, above, except that
/* NOTE: this preserves the full precision of the application
/* Coverity claims that output_encoding cannot be 2 (P_LINEAR)
/* For non-opaque input composite on the sRGB background - this
/* else already linear */
/* This may produce a value not exactly matching the
/* PNG_sRGB_FROM_LINEAR expects a 16-bit linear value scaled
/* Exclude the case where the output is gray; we can always handle this
/* The color-map will be grayscale, so we may as well convert the
/* The output will now be one or two 8-bit gray or gray+alpha
/* Both input and output have an alpha channel, so no background
/* Either the input or the output has no alpha channel, so there
/* Ideally this code would use libpng to do the gamma correction,
/* But if the input has alpha or transparency it must be removed
/* We need to ensure that the application background exists in
/* from the fixup above */
/* The app supplied a gray which is in output_encoding, we
/* now P_LINEAR */
/* now P_FILE */
/* And make sure the corresponding palette entry contains
/*unused*/, output_encoding);
/* And make sure the corresponding palette entry matches.
/*unused*/, P_LINEAR);
/* The background passed to libpng, however, must be the
/*unused*/
/* NOTE: the following is apparently a bug in libpng. Without
/*need_expand*/,
/*gamma: not used*/);
/* output is color */
/* We could use png_quantize here so long as there is no transparent
/* Is there any transparency or alpha? */
/* Is there alpha in the output too?  If so all four channels are
/* Add a transparent entry. */
/* This is stored as the background index for the processing
/* Add 27 r,g,b entries each with alpha 0.5. */
/* This generates components with the values 0, 127 and
/* Alpha/transparency must be removed.  The background must
/* sRGB background */
/*unused*/, output_encoding);
/* Compare the newly-created color-map entry with the one the
/* The background color must be added. */
/* Add 27 r,g,b entries each with created by composing with
/* This generates components with the values 0, 127
/*unused*/, output_encoding);
/* background color is in the standard color-map */
/*unused*/
/*need_expand*/,
/*gamma: not used*/);
/* no alpha or transparency in the input */
/* Alpha in the output is irrelevant, simply map the opaque input
/* It's already got a color-map.  It may be necessary to eliminate the
/* Just in case: */
/* Don't change from color-map indices */
/* Must compose the PNG file color in the color-map entry
/*8-bit*/);
/* The PNG data may have indices packed in fewer than 8 bits, it
/*NOT REACHED*/
/* Now deal with the output processing */
/* Change to 8-bit sRGB */
/* FALL THROUGH */
/* Double check using the recorded background index */
/*ok*/;
/* The final part of the color-map read called from png_image_finish_read. */
/* Called when the libpng data must be transformed into the color-mapped
/* The row may be empty for a short image: */
/* Read read the libpng data into the temporary buffer. */
/* Now process the row according to the processing option, note
/* The data is always in the PNG order */
/* NOTE: this code is copied as a comment in
/* opaque */
/* transparent */
/* partially opaque */
/* Because the alpha entries only hold alpha==0.5 values
/* Likewise there are three entries for each of r, g
/* Here are how the values map:
/* red */
/* green */
/* blue */
/* As a flag */
/* Update the 'info' structure and make sure the result is as required; first
/* The expected output can be deduced from the colormap_processing option. */
/* Output must be one channel and one byte per pixel, the output
/* Output must be two channels and the 'G' one must be sRGB, the latter
/* Output must be 8-bit sRGB encoded RGB */
/* Output must be 8-bit sRGB encoded RGBA */
/* 216 + 1 + 27 */)
/* goto bad_output; */
/* FALL THROUGH */
/* Now read the rows.  Do this here if it is possible to read directly into
/* The following expression is designed to work correctly whether it gives
/* Just the row reading part of png_image_read. */
/* The row may be empty for a short image: */
/* Read the row, which is packed: */
/* Now do the composition on each pixel in this row. */
/* else no change to the output */
/* else just use component */
/* This is PNG_OPTIMIZED_ALPHA, the component value
/* =65535 */
/* So 'component' is scaled by 255*65535 and is
/* components and alpha channel */
/* The do_local_background case; called when all the following transforms are to
/* Double check the convoluted logic below.  We expect to get here with
/* Expect the 8-bit case to always remove the alpha channel */
/* Use direct access to info_ptr here because otherwise the simplified API
/* 8-bit sRGB gray values with an alpha channel; the alpha channel is
/* The row may be empty for a short image: */
/* Read the row, which is packed: */
/* Now do the composition on each pixel in this row. */
/* else no change to the output */
/* else just use component */
/* Since PNG_OPTIMIZED_ALPHA was not set it is
/* gray and alpha channel */
/* constant background value */
/* Read the row, which is packed: */
/* Now do the composition on each pixel in this row. */
/* else use background */
/* else just use component */
/* gray and alpha channel */
/* 16-bit linear with pre-multiplied alpha; the pre-multiplication must
/* The division by two is safe because the caller passed in a
/* The 'x' start and step are adjusted to output components here.
/* The row may be empty for a short image: */
/* Read the row, which is packed: */
/* Now do the pre-multiplication on each pixel in this row.
/* else 0 */
/* else just use component */
/* components and alpha channel */
/* The guts of png_image_finish_read as a png_safe_execute callback. */
/* to avoid double gamma correction bug */
/* Add transforms to ensure the correct output format is produced then check
/* Now check the format to see if it was modified. */
/* removed by png_set_expand */;
/* alpha mode */
/* Do this first so that we have a record if rgb to gray is happening. */
/* gray<->color transformation required. */
/* libpng can't do both rgb to gray and
/*maybe*/;
/* Set the gamma appropriately, linear for 16-bit input, sRGB otherwise.
/* Call png_set_alpha_mode to set the default for the input gamma; the
/* If there *is* an alpha channel in the input it must be multiplied
/* associated alpha */
/* If 'do_local_background' is set check for the presence of gamma
/* This is 'png_gamma_threshold' from pngrtran.c; the test used for
/*required*/;
/* prevent libpng doing it */
/* else leave as 1 for the checks below */
/* If the bit-depth changes then handle that here. */
/*16-bit output*/)
/* 8-bit output */
/* Now the background/alpha channel changes. */
/* Removing an alpha channel requires composition for the 8-bit
/* If RGB->gray is happening the alpha channel must be left and the
/*required*/;
/* 16-bit output: just remove the channel */
/* compose on black (well, pre-multiply) */
/* 8-bit output: do an appropriate compose */
/*unused*/
/* This is always an 8-bit sRGB value, using the 'green' channel
/*need_expand*/,
/*gamma: not used*/);
/* compose on row: implemented below. */
/* This leaves the alpha channel in the output, so it has to be
/* output needs an alpha channel */
/* This is tricky because it happens before the swap operation has
/* opaque filler */
/* This stops the (irrelevant) call to swap_alpha below. */
/* Now set the alpha mode correctly; this is always done, even if there is
/* Check only the output format; PNG is never BGR; don't do this if
/* Only relevant if there is an alpha channel - it's particularly
/* Disable this if doing a local background,
/* If the *output* is 16-bit then we need to check for a byte-swap on this
/* If change is not now 0 some transformation is missing - error out. */
/* Update the 'info' structure and make sure the result is as required; first
/* do_local_compose removes this channel below. */
/* do_local_background does the same if required. */
/* internal error */
/* This is actually an internal error. */
/* Now read the rows.  If do_local_compose is set then it is necessary to use
/* The following expression is designed to work correctly whether it gives
/* Choose the correct 'end' routine; for the color-map case all the
/* SIMPLIFIED_READ */
/* READ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libpng\pngrio.c
/* pngrio.c - functions for data input
/* Read the data from whatever input you are using.  The default routine
/* PRIVATE */
/* This is the function that does the actual reading of data.  If you are
/* fread() returns 0 on error, so it is OK to store this in a png_size_t
/* This function allows the application to supply a new input function
/* It is an error to write to a read device */
/* READ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libpng\pngrtran.c
/* pngrtran.c - transforms the data in a row for PNG readers
/* Set the action on getting a CRC error for an ancillary or critical chunk. */
/* Tell libpng how we react to CRC errors in critical chunks */
/* Leave setting as is */
/* Warn/use data */
/* Quiet/use data */
/* Not a valid action for critical data */
/* Error/quit */
/* Tell libpng how we react to CRC errors in ancillary chunks */
/* Leave setting as is */
/* Warn/use data */
/* Quiet/use data */
/* Error/quit */
/* Warn/discard data */
/* Is it OK to set a transformation now?  Only if png_start_read_image or
/* Turn on failure to initialize correctly for all transforms. */
/* Ok */
/* no png_error possible! */
/* Handle alpha and tRNS via a background color */
/* FLOATING_POINT */
/* READ_BACKGROUND */
/* Scale 16-bit depth files to 8-bit depth.  If both of these are set then the
/* Chop 16-bit depth files to 8-bit depth */
/* Check for flag values.  The main reason for having the old Mac value as a
/* If there is no sRGB support this just sets the gamma to the standard
/* The following silently ignores cases where fixed point (times 100,000)
/* This preserves -1 and -2 exactly: */
/* READ_ALPHA_MODE || READ_GAMMA */
/*screen*/);
/* Validate the value to ensure it is in a reasonable range. The value
/* The default file gamma is the inverse of the output gamma; the output
/* There are really 8 possibilities here, composed of any combination
/* default: png standard */
/* No compose, but it may be set by png_set_background! */
/* color channels premultiplied */
/* The output is linear: */
/* associated, non-opaque pixels linear */
/* output_gamma records the encoding of opaque pixels! */
/* associated, non-linear, alpha encoded */
/* Only set the default gamma if the file gamma has not been set (this has
/* But always set the output gamma: */
/* Finally, if pre-multiplying, set the background fields to achieve the
/* And obtain alpha pre-multiplication by composing on black: */
/* just in case */
/* Dither file to 8-bit.  Supply a palette, the current number
/* This is easy enough, just throw out the least used colors.
/* Initialize an array to sort colors */
/* Initialize the quantize_sort array */
/* Find the least used palette entries by starting a
/* To stop early if the list is pre-sorted */
/* Swap the palette around, and set up a table, if necessary */
/* Put all the useful colors within the max, but don't
/* Move all the used colors inside the max limit, and
/* Only move the colors we need to */
/* Indicate where the color went */
/* Find closest color for those colors we are not using */
/* Find the closest color to one we threw out */
/* Point to closest color */
/* This is much harder to do simply (and quickly).  Perhaps
/* Initialize palette index arrays */
/* Initialize the sort array */
/* Initial wild guess at how far apart the farthest pixel
/* int dr = abs(ir - r); */
/* int dg = abs(ig - g); */
/* int db = abs(ib - b); */
/* READ_QUANTIZE */
/* New in libpng-1.5.4 - reserve particular negative values as flags. */
/*screen*/);
/*file*/);
/* Checking the gamma values for being >0 was added in 1.5.4 along with the
/* Set the gamma values unconditionally - this overrides the value in the PNG
/* FLOATING_POINT */
/* READ_GAMMA */
/* Expand paletted images to RGB, expand grayscale images of
/* GRR 19990627:  the following three functions currently are identical
/* Expand paletted images to RGB. */
/* Expand grayscale images of less than 8-bit depth to 8 bits. */
/* Expand tRNS chunks to alpha channels. */
/* READ_EXPAND */
/* Expand to 16-bit channels, expand the tRNS chunk too (because otherwise
/* Because rgb must be 8 bits or more: */
/* Need the IHDR here because of the check on color_type below. */
/* TODO: fix this */
/* Make this an error in 1.6 because otherwise the application may assume
/* png_ptr->transformations &= ~PNG_RGB_TO_GRAY; */
/* NOTE: this calculation does not round, but this behavior is retained
/* Use the defaults, from the cHRM chunk if set, else the historical
/* png_ptr->rgb_to_gray_blue_coeff  = 2366; */
/* Convert a RGB image to a grayscale of the same width.  This allows us,
/* FLOATING POINT */
/* RGB_TO_GRAY */
/* In the case of gamma transformations only do transformations on images where
/* PRIVATE */
/* PNG_GAMMA_THRESHOLD is the threshold for performing gamma
/* Initialize everything needed for the read.  This includes modifying
/* For the moment 'png_init_palette_transformations' and
/* PRIVATE */
/* Called to handle the (input) palette case.  In png_do_read_transformations
/* Ignore if all the entries are opaque (unlikely!) */
/* If no alpha we can optimize. */
/* Any alpha means background and associative alpha processing is
/* png_set_background handling - deals with the complexity of whether the
/* The following code cannot be entered in the alpha pre-multiplication case
/* Invert the alpha channel (in tRNS) unless the pixels are
/* READ_INVERT_ALPHA */
/* background expand and (therefore) no alpha association. */
/* READ_EXPAND && READ_BACKGROUND */
/* PRIVATE */
/* Added to libpng-1.5.4: check the color type to determine whether there
/* If no alpha we can optimize. */
/* Any alpha means background and associative alpha processing is
/* png_set_background handling - deals with the complexity of whether the
/* The following code cannot be entered in the alpha pre-multiplication case
/* i.e., GRAY or GRAY_ALPHA */
/* Expand background and tRNS chunks */
/* FALL THROUGH (Already 8 bits) */
/* Already a full 16 bits */
/* background expand and (therefore) no alpha association. */
/* READ_EXPAND && READ_BACKGROUND */
/* PRIVATE */
/* This internal function is called from png_read_start_row in pngrutil.c
/* Prior to 1.5.4 these tests were performed from png_set_gamma, 1.5.4 adds
/* The following temporary indicates if overall gamma correction is
/* has been set */
/* screen set too */
/* Assume the output matches the input; a long time default behavior
/* The converse - assume the file matches the screen, note that this
/* neither are set */
/* Just in case the following prevents any processing - file and screen
/* We have a gamma value now. */
/* Now turn the gamma transformation on or off as appropriate.  Notice
/* Certain transformations have the effect of preventing other
/* Stripping the alpha channel happens immediately after the 'expand'
/* Kill the tRNS chunk itself too.  Prior to 1.5.4 this did not happen
/* STRIP_ALPHA supported, no COMPOSE */
/* If the screen gamma is about 1.0 then the OPTIMIZE_ALPHA and ENCODE_ALPHA
/* Make sure the coefficients for the rgb to gray conversion are set
/* Detect gray background and attempt to enable optimization for
/* PNG_BACKGROUND_EXPAND: the background is in the file color space, so if
/* PNG_COMPOSE: png_set_background was called with need_expand false,
/* READ_EXPAND && READ_BACKGROUND */
/* READ_GRAY_TO_RGB */
/* For indexed PNG data (PNG_COLOR_TYPE_PALETTE) many of the transformations
/* TODO: fix this.  Because the expand_16 operation is after the compose
/* READ_BACKGROUND && READ_EXPAND_16 */
/* On the other hand, if a 16-bit file is to be reduced to 8-bits per
/* NOTE: below 'PNG_READ_ALPHA_MODE_SUPPORTED' is presumed to also enable the
/* Includes ALPHA_MODE */
/* This needs to change - in the palette image case a whole set of tables are
/* Issue a warning about this combination: because RGB_TO_GRAY is
/* We don't get to here unless there is a tRNS chunk with non-opaque
/* back_1 */
/* back */
/* if (png_ptr->trans_alpha[i] != 0xff) */
/* Prevent the transformations being done again.
/* color_type == PNG_COLOR_TYPE_PALETTE */
/* if (png_ptr->background_gamma_type!=PNG_BACKGROUND_GAMMA_UNKNOWN) */
/* color_type != PNG_COLOR_TYPE_PALETTE */
/* Correction to linear */
/* Correction to screen */
/* gs = PNG_FP_1; */
/* RGB or RGBA with color background */
/* GRAY, GRAY ALPHA, RGB, or RGBA with gray background */
/* The background is now in screen gamma: */
/* color_type != PNG_COLOR_TYPE_PALETTE */
/* png_ptr->transformations & PNG_BACKGROUND */
/* Transformation does not include PNG_BACKGROUND */
/* READ_BACKGROUND */
/* RGB_TO_GRAY needs to have non-gamma-corrected values! */
/* NOTE: there are other transformations that should probably be in
/* Done the gamma correction. */
/* color_type == PALETTE && !PNG_BACKGROUND transformation */
/* READ_GAMMA */
/* No GAMMA transformation (see the hanging else 4 lines above) */
/* The png_composite() macro is defined in png.h */
/* READ_BACKGROUND */
/* significant bits can be in the range 1 to 7 for a meaninful result, if
/* READ_SHIFT */
/* Modify the info structure to reflect the transformations.  The
/* PRIVATE */
/* This check must match what actually happens in
/* The following is almost certainly wrong unless the background value is in
/* The following used to be conditional on PNG_GAMMA (prior to 1.5.4),
/* No 16 bit support: force chopping 16-bit input down to 8, in this case
/* For compatibility with previous versions use the strip method by
/* !READ_16BIT */
/* STRIP_ALPHA and FILLER allowed:  MASK_ALPHA bit stripped above */
/* If adding a true alpha channel not just filler */
/* Adding in 1.5.4: cache the above value in png_struct so that we can later
/* Unpack pixels of 1, 2, or 4 bits per pixel into 1 byte per pixel,
/* Reverse the effects of png_do_shift.  This routine merely shifts the
/* The palette case has already been handled in the _init routine. */
/* A shift of more than the bit depth is an error condition but it
/* Must be 1bpp gray: should not be here! */
/* NOTREACHED */
/* Must be 2bpp gray */
/* assert(channels == 1 && shift[0] == 1) */
/* Must be 4bpp gray */
/* assert(channels == 1) */
/* Single byte components, G, GA, RGB, RGBA */
/* Double byte components, G, GA, RGB, RGBA */
/* Scale rows of bit depth 16 down to 8 accurately */
/* source */
/* destination */
/* end+1 */
/* The input is an array of 16 bit components, these must be scaled to
/* must be signed! */
/* Simply discard the low byte.  This was the default behavior prior
/* source */
/* destination */
/* end+1 */
/* skip low byte */
/* This converts from RGBA to ARGB */
/* This converts from RRGGBBAA to AARRGGBB */
/* This converts from GA to AG */
/* This converts from GGAA to AAGG */
/* This inverts the alpha channel in RGBA */
/*          This does nothing:
/* This inverts the alpha channel in RRGGBBAA */
/*          This does nothing:
/* This inverts the alpha channel in GA */
/* This inverts the alpha channel in GGAA */
/*
/* Add filler channel if we have RGB color */
/* This changes the data from G to GX */
/* This changes the data from G to XG */
/* This changes the data from GG to GGXX */
/* This changes the data from GG to XXGG */
/* COLOR_TYPE == GRAY */
/* This changes the data from RGB to RGBX */
/* This changes the data from RGB to XRGB */
/* This changes the data from RRGGBB to RRGGBBXX */
/* This changes the data from RRGGBB to XXRRGGBB */
/* COLOR_TYPE == RGB */
/* Expand grayscale files to RGB, with or without alpha */
/* This changes G to RGB */
/* This changes GG to RRGGBB */
/* This changes GA to RGBA */
/* This changes GGAA to RRGGBBAA */
/* Reduce RGB files to grayscale, with or without alpha
//www.inforamp.net/~poynton/>  (THIS LINK IS DEAD June 2008 but
//web.archive.org/web/20000816232553/http://www.inforamp.net/
//www.poynton.com/notes/colour_and_gamma/>
/* Notice that gamma to/from 1 are not necessarily inverses (if
/* If there is no overall correction the table will not be
/* NOTE: this is the historical approach which simply
/* RGB bit_depth == 16 */
/* From 1.5.5 in the 16 bit case do the accurate conversion even
/* Replace any alpha or transparency with the supplied background color.
/* Background is already in screen gamma */
/* if (row_info->bit_depth == 16) */
/* Background is already in screen gamma */
/* Background is already in screen gamma */
/* if (png_ptr->bit_depth == 16) */
/* Background is already in screen gamma */
/* Background is already in screen gamma */
/* if (row_info->bit_depth == 16) */
/* Background is already in screen gamma */
/* READ_BACKGROUND || READ_ALPHA_MODE */
/* Gamma correct the image, avoiding the alpha channel.  Make sure
/* if (row_info->bit_depth == 16) */
/* if (row_info->bit_depth == 16) */
/* if (row_info->bit_depth == 16) */
/* Encode the alpha channel to the output gamma (the input channel is always
/* The alpha channel is the last component: */
/* The alpha channel is the last component: */
/* Only get to here if called with a weird row_info; no harm has been done,
/* Expands a palette row to an RGB or RGBA row depending
/* If the bit depth < 8, it is expanded to 8.  Also, if the already
/* If the bit depth is 8 and the color type is not a palette type expand the
/* The row have a sequence of bytes containing [0..255] and we need
/* source, last byte + 1 */
/* destination, end + 1 */
/* This looks real messy, but the compiler will reduce
/* READ_QUANTIZE */
/* Transform the row.  The order of transformations is significant,
/* PRIVATE */
/* Prior to 1.5.4 this output row/pass where the NULL pointer is, but this
/* The following is debugging; prior to 1.5.4 the code was never compiled in;
/* Application has failed to call either png_read_start_image() or
/* at_start == false, because SWAP_ALPHA happens later */);
/* From Andreas Dilger e-mail to png-implement, 26 March 1998:
/* If gray -> RGB, do so now only if background is non-gray; else do later
/* Because RGB_TO_GRAY does the gamma transform. */
/* Because PNG_COMPOSE does the gamma transform if there is something to
/* Because png_init_read_transformations transforms the palette, unless
/* at_start == false, because SWAP_ALPHA happens later */);
/* There is no harm in doing both of these because only one has any effect,
/* READ_QUANTIZE */
/* Do the expansion now, after all the arithmetic has been done.  Notice
/* NOTE: moved here in 1.5.4 (from much later in this list.) */
/* Added at libpng-1.5.10 */
/* User read transform function */
/* png_ptr */
/* row_info: */
/*  png_uint_32 width;       width of row */
/*  png_size_t rowbytes;     number of bytes in row */
/*  png_byte color_type;     color type of pixels */
/*  png_byte bit_depth;      bit depth of samples */
/*  png_byte channels;       number of channels (1-4) */
/*  png_byte pixel_depth;    bits per pixel (depth*channels) */
/* start of pixel data for row */
/* READ_TRANSFORMS */
/* READ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libpng\pngrutil.c
/* pngrutil.c - utilities to read a PNG file
/* The following is a variation on the above for use with the fixed
/* PRIVATE */
/* known to be in range */
/* The caller can turn off the warning by passing NULL. */
/* NOTE: the read macros will obscure these definitions, so that if
/* Grab an unsigned 32-bit integer from a buffer in big-endian format. */
/* Grab a signed 32-bit integer from a buffer in big-endian format.  The
/* non-negative */
/* 2's complement: -x = ~x+1 */
/* Grab an unsigned 16-bit integer from a buffer in big-endian format. */
/* ANSI-C requires an int value to accomodate at least 16 bits so this
/* READ_INT_FUNCTIONS */
/* Read and check the PNG file signature */
/* PRIVATE */
/* Exit if the user application does not expect a signature. */
/* The signature must be serialized in a single I/O call. */
/* Read the chunk header (length + type name).
/* PRIVATE */
/* Read the length and the chunk name.
/* Put the chunk name into png_ptr->chunk_name. */
/* Reset the crc and run it over the chunk name. */
/* Check to see if chunk name is valid. */
/* Read data, and (optionally) run it through the CRC. */
/* PRIVATE */
/* Optionally skip data and then check the CRC.  Depending on whether we
/* PRIVATE */
/* The size of the local buffer for inflate is a good guess as to a
/* Compare the CRC stored in the PNG file with that calculated by libpng from
/* PRIVATE */
/* critical */
/* The chunk CRC must be serialized in a single I/O call. */
/* Manage the read buffer; this simply reallocates the buffer if it is not small
/* else silent */
/* READ_iCCP|iTXt|pCAL|sCAL|sPLT|tEXt|zTXt|SEQUENTIAL_READ */
/* png_inflate_claim: claim the zstream for some nefarious purpose that involves
/* So the message that results is "<chunk> using zstream"; this is an
/* Implementation note: unlike 'png_deflate_claim' this internal function
/* zlib return code */
/* Set this for safety, just in case the previous owner left pointers to
/* png_inflate now returns zlib error codes including Z_OK and Z_STREAM_END to
/* INPUT: */ png_const_bytep input, png_uint_32p input_size_ptr,
/* OUTPUT: */ png_bytep output, png_alloc_size_t *output_size_ptr)
/* Else not claimed */
/* zlib can't necessarily handle more than 65535 bytes at once (i.e. it
/* avail_in and avail_out are set below from 'size' */
/* Read directly into the output if it is available (this is set to
/* zlib INPUT BUFFER */
/* The setting of 'avail_in' used to be outside the loop; by setting it
/* not consumed last time */
/* safe: < than ZLIB_IO_MAX */
/* zlib OUTPUT BUFFER */
/* not written last time */
/* maximum zlib can process */
/* Reset the output buffer each time round if output is NULL and
/* safe: < ZLIB_IO_MAX */
/* zlib inflate call */
/* In fact 'avail_out' may be 0 at this point, that happens at the end
/* For safety kill the local buffer pointer now */
/* Claw back the 'size' and 'remaining_space' byte counts. */
/* Update the input and output sizes; the updated values are the amount
/* Ensure png_ptr->zstream.msg is set (even in the success case!) */
/* This is a bad internal error.  The recovery assigns to the zstream msg
/*
/* must be initialized to the maximum! */,
/*add a '\0' to the end of the uncompressed data*/)
/* TODO: implement different limits for different types of chunk.
/* Now try to claim the stream. */
/*finish*/,
/* input: */ png_ptr->read_buffer + prefix_size, &lzsize,
/* output: */ NULL, newlength);
/* Use 'inflateReset' here, not 'inflateReset2' because this
/* Because of the limit checks above we know that the new,
/*finish*/,
/* freed below */
/* The size changed on the second read, there can be no
/* for safety */
/* Free the text pointer (this is the old read_buffer on
/* This really is very benign, but it's still an error because
/* Out of memory allocating the buffer */
/* inflateReset failed, store the error message */
/* Release the claimed stream */
/* the claim failed */ if (ret == Z_STREAM_END) /* impossible! */
/* Application/configuration limits exceeded */
/* READ_COMPRESSED_TEXT */
/* Perform a partial read and decompress, producing 'avail_out' bytes and
/* next_in and avail_in must have been initialized by the caller. */
/* set in the loop */
/* Use Z_SYNC_FLUSH when there is no more chunk data to ensure that all
/* Should not be required, but is safe */
/* Ensure the error message pointer is always set: */
/* Read and check the IDHR chunk */
/* PRIVATE */
/* Check the length */
/* Set internal variables */
/* Find number of channels */
/* invalid, png_set_IHDR calls png_error */
/* Set up other useful info */
/* Read and check the palette */
/* PRIVATE */
/* Moved to before the 'after IDAT' check below because otherwise duplicate
/* This is benign because the non-benign error happened before, when an
/* The cast is safe because 'length' is less than 3*PNG_MAX_PALETTE_LENGTH */
/* Don't depend upon png_color being any order */
/* If we actually need the PLTE chunk (ie for a paletted image), we do
/* Only if we have a CRC error */
/* If we don't want to use the data from an ancillary chunk,
/* Otherwise, we (optionally) emit a warning and use the chunk. */
/* TODO: png_set_PLTE has the side effect of setting png_ptr->palette to its
/* The three chunks, bKGD, hIST and tRNS *must* appear after PLTE and before
/* Cancel this because otherwise it would be used if the transforms
/* PRIVATE */
/* PRIVATE */
/* PRIVATE */
/* PRIVATE */
/* If a colorspace error has already been output skip this chunk */
/*prefer cHRM values*/);
/* PRIVATE */
/* If a colorspace error has already been output skip this chunk */
/* Only one sRGB or iCCP chunk is allowed, use the HAVE_INTENT flag to detect
/* READ_sRGB */
/* PRIVATE */
/* Note: this does not properly handle profiles that are > 64K under DOS */
/* error message output, or no error */
/* crc checked */
/* Consistent with all the above colorspace handling an obviously *invalid*
/* If a colorspace error has already been output skip this chunk */
/* Only one sRGB or iCCP chunk is allowed, use the HAVE_INTENT flag to detect
/* Find the keyword; the keyword plus separator and compression method
/* maximum */
/* TODO: make the keyword checking common */
/* We only understand '0' compression - deflate - so if we get a
/*finish: don't, because the output is too small*/);
/* We have the ICC profile header; do the basic header checks.
/* The length is apparently ok, so we can check the 132
/* Now read the tag table; a variable size buffer is
/*silent*/);
/* Still expect a buffer error because we expect
/* The profile has been validated for basic
/*finish*/);
/* But otherwise allow extra data: */
/* This can be handled completely, so
/* Check for a match against sRGB */
/* Steal the profile for info_ptr. */
/*steal*/
/* else the profile remains in the read
/* else png_icc_check_tag_table output an error */
/* profile truncated */
/* else png_icc_check_header output an error */
/* else png_icc_check_length output an error */
/* profile truncated */
/* Release the stream */
/* png_inflate_claim failed */
/* or missing */
/* Failure: the reason is in 'errmsg' */
/* else already output */
/* READ_iCCP */
/* PRIVATE */
/* Note: this does not properly handle chunks that are > 64K under DOS */
/*silent*/);
/* WARNING: this may break if size_t is less than 32 bits; it is assumed
/* Empty loop to find end of name */ ;
/* A sample depth should follow the separator, and we should be on it  */
/* This must fit in a png_uint_32 because it is derived from the original
/* Integrity-check the data length */
/* Discard all chunk data except the name and stash that */
/* READ_sPLT */
/* PRIVATE */
/* TODO: is this actually an error in the ISO spec? */
/* TODO: this is a horrible side effect in the palette case because the
/* PRIVATE */
/* We convert the index value into RGB components so that we can allow
/* GRAY */
/* PRIVATE */
/* PRIVATE */
/* PRIVATE */
/* Read the pCAL chunk (described in the PNG Extensions document) */
/* PRIVATE */
/*silent*/);
/* Null terminate the last string */
/* Empty loop */ ;
/* We need to have at least 12 bytes after the purpose string
/* Check that we have the right number of parameters for known
/* Empty loop to move past the units string. */ ;
/* Get pointers to the start of each parameter string. */
/* Skip the null string terminator from previous parameter. */
/* Empty loop to move past each parameter string */ ;
/* Make sure we haven't run out of data yet */
/* Read the sCAL chunk */
/* PRIVATE */
/* Need unit type, width, \0, height: minimum 4 bytes */
/*silent*/);
/* Null terminate the last string */
/* Validate the unit. */
/* Validate the ASCII numbers, need two ASCII numbers separated by
/* This is the (only) success case. */
/* PRIVATE */
/* Note: this does not properly handle chunks that are > 64K under DOS */
/* PRIVATE */
/*warn*/);
/* Empty loop to find end of key */ ;
/* Note: this does not correctly handle chunks that are > 64K under DOS */
/* PRIVATE */
/*silent*/);
/* TODO: also check that the keyword contents match the spec! */
/* Empty loop to find end of name */ ;
/* zTXt must have some LZ data after the keyword, although it may expand to
/* TODO: at present png_decompress_chunk imposes a single application
/*terminate*/) == Z_STREAM_END)
/* It worked; png_ptr->read_buffer now looks like a tEXt chunk except
/* Note: this does not correctly handle chunks that are > 64K under DOS */
/* PRIVATE */
/*warn*/);
/* First the keyword. */
/* Empty loop */ ;
/* Perform a basic check on the keyword length here. */
/* Expect keyword, compression flag, compression type, language, translated
/* Now the language tag */
/* Empty loop */ ;
/* WARNING: the length may be invalid here, this is checked below. */
/* Empty loop */ ;
/* prefix_length should now be at the trailing '\0' of the translated
/* TODO: at present png_decompress_chunk imposes a single application
/*terminate*/) == Z_STREAM_END)
/* Utility function for png_handle_unknown; set up png_ptr::unknown_chunk */
/* The following is safe because of the PNG_SIZE_MAX init above */
/*SAFE*/;
/* 'mode' is a flag array, only the bottom four bits matter here */
/*SAFE*/;
/* Do a 'warn' here - it is handled below. */
/* This is benign because we clean up correctly */
/* READ_UNKNOWN_CHUNKS */
/* Handle an unknown, or known but disabled, chunk */
/* PRIVATE */
/* the chunk was handled */
/* NOTE: this code is based on the code in libpng-1.4.12 except for fixing
/* One of the following methods will read the chunk or skip it (at least one
/* The user callback takes precedence over the chunk keep value, but the
/* Callback to user unknown chunk handler */
/* ret is:
/* If the keep value is 'default' or 'never' override it, but
/* with keep = PNG_HANDLE_CHUNK_IF_SAFE */
/* chunk was handled */
/* Critical chunks can be safely discarded at this point. */
/* insufficient memory */
/* Use the SAVE_UNKNOWN_CHUNKS code or skip the chunk */
/* READ_USER_CHUNKS */
/* keep is currently just the per-chunk setting, if there was no
/* If here there is no read callback pointer set and no support is
/* Now store the chunk in the chunk list if appropriate, and if the limits
/* FALL THROUGH */
/* NOTE: prior to 1.6.0 this case resulted in an unknown critical
/* not at limit */
/* FALL THROUGH */
/* no limit */
/* USER_LIMITS */
/* Here when the limit isn't reached or when limits are compiled
/* no store support: the chunk must be handled by the user callback */
/* Regardless of the error handling below the cached data (if any) can be
/* !PNG_READ_UNKNOWN_CHUNKS_SUPPORTED */
/* There is no support to read an unknown chunk, so just skip it. */
/* !READ_UNKNOWN_CHUNKS */
/* Check for unhandled critical chunks */
/* This function is called to verify that a chunk name is valid.
/* Bit hacking: the test for an invalid byte in the 4 byte chunk name is:
/* PRIVATE */
/* Combines the row recently read in with the existing pixels in the row.  This
/* PRIVATE */
/* Added in 1.5.6: it should not be possible to enter this routine until at
/* Added in 1.5.4: the pixel depth should match the information returned by
/* Don't expect this to ever happen: */
/* Preserve the last byte in cases where only part of it will be overwritten,
/* end_ptr == NULL is a flag to say do nothing */
/* little-endian byte */
/* big-endian byte */
/* end_mask is now the bits to *keep* from the destination row */
/* For non-interlaced images this reduces to a memcpy(). A memcpy()
/* The following copies everything for 'display' on passes 0, 2 and 4. */
/* Narrow images may have no bits in a pass; the caller should handle
/* For pixel depths up to 4 bpp the 8-pixel mask can be expanded to fit
/* Return a mask for pass 'p' pixel 'x' at depth 'd'.  The mask is
/* Hence generate the appropriate 'block' or 'sparkle' pixel copy mask.
/* Combine 8 of these to get the full mask.  For the 1-bpp and 2-bpp
/* Utility macros to construct all the masks for a depth/swap
/* Hence the pre-compiled masks indexed by PACKSWAP (or not), depth and
/*PACKSWAP*/][3/*depth*/][6] =
/* Little-endian byte masks for PACKSWAP */
/* Normal (big-endian byte) masks - PNG format */
/* display_mask has only three entries for the odd passes, so index by
/* Little-endian byte masks for PACKSWAP */
/* Normal (big-endian byte) masks - PNG format */
/* !PNG_USE_COMPILE_TIME_MASKS */
/* This is the runtime alternative: it seems unlikely that this will
/* !USE_COMPILE_TIME_MASKS */
/* Use the appropriate mask to copy the required bits.  In some cases
/* It doesn't matter in the following if png_uint_32 has more than
/* rotate right to good compilers */
/* something to copy */
/* NOTE: this may overwrite the last byte with garbage if the image
/* May need to restore part of the last byte */
/* pixel_depth >= 8 */
/* Validate the depth - it must be a multiple of 8 */
/* now in bytes */
/* Regardless of pass number the Adam 7 interlace always results in a
/* Work out the bytes to copy. */
/* When doing the 'block' algorithm the pixel in the pass gets
/* But don't allow this number to exceed the actual row width. */
/*SAFE*/row_width;
/* normal row; Adam7 only ever gives us one pixel to copy. */
/* In Adam7 there is a constant offset between where the pixels go. */
/* And simply copy these bytes.  Some optimization is possible here,
/* There is a possibility of a partial copy at the end here; this
/* And there can only be one byte left at this point: */
/* This can only be the RGB case, so each copy is exactly one
/* Check for double byte alignment and, if possible, use a
/*else use memcpy*/ &&
/* Everything is aligned for png_uint_16 copies, but try for
/* Get to here when the row_width truncates the final copy.
/* Else do it in 16-bit quantities, but only if the size is
/* End of row - 1 byte left, bytes_to_copy > row_width: */
/* ALIGN_TYPE code */
/* The true default - use a memcpy: */
/*SAFE*/row_width;
/* NOT REACHED*/
/* pixel_depth >= 8 */
/* Here if pixel_depth < 8 to check 'end_ptr' below. */
/* READ_INTERLACING */
/* If here then the switch above wasn't used so just memcpy the whole row
/* Restore the overwritten bits from the last byte if necessary. */
/* PRIVATE */
/* Because these may affect the byte layout */)
/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
/* Offset to next interlace block */
/* SAFE; pixel_depth does not exceed 64 */
/* Silence compiler warning */
/* READ_INTERLACING */
/* First pixel/byte */
/* Remainder */
/* From previous iteration or start */
/* Find the best predictor, the least of pa, pb, pc favoring the earlier
/* Calculate the current pixel in a, and move the previous row pixel to c
/* Process the first pixel in the row completely (this is the same as 'up'
/* Remainder */
/* This function is called once for every PNG image (except for PNG images
/* To use this define PNG_FILTER_OPTIMIZATIONS as the name of a function to
/* PRIVATE */
/* OPTIMIZATION: DO NOT MODIFY THIS FUNCTION, instead #define
/* PRIVATE */
/* Loop reading IDATs and decompressing the result into output[avail_out] */
/* safety: set below */
/* This is an error even in the 'check' case because the code just
/* A PNG with a gradually increasing IDAT size will defeat this attempt
/*error*/);
/* And set up the output side. */
/* standard read */
/* after last row, checking for end */
/* Use NO_FLUSH; this gives zlib the maximum opportunity to optimize the
/* Take the unconsumed output back. */
/* avail_out counts the extra bytes */
/* Do this for safety; we won't read any more into this row. */
/* checking */
/* The stream ended before the image; this is the same as too few IDATs so
/* the deflate stream contained extra data */
/* PRIVATE */
/* We don't need any more data and the stream should have ended, however the
/* The NULL causes png_read_IDAT_data to swallow any remaining bytes in
/* safety */
/* Now clear everything out for safety; the following may not have been
/* If the zstream has not been released do it now *and* terminate the reading
/* Always do this; the pointers otherwise point into the read buffer. */
/* Now we no longer own the zstream. */
/* The slightly weird semantics of the sequential IDAT reading is that we
/* PRIVATE */
/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
/* Start of interlace block */
/* Offset to next interlace block */
/* Start of interlace block in the y direction */
/* Offset to next interlace block in the y direction */
/* TO DO: don't do this if prev_row isn't needed (requires
/* if (png_ptr->transformations & PNG_INTERLACE) */
/* libpng deinterlacing sees every row */
/* Here after at the end of the last row of the last pass. */
/* SEQUENTIAL_READ */
/* PRIVATE */
/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
/* Start of interlace block */
/* Offset to next interlace block */
/* Start of interlace block in the y direction */
/* Offset to next interlace block in the y direction */
/* WARNING: * png_read_transform_info (pngrtran.c) performs a simpler set of
/* In fact it is an error if it isn't supported, but checking is
/* This value is stored in png_struct and double checked in the row read
/* calculated on demand */
/* Align the width on the next larger 8 pixels.  Mainly used
/* Calculate the maximum bytes needed, adding a byte and a pixel
/* Use 16-byte aligned memory for row_buf with at least 16 bytes
/*filter byte*/;
/*filter byte*/;
/* Use 31 bytes of padding before and 17 bytes after row_buf. */
/* The sequential reader needs a buffer for IDAT, but the progressive reader
/* Finally claim the zstream for the inflate of the IDAT data, use the bits
/* READ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libpng\pngset.c
/* pngset.c - storage of image information into info struct
/* override with app values*/) != 0)
/* FLOATING_POINT */
/* cHRM */
/* Changed from info->num_palette to PNG_MAX_PALETTE_LENGTH in
/* TODO: validate format of calibration name and unit name */
/* Check that the type matches the specification. */
/* Validate params[nparams] */
/* Double check the unit (should never get here with an invalid
/* '-' */ || !png_check_fp_string(swidth, lengthw))
/* '-' */ || !png_check_fp_string(sheight, lengthh))
/* Check the arguments. */
/* Convert 'width' and 'height' to ASCII. */
/* Check the arguments. */
/* Convert 'width' and 'height' to ASCII. */
/* It may not actually be necessary to set png_ptr->palette here;
/* Changed in libpng-1.2.1 to allocate PNG_MAX_PALETTE_LENGTH instead
/* This causes the gAMA and cHRM to be written too */
/* sRGB */
/* Set the colorspace first because this validates the profile; do not
/* Don't do any of the copying if the profile was bad, or inconsistent. */
/* But do write the gAMA and cHRM chunks from the profile. */
/* PRIVATE */
/* Make sure we have enough space in the "text" array in info_struct
/* Calculate an appropriate max_text, checking for overflow. */
/* Round up to a multiple of 8 */
/* Now allocate a new array and copy the old members in; this does all
/* num_text is adjusted below as the entries are copied in */
/* Set iTXt data */
/* iTXt */
/* It may not actually be necessary to set png_ptr->trans_alpha here;
/* Changed from num_trans to PNG_MAX_PALETTE_LENGTH in version 1.2.1 */
/*
/* Use the internal realloc function, which checks for all the possible
/* Out of memory or too many chunks */
/* Skip invalid input entries */
/* png_handle_sPLT doesn't do this, so this is an app error */
/* Just skip the invalid entry */
/* In the event of out-of-memory just return - there's no point keeping
/* IMPORTANT: we have memory now that won't get freed if something else
/* This multiply can't overflow because png_malloc_array has already
/* Note that 'continue' skips the advance of the out pointer and out
/* sPLT */
/* New in 1.6.0; copy the location and check it.  This is an API
/* Write struct, so unknown chunks come from the app */
/* Use the old behavior */
/* This need not be an internal error - if the app calls
/* Now reduce the location to the top-most set bit by removing each least
/* The cast is safe because 'location' is a bit mask and only the low four
/* Check for the failure cases where support has been disabled at compile
/* Prior to 1.6.0 this code used png_malloc_warn; however, this meant that
/* safe because it is initialized */
/* Increment unknown_chunks_num each time round the loop to protect the
/* But just skip storing the unknown chunk */
/* These increments are skipped on out-of-memory for the data - the
/* This API is pretty pointless in 1.6.0 because the location can be set
/* Fake out the pre 1.6.0 behavior: */
/* undocumented! */
/* also undocumented */
/* STORE_UNKNOWN_CHUNKS */
/* Utility function: update the 'keep' state of a chunk if it is already in
/* '0' means just set the flags, so stop here */
/* Ignore all unknown chunks and all chunks recognized by
/* bKGD */
/* cHRM */
/* gAMA */
/* hIST */
/* iCCP */
/* iTXt */
/* oFFs */
/* pCAL */
/* pHYs */
/* sBIT */
/* sCAL */
/* sPLT */
/* sTER */
/* sRGB */
/* tEXt */
/* tIME */
/* zTXt */
/*SAFE*/(sizeof chunks_to_ignore)/5U;
/* num_chunks_in > 0 */
/* Prior to 1.6.0 this was silently ignored, now it is an app_error
/* Since num_chunks is always restricted to UINT_MAX/5 this can't overflow.
/* If these chunks are being reset to the default then no more memory is
/* Add the new chunks together with each one's handling code.  If the chunk
/* Now remove any spurious 'default' entries. */
/* This means the application has removed all the specialized handling. */
/* checked above */
/* must fit */
/* Deflate will potentially go into an infinite loop on a SYNC_FLUSH
/* This function was added to libpng 1.2.6 */
/* Images with dimensions larger than these limits will be
/* This function was added to libpng 1.4.0 */
/* This function was added to libpng 1.4.1 */
/* ?SET_USER_LIMITS */
/* If allowed is 1, png_benign_error() is treated as a warning.
/* BENIGN_ERRORS */
/* Whether to report invalid palette index; added at libng-1.5.10.
/* READ || WRITE */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libpng\pngtrans.c
/* pngtrans.c - transforms the data in a row (used by both readers and writers)
/* Turn on BGR-to-RGB mapping */
/* Turn on 16 bit byte swapping */
/* Turn on pixel packing */
/* Turn on packed pixel swapping */
/* Add a filler byte on read, or remove a filler or alpha byte on write.
/* In libpng 1.6 it is possible to determine whether this is a read or write
/* On read png_set_filler is always valid, regardless of the base PNG
/* not used in the write case */
/* write */
/* On write the usr_channels parameter must be set correctly at the
/* There simply isn't any code in libpng to strip out bits
/* Here on success - libpng supports the operation, set the transformation
/* Added to libpng-1.2.7 */
/* The above may fail to do anything. */
/* Invert monochrome grayscale data */
/* PRIVATE */
/* This test removed from libpng version 1.0.13 and 1.2.0:
/* Swaps byte order on 16 bit depth images */
/* PRIVATE */
/* Feature added to libpng-1.6.11 for testing purposes, not
/* Swaps pixel packing order within bytes */
/* PRIVATE */
/* PACKSWAP || WRITE_PACKSWAP */
/* Remove a channel - this used to be 'png_do_strip_filler' but it used a
/* PRIVATE */
/* source pointer */
/* destination pointer */
/* One beyond end of row */
/* At the start sp will point to the first byte to copy and dp to where
/* GA, GX, XG cases */
/* Skip initial filler */
/* Skip initial channel and, for sp, the filler */
/* For a 1 pixel wide image there is nothing to do */
/* Skip initial filler */
/* Skip initial channel and, for sp, the filler */
/* bad bit depth */
/* Finally fix the color type if it records an alpha channel */
/* RGBA, RGBX, XRGB cases */
/* Skip initial filler */
/* Skip initial channels and, for sp, the filler */
/* Note that the loop adds 3 to dp and 4 to sp each time. */
/* Skip initial filler */
/* Skip initial channels and, for sp, the filler */
/* Copy 6 bytes, skip 2 */
/* bad bit depth */
/* Finally fix the color type if it records an alpha channel */
/* The filler channel has gone already */
/* Fix the rowbytes value. */
/* Swaps red and blue bytes within a pixel */
/* PRIVATE */
/* READ_BGR || WRITE_BGR */
/* Added at libpng-1.5.10 */
/* PRIVATE */
/* num_palette can be 0 in MNG files */
/* Calculations moved outside switch in an attempt to stop different
/* in this case, all bytes must be 0 so we don't need
/* CHECK_FOR_INVALID_INDEX */
/* This function returns a pointer to the user_transform_ptr associated with
/* See the comments in png.h - this is the sub-image row when reading an
/* help the app not to fail silently */
/* invalid */
/* USER_TRANSFORM_INFO */
/* READ_USER_TRANSFORM || WRITE_USER_TRANSFORM */
/* READ || WRITE */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libpng\pngwio.c
/* pngwio.c - functions for data output
/* Write the data to whatever output you are using.  The default routine
/* PRIVATE */
/* NOTE: write_data_fn must not change the buffer! */
/* This is the function that does the actual writing of data.  If you are
/* This function is called to output any data pending writing (normally
/* PRIVATE */
/* This function allows the application to supply new output functions for
/* WRITE_FLUSH */
/* It is an error to read while writing a png file */
/* WRITE */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libpng\pngwrite.c
/* pngwrite.c - general routines to write a PNG file
/* Write out all the unknown chunks for the current given location */
/* If per-chunk unknown chunk handling is enabled use it, otherwise
/* NOTE: this code is radically different from the read side in the
/* safe-to-copy overrides everything */ ||
/* TODO: review, what is wrong with a zero length unknown chunk? */
/* WRITE_UNKNOWN_CHUNKS */
/* Writes all the PNG information.  This is the suggested way to use the
/* Write PNG signature */
/* Write IHDR information. */
/* The rest of these check to see if the valid field has the appropriate
/* Write only one of sRGB or an ICC profile.  If a profile was supplied
/* WRITE_sRGB */
/* COLORSPACE */
/* Invert the alpha channel (in tRNS) */
/* sCAL */
/* pHYs */
/* tIME */
/* sPLT */
/* Check to see if we need to write text chunks */
/* An internationalized chunk? */
/* Write international chunk */
/* Mark this chunk as written */
/* If we want a compressed text chunk */
/* Write compressed chunk */
/* Mark this chunk as written */
/* Write uncompressed chunk */
/* Mark this chunk as written */
/* Can't get here */
/* tEXt */
/* Writes the end of the PNG file.  If you don't want to write comments or
/* See if user wants us to write information chunks */
/* local index variable */
/* Check to see if user has supplied a time chunk */
/* Loop through comment chunks */
/* An internationalized chunk? */
/* Write international chunk */
/* Mark this chunk as written */
/* Write compressed chunk */
/* Mark this chunk as written */
/* Write uncompressed chunk */
/* Mark this chunk as written */
/* Write end of PNG file */
/* This flush, added in libpng-1.0.8, removed from libpng-1.0.9beta03,
/* Initialize png_ptr structure, and allocate any memory needed */
/* Alternate initialize png_ptr structure, and allocate any memory needed */
/* USER_MEM */
/* Set the zlib control values to defaults; they can be overridden by the
/* The 'zlib_strategy' setting is irrelevant because png_default_claim in
/* WRITE_COMPRESSED_TEXT */
/* This is a highly dubious configuration option; by default it is off,
/* In stable builds only warn if an application error can be completely
/* App warnings are warnings in release (or release candidate) builds but
/* TODO: delay this, it can be done in png_init_io() (if the app doesn't
/* Write a few rows of image data.  If the image is interlaced,
/* row counter */
/* row pointer */
/* Loop through the rows */
/* Write the image.  You only need to call this function once, even
/* row index */
/* pass variables */
/* points to current row */
/* Initialize interlace handling.  If image is not interlaced,
/* Loop through passes */
/* Loop through image */
/* Performs intrapixel differencing  */
/* WRITE_16BIT */
/* MNG_FEATURES */
/* Called by user to write a row of image data */
/* 1.5.6: moved from png_struct to be a local structure: */
/* Initialize transformations and other stuff if first time */
/* Make sure we wrote the header info */
/* Check for transforms that have been set but were defined out */
/* If interlaced and not interested in row, return */
/* error: ignore it */
/* Set up row info for transformations */
/* Copy user's row into buffer, leaving room for filter byte. */
/* Handle interlacing */
/* This should always get caught above, but still ... */
/* Handle other transformations */
/* At this point the row_info pixel depth must match the 'transformed' depth,
/* Write filter_method 64 (intrapixel differencing) only if
/* Intrapixel differencing */
/* Added at libpng-1.5.10 */
/* Check for out-of-range palette index */
/* Find a filter if necessary, filter the row and write it out. */
/* Set the automatic flush interval or 0 to turn flushing off */
/* Flush the current output buffers now */
/* We have already written out all of the data */
/* WRITE_FLUSH */
/* forward decl */
/* Free any memory used in png_ptr struct without freeing the struct itself. */
/* Free any memory zlib uses */
/* Free our memory.  png_free checks NULL for us. */
/* Use this to save a little code space, it doesn't free the filter_costs */
/* The error handling and memory handling information is left intact at this
/* Free all memory used by the write.
/* added in libpng 1.6.0 */
/* Allow the application to select one or more row filters to use. */
/* FALL THROUGH */
/* WRITE_FILTER */
/* WRITE_FILTER */
/* If we have allocated the row_buf, this means we have already started
/* WRITE_FILTER */
/* This allows us to influence the way in which libpng chooses the "best"
/* GRR 970116 */
/* Convenience reset API. */
/* Clear out any old values in the 'weights' - this must be done because if
/* Leave the filter_costs - this array is fixed size. */
/* Clear out the arrays */
/* Check arguments; the 'reset' function makes the correct settings for the
/* To make sure that the weighting starts out fairly */
/* Safe to set this now */
/* If, in the future, there are other filter methods, this would
/* All the arrays are inited, safe to set this: */
/* Return the 'ok' code. */
/* Provide floating and fixed point APIs */
/* The internal API allocates all the arrays and ensures that the elements of
/* If using the weighted method copy in the weights. */
/* Here is where we set the relative costs of the different filters.  We
/* FLOATING_POINT */
/* The internal API allocates all the arrays and ensures that the elements of
/* If using the weighted method copy in the weights. */
/* Here is where we set the relative costs of the different filters.  We
/* Use a 32 bit unsigned temporary here because otherwise the
/* FIXED_POINT */
/* WRITE_WEIGHTED_FILTER */
/* The flag setting here prevents the libpng dynamic selection of strategy.
/* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a
/* Prior to 1.6.0 this would warn but then set the window_bits value. This
/* This would produce an invalid PNG file if it worked, but it doesn't and
/* WRITE_CUSTOMIZE_COMPRESSION */
/* The following were added to libpng-1.5.4 */
/* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a
/* WRITE_CUSTOMIZE_ZTXT_COMPRESSION */
/* end of API added to libpng-1.5.4 */
/* Write the file header information. */
/* ------ these transformations don't touch the info structure ------- */
/* Invert monochrome pixels */
/* Shift the pixels up to a legal bit depth and fill in
/* Pack pixels into bytes */
/* Swap location of alpha bytes from ARGB to RGBA */
/* Remove a filler (X) from XRGB/RGBX/AG/GA into to convert it into
/* Continue if ignored - this is the pre-1.6.10 behavior */
/* Flip BGR pixels to RGB */
/* Swap bytes of 16-bit files to most significant byte first */
/* Swap bits of 1, 2, 4 bit packed pixel formats */
/* Invert the alpha channel from opacity to transparency */
/* ----------------------- end of transformations ------------------- */
/* Write the bits */
/* It is REQUIRED to call this to finish writing the rest of the file */
/* currently required for png_image_write_* */
/* Initialize the write structure - general purpose utility. */
/* Error clean up */
/* Arguments to png_image_write_main: */
/* Arguments: */
/* Local variables: */
/* Write png_uint_16 input to a 16-bit PNG; the png_ptr has already been set to
/* To point to the first component */
/* Work out the output row end and count over this, note that the increment
/* Calculate a reciprocal.  The correct calculation is simply
/* always at least one channel */
/* The following gives 65535 for an alpha of 0, which is fine,
/* component<alpha, so component/alpha is less than one and
/* round to nearest */
/* Skip to next component (skip the intervening alpha channel) */
/* Given 16-bit input (1 to 4 channels) write 8-bit output.  If an alpha channel
/*from the above macro*/)
/* The following gives 1.0 for an alpha of 0, which is fine, otherwise if 0/0
/* component<alpha, so component/alpha is less than one and
/* The test is that alpha/257 (rounded) is less than 255, the first value
/* round to nearest */
/* Convert the component to sRGB. */
/* To point to the first component */
/* Use row_end in place of a loop counter: */
/* Scale and write the alpha channel. */
/* always at least one channel */
/* Skip to next component (skip the intervening alpha channel) */
/* while out_ptr < row_end */
/* while y */
/* No alpha channel, so the row_end really is the end of the row and it
/* NOTE: the caller must check for cmap != NULL and entries != 0 */
/* This gets automatically converted to sRGB with reversal of the
/* no alpha */
/* RGB */
/* Gray */
/* alpha */
/* Calculate a reciprocal, as in the png_write_image_8bit code above
/* RGB */
/* gray */
/* Color-map has sRGB values */
/* FALL THROUGH */
/* FALL THROUGH */
/* The following four ints are actually booleans */
/* input */
/* Make sure we error out on any bad situation */
/*error*/);
/* Default the 'row_stride' parameter if required. */
/* Set the required transforms then write the rows in the correct order. */
/* Counter-intuitively the data transformations must be called *after*
/* The gamma here is 1.0 (linear) and the cHRM chunk matches sRGB. */
/* color      x       y */
/* white */ 31270, 32900,
/* red   */ 64000, 33000,
/* green */ 30000, 60000,
/* blue  */ 15000,  6000
/* Else writing an 8-bit file and the *colors* aren't sRGB, but the 8-bit
/* Write the file header. */
/* Now set up the data transformations (*after* the header is written),
/* If there are 16 or fewer color-map entries we wrote a lower bit depth
/* That should have handled all (both) the transforms. */
/* Apply 'fast' options if the flag is set. */
/* NOTE: determined by experiment using pngstest, this reflects some
/* Check for the cases that currently require a pre-transform on the row
/* Skip the 'write_end' on error: */
/* Otherwise this is the case where the input is in a format currently
/* Write the image to the given (FILE*). */
/* This is slightly evil, but png_init_io doesn't do anything other
/* Write the image to the named file. */
/* from fflush/fclose */
/* Make sure the file is flushed correctly. */
/* from fclose */
/* from fflush or ferror */
/* The image has already been cleaned up; this is just used to
/* Clean up: just the opened file. */
/* STDIO */
/* SIMPLIFIED_WRITE */
/* WRITE */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libpng\pngwtran.c
/* pngwtran.c - transforms the data in a row for PNG writers
/* Pack pixels into bytes.  Pass the true bit depth in bit_depth.  The
/* Shift pixel values to take advantage of whole range.  Pass the
/* With low row depths, could only be grayscale, so one channel */
/* This converts from ARGB to RGBA */
/* This converts from AARRGGBB to RRGGBBAA */
/* WRITE_16BIT */
/* This converts from AG to GA */
/* This converts from AAGG to GGAA */
/* WRITE_16BIT */
/* This inverts the alpha channel in RGBA */
/* Does nothing
/* This inverts the alpha channel in RRGGBBAA */
/* Does nothing
/* WRITE_16BIT */
/* This inverts the alpha channel in GA */
/* This inverts the alpha channel in GGAA */
/* Does nothing
/* WRITE_16BIT */
/* Transform the data according to the user's wishes.  The order of
/* PRIVATE */
/* User write transform
/* png_ptr */
/* row_info: */
/*  png_uint_32 width;       width of row */
/*  png_size_t rowbytes;     number of bytes in row */
/*  png_byte color_type;     color type of pixels */
/*  png_byte bit_depth;      bit depth of samples */
/*  png_byte channels;       number of channels (1-4) */
/*  png_byte pixel_depth;    bits per pixel (depth*channels) */
/* start of pixel data for row */
/* WRITE_TRANSFORMS */
/* WRITE */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libpng\pngwutil.c
/* pngwutil.c - utilities to write a PNG file
/* Place a 32-bit number into a buffer in PNG byte order.  We work
/* Place a 16-bit number into a buffer in PNG byte order.
/* Simple function to write the signature.  If we have already written
/* Inform the I/O callback that the signature is being written */
/* Write the rest of the 8 byte signature */
/* Write the start of a PNG chunk.  The type is the chunk type.
/* Inform the I/O callback that the chunk header is being written.
/* Write the length and the chunk name */
/* Put the chunk name into png_ptr->chunk_name */
/* Reset the crc and run it over the chunk name */
/* Inform the I/O callback that chunk data will (possibly) be written.
/* Write the data of a PNG chunk started with png_write_chunk_header().
/* Write the data, and run the CRC over it */
/* Update the CRC after writing the data,
/* Finish a chunk started with png_write_chunk_header(). */
/* Inform the I/O callback that the chunk CRC is being written.
/* Write the crc in a single operation */
/* Write a PNG chunk all at once.  The type is an array of ASCII characters
/* On 64 bit architectures 'length' may not fit in a png_uint_32. */
/* This is the API that calls the internal function above. */
/* This is used below to find the size of an image to pass to png_deflate_claim,
/* Only return sizes up to the maximum of a png_uint_32; do this by limiting
/* Interlacing makes the image larger because of the replication of
/* This is the code to hack the first two bytes of the deflate stream (the
/* Optimize the CMF field in the zlib stream.  The resultant zlib stream is
/* else windowBits must be 15 */
/* zlib compression method and flags */
/* else no change */
/* WRITE_OPTIMIZE_CMF */
/* Initialize the compressor for the appropriate type of compression. */
/* So the message that results is "<chunk> using zstream"; this is an
/* Attempt sane error recovery */
/* don't steal from IDAT */
/* set below */
/* zlib return code */
/* If customization is not supported the values all come from the
/* Adjust 'windowBits' down if larger than 'data_size'; to stop this
/* IMPLEMENTATION NOTE: this 'half_window_size' stuff is only here to
/* Check against the previous initialized values, if any. */
/* For safety clear out the input and output pointers (currently zlib
/* Now initialize if required, setting the new parameters, otherwise just
/* The return code is from either deflateReset or deflateInit2; they have
/* Clean up (or trim) a linked list of compression buffers. */
/* PRIVATE */
/* This pair of functions encapsulates the operation of (a) compressing a
/* The uncompressed input data */
/* Its length */
/* Final compressed length */
/* First block of output */
/* Compress the data in the compression state input */
/* To find the length of the output it is necessary to first compress the
/* Set up the compression buffers, we need a loop here to avoid overflowing a
/* may be zero! */
/* zlib updates these for us: */
/* Set below */
/* Chunk data is limited to 2^31 bytes in length, so the prefix
/* Need a new (malloc'ed) buffer, but there may be one present
/* Link in this buffer (so that it will be freed later) */
/* Move 'end' to the next buffer pointer. */
/* Compress the data */
/* Claw back input data that was not consumed (because avail_in is
/* safety */
/* There may be some space left in the last output buffer. This needs to
/* safety */
/* Now double check the output length, put in a custom message if it is
/* Reset zlib for another zTXt/iTXt or image data */
/* The only success case is Z_STREAM_END, input_len must be 0; if not this
/* Fix up the deflate header, if required */
/* But Z_OK is returned, not Z_STREAM_END; this allows the claim
/* Ship the compressed text out via chunk writes */
/* This is an internal error; 'next' must have been NULL! */
/* WRITE_COMPRESSED_TEXT */
/* Check that the tEXt or zTXt keyword is valid per PNG 1.0 specification,
/*&& ch <= 255*/))
/* A space or an invalid character when one wasn't seen immediately
/* If the character was not a space then it is invalid. */
/* just skip it, record the first error */
/* trailing space */
/* Terminate the keyword */
/* Try to only output one warning per keyword: */
/* keyword too long */
/* WARNINGS */
/* WRITE_TEXT || WRITE_pCAL || WRITE_iCCP || WRITE_sPLT */
/* Write the IHDR chunk, and update the png_struct with the necessary
/* PRIVATE */
/* Buffer to store the IHDR info */
/* Check that we have valid input data from the application info */
/* Write filter_method 64 (intrapixel differencing) only if
/* Save the relevant information */
/* Set the usr info, so any transformations can modify it */
/* Pack the header information into the buffer */
/* Write the chunk */
/* not READY_FOR_ZTXT */
/* Write the palette.  We are careful not to trust png_color to be in the
/* PRIVATE */
/* This is a little slower but some buggy compilers need to do this
/* This is similar to png_text_compress, above, except that it does not require
/* PRIVATE */
/* First time.   Ensure we have a temporary buffer for compression and
/* It is a terminal error if we can't claim the zstream. */
/* The output state is maintained in png_ptr->zstream, so it must be
/* Now loop reading and writing until all the input is consumed or an error
/* set below */
/* INPUT: from the row data */
/* safe because of the check */
/* Include as-yet unconsumed input */
/* OUTPUT: write complete IDAT chunks when avail_out drops to zero. Note
/* Write an IDAT containing the data then reset the buffer.  The
/* For SYNC_FLUSH or FINISH it is essential to keep calling zlib with
/* The order of these checks doesn't matter much; it just affects which
/* most likely return code! */
/* If all the input has been consumed then just return.  If Z_FINISH
/* This is the end of the IDAT data; any pending output must be
/* Release the stream */
/* This is an error condition. */
/* Write an IEND chunk */
/* PRIVATE */
/* Write a gAMA chunk */
/* PRIVATE */
/* file_gamma is saved in 1/100,000ths */
/* Write a sRGB chunk */
/* PRIVATE */
/* Write an iCCP chunk */
/* PRIVATE */
/* 1 byte for the compression byte */
/* These are all internal problems: the profile should have been checked
/* internal error */
/* Make sure we include the NULL after the name and the compression type */
/* Allow for keyword terminator and compression byte */
/* Write a sPLT chunk */
/* PRIVATE */
/* Make sure we include the NULL after the name */
/* Loop through each palette entry, writing appropriately */
/* Write the sBIT chunk */
/* PRIVATE */
/* Make sure we don't depend upon the order of PNG_COLOR_8 */
/* Write the cHRM chunk */
/* PRIVATE */
/* Each value is saved in 1/100,000ths */
/* Write the tRNS chunk */
/* PRIVATE */
/* Write the chunk out as it is */
/* One 16 bit value */
/* Three 16 bit values */
/* Write the background chunk */
/* PRIVATE */
/* Write the histogram */
/* PRIVATE */
/* Write a tEXt chunk */
/* PRIVATE */
/* Make sure we include the 0 after the key */
/*checked above*/(key_len + text_len + 1));
/*
/* Write a compressed text chunk */
/* PRIVATE */
/* Add the compression method and 1 for the keyword separator. */
/* Compute the compressed data; do it now for the length */
/* Write start of chunk */
/* Write key */
/* Write the compressed data */
/* Close the chunk */
/* Write an iTXt chunk */
/* PRIVATE */
/* Set the compression flag */
/* no compression */
/* compressed */
/* for the keywod separator */
/* We leave it to the application to meet PNG-1.0 requirements on the
/* empty language is valid */
/* may be empty */
/* may be empty */
/* So the string will fit in a chunk: */
/*SAFE*/comp.input_len;
/* Write the oFFs chunk */
/* PRIVATE */
/* Write the pCAL chunk (described in the PNG extensions document) */
/* PRIVATE */
/* terminator */
/* Find the length of each parameter, making sure we don't count the
/* Write the sCAL chunk */
/* PRIVATE */
/* Append the '\0' here */
/* Do NOT append the '\0' here */
/* Write the pHYs chunk */
/* PRIVATE */
/* Write the tIME chunk.  Use either png_convert_from_struct_tm()
/* PRIVATE */
/* Initializes the row writing capability of libpng */
/* PRIVATE */
/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
/* Start of interlace block */
/* Offset to next interlace block */
/* Start of interlace block in the y direction */
/* Offset to next interlace block in the y direction */
/* 1.5.6: added to allow checking in the row write code. */
/* Set up row buffer */
/* Set up filtering buffer, if using this filter */
/* We only need to keep the previous row if we are using one of these. */
/* Set up previous row buffer */
/* WRITE_FILTER */
/* If interlaced, we need to set up width and height of pass */
/* Internal use only.  Called when finished processing a row of data. */
/* PRIVATE */
/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
/* Start of interlace block */
/* Offset to next interlace block */
/* Start of interlace block in the y direction */
/* Offset to next interlace block in the y direction */
/* Next row */
/* See if we are done */
/* If interlaced, go to next pass */
/* Loop until we find a non-zero width or height pass */
/* Reset the row above the image for the next pass */
/* If we get here, we've just written the last row, so we need
/* Pick out the correct pixels for the interlace pass.
/* PRIVATE */
/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
/* Start of interlace block */
/* Offset to next interlace block */
/* We don't have to do anything on the last pass (6) */
/* Each pixel depth is handled separately */
/* Start at the beginning */
/* Find out how many bytes each pixel takes up */
/* Loop through the row, only looking at the pixels that matter */
/* Find out where the original pixel is */
/* Move the pixel */
/* Next pixel */
/* Set new row width */
/* This filters the row, chooses which filter to use, if it has not already
/* PRIVATE */
/* PRIVATE */
/* These will never be selected so we need not test them. */
/* Find out how many bytes offset each pixel is */
/* The prediction method we use is to find which method provides the
/* We don't need to test the 'no filter' case if this is the only filter
/* Gives us some footroom */
/* Reduce the sum if we match any of the previous rows */
/* Factor in the cost of this filter (this is here for completeness,
/* Sub filter */
/* It's the only filter so no testing is needed */
/* We temporarily increase the "minimum sum" by the factor we
/* We are already worse, don't continue. */
/* Up filter */
/* We are already worse, don't continue. */
/* Avg filter */
/* We are already worse, don't continue. */
/* Paeth filter */
/* SLOW_PAETH */
/* SLOW_PAETH */
/* We are already worse, don't continue. */
/* WRITE_FILTER */
/* Do the actual writing of the filtered row data from the chosen filter. */
/* Save the type of filter we picked this time for future calculations */
/* WRITE_FILTER */
/* Do the actual writing of a previously filtered row. */
/*includes filter byte*/)
/* Swap the current and previous rows */
/* WRITE_FILTER */
/* Finish row - updates counters and flushes zlib if last row */
/* WRITE_FLUSH */
/* WRITE */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libpng\arm\arm_init.c
/* arm_init.c - NEON optimised filter functions
/* Below, after checking __linux__, various non-C90 POSIX 1003.1 functions are
/* Do run-time checks */
/* WARNING: it is strongly recommended that you do not build libpng with
/* for sig_atomic_t */
/* PNG_ARM_NEON_FILE */
/* PNG_ARM_NEON_FILE */
/* PNG_ARM_NEON_CHECK_SUPPORTED */
/* The switch statement is compiled in for ARM_NEON_API, the call to
/* Allow the run-time check to execute if it has been enabled -
/* PNG_ARM_NEON_API_SUPPORTED */
/* not checked */
/* PNG_ARM_NEON_CHECK_SUPPORTED */
/* OFF or INVALID */
/* Option turned on */
/* IMPORTANT: any new external functions used here must be declared using
/* PNG_ARM_NEON_OPT > 0 */
/* READ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libpng\arm\filter_neon_intrinsics.c
/* filter_neon_intrinsics.c - NEON optimised filter functions
/* This code requires -mfpu=neon on the command line: */
/* intrinsics code from pngpriv.h */
/* libpng row pointers are not necessarily aligned to any particular boundary,
/* The following relies on a variable 'temp_pointer' being declared with type
/* a + b */
/* c * 2 */
/* pa */
/* pb */
/* pc */
/* pa <= pb */
/* pa <= pc */
/* pb <= pc */
/* pa <= pb && pa <= pc */
/* PNG_ARM_NEON_OPT > 0 */
/* PNG_ARM_NEON_IMPLEMENTATION == 1 (intrinsics) */
/* READ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\mkg3states.c
/* "$Id: mkg3states.c,v 1.11 2010-03-10 18:56:48 bfriesen Exp $ */
/*
/* Initialise fax decoder tables
/* NB: can't use names in tif_fax3.h 'cuz they are declared const */
/* right justified, lsb-first, zero filled */
/* (pixel count)<<4 + code width  */
/* initialise the huffman code tables */
/* WARNING, this file was automatically generated by the\n");
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_aux.c
/* $Id: tif_aux.c,v 1.26 2010-07-01 15:33:28 dron Exp $ */
/*
/*
/*
/*
/*
/*
/* defaults are from CCIR Recommendation 601-1 */
/* TIFF 6.0 specification tells that it is no default
/*
/* adding 2**64 */
/* adding 2**64 */
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_close.c
/* $Id: tif_close.c,v 1.19 2010-03-10 18:56:48 bfriesen Exp $ */
/*
/*
/************************************************************************/
/*                            TIFFCleanup()                             */
/************************************************************************/
/**
/*
/*
/*
/************************************************************************/
/*                            TIFFClose()                               */
/************************************************************************/
/**
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_codec.c
/* $Id: tif_codec.c,v 1.15 2010-12-14 12:53:00 dron Exp $ */
/*
/*
/*
/************************************************************************/
/*                       TIFFIsCODECConfigured()                        */
/************************************************************************/
/**
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_color.c
/* $Id: tif_color.c,v 1.19 2010-12-14 02:22:42 faxguy Exp $ */
/*
/*
//www.vips.ecs.soton.ac.uk) with
/*
/*
/*
/* Multiply through the matrix to get luminosity values. */
/* Clip input */
/* Avoid overflow in case of wrong input values */
/* Turn luminosity to colour value. */
/* Clip output. */
/* 
/* Red */
/* Green */
/* Blue */
/* Init reference white point */
/* 
/* XXX: Only 8-bit YCbCr input supported for now */
/*
/* v < 0 => 0 */
/* v > 255 => 255 */
/*
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_compress.c
/* $Id: tif_compress.c,v 1.22 2010-03-10 18:56:48 bfriesen Exp $ */
/*
/*
/*
/*
/************************************************************************/
/*                       TIFFGetConfisuredCODECs()                      */
/************************************************************************/
/**
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_dir.c
/* $Id: tif_dir.c,v 1.113 2012-06-14 20:32:53 fwarmerdam Exp $ */
/*
/*
/*
/* !untyped data */
/* !signed integer data */
/* !unsigned integer data */
/* !IEEE floating point data */
/*
/* XXX: Unassociated alpha data == 999 is a known Corel Draw bug, see below */
/* typically missing param */
/*
/*
/* skip \0 */
/*
/*
/* two 64's */
/*
/*
/*  Try to fix up the SWAB function for complex data. */
/* XXX should check for null range */
/*
/*
/*
/*
/* TODO: This is an evil exception and should not have been
/*
/* unknown tag */
/*
/*
/*
/*
/*
/* libtiff historially treats this as a single value. */
/* libtiff historially treats this as a single value. */
/*
/*
/* Assume TIFF_VARIABLE */
/* TODO: This is an evil exception and should not have been
/*
/*
/*
/* Cleanup custom tag values */
/*
/*
/*
/*
/* Our own arrays always sorted. */  
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/* force link on next write */
/* next write must be at end */
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_dirinfo.c
/* $Id: tif_dirinfo.c,v 1.117 2012-08-19 16:56:34 bfriesen Exp $ */
/*
/*
/*
/* begin SGI tags */
/* end SGI tags */
/* begin Pixar tags */
/* end Pixar tags */
/* begin DNG tags */
/* end DNG tags */
/* begin TIFF/FX tags */
/* end DNG tags */
/* begin pseudo tags */
/*
/* key found */
/* NB: be careful of return values for 16-bit platforms */
/* TIFFField** tp; */
/* tp = tif->tif_fields + tif->tif_nfields; */
/* only add definitions that aren't already present */
/* Sort the field info by tag number */
/*
/* nothing */
/* will return 0 for unknown types */
/*
/* If we are invoked with no field information, then just return. */
/* NB: use sorted search (e.g. binary search) */
/* If we are invoked with no field information, then just return. */
/* NB: use linear search since list is sorted by key#, not name */
/* 
/****************************************************************************
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_dirread.c
/* $Id: tif_dirread.c,v 1.178 2012-08-19 16:56:34 bfriesen Exp $ */
/*
/*
/* Suggested pending improvements:
/* tag placeholder used below */
/*
/*
/*
/* 
/*
/*
/* *value=*(uint16*)(&direntry->tdir_offset); */
/*
/*
/* we should never get here */
/* we should never get here */
/*
/* last offset or bad offset (IFD looping) */
/* cleanup any previous compression state */
/*
/* reset before new dir */
/* reset before new dir */
/* free any old stuff and reinit */
/*
/*
/*
/*
/* the following knowingly leaks the 
/*
/*
/*
/*
/*
/*
/* BEGIN REV 4.0 COMPATIBILITY */
/* END REV 4.0 COMPATIBILITY */
/*
/*
/*
/*
/*
/*
/*
/*
/*
/* !defined(DEFER_STRILE_LOAD) */                        
/*
/* !defined(DEFER_STRILE_LOAD) */
/*
/*
/*
/*
/*
/* check data type */
/* check count if known in advance */
/*
/* calculate amount of space used by indirect values */
/*
/*
/* no more directories */
/*
/*
/*
/*
/*
/*
/* if so, we shouldn't arrive here but deal with this in specialized code */
/* if so, we shouldn't arrive here as this is only the case for pseudo-tags */
/* corrupt file */;
/* corrupt file */;
/* corrupt file */;
/* we should never get here */
/*
/*
/*
/*
/*
/*
/* something is wonky, do nothing. */
/*
/*
/*
/* !defined(DEFER_STRILE_LOAD) */
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_dirwrite.c
/* $Id: tif_dirwrite.c,v 1.77 2012-07-06 19:18:31 bfriesen Exp $ */
/*
/*
/*
/*
/* Setup the strips arrays, if they haven't already been. */
/*
/* We don't need to do anything special if it hasn't been written. */
/*
/*
/*
/* shutdown encoder */
/*
/* we should never get here */
/* we should never get here */
/* This is correct. The data has been */
/* swabbed previously in TIFFWriteDirectoryTagData */
/*
/************************************************************************/
/*                TIFFWriteDirectoryTagLongLong8Array()                 */
/*                                                                      */
/*      Write out LONG8 array as LONG8 for BigTIFF or LONG for          */
/*      Classic TIFF with some checking.                                */
/************************************************************************/
/* is this just a counting pass? */
/* We always write LONG8 for BigTIFF, no checking needed. */
/*
/************************************************************************/
/*                 TIFFWriteDirectoryTagIfdIfd8Array()                  */
/*                                                                      */
/*      Write either IFD8 or IFD array depending on file type.          */
/************************************************************************/
/* is this just a counting pass? */
/* We always write IFD8 for BigTIFF, no checking needed. */
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/************************************************************************/
/*                          TIFFRewriteField()                          */
/*                                                                      */
/*      Rewrite a field in the directory on disk without regard to      */
/*      updating the TIFF directory structure in memory.  Currently     */
/*      only supported for field that already exist in the on-disk      */
/*      directory.  Mainly used for updating stripoffset /              */
/*      stripbytecount values after the directory is already on         */
/*      disk.                                                           */
/*                                                                      */
/*      Returns zero on failure, and one on success.                    */
/************************************************************************/
/* const TIFFField* fip = NULL; */
/* -------------------------------------------------------------------- */
/*      Find field definition.                                          */
/* -------------------------------------------------------------------- */
/*fip =*/ TIFFFindField(tif, tag, TIFF_ANY);
/* -------------------------------------------------------------------- */
/*      Do some checking this is a straight forward case.               */
/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
/*      Read the directory entry count.                                 */
/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
/*      Read through directory to find target tag.                      */
/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
/*      Extract the type, count and offset for this entry.              */
/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
/*      What data type do we want to write this as?                     */
/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
/*      Prepare buffer of actual data to write.  This includes          */
/*      swabbing as needed.                                             */
/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
/*      Is this a value that fits into the directory entry?             */
/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
/*      If the tag type, and count match, then we just write it out     */
/*      over the old values without altering the directory entry at     */
/*      all.                                                            */
/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
/*      Otherwise, we write the new tag data at the end of the file.    */
/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
/*      Adjust the directory entry.                                     */
/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
/*      Write the directory entry out to disk.                          */
/* -------------------------------------------------------------------- */
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_dumpmode.c
/* $Header: /cvs/maptools/cvsroot/libtiff/libtiff/tif_dumpmode.c,v 1.14 2011-04-02 20:54:09 bfriesen Exp $ */
/*
/*
/*
/*
/*
/*
/*
/*
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_error.c
/* $Header: /cvs/maptools/cvsroot/libtiff/libtiff/tif_error.c,v 1.5 2010-03-10 18:56:48 bfriesen Exp $ */
/*
/*
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_extension.c
/* $Header: /cvs/maptools/cvsroot/libtiff/libtiff/tif_extension.c,v 1.7 2010-03-10 18:56:48 bfriesen Exp $ */
/*
/*
/*
/*
/*
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_fax3.c
/* $Id: tif_fax3.c,v 1.74 2012-06-21 02:01:31 fwarmerdam Exp $ */
/*
/*
/*
/* O_RDONLY for decode, else encode */
/* operating mode */
/* bytes in a decoded scanline */
/* pixels in a scanline */
/* CleanFaxData tag */
/* BadFaxRun tag */
/* BadFaxLines tag */
/* Group 3/4 options tag */
/* super-class method */
/* super-class method */
/* super-class method */
/* Decoder state info */
/* bit reversal table */
/* current i/o byte/word */
/* current i/o bit in byte */
/* count of EOL codes recognized */
/* fill routine */
/* b&w runs for current/previous row */
/* runs for reference line */
/* runs for current line */
/* Encoder state info */
/* encoding state */
/* reference line for 2d decoding */
/* #rows left that can be 2d encoded */
/* max #rows that can be 2d encoded */
/*
/*
/* reference element */		\
/* last element in row */	\
/* bit accumulator */		\
/* # valid bits in BitAcc */	\
/* length of current run */	\
/* next byte of input data */	\
/* end of input data */		\
/* place to stuff next run */	\
/* current row's run array */	\
/* # EOL codes recognized */	\
/* input data bit reverser */	\
/* next change on prev line */	\
/* next run in reference line */\
/*
/*
/*
/* force initial read */
/* force initial scan for EOL */
/*
/* init reference line to white */
/*
/*
/* premature EOF */
/* premature EOF */
/*
/* current line is 1d/2d-encoded */
/* 1D/2D-encoding tag bit */
/* imaginary change for reference */
/* premature EOF */
/* premature EOF */
/*
/*
/* align to byte boundary */
/* multiple bytes to fill */
/*
/* align to byte boundary */
/* multiple bytes to fill */
/*
/*
/*
/*
/*
/* NB: default is 1D routine */
/* 2d encoding */
/*
/* 1d encoding */
/*
/*
/*
/*
/*
/*
/*
/*
/*
/* convert to inches */
/* 0x00 - 0x0f */
/* 0x10 - 0x1f */
/* 0x20 - 0x2f */
/* 0x30 - 0x3f */
/* 0x40 - 0x4f */
/* 0x50 - 0x5f */
/* 0x60 - 0x6f */
/* 0x70 - 0x7f */
/* 0x80 - 0x8f */
/* 0x90 - 0x9f */
/* 0xa0 - 0xaf */
/* 0xb0 - 0xbf */
/* 0xc0 - 0xcf */
/* 0xd0 - 0xdf */
/* 0xe0 - 0xef */
/* 0xf0 - 0xff */
/* 0x00 - 0x0f */
/* 0x10 - 0x1f */
/* 0x20 - 0x2f */
/* 0x30 - 0x3f */
/* 0x40 - 0x4f */
/* 0x50 - 0x5f */
/* 0x60 - 0x6f */
/* 0x70 - 0x7f */
/* 0x80 - 0x8f */
/* 0x90 - 0x9f */
/* 0xa0 - 0xaf */
/* 0xb0 - 0xbf */
/* 0xc0 - 0xcf */
/* 0xd0 - 0xdf */
/* 0xe0 - 0xef */
/* 0xf0 - 0xff */
/*
/*
/*
/* table value too generous */
/* constrain span to bit range */
/* doesn't extend to edge of byte */
/*
/*
/* end of run */
/*
/*
/* table value too generous */
/* constrain span to bit range */
/* doesn't extend to edge of byte */
/*
/*
/* end of run */
/*
/*
/*
/*
/* white span */
/* black span */
/* byte-align */
/* 001 */
/* 0001 */
/* 0000 011 */
/* 0000 11 */
/* 011 */
/* 1 */
/* 010 */
/* 0000 10 */
/* 0000 010 */
/*
/* horizontal mode */
/* vertical mode */
/* pass mode */
/*
/* NB: pseudo tag */
/* NB: pseudo tag */
/* XXX: avoid reading options if compression mismatches. */
/* XXX: avoid reading options if compression mismatches. */
/*
/*
/*
/* hook for codec tags */
/* hook for codec tags */
/* hook for codec tags */
/* FIXME: improve for in place update */
/* decoder does bit reversal */
/*
/*
/*
/*
/*
/* imaginary change for reference */
/* don't error on badly-terminated strips */
/*
/* terminate strip w/ EOFB */
/* reuse G3 support */
/*
/*
/*
/*
/*
/* premature EOF */
/* reuse G3 support */
/*
/* reuse G3 support */
/*
/* CCITT_SUPPORT */
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_fax3sm.c
/* WARNING, this file was automatically generated by the
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_flush.c
/* $Id: tif_flush.c,v 1.9 2010-03-31 06:40:10 fwarmerdam Exp $ */
/*
/*
/* In update (r+) mode we try to detect the case where 
/*
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_getimage.c
/* $Id: tif_getimage.c,v 1.82 2012-06-06 00:17:49 fwarmerdam Exp $ */
/*
/*
/* 
/*
/* XYZ -> luminance matrix */
/* Light o/p for reference white */
/* Pixel values for ref. white */
/* Residual light o/p for black pixel */
/* Gamma values for the three guns */
/*
/*
/*
/* Initialize to normal values */
/* It is the default */
/* Workaround for some images without */
/* correct info about alpha channel */
/* data is pre-multiplied */
/* data is not pre-multiplied */
/* copy the colormaps so we can modify them */
/* fall thru... */
/* It would probably be nice to have a reality check here. */
/* can rely on libjpeg to convert to RGB */
/* XXX should restore current state on exit */
/*
/* do nothing */;
/*
/* little white lie */
/* little white lie */
/*
/* XXX verify rwidth and rheight against width and height */
/*
/* NOTREACHED */
/*
/*
/*
/*
/*
/*
/*
/* TODO: PACKW should have be made redundant in favor of Bitdepth16To8 LUT */
/*
/*
/*
/*
/*
/*
/*
/* use high order byte of 16bit value */
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/* adjust fromskew */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/*
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/* FALLTHROUGH */
/*
/* XXX adjust fromskew */
/*
/*
/*
/*
/* was x = w>>1; patched 2000/09/25 warmerda@home.com */
/*
/* TODO: naming of input vars is still off, change obfuscating declaration inside define, or resolve obfuscation */
/*
/*
/* treat 16 bit the same as eight bit */
/*
/* no longer need Map, free it */
/*
/* 
/* fall thru... */
/*
/*
/*
/*
/*
/* greyscale images processed pretty much as RGB by gtTileSeparate */
// Not alpha, but seems like the only way to get 4th band
/* TODO: add other cases here */
/*
/*
/*
/*
/*
/*
/*
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_jbig.c
/* $Id: tif_jbig.c,v 1.15 2010-03-10 18:56:48 bfriesen Exp $ */
/*
/*
/*
/* HAVE_JBG_NEWLEN */
/*
/*
/*
/* Setup the function pointers for encode, decode, and cleanup. */
/* JBIG_SUPPORT */
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_jpeg.c
/* $Id: tif_jpeg.c,v 1.111 2012-07-06 18:48:04 bfriesen Exp $ */
/*
/*
/* We undefine FAR to avoid conflict with JPEG definition */
/*
/*
/* Define "boolean" as unsigned char, not int, per Windows custom. */
/* don't conflict if rpcndr.h already read */
/* prevent jmorecfg.h from redefining it */
/* 
/*
/*
/*
/* NB: must be first */
/* libjpeg error manager */
/* for catching libjpeg failures */
/*
/* data dest for compression */
/* data source for decompression */
/* private state */
/* back link needed by some code */
/* copy of PhotometricInterpretation */
/* luminance sampling factors */
/* decompressed bytes per scanline */
/* pointers to intermediate buffers when processing downsampled data */
/* number of "scanlines" accumulated */
/* super-class method */
/* super-class method */
/* super-class method */
/* super-class method */
/* super-class method */
/* pseudo-tag fields */
/* JPEGTables tag value, or NULL */
/* number of bytes in same */
/* Compression quality level */
/* Auto RGB<=>YCbCr convert? */
/* What to put in JPEGTables */
/*
/*
/* NB: cinfo assumed first */
/* display the error message */
/* clean up libjpeg state */
/* return to libtiff caller */
/*
/*
/* initialize JPEG error handling */
/* initialize JPEG error handling */
/*
/* the entire buffer has been filled */
/*
//trac.osgeo.org/gdal/wiki/JpegIPP
/* NB: libtiff does the final buffer flush */
/*
/* while building, jpegtables_length is allocated buffer size */
/* the entire buffer has been filled; enlarge it by 1000 bytes */
/* set tables length to number of bytes actually emitted */
/*
/*
/*
//trac.osgeo.org/gdal/wiki/JpegIPP
/*
//trac.osgeo.org/gdal/ticket/3894
/* insert a fake EOI marker */
/* oops, buffer overrun */
/* No work necessary here */
/* for safety */
/*
/*
/*
/*
//bugzilla.remotesensing.org/show_bug.cgi?id=168
/* Do not even try to check if the first strip/tile does not
/* this type of marker has no data and should be skipped */
/* this type of marker has data, but it has no use to us and should be skipped */
/* this marker contains the subsampling factors we're scanning for */
/* Read JPEGTables if it is present */
/* Grab parameters that are same for all strips/tiles */
/* TIFF 6.0 forbids subsampling of all other color spaces */
/* Set up for reading normal data */
/* override byte swapping */
/*
/*
/*
/*
/*
/*
/* Component 0 should have expected sampling factors */
/* Rest should have sampling factors 1,1 */
/* PC 2's single component should have sampling factors 1,1 */
/* Convert YCbCr to RGB */
/* Suppress colorspace handling */
/* XXX what about up-sampling? */
/* Need to use raw-data interface to libjpeg */
/* JPEG_LIB_VERSION >= 70 */
/* Use normal interface to libjpeg */
/* Start JPEG decompressor */
/* Allocate downsampled-data buffers if needed */
/* mark buffer empty */
/*
/*ARGSUSED*/ static int
/*
/* data is expected to be read in multiples of a scanline */
/*
/*
/*
/* Update information on consumed data */
/* Close down the decompressor if we've finished the strip or tile. */
/*ARGSUSED*/ static int
/*
/*ARGSUSED*/ static int
/* data is expected to be read in multiples of a scanline */
/* Cb,Cr both have sampling factors 1, so this is correct */
/* Reload downsampled-data buffer if needed */
/*
/* first sample in clump */
/* fast path for at least Cb and Cr */
/* general case */
/* 12-bit */
/* Close down the decompressor if done. */
/*
/* Initialize quant tables for current quality setting */
/* Mark only the tables we want for output */
/* NB: chrominance tables are currently used only with YCbCr */
/* Direct libjpeg output into jpegtables */
/* Emit tables-only datastream */
/*
/* Set per-file parameters */
/*
/* disallowed by Tech Note */
/* TIFF 6.0 forbids subsampling of all other color spaces */
/* Verify miscellaneous parameters */
/*
/* BITS_IN_JSAMPLE now permits 8 and 12 --- dgilbert */
/* Create a JPEGTables field if appropriate */
/* Mark the field present */
/* Can't use TIFFSetField since BEENWRITING is already set! */
/* We do not support application-supplied JPEGTables, */
/* so mark the field not present */
/* Direct libjpeg output to libtiff's output buffer */
/*
/*
/* for PC 2, scale down the strip/tile size
/*
/* jpeg_set_colorspace set all sampling factors to 1 */
/* jpeg_set_colorspace() set sampling factors to 1 */
/* ensure libjpeg won't write any extraneous markers */
/* set up table handling correctly */
/* Need to use raw-data interface to libjpeg */
/* Use normal interface to libjpeg */
/* Start JPEG compressor */
/* Allocate downsampled-data buffers if needed */
/*
/* data is expected to be supplied in multiples of a scanline */
/* The last strip will be limited to image size */
// FIXME: undiagnosed malloc failure
/*
/* data is expected to be supplied in multiples of a clumpline */
/* a clumpline is equivalent to v_sampling desubsampled scanlines */
/* TODO: the following calculation of bytesperclumpline, should substitute calculation of sp->bytesperline, except that it is per v_sampling lines */
/* Cb,Cr both have sampling factors 1, so this is correct */
/*
/* first sample in clump */
/* fast path for at least Cb and Cr */
/* general case */
/* pad each scanline as needed */
/*
/*
/* release libjpeg resources */
/* tag value */
/* release local state */
/*
/* XXX what about up-sampling? */
/*
/* XXX */
/* pseudo tag */
/* pseudo tag */
/* pseudo tag */
/* mark the fact that we have a real ycbcrsubsampling! */
/* should we be recomputing upsampling info here? */
/*
/*
/*
/*
/* back link */
/*
/* hook for codec tags */
/* hook for codec tags */
/* hook for codec tags */
/* Default values for codec-specific fields */
/* Default IJG quality */
/*
/* no bit reversal, please */
/*
/*
// FIXME: NULL-deref after malloc failure
/* JPEG_SUPPORT */
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_jpeg_12.c
/* back link */
/*
/* hook for codec tags */
/* hook for codec tags */
/* hook for codec tags */
/*
/* no bit reversal, please */
/* defined(JPEG_DUAL_MODE_8_12) */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_luv.c
/* $Id: tif_luv.c,v 1.35 2011-04-02 20:54:09 bfriesen Exp $ */
/*
/*
/*
/* user data format */
/* encoding method */
/* bytes per pixel */
/* translation buffer */
/* buffer length */
/* super-class method */
/* super-class method */
/* minimum run length */
/*
/* get each byte string */
/* run */
/* TODO: potential input buffer overrun when decoding corrupt or truncated data */
/* non-run */
/* nul is noop */
/*
/* copy to array of uint32 */
/*
/* get each byte string */
/* run */
/* TODO: potential input buffer overrun when decoding corrupt or truncated data */
/* non-run */
/* nul is noop */
/*
/*
/*
/* compress each byte string */
/* find next run */
/* long enough */
/*check short run */
/* write out non-run */
/* write out run */
/*
/* write out encoded pixels */
/*
/* compress each byte string */
/* find next run */
/* long enough */
/* check short run */
/* write out non-run */
/* write out run */
/*
/*
/*
/* compute luminance from 16-bit LogL */
/* get 16-bit LogL from Y */
/* assume CCIR-709 primaries */
/* assume 2.0 gamma for speed */
/* could use integer sqrt approx., but this is probably faster */
/* compute luminance from 10-bit LogL */
/* get 10-bit LogL from Y */
/* encode out-of-gamut chroma */
/* set up perimeter table */
/* fill any holes */
/* look up hue angle */
/* encode (u',v') coordinates */
/* decode (u',v') index */
/* binary search */
/* decode luminance */
/* decode color */
/* convert to XYZ */
/* encode luminance */
/* encode color */
/* never happens */
/* combine encodings */
/* never happens */
/* decode luminance */
/* decode color */
/* convert to XYZ */
/* encode luminance */
/* encode color */
/* combine encodings */
/* for some reason, we can't do this in TIFFInitLogL16 */
/*
/*
/* for some reason, we can't do this in TIFFInitLogLuv */
/*
/*
/*
/*
/*
/*
/*
/* hook for codec tags */
/* hook for codec tags */
/* LOGLUV_SUPPORT */
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_lzma.c
/* $Id: tif_lzma.c,v 1.4 2011-12-22 00:29:29 bfriesen Exp $ */
/*
/*
//tukaani.org/xz/ for details.
/*
/* delta filter options */
/* LZMA2 filter options */
/* compression level */
/* type of the integrity check */
/* state flags */
/* super-class method */
/* super-class method */
/* if we were last encoding, terminate this mode */
/*
/*
/*
/* cast away const */
/*
/*
/* this is a safe typecast, as check is made already in LZMAPreEncode */
/*
/* this is a safe typecast, as check is made already in ZIPPreEncode */
/*NOTREACHED*/
/*
/*
/*
/* hook for codec tags */
/* hook for codec tags */
/* Default values for codec-specific fields */
/* default comp. level */
/* Data filters. So far we are using delta and LZMA2 filters only. */
/*
/*
/*
/* LZMA_SUPORT */
/* vim: set ts=8 sts=8 sw=8 noet: */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_lzw.c
/* $Id: tif_lzw.c,v 1.45 2011-04-02 20:54:09 bfriesen Exp $ */
/*
/*
/*
/* include backwards compatibility code */
/*
/* include checks for strips w/o EOI code */
/*
/* start with 9 bits */
/* max of 12 bit strings */
/* predefined codes */
/* code to clear string table */
/* end-of-information code */
/* first free code entry */
/* 91% occupancy */
/* NB: +1024 is for compatibility with old files */
/*
/* predictor super class */
/* # of bits/code */
/* maximum code for lzw_nbits */
/* next free entry in hash table */
/* next bits of i/o */
/* # of valid bits in lzw_nextdata */
/* preserve rw_mode from init */
/*
/* codes fit in 16 bits */
/*
/* string len, including this token */
/* data value */
/* first token of string */
/* Decoding specific data */
/* lzw_nbits 1 bits, right adjusted */
/* restart count */
/* available bits in raw data */
/* regular or backwards compatible */
/* current recognized code */
/* previously recognized code */
/* next free entry */
/* max available entry */
/* kept separate for small machines */
/* Encoding specific data */
/* last code encountered */
/* point at which to clear table */
/* enc_ratio check interval */
/* current compression ratio */
/* (input) data bytes encoded */
/* encoded (output) bytes */
/* bound on tif_rawdata buffer */
/* kept separate for small machines */
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/* !LZW_COMPAT */
/* !LZW_COMPAT */
/*
/*
/*
/*
/*
/*
/*
/* should not happen */
/*
/*
/*
/*
/*
/*
/*
/*
/* should not happen */
/*
/*
/* LZW_COMPAT */
/*
/*
/*
/* clear hash table */
/* generates CODE_CLEAR in LZWEncode */
/* NB: shift will overflow */\
/*
/*
/*
/* xor hashing */
/*
/*
/*
/*
/*
/* table is full, emit clear code and reset */
/*
/*
/*
/*
/*
/*
/*
/*
/*
/* LZW_SUPPORT */
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_next.c
/* $Id: tif_next.c,v 1.13 2010-03-10 18:56:48 bfriesen Exp $ */
/*
/*
/*
/*
/*
/*
/*
/* NEXT_SUPPORT */
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_ojpeg.c
/* $Id: tif_ojpeg.c,v 1.56 2012-05-24 03:15:18 fwarmerdam Exp $ */
/* WARNING: The type of JPEG encapsulation defined by the TIFF Version 6.0
//www.remotesensing.org/libtiff/>
//www.awaresystems.be/imaging/tiff.html>. It is also absorbed
//www.awaresystems.be/>
/* What is what, and what is not?
/* Configuration defines here are:
/* define LIBJPEG_ENCAP_EXTERNAL */
/* define EGYPTIANWALK */
/* We undefine FAR to avoid conflict with JPEG definition */
/*
/* Define "boolean" as unsigned char, not int, per Windows custom. */
/* don't conflict if rpcndr.h already read */
/* prevent jmorecfg.h from redefining it */
/* if the codec outputs subsampled data, a 'line' in bytes_per_line */
/* and lines_per_strile means subsampling_ver desubsampled rows     */
/*
/* state block */
/* tif codec methods */
/* tif tag methods */
/* Some OJPEG files don't have strip or tile offsets or bytecounts tags.
/* if a previous attempt failed, don't try again */
/* this type of marker has no data, and should be skipped */
/* this type of marker has data, but it has no use to us (and no place here) and should be skipped */
/* this could easilly cause trouble in some cases... but no such cases have occured sofar */
/* this is a table marker, and it is to be saved as a whole for exact pushing on the jpeg stream later on */
/* this is a table marker, and it is to be saved as a whole for exact pushing on the jpeg stream later on */
/* TODO: the following assumes there is only one table in this marker... but i'm not quite sure that assumption is guaranteed correct */
/* this marker needs to be checked, and part of its data needs to be saved for regeneration later on */
/* Lf: data length */
/* P: Sample precision */
/* Y: Number of lines, X: Number of samples per line */
/* Y: Number of lines */
/* X: Number of samples per line */
/* Nf: Number of image components in frame */
/* per component stuff */
/* TODO: double-check that flow implies that n cannot be as big as to make us overflow sof_c, sof_hv and sof_tq arrays */
/* C: Component identifier */
/* H: Horizontal sampling factor, and V: Vertical sampling factor */
/* Tq: Quantization table destination selector */
/* this marker needs to be checked, and part of its data needs to be saved for regeneration later on */
/* Ls */
/* Ns */
/* Cs, Td, and Ta */
/* Cs */
/* Td and Ta */
/* skip Ss, Se, Ah, en Al -> no check, as per Tom Lane recommendation, as per LibJpeg source */
/* TODO: double-check: when subsamplingcorrect is set, no call to TIFFErrorExt or TIFFWarningExt should be made
/* we don't skip past jpeginterchangeformat/strile block...
/* Lf */
/* P */
/* Y */
/* X */
/* Nf */
/* C */
/* H and V */
/* Tq */
/* Ls */
/* Ns */
/* Cs */
/* Td and Ta */
/* Ss */
/* Se */
/* Ah and Al */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_open.c
/* $Id: tif_open.c,v 1.46 2010-12-06 16:54:54 faxguy Exp $ */
/*
/*
/*
/* The following are configuration checks. They should be redundant, but should not
/* non-existent directory */
/* invalid strip */
/* read/write pre-increment */
/* setup default state */
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/* XXX avoid flush */
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_packbits.c
/* $Id: tif_packbits.c,v 1.22 2012-06-20 05:25:33 fwarmerdam Exp $ */
/*
/*
/*
/*
/*
/* insure space for new data */
/*
/* initial state, set run/literal */
/* last object was literal string */
/* encode run */
/* extend literal */
/* last object was run */
/* literal followed by a run */
/*
/* replicate */
/*
/*
/* replicate next byte -n+1 times */
/* nop */
/* copy next n+1 bytes literally */
/* PACKBITS_SUPPORT */
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_pixarlog.c
/* $Id: tif_pixarlog.c,v 1.38 2012-06-21 01:01:53 fwarmerdam Exp $ */
/*
/*
//trac.osgeo.org/gdal/ticket/3894.   FrankW - Jan'11
/* Tables for converting to/from 11 bit coded values */
/* decode table size (11-bit tokens) */
/* Plus one for slop */
/* token value of 1.0 exactly */
/* nominal ratio for log part */
/* 11 bits. */
/* 
/*
/* super-class method */
/* super-class method */
/* Really for 16-bit data, but we shift down 2 */
/*
/* Really for 16-bit data, but we shift down 2 */
/* nlin must be an integer */
/* multiplicative scale factor [b*exp(c*ONE) = 1] */
/* if (v >= 2)  token = k1*log(v*k2) */
/*
/* If the user didn't tell us his datafmt,
/* Make sure no byte swapping happens on the data
/* for some reason, we can't do this in TIFFInitPixarLog */
/* TODO: this is an error return without error report through TIFFErrorExt */
/*
/* if this assert gets raised,
/* XXX float == 32 bits */
/* XXX uint16 == 16 bits */
/* if this assert gets raised,
/* XXX */
/* hopefully, we got all the bytes we needed */
/* Swap bytes in the data if from a different endian machine. */
/*
/* for some reason, we can't do this in TIFFInitPixarLog */
/* TODO: this is an error return without error report through TIFFErrorExt */
/*
/* if this assert gets raised,
/* point to last one */
/* point to last one */
/* assumption is unsigned pixel values */
/* point to last one */
/* point to last one */
/* point to last one */
/* point to last one */
/*
/* XXX float == 32 bits */
/* XXX uint16 == 16 bits */
/* if this assert gets raised,
/* this is a safe typecast, as check is made already in PixarLogPreEncode */
/*
/* this is a safe typecast, as check is made already in PixarLogPreEncode */
/* In a really sneaky (and really incorrect, and untruthfull, and
/* Tweak the TIFF header so that the rest of libtiff knows what
/*
/* NB: pseudo tag */
/*
/*
/*
/* Override SetField so we can handle our private pseudo-tag */
/* hook for codec tags */
/* hook for codec tags */
/* Default values for codec-specific fields */
/* default comp. level */
/* we don't wish to use the predictor, 
/*
/* PIXARLOG_SUPPORT */
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_predict.c
/* $Id: tif_predict.c,v 1.32 2010-03-10 18:56:49 bfriesen Exp $ */
/*
/*
/* no differencing */
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/* XXX horizontal differencing alters user's data XXX */
/* 
//trac.osgeo.org/gdal/ticket/1965
/* XXX */
/*
/*
/* hook for predictor tag */
/* hook for predictor tag */
/* hook for predictor tag */
/* default value */
/* no predictor routine */
/* no predictor routine */
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_print.c
/* $Id: tif_print.c,v 1.60 2012-08-19 16:56:35 bfriesen Exp $ */
/*
/*
/* PHOTOMETRIC_MINISWHITE */
/* PHOTOMETRIC_MINISBLACK */
/* PHOTOMETRIC_RGB */
/* PHOTOMETRIC_PALETTE */
/* PHOTOMETRIC_MASK */
/* PHOTOMETRIC_SEPARATED */
/* PHOTOMETRIC_YCBCR */
/* PHOTOMETRIC_CIELAB */
/* PHOTOMETRIC_ICCLAB */
/* PHOTOMETRIC_ITULAB */
/* ORIENTATION_TOPLEFT */
/* ORIENTATION_TOPRIGHT */
/* ORIENTATION_BOTRIGHT */
/* ORIENTATION_BOTLEFT */
/* ORIENTATION_LEFTTOP */
/* ORIENTATION_RIGHTTOP */
/* ORIENTATION_RIGHTBOT */
/* ORIENTATION_LEFTBOT */
/* do not try to pretty print auto-defined fields */
/*
/*
/*
/* TODO: This is an evil exception and should not have been
/*
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_read.c
/* $Id: tif_read.c,v 1.41 2012-07-06 19:22:58 bfriesen Exp $ */
/*
/*
/* undefined state */
/* undefined state */
/* tmsize_t bytecountm; */
/*
/* bytecountm=(tmsize_t) td->td_stripbytecount[strip]; */
/*
/*
/*
/*
/*
/*
/* out of range */
/*
/*
/* different strip, refill */
/*
/*
/*
/* TODO: Will this really work with partial buffers? */
/*
/* we are now poised at the beginning of the next row */
/*
/*
/*
/*
/*
/*
/*
/* 
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_strip.c
/* $Id: tif_strip.c,v 1.35 2012-06-06 05:33:55 fwarmerdam Exp $ */
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_swab.c
/* $Id: tif_swab.c,v 1.13 2010-03-10 18:56:49 bfriesen Exp $ */
/*
/*
/* XXX unroll loop some */
/* XXX unroll loop some */
/* XXX unroll loop some */
/* XXX unroll loop some */
/* XXX unroll loop some */
/* XXX unroll loop some */
/*
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_thunder.c
/* $Id: tif_thunder.c,v 1.12 2011-04-02 20:54:09 bfriesen Exp $ */
/*
/*
/*
/* mask for 6-bit data */
/* mask for 2-bit code word */
/* code values */
/* run of pixels w/ encoded count */
/* 3 pixels w/ encoded 2-bit deltas */
/* skip code for 2-bit deltas */
/* 2 pixels w/ encoded 3-bit deltas */
/* skip code for 3-bit deltas */
/* raw data encoded */
/* pixel run */
/*
/* 2-bit deltas */
/* 3-bit deltas */
/* raw data */
/* THUNDER_SUPPORT */
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_tile.c
/* $Id: tif_tile.c,v 1.23 2012-06-06 05:33:55 fwarmerdam Exp $ */
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/* roundup to a multiple of 16 per the spec */
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_unix.c
/* $Id: tif_unix.c,v 1.23 2012-06-01 21:40:59 fwarmerdam Exp $ */
/*
/*
/* this is really gross */
/* !HAVE_MMAP */
/* !HAVE_MMAP */
/*
/*
/* for cygwin and mingw */
/*
/* for cygwin and mingw */
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_version.c
/* $Header: /cvs/maptools/cvsroot/libtiff/libtiff/tif_version.c,v 1.3 2010-03-10 18:56:49 bfriesen Exp $ */
/*
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_warning.c
/* $Header: /cvs/maptools/cvsroot/libtiff/libtiff/tif_warning.c,v 1.3 2010-03-10 18:56:49 bfriesen Exp $ */
/*
/*
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_win32.c
/* $Id: tif_win32.c,v 1.39 2011-12-22 17:07:57 bfriesen Exp $ */
/*
/*
/* tmsize_t is 64bit on 64bit systems, but the WinAPI ReadFile takes
/* tmsize_t is 64bit on 64bit systems, but the WinAPI WriteFile takes
/*
/* By passing in 0 for the maximum file size, it specifies that we
/*
/*
/*
/* ndef _WIN32_WCE */
/* ndef _WIN32_WCE */
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_write.c
/* $Id: tif_write.c,v 1.37 2012-08-13 22:10:17 fwarmerdam Exp $ */
/*
/*
/* expansion factor on strip array */
/*
/* not strictly sure this is right*/
/*
/* extend image */
/*
/*
/*
/*
/* if we are writing over existing tiles, zero length */
/* this forces TIFFAppendToStrip() to do a seek */
/*
/*
/*
/* swab if needed - note that source buffer will be altered */
/* we are now poised at the beginning of the next row */
/*
/*
/*
/* Make sure that at the first attempt of rewriting the tile, we will have */
/* more bytes available in the output buffer than the previous byte count, */
/* so that TIFFAppendToStrip() will detect the overflow when it is called the first */
/* time if the new compressed tile is bigger than the older one. (GDAL #4771) */
/* Force TIFFAppendToStrip() to consider placing data at end
/* swab if needed - note that source buffer will be altered */
/*
/*
/*
/*
/*
/*
/*
/* Make sure that at the first attempt of rewriting the tile, we will have */
/* more bytes available in the output buffer than the previous byte count, */
/* so that TIFFAppendToStrip() will detect the overflow when it is called the first */
/* time if the new compressed tile is bigger than the older one. (GDAL #4771) */
/* Force TIFFAppendToStrip() to consider placing data at end
/* 
/*
/* swab if needed - note that source buffer will be altered */
/*
/*
/*
/*
/* 
/*
/*
/* NB: force malloc */
/*
/*
/* 
/* 
/*
/*
/*
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libtiff\tif_zip.c
/* $Id: tif_zip.c,v 1.31 2011-01-06 16:00:23 fwarmerdam Exp $ */
/*
/*
//ftp.uu.net/pub/archiving/zip/doc.  The library was
//ftp.uu.net/pub/archiving/zip/zlib/zlib-0.99.tar.gz.
/*
/*
/* compression level */
/* state flags */
/* super-class method */
/* super-class method */
/* if we were last encoding, terminate this mode */
/*
/* if this assert gets raised,
/* if this assert gets raised,
/*
/* if this assert gets raised,
/*
/* if this assert gets raised,
/* this is a safe typecast, as check is made already in ZIPPreEncode */
/*
/* this is a safe typecast, as check is made already in ZIPPreEncode */
/*NOTREACHED*/
/*
/*
/*
/* hook for codec tags */
/* hook for codec tags */
/* Default values for codec-specific fields */
/* default comp. level */
/*
/*
/* ZIP_SUPORT */
/* vim: set ts=8 sts=8 sw=8 noet: */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\lib\analysis.c
/********************************************************************
//www.xiph.org/                  *
/* decides between modes, dispatches to the appropriate mapping. */
/* first things first.  Make sure encode is ready */
/* we only have one mapping type (0), and we let the mapping code
/* The app is using a bitmanaged mode... but not using the
/* for sake of completeness */
/* there was no great place to put this.... */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\lib\barkmel.c
/********************************************************************
//www.xiph.org/                  *
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\lib\bitrate.c
/********************************************************************
//www.xiph.org/                  *
/* compute bitrate tracking setup  */
/* not a necessary fix, but one that leads to a more balanced
/* finish taking in the block we just processed */
/* not a bitrate managed stream, but for API simplicity, we'll
/* one has been submitted without
/* look ahead for avg floater */
/* choosing a new floater:
/* enforce min(if used) on the current floater (if used) */
/* do we need to force the bitrate up? */
/* enforce max (if used) on the current floater (if used) */
/* do we need to force the bitrate down? */
/* Choice of packetblobs now made based on floater, and min/max
/* choosing a smaller packetblob is insufficient to trim bitrate.
/* prop up bitrate according to demand. pad this frame out with zeroes */
/* now we have the final packet and the final packet size.  Update statistics */
/* min and max reservoir */
/* inbetween; we want to take reservoir toward but not past desired_fill */
/* logical bulletproofing against initialization state */
/* logical bulletproofing against initialization state */
/* avg reservoir */
/* for sake of completeness */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\lib\block.c
/********************************************************************
//www.xiph.org/                  *
/* pcm accumulator examples (not exhaustive):
/* block abstraction setup *********************************************/
/* can't just _ogg_realloc... there are outstanding pointers */
/* highly conservative */
/* reap the chain, pull the ripcord */
/* reap the chain */
/* consolidate storage */
/* pull the ripcord */
/* Analysis side code, but directly related to blocking.  Thus it's
/* MDCT is tranform 0 */
/* Vorbis I uses only window type 0 */
/* note that the correct computation below is technically:
/* encode/decode differ here */
/* analysis always needs an fft */
/* finish the codebooks */
/* finish the codebooks */
/* decode codebooks are now standalone after init */
/* initialize the storage vectors. blocksize[1] is small for encode,
/* all 1 (large block) or 0 (small block) */
/* explicitly set for the sake of clarity */
/* previous window size */
/* current window size */
/* all vector indexes */
/* initialize all the backend lookups */
/* arbitrary settings and spec-mandated numbers get filled in here */
/* Initialize the envelope state storage */
/* compressed audio packets start after the headers
/* free header, header1, header2 */
/* free header, header1, header2 */
/* Do we have enough storage space for the requested buffer? If not,
/* safety */
/* need to run the extrapolation in reverse! */
/* prime as above */
/* run the predictor filter */
/* call with val<=0 to set eof */
/* if it wasn't done earlier (very short sample) */
/* We're encoding the end of the stream.  Just make sure we have
/* actually, we don't want zeroes; that could drop a large
/* extrapolate with LPC to fill in */
/* make a predictor filter */
/* run the predictor filter */
/* not enough data to extrapolate (unlikely to happen due to
/* we may want to reverse extrapolate the beginning of a stream
/* clumsy, but simple.  It only runs once, so simple is good. */
/* do the deltas, envelope shaping, pre-echo and determine the size of
/* check to see if we're started... */
/* check to see if we're done... */
/* By our invariant, we have lW, W and centerW set.  Search for
/* we do an envelope search even on a single blocksize; we may still
/* not enough data currently to search for a
/* center of next block + next block maximum right side. */
/* not enough data yet;
/* fill in the block.  Note that for a short window, lW and nW are *short*
/*fprintf(stderr,"-");*/
/*fprintf(stderr,"_");*/
/*fprintf(stderr,"|");*/
/*fprintf(stderr,".");*/
/* copy the vectors; this uses the local storage in vb */
/* this tracks 'strongest peak' for later psychoacoustics */
/* moved to the global psy state; clean this mess up */
/* before we added the delay
/* handle eof detection: eof==0 means that we've not yet received EOF
/* advance storage vectors and clean up */
/* do not add padding to end of stream! */
/* done */
/* Unlike in analysis, the window is only partially applied for each
/* out of sequence; lose count */
/* no pcm to process if vorbis_synthesis_trackonly
/* v->pcm is now used like a two-stage double buffer.  We don't want
/* the overlap/add section */
/* large/large */
/* large/small */
/* small/large */
/* small/small */
/* the copy section */
/* deal with initial packet state; we do this using the explicit
/* track the frame number... This is for convenience, but also
/* only set if we have a position to set to */
/* is this a short page? */
/* corner case; if this is both the first and last audio page,
/* we use ogg_int64_t for granule positions because a
/* trim the end */
/* no preceding granulepos; assume we started at zero (we'd
/* granulepos could be -1 due to a seek, but that would result
/* Guard against corrupt/malicious frames that set EOP and
/* trim the beginning */
/* partial last frame.  Strip the extra samples off */
/* Guard against corrupt/malicious frames that set EOP and
/* we use ogg_int64_t for granule positions because a
/* else {Shouldn't happen *unless* the bitstream is out of
/* else {Shouldn't happen *unless* the bitstream is out of
/* Update, cleanup */
/* pcm==NULL indicates we just want the pending samples, no more */
/* intended for use with a specific vorbisfile feature; we want access
/* our returned data ends at pcm_returned; because the synthesis pcm
/* centerW was advanced by blockin; it would be the center of the
/* the data buffer wraps; swap the halves */
/* slow, sure, small */
/* solidify buffer into contiguous space */
/* long/short or short/long */
/* short/short */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\lib\codebook.c
/********************************************************************
//www.xiph.org/                  *
/* packs the given codebook into the bitstream **************************/
/* first the basic parameters */
/* pack the codewords.  There are two packings; length ordered and
/* length ordered.  We only need to say how many codewords of
/* ordered */
/* 1 to 32 */
/* length random.  Again, we don't code the codeword itself, just
/* unordered */
/* algortihmic mapping has use for 'unused entries', which we tag
/* no unused entries */
/* we have unused entries; thus we tag */
/* is the entry number the desired return value, or do we have a
/* no mapping */
/* implicitly populated value mapping */
/* explicitly populated value mapping */
/* no quantlist?  error */
/* values that define the dequantization */
/* a single column of (c->entries/c->dim) quantized values for
/* every value (c->entries*c->dim total) specified explicitly */
/* NOT_REACHABLE */
/* quantized values */
/* error case; we don't have any other map types now */
/* unpacks a codebook from the packet buffer into the codebook struct,
/* make sure alignment is correct */
/* first the basic parameters */
/* codeword ordering.... length ordered or unordered? */
/* allocated but unused entries? */
/* unordered */
/* allocated but unused entries? */
/* yes, unused entries */
/* all entries used; no tagging */
/* ordered */
/* EOF */
/* Do we have a mapping to unpack? */
/* no mapping */
/* implicitly populated value mapping */
/* explicitly populated value mapping */
/* quantized values */
/* all set */
/* returns the number of bits ************************************************/
/* the 'eliminate the decode tree' optimization actually requires the
/* Single entry codebooks use a firsttablen of 1 and a
/* bisect search for the codeword in the ordered list */
/* Decode side is specced and easier, because we don't need to find
/* returns the [original, not compacted] entry number or -1 on eof *********/
/* if there's no dec_index, the codebook unpacking isn't collapsed */
/* returns 0 on OK or -1 on eof *************************************/
/* decode vector / dim granularity gaurding is done in the upper layer */
/* decode vector / dim granularity gaurding is done in the upper layer */
/* unlike the others, we guard against n not being an integer number
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\lib\envelope.c
/********************************************************************
//www.xiph.org/                  *
/* not random */
/* magic follows */
/* fairly straight threshhold-by-band based until we find something
/* we want to have a 'minimum bar' for energy, else we're just
/* stretch is used to gradually lengthen the number of windows
/*_analysis_output_always("lpcm",seq2,data,n,0,0,
/* window and transform */
/*_analysis_output_always("mdct",seq2,vec,n/2,0,1,0); */
/* near-DC spreading function; this has nothing to do with
/* the accumulation is regularly refreshed from scratch to avoid
/* perform spreading and limiting, also smooth the spectrum.  yes,
/*_analysis_output_always("spread",seq2++,vec,n/4,0,0,0);*/
/* perform preecho/postecho triggering by band */
/* accumulate amplitude */
/* convert amplitude to delta */
/*filters[j].markers[pos]=valmax;*/
/* look at min/max, decide trigger */
/* make sure we have enough storage to match the PCM */
/* be sure */
/* account for postecho
/* adjust for placing marks
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\lib\floor0.c
/********************************************************************
//www.xiph.org/                  *
/***********************************************/
/* initialize Bark scale and normalization lookups.  We could do this
/* we choose a scaling constant so that:
/* the mapping from a linear scale to a smaller bark scale is
/* bark numbers represent band edges */
/* guard against the approximation */
/* also handles the -1 out of data case */
/* be paranoid */
/* the additional b->dim is a guard against any possible stack
/* take the coefficients back to a spectral envelope curve */
/* export hooks */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\lib\floor1.c
/********************************************************************
//www.xiph.org/                  *
/* floor 1 fixed at -140dB to 0dB range */
/***********************************************/
/*fprintf(stderr,"floor 1 bit usage %f:%f (%f total)\n",
/* save out partitions */
/* only 0 to 31 legal */
/* only 0 to 15 legal */
/* save out partition classes */
/* 1 to 8 */
/* 0 to 3 */
/* save out the post list */
/* only 1,2,3,4 legal now */
/* maxposit cannot legally be less than 1; this is encode-side, we
/* read partitions */
/* only 0 to 31 legal */
/* only 0 to 15 legal */
/* read partition classes */
/* 1 to 8 */
/* 0,1,2,3 bits */
/* read the post list */
/* only 1,2,3,4 legal now */
/* don't allow repeated values in post list as they'd result in
/* we drop each position value in-between already decoded values,
/* also store a sorted position index */
/* points from sort order back to range number */
/* points from range order to sorted position */
/* we actually need the post values too */
/* quantize values to multiplier spec */
/* 1024 -> 256 */
/* 1024 -> 128 */
/* 1024 -> 86 */
/* 1024 -> 64 */
/* discover our neighbors for decode where we don't use fit flags
/* mask off flag */
/* the floor has already been filtered to only include relevant sections */
/* limit to our range! */
/* in */
/* index by range list position */
/* index by range list position */
/* sorted index of range list position (+2) */
/* mark all unused */
/* mark all unused */
/* 0 for the implicit 0 post */
/* 1 for the implicit post at n */
/* no neighbor yet */
/* quantize the relevant floor points and collect them into line fit
/* start by fitting the implicit base case.... */
/* Non degenerate case */
/* start progressive splitting.  This is a greedy, non-optimal
/* eliminate repeat searches of a particular range with a memo */
/* haven't performed this error search yet */
/* A note: we want to bound/minimize *local*, not global, error */
/* outside error bounds/begin search area.  Split it. */
/* store new edge values */
/* store new neighbor values */
/* fill in posts marked as not using a fit; we will zero
/* overly simpleminded--- look again post 1.2 */
/* quantize values to multiplier spec */
/* 1024 -> 256 */
/* 1024 -> 128 */
/* 1024 -> 86 */
/* 1024 -> 64 */
/* find prediction values for each post and subtract them */
/* in case there was roundoff jitter
/* at this point the 'deviation' value is in the range +/- max
/* we have everything we need. pack it out */
/* mark nontrivial floor */
/* beginning/end post */
/* partition by partition */
/* generate the partition's first stage cascade value */
/* gcc's static analysis
/* write it */
/* write post values */
/* hack to allow training with 'bad' books */
/*else
/* generate quantized floor equivalent to what we'd unpack in decode */
/* render the lines */
/* be certain */
/* unpack wrapped/predicted values from stream */
/* partition by partition */
/* decode the partition's first stage cascade value */
/* unwrap positive values and reconsitute via linear interpolation */
/* render the lines */
/* guard lookup against out-of-range values */
/* guard lookup against out-of-range values */
/* be certain */
/* export hooks */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\lib\info.c
/********************************************************************
//www.xiph.org/                  *
/* general handling of the header and the vorbis_info structure (and
/* helpers */
/* +2 for = and \0 */
/* This is more or less the same as strncasecmp - but that doesn't exist
/* +1 for the = we append */
/* We return a pointer to the data, not a copy */
/* didn't find anything */
/* +1 for the = we append */
/* blocksize 0 is guaranteed to be short, 1 is guaranteed to be long.
/* used by synthesis, which has a full, alloced vi */
/* unpack does the range checking */
/* this may be cleaning up an aborted
/* unpack does the range checking */
/* this may be cleaning up an aborted
/* unpack does the range checking */
/* this may be cleaning up an aborted
/* knows if the book was not alloced */
/* Header packing/unpacking ********************************************/
/* EOP check */
/* EOP check */
/* all of the real encoding details are here.  The modes, books,
/* codebooks */
/* time backend settings; hooks are unused */
/* floor backend settings */
/* residue backend settings */
/* map backend settings */
/* mode settings */
/* top level EOP check */
/* Is this packet a vorbis ID header? */
/* Not the initial packet */
/* not an ID header */
/* not vorbis */
/* The Vorbis header is in three packets; the initial small packet in
/* Which of the three types of header is this? */
/* Also verify header-ness, vorbis */
/* not a vorbis header */
/* least significant *bit* is read first */
/* Not the initial packet */
/* previously initialized info header */
/* least significant *bit* is read first */
/* um... we didn't get the initial header */
/* previously initialized comment header */
/* least significant *bit* is read first */
/* um... we didn;t get the initial header or comments yet */
/* improperly initialized vorbis_info */
/* previously initialized setup header */
/* Not a valid vorbis header type */
/* pack side **********************************************************/
/* preamble */
/* basic information about the stream */
/* preamble */
/* vendor */
/* comments */
/* books */
/* times; hook placeholders */
/* floors */
/* residues */
/* maps */
/* modes */
/* first header packet **********************************************/
/* build the packet */
/* second header packet (comments) **********************************/
/* third header packet (modes/codebooks) ****************************/
/* We're not guaranteed a 64 bit unsigned type everywhere, so we
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\lib\lookup.c
/********************************************************************
//www.xiph.org/                  *
/* interpolated lookup based cos function, domain 0 to PI only */
/* interpolated 1./sqrt(p) where .5 <= p < 1. */
/* interpolated 1./sqrt(p) where .5 <= p < 1. */
/* interpolated lookup based fromdB function, domain -140dB to 0dB only */
/* interpolated 1./sqrt(p) where .5 <= a < 1. (.100000... to .111111...) in
/*  0.16 */
/*  1.16 */
/*  0.16 */
/* result 1.16 */
/* multiply val by 1/sqrt(2) */
/* interpolated lookup based fromdB function, domain -140dB to 0dB only */
/* a is in n.12 format */
/* interpolated lookup based cos function, domain 0 to PI only */
/* a is in 0.16 format, where 0==0, 2^^16-1==PI, return 0.14 */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\lib\lpc.c
/********************************************************************
//www.xiph.org/                  *
/* Some of these routines (autocorrelator, LPC coefficient estimator)
/* Preserved Copyright: *********************************************/
/* Copyright 1992, 1993, 1994 by Jutta Degener and Carsten Bormann,
/* Autocorrelation LPC coeff generation algorithm invented by
/* Input : n elements of time doamin data
/* autocorrelation, p+1 lag coefficients */
/* double needed for accumulator depth */
/* Generate lpc coefficients from autocorr values */
/* set our noise floor to about -100dB */
/* Sum up this iteration's reflection coefficient; note that in
/* Update LPC coefficients and total error */
/* slightly damp the filter */
/* we need the error value to know how big an impulse to hit the
/* in: coeff[0...m-1] LPC coefficients
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\lib\lsp.c
/********************************************************************
//www.xiph.org/                  *
//www.rothweiler.us for contact info).
//www.myown1.com/joe/lsf
/* Note that the lpc-lsp conversion finds the roots of polynomial with
/* three possible LSP to f curve functions; the exact computation
/* define either of these (preferably FLOAT_LOOKUP) to have faster
/* catch this in the build system; we #include for
/* side effect: changes *lsp to cosines of lsp */
/* odd order filter; slightly assymetric */
/* the last coefficient */
/* even order filter; still symmetric */
/* catch this in the build system; we #include for
/* side effect: changes *lsp to cosines of lsp */
/* 0 <= m < 256 */
/* set up for using all int later */
/* 2**-.5 in 0.16 */
/* pi,qi normalized collectively, both tracked using qexp */
/* odd order filter; slightly assymetric */
/* the last coefficient */
/* even order filter; still symmetric */
/* p*=p(1-w), q*=q(1+w), let normalization drift because it isn't
/* we've let the normalization drift because it wasn't important;
/* checks for 1.xxxxxxxxxxxxxxxx */
/* checks for 0.0xxxxxxxxxxxxxxx or less*/
/*  n.4         */
/*  m.8, m+n<=8 */
/*  8.12[0]     */
/* old, nonoptimized but simple version for any poor sap who needs to
/* side effect: changes *lsp to cosines of lsp */
/* odd order filter; slightly assymetric */
/* the last coefficient */
/* even order filter; still symmetric */
/* Newton-Raphson-Maehly actually functioned as a decent root finder,
/* iterate a root */
/* eval the polynomial and its first two derivatives */
/* Laguerre's method */
/* complex root!  The LPC generator handed us a bad filter */
/* forward deflation */
/* for spit-and-polish only */
/* Update each point. */
/* Replaced the original bubble sort with a real sort.  With your
/* Convert lpc coefficients to lsp coefficients */
/* even and odd are slightly different base cases */
/* Compute the lengths of the x polynomials. */
/* Compute the first half of K & R F1 & F2 polynomials. */
/* Compute half of the symmetric and antisymmetric polynomials. */
/* Remove the roots at +1 and -1. */
/* Convert into polynomials in cos(alpha) */
/* Find the roots of the 2 even polynomials.*/
/* if it fails, it leaves g1r alone */
/* if it fails, it leaves g2r alone */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\lib\mapping0.c
/********************************************************************
//www.xiph.org/                  *
/* simplistic, wasteful way of doing this (unique lookup for each
/* another 'we meant to do it this way' hack...  up to beta 4, we
/* 2,3:reserved */
/* we don't write the channel submappings if we only have one... */
/* time submap unused */
/* also responsible for range checking */
/* vi->channels > 0 is enforced in the caller */
/* 2,3:reserved */
/* time submap unused */
/* + .345 is a hack; the original
/* window the PCM data */
/* transform the PCM data */
/* only MDCT right now.... */
/* FFT yields more accurate tonal estimation (not phase sensitive) */
/* + .345 is a hack; the
/* +
/* the encoder setup assumes that all the modes used by any
/* the following makes things clearer to *me* anyway */
/* + .345 is a hack; the original
/* first step; noise masking.  Not only does 'noise masking'
/* noise does not have by-frequency offset
/* second step: 'all the other crap'; all the stuff that isn't
/* third step; we offset the noise vectors, overlay tone
/* this algorithm is hardwired to floor 1 for now; abort out if
/* are we managing bitrate?  If so, perform two more fits for
/* higher rate by way of lower noise curve */
/* lower rate by way of higher noise curve */
/* we also interpolate a range of intermediate curves for
/*
/* iterate over the many masking curve fits we've created */
/* start out our new packet blob with packet type and mode */
/* Encode the packet type */
/* Encode the modenumber */
/* Encode frame mode, pre,post windowsize, then dispatch */
/* encode floor, compute masking curve, sep out residue */
/* our iteration is now based on masking curve, not prequant and
/* quantize/couple */
/* incomplete implementation that assumes the tree is all depth
/* classify and encode by submap */
/* ok, done encoding.  Next protopacket. */
/* recover the spectral envelope; store it in the PCM vector for now */
/* channel coupling can 'dirty' the nonzero listing */
/* recover the residue into our working vectors */
/* channel coupling */
/* compute and apply spectral envelope */
/* transform the PCM data; takes PCM vector, vb; modifies PCM vector */
/* only MDCT right now.... */
/* all done! */
/* export hooks */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\lib\mdct.c
/********************************************************************
//www.xiph.org/                  *
/* this can also be run as an integer transform by uncommenting a
/* build lookups for trig functions; also pre-figure scaling and
/* trig lookups... */
/* bitreverse lookup... */
/* 8 point butterfly (in place, 4 register) */
/* 16 point butterfly (in place, 4 register) */
/* 32 point butterfly (in place, 4 register) */
/* N point first stage butterfly (in place, 2 register) */
/* N/stage point generic N stage butterfly (in place, 2 register) */
/* rotate */
/* roatate + window */
/* forward needs working space */
/* rotate */
/* window + rotate + step 1 */
/* roatate + window */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\lib\psy.c
/********************************************************************
//www.xiph.org/                  *
/* we add back in the ATH to avoid low level curves falling off to
/* A half-band's settings must be valid over the whole band, and
/* copy curves into working space, replicate the 50dB curve to 30
/* apply centered curve boost/decay */
/* normalize curves so the driving amplitude is 0dB */
/* make temp curves with the ATH overlayed */
/* Now limit the louder curves.
/* low frequency curves are measured with greater resolution than
/* which octave curves will we be compositing? */
/* render the curve into bins, then pull values back into curve.
/* be equally paranoid about being valid up to next half ocatve */
/* add fenceposts */
/* AoTuV HF weighting */
/* 32kHz */
/* 48kHz */
/* set up the lookups for a given blocksize and sample rate */
/* set up rolling noise median */
/* octave/(8*eighth_octave_lines) x scale and dB y scale */
/* prime the working vector with peak values */
/* we completely overlap, making stack-1 irrelevant.  pop it */
/* the stack now contains only the positions that are relevant. Scan
/* +1 is important, else bin 0 is
/* there.  Linear time.  I now remember this was on a problem set I
/* bleaugh, this is more complicated than it needs to be */
/* for masking */
/* set the ATH (floating below localmax, not global max by a
/* tone masking */
/* AoTuV */
/* AoTuV */
/** @ M1 **
/* coeffi is a -17.2dB threshold */
/* val == mdct line value relative to floor in dB */
/* mdct value is > -17.2 dB below floor */
/* pro-rated attenuation:
/* mdct value is <= -17.2 dB below floor */
/* pro-rated attenuation:
/* this is for per-channel noise normalization */
/* Overload/Side effect: On input, the *q vector holds either the
/* force classic behavior where only energy in the current band is considered */
/* still responsible for populating *out where noise norm not in
/* lossless coupling already quantized.
/* sort magnitudes for noise norm portion of partition */
/* can't noise norm elements that have
/* Despite all the new, more capable coupling code, for now we
/* also-- the original point code only applied noise norm at > pointlimit */
/* q is fabs(r) for unflagged element */
/* For now: no acc adjustment for nonzero quantization.  populate *out and q as this value is final. */
/* else{
/* noise norm to do */
/* Noise normalization, quantization and coupling are not wholly
/* a blend of the AoTuV M2 and M3 code here and below */
/* mdct is our raw mdct output, floor not removed. */
/* inout passes in the ifloor, passes back quantized result */
/* unquantized energy (negative indicates amplitude has negative sign) */
/* dual pupose; quantized energy (if flag set), othersize fabs(raw) */
/* floor energy */
/* flags indicating raw/quantized status of elements in raw vector */
/* non-zero flag working vector */
/* energy surplus/defecit tracking */
/* The threshold of a stereo is changed with the size of n */
/* prefill */
/* coupling */
/* lossless coupling */
/* couple iM/iA */
/* collapse two equivalent tuples to one */
/* lossy (point) coupling */
/* dipole */
/* AoTuV */
/** @ M2 **
/* elliptical */
/* elliptical */
/* normalize the resulting mag vector */
/* make sure coupling a zero and a nonzero channel results in two
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\lib\psytune.c
/********************************************************************
//www.xiph.org/                  *
/* NB: this is dead code, retained purely for doc and reference value
/* decaydBpms */
/* lines per eighth octave */
/* thresh sample period, preecho clamp trigger threshhold, range, minenergy */
/*{ 9999, 1.5f, 9e10f,       .5f,9999.f},*/
/* floor master att */
/*     0  1  2   3   4   5   6   7   8   9  10  11  12  13  14  15   16   */
/* x: 63 88 125 175 250 350 500 700 1k 1.4k 2k 2.8k 4k 5.6k 8k 11.5k 16k Hz */
/* y: 0 10 20 30 40 50 60 70 80 90 100 dB */
/* tonemaskp */
/* tone master att */
/*  0   10   20   30   40   50   60   70   80   90   100 */
/*63*/
/*88*/
/*125*/
/*175*/
/*250*/
/*350*/
/*500*/
/*700*/
/*1000*/
/*1400*/
/*2000*/
/*2800*/
/*4000*/
/*5600*/
/*8000*/
/*11500*/
/*16000*/
/* peakattp */
/*63*/
/*88*/
/*125*/
/*175*/
/*250*/
/*350*/
/*500*/
/*700*/
/*1000*/
/*1400*/
/*2000*/
/*2800*/
/*4000*/
/*5600*/
/*8000*/
/*11500*/
/*16000*/
/*noisemaskp */
/* suppress any noise curve over maxspec+n */
/* low window */
/* high window */
/*63*/
/*88*/
/*125*/
/*175*/
/*250*/
/*350*/
/*500*/
/*700*/
/*1000*/
/*1400*/
/*2000*/
/*2800*/
/*4000*/
/*5600*/
/*8000*/
/*11500*/
/*16000*/
/* even decade + 5 is important; saves an rint() later in a
/****************************************************************/
/* option */
/* option */
/* we cheat on the WAV header; we just bypass 44 bytes and never
/* uninterleave samples */
/* fft and mdct transforms  */
/* floor psychoacoustics */
/* floor quantization/application */
/* residue prequantization */
/* channel coupling / stereo quantization */
/* decoupling */
/* take it back to time */
/* write data.  Use the part of buffer we're about to shift out */
/* might as well guard against clipping */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\lib\registry.c
/********************************************************************
//www.xiph.org/                  *
/* seems like major overkill now; the backend numbers will grow into
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\lib\res0.c
/********************************************************************
//www.xiph.org/                  *
/* Slow, slow, slow, simpleminded and did I mention it was slow?  The
//#define TRAIN_RES 1
//#define TRAIN_RESAUX 1
/*fprintf(stderr,"partition %d: ",j);*/
/* long and short into the same bucket by current convention */
/*fprintf(stderr,"%d(%.2f|%.2f) ",k,
/*fprintf(stderr,"\n");*/
/*fprintf(stderr,"residue bit usage %f:%f (%f total)\n",
/*vorbis_info_residue0 *info=look->info;
/* residue vectors to group and
/* possible partition choices */
/* group huffman book */
/* secondstages is a bitmask; as encoding progresses pass by pass, a
/* yes, this is a minor hack due to not thinking ahead */
/* trailing zero */
/* vorbis_info is for range checking */
/* check for premature EOP */
/* verify the phrasebook is not specifying an impossible or
/* modify the phrasebook ranging check from r16327; an early beta
/* break an abstraction and copy some code for performance purposes */
/* assumes integer/centered encoder codebook maptype 1 no more than dim 8 */
/* assumes integer/centered encoder codebook maptype 1 no more than dim 8 */
/* assumes the value patterning created by the tools in vq/ */
/* move all this setup out later */
/* we find the partition type for each partition of each
/* designed for stereo or other modes where the partition size is an
/* move all this setup out later */
/* move all this setup out later */
/* we code the partition words for each channel, then the residual
/* first we encode a partition codeword for each channel */
/* training hack */
/*def TRAIN_RES*/
/* now we encode interleaved residual values for the partitions */
/* a truncated packet here just means 'stop working'; it's not an error */
/* move all this setup out later */
/* each loop decodes on partition codeword containing
/* fetch the partition word for each channel */
/* now we decode residual values for the partitions */
/* res2 is slightly more different; all the channels are interleaved
/* don't duplicate the code; use a working vector hack for now and
/* ugly; reallocs for each coupling pass :-( */
/* duplicate code here as speed is somewhat more important */
/* move all this setup out later */
/* no nonzero vectors */
/* fetch the partition word */
/* now we decode residual values for the partitions */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\lib\sharedbook.c
/********************************************************************
//www.xiph.org/                  *
/**** pack/unpack helpers ******************************************/
/* 32 bit float (not IEEE; nonnormalized mantissa +
/* bias toward values smaller than 1. */
/* doesn't currently guard under/overflow */
//+epsilon
/* given a list of word lengths, generate a list of codewords.  Works
/* when we claim a node for an entry, we also claim the nodes
/* update ourself */
/* error condition; the lengths must specify an overpopulated tree */
/* Look to see if the next shorter marker points to the node
/* have to jump branches */
/* invariant says next upper marker would already
/* prune the tree; the implicit invariant says all the longer
/* any underpopulated tree must be rejected. */
/* Single-entry codebooks are a retconned extension to the spec.
/* bitreverse the words because our bitwise packer/unpacker is LSb
/* there might be a straightforward one-line way to do the below
/* the above *should* be reliable, but we'll not assume that FP is
/* treat the above as an initial guess */
/* unpack the quantized list of values for encode/decode ***********/
/* we need to deal with two map types: in map type 1, the values are
/* maptype 1 and 2 both use a quantized value vector, but
/* most of the time, entries%dimensions == 0, but we need to be
/* otherwise, it is in static memory */
/* static book is not cleared; we're likely called on the lookup and
//c->valuelist=_book_unquantize(s,s->entries,NULL);
/* decode codebook arrangement is more heavily optimized than encode */
/* count actually used entries and find max length */
/* two different remappings go on here.
/* perform sort */
/* the index is a reverse index */
/* special case the 'single entry codebook' with a single bit
/* this is magic */
/* now fill in 'unused' entries in the firsttable with hi/lo search
/* we only actually have 15 bits per hint to play with here.
/* only use with encode; decode optimizations are
/* only use with encode; decode optimizations are
/* Unit tests of the dequantizer; this stuff will be OK
/* cases:
/* no mapping */
/* linear, full mapping, nonsequential */
/* linear, full mapping, sequential */
/* linear, algorithmic mapping, nonsequential */
/* linear, algorithmic mapping, sequential */
/* run the nine dequant tests, and compare to the hand-rolled results */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\lib\smallft.c
/********************************************************************
//www.xiph.org/                  *
/* FFT implementation from OggSquish, minus cosine transforms,
/*    The radix five case can be translated later..... */
/*    if(ip!=5)goto L112;
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\lib\synthesis.c
/********************************************************************
//www.xiph.org/                  *
/* first things first.  Make sure decode is ready */
/* Check the packet type */
/* Oops.  This is not an audio data packet */
/* read our mode and pre/post windowsize */
/* this doesn;t get mapped through mode selection as it's used
/* more setup */
/* alloc pcm passback storage */
/* unpack_header enforces range checking */
/* used to track pcm position without actually performing decode.
/* first things first.  Make sure decode is ready */
/* Check the packet type */
/* Oops.  This is not an audio data packet */
/* read our mode and pre/post windowsize */
/* more setup */
/* no pcm */
/* codec setup not properly intialized */
/* Check the packet type */
/* Oops.  This is not an audio data packet */
/* read our mode and pre/post windowsize */
/* set / clear half-sample-rate mode */
/* right now, our MDCT can't handle < 64 sample windows. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\lib\tone.c
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\lib\vorbisenc.c
/********************************************************************
//www.xiph.org/                  *
/* careful with this; it's using static array sizing to make managing
/* 0 lowpass limited, 1 point stereo limited */
/* high level configuration information for setting things up
/* a few static coder conventions */
/* books */
/* for now, we're only using floor 1 */
/* interpolate the trigger threshholds */
/* interpolate the kHz threshholds */
/* 0 and 2 are only used by bitmanagement, but there's no harm to always
/* interpolate the compander settings */
/* impulse blocks may take a user specified bias to boost the
/* the lowest it can go */
/* fill in all the books */
/* lowpass setup/pointlimit */
/* by convention */
/* lowpass needs to be set in the floor and the residue. */
/* in the floor, the granularity can be very fine; it doesn't alter
/* this res may by limited by the maximum pointlimit of the mode,
/* point stereo limited */
/* LFE channel; lowpass at ~ 250Hz */
/* already set */
/* in the residue, we're constrained, physically, by partition
/* residue 2 bundles together multiple channels; used by stereo
/* Multiple maps/submaps can point to the same residue.  In the case
/* we found a submap referencing theis residue backend */
/* this channel belongs to the submap */
/* round up only if we're well past */
/* the blocksize and grouping may disagree at the end */
/* round up only if we're well past */
/* the blocksize and grouping may disagree at the end */
/* LFE channel */
/* we assume two maps in this encoder */
/* the template matches.  Does the requested quality mode
/* an all-points match */
/* encoders will need to use vorbis_info_init beforehand and call
/* two interfaces; this, more detailed one, and later a convenience
/* the final setup call */
/* too low/high an ATH floater is nonsensical, but doesn't break anything */
/* again, bound this to avoid the app shooting itself int he foot
/* get the appropriate setup template; matches the fetch in previous
/* choose block sizes from configured sizes as well as paying
/* floor setup; choose proper floor params.  Allocated on the floor
/* setup of [mostly] short block detection and stereo*/
/* basic psych setup and noise normalization */
/* tone masking setup */
/* noise companding setup */
/* peak guarding setup  */
/* noise bias setup */
/* set bitrate readonlies and management */
/* 0. to 1. */
/* initialize management with sane defaults */
/* full range in no less than 1.5 second */
/* bias toward hoarding bits */
/* a read request has a low nibble of 0 */
/* now deprecated *****************/
/* now deprecated *****************/
/* now deprecated *****************/
/* now deprecated *****************/
/* replacement ratemanage interface */
/* sanity check; only catch invariant violations */
/* Fetching a new template can alter the base_setting, which
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\lib\vorbisfile.c
/********************************************************************
//www.xiph.org/                  *
/* we don't need or want the static callback symbols here */
/* A 'chained bitstream' is a Vorbis bitstream that contains more than
/* A Vorbis file can be played beginning to end (streamed) without
/* We can handle things a number of ways; we can determine the entire
/* There are also different ways to implement seeking.  Enough
/*************************************************************************
/* read a little more data from the file/pipe into the ogg_sync framer
/* greater-than-page-size granularity seeking */
/* a smaller read size is needed for low-rate streaming. */
/* save a tiny smidge of verbosity to make the code more readable */
/* only seek if the file position isn't already there */
/* shouldn't happen unless someone writes a broken callback */
/* The read/seek functions track absolute position within the stream */
/* from the head of the stream, get the next page.  boundary specifies
/* skipped n bytes */
/* send more paramedics */
/* got a page.  Return the offset at the page beginning,
/* find the latest page beginning before the passed in position. Much
/* returns offset or OV_EREAD, OV_FAULT */
/* In a fully compliant, non-multiplexed stream, we'll still be
/* this shouldn't be possible */
/* returns nonzero if found */
/* performs the same search as _get_prev_page, but prefers pages of
/* we fell off the end of the link, which means we seeked
/* we're not interested in the page... just the serialno and granpos. */
/* uses the local ogg_stream storage in vf; this is important for
/* extract the serialnos of all BOS pages + the first set of vorbis
/* a dupe serialnumber in an initial header packet set == invalid stream */
/* we don't have a vorbis stream in this link yet, so begin
/* vorbis header; continue setup */
/* get next page */
/* if this page also belongs to our vorbis stream, submit it and break */
/* get a page loop */
/* get a packet loop */
/* if this page belongs to the correct stream, go parse it */
/* if we never see the final vorbis headers before the link
/* otherwise, keep looking */
/* Starting from current cursor position, get initial PCM offset of
/* should not be possible unless the file is truncated/mangled */
/* count blocksizes of all frames in the page */
/* ignore holes */
/* pcm offset of last packet on the first audio page */
/* less than zero?  Either a corrupt file or a stream with samples
/* finds each bitstream link one at a time using a bisection search
/* invariants:
/* Is the last page in our list of current serialnumbers? */
/* last page is in the starting serialno list, so we've bisected
/* last page is not in the starting stream's serial number list,
/* the below guards against garbage seperating the last and
/* Bisection point found */
/* for the time being, fetch end PCM offset the simple way */
/* this will consume a page, however the next bisection always
/* we're partially open and have a first link header state in
/* fetch initial PCM offset */
/* we can seek, so set out learning all about this file */
/* If seek_func is implemented, tell_func must also be implemented */
/* Get the offset of the last page of the physical bitstream, or, if
/* now determine bitstream structure recursively */
/* clear out the current logical bitstream decoder */
/* fetch and process a packet.  Handles the case where we're at a
/* handle one packet.  Try to fetch it from current stream state */
/* extract packets from page */
/* process a packet if we can. */
/* hole in the data. */
/* got a packet.  process it */
/* lazy check for lazy
/* suck in the synthesis data and track bitrate */
/* for proper use of libvorbis within libvorbisfile,
/* update the pcm offset. */
/* this packet has a pcm_offset on it (the last packet
/* actually, this
/* the loop is not strictly necessary, but there's no sense in
/* eof. leave unitialized */
/* bitrate tracking; add the header's bytes here, the body bytes
/* two possibilities:
/* boundary case */
/* possibility #2 */
/* Do we need to load a new machine before submitting the page? */
/* This is different in the seekable and non-seekable cases.
/* match the serialno to bitstream section.  We use this rather than
/* not the desired Vorbis
/* we're streaming */
/* fetch the three header packets, build the info struct */
/* the buffered page is the data we want, and we're ready for it;
/* if, eg, 64 bit stdio is configured by default, this will build with
/* init the framing state */
/* perhaps some data was previously read into a buffer for testing
/* can we seek? Stevens suggests the seek test was portable */
/* No seeking yet; Set up a 'single' (current) logical bitstream
/* fill in the serialno later */
/* Fetch all BOS pages, store the vorbis header and all seen serial
/* serial number list for first link needs to be held somewhere
/* clear out the OggVorbis_File struct */
/* inspects the OggVorbis file and finds/documents all the logical
/* cheap hack for game usage where downsampling is desirable; there's
/* clear out stream state; dumping the decode machine is needed to
/* make sure the pos is dumped if unseekable */
/* Only partially open the vorbis file; test for Vorbisness, and load
/* How many logical bitstreams in this physical bitstream? */
/* Is the FILE * associated with vf seekable? */
/* returns the bitrate for a given logical bitstream or the entire
/* This once read: return(rint(bits/ov_time_total(vf,-1)));
/* return the actual bitrate */
/* return nominal if set */
/* returns the actual bitrate since last call.  returns -1 if no
/* Guess */
/* returns: total raw (compressed) length of content if i==-1
/* returns: total PCM length (samples) of content if i==-1 PCM length
/* returns: total seconds of content if i==-1
/* seek to an offset relative to the *compressed* data. This also
/* don't dump machine if we can't seek */
/* is the seek position outside our current link [if any]? */
/* clear out stream state */
/* don't yet clear out decoding machine (if it's initialized), in
/* must set serialno */
/* we need to make sure the pcm_offset is set, but we don't want to
/* get the memory ready */
/* eliminate the spurious OV_HOLE
/* snarf/scan a packet if we can */
/* We can't get a guaranteed correct pcm position out of the
/* huh?  Bogus stream with packets but no granulepos */
/* has our decoding just traversed a bitstream boundary? */
/* two possibilities:
/* we traversed */
/* clear out stream state */
/* else, do nothing; next loop will scoop another page */
/* not the desired Vorbis
/* dump the machine so we're in a known state */
/* Page granularity seek (faster than sample granularity because we
/* which bitstream section does this pcm offset occur in? */
/* Search within the logical bitstream for the page with the highest
/* new search algorithm originally by HB (Nicholas Vinen) */
/* if we have only one page, there will be no bisection.  Grab the page here */
/* bisection loop */
/* take a (pretty decent) guess. */
/* read loop within the bisection loop */
/* there is no next page! */
/* No bisection left to perform.  We've either found the
/* We tried to load a fraction of the last page; back up a
/* don't repeat/loop on a read we've already performed */
/* seek and cntinue bisection */
/* got a page. analyze it */
/* only consider pages from primary vorbis stream */
/* only consider pages with the granulepos set */
/* this page is a successful candidate! Set state */
/* raw offset of packet with granulepos */
/* raw offset of next page */
/* if we're before our target but within a short distance,
/* *not* begin + 1 as above */
/* This is one of our pages, but the granpos is
/* No bisection left to perform.  We've either found the
/* bisection read to the end; use the known page
/* Normal bisection */
/* Out of bisection: did it 'fail?' */
/* Check the 'looking for data in first page' special case;
/* Yes, this is the beginning-of-stream case. We already have
/* Different link; dump entire decode machine */
/* Bisection found our page. seek to it, update pcm offset. Easier case than
/* seek */
/* Different link; dump entire decode machine */
/* pull out all but last packet; the one with granulepos */
/* No packet returned; we exited the bisection with 'best'
/* Do not rewind past the beginning of link data; if we do,
/* verify result */
/* dump machine so we're in a known state */
/* seek to a sample offset relative to the decompressed pcm stream
/* discard leading packets we don't need for the lapping of the
/* non audio packet */
/* remove the packet from packet queue and track its granulepos */
/* set up a vb with
/* end of logical stream case is hard, especially with exact
/* always believe the stream markers */
/* suck in a new page */
/* discard samples until we reach the desired position. Crossing a
/* note that halfrate could be set differently in each link, but
/* eof */
/* seek to a playback time relative to the decompressed pcm stream
/* translate time to PCM position and call ov_pcm_seek */
/* which bitstream section does this time offset occur in? */
/* enough information to convert time offset to pcm offset */
/* page-granularity version of ov_time_seek
/* translate time to PCM position and call ov_pcm_seek */
/* which bitstream section does this time offset occur in? */
/* enough information to convert time offset to pcm offset */
/* tell the current stream offset cursor.  Note that seek followed by
/* return PCM offset (sample) of next PCM sample to be read */
/* return time offset (seconds) of next PCM sample to be read */
/* which bitstream section does this time offset occur in? */
/*  link:   -1) return the vorbis_info struct for the bitstream section
/* grr, strong typing, grr, no templates/inheritence, grr */
/* deadbeef */
/* up to this point, everything could more or less hide the multiple
/* suck in another packet */
/* yay! proceed to pack data into the byte buffer */
/* Here. */
/* a tight loop to pack each size */
/* It's faster in this order */
/* input values: pcm_channels) a float vector per channel of output
/* suck in another packet */
/* splice */
/* window from zero */
/* make sure vf is INITSET */
/* suck in another packet */
/* make sure vf is INITSET and that we have a primed buffer; if
/* suck in another packet */
/* grab enough data for lapping from vf; this may be in the form of
/* try first to decode the lapping data */
/* suck in another packet */
/* do *not* span */
/* failed to get lapping data from normal decode; pry it from the
/* this sets up crosslapping of a sample by using trailing data from
/* degenerate case */
/* the relevant overlap buffers must be pre-checked and pre-primed
/* have a lapping buffer from vf1; now to splice it into the lapping
/* consolidate and expose the buffer. */
/* splice */
/* done */
/* window arrays from libvorbis are
/* have lapping data; seek and prime the buffer */
/* Guard against cross-link changes; they're perfectly legal */
/* consolidate and expose the buffer. */
/* splice */
/* done */
/* window arrays from libvorbis are
/* have lapping data; seek and prime the buffer */
/* Guard against cross-link changes; they're perfectly legal */
/* consolidate and expose the buffer. */
/* splice */
/* done */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\lib\window.c
/********************************************************************
//www.xiph.org/                  *
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\vq\bookutil.c
/********************************************************************
//www.xiph.org/                  *
/* assumes integer/centered encoder codebook maptype 1 no more than dim 8 */
/* assumes integer/centered encoder codebook maptype 1 no more than dim 8 */
/* assumes the value patterning created by the tools in vq/ */
/* A few little utils for reading files */
/* read a line.  Use global, persistent buffering */
/* fallthrough correct */
/* read the next numerical value from the given file */
/* read lines fromt he beginning until we find one containing the
/* this reads the format as written by vqbuild/latticebuild; innocent
/* find the codebook struct */
/* get the major important values */
/* load the quantized entries */
/* load the lengthlist */
/* got it all */
/* find codeword lengths */
/* much more elegant means exist.  Brute force n^2, minimum thought */
/* find the two nodes to join */
/* join them */
/* for sanity check purposes: how many bits would it have taken to
/* wrap build_tree_from_lengths to allow zero entries in the histogram */
/* pack the 'sparse' hit list into a dense list, then unpack
/* save the book in C header form */
/* first, the static vectors, then the book structure to tie it together. */
/* quantlist */
/* lengthlist */
/* tie it all together */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\vq\distribution.c
/********************************************************************
//www.xiph.org/                  *
/* command line:
/* load/decode a book */
/* lattice codebook.  dump it. */
/* dump a full, correlated count */
/* do a rough count */
/* dump the count */
/* trained, full mapping codebook. */
/* load/count a data file */
/* do it the simple way; two pass. */
/* make a pretty graph */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\vq\huffbuild.c
/********************************************************************
//www.xiph.org/                  *
/* scan the file for maximum value */
/* we have the probabilities, build the tree */
/* save the book */
/* first, the static vectors, then the book structure to tie it together. */
/* lengthlist */
/* the toplevel book */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\vq\latticebuild.c
/********************************************************************
//www.xiph.org/                  *
/* The purpose of this util is just to finish packaging the
/* read the description */
/* gen a real quant list from the more easily human-grokked input */
/* build the [default] codeword lengths */
/* save the book in C header form */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\vq\latticetune.c
/********************************************************************
//www.xiph.org/                  *
/* This util takes a training-collected file listing codewords used in
/* now we simply count already collated by-entry data */
/* code:hits\n */
/* likely to have multiple listing for each code entry; must
/* build the codeword lengths */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\vq\metrics.c
/********************************************************************
//www.xiph.org/                  *
/* collect the following metrics:
/* set up metrics */
/* minimum, maximum, mean, ms cell spacing */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\libvorbis\vq\vqgen.c
/********************************************************************
//www.xiph.org/                  *
/* This code is *not* part of libvorbis.  It is used to generate
/* There are so many optimizations to explore in *both* stages that
/* Codebook generation happens in two steps: 
/* Codebook training ****************************************************
/* internal helpers *****************************************************/
/* default metric; squared 'distance' from desired value. */
/* *must* be beefed up. */
/* minimum, maximum, cell spacing */
/* this gives us rough diameter */
/* External calls *******************************************************/
/* We have two forms of quantization; in the first, each vector
/* first find the basic delta amount from the maximum span to be
/* be paranoid; this should be impossible */
/* be paranoid; this should be impossible */
/* much easier :-).  Unlike in the codebook, we don't un-log log
/* quantize to the density mesh if it's selected */
/* quantize to the mesh */
/* yes, not threadsafe.  These utils aren't */
/* sort to make uniqueness detection trivial */
/* now march through and eliminate dupes */
/* a new, unique entry.  march it down */
/* we're done */
/* fill in nearest points for entry biasing */
/*memset(v->bias,0,sizeof(float)*v->entries);*/
/* 'thismetric' is to be the bias value necessary in the current
/* use the secondary entry as the threshhold */
/* use the primary entry as the threshhold */
/* support the idea of 'minimum distance'... if we want the
/* a cute two-stage delayed sorting hack */
/* inflate/deflate */
/* due to the delayed sorting, we likely need to finish it off....*/
/* Now assign with new bias and find new midpoints */
/* set up midpoints for next iter */
/* centroid */
/* assign midpoints */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\lapi.c
/*
/* pseudo-indices */
/* no enclosing function? */
/* use global table as environment */
/* stack overflow */
/*
/* `subtract' index (index is negative) */
/* explicit test for incompatible code */
/* function upvalue? */
/*
/* may call tag method */
/* may call tag method */
/* `luaV_tostring' may create a new string */
/* conversion failed? */
/* previous call may reallocate the stack */
/* `luaV_tostring' may create a new string */
/*
/* ensure that true is 1 */
/*
/*
/* pop index and value */
/* pop value */
/*
/*
/* data to `f_call' */
/* function to be called */
/*
/* data to `f_Ccall' */
/* push function */
/* push only argument */
/*
/* GC values are expressed in Kbytes: #bytes/2^10 */
/* end of cycle? */
/* signal it */
/* invalid option */
/*
/* to avoid warnings */
/* no more elements */
/* remove key */
/* push empty string */
/* else n == 1; nothing to do */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\lauxlib.c
/*
/* This file uses only the official API of Lua.
/* free list of references */
/* convert a stack index to positive */
/*
/* no stack frame? */
/* do not count `self' */
/* error is in the self argument itself? */
/* check function at level */
/* get info about it */
/* is there info? */
/* else, no information available... */
/* }====================================================== */
/* get registry.name */
/* name already in use? */
/* leave previous value on top, but return 0 */
/* create metatable */
/* registry.name = metatable */
/* value is a userdata? */
/* does it have a metatable? */
/* get correct metatable */
/* does it have the correct mt? */
/* remove both metatables */
/* else error */
/* to avoid warnings */
/* avoid extra test when d is not 0 */
/* avoid extra test when d is not 0 */
/* no metatable? */
/* remove metatable and metafield */
/* remove only metatable */
/* no metafield? */
/* check whether lib already exists */
/* get _LOADED[libname] */
/* not found? */
/* remove previous result */
/* try global variable (and create one if it does not exist) */
/* _LOADED[libname] = new table */
/* remove _LOADED table */
/* move library table to below upvalues */
/* copy upvalues to the top */
/* remove upvalues */
/*
/* no `size' table? */
/* remove nil */
/* create it */
/* `size' will be its own metatable */
/* metatable(N).__mode = "kv" */
/* store in register */
/* is there a numeric field `n'? */
/* use it */
/* use `sizes' */
/* sizes[t] = n */
/* remove `sizes' */
/* try t.n */
/* else try sizes[t] */
/* }====================================================== */
/* push prefix */
/* push replacement in place of pattern */
/* continue after `p' */
/* push last suffix */
/* no such field? */
/* remove this nil */
/* new table for field */
/* set new table into field */
/* field has a non-table value? */
/* remove table and value */
/* return problematic part of the name */
/* remove previous table */
/*
/* put nothing on stack */
/* number of levels to concat */
/* fit into buffer? */
/* put it there */
/* remove from stack */
/* put buffer before new value */
/* add new value into B stack */
/* }====================================================== */
/* remove from stack */
/* `nil' has a unique fixed reference */
/* get first free element */
/* ref = t[FREELIST_REF] */
/* remove it from stack */
/* any free element? */
/* remove it from list */
/* (t[FREELIST_REF] = t[ref]) */
/* no free elements */
/* create new reference */
/* t[ref] = t[FREELIST_REF] */
/* t[FREELIST_REF] = ref */
/*
/* index of filename on the stack */
/* Unix exec. file? */
/* skip first line */
/* binary file? */
/* reopen in binary mode */
/* skip eventual `#!...' */
/* close file (even in case of errors) */
/* ignore results from `lua_load' */
/* }====================================================== */
/* to avoid warnings */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\lbaselib.c
/*
/*
/* number of arguments */
/* function to be called */
/* value to print */
/* get result */
/* pop result */
/* standard conversion */
/* at least one valid digit? */
/* skip trailing spaces */
/* no invalid trailing characters? */
/* else not a number */
/* add extra information? */
/* no metatable */
/* returns either __metatable field (if present) or metatable */
/* is a C function? */
/* return the thread's global env. */
/* change environment of current thread */
/* create a 2nd argument if there isn't one */
/* return generator, */
/* state, */
/* and initial value */
/* next value */
/* return generator, */
/* state, */
/* and initial value */
/* OK? */
/* put before error message */
/* return nil plus error message */
/*
/* to avoid warnings */
/* get function */
/* call it */
/* save string in a reserved stack slot */
/* to avoid warnings */
/* function, eventual name, plus one reserved slot */
/* empty range */
/* number of elements */
/* n <= 0 means arith. overflow */
/* push arg[i] (avoiding overflow problems) */
/* push arg[i + 1...e] */
/* return status + all results */
/* put error function under function to be called */
/* return status + all results */
/* is there a metafield? */
/* use its value */
/* create proxy */
/* no metatable */
/* create a new metatable `m' ... */
/* ... and mark `m' as a valid metatable */
/* weaktable[m] = true */
/* to check if weaktable[metatable(u)] == true */
/* remove value */
/* metatable is valid; get it */
/*
/* running */
/* suspended */
/* 'normal' (it resumed another coroutine) */
/* does it have frames? */
/* it is running */
/* initial state */
/* some error occured */
/* error flag */
/* move yielded values */
/* move error message */
/* error flag */
/* return false + error message */
/* return true + `resume' returns */
/* error object is a string? */
/* add extra info */
/* propagate error */
/* move function to top */
/* move function from L to NL */
/* main thread is not a coroutine */
/* }====================================================== */
/* set global _G */
/* open lib into global table */
/* set global _VERSION */
/* `ipairs' and `pairs' need auxiliary functions as upvalues */
/* `newproxy' needs a weaktable as upvalue */
/* new table `w' */
/* `w' will be its own metatable */
/* metatable(w).__mode = "kv" */
/* set global `newproxy' */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\lcode.c
/*
/* no jumps to current position? */
/* function start? */
/* positions are already clean */
/* can connect both? */
/* else no optimization */
/* save list of jumps to here */
/* keep them on hold */
/*
/* point to itself represents end of list */
/* end of list */
/* turn offset into absolute position */
/*
/* not found */
/* cannot patch other instructions */
/* no register to put value or register already has the value */
/* jump to default target */
/* find last element */
/* constant not found; create a new entry */
/* cannot use nil as key; instead use table itself to represent nil */
/* expression is an open function call? */
/* expression is an open function call? */
/* can relocate its simple result */
/* there is one value available (somewhere) */
/* those instructions may be jump targets */
/* nothing to do... */
/* put this jump in `t' list */
/* position after whole expression */
/* position of an eventual LOAD false */
/* position of an eventual LOAD true */
/* exp is already in a register */
/* reg. is not a local? */
/* put value on it */
/* default */
/* constant fit in RK operand? */
/* constant fit in argC? */
/* not a constant in the right range: put it in a register */
/* invalid var kind to store */
/* remove previous OP_NOT */
/* else go through */
/* pc of last jump */
/* always true; do nothing */
/* insert last jump in `f' list */
/* pc of last jump */
/* always false; do nothing */
/* insert last jump in `t' list */
/* cannot happen */
/* interchange true and false lists */
/* do not attempt to divide by 0 */
/* do not attempt to divide by 0 */
/* no constant folding for 'len' */
/* do not attempt to produce NaN */
/* exchange args to replace by `<' or `<=' */
/* o1 <==> o2 */
/* cannot operate on non-numeric constants */
/* cannot operate on constants */
/* operand must be on the `stack' */
/* list must be closed */
/* list must be closed */
/* operand must be on the 'stack' */
/* `pc' will change */
/* put new instruction in code array */
/* save corresponding line information */
/* free registers with list values */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\ldblib.c
/*
/* no metatable */
/* level out of range */
/* return table */
/* out of range? */
/* out of range? */
/* cannot touch C upvalues from Lua */
/* turn off hooks */
/* set new hook */
/* remove hook table */
/* set hooks */
/* external hook? */
/* get hook */
/* remove hook table */
/* remove eventual returns */
/* size of the first part of the stack */
/* size of the second part of the stack */
/* still before eventual `...' */
/* level 0 may be this own function */
/* message is not a string */
/* no more than `LEVELS2' more levels? */
/* keep going */
/* too many levels */
/* find last levels */
/* is there a name? */
/* main? */
/* C function or tail call */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\ldebug.c
/*
/* function is not a Lua function? */
/* only active lua functions have current-line information */
/*
/* turn off hooks? */
/* Lua function? */
/* skip lost tail calls */
/* level found? */
/* level is of a lost tail call? */
/* no such level */
/* is a local variable in a Lua function */
/* is 'n' inside 'ci' stack? */
/* pop value */
/* not found */
/* handled by lua_getinfo */
/* invalid option */
/* skip the '>' */
/* pop function */
/* no tail call? */
/*
/* invalid instruction after an open call */
/* stores position of last instruction that changed `reg' */
/* points to final return (a `neutral' instruction) */
/* check that it does not jump to a setlist count; this
/* if 'j' is even, previous value is not a setlist (even if
/* change register `a' */
/* check skip */
/* does it jump? */
/* check its jump */
/* set registers from `a' to `b' */
/* at least two operands */
/* at least one result (control variable) */
/* space for results */
/* affect all regs above its base */
/* go through */
/* not full check and jump is forward and do not skip `lastpc'? */
/* do the jump */
/* c = num. returns */
/* affect all registers above base */
/* b = num. returns */
/* tracing? */
/* do not 'execute' these pseudo-instructions */
/* }====================================================== */
/* a Lua function? */
/* is a local? */
/* try symbolic execution */
/* global index */
/* move from `b' to `a' */
/* get name for `b' */
/* key index */
/* upvalue index */
/* key index */
/* no useful name found */
/* calling function is not Lua (or is unknown) */
/* calling function */
/* no useful name can be found */
/* only ANSI way to check whether a pointer points to an array */
/* first operand is wrong */
/* is Lua code? */
/* add file:line information */
/* is there an error handling function? */
/* move argument */
/* push function */
/* call it */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\ldo.c
/*
/*
/* chain list of long jump buffers */
/* error code */
/* error message on current top */
/* there was an overflow? */
/* can `undo' overflow? */
/* close eventual pending closures */
/* chain new error handler */
/* restore old error handler */
/* }====================================================== */
/* double size is enough? */
/* overflow while handling overflow? */
/* tail call; no debug information about it */
/* ensure minimum stack size */
/* cannot call hooks inside a hook */
/* compat. with old-style vararg? */
/* number of extra arguments */
/* create `arg' table */
/* put extra arguments into `arg' table */
/* store counter in field `n' */
/* move fixed parameters to final position */
/* first fixed argument */
/* final position of first argument */
/* add `arg' parameter */
/* Open a hole inside the stack at `func' */
/* previous call may change stack */
/* tag method is the new function to be called */
/* `func' is not a function? */
/* check the `function' tag method */
/* Lua function? prepare its call */
/* no varargs? */
/* vararg function */
/* previous call may change the stack */
/* now `enter' new function */
/* starting point */
/* hooks assume 'pc' is already incremented */
/* correct 'pc' */
/* if is a C function, call it */
/* ensure minimum stack size */
/* now `enter' new function */
/* do the actual call */
/* yielding? */
/* next call may change stack */
/* Lua function? */
/* tail calls */
/* res == final position of 1st result */
/* restore base */
/* restore savedpc */
/* move results to correct place */
/* 0 iff wanted == LUA_MULTRET */
/*
/* error while handing stack error */
/* is a Lua function? */
/* call it */
/* start coroutine? */
/* resuming from previous yield */
/* `common' yield? */
/* finish interrupted execution of `OP_CALL' */
/* complete it... */
/* and correct top if not multiple results */
/* yielded inside a hook: just continue its execution */
/* error? */
/* mark thread as `dead' */
/* protect stack slots below */
/* an error occurred? */
/* close eventual pending closures */
/*
/* data to `f_parser' */
/* buffer to be used by the scanner */
/* initialize eventual upvalues */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\ldump.c
/*
/* include trailing '\0' */
/* cannot happen */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\lfunc.c
/*
/* found a corresponding upvalue? */
/* is it dead? */
/* ressurect it */
/* not found: create a new one */
/* current value lives in the stack */
/* chain it in the proper position */
/* double link it in `uvhead' list */
/* remove from `uvhead' list */
/* is it open? */
/* remove from open list */
/* free upvalue */
/* remove from `open' list */
/* free upvalue */
/* now current value lives here */
/* link upvalue into `gcroot' list */
/*
/* is variable active? */
/* not found */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\lgc.c
/*
/* dead key; remove it */
/* udata are never gray */
/* closed? */
/* open upvalues are never black */
/* may be marked, if left from previous GC */
/* move `dead' udata that need finalization to list `tmudata' */
/* don't bother with them */
/* don't need finalization */
/* must call its gc method */
/* link `curr' at the end of `tmudata' list */
/* list is empty? */
/* creates a circular list */
/* is there a weak mode? */
/* is really weak? */
/* clear bits */
/* must be cleared after GC, ... */
/* ... so put in the appropriate list */
/* remove empty entries */
/*
/* mark literals */
/* mark upvalue names */
/* mark nested protos */
/* mark local-variable names */
/* mark its upvalues */
/* mark its upvalues */
/* number of `ci' in use */
/* part of stack in use */
/* handling overflow? */
/* do not touch the stacks */
/* still big enough... */
/* still big enough... */
/*
/* table is weak? */
/* keep it gray */
/*
/* strings are `values', so are never weak */
/*
/* value was collected? */
/* remove value */
/* non-empty entry? */
/* remove value ... */
/* remove entry from table */
/* sweep open upvalues of each thread */
/* not dead? */
/* make it white (for next cycle) */
/* must erase `curr' */
/* is the first element of the list? */
/* adjust first */
/* check size of string hash */
/* table is too big */
/* check size of buffer */
/* buffer too big? */
/* get first element */
/* remove udata from `tmudata' */
/* last element? */
/* return it to `root' list */
/* stop debug hooks during GC tag method */
/* avoid GC steps */
/* restore hooks */
/* restore threshold */
/*
/* mask to collect all elements */
/* free all string lists */
/* mark root set */
/* make global table be traversed before main stack */
/* total size of userdata to be finalized */
/* remark occasional upvalues of (maybe) dead threads */
/* traverse objects cautch by write barrier and by 'remarkupvals' */
/* remark weak tables */
/* mark running thread */
/* mark basic metatables (again) */
/* remark gray again */
/* separate userdata to be finalized */
/* mark `preserved' userdata */
/* remark, to propagate `preserveness' */
/* remove collected objects from weak tables */
/* flip current white */
/* first estimate */
/*lua_checkmemory(L);*/
/* start a new collection */
/* no more `gray' objects */
/* finish mark phase */
/* nothing more to sweep? */
/* end sweep-string phase */
/* nothing more to sweep? */
/* end sweep phase */
/* end collection */
/* no limit */
/* - lim/g->gcstepmul;*/
/* reset sweep marks to sweep all elements (returning them to white) */
/* reset other collector lists */
/* finish any pending sweep phase */
/* must keep invariant? */
/* restore invariant */
/* don't mind */
/* mark as white just to avoid other barriers */
/* make table gray (again) */
/* link upvalue into `rootgc' list */
/* closed upvalues need barrier */
/* sweep phase: sweep it (turning it into white) */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\linit.c
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\liolib.c
/*
/* calls to Lua API may change this value */
/* not a file */
/*
/* file handle is currently `closed' */
/*
/*
/*
/* make sure argument is a file */
/* ignore closed files */
/*
/* check that it's a valid file handle */
/* return current value */
/* close/not close file when finished */
/* check that it's a valid file handle */
/* no arguments? */
/* will iterate over default input */
/*
/* "result" to be removed */
/* read fails */
/* eof? */
/* close buffer */
/* check whether read something */
/* do not include `eol' */
/* close buffer */
/* read at least an `eol' */
/* how much to read */
/* number of chars actually read */
/* try to read that much each time */
/* cannot read more than asked */
/* still have to read `n' chars */
/* until end of count or eof */
/* close buffer */
/* no arguments? */
/* to return 1 result */
/* ensure stack space for all results and for auxlib's buffer */
/* number */
/* line */
/* file */
/* read MAX_SIZE_T chars */
/* always success */
/* remove last result */
/* push nil instead */
/* file is already closed? */
/* EOF */
/* generator created file? */
/* close it */
/* }====================================================== */
/* optimization: could be done exactly as for strings */
/* error */
/* create metatable for file handles */
/* push metatable */
/* metatable.__index = metatable */
/* file methods */
/* copy environment */
/* set it */
/* create (private) environment (with fields IO_INPUT, IO_OUTPUT, __close) */
/* open library */
/* create (and set) default files */
/* close function for default files */
/* pop environment for default files */
/* create environment for 'popen' */
/* set fenv for 'popen' */
/* pop 'popen' */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\llex.c
/*
/* ORDER RESERVED */
/* reserved words are never collected */
/* reserved word */
/* entry for `str' */
/* make sure `str' will not be collected */
/* skip `\n' or `\r' */
/* skip `\n\r' or `\r\n' */
/* no look-ahead token */
/* initialize buffer */
/* read first char */
/*
/* format error: try to update decimal point separator */
/* try updated decimal separator */
/* format error with correct decimal point: no more options */
/* undo change (for error message) */
/* LUA_NUMBER */
/* `E'? */
/* optional exponent sign */
/* follow locale for decimal point */
/* format error? */
/* try to update decimal point separator */
/* avoid warnings when `cont' is not used */
/* skip 2nd `[' */
/* string starts with a newline? */
/* skip it */
/* to avoid warnings */
/* skip 2nd `[' */
/* skip 2nd `]' */
/* avoid wasting space */
/* to avoid warnings */
/* to avoid warnings */
/* do not save the `\' */
/* go through */
/* will raise an error next loop */
/* handles \\, \", \', and \? */
/* \xxx */
/* skip delimiter */
/* else is a comment */
/* `skip_sep' may dirty the buffer */
/* long comment */
/* else short comment */
/* ... */
/* .. */
/* identifier or reserved word */
/* reserved word? */
/* single-char tokens (+ - / ...) */
/* is there a look-ahead token? */
/* use this one */
/* and discharge it */
/* read next token */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\lmathlib.c
/*
/* number of arguments */
/* number of arguments */
/* the `%' avoids the (rare) case of r==1, and is needed also because on
/* check number of arguments */
/* no arguments */
/* Number between 0 and 1 */
/* only upper limit */
/* int between 1 and `u' */
/* lower and upper limits */
/* int between `l' and `u' */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\lmem.c
/*
/*
/* cannot double it? */
/* cannot grow even a little? */
/* still have at least one free place */
/* minimum size */
/* update only when everything else is OK */
/* to avoid warnings */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\loadlib.c
/*
/* prefix for open functions in C libraries */
/* separator for open functions in C libraries */
/* error codes for ll_loadfunc */
/*
/* }====================================================== */
/*
/* remove original string */
/* }====================================================== */
/*
/* Mac appends a `_' before C function names */
/* this would be a rare case, but prevents crashing if it happens */
/* }====================================================== */
/*
/* to avoid warnings */
/* to avoid warnings */
/* to avoid warnings */
/* }====================================================== */
/* check library in registry? */
/* is there an entry? */
/* no entry yet; create one */
/*
/* mark library as closed */
/* unable to load library */
/* unable to find function */
/* return function */
/* no errors? */
/* return the loaded function */
/* error; error message is on stack top */
/* return nil, error message, and where */
/*
/* try to open file */
/* open failed */
/* skip separators */
/* no more templates */
/* find next separator */
/* template */
/* error accumulator */
/* remove path template */
/* does file exist and is readable? */
/* return that file name */
/* remove file name */
/* add entry to possible error message */
/* not found */
/* library not found in this path */
/* library loaded successfully */
/* remove 'gsub' result */
/* library not found in this path */
/* library loaded successfully */
/* is root */
/* root not found */
/* real error */
/* function not found */
/* not found? */
/* _LOADED table will be at index 2 */
/* is it there? */
/* check loops */
/* package is already loaded */
/* else must load it; iterate over available loaders */
/* error message accumulator */
/* get a loader */
/* call it */
/* did it find module? */
/* module loaded successfully */
/* loader returned error message? */
/* accumulate it */
/* _LOADED[name] = sentinel */
/* pass name as argument to module */
/* run loaded module */
/* non-nil return? */
/* _LOADED[name] = returned value */
/* module did not set a value? */
/* use true as result */
/* extra copy to be returned */
/* _LOADED[name] = true */
/* }====================================================== */
/*
/* get calling function */
/* get option (a function) */
/* module */
/* module._M = module */
/* look for last dot in module name */
/* set _PACKAGE as package name (full module name minus last part) */
/* index of _LOADED table */
/* get _LOADED[modname] */
/* not found? */
/* remove previous result */
/* try global variable (and create one if it does not exist) */
/* _LOADED[modname] = new table */
/* check whether table already has a _NAME field */
/* is table an initialized module? */
/* no; initialize it */
/* create new metatable */
/* mt.__index = _G */
/* }====================================================== */
/* auxiliary mark (for internal use) */
/* no environment variable? */
/* use default */
/* replace ";;" by ";AUXMARK;" and then AUXMARK by default path */
/* create new type _LOADLIB */
/* create `package' table */
/* create `loaders' table */
/* fill it with pre-defined loaders */
/* put it in field `loaders' */
/* set field `path' */
/* set field `cpath' */
/* store config information */
/* set field `loaded' */
/* set field `preload' */
/* open lib into global table */
/* return 'package' table */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\lobject.c
/*
/*
/* expoent */
/* converts back */
/* boolean true must be 1 !! */
/* conversion failed */
/* maybe an hexadecimal constant? */
/* most common case */
/* invalid trailing characters? */
/* this function handles only `%d', `%c', %f, %p, and `%s' formats */
/* should be enough space for a `%p' */
/* remove first char */
/* ensures null termination */
/* out = "source", or "...source" */
/* skip the `@' */
/* get last part of file name */
/* out = [string "string"] */
/* stop at first newline */
/* must truncate? */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\lopcodes.c
/*
/* ORDER OP */
/*       T  A    B       C     mode		   opcode	*/
/* OP_MOVE */
/* OP_LOADK */
/* OP_LOADBOOL */
/* OP_LOADNIL */
/* OP_GETUPVAL */
/* OP_GETGLOBAL */
/* OP_GETTABLE */
/* OP_SETGLOBAL */
/* OP_SETUPVAL */
/* OP_SETTABLE */
/* OP_NEWTABLE */
/* OP_SELF */
/* OP_ADD */
/* OP_SUB */
/* OP_MUL */
/* OP_DIV */
/* OP_MOD */
/* OP_POW */
/* OP_UNM */
/* OP_NOT */
/* OP_LEN */
/* OP_CONCAT */
/* OP_JMP */
/* OP_EQ */
/* OP_LT */
/* OP_LE */
/* OP_TEST */
/* OP_TESTSET */
/* OP_CALL */
/* OP_TAILCALL */
/* OP_RETURN */
/* OP_FORLOOP */
/* OP_FORPREP */
/* OP_TFORLOOP */
/* OP_SETLIST */
/* OP_CLOSE */
/* OP_CLOSURE */
/* OP_VARARG */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\loslib.c
/*
/* calls to Lua API may change this value */
/* if NULL push nil */
/*
/* undefined? */
/* does not set field */
/* UTC? */
/* skip `!' */
/* invalid date? */
/* 9 = number of fields */
/* no conversion specifier? */
/* should be big enough for any conversion result */
/* called without args? */
/* get current time */
/* make sure table is at the top */
/* }====================================================== */
/* }====================================================== */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\lparser.c
/*
/*
/* chain */
/* list of jumps out of this loop */
/* # active locals outside the breakable structure */
/* true if some variable in the block is an upvalue */
/* true if `block' is a loop */
/*
/* new one */
/* not found */
/* no more levels? */
/* default is global variable */
/* look up at current level */
/* local will be used as an upval */
/* not found at current level; try upper one */
/* else was LOCAL or UPVAL */
/* upvalue in this level */
/* info points to global name */
/* includes call itself */
/* last exp. provides the difference */
/* close last expression */
/* a block either controls scope or breaks (never both) */
/* free registers */
/* linked list of funcstates */
/* registers 0/1 are always valid */
/* anchor table of constants and prototype (to avoid being collected) */
/* final return */
/* last token read was anchored in defunct function; must reanchor it */
/* remove table and prototype from the stack */
/* main func. is always vararg */
/* read first token */
/*============================================================*/
/* GRAMMAR RULES */
/*============================================================*/
/* field -> ['.' | ':'] NAME */
/* skip the dot or colon */
/* index -> '[' expr ']' */
/* skip the '[' */
/*
/* last list item read */
/* table descriptor */
/* total number of `record' elements */
/* total number of array elements */
/* number of array elements pending to be stored */
/* recfield -> (NAME | `['exp1`]') = exp1 */
/* ls->t.token == '[' */
/* free registers */
/* there is no list item */
/* flush */
/* no more items pending */
/* do not count last expression (unknown number of elements) */
/* constructor -> ?? */
/* no value (yet) */
/* fix it at stack top (for gc) */
/* may be listfields or recfields */
/* expression? */
/* constructor_item -> recfield */
/* constructor_part -> listfield */
/* set initial array size */
/* set initial table size */
/* }====================================================================== */
/* parlist -> [ param { `,' param } ] */
/* is `parlist' not empty? */
/* param -> NAME */
/* param -> `...' */
/* use `arg' as default name */
/* reserve register for parameters */
/* body ->  `(' parlist `)' chunk END */
/* explist1 -> expr { `,' expr } */
/* at least one expression */
/* funcargs -> `(' [ explist1 ] `)' */
/* arg list is empty? */
/* funcargs -> constructor */
/* funcargs -> STRING */
/* must use `seminfo' before `next' */
/* base register for call */
/* open call */
/* close last argument */
/* call remove function and arguments and leaves
/*
/* prefixexp -> NAME | '(' expr ')' */
/* primaryexp ->
/* field */
/* `[' exp1 `]' */
/* `:' NAME funcargs */
/* funcargs */
/* simpleexp -> NUMBER | STRING | NIL | true | false | ... |
/* vararg */
/* don't need 'arg' */
/* constructor */
/* left priority for each binary operator */
/* right priority */
/* ORDER OPR */
/* `+' `-' `/' `%' */
/* power and concat (right associative) */
/* equality and inequality */
/* order */
/* logical (and/or) */
/* priority for unary operators */
/*
/* expand while operators have priorities higher than `limit' */
/* read sub-expression with higher priority */
/* return first untreated operator */
/* }==================================================================== */
/*
/* block -> chunk */
/*
/* variable (global, local, upvalue, or indexed) */
/*
/* eventual position to save local variable */
/* conflict? */
/* previous assignment will use safe copy */
/* conflict? */
/* previous assignment will use safe copy */
/* make copy */
/* assignment -> `,' primaryexp assignment */
/* assignment -> `=' explist1 */
/* remove extra values */
/* close last expression */
/* avoid default */
/* default assignment */
/* cond -> exp */
/* read condition */
/* `falses' are all equal here */
/* whilestat -> WHILE cond DO block END */
/* skip WHILE */
/* false conditions finish the loop */
/* repeatstat -> REPEAT block UNTIL cond */
/* loop block */
/* scope block */
/* skip REPEAT */
/* read condition (inside scope block) */
/* no upvalues? */
/* finish scope */
/* close the loop */
/* complete semantics when there are upvalues */
/* if condition then break */
/* else... */
/* finish scope... */
/* and repeat */
/* finish loop */
/* forbody -> DO block */
/* control variables */
/* scope for declared variables */
/* end of scope for declared variables */
/* pretend that `OP_FOR' starts the loop */
/* fornum -> NAME = exp1,exp1[,exp1] forbody */
/* initial value */
/* limit */
/* optional step */
/* default step = 1 */
/* forlist -> NAME {,NAME} IN explist1 forbody */
/* create control variables */
/* create declared variables */
/* extra space to call generator */
/* forstat -> FOR (fornum | forlist) END */
/* scope for loop and control variables */
/* skip `for' */
/* first variable name */
/* loop scope (`break' jumps to this point) */
/* test_then_block -> [IF | ELSEIF] cond THEN block */
/* skip IF or ELSEIF */
/* `then' part */
/* ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */
/* IF cond THEN block */
/* ELSEIF cond THEN block */
/* skip ELSE (after patch, for correct line info) */
/* `else' part */
/* debug information will only see the variable after this point! */
/* stat -> LOCAL NAME {`,' NAME} [`=' explist1] */
/* funcname -> NAME {field} [`:' NAME] */
/* funcstat -> FUNCTION funcname body */
/* skip FUNCTION */
/* definition `happens' in the first line */
/* stat -> func | assignment */
/* stat -> func */
/* call statement uses no results */
/* stat -> assignment */
/* stat -> RETURN explist */
/* registers with returned values */
/* skip RETURN */
/* return no values */
/* optional return values */
/* tail call? */
/* return all values */
/* only one single value? */
/* values must go to the `stack' */
/* return all `active' values */
/* may be needed for error messages */
/* stat -> ifstat */
/* stat -> whilestat */
/* stat -> DO block END */
/* skip DO */
/* stat -> forstat */
/* stat -> repeatstat */
/* stat -> funcstat */
/* stat -> localstat */
/* skip LOCAL */
/* local function? */
/* stat -> retstat */
/* must be last statement */
/* stat -> breakstat */
/* skip BREAK */
/* must be last statement */
/* to avoid warnings */
/* chunk -> { stat [`;'] } */
/* free registers */
/* }====================================================================== */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\lstate.c
/*
/*
/* initialize CallInfo array */
/* initialize stack array */
/* initialize first ci */
/* `function' entry for this `ci' */
/*
/* init stack */
/* table of globals */
/* registry */
/* initial size of string table */
/* close all upvalues for this thread */
/* collect all objects */
/* init stack */
/* share table of globals */
/* close all upvalues for this thread */
/* mark it as unfinished state */
/* memory allocation error: free partial state */
/* call GC metamethods for all udata */
/* only the main thread can be closed */
/* close all upvalues for this thread */
/* separate udata that have GC metamethods */
/* no error function during GC metamethods */
/* repeat until no more errors */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\lstring.c
/*
/* cannot resize during GC traverse */
/* rehash */
/* for each node in the list */
/* save next */
/* new position */
/* chain it */
/* ending 0 */
/* chain new entry */
/* too crowded */
/* seed */
/* if string is too long, don't hash all its chars */
/* compute hash */
/* string may be dead */
/* not found */
/* is not finalized */
/* chain it on udata list (after main thread) */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\lstrlib.c
/*
/* macro to `unsign' a character */
/* relative string position: negative means back from end */
/* empty interval; return no values */
/* overflow? */
/* number of arguments */
/*
/* init of source string */
/* end (`\0') of source string */
/* total number of captures (finished or unfinished) */
/* look for a `]' */
/* skip escapes (e.g. `%]') */
/* skip the `^' */
/* matches any char */
/* string ends out of balance */
/* counts maximum expand for item */
/* keeps trying to match with the maximum repetitions */
/* else didn't match; reduce 1 repetition to try again */
/* try with one more repetition */
/* match failed? */
/* undo capture */
/* close capture */
/* match failed? */
/* undo capture */
/* using goto's to optimize tail recursion */
/* start capture */
/* position capture? */
/* end capture */
/* balanced string? */
/* else return match(ms, s, p+4); */
/* frontier? */
/* points to what is next */
/* else return match(ms, s, ep); */
/* capture results (%0-%9)? */
/* else return match(ms, s, p+2) */
/* case default */
/* end of pattern */
/* match succeeded */
/* is the `$' the last char in pattern? */
/* check end of string */
/* it is a pattern item */
/* points to what is next */
/* optional */
/* else return match(ms, s, ep+1); */
/* 0 or more repetitions */
/* 1 or more repetitions */
/* 0 or more repetitions (minimum) */
/* else return match(ms, s+1, ep); */
/* empty strings are everywhere */
/* avoids a negative `l1' */
/* to search for a `*s2' inside `s1' */
/* 1st char will be checked by `memchr' */
/* `s2' cannot be found after that */
/* 1st char is already checked */
/* correct `l1' and `s1' to try again */
/* not found */
/* ms->level == 0, too */
/* add whole match */
/* number of strings pushed */
/* explicit request? */
/* or no special characters? */
/* do a plain search */
/* start */
/* end */
/* not found */
/* empty match? go at least one position */
/* not found */
/* skip ESC */
/* add capture to accumulated result */
/* nil or false? */
/* keep original text */
/* add result to accumulator */
/* non empty match? */
/* skip it */
/* number of substitutions */
/* }====================================================== */
/* maximum size of each formatted item (> len(format('%99.99f', -1e308))) */
/* valid flags in a format specification */
/*
/* skip flags */
/* skip width */
/* (2 digits at most) */
/* skip precision */
/* (2 digits at most) */
/* %% */
/* format item */
/* to store the format (`%...') */
/* to store the formatted item */
/* skip the 'addsize' at the end */
/* no precision and string is too long to be formatted;
/* skip the `addsize' at the end */
/* also treat cases `pnLlh' */
/* create metatable for strings */
/* dummy string */
/* set string metatable */
/* pop dummy string */
/* string library... */
/* ...is the __index metamethod */
/* pop metatable */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\ltable.c
/*
/*
/*
/*
/*
/* value */
/* key */
/*
/* avoid problems with -0 */
/*
/*
/* `key' did not match some condition */
/*
/* first iteration */
/* is `key' inside array part? */
/* yes; that's the index (corrected to C) */
/* check whether `key' is somewhere in the chain */
/* key may be dead already, but it is ok to use it in `next' */
/* key index in hash table */
/* hash elements are numbered after array ones */
/* key not found */
/* to avoid warnings */
/* find original element */
/* try first array part */
/* a non-nil value? */
/* then hash part */
/* a non-nil value? */
/* no more elements */
/*
/* 2^i */
/* number of elements smaller than 2^i */
/* number of elements to go to array part */
/* optimal size for array part */
/* more than half elements present? */
/* optimal size (till now) */
/* all elements smaller than n will go to array part */
/* all elements already counted */
/* is `key' an appropriate array index? */
/* count as such */
/* 2^lg */
/* summation of `nums' */
/* count to traverse all array keys */
/* for each slice */
/* counter */
/* adjust upper limit */
/* no more elements to count */
/* count elements in range (2^(lg-1), 2^lg] */
/* total number of elements */
/* summation of `nums' */
/* no elements to hash part? */
/* use common `dummynode' */
/* all positions are free */
/* save old hash ... */
/* array part must grow? */
/* create new hash part with appropriate size */
/* array part must shrink? */
/* re-insert elements from vanishing slice */
/* shrink array */
/* re-insert elements from hash part */
/* free old array */
/* nums[i] = number of keys between 2^(i-1) and 2^i */
/* reset counts */
/* count keys in array part */
/* all those keys are integer keys */
/* count keys in hash part */
/* count extra key */
/* compute new size for array part */
/* resize the table to new computed sizes */
/*
/* temporary values (kept only if some malloc fails) */
/* could not find a free place */
/*
/* get a free place */
/* cannot find a free place? */
/* grow table */
/* re-insert key into grown table */
/* is colliding node out of its main position? */
/* yes; move colliding node into free position */
/* find previous */
/* redo the chain with `n' in place of `mp' */
/* copy colliding node into free pos. (mp->next also goes) */
/* now `mp' is free */
/* colliding node is in its own main position */
/* new node will go into free position */
/* chain new position */
/*
/* (1 <= key && key <= t->sizearray) */
/* check whether `key' is somewhere in the chain */
/* that's it */
/*
/* check whether `key' is somewhere in the chain */
/* that's it */
/*
/* index is int? */
/* use specialized version */
/* else go through */
/* check whether `key' is somewhere in the chain */
/* that's it */
/* i is zero or a present index */
/* find `i' and `j' such that i is present and j is not */
/* overflow? */
/* table was built with bad purposes: resort to linear search */
/* now do a binary search between them */
/*
/* there is a boundary in the array part: (binary) search for it */
/* else must find a boundary in hash part */
/* hash part is empty? */
/* that is easy... */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\ltablib.c
/*
/* function */
/* 1st argument */
/* 2nd argument */
/* remove nil result */
/* first key */
/* function */
/* key */
/* value */
/* remove value and result */
/* first key */
/* remove value */
/* first empty element */
/* where to insert new element */
/* called with only 2 arguments */
/* insert new element at the end */
/* 2nd argument is the position */
/* `grow' array if necessary */
/* move up elements */
/* t[i] = t[i-1] */
/* new size */
/* t[pos] = v */
/* position is outside bounds? */
/* nothing to remove */
/* t.n = n-1 */
/* result = t[pos] */
/* t[pos] = t[pos+1] */
/* t[e] = nil */
/* add last value (if interval was not empty) */
/*
/* function? */
/* -1 to compensate function */
/* -2 to compensate function and `a' */
/* a < b? */
/* for tail recursion */
/* sort elements a[l], a[(l+u)/2] and a[u] */
/* a[u] < a[l]? */
/* swap a[l] - a[u] */
/* only 2 elements */
/* a[i]<a[l]? */
/* remove a[l] */
/* a[u]<a[i]? */
/* only 3 elements */
/* Pivot */
/* a[l] <= P == a[u-1] <= a[u], only need to sort from l+1 to u-2 */
/* invariant: a[l..i] <= P <= a[j..u] */
/* repeat ++i until a[i] >= P */
/* remove a[i] */
/* repeat --j until a[j] <= P */
/* remove a[j] */
/* pop pivot, a[i], a[j] */
/* swap pivot (a[u-1]) with a[i] */
/* a[l..i-1] <= a[i] == P <= a[i+1..u] */
/* adjust so that smaller half is in [j..i] and larger one in [l..u] */
/* call recursively the smaller one */
/* repeat the routine for the larger one */
/* assume array is smaller than 2^40 */
/* is there a 2nd argument? */
/* make sure there is two arguments */
/* }====================================================== */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\ltm.c
/*
/* ORDER TM */
/* never collect these names */
/*
/* no tag method? */
/* cache this fact */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\lua.c
/*
/* unused arg. */
/* if another SIGINT happens before lstop,
/* 'message' not a string? */
/* keep it intact */
/* pass error message */
/* skip this function and traceback */
/* call debug.traceback */
/* function index */
/* push traceback function */
/* put it under chunk and args */
/* remove traceback function */
/* force a complete garbage collection in case of errors */
/* count total number of arguments */
/* number of arguments to the script */
/* remove global */
/* else... */
/* no input */
/* line ends with newline? */
/* remove it */
/* first line starts with `=' ? */
/* change it to `return' */
/* no input */
/* repeat until gets a complete line */
/* cannot try to add lines? */
/* no more input? */
/* add a new line... */
/* ...between the two lines */
/* join them */
/* remove line */
/* any result to print? */
/* clear stack */
/* collect arguments */
/* stdin */
/* check that argument has no extra characters at the end */
/* not an option? */
/* option */
/* go through */
/* go through */
/* invalid option */
/* option */
/* stop if file fails */
/* status OK */
/* stop collector during initialization */
/* open libraries */
/* invalid args? */
/* executes stdin as a file */
/* create state */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\luac.c
/*
/* default program name */
/* default output file */
/* list bytecodes? */
/* dump bytecodes? */
/* strip debug information? */
/* default output file name */
/* actual output file name */
/* actual program name */
/* end of options; keep it */
/* end of options; skip it */
/* end of options; use stdin */
/* list */
/* output file */
/* parse only */
/* strip debug information */
/* show version */
/* unknown option */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\lundump.c
/*
/* remove trailing '\0' */
/*
/*
/* endianness */
/* is lua_Number integral? */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\lvm.c
/*
/* limit for table tag-method chains (to avoid loops) */
/* call linehook when enter a new function, when jump back (loop),
/* push function */
/* 1st argument */
/* 2nd argument */
/* push function */
/* 1st argument */
/* 2nd argument */
/* 3th argument */
/* `t' is a table? */
/* do a primitive get */
/* result is no nil? */
/* or no TM? */
/* else will try the tag method */
/* else repeat with `tm' */ 
/* `t' is a table? */
/* do a primitive set */
/* result is no nil? */
/* or no TM? */
/* else will try the tag method */
/* else repeat with `tm' */
/* avoid pointing inside table (may rehash) */
/* try first operand */
/* try second operand */
/* no metamethod */
/* same metatables => same metamethods */
/* no metamethod */
/* same metamethods? */
/* no metamethod? */
/* different metamethods? */
/* strings are equal up to a `\0' */
/* index of first `\0' in both strings */
/* r is finished? */
/* l is finished? */
/* l is smaller than r (because r is not finished) */
/* both strings longer than `len'; go on comparing (after the `\0') */
/* first try `le' */
/* else try `lt' */
/* true must be 1 !! */
/* will try TM */
/* will try TM */
/* no TM? */
/* call TM */
/* number of elements handled in this pass (at least 2) */
/* second op is empty? */
/* result is first op (as string) */
/* at least two string values; get as many as possible */
/* collect total length */
/* concat all strings */
/* got `n' strings to create 1 new */
/* repeat until only 1 result left */
/*
/* to be used after possible stack reallocation */
/* entry point */
/* main loop of interpreter */
/* did hook yield? */
/* warning!! several calls may realloc the stack and invalidate `ra' */
/* skip next instruction (if C) */
/* next assignment may change this value */
/* try metamethod */
/* else previous instruction set top */
/* restart luaV_execute over new Lua function */
/* it was a C function (`precall' called it); adjust results */
/* yield */
/* else previous instruction set top */
/* tail call: put new frame in place of previous one */
/* previous frame */
/* previous function index */
/* move frame down */
/* correct top */
/* one more call lost */
/* remove new frame */
/* it was a C function (`precall' called it) */
/* yield */
/* was previous function running `here'? */
/* no: return */
/* yes: continue its execution */
/* increment index */
/* jump back */
/* update internal index... */
/* ...and external index */
/* next steps may throw errors */
/* call base */
/* func. + 2 args (state and index) */
/* previous call may change the stack */
/* continue loop? */
/* save control variable */
/* jump back */
/* needs more space? */
/* pre-alloc it at once */
/* previous call may change the stack */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\lzio.c
/*
/* luaZ_fill removed first byte; put back it */
/* --------------------------------------------------------------- read --- */
/* return number of missing bytes */
/* min. between n and z->n */
/* ------------------------------------------------------------------------ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\lua\print.c
/*
/* cannot happen */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lib_aux.c
/*
/* -- I/O error handling -------------------------------------------------- */
/* Lua API calls may change this value. */
/* -- Module registration ------------------------------------------------- */
/* no such field? */
/* remove this nil */
/* new table for field */
/* set new table into field */
/* field has a non-table value? */
/* remove table and value */
/* return problematic part of the name */
/* remove previous table */
/* check whether lib already exists */
/* get _LOADED[libname] */
/* not found? */
/* remove previous result */
/* try global variable (and create one if it does not exist) */
/* _LOADED[libname] = new table */
/* remove _LOADED table */
/* move library table to below upvalues */
/* copy upvalues to the top */
/* remove upvalues */
/* push prefix */
/* push replacement in place of pattern */
/* continue after `p' */
/* push last suffix */
/* -- Buffer handling ----------------------------------------------------- */
/* put nothing on stack */
/* number of levels to concat */
/* fit into buffer? */
/* put it there */
/* remove from stack */
/* put buffer before new value */
/* add new value into B stack */
/* -- Reference management ------------------------------------------------ */
/* Convert a stack index to an absolute index. */
/* remove from stack */
/* `nil' has a unique fixed reference */
/* get first free element */
/* ref = t[FREELIST_REF] */
/* remove it from stack */
/* any free element? */
/* remove it from list */
/* (t[FREELIST_REF] = t[ref]) */
/* no free elements */
/* create new reference */
/* t[ref] = t[FREELIST_REF] */
/* t[FREELIST_REF] = ref */
/* -- Default allocator and panic function -------------------------------- */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lib_base.c
/*
/* -- Base library: checks ------------------------------------------------ */
/* ORDER LJ_T */
/* boolean */
/* userdata */
/* Recycle the lj_lib_checkany(L, 1) from assert. */
/* -- Base library: iterators --------------------------------------------- */
/* This solves a circular dependency problem -- change FF_next_N as needed. */
/* Only keep one argument. */
/* Replace callable. */
/* -- Base library: getters and setters ----------------------------------- */
/* Recycle the lj_lib_checkany(L, 1) from assert. */
/* NOBARRIER: A thread (i.e. L) is never black. */
/* -- Base library: conversions ------------------------------------------- */
/* Only keep one argument. */
/* Replace callable. */
/* Note: lua_pushfstring calls the GC which may invalidate o. */
/* -- Base library: throw and catch errors -------------------------------- */
/* For xpcall only. */
/* -- Base library: load Lua code ----------------------------------------- */
/* Ensure env arg exists. */
/* Call user-supplied function. */
/* Anchor string in reserved stack slot. */
/* Ensure env arg exists. */
/* Reserve a slot for the string from the reader. */
/* -- Base library: GC control -------------------------------------------- */
/* ORDER LUA_GC* */
/* -- Base library: miscellaneous functions ------------------------------- */
/* Upvalue holds weak table. */
/* newproxy(): without metatable. */
/* newproxy(true): with metatable. */
/* Remember mt in weak table. */
/* newproxy(proxy): inherit metatable. */
/* -- Coroutine library --------------------------------------------------- */
/* Inline declarations. */
/* Error handler, called from assembler VM. */
/* Forward declaration. */
/* Fix the PC of wrap_aux. Really ugly workaround. */
/* ------------------------------------------------------------------------ */
/* NOBARRIER: The table is new (marked white). */
/* NOBARRIER: Table and value are the same. */
/* top-3. */
/* top-2. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lib_bit.c
/*
/* ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lib_debug.c
/*
/* ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------ */
/* Create result table. */
/* Return result table. */
/* ------------------------------------------------------------------------ */
/* turn off hooks */
/* external hook? */
/* get hook */
/* ------------------------------------------------------------------------ */
/* remove eventual returns */
/* ------------------------------------------------------------------------ */
/* size of the first part of the stack */
/* size of the second part of the stack */
/* ------------------------------------------------------------------------ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lib_ffi.c
/*
/* -- C type checks ------------------------------------------------------- */
/* Check first argument for a C type and returns its ID. */
/* Parse an abstract C type declaration. */
/* Propagate errors. */
/* Check argument for C data and return it. */
/* Convert argument to C pointer. */
/* Convert argument to int32_t. */
/* -- C type metamethods -------------------------------------------------- */
/* Handle ctype __index/__newindex metamethods. */
/* Also checks for presence of key. */
/* Also checks for key and value. */
/* Common handler for cdata arithmetic. */
/* The following functions must be in contiguous ORDER MM. */
/* Forward declaration. */
/* Handle ctype __call/__new metamethod. */
/* End of contiguous ORDER MM. */
/* Handle ctype __tostring metamethod. */
/* -- C library metamethods ----------------------------------------------- */
/* Index C library by a name. */
/* Skip attributes and collect qualifiers. */
/* unreachable */
/* -- Callback function metamethods --------------------------------------- */
/* -- FFI library functions ----------------------------------------------- */
/* Propagate errors. */
/* Anchor the uninitialized cdata. */
/* Initialize cdata. */
/* Handle ctype __gc metamethod. Use the fast lookup here. */
/* Add to finalizer table, if still enabled. */
/* Only return the cdata itself. */
/* Make sure this is the last item on the stack. */
/* Remember for trace recorder. */
/* Make sure this is the last item on the stack. */
/* Copy Lua string including trailing '\0'. */
/* Test ABI string. */
/* 64bit */
/* 32bit */
/* fpu */
/* softfp */
/* hardfp */
/* eabi */
/* win */
/* le/be */
/* Remember for trace recorder. */
/* Store reference to miscmap table. */
/* Only allow raw types. */
/* Store reference to finalizer table. */
/* Update finalizer table, if still enabled. */
/* Pass through the cdata object. */
/* Store clib metatable in func environment. */
/* ------------------------------------------------------------------------ */
/* Create special weak-keyed finalizer table. */
/* NOBARRIER: The table is new (marked white). */
/* Register FFI module as loaded. */
/* NOBARRIER: basemt is a GC root. */
/* NOBARRIER: the key is new and lj_tab_newkey() handles the barrier. */
/* Create ffi.C default namespace. */
/* Note: no global "ffi" created! */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lib_init.c
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lib_io.c
/*
/* Userdata payload for I/O file. */
/* File handle. */
/* File type. */
/* Regular file. */
/* Pipe. */
/* Standard file handle. */
/* Close after io.lines() iterator. */
/* -- Open/close helpers -------------------------------------------------- */
/* NOBARRIER: The GCudata is new (marked white). */
/* -- Read/write helpers -------------------------------------------------- */
/* Return 1 result. */
/* The results plus the buffers go on top of the args. */
/* Replace last result with nil. */
/* Copy upvalues with options to stack. */
/* Return values are ignored. */
/* -- I/O file methods ---------------------------------------------------- */
/* -- I/O library functions ----------------------------------------------- */
/* Set environment. */
/* NOBARRIER: The standard I/O handles are GC roots. */
/* io.lines(fname) */
/* io.lines() iterates over stdin. */
/* ------------------------------------------------------------------------ */
/* NOBARRIER: The GCudata is new (marked white). */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lib_jit.c
/*
/* -- jit.* functions ----------------------------------------------------- */
/* jit.on/off/flush([nil]) */
/* jit.on/off/flush(func|proto, nil|true|false) */
/* jit.on/off/flush(true, nil|true|false) */
/* Push a string for every flag bit that is set. */
/* Attach to given event. */
/* Invalidate cache. */
/* Detach if no event given. */
/* -- jit.util.* functions ------------------------------------------------ */
/* -- Reflection API for Lua functions ------------------------------------ */
/* Return prototype of first argument (Lua function or prototype object) */
/* unreachable */
/* local info = jit.util.funcinfo(func [,pc]) */
/* Increment hash size if fields are added. */
/* Increment hash size if fields are added. */
/* local ins, m = jit.util.funcbc(func, pc) */
/* local k = jit.util.funck(func, idx) */
/* local name = jit.util.funcuvname(func, idx) */
/* -- Reflection API for traces ------------------------------------------- */
/* Check trace argument. Must not throw for non-existent trace numbers. */
/* Names of link types. ORDER LJ_TRLINK */
/* local info = jit.util.traceinfo(tr) */
/* Increment hash size if fields are added. */
/* There are many more fields. Add them only when needed. */
/* local m, ot, op1, op2, prev = jit.util.traceir(tr, idx) */
/* local k, t [, slot] = jit.util.tracek(tr, idx) */
/* local snap = jit.util.tracesnap(tr, sn) */
/* local mcode, addr, loop = jit.util.tracemc(tr) */
/* local addr = jit.util.traceexitstub([tr,] exitno) */
/* Don't throw for one-argument variant. */
/* local addr = jit.util.ircalladdr(idx) */
/* -- jit.opt module ------------------------------------------------------ */
/* Parse optimization level. */
/* Ok. */
/* No match. */
/* Parse optimization flag. */
/* Ok. */
/* No match. */
/* Parse optimization parameter. */
/* Malformed number. */
/* Ok. */
/* No match. */
/* jit.opt.start(flags...) */
/* -- JIT compiler initialization ----------------------------------------- */
/* Default values for JIT parameters. */
/* Arch-dependent CPU detection. */
/* Intel. */
/* P4. */
/* Currently unused. */
/* Atom. */
/* AMD. */
/* K8. */
/* K8, K10. */
/* Check for required instruction set support on x86 (unnecessary on x64). */
/* Compile-time ARM CPU detection. */
/* Runtime ARM CPU detection. */
/* Nothing to do. */
/* Compile-time MIPS CPU detection. */
/* Runtime MIPS CPU detection. */
/* On MIPS32R1 rotr is treated as srl. rotr r2,r2,1 -> srl r2,r2,1. */
/* Either 0x80000000 (R2) or 0 (R1). */
/* Initialize JIT compiler. */
/* Silently turn off the JIT compiler on CPUs without SSE2. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lib_math.c
/*
/* ------------------------------------------------------------------------ */
/* Do NOT join the expression to x / y. */
/* ------------------------------------------------------------------------ */
/* This implements a Tausworthe PRNG with period 2^223. Based on:
/* PRNG state. */
/* State of the 4 LFSR generators. */
/* State is valid. */
/* Union needed for bit-pattern conversion between uint64_t and double. */
/* Update generator i and compute a running xor of all states. */
/* PRNG step function. Returns a double in the range 1.0 <= d < 2.0. */
/* PRNG initialization function. */
/* 64-k[i] as four 8 bit constants. */
/* Ensure k[i] MSB of gen[i] are non-zero. */
/* PRNG extract function. */
/* Upvalue holds userdata with RandomState. */
/* d is an int in range [1, r1] */
/* d is an int in range [r1, r2] */
/* else: d is a double in range [0, 1] */
/* PRNG seed function. */
/* Upvalue holds userdata with RandomState. */
/* ------------------------------------------------------------------------ */
/* Use lazy initialization to save some time on startup. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lib_os.c
/*
/* ------------------------------------------------------------------------ */
/* if NULL push nil */
/* Unreachable. */
/* ------------------------------------------------------------------------ */
/* undefined? */
/* does not set field */
/* UTC? */
/* Skip '!' */
/* Invalid date? */
/* 9 = number of fields */
/* No conversion specifier? */
/* Should be big enough for any conversion result. */
/* called without args? */
/* get current time */
/* make sure table is at the top */
/* ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lib_package.c
/*
/* ------------------------------------------------------------------------ */
/* Error codes for ll_loadfunc. */
/* Redefined in platform specific part. */
/* Symbol name prefixes. */
/* remove original string */
/* ------------------------------------------------------------------------ */
/* check library in registry? */
/* is there an entry? */
/* no entry yet; create one */
/* remove 'gsub' result */
/* Unable to load library. */
/* Only load library into global namespace. */
/* Unable to find function. */
/* no errors? */
/* return the loaded function */
/* error; error message is on stack top */
/* return nil, error message, and where */
/* mark library as closed */
/* ------------------------------------------------------------------------ */
/* try to open file */
/* open failed */
/* skip separators */
/* no more templates */
/* find next separator */
/* template */
/* to build error message */
/* non-empty separator? */
/* replace it by 'dirsep' */
/* remove path template */
/* does file exist and is readable? */
/* return that file name */
/* remove file name */
/* concatenate error msg. entry */
/* create error message */
/* not found */
/* error message is on top of the stack */
/* return nil + error message */
/* library not found in this path */
/* library loaded successfully */
/* library not found in this path */
/* library loaded successfully */
/* is root */
/* root not found */
/* real error */
/* function not found */
/* Not found? */
/* ------------------------------------------------------------------------ */
/* _LOADED table will be at index 2 */
/* is it there? */
/* check loops */
/* package is already loaded */
/* else must load it; iterate over available loaders */
/* error message accumulator */
/* get a loader */
/* call it */
/* did it find module? */
/* module loaded successfully */
/* loader returned error message? */
/* accumulate it */
/* _LOADED[name] = sentinel */
/* pass name as argument to module */
/* run loaded module */
/* non-nil return? */
/* _LOADED[name] = returned value */
/* module did not set a value? */
/* use true as result */
/* extra copy to be returned */
/* _LOADED[name] = true */
/* ------------------------------------------------------------------------ */
/* get calling function */
/* get option (a function) */
/* module */
/* module._M = module */
/* look for last dot in module name */
/* set _PACKAGE as package name (full module name minus last part) */
/* index of _LOADED table */
/* get _LOADED[modname] */
/* not found? */
/* remove previous result */
/* try global variable (and create one if it does not exist) */
/* _LOADED[modname] = new table */
/* check whether table already has a _NAME field */
/* is table an initialized module? */
/* no; initialize it */
/* create new metatable */
/* mt.__index = _G */
/* ------------------------------------------------------------------------ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lib_string.c
/*
/* ------------------------------------------------------------------------ */
/* Empty interval: return no results. */
/* Ignore trailing separator. */
/* Paste one string and one separator. */
/* Now copy that k-1 times. */
/* ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------ */
/* macro to `unsign' a character */
/* init of source string */
/* end (`\0') of source string */
/* total number of captures (finished or unfinished) */
/* unreachable */
/* look for a `]' */
/* skip escapes (e.g. `%]') */
/* skip the `^' */
/* matches any char */
/* string ends out of balance */
/* counts maximum expand for item */
/* keeps trying to match with the maximum repetitions */
/* else didn't match; reduce 1 repetition to try again */
/* try with one more repetition */
/* match failed? */
/* undo capture */
/* close capture */
/* match failed? */
/* undo capture */
/* using goto's to optimize tail recursion */
/* start capture */
/* position capture? */
/* end capture */
/* balanced string? */
/* else s = match(ms, s, p+4); */
/* frontier? */
/* points to what is next */
/* else s = match(ms, s, ep); */
/* capture results (%0-%9)? */
/* else s = match(ms, s, p+2) */
/* case default */
/* end of pattern */
/* match succeeded */
/* is the `$' the last char in pattern? */
/* check end of string */
/* it is a pattern item */
/* points to what is next */
/* optional */
/* else s = match(ms, s, ep+1); */
/* 0 or more repetitions */
/* 1 or more repetitions */
/* 0 or more repetitions (minimum) */
/* else s = match(ms, s+1, ep); */
/* empty strings are everywhere */
/* avoids a negative `l1' */
/* to search for a `*s2' inside `s1' */
/* 1st char will be checked by `memchr' */
/* `s2' cannot be found after that */
/* 1st char is already checked */
/* correct `l1' and `s1' to try again */
/* not found */
/* ms->level == 0, too */
/* add whole match */
/* number of strings pushed */
/* relative string position: negative means back from end */
/* explicit request? */
/* or no special characters? */
/* do a plain search */
/* start */
/* end */
/* not found */
/* Ensure progress for empty match. */
/* not found */
/* skip ESC */
/* add capture to accumulated result */
/* nil or false? */
/* keep original text */
/* add result to accumulator */
/* non empty match? */
/* skip it */
/* number of substitutions */
/* ------------------------------------------------------------------------ */
/* maximum size of each formatted item (> len(format('%99.99f', -1e308))) */
/* valid flags in a format specification */
/*
/* This can only be 0-31 or 127. */
/* skip flags */
/* skip width */
/* (2 digits at most) */
/* skip precision */
/* (2 digits at most) */
/* Caller already checks for existence. */
/* %% */
/* format item */
/* to store the format (`%...') */
/* to store the formatted item */
/* Canonicalize output of non-finite values. */
/* no precision and string is too long to be formatted;
/* ------------------------------------------------------------------------ */
/* NOBARRIER: basemt is a GC root. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lib_table.c
/*
/* ------------------------------------------------------------------------ */
/* NOBARRIER: This just moves existing elements around. */
/* The set may invalidate the get pointer, so need to do it first! */
/* Set new value. */
/* Nothing to remove? */
/* Get previous value. */
/* NOBARRIER: This just moves existing elements around. */
/* Remove (last) value. */
/* Return previous value. */
/* ------------------------------------------------------------------------ */
/* function? */
/* -1 to compensate function */
/* -2 to compensate function and `a' */
/* a < b? */
/* for tail recursion */
/* sort elements a[l], a[(l+u)/2] and a[u] */
/* a[u] < a[l]? */
/* swap a[l] - a[u] */
/* only 2 elements */
/* a[i]<a[l]? */
/* remove a[l] */
/* a[u]<a[i]? */
/* only 3 elements */
/* Pivot */
/* a[l] <= P == a[u-1] <= a[u], only need to sort from l+1 to u-2 */
/* invariant: a[l..i] <= P <= a[j..u] */
/* repeat ++i until a[i] >= P */
/* remove a[i] */
/* repeat --j until a[j] <= P */
/* remove a[j] */
/* pop pivot, a[i], a[j] */
/* swap pivot (a[u-1]) with a[i] */
/* a[l..i-1] <= a[i] == P <= a[i+1..u] */
/* adjust so that smaller half is in [j..i] and larger one in [l..u] */
/* call recursively the smaller one */
/* repeat the routine for the larger one */
/* NOBARRIER: The table is new (marked white). */
/* ------------------------------------------------------------------------ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\ljamalg.c
/*
/*
/* To get the mremap prototype. Must be defined before any system includes. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_alloc.c
/*
//creativecommons.org/licenses/publicdomain.
//gee.cs.oswego.edu/pub/misc/
//www.malloc.de/
//www.nedprod.com/programs/portable/nedmalloc/
/* To get the mremap prototype. Must be defined before any system includes. */
/* ------------------- size_t and alignment properties -------------------- */
/* The byte and bit size of a size_t */
/* Some constants coerced to size_t */
/* Annoying but necessary to avoid errors on some platforms */
/* The bit mask value corresponding to MALLOC_ALIGNMENT */
/* the number of bytes to offset an address to align it */
/* -------------------------- MMAP support ------------------------------- */
/* defined for convenience */
/* Undocumented, but hey, that's what we all love so much about Windows. */
/* Number of top bits of the lower 32 bits of an address that must be zero.
/* Win64 32 bit MMAP via NtAllocateVirtualMemory. */
/* For direct MMAP, use MEM_TOP_DOWN to minimize interference */
/* Win32 MMAP via VirtualAlloc */
/* For direct MMAP, use MEM_TOP_DOWN to minimize interference */
/* This function supports releasing coalesed segments */
/* 64 bit mode needs special support for allocating memory in the lower 2GB. */
/* Actually this only gives us max. 1GB in current Linux kernels. */
/* OSX and FreeBSD mmap() use a naive first-fit linear search.
/* Hint for next allocation. Doesn't need to be thread-safe. */
/* Ignore result. May fail below. */
/* Need near-exhaustive linear scan. */
/* 32 bit mode is easy. */
/* Need to define _GNU_SOURCE to get the mremap prototype. */
/* -----------------------  Chunk representations ------------------------ */
/* Size of previous chunk (if free).  */
/* Size and inuse bits. */
/* double links -- used only if free. */
/* The type of bins of chunks */
/* Described below */
/* Described below */
/* The type of various bit flag sets */
/* ------------------- Chunks sizes and alignments ----------------------- */
/* Direct chunks need a second word of overhead ... */
/* ... and additional padding for fake next-chunk at foot */
/* The smallest size we can malloc is an aligned minimal chunk */
/* conversion from malloc headers to user pointers, and back */
/* chunk associated with aligned address A */
/* Bounds on request (not chunk) sizes. */
/* pad request bytes into a usable size */
/* pad request, checking for minimum (but not maximum) */
/* ------------------ Operations on head and foot fields ----------------- */
/* Head value for fenceposts */
/* extraction of fields from head words */
/* Treat space at ptr +/- offset as a chunk */
/* Ptr to next or previous physical malloc_chunk. */
/* extract next chunk's pinuse bit */
/* Get/set size at footer */
/* Set size, pinuse bit, and foot */
/* Set size, pinuse bit, foot, and clear next pinuse */
/* Get the internal overhead associated with chunk p */
/* ---------------------- Overlaid data structures ----------------------- */
/* The first four fields must be compatible with malloc_chunk */
/* The type of bins of trees */
/* A little helper macro for trees */
/* ----------------------------- Segments -------------------------------- */
/* base address */
/* allocated size */
/* ptr to next segment */
/* ---------------------------- malloc_state ----------------------------- */
/* Bin types, widths and sizes */
/* -------------------------- system alloc setup ------------------------- */
/* page-align a size */
/* granularity-align a size */
/*  True if segment S holds address A */
/* Return segment holding given address */
/* Return true if segment contains a segment link */
/*
/* ---------------------------- Indexing Bins ---------------------------- */
/* addressing by index. See above about smallbin repositioning */
/* assign tree index for size S to variable I */
/* Bit representing maximum resolved size in a treebin at i */
/* Shift placing maximum resolved bit in a treebin at i as sign bit */
/* The size of the smallest chunk held in bin with index i */
/* ------------------------ Operations on bin maps ----------------------- */
/* bit corresponding to given index */
/* Mark/Clear bits with given index */
/* mask with all bits to left of least bit of x on */
/* Set cinuse bit and pinuse bit of next chunk */
/* Set cinuse and pinuse of this chunk and pinuse of next chunk */
/* Set size, cinuse and pinuse bit of this chunk */
/* ----------------------- Operations on smallbins ----------------------- */
/* Link a free chunk into a smallbin  */
/* Unlink a chunk from a smallbin  */
/* Unlink the first chunk from a smallbin */
/* Replace dv node, binning the old one */
/* Used only when dvsize known to be small */
/* ------------------------- Operations on trees ------------------------- */
/* Insert chunk into tree */
/* Relays to large vs small bin operations */
/* -----------------------  Direct-mmapping chunks ----------------------- */
/* Check for wrap around 0 */
/* Can't shrink direct regions below small size */
/* Keep old chunk if big enough but not too big */
/* -------------------------- mspace management -------------------------- */
/* Initialize top chunk and its size */
/* Ensure alignment */
/* set size of fake trailing chunk holding overhead space only once */
/* reset on each update */
/* Initialize bins for a new mstate that is otherwise zeroed out */
/* Establish circular links for smallbins */
/* Allocate chunk and prepend remainder with chunk in successor base. */
/* consolidate remainder with first chunk of old base */
/* Add a segment to hold a new noncontiguous region */
/* Determine locations and sizes of segment, fenceposts, old top */
/* reset top to new space */
/* Set up segment record */
/* Push current record */
/* Insert trailing fenceposts */
/* Insert the rest of old top into a bin as an ordinary free chunk */
/* -------------------------- System allocation -------------------------- */
/* Directly map large chunks */
/* Fail if wraps around zero */
/* Try to merge with an existing segment */
/* append */
/* Allocate from new or extended top space */
/* -----------------------  system deallocation -------------------------- */
/* Unmap and unlink any mmapped segments that don't contain used chunks */
/* Can unmap if first chunk holds entire segment and not pinned */
/* unlink obsoleted record */
/* back out if cannot unmap */
/* Reset check counter */
/* ensure enough room for segment overhead */
/* Shrink top space in granularity-size units, keeping at least one */
/* can't shrink if pinned */
/* Prefer mremap, fall back to munmap */
/* Unmap any unused mmapped segments */
/* On failure, disable autotrim to avoid repeated failed future calls */
/* ---------------------------- malloc support --------------------------- */
/* allocate a large request from the best fitting chunk in a treebin */
/* Unsigned negation */
/* Traverse tree for this bin looking for node with size == nb */
/* The deepest untaken right subtree */
/* set t to least subtree holding sizes > nb */
/* set t to root of next non-empty treebin */
/* find smallest of tree or subtree */
/*  If dv is a better fit, return NULL so malloc will use it */
/* allocate a small request from the best fitting chunk in a treebin */
/* ----------------------------------------------------------------------- */
/* Remainderless fit to a smallbin. */
/* Uses next bin if idx empty */
/* Use chunk in next nonempty smallbin */
/* Fit here cannot be remainderless if 4byte sizes */
/* Too big to allocate. Force failure (in sys alloc) */
/* split dv */
/* exhaust dv */
/* Split top */
/* consolidate backward */
/* consolidate forward */
/* Try to either shrink or extend into top. Else malloc-copy-free */
/* this may return NULL. */
/* already big enough */
/* Expand into top */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_api.c
/*
/* -- Common helper functions --------------------------------------------- */
/* -- Miscellaneous API functions ----------------------------------------- */
/* Stack overflow. */
/* -- Stack manipulation -------------------------------------------------- */
/* Shrinks top (idx < 0). */
/* NOBARRIER: A thread (i.e. L) is never black. */
/* Need a barrier for upvalues. */
/* -- Stack getters ------------------------------------------------------- */
/* Magic internal/external tag conversion. ORDER LJ_T */
/* GC may move the stack. */
/* GC may move the stack. */
/* GC may move the stack. */
/* -- Stack setters (object creation) ------------------------------------- */
/* Canonicalize injected NaNs. */
/* Push empty string. */
/* else n == 1: nothing to do. */
/* -- Object getters ------------------------------------------------------ */
/* Return new key and value slot. */
/* End of traversal. */
/* Remove key slot. */
/* unreachable */
/* -- Object setters ------------------------------------------------------ */
/* NOBARRIER: lj_meta_tset ensures the table is not black. */
/* NOBARRIER: lj_meta_tset ensures the table is not black. */
/* Flush cache, since traces specialize to basemt. But not during __gc. */
/* NOBARRIER: basemt is a GC root. */
/* NOBARRIER: basemt is a GC root. */
/* -- Calls --------------------------------------------------------------- */
/* Zero results. */
/* Now call the newly allocated C function. */
/* -- Coroutine yield and resume ------------------------------------------ */
/* Regular yield: move results down if needed. */
/* Yield from hook: add a pseudo-frame. */
/* unreachable */
/* -- GC and memory management -------------------------------------------- */
/* Invalid option. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_asm.c
/*
/* -- Assembler state and common macros ----------------------------------- */
/* Assembler state. */
/* Reference and blended allocation cost for regs. */
/* Current MCode pointer (grows down). */
/* Lower limit for MCode memory + red zone. */
/* Red zone overflow check. */
/* Copy of pointer to IR instructions/constants. */
/* JIT compiler state. */
/* Fused x86 address operand. */
/* Set of free registers. */
/* Set of registers modified inside the loop. */
/* Set of weakly referenced registers. */
/* Set of PHI registers. */
/* Copy of JIT compiler flags. */
/* Loop branch inversion (0:no, 1:yes, 2:yes+CC_P). */
/* Next even spill slot. */
/* Next odd spill slot (or 0). */
/* Reference of current instruction. */
/* Stop assembly before hitting this instruction. */
/* Original T->nins. */
/* Current snapshot is active after this reference. */
/* Rename highwater mark for snapshot check. */
/* Current snapshot number. */
/* Loop snapshot number. */
/* Fusion limit (loopref, 0 or FUSE_DISABLED). */
/* Section base reference (loopref or 0). */
/* Reference of LOOP instruction (or 0). */
/* Number of slots for stack check (unless 0). */
/* Accumulated number of GC steps (per section). */
/* Trace to assemble. */
/* Parent trace (or NULL). */
/* Bottom of reserved MCode. */
/* Top of generated MCode. */
/* Pointer to loop MCode (or NULL). */
/* Points to invertible loop branch (or NULL). */
/* Pending opportunity to merge flag setting ins. */
/* Realign loop if not NULL. */
/* PHI register references. */
/* Parent instruction to RegSP map. */
/* Temp. register. */
/* Temp. register. */
/* Stores register for L. */
/* Check for variant to invariant references. */
/* Inhibit memory op fusion from variant to invariant references. */
/* Sparse limit checks using a red zone before the actual limit. */
/* Arch-specific field offsets. */
/* -- Target-specific instruction emitter --------------------------------- */
/* -- Register allocator debugging ---------------------------------------- */
/* #define LUAJIT_DEBUG_RA */
/* -- Register allocator -------------------------------------------------- */
/* Setup register allocator. */
/* Initially all regs (except the stack pointer) are free for use. */
/* Rematerialize constants. */
/* Do not keep any hint. */
/* Restore BASE register hint. */
/* REF_NIL stores ASMREF_L register. */
/* Force a spill. Allocate a new spill slot if needed. */
/* Release the temporarily allocated register in ASMREF_TMP1/ASMREF_TMP2. */
/* Restore a register (marked as free). Rematerialize or force a spill. */
/* Force a spill slot. */
/* Keep hint. */
/* Only restore non-weak references. */
/* Save a register to a spill slot. */
/* Evict the register with the lowest cost, forcing a restore. */
/* Preferably pick any weak ref instead of a non-weak, non-const ref. */
/* Pick any register (marked as free). Evict on-demand. */
/* Get a scratch register (marked as free). */
/* Evict all registers from a set (if not free). */
/* Evict (rematerialize) all registers allocated to constants. */
/* Allocate a register for a constant. */
/* First try to find a register which already holds the same constant. */
/* Constants should preferably get unmodified registers. */
/* Reduce conflicts with inverse allocation. */
/* Allocate a specific register for a constant. */
/* Allocate a register for ref from the allowed set of registers.
/* First check register hint from propagation or PHI. */
/* Use hint register if possible. */
/* Rematerialization is cheaper than missing a hint. */
/* Invariants should preferably get unmodified registers. */
/* Reduce conflicts with inverse allocation. */
/* We've got plenty of regs, so get callee-save regs if possible. */
/* Allocate a register on-demand. */
/* Note: allow is ignored if the register is already allocated. */
/* Rename register allocation and emit move. */
/* 'down' is free ... */
/* ... and 'up' is now allocated. */
/* Backwards codegen needs inverse move. */
/* Add the rename to the IR. */
/* The IR may have been reallocated. */
/* Pick a destination register (marked as free).
/* Force a specific destination register (marked as free). */
/* Propagate dest register to left reference. Emit moves as needed.
/* FP remat needs a load except for +0. Still better than eviction. */
/* Propagate register hint. */
/* Move needed for true 3-operand instruction: y=a+b ==> y=a; y+=b. */
/* Use register renaming if dest is the PHI reg. */
/* Similar to ra_left, except we override any hints. */
/* Propagate register hint. */
/* Use register renaming if dest is the PHI reg. */
/* Force a RID_RETLO/RID_RETHI destination register pair (marked as free). */
/* First spill unrelated refs blocking the destination registers. */
/* Next free the destination registers (if any). */
/* Check for conflicts and shuffle the registers as needed. */
/* Restore spill slots (if any). */
/* -- Snapshot handling --------- ----------------------------------------- */
/* Can we rematerialize a KNUM instead of forcing a spill? */
/* Check whether a sunk store corresponds to an allocation. */
/* Quick check. */
/* Allocate register or spill slot for a ref that escapes to a snapshot. */
/* Allocate CNEWI value. */
/* Allocate stored values for TNEW, TDUP and CNEW. */
/* Don't sink conversion if result is used. */
/* Get a weak register if we have a free one or can rematerialize. */
/* Allocate a register. */
/* But mark it as weakly referenced. */
/* Otherwise force a spill slot. */
/* Allocate refs escaping to a snapshot. */
/* All guards for a snapshot use the same exitno. This is currently the
/* Register renamed, so force a spill slot. */
/* Found. */
/* Not found. */
/* Prepare snapshot for next guard instruction. */
/* Called by sunk stores before snap #0. */
/* Process any renames above the highwater mark. */
/* Kill rename. */
/* -- Miscellaneous helpers ----------------------------------------------- */
/* Collect arguments from CALL* and CARG instructions. */
/* Account for split args. */
/* Reconstruct CCallInfo flags for CALLX*. */
/* Count number of arguments first. */
/* Copy calling convention info. */
/* Calculate stack adjustment. */
/* Must match with hash*() in lj_tab.c. */
/* -- Allocations --------------------------------------------------------- */
/* lua_State *L    */
/* const char *str */
/* size_t len      */
/* GCstr * */
/* lua_State *L    */
/* uint32_t ahsize */
/* GCtab * */
/* lua_State *L    */
/* const GCtab *kt */
/* GCtab * */
/* Explicit GC step. */
/* Prevent implicit GC check further up. */
/* -- PHI and loop handling ----------------------------------------------- */
/* Break a PHI cycle by renaming to a free register (evict if needed). */
/* If this register file has candidates. */
/* Note: the set for ra_pick cannot be empty, since each register file
/* Get a free register. */
/* Optimize shifts, else it's a cycle. */
/* Pick candidate PHI register. */
/* And rename it to the free register. */
/* PHI register shuffling.
/* Find and resolve PHI register mismatches. */
/* Check all left PHI operand registers. */
/* Mismatch? */
/* PHI register blocked? */
/* Blocked by other PHI (w/reg)? */
/* Otherwise grab register from invariant. */
/* Finished. */
/* Break cycles if none are free. */
/* Else retry some more renames. */
/* Restore/remat invariants whose registers are modified inside the loop. */
/* Allocate and save all unsaved PHI regs and clear marks. */
/* Left PHI gained a spill slot? */
/* Handled here, so clear marker now. */
/* Save to spill slot inside the loop. */
/* Copy unsynced left/right PHI spill slots. Rarely needed. */
/* Unsynced spill slot? */
/* Copy integer spill slots. */
/* Copy FP spill slots. */
/* Emit renames for left PHIs which are only spilled outside the loop. */
/* Left PHI gained a spill slot before the loop? */
/* The IR may have been reallocated. */
/* Setup right PHI reference. */
/* Sink PHI. */
/* Spill slot shuffling is not implemented yet (but rarely needed). */
/* Leave at least one register free for non-PHIs (and PHI cycle breaking). */
/* Two or more free registers? */
/* Get a register for the right PHI. */
/* Duplicate right PHI, need a copy (rare). */
/* Marks left PHIs _with_ register. */
/* Set register hint for left PHI. */
/* Otherwise allocate a spill slot. */
/* This is overly restrictive, but it triggers only on synthetic code. */
/* Set right PHI spill slot. Sync left slot later. */
/* Middle part of a loop. */
/* LOOP is a guard, so the snapno is up to date. */
/* LOOP marks the transition from the variant to the invariant part. */
/* -- Target-specific assembler ------------------------------------------- */
/* -- Head of trace ------------------------------------------------------- */
/* Head of a root trace. */
/* Root traces assume a checked stack for the starting proto. */
/* Head of a side trace.
/* Inverse of all coalesced registers. */
/* Live parent registers. */
/* Parent base. */
/* Force snap #0 alloc to prevent register overwrite in stack check. */
/* Scan all parent SLOADs and collect register dependencies. */
/* Coalesce matching registers right now. */
/* Block live parent register. */
/* Calculate stack frame adjustment. */
/* Don't shrink the stack frame. */
/* Reload spilled target registers. */
/* Hint may be gone, set it again. */
/* Same spill slot, do nothing. */
/* Coalesce matching registers right now. */
/* Store trace number and adjust stack frame relative to the parent. */
/* Restore BASE register from parent spill slot. */
/* Restore target registers from parent spill slots. */
/* Shuffle registers to match up target regs with parent regs. */
/* Repeatedly coalesce free live registers by moving to their target. */
/* We're done if no live registers remain. */
/* Break cycles by renaming one target to a temp. register. */
/* Continue with coalescing to fix up the broken cycle(s). */
/* Inherit top stack slot already checked by parent trace. */
/* Need to check for higher slot? */
/* Highest exit + 1 indicates stack check. */
/* Reuse the parent exit in the context of the parent trace. */
/* Remember for child traces. */
/* -- Tail of trace ------------------------------------------------------- */
/* Get base slot for a snapshot. */
/* Link to another trace. */
/* Last snapshot. */
/* Setup fixed registers for exit to interpreter. */
/* NYI: find a better way to do this. */
/* Return MULTRES or 0. */
/* Save modified BASE for linking to trace with higher start frame. */
/* Sync the interpreter state with the on-trace state. */
/* Root traces that add frames need to check the stack at the end. */
/* -- Trace setup --------------------------------------------------------- */
/* Clear reg/sp for all instructions and add register hints. */
/* Clear reg/sp for constants. */
/* REF_BASE is used for implicit references to the BASE register. */
/* Remove any renames left over from ASM restart. */
/* Setup register hints for parent link instructions. */
/* Copy original parent RegSP to parentmap. */
/* Revert after ASM restart. */
/* fallthrough */
/* fallthrough */
/* fallthrough */
/* C calls evict all scratch regs and return results in RID_RET. */
/* lj_str_new and lj_tab_newkey need 3 args. */
/* fallthrough for integer POW */
/* May be joined to lj_vm_pow_sse. */
/* Leave room for 16 byte scratch area. */
/* Non-constant shift counts need to be in RID_ECX on x86/x64. */
/* Do not propagate hints across type conversions or loads. */
/* fallthrough */
/* Propagate hints across likely 'op reg, imm' or 'op reg'. */
/* -- Assembler core ------------------------------------------------------ */
/* Assemble a trace. */
/* Ensure an initialized instruction beyond the last one for HIOP checks. */
/* Setup initial state. Copy some fields to reduce indirections. */
/* Reserve MCode memory. */
/* General trace setup. Emit tail of trace. */
/* Assemble a trace in linear backwards order. */
/* Handled by SPLIT. */
/* Dead-code elimination can be soooo easy. */
/* Retry in case the MCode needs to be realigned. */
/* Emit head of trace. */
/* The GC check is a guard. */
/* Ouch! Should never happen. */
/* Set trace entry point before fixing up tail to allow link to self. */
/* Note: this may change as->mctop! */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_bc.c
/*
/* Bytecode offsets and bytecode instruction modes. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_bcread.c
/*
/* Reuse some lexer fields for our own purposes. */
/* -- Input buffer handling ----------------------------------------------- */
/* Throw reader error. */
/* Resize input buffer. */
/* Caveat: this may change ls->sb.buf which may affect ls->p. */
/* Refill buffer if needed. */
/* Copy remainder to buffer. */
/* Move down in buffer. */
/* Copy from buffer provided by reader. */
/* Get more data from reader. */
/* EOF? */
/* Only bad if we get called again. */
/* Append to buffer. */
/* Return buffer provided by reader. */
/* Need a certain number of bytes. */
/* Want to read up to a certain number of bytes, but may need less. */
/* Return memory block from buffer. */
/* Copy memory block from buffer. */
/* Read byte from buffer. */
/* Read ULEB128 value from buffer. */
/* Read top 32 bits of 33 bit ULEB128 value from buffer. */
/* -- Bytecode reader ----------------------------------------------------- */
/* Read debug info of a prototype. */
/* Swap lineinfo if the endianess differs. */
/* Find pointer to varinfo. */
/* Read a single constant key/value of a template table. */
/* Read a template table. */
/* Read array entries. */
/* Read hash entries. */
/* Read GC constants of a prototype. */
/* Stack underflow? */
/* Read number constants of a prototype. */
/* Read bytecode instructions. */
/* Swap bytecode instructions if the endianess differs. */
/* Read upvalue refs. */
/* Swap upvalue refs if the endianess differs. */
/* Read a prototype. */
/* Read length. */
/* Shortcut EOF. */
/* EOF */
/* Read prototype header. */
/* Calculate total size of prototype including all colocated arrays. */
/* Allocate prototype object and initialize its fields. */
/* Set to zero until fully initialized. */
/* Close potentially uninitialized gap between bc and kgc. */
/* Read bytecode instructions and upvalue refs. */
/* Read constants. */
/* Read and initialize debug info. */
/* Read and check header of bytecode dump. */
/* Load FFI library on-demand. */
/* Ok. */
/* Read a bytecode dump. */
/* Check for a valid bytecode dump header. */
/* Process all prototypes in the bytecode dump. */
/* Pop off last prototype. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_bcwrite.c
/*
/* Context for bytecode writer. */
/* Output buffer. */
/* Lua state. */
/* Root prototype. */
/* Writer callback. */
/* Writer callback data. */
/* Strip debug info. */
/* Status from writer callback. */
/* -- Output buffer handling ---------------------------------------------- */
/* Resize buffer if needed. */
/* Need a certain amount of buffer space. */
/* Add memory block to buffer. */
/* Add byte to buffer. */
/* Add ULEB128 value to buffer. */
/* -- Bytecode writer ----------------------------------------------------- */
/* Write a single constant key/value of a template table. */
/* Narrow number constants to integers. */
/* -0 is never a constant. */
/* Write a template table. */
/* Determine max. length of array part. */
/* Count number of used hash slots. */
/* Write number of array slots and hash slots. */
/* Write array entries (may contain nil). */
/* Write hash entries. */
/* Write GC constants of a prototype. */
/* Determine constant type and needed size. */
/* Write constant type. */
/* Write constant data (if any). */
/* Write number constants of a prototype. */
/* Write a 33 bit ULEB128 for the int (lsb=0) or loword (lsb=1). */
/* Narrow number constants to integers. */
/* -0 is never a constant. */
/* Write bytecode instructions. */
/* Omit the [JI]FUNC* header. */
/* Unpatch modified bytecode containing ILOOP/JLOOP etc. */
/* Write prototype. */
/* Recursively write children of prototype. */
/* Start writing the prototype info to a buffer. */
/* Leave room for final size. */
/* Write prototype header. */
/* Write bytecode instructions and upvalue refs. */
/* Write constants. */
/* Write debug info, if not stripped. */
/* Pass buffer to writer function. */
/* Fill in final size. */
/* Write header of bytecode dump. */
/* Write footer of bytecode dump. */
/* Protected callback for bytecode writer. */
/* Avoids resize for most prototypes. */
/* Write bytecode for a prototype. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_carith.c
/*
/* -- C data arithmetic --------------------------------------------------- */
/* Binary operands of an operator converted to ctypes. */
/* Check arguments for arithmetic metamethods. */
/* Assumes ct does not grow. */
/* Use enum to improve error message. */
/* To make it unequal. */
/* Pointer arithmetic. */
/* Pointer equality. Incompatible pointers are ok. */
/* Pointer difference. */
/* Element size. */
/* All valid pointer differences on x64 are in (-2^47, +2^47),
/* Pointer comparison (unsigned). */
/* Swap pointer and index. */
/* Element size. */
/* Compute pointer + index. */
/* 64 bit integer arithmetic. */
/* Handle ctype arithmetic metamethods. */
/* Equality checks never raise an error. */
/* Remember for trace recorder. */
/* Arithmetic operators for cdata. */
/* Remember for trace recorder. */
/* -- 64 bit integer arithmetic helpers ----------------------------------- */
/* Signed/unsigned 64 bit multiplication. */
/* Unsigned 64 bit division. */
/* Signed 64 bit division. */
/* Unsigned 64 bit modulo. */
/* Signed 64 bit modulo. */
/* Unsigned 64 bit x^k. */
/* Signed 64 bit x^k. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_ccall.c
/*
/* Target-specific handling of register arguments. */
/* -- x86 calling conventions --------------------------------------------- */
/* Return structs bigger than 8 by reference (on stack only). */ \
/* Return structs of size 1, 2, 4 or 8 in registers. */ \
/* Struct with single FP field ends up in FPR. */ \
/* Return all structs by reference (in reg or on stack). */ \
/* Return complex float in GPRs and complex double by reference. */ \
/* Copy complex float from GPRs. */
/* Pass all structs by value on the stack. */
/* Pass complex by value on stack. */
/* Only non-FP values may be passed in registers. */ \
/* Anything > 32 bit is passed on the stack. */ \
/* Prevent reordering. */ \
/* -- Windows/x64 calling conventions ------------------------------------- */
/* Return structs of size 1, 2, 4 or 8 in a GPR. */ \
/* Copy complex float from GPRs. */
/* Pass structs of size 1, 2, 4 or 8 in a GPR by value. */ \
/* Pass all other structs by reference. */ \
/* Pass complex float in a GPR and complex double by reference. */ \
/* Windows/x64 argument registers are strictly positional (use ngpr). */
/* -- POSIX/x64 calling conventions --------------------------------------- */
/* Return struct by reference. */ \
/* Return small structs in registers. */ \
/* Complex values are returned in one or two FPRs. */ \
/* Copy complex float from FPR. */ \
/* Copy non-contiguous complex double from FPRs. */ \
/* Pass all other structs by value on stack. */
/* Pass complex in FPRs or on stack. Needs postprocessing. */
/* Try to pass argument in FPRs. */ \
/* Try to pass argument in GPRs. */ \
/* Note that reordering is explicitly allowed in the x64 ABI. */ \
/* -- ARM calling conventions --------------------------------------------- */
/* Return structs of size <= 4 in a GPR. */ \
/* Return all complex values by reference. */ \
/* Nothing to do. */
/* Pass all structs by value in registers and/or on the stack. */
/* Pass complex by value in 2 or 4 GPRs. */
/* Return complex in FPRs. */
/* Pass all structs by value in registers and/or on the stack. */
/* Pass complex by value in FPRs or on stack. */
/* No reordering after the first FP value is on stack. */ \
/* Align to regpair. */ \
/* Assumes contiguous gpr/stack fields. */ \
/* Too many arguments. */ \
/* -- PPC calling conventions --------------------------------------------- */
/* Return all structs by reference. */ \
/* Complex values are returned in 2 or 4 GPRs. */ \
/* Copy complex from GPRs. */
/* Pass all structs by reference. */
/* Pass complex by value in 2 or 4 GPRs. */
/* Try to pass argument in FPRs. */ \
/* FPRs always hold doubles. */ \
/* Try to pass argument in GPRs. */ \
/* int64_t or complex (float). */ \
/* Align int64_t to regpair. */ \
/* Prevent reordering. */ \
/* FPRs always hold doubles. */
/* -- PPC/SPE calling conventions ----------------------------------------- */
/* Return all structs by reference. */ \
/* Complex values are returned in 2 or 4 GPRs. */ \
/* Copy complex from GPRs. */
/* Pass all structs by reference. */
/* Pass complex by value in 2 or 4 GPRs. */
/* PPC/SPE has a softfp ABI. */
/* Doesn't fit in a single GPR? */ \
/* int64_t, double or complex (float). */ \
/* Only align 64 bit value to regpair. */ \
/* Prevent reordering. */ \
/* -- MIPS calling conventions -------------------------------------------- */
/* Return all structs by reference. */ \
/* Complex values are returned in 1 or 2 FPRs. */ \
/* Copy complex float from FPRs. */ \
/* Copy complex double from FPRs. */ \
/* Pass all structs by value in registers and/or on the stack. */
/* Pass complex by value in 2 or 4 GPRs. */
/* Try to pass argument in FPRs. */ \
/* Try to pass argument in GPRs. */ \
/* Align to regpair. */ \
/* Assumes contiguous gpr/stack fields. */ \
/* Too many arguments. */ \
/* Copy struct return value from GPRs. */
/* -- x86 OSX ABI struct classification ----------------------------------- */
/* Check for struct with single FP field. */
/* Return 1 for float or 2 for double. */
/* -- x64 struct classification ------------------------------------------- */
/* Register classes for x64 struct classification. */
/* NYI: classify vectors. */
/* Classify a C type. */
/* Unaligned. */
/* Recursively classify a struct based on its fields. */
/* Too big, gets memory class. */
/* NYI: unaligned bitfields? */
/* Memory class? */
/* Try to split up a small struct into registers. */
/* Integer class takes precedence. */
/* Register overflow. */
/* Register overflow. */
/* Ok. */
/* Pass a small struct argument. */
/* Convert to temp. struct. */
/* Register overflow? Pass on stack. */
/* Too many arguments. */
/* Ok. */
/* Combine returned small struct. */
/* Integer class takes precedence. */
/* -- ARM hard-float ABI struct classification ---------------------------- */
/* Classify a struct based on its fields. */
/* Not a homogeneous float/double aggregate. */
/* Return structs of size <= 4 in a GPR. */
/* -- Common C call handling ---------------------------------------------- */
/* Infer the destination CTypeID for a vararg argument. */
/* NYI: how to pass a struct by value in a vararg argument? */
/* Setup arguments for C call. */
/* Clear unused regs to get some determinism in case of misdeclaration. */
/* x86 has several different calling conventions. */
/* Perform required setup for some result types. */
/* Preallocate cdata object and anchor it after arguments. */
/* Skip initial attributes. */
/* Walk through all passed arguments. */
/* Get argument type from field. */
/* Too many arguments. */
/* Infer vararg type. */
/* Find out how (by value/ref) and where (GPR/FPR) to pass an argument. */
/* Number of GPRs or stack slots needed. */
/* Handle register arguments. */
/* Otherwise pass argument on stack. */
/* Align argument on stack. */
/* Too many arguments. */
/* Pass by reference. */
/* Extend passed integers to 32 bits at least. */
/* Windows/x64 mirrors varargs in both register sets. */
/* Split complex double. */
/* Too few arguments. */
/* Required for vararg functions. */
/* Get results from C call. */
/* Zero results. */
/* No additional GC step. */
/* One result. */
/* Return cdata object which is already on top of stack. */
/* Use preallocated object. */
/* One GC step. */
/* Return cdata object which is already on top of stack. */
/* Use preallocated object. */
/* One GC step. */
/* No reference types end up here, so there's no need for the CTypeID. */
/* Call C function. */
/* Blacklist function that called a callback. */
/* May be reallocated. */
/* Automatically detect __stdcall and fix up C function declaration. */
/* Not a function. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_ccallback.c
/*
/* -- Target-specific handling of callback slots -------------------------- */
/* Disabled callback support. */
/* Missing support for this architecture. */
/* Convert callback slot number to callback function pointer. */
/* Convert callback function pointer to slot number. */
/* Not a known callback function pointer. */
/* Initialize machine code for callback function pointers. */
/* Disabled callback support. */
/* mov al, slot; jmp group */
/* push ebp/rbp; mov ah, slot>>8; mov ebp, &g. */
/* jmp [rip-pageofs] where lj_vm_ffi_callback is stored. */
/* jmp lj_vm_ffi_callback. */
/* This must match with the saveregs macro in buildvm_arm.dasc. */
/* Missing support for this architecture. */
/* -- Machine code management --------------------------------------------- */
/* Allocate and initialize area for callback function pointers. */
/* Fallback allocator. Fails if memory is not executable by default. */
/* Free area for callback function pointers. */
/* -- C callback entry ---------------------------------------------------- */
/* Target-specific handling of register arguments. Similar to lj_ccall.c. */
/* Only non-FP values may be passed in registers. */ \
/* Anything > 32 bit is passed on the stack. */ \
/* Prevent reordering. */ \
/* Windows/x64 argument registers are strictly positional (use ngpr). */
/* No reordering after the first FP value is on stack. */ \
/* Align to regpair. */ \
/* FPRs always hold doubles. */ \
/* Try to pass argument in GPRs. */ \
/* int64_t. */ \
/* Align int64_t to regpair. */ \
/* FPRs always hold doubles. */
/* Try to pass argument in FPRs. */ \
/* Try to pass argument in GPRs. */ \
/* Align to regpair. */ \
/* Convert and push callback arguments to Lua stack. */
/* Must set up frame first, before throwing the error. */
/* Continuation returns from callback. */
/* Return type. x86: +(spadj<<16). */
/* May throw. */
/* Might have been reallocated. */
/* x86 has several different calling conventions. */
/* Number of GPRs or stack slots needed. */
/* Handle register arguments. */
/* Otherwise pass argument on stack. */
/* Align 64 bit argument on stack. */
/* Store stack adjustment for returns from non-cdecl callbacks. */
/* Convert Lua object to callback result. */
/* Extend returned integers to (at least) 32 bits. */
/* Enter callback. */
/* Never record across callback. */
/* Setup C frame. */
/* Now call the function on this stack. */
/* Leave callback. */
/* Keep continuation frame for throwing errors. */
/* PC of RET* is lost. Point to last line for result conv. errors. */
/* Finally drop C frame and continuation frame. */
/* Blacklist C function that called the callback. */
/* -- C callback management ----------------------------------------------- */
/* Get an unused slot in the callback slot table. */
/* Check for function pointer and supported argument/result types. */
/* Create a new callback and return the callback function pointer. */
/* Bad conversion. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_cconv.c
/*
/* -- Conversion errors --------------------------------------------------- */
/* Bad conversion. */
/* Bad conversion from TValue. */
/* Initializer overflow. */
/* -- C type compatibility checks ----------------------------------------- */
/* Get raw type and qualifiers for a child type. Resolves enums, too. */
/* Check for compatible types when converting to a pointer.
/* Different qualifiers. */
/* Discarded qualifiers. */
/* Converting to/from void * is always ok. */
/* Different type or different size. */
/* Different numeric types. */
/* Check child types for compatibility. */
/* Must be exact same type for struct/union. */
/* NYI: structural equality of functions. */
/* Types are compatible. */
/* -- C type to C type conversion ----------------------------------------- */
/* Convert C type to C type. Caveat: expects to get the raw CType!
/* Some basic sanity checks. */
/* Destination is a bool. */
/* Source operand is already normalized. */
/* NYI: long double. */
/* Destination is an integer. */
/* Zero-extend or sign-extend LSB. */
/* Copy LSB. */
/* Always convert via double. */
/* Convert source to double. */
/* NYI: long double. */
/* Then convert double to integer. */
/* The conversion must exactly match the semantics of JIT-compiled code! */
/* NYI: conversion to >64 bit integers. */
/* Just convert re. */
/* Destination is a floating-point number. */
/* Always convert via double. */
/* First convert source to double. */
/* The conversion must exactly match the semantics of JIT-compiled code! */
/* NYI: conversion from >64 bit integers. */
/* Convert double to destination. */
/* NYI: long double. */
/* Always convert via double. */
/* Convert source to double. */
/* NYI: long double. */
/* Convert double to destination. */
/* NYI: long double. */
/* Ignore im, and convert from re. */
/* Destination is a complex number. */
/* Clear im. */
/* Convert to re. */
/* Clear im. */
/* Convert to re. */
/* Different types: convert re/im separately. */
/* Otherwise this is easy. */
/* Destination is a vector. */
/* First convert the scalar to the first element. */
/* Then replicate it to the other elements (splat). */
/* Copy same-sized vectors, even for different lengths/element-types. */
/* Destination is a pointer. */
/* The signed conversion is cheaper. x64 really has 47 bit pointers. */
/* Destination is an array. */
/* Destination is a struct/union. */
/* Must be exact same type. */
/* Copy value. */
/* -- C type to TValue conversion ----------------------------------------- */
/* Convert C type to TValue. Caveat: expects to get the raw CType! */
/* Numbers are NOT canonicalized here! Beware of uninitialized data. */
/* Remember for trace recorder. */
/* Create reference. */
/* Need GC step. */
/* Copy value. */
/* Attributes are stripped, qualifiers are kept (but mostly ignored). */
/* Need GC step. */
/* Convert bitfield to TValue. */
/* NYI: packed bitfields may cause misaligned reads. */
/* Check if a packed bitfield crosses a container boundary. */
/* No GC step needed. */
/* -- TValue to C type conversion ----------------------------------------- */
/* Convert table to array. */
/* Array element type. */
/* Try again for 1-based tables. */
/* Stop at first nil. */
/* Only fill up arrays with known size. */
/* Replicate a single element. */
/* Otherwise fill the remainder with zero. */
/* Convert table to sub-struct/union. */
/* Ignore unnamed fields. */
/* 1-based tables. */
/* Init named fields. */
/* Stop at first nil. */
/* Ignore all other entries in the chain. */
/* Convert table to struct/union. */
/* Much simpler to clear the struct first. */
/* Convert TValue to C type. Caveat: expects to get the raw CType! */
/* Resolve reference for value. */
/* Match string against enum constant. */
/* Copy string to array. */
/* Otherwise pass it as a const char[]. */
/* Convert TValue to bitfield. */
/* Check if a packed bitfield crosses a container boundary. */
/* NYI: packed bitfields may cause misaligned reads/writes. */
/* -- Initialize C type with TValues -------------------------------------- */
/* Initialize an array with TValues. */
/* Array element type. */
/* Replicate a single element. */
/* Otherwise fill the remainder with zero. */
/* Initialize a sub-struct/union with TValues. */
/* Ignore unnamed fields. */
/* Ignore all other entries in the chain. */
/* Initialize a struct/union with TValues. */
/* Much simpler to clear the struct first. */
/* Check whether to use a multi-value initializer.
/* Destination is not an aggregate. */
/* Initializer is not a value. */
/* Source and destination are identical aggregates. */
/* Otherwise the initializer is a value. */
/* Initialize C type with TValues. Caveat: expects to get the raw CType! */
/* Also handles valarray init with len>1. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_cdata.c
/*
/* -- C data allocation --------------------------------------------------- */
/* Allocate a new C data object holding a reference to another object. */
/* Allocate variable-sized or specially aligned C data object. */
/* Free a C data object. */
/* Add cdata to finalizer table, if still enabled. */
/* Otherwise return dummy TValue. */
/* -- C data indexing ----------------------------------------------------- */
/* Index C data by a TValue. Return CType and pointer. */
/* Resolve reference for cdata object. */
/* Skip attributes and collect qualifiers. */
/* Interning rejects refs to refs. */
/* Numeric key. */
/* Element size. */
/* Valarray elements are constant. */
/* Integer cdata key. */
/* String key. */
/* Complex fields are constant. */
/* Allow indexing a (pointer to) struct constructor to get constants. */
/* Allow resolving metamethods for constructors, too. */
/* Automatically perform '->'. */
/* Lookup failed. */
/* But return the resolved raw type. */
/* -- C data getters ------------------------------------------------------ */
/* Get constant value and convert to TValue. */
/* Constants are already zero-extended/sign-extended to 32 bits. */
/* Get C data value and convert to TValue. */
/* No GC step needed. */
/* Get child type of pointer/array/field. */
/* Resolve reference for field. */
/* Skip attributes. */
/* -- C data setters ------------------------------------------------------ */
/* Convert TValue and set C data value. */
/* Get child type of pointer/array/field. */
/* Resolve reference for field. */
/* Skip attributes and collect qualifiers. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_char.c
/*
//luaforge.net/projects/sln/
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_clib.c
/*
/* -- OS-specific functions ----------------------------------------------- */
/* Check for a recognized ld script line. */
/* Quick and dirty solution to resolve shared library name from ld script. */
/* GNU ld script", 16)) {  /* ld script magic? */
/* Check all lines. */
/* Otherwise check only the first line. */
/* Default libraries. */
/* Search default libraries. */
/* Resolve default library handles (once). */
/* -- C library indexing -------------------------------------------------- */
/* Compute argument size for fastcall/stdcall functions. */
/* Get redirected or mangled external symbol. */
/* Index a C library by name. */
/* Retry with decorated name for fastcall/stdcall functions. */
/* -- C library management ------------------------------------------------ */
/* Create a new CLibrary object and push it on the stack. */
/* NOBARRIER: The GCudata is new (marked white). */
/* Load a C library. */
/* Unload a C library. */
/* Create the default C library object. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_cparse.c
/*
/*
/* -- C lexer ------------------------------------------------------------- */
/* C lexer token names. */
/* Forward declaration. */
/* End-of-line? */
/* Peek next raw character. */
/* Get next character. */
/* Transparently skip backslash-escaped line breaks. */
/* Grow save buffer. */
/* Save character in buffer. */
/* Skip line break. Handles "\n", "\r", "\r\n" or "\n\r". */
/* -- Main lexical scanner ------------------------------------------------ */
/* Parse number literal. Only handles int32_t/uint32_t right now. */
/* Parse identifier or keyword. */
/* Parse parameter. */
/* Reserve $xyz for future extensions. */
/* Parse string or character constant. */
/* Skip C comment. */
/* Skip C++ comment. */
/* Lexical scanner for C. Only a minimal subset is implemented. */
/* fallthrough. */
/* -- C parser ------------------------------------------------------------ */
/* Namespaces for resolving identifiers. */
/* Index into declaration stack. */
/* Storage class flags. */
/* Type declaration context. */
/* Top of declaration stack. */
/* Insertion position in declaration chain. */
/* Saved position for declaration specifier. */
/* Declarator mode. */
/* C parser state. */
/* Name of declared identifier (if direct). */
/* Redirected symbol name. */
/* Existing typedef for declared identifier. */
/* Attributes. */
/* Function attributes. */
/* Saved attributes. */
/* Saved function attributes. */
/* Field size in bits (if any). */
/* Type declaration stack. */
/* Forward declarations. */
/* Initialize C parser state. Caller must set up: L, p, srcname, mode. */
/* Read-ahead first char. */
/* Read-ahead first token. */
/* Cleanup C parser state. */
/* Check and consume optional token. */
/* Check and consume token. */
/* Check if the next token may start a type declaration. */
/* -- Constant expression evaluator --------------------------------------- */
/* Forward declarations. */
/* Please note that type handling is very weak here. Most ops simply
/* Parse comma separated expression and return last result. */
/* Parse sizeof/alignof operator. */
/* Special case for sizeof("string"). */
/* Really size_t. */
/* Parse prefix operators. */
/* Nothing to do (well, integer promotion). */
/* Cast operator. */
/* No conversion performed. */
/* Sub-expression. */
/* Indirection. */
/* Address operator. */
/* Parse postfix operators. */
/* Array/pointer index. */
/* Struct deref. */
/* Parse infix operators. */
/* Silence the compiler. */
/* Right-associative. */
/* Trivial promotion to unsigned. */
/* Trivial promotion to unsigned. */
/* Trivial promotion to unsigned. */
/* Parse and evaluate unary expression. */
/* Parse and evaluate sub-expression. */
/* Parse constant integer expression. */
/* Parse (non-negative) size expression. */
/* -- Type declaration stack management ----------------------------------- */
/* Add declaration element behind the insertion position. */
/* Push declaration element before the insertion position. */
/* Push or merge attributes. */
/* Ok to modify in-place. */
/* Push unrolled type to declaration stack and merge qualifiers. */
/* Don't copy unique types. */
/* Push unmerged qualifiers. */
/* Remove redundant qualifiers. */
/* Unroll. */
/* Copy type. */
/* Unroll. */
/* Copy type. */
/* Mark as already checked and sized. */
/* Note: this is not copied to the ct->sib in the C type table. */
/* Copy type, link parameters (shared). */
/* Copy type, merge common qualifiers. */
/* Consume the declaration element chain and intern the C type. */
/* The cid is already part of info for copies of pointers/functions. */
/* Always refetch info/size, since struct/enum may have been completed. */
/* Intern function. */
/* Reject function or refarray return types. */
/* No intervening attributes allowed, skip forward. */
/* Skip attribute. */
/* Next line may reallocate the C type table. */
/* Inherit csize/cinfo from original type. */
/* Handle mode/vector-size attributes. */
/* Limit alignment. */
/* Override size via mode. */
/* Vector size set? */
/* Intern the element type first. */
/* Then create a vector (array) with vsize alignment. */
/* Limit alignment. */
/* Reject pointer/ref to ref. */
/* Refs are always const, never volatile. */
/* No intervening attributes allowed, skip forward. */
/* Skip attribute. */
/* Check for valid array size etc. */
/* Only check/size arrays not copied by unroll. */
/* Reject arrays of refs. */
/* Reject VLS or unknown-sized types. */
/* a[] and a[?] keep their invalid size. */
/* Find max. align. */
/* Inherit qual. */
/* -- C declaration parser ------------------------------------------------ */
/* Reset declaration state to declaration specifier. */
/* Parse constant initializer. */
/* NYI: FP constants and strings as initializers. */
/* Skip attributes. */
/* Update ID, too. */
/* Parse size in parentheses as part of attribute. */
/* Required for expression evaluator. */
/* Parse alignment attribute. */
/* Unspecified alignment is 16 bytes. */
/* Parse GCC asm("name") redirect. */
/* Parse GCC __attribute__((mode(...))). */
/* Parse GCC __attribute__((...)). */
/* aligned */
/* packed */
/* mode */
/* vector_size */
/* regparm */
/* cdecl */
/* thiscall */
/* fastcall */
/* stdcall */
/* sseregparm */
/* Skip all other attributes. */
/* For __attribute((const)) etc. */
/* Parse MSVC __declspec(...). */
/* align */
/* Ignore all other attributes. */
/* Parse declaration attributes (and common qualifiers). */
/* Ignore. */
/* Ignore. */
/* Parse struct/union/enum name. */
/* Name of existing struct/union/enum. */
/* Wrong type. */
/* Create named, incomplete struct/union/enum. */
/* Create anonymous, incomplete struct/union/enum. */
/* Indicate the type is currently being defined. */
/* Determine field alignment. */
/* The SYSV i386 and iOS ABIs limit alignment of non-vector fields to 2^2. */
/* Layout struct/union fields. */
/* Bit offset and max. bit offset. */
/* Field declaration attributes (temp.). */
/* Alignment (pow2) and alignment mask (bits). */
/* Field size and container size (in bits). */
/* Merge pseudo-qualifiers. */
/* Check for size overflow and determine alignment. */
/* Treat a[] and a[?] as zero-sized. */
/* Bitfield size (temp.). */
/* Regular fields or subtypes always fill the container. */
/* Start new aligned field. */
/* Store field offset. */
/* Bitfield. */
/* Start new aligned field. */
/* Prefer regular field over bitfield. */
/* Store field offset. */
/* Store container offset. */
/* Determine next offset or max. offset. */
/* All other fields in the chain are already set up. */
/* Complete struct/union. */
/* Parse struct/union declaration. */
/* Struct/union definition. */
/* Parse field declarator. */
/* Static constant in struct namespace. */
/* Temp. for layout phase. */
/* Do this first. */
/* Regular field. */
/* a[] or a[?] must be the last declared field. */
/* Accept transparent struct/union/enum. */
/* For layout phase. */
/* Bitfield. */
/* Create temporary field for layout phase. */
/* Drop sib = 1 for empty structs. */
/* Layout phase needs postfix attributes. */
/* Parse enum declaration. */
/* Only 32 bit enums are supported. */
/* Enum definition. */
/* C99 says that enum constants are always (signed) integers.
/* OTOH it's common practice and even mandated by some ABIs
/* Add named enum constant. */
/* Trailing ',' is ok. */
/* Complete enum. */
/* Parse declaration specifiers. */
/* Parse basic types. */
/* Get typedef. */
/* Use predefined complex types. */
/* Determine type info and size. */
/* Handle platforms where char is unsigned. */
/* Use natural alignment. */
/* Merge qualifiers. */
/* Return storage class. */
/* Parse array declaration. */
/* Default size for a[] or a[?]. */
/* Create variable-length array a[?]. */
/* Parse function declaration. */
/* Vararg function. */
/* Workaround for the minimalistic lexer. */
/* Add new parameter. */
/* Skip function definition. */
/* Ok for cp_decl_multi(), error in cp_decl_single(). */
/* Parse declarator. */
/* Head of declarator. */
/* Pointer. */
/* Reference. */
/* Inner declarator. */
/* Resolve ambiguity between inner declarator and 1st function parameter. */
/* Direct declarator. */
/* Abstract declarator. */
/* Tail of declarator. */
/* Array. */
/* Function. */
/* Field width. */
/* Process postfix attributes. */
/* Parse an abstract type declaration and return it's C type ID. */
/* Handle pragmas. */
/* pack */
/* push */
/* pop */
/* Ignore all other pragmas. */
/* Parse multiple C declarations of types or extern identifiers. */
/* Skip empty statements. */
/* Workaround, since we have no preprocessor, yet. */
/* pragma */
/* Accept empty declaration of struct/union/enum. */
/* NYI: redeclarations are ignored. */
/* Create new typedef. */
/* Treat both static and extern function declarations as extern. */
/* We always get new anonymous functions (typedefs are copied). */
/* Just name it. */
/* Accept static constants. */
/* External references have extern or no storage class. */
/* Add attribute for redirected symbol name. */
/* Table may have been reallocated. */
/* May omit ';' for 1 decl. */
/* Parse a single C type declaration. */
/* ------------------------------------------------------------------------ */
/* Protected callback for C parser. */
/* Inherit error function. */
/* C parser. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_crecord.c
/*
/* Some local macros to save typing. Undef'd at the end. */
/* Pass IR on to next optimization in chain (FOLD). */
/* -- C type checks ------------------------------------------------------- */
/* Specialize to the CTypeID. */
/* Specialize to the CTypeID held by a cdata constructor. */
/* Specialize to the string containing the C type declaration. */
/* Avoid new struct defs. */
/* Convert CType to IRType (if possible). */
/* -- Optimized memory fill and copy -------------------------------------- */
/* Maximum length and unroll of inlined copy/fill. */
/* Number of windowed registers used for optimized memory copy. */
/* List of memory offsets for copy/fill. */
/* Offset in bytes. */
/* Type of load/store. */
/* TRef of interned offset. */
/* TRef of load value. */
/* Generate copy list for element-wise struct copy. */
/* Ignore unnamed fields. */
/* Field type. */
/* NYI: aggregates. */
/* NYI: bitfields and sub-structures. */
/* Generate unrolled copy list, from highest to lowest step size/alignment. */
/*
/* Flush buffered stores. */
/* Optimized memory copy. */
/* Length must be constant. */
/* Shortcut. */
/* Call memcpy. Always needs a barrier to disable alias analysis. */
/* Generate unrolled fill list, from highest to lowest step size/alignment. */
/*
/* Optimized memory fill. */
/* Length must be constant. */
/* Shortcut. */
/* Scatter U8 to U16/U32/U64. */
/* Pointless on x64 with zero-extended regs. */
/* Call memset. Always needs a barrier to disable alias analysis. */
/* Note: arg order! */
/* -- Convert C type to C type -------------------------------------------- */
/*
/* Determine whether a passed number or cdata number is non-zero. */
/*
/* Destination is a bool. */
/* Source operand is already normalized. */
/* Specialize to the result of a comparison against 0. */
/* Destination is an integer. */
/* Extend 32 to 64 bit integer. */
/* Truncate from 64 bit integer. */
/* Load re. */
/* fallthrough */
/* Must insert no-op type conversion. */
/* Destination is a floating-point number. */
/* Load re. */
/* fallthrough */
/* Destination is a complex number. */
/* Clear im. */
/* Convert to re. */
/* Destination is a vector. */
/* Destination is a pointer. */
/* There are only 32 bit pointers/addresses on 32 bit machines.
/* Truncate from 64 bit integer. */
/* The signed conversion is cheaper. x64 really has 47 bit pointers. */
/* Destination is an array. */
/* Destination is a struct/union. */
/* -- Convert C type to TValue (load) ------------------------------------- */
/* NYI: copyval of >64 bit integers. */
/* Keep uint32_t/float as numbers. */
/* Box 64 bit integer. */
/* Assume not equal to zero. Fixup and emit pending guard later. */
/* Box pointers and enums. */
/* Create ref. */
/* Unbox/box complex. */
/* NYI: copyval of vectors. */
/* Box pointer, ref, enum or 64 bit integer. */
/* -- Convert TValue to C type (store) ------------------------------------ */
/* Match string against enum constant. */
/* Specialize to the name of the enum constant. */
/* else: interpreter will throw. */
/* Copy string to array. */
/* NYI */
/* Otherwise pass the string data as a const char[]. */
/* Don't use STRREF. It folds with SNEW, which loses the trailing NUL. */
/* NYI: tref_istab(sp), tref_islightud(sp). */
/* Load number value. */
/* -- C data metamethods -------------------------------------------------- */
/* This would be rather difficult in FOLD, so do it here:
/* Not a TRef, but the caller doesn't care. */
/* Record ctype __index/__newindex metamethods. */
/* Pending tailcall. */
/* Specialize to result of __index lookup. */
/* Always specialize to the key. */
/* NYI: resolving of non-function metamethods. */
/* NYI: non-string keys for __index table. */
/* NYI: stores to __newindex table. */
/* Resolve pointer or reference for cdata object. */
/* Hoist base add to allow fusion of index/shift into operands. */
/* Always specialize to the field name. */
/* Interpreter will throw for newindex. */
/* Always specialize to the field name. */
/* Automatically perform '->'. */
/* Resolve reference for field. */
/* Skip attributes. */
/* __index metamethod. */
/* __newindex metamethod. */
/* Record setting a finalizer. */
/* Record cdata allocation. */
/* NYI: large/special allocations. */
/* Use special instruction to box pointer or 32/64 bit integer. */
/* Array element type. */
/* NYI: init array of aggregates. */
/* Ignore unnamed fields. */
/* Field type. */
/* NYI: init aggregates. */
/* NYI: init bitfields and sub-structures. */
/* Handle __gc metamethod. */
/* Record argument conversions. */
/* Skip initial attributes. */
/* Get argument type from field. */
/* Too many arguments. */
/* Infer vararg type. */
/* 64 bit args must not end up in registers for fastcall/thiscall. */
/* Sigh, the Windows/x86 ABI allows reordering across 64 bit args. */
/* No reordering for other x86 ABIs. Simply add alignment args. */
/* Create a snapshot for the caller, simulating a 'false' return value. */
/* Record function call. */
/* Check for blacklisted C functions that might call a callback. */
/* Don't check result if ignored. */
/* Note: only the x86/x64 backend supports U8 and only for EQ(tr, 0). */
/* Record ctype __call/__new metamethod. */
/* Pending tailcall. */
/* No metamethod or NYI: non-function metamethods. */
/* Try to narrow comparison. */
/* Assume true comparison. Fixup and emit pending guard later. */
/* Pointer difference. */
/* NYI: integer division. */
/* Pointer comparison (unsigned). */
/* Assume true comparison. Fixup and emit pending guard later. */
/* Swap pointer and index. */
/* Record ctype arithmetic metamethods. */
/* Pending tailcall. */
/* NYI: non-function metamethods. */
/* Fallback cdata pointer comparison. */
/* Assume true comparison. Fixup and emit pending guard later. */
/* Resolve pointer or reference. */
/* Match string against enum constant. */
/* Specialize to the name of the enum constant. */
/* Interpreter will throw or return false. */
/* Fixup cdata comparisons, too. Avoids some cdata escapes. */
/* -- C library namespace metamethods ------------------------------------- */
/* Specialize to the symbol name and make the result a constant. */
/* else: interpreter will throw. */
/* -- FFI library functions ----------------------------------------------- */
/* else: interpreter will throw. */
/* else: interpreter will throw. */
/* Get alignment of original destination. */
/* else: interpreter will throw. */
/* Specialize to the ABI string to make the boolean result a constant. */
/* Record ffi.sizeof(), ffi.alignof(), ffi.offsetof(). */
/* Specialize to the field name. */
/* Just in case. */
/* -- Miscellaneous library functions ------------------------------------- */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_ctype.c
/*
/* -- C type definitions -------------------------------------------------- */
/* Predefined typedefs. */
/* Vararg handling. */ \
/* From stddef.h. */ \
/* Subset of stdint.h. */ \
/* End of typedef list. */
/* Keywords (only the ones we actually care for). */
/* Type specifiers. */ \
/* Type qualifiers. */ \
/* Storage class specifiers. */ \
/* GCC Attributes. */ \
/* MSVC Attributes. */ \
/* Other type specifiers. */ \
/* Operators. */ \
/* End of keyword list. */
/* Type info for predefined types. Size merged in. */
/* Predefined type names collected in a single string. */
/* -- C type interning ---------------------------------------------------- */
/* Create new type element. */
/* Intern a type element. */
/* Add type element to hash table. */
/* Add named element to hash table. */
/* Get a C type by name, matching the type mask. */
/* Simplify caller logic. ctype_get() would assert. */
/* Get a struct/union/enum/function field by name. */
/* Not found. */
/* -- C type information -------------------------------------------------- */
/* Follow references and get raw type for a C type ID. */
/* Get size for a C type ID. Does NOT support VLA/VLS. */
/* Get size for a variable-length C type. Does NOT support other C types. */
/* Add the struct size. */
/* Remember last field of VLS. */
/* Must be a VLA. */
/* Get array element. */
/* Calculate actual size of VLA and check for overflow. */
/* Get type, qualifiers, size and alignment for a C type ID. */
/* Follow child. Need to look at its attributes, too. */
/* Get ctype metamethod. */
/* -- C type representation ----------------------------------------------- */
/* Fixed max. length of a C type representation. */
/* Prepend string. */
/* Prepend char. */
/* Prepend number. */
/* Append char. */
/* Append number. */
/* Prepend qualifiers. */
/* Prepend named type. */
/* Return a printable representation of a C type. */
/* Convert int64_t/uint64_t to string with 'LL' or 'ULL' suffix. */
/* Convert complex to string with 'i' or 'I' suffix. */
/* -- C type state -------------------------------------------------------- */
/* Initialize C type table and state. */
/* Free C type table and state. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_debug.c
/*
/* -- Frames -------------------------------------------------------------- */
/* Get frame corresponding to a level. */
/* Traverse frames backwards. */
/* Skip dummy frames. See lj_meta_call(). */
/* Level found. */
/* Skip vararg pseudo-frame. */
/* Level not found. */
/* Invalid bytecode position. */
/* Return bytecode position for function/frame or NO_BCPOS. */
/* Cannot derive a PC for non-Lua functions. */
/* Lua function on top. */
/* Only happens during error/hook handling. */
/* Lua function below errfunc/gc/hook: find cframe to get the PC. */
/* Undo the effects of lj_trace_exit for JLOOP. */
/* -- Line numbers -------------------------------------------------------- */
/* Get line number for a bytecode position. */
/* Get line number for function/frame. */
/* -- Variable names ------------------------------------------------------ */
/* Read ULEB128 value. */
/* Get name of a local variable from slot number and PC. */
/* End of varinfo. */
/* Skip over variable name string. */
/* Get name of local variable from 1-based slot number and function/frame. */
/* Negative slot number is for varargs. */
/* Vararg frame has been set up? (pc!=0) */
/* Get name of upvalue. */
/* Get name and value of upvalue. */
/* Deduce name of an object from slot number and PC. */
/* Deduce function name from caller of a frame. */
/* -- Source code locations ----------------------------------------------- */
/* Generate shortened source name. */
/* Remove first char. */
/* Ensures null termination. */
/* Output "source", or "...source". */
/* Skip the `@' */
/* Get last part of file name. */
/* Output [string "string"]. */
/* Length, up to first control char. */
/* Must truncate? */
/* Add current location of a frame to error message. */
/* Push location string for a bytecode position to Lua stack. */
/* -- Public debug API ---------------------------------------------------- */
/* lua_getupvalue() and lua_setupvalue() are in lj_api.c. */
/* Bad option. */
/* Ok. */
/* Number of frames for the leading and trailing part of a traceback. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_dispatch.c
/*
/* Bump GG_NUM_ASMFF in lj_dispatch.h as needed. Ugly. */
/* -- Dispatch table management ------------------------------------------- */
/* Initialize instruction dispatch table and hot counters. */
/* The JIT engine is off by default. luaopen_jit() turns it on. */
/* Initialize hotcount table. */
/* Internal dispatch mode bits. */
/* JIT compiler on. */
/* Recording active. */
/* Override instruction dispatch. */
/* Override call dispatch. */
/* Override return dispatch. */
/* Update dispatch table depending on various flags. */
/* Mode changed? */
/* Hotcount if JIT is on, but not while recording. */
/* Otherwise use the non-hotcounting instructions. */
/* Init static counting instruction dispatch first (may be copied below). */
/* Set dynamic instruction dispatch. */
/* Need to update the whole table. */
/* No ins dispatch? */
/* Copy static dispatch table to dynamic dispatch table. */
/* Overwrite with dynamic return dispatch. */
/* The recording dispatch also checks for hooks. */
/* Otherwise set dynamic counting ins. */
/* Set dynamic return dispatch. */
/* Set dynamic call dispatch. */
/* Update the whole table? */
/* No call hooks? */
/* Overwrite dynamic counting ins. */
/* Reset hotcounts for JIT off to on transition. */
/* -- JIT mode setting ---------------------------------------------------- */
/* Set JIT mode for a single prototype. */
/* (Re-)enable JIT compilation. */
/* Unpatch all ILOOP etc. bytecodes. */
/* Flush and/or disable JIT compilation. */
/* Flush all traces of prototype. */
/* Recursively set the JIT mode for all children of a prototype. */
/* Public API function: control the JIT engine. */
/* Abort recording on any state change. */
/* Avoid pulling the rug from under our own feet. */
/* Don't turn on JIT compiler without SSE2 support. */
/* Cannot use funcV() for frame slot. */
/* Failed. */
/* Failed. */
/* Failed. */
/* Failed. */
/* Failed. */
/* Failed. */
/* OK. */
/* Enforce (dynamic) linker error for version mismatches. See luajit.c. */
/* -- Hooks --------------------------------------------------------------- */
/* This function can be called asynchronously (e.g. during a signal). */
/* Consistency. */
/* Abort recording on any hook change. */
/* Call a hook. */
/* Abort recording on any hook call. */
/* Top frame, nextframe = NULL. */
/* -- Dispatch callbacks -------------------------------------------------- */
/* Calculate number of used stack slots in the current frame. */
/* Instruction dispatch. Used by instr/line/return hooks or when recording. */
/* Fix top. */
/* The interpreter bytecode PC is offset by 1. */
/* Fix top again. */
/* Fix top again. */
/* Initialize call. Ensure stack space and return # of missing parameters. */
/* Call dispatch. Used by call hooks, hot calls or when recording. */
/* Marker for hot call. */
/* Record the FUNC* bytecodes, too. */
/* The interpreter bytecode PC is offset by 1. */
/* Add missing parameters. */
/* Preserve modifications of missing parameters by lua_setlocal(). */
/* Get FUNC* op. */
/* Use the non-hotcounting variants if JIT is off or while recording. */
/* Return static dispatch target. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_err.c
/*
/*
/* -- Error messages ------------------------------------------------------ */
/* Error message strings. */
/* -- Internal frame unwinding -------------------------------------------- */
/* Unwind Lua stack and move error message to new top. */
/* Unwind until stop frame. Optionally cleanup frames. */
/* C frame without Lua frame? */
/* Frame reached? */
/* Lua frame. */
/* C frame. */
/* Continue unwinding. */
/* Protected C frame. */
/* Resume? */
/* Assumes nobody uses coroutines inside hooks. */
/* Continuation frame. */
/* Vararg frame. */
/* FF pcall() frame. */
/* FF pcall() frame inside hook. */
/* No C frame. */
/* Anything non-NULL will do. */
/* -- External frame unwinding -------------------------------------------- */
/*
/* LUAJIT2\0 */
/* DWARF2 personality handler referenced from interpreter .eh_frame. */
/* Workaround for ancient libgcc bug. Still present in RHEL 5.5. :-/
/* This is not the proper way to escape from the unwinder. We get away with
/* Sorry, no thread safety for OSX. Complain to Apple, not me. */
/* Raise DWARF2 exception. */
/* ARM unwinder personality handler referenced from interpreter .ARM.extab. */
/*
//www.nynaeve.net/?p=99 */
/* Taken from: http://www.nynaeve.net/?p=99 */
/* Another wild guess. */
/* Workaround for broken MinGW64 declaration. */
/* Win64 exception handler for interpreter frame. */
/* EH_UNWINDING|EH_EXIT_UNWIND */
/* Unwind internal frames. */
/* We catch it, so start unwinding the upper frames. */
/* Don't catch access violations etc. */
/* Unwind the stack and call all handlers for all lower C frames
/* RtlUnwindEx should never return. */
/* Raise Windows exception. */
/* EH_NONCONTINUABLE */, 0, NULL);
/* -- Error handling ------------------------------------------------------ */
/* Throw error. Find catch frame, unwind stack and continue. */
/*
/* Return string object for error message. */
/* Out-of-memory error. */
/* Don't touch the stack during lua_open. */
/* Find error function for runtime errors. Requires an extra stack traversal. */
/* cframe without frame? */
/* Error handler not inherited (-1)? */
/* Else unwind cframe and continue searching. */
/* fallthrough */
/* xpcall? */
/* Point to xpcall's errorfunc. */
/* Runtime error. */
/* Stack: |errfunc|msg| -> |msg| */
/* Formatted runtime error message. */
/* Non-vararg variant for better calling conventions. */
/* Lexer error. */
/* Typecheck error for operands. */
/* Typecheck error for ordered comparisons. */
/* This assumes the two "boolean" entries are commoned by the C compiler. */
/* Typecheck error for __call. */
/* Gross hack if lua_[p]call or pcall/xpcall fail for a non-callable object:
/* Error in context of caller. */
/* Remove frame for FFI metamethods. */
/* Formatted error in context of caller. */
/* Error in context of caller. */
/* Argument error message. */
/* Check for "method". */
/* Formatted argument error. */
/* Argument error. */
/* Typecheck error for arguments. */
/* Typecheck error for arguments. */
/* -- Public error handling API ------------------------------------------- */
/* Forwarders for the public API (C calling convention and no LJ_NORET). */
/* unreachable */
/* unreachable */
/* unreachable */
/* unreachable */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_ffrecord.c
/*
/* Some local macros to save typing. Undef'd at the end. */
/* Pass IR on to next optimization in chain (FOLD). */
/* -- Fast function recording handlers ------------------------------------ */
/* Conventions for fast function call handlers:
/* Type of handler to record a fast function. */
/* Get runtime value of int argument. */
/* Get runtime value of string argument. */
/* Return number of results wanted by caller. */
/* Throw error for unsupported variant of fast function. */
/* Fallback handler for all fast functions that are not recorded (yet). */
/* C functions can have arbitrary side-effects and are not recorded (yet). */
/* -- Base library fast functions ----------------------------------------- */
/* Arguments already specialized. The interpreter throws for nil/false. */
/* Pass through all arguments. */
/* Arguments already specialized. Result is a constant string. Neat, huh? */
/* else: Interpreter will throw. */
/* Guard for no __metatable. */
/* else: Interpreter will throw. */
/* else: Interpreter will throw. */
/* Pass through table at J->base[0] as result. */
/* else: Interpreter will throw. */
/* else: Interpreter will throw. */
/* else: Interpreter will throw. */
/* Determine mode of select() call. */
/* select('#', ...) */
/* select(n, ...) */
/* A bit misleading. */
/* select('#', ...) */
/* select(k, ...) */
/* else: Interpreter will throw. */
/* else: Interpreter will throw. */
/* Would need an inverted STRTO for this case. */
/* Has metamethod? */
/* Temporarily insert metamethod below object. */
/* Need to protect lj_record_tailcall because it may throw. */
/* Always undo Lua stack changes to avoid confusing the interpreter. */
/* Propagate errors. */
/* Pending call. */
/* Tailcalled to metamethod. */
/* Ignore __tostring in the string base metatable. */
/* Pass on result in J->base[0]. */
/* No support for string coercion. */
/* else: Interpreter will throw. */
/* else: Interpreter will throw. */
/* Pending call. */
/* else: Interpreter will throw. */
/* Swap function and traceback. */
/* Need to protect lj_record_call because it may throw. */
/* Always undo Lua stack swap to avoid confusing the interpreter. */
/* Propagate errors. */
/* Pending call. */
/* else: Interpreter will throw. */
/* -- Math library fast functions ----------------------------------------- */
/* Record rounding functions math.floor and math.ceil. */
/* Pass through integers unmodified. */
/* Result is integral (or NaN/Inf), but may not fit an int32_t. */
/* Try to narrow using a guarded conversion to int. */
/* Record unary math.* functions, mapped to IR_FPMATH opcode. */
/* Record math.log. */
/* Record math.atan2. */
/* Record math.ldexp. */
/* Record math.asin, math.acos, math.atan. */
/* Prevent collection. */
/* d = floor(d*(r2-r1+1.0)) + r1 */
/* d = floor(d*r1) + 1.0 */
/* -- Bit library fast functions ------------------------------------------ */
/* Record unary bit.tobit, bit.bnot, bit.bswap. */
/* Record N-ary bit.band, bit.bor, bit.bxor. */
/* Record bit shifts. */
/* -- String library fast functions --------------------------------------- */
/* Handle string.byte (rd->data = 0) and string.sub (rd->data = 1). */
/* string.sub(str, start [,end]) */
/* string.byte(str, [,start [,end]]) */
/* Return string.sub result. */
/* Also handle empty range here, to avoid extra traces. */
/* Range underflow: return empty string. */
/* Return string.byte result(s). */
/* Empty range or range underflow: return no results. */
/* -- Table library fast functions ---------------------------------------- */
/* else: Interpreter will throw. */
/* Simple pop: t[#t] = nil */
/* Specialize load only if needed. */
/* Load previous value. */
/* Assumes ix.key/ix.tab is not modified for raw lj_record_idx(). */
/* Remove value. */
/* Complex case: remove in the middle. */
/* else: Interpreter will throw. */
/* Simple push: t[#t+1] = v */
/* Set new value. */
/* Complex case: insert in the middle. */
/* else: Interpreter will throw. */
/* -- I/O library fast functions ------------------------------------------ */
/* Get FILE* for I/O function. Any I/O error aborts recording, so there's
/* io.func() */
/* fp:method() */
/* Check result only if not ignored. */
/* Check result only if not ignored. */
/* Check result only if not ignored. */
/* -- Record calls to fast functions -------------------------------------- */
/* Record entry to a fast function or C function. */
/* Default is one result. */
/* Mark end of arguments. */
/* Call recff_* handler. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_func.c
/*
/* -- Prototypes ---------------------------------------------------------- */
/* -- Upvalues ------------------------------------------------------------ */
/* Find existing open upvalue for a stack slot or create a new one. */
/* Search the sorted list of open upvalues. */
/* Found open upvalue pointing to same slot? */
/* Resurrect it, if it's dead. */
/* No matching upvalue found. Create a new one. */
/* Still open. */
/* Pointing to the stack slot. */
/* NOBARRIER: The GCupval is new (marked white) and open. */
/* Insert into sorted list of open upvalues. */
/* Insert into GC list, too. */
/* Create an empty and closed upvalue. */
/* Close all open upvalues pointing to some stack level or above. */
/* No longer in open list. */
/* -- Functions (closures) ------------------------------------------------ */
/* NOBARRIER: The GCfunc is new (marked white). */
/* Set to zero until upvalues are initialized. */
/* NOBARRIER: Really a setgcref. But the GCfunc is new (marked white). */
/* Saturating 3 bit counter (0..7) for created closures. */
/* Create a new Lua function with empty upvalues. */
/* NOBARRIER: The GCfunc is new (marked white). */
/* Do a GC check and create a new Lua function with inherited upvalues. */
/* NOBARRIER: The GCfunc is new (marked white). */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_gc.c
/*
/* Macros to set GCobj colors and flags. */
/* -- Mark phase ---------------------------------------------------------- */
/* Mark a TValue (if needed). */
/* Mark a GCobj (if needed). */
/* Mark a string object. */
/* Mark a white GCobj. */
/* Userdata are never gray. */
/* Closed upvalues are never gray. */
/* Mark GC roots. */
/* Start a GC cycle and mark the root set. */
/* Mark open upvalues. */
/* Mark userdata in mmudata list. */
/* Could be from previous GC. */
/* Separate userdata objects to be finalized to mmudata list. */
/* Nothing to do. */
/* Done, as there's no __gc metamethod. */
/* Otherwise move userdata to be finalized to mmudata list. */
/* Link to end of mmudata list. */
/* Create circular list. */
/* -- Propagation phase --------------------------------------------------- */
/* Traverse a table. */
/* Valid __mode field? */
/* Weak tables are cleared in the atomic phase. */
/* Nothing to mark if both keys/values are weak. */
/* Mark array part. */
/* Mark hash part. */
/* Mark non-empty slot. */
/* Traverse a function. */
/* Mark Lua function upvalues. */
/* Mark C function upvalues. */
/* Mark a trace. */
/* Traverse a trace. */
/* The current trace is a GC root while not anchored in the prototype (yet). */
/* Traverse a prototype. */
/* Mark collectable consts. */
/* Traverse the frame structure of a stack. */
/* Note: extra vararg frame not skipped, marks function twice (harmless). */
/* Need to mark hidden function (or L). */
/* Correct bias of -1 (frame == base-1). */
/* Return minimum needed stack size. */
/* Traverse a thread object. */
/* Clear unmarked slots. */
/* Propagate one gray object. Traverse it and turn it black. */
/* Remove from gray list. */
/* Keep weak tables gray. */
/* Threads are never black. */
/* Propagate all gray objects. */
/* -- Sweep phase --------------------------------------------------------- */
/* Try to shrink some common data structures. */
/* Shrink string table. */
/* Shrink temp buf. */
/* Type of GC free functions. */
/* GC free functions for LJ_TSTR .. LJ_TUDATA. ORDER LJ_T */
/* Full sweep of a GC list. */
/* Partial sweep of a GC list. */
/* Mask with other white and LJ_GC_FIXED. Or LJ_GC_SFIXED on shutdown. */
/* Need to sweep open upvalues, too. */
/* Black or current white? */
/* Value is alive, change to the current white. */
/* Otherwise value is dead, free it. */
/* Adjust list anchor. */
/* Check whether we can clear a key or a value slot from a table. */
/* Only collectable objects can be weak references. */
/* But strings cannot be used as weak references. */
/* And need to be marked. */
/* Object is about to be collected. */
/* Finalized userdata is dropped only from values. */
/* Cannot clear. */
/* Clear collected entries from weak tables. */
/* Clear array slot when value is about to be collected. */
/* Clear hash slot when key or value is about to be collected. */
/* Call a userdata or cdata finalizer. */
/* Save and restore lots of state around the __gc callback. */
/* Disable hooks and new traces during __gc. */
/* Prevent GC steps. */
/* Stack: |mo|o| -> | */
/* Restore GC threshold. */
/* Propagate errors. */
/* Finalize one userdata or cdata object from the mmudata list. */
/* Must not be called on trace. */
/* Unchain from list of userdata to be finalized. */
/* Add cdata back to the GC list and make it white. */
/* Resolve finalizer. */
/* Clear entry in finalizer table. */
/* Add userdata back to the main userdata list and make it white. */
/* Resolve the __gc metamethod. */
/* Finalize all userdata objects from mmudata list. */
/* Finalize all cdata objects from finalizer table. */
/* Mark finalizer table as disabled. */
/* Free all remaining GC objects. */
/* Free everything, except super-fixed objects (the main thread). */
/* Free all string hash chains. */
/* -- Collector ----------------------------------------------------------- */
/* Atomic part of the GC cycle, transitioning from mark to sweep phase. */
/* Need to remark open upvalues (the thread may be dead). */
/* Propagate any left-overs. */
/* Empty the list of weak tables. */
/* Mark running thread. */
/* Traverse current trace. */
/* Mark GC roots (again). */
/* Propagate all of the above. */
/* Empty the 2nd chance list. */
/* Propagate it. */
/* Separate userdata to be finalized. */
/* Mark them. */
/* And propagate the marks. */
/* All marking done, clear weak tables. */
/* Prepare for sweep phase. */
/* Flip current white. */
/* Initial estimate. */
/* GC state machine. Returns a cost estimate for each step performed. */
/* Start a new GC cycle by marking all GC roots. */
/* Propagate one gray object. */
/* End of mark phase. */
/* Don't run atomic phase on trace. */
/* Start of sweep phase. */
/* Sweep one chain. */
/* All string hash chains sweeped. */
/* Need any finalizations? */
/* Otherwise skip this phase to help the JIT. */
/* End of GC cycle. */
/* Don't call finalizers on trace. */
/* Finalize one userdata object. */
/* End of GC cycle. */
/* Perform a limited amount of incremental GC steps. */
/* Finished a GC cycle. */
/* Ditto, but fix the stack top first. */
/* Perform multiple GC steps. Called from JIT-compiled code. */
/* Return 1 to force a trace exit. */
/* Perform a full GC cycle. */
/* Caught somewhere in the middle. */
/* Sweep everything (preserving it). */
/* Reset lists from partial propagation. */
/* Fast forward to the sweep phase. */
/* Finish sweep. */
/* Now perform a full GC. */
/* -- Write barriers ------------------------------------------------------ */
/* Move the GC propagation frontier forward. */
/* Preserve invariant during propagation. Otherwise it doesn't matter. */
/* Move frontier forward. */
/* Make it white to avoid the following barrier. */
/* Specialized barrier for closed upvalue. Pass &uv->tv. */
/* Close upvalue. Also needs a write barrier. */
/* Copy stack slot to upvalue itself and point to the copy. */
/* A closed upvalue is never gray, so fix this. */
/* Make it black and preserve invariant. */
/* Make it white, i.e. sweep the upvalue. */
/* Mark a trace if it's saved during the propagation phase. */
/* -- Allocator ----------------------------------------------------------- */
/* Call pluggable memory allocator to allocate or resize a fragment. */
/* Allocate new GC object and link it to the root set. */
/* Resize growable vector. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_gdbjit.c
/*
/* This is not compiled in by default.
/* The GDB JIT API allows JIT compilers to pass debug information about
/* -- GDB JIT API --------------------------------------------------------- */
/* GDB JIT actions. */
/* GDB JIT entry. */
/* GDB JIT descriptor. */
/* GDB sets a breakpoint at this function. */
/* -- In-memory ELF object definitions ------------------------------------ */
/* ELF definitions. */
/* DWARF definitions. */
/* Yes, the order is strange, but correct. */
/* Minimal list of sections for the in-memory ELF object. */
/* In-memory ELF object. */
/* ELF header. */
/* ELF sections. */
/* ELF symbol table. */
/* Space for various section data. */
/* Combined structure for GDB JIT entry and ELF object. */
/* Template for in-memory ELF header. */
/* Nope, it's not 3. */
/* -- In-memory ELF object generation ------------------------------------- */
/* Context for generating the ELF object for the GDB JIT API. */
/* Pointer to next address in obj.space. */
/* Pointer to start address in obj.space. */
/* Generate symbols for this trace. */
/* Machine code address. */
/* Size of machine code. */
/* Stack adjustment for parent trace or interpreter. */
/* Stack adjustment for trace itself. */
/* Starting line number. */
/* Starting file name. */
/* Final size of ELF object. */
/* In-memory ELF object. */
/* Add a zero-terminated string. */
/* Append a decimal number. */
/* Add a ULEB128 value. */
/* Add a SLEB128 value. */
/* Shortcuts to generate DWARF structures. */
/* Initialize ELF section headers. */
/* Empty string at start of string table. */
/* Initialize symbol table. */
/* Empty string at start of string table. */
/* Initialize .eh_frame section. */
/* Emit DWARF EH CIE. */
/* Offset to CIE itself. */
/* Augmentation. */
/* Code alignment factor. */
/* Data alignment factor. */
/* Return address register. */
/* Augmentation data. */
/* Emit DWARF EH FDE. */
/* Offset to CIE. */
/* Machine code offset relative to .text. */
/* Machine code length. */
/* Augmentation data. */
/* Registers saved in CFRAME. */
/* Extra registers saved for JIT-compiled code. */
/* Parent/interpreter stack frame size. */
/* Only an approximation. */
/* Trace stack frame size. */
/* Initialize .debug_info section. */
/* DWARF version. */
/* Abbrev offset. */
/* Pointer size. */
/* Abbrev #1: DW_TAG_compile_unit. */
/* DW_AT_name. */
/* DW_AT_low_pc. */
/* DW_AT_high_pc. */
/* DW_AT_stmt_list. */
/* Initialize .debug_abbrev section. */
/* Abbrev #1: DW_TAG_compile_unit. */
/* Initialize .debug_line section. */
/* DWARF version. */
/* Minimum instruction length. */
/* is_stmt. */
/* Line base for special opcodes. */
/* Line range for special opcodes. */
/* Opcode base at DW_LNS_advance_line+1. */
/* Standard opcode lengths. */
/* Directory table. */
/* File name table. */
/* Undef shortcuts. */
/* Type of a section initializer callback. */
/* Call section initializer and set the section offset and size. */
/* Build in-memory ELF object. */
/* Fill in ELF header and clear structures. */
/* Initialize sections. */
/* -- Interface to GDB JIT API -------------------------------------------- */
/* Add new entry to GDB JIT symbol chain. */
/* Allocate memory for GDB JIT entry and ELF object. */
/* Copy ELF object. */
/* Link new entry to chain and register it. */
/* Add debug info for newly compiled trace and notify GDB. */
/* Delete debug info for trace and notify GDB. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_ir.c
/*
/* For pointers to libc/libm functions. */
/* Some local macros to save typing. Undef'd at the end. */
/* Pass IR on to next optimization in chain (FOLD). */
/* -- IR tables ----------------------------------------------------------- */
/* IR instruction modes. */
/* IR type sizes. */
/* C call info for CALL* instructions. */
/* -- IR emitter ---------------------------------------------------------- */
/* Grow IR buffer at the top. */
/* Grow IR buffer at the bottom or shift it up. */
/* More than half of the buffer is free on top: shift up by a quarter. */
/* Double the buffer size, but split the growth amongst top/bottom. */
/* Limit bottom growth. */
/* Emit IR without any optimizations. */
/* Emit call to a C function. */
/* Need snapshot after call with side effect. */
/* -- Interning of constants ---------------------------------------------- */
/*
/* Get ref of next IR constant and optionally grow IR.
/* Intern int32_t constant. */
/* The MRef inside the KNUM/KINT64 IR instructions holds the address of the
/* Pointer to next list. */
/* Number of used elements in this array. */
/* Array of constants. */
/* Free all chained arrays. */
/* Find 64 bit constant in chained array or add it. */
/* Search for the constant in the whole chain of arrays. */
/* Remember previous element in list. */
/* Search one array. */
/* Needed for +-0/NaN/absmask. */
/* Constant was not found, need to add it. */
/* Allocate a new array. */
/* Chain to the end of the list. */
/* Link first array. */
/* Add to current array. */
/* Intern 64 bit constant, given by its address. */
/* Intern FP constant, given by its 64 bit pattern. */
/* Intern 64 bit integer constant. */
/* Check whether a number is int and return it. -0 is NOT considered an int. */
/* Special check for -0. */
/* Intern number as int32_t constant if possible, otherwise as FP constant. */
/* Intern GC object "constant". */
/* NOBARRIER: Current trace is a GC root. */
/* Intern 32 bit pointer constant. */
/* Intern typed NULL constant. */
/* Intern key slot. */
/* Const part is not touched by CSE/DCE, so 0-65535 is ok for IRMlit here. */
/* -- Access to IR constants ---------------------------------------------- */
/* Copy value of IR constant. */
/* Common mistake. */
/* -- Convert IR operand types -------------------------------------------- */
/* Convert from string to number. */
/* Convert from integer or string to number. */
/* Convert from integer or number to string. */
/* -- Miscellaneous IR ops ------------------------------------------------ */
/* Evaluate numeric comparison. */
/* Evaluate string comparison. */
/* Rollback IR to previous state. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_lex.c
/*
/* Lua lexer token names. */
/* -- Buffer handling ----------------------------------------------------- */
/* skip `\n' or `\r' */
/* skip `\n\r' or `\r\n' */
/* -- Scanner for terminals ----------------------------------------------- */
/* Parse a number literal. */
/* Already in correct format. */
/* Load FFI library on-demand. */
/* skip 2nd `[' */
/* string starts with a newline? */
/* skip it */
/* skip 2nd `]' */
/* avoid wasting space */
/* Skip the '\\'. */
/* Hexadecimal escape '\xXX'. */
/* Skip whitespace. */
/* Decimal escape '\ddd'. */
/* skip delimiter */
/* -- Main lexical scanner ------------------------------------------------ */
/* Numeric literal. */
/* Identifier or reserved word. */
/* Reserved word? */
/* else is a comment */
/* `skip_sep' may dirty the buffer */
/* long comment */
/* else short comment */
/* ... */
/* .. */
/* Single-char tokens (+ - / ...). */
/* -- Lexer API ----------------------------------------------------------- */
/* Setup lexer state. */
/* No look-ahead token. */
/* Read-ahead first char. */
/* Skip UTF-8 BOM (if buffered). */
/* Skip POSIX #! header line. */
/* Bytecode dump. */
/*
/* Cleanup lexer state. */
/* No lookahead token? */
/* Get next token. */
/* Otherwise return lookahead token. */
/* Reserved words are never collected. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_lib.c
/*
/* -- Library initialization ---------------------------------------------- */
/* _LOADED[libname] = new table */
/* Avoid barriers further down. */
/* Copy handler from previous function. */
/* Get cf or handler from C function table. */
/* NOBARRIER: See above for common barrier. */
/* NOBARRIER: See above for common barrier. */
/* -- Type checks --------------------------------------------------------- */
/* unreachable */
/* unreachable */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_load.c
/*
/* -- Load Lua source code and bytecode ----------------------------------- */
/* Inherit error function. */
/* Don't combine above/below into one statement. */
/* -- Dump bytecode ------------------------------------------------------- */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_mcode.c
/*
/* -- OS-specific functions ----------------------------------------------- */
/* Define this if you want to run LuaJIT with Valgrind. */
/* Synchronize data/instruction cache. */
/* Fallback allocator. This will fail if memory is not executable by default. */
/* -- MCode area protection ----------------------------------------------- */
/* Define this ONLY if page protection twiddling becomes a bottleneck. */
/* It's generally considered to be a potential security risk to have
/* This is the default behaviour and much safer:
/* Protection twiddling failed. Probably due to kernel security. */
/* Change protection of MCode area. */
/* -- MCode area allocation ----------------------------------------------- */
/* Get memory within relative jump distance of our code in 64 bit mode. */
/* Target an address in the static assembler code (64K aligned).
/* Use the middle of the 256MB-aligned region. */
/* First try a contiguous area below the last one. */
/* Limit probing iterations, depending on the available pool size. */
/* Free badly placed area. */
/* Next try probing 64K-aligned pseudo-random addresses. */
/* Give up. OS probably ignores hints? */
/* All memory addresses are reachable by relative jumps. */
/* Allow better executable memory allocation for OpenBSD W^X mode. */
/* -- MCode area management ----------------------------------------------- */
/* Linked list of MCode areas. */
/* Next area. */
/* Size of current area. */
/* Allocate a new MCode area. */
/* Free all MCode areas. */
/* -- MCode transactions -------------------------------------------------- */
/* Reserve the remainder of the current MCode area. */
/* Commit the top part of the current MCode area. */
/* Abort the reservation. */
/* Set/reset protection to allow patching of MCode areas. */
/* Try current area first to use the protection cache. */
/* Otherwise search through the list of MCode areas. */
/* Limit of MCode reservation reached. */
/* Too long for any area. */
/* Retry with new area. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_meta.c
/*
/* -- Metamethod handling ------------------------------------------------- */
/* String interning of metamethod names for fast indexing. */
/* NOBARRIER: g->gcroot[] is a GC root. */
/* Negative caching of a few fast metamethods. See the lj_meta_fast() macro. */
/* No metamethod? */
/* Set negative cache flag. */
/* Lookup metamethod for object. */
/* Tailcall from C function. */
/* Preserve old PC from frame. */
/* Replace frame with new object. */
/* Dummy frame object. */
/*
/* Setup call to metamethod to be run by Assembler VM. */
/*
/* Assembler VM stores PC in upper word. */
/* Store metamethod and two arguments. */
/* Return new base. */
/* -- C helpers for some instructions, called from assembler VM ----------- */
/* Helper for TGET*. __index chain and metamethod. */
/* unreachable */
/* Trigger metamethod call. */
/* unreachable */
/* Helper for TSET*. __newindex chain and metamethod. */
/* Invalidate negative metamethod cache. */
/* Invalidate negative metamethod cache. */
/* unreachable */
/* L->top+2 = v filled in by caller. */
/* Trigger metamethod call. */
/* unreachable */
/* Helper for arithmetic instructions. Coercion, metamethod. */
/* Try coercion first. */
/* unreachable */
/* In-place coercion of a number to a string. */
/* Helper for CAT. Coercion, iterative concat, __concat metamethod. */
/* unreachable */
/* One of the top two elements is not a string, call __cat metamethod:
/* Careful with the order of stack copies! */
/* Trigger metamethod call. */
/* Shortcut. */
/* Pick as many strings as possible from the top and concatenate them:
/* Helper for LEN. __len metamethod. */
/* Helper for equality comparisons. __eq metamethod. */
/* Field metatable must be at same offset for GCtab and GCudata! */
/* Trigger metamethod call. */
/* Helper for ordered comparisons. String compare, __lt/__le metamethods. */
/* Never called with two numbers. */
/* MM_le not found: retry with MM_lt. */
/* Swap operands. */
/* Use LT and flip condition. */
/* Helper for calls. __call metamethod. */
/* Helper for FORI. Coercion. */
/* Ensure all slots are integers or all slots are numbers. */
/* Narrow to integers. */
/* Widen to numbers. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_obj.c
/*
/* Object type names. */
/* ORDER LUA_T */
/* ORDER LJ_T */
/* Compare two objects without calling metamethods. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_opt_dce.c
/*
/* Some local macros to save typing. Undef'd at the end. */
/* Scan through all snapshots and mark all referenced instructions. */
/* Backwards propagate marks. Replace unused instructions with NOPs. */
/* Reroute original instruction chain. */
/* Replace instruction with NOP. */
/* Dead Code Elimination.
/* Invalidate cache. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_opt_fold.c
/*
/* Here's a short description how the FOLD engine processes instructions:
/* Some local macros to save typing. Undef'd at the end. */
/* Pass IR on to next optimization in chain (FOLD). */
/* Fold function type. Fastcall on x86 significantly reduces their size. */
/* Macros for the fold specs, so buildvm can recognize them. */
/* Note: They must be at the start of a line or buildvm ignores them! */
/* Barrier to prevent using operands across PHIs. */
/* Barrier to prevent folding across a GC step.
/* -- Constant folding for FP numbers ------------------------------------- */
/* Must not use kfold_kref for numbers (could be NaN). */
/* -- Constant folding for 32 bit integers -------------------------------- */
/* -- Constant folding for 64 bit integers -------------------------------- */
/* -- Constant folding for strings ---------------------------------------- */
/* strref(snew(ptr, len), 0) ==> ptr */
/* Reassociate: strref(snew(strref(str, a), len), b) ==> strref(str, a+b) */
/* IRIns * is not valid across emitir. */
/* Clobbers fins! */
/* -- Constant folding of pointer arithmetic ------------------------------ */
/* -- Constant folding of conversions ------------------------------------- */
/* We're about to create a guard which always fails, like CONV +1.5.
/* Workaround for MSVC bug. */
/* -- Constant folding of equality checks --------------------------------- */
/* Don't constant-fold away FLOAD checks against KNULL. */
/* But fold all other KNULL compares, since only KNULL is equal to KNULL. */
/* Constants are unique, so same refs <==> same value. */
/* -- Algebraic shortcuts ------------------------------------------------- */
/* round(round_left(x)) = round_left(x) */
/* f(g(x)) ==> g(x) */
/* abs(neg(x)) ==> abs(x) */
/* Note: no safe shortcuts with STRTO and TOSTR ("1e2" ==> +100 ==> "100"). */
/* See above. Fold would be ok, but not beneficial. */
/* f(g(x)) ==> x */
/* -- FP algebraic simplifications ---------------------------------------- */
/* FP arithmetic is tricky -- there's not much to simplify.
/* (-a) + b ==> b - a */
/* a + (-b) ==> a - b */
/* x - (+-0) ==> x */
/* (-x) - k ==> (-k) - x */
/* a - (-b) ==> a + b */
/* x o 1 ==> x */
/* x o -1 ==> -x */
/* x * 2 ==> x + x */
/* x / 2^k ==> x * 2^-k */
/* Multiply by exact reciprocal. */
/* (-a) o k ==> a o (-k) */
/* (-a) o (-b) ==> a o b */
/* x ^ 0 ==> 1 */
/* Result must be a number, not an int. */
/* x ^ 1 ==> x */
/* Limit code explosion. */
/* x ^ (-k) ==> (1/x) ^ k. */
/* Unroll x^k for 1 <= k <= 65536. */
/* Handle leading zeros. */
/* Handle trailing bits. */
/* 2.0 ^ i ==> ldexp(1.0, tonum(i)) */
/* -- Simplify conversions ------------------------------------------------ */
/* _NUM */
/* Only safe with a guarded conversion to int. */
/* f(g(x)) ==> x */
/* _INT */
/* _U32*/
/* Fold even across PHI to avoid expensive num->int conversions in loop. */
/* _INT or _U32 */
/* _INT or _U32 */
/* Reduce to a sign-extension. */
/* Reduce to a zero-extension. */
/* _INT or _U32 */
/* _INT or _U32 */
/* _INT or _U32 */
/* _INT or _U32 */
/* _FLOAT */
/* Shortcut TOBIT + IRT_NUM <- IRT_INT/IRT_U32 conversion. */
/* Fold even across PHI to avoid expensive num->int conversions in loop. */
/* Shortcut floor/ceil/round + IRT_NUM <- IRT_INT/IRT_U32 conversion. */
/* Strength reduction of widening. */
/* Use scalar evolution analysis results to strength-reduce sign-extension. */
/* Eliminate widening. All 32 bit ops do an implicit zero-extension. */
/* Reduce to a (cheaper) zero-extension. */
/* Strength reduction of narrowing. */
/* Special CSE rule for CONV. */
/* Commoning with stronger checks is ok. */
/* No fallthrough to regular CSE. */
/* FP conversion narrowing. */
/* Narrowing ignores PHIs and repeating it inside the loop is not useful. */
/* -- Integer algebraic simplifications ----------------------------------- */
/* i o 0 ==> i */
/* i * 0 ==> 0 */
/* i * 1 ==> i */
/* i * 2 ==> i + i */
/* i - 0 ==> i */
/* i - k ==> i + (-k) */
/* Overflow for -2^31 ok. */
/* 0 - i ==> -i */
/* i + 0 ==> i */
/* i - 0 ==> i */
/* i - k ==> i + (-k) */
/* Note: many more simplifications are possible, e.g. 2^k1 +- 2^k2.
/* i * 1 ==> i */
/* i * 2^k ==> i << k */
/* i * 0 ==> 0 */
/* i * 0 ==> 0 */
/* NYI: SPLIT for BSHL and 32 bit backend support. */
/* i % (2^k) ==> i & (2^k-1) */
/* i - i ==> 0 */
/* (i + j) - i ==> j */
/* (i + j) - j ==> i */
/* (i - j) - i ==> 0 - j */
/* i - (i - j) ==> j */
/* i - (i + j) ==> 0 - j */
/* i - (j + i) ==> 0 - j */
/* (i + j1) - (i + j2) ==> j1 - j2 */
/* (i + j1) - (j2 + i) ==> j1 - j2 */
/* (j1 + i) - (i + j2) ==> j1 - j2 */
/* (j1 + i) - (j2 + i) ==> j1 - j2 */
/* i & 0 ==> 0 */
/* i & -1 ==> i */
/* i | 0 ==> i */
/* i | -1 ==> -1 */
/* i xor 0 ==> i */
/* i xor -1 ==> ~i */
/* i o 0 ==> i */
/* i << 1 ==> i + i */
/* i o k ==> i o (k & mask) */
/* bror(i, k) ==> brol(i, (-k)&mask) */
/* i o (j & mask) ==> i o j */
/* 0 o i ==> 0 */
/* 0 o i ==> 0; -1 o i ==> -1 */
/* (i & k1) o k2 ==> (i o k2) & (k1 o k2) */
/* (i o k1) & k2 ==> i, if (-1 o k1) == k2 */
/* -- Reassociation ------------------------------------------------------- */
/* (i o k1) o k2 ==> i o k1, if (k1 o k2) == k1. */
/* (i o k1) o k2 ==> i o (k1 o k2) */
/* (i o k1) o k2 ==> i o (k1 o k2) */
/* (a o b) o a ==> a o b; (a o b) o b ==> a o b */
/* (a xor b) xor a ==> b */
/* (a xor b) xor b ==> a */
/* The (shift any KINT) rule covers k2 == 0 and more. */
/* (i o k1) o k2 ==> i o (k1 + k2) */
/* Combined shift too wide? */
/* (x o k1) o k2 ==> x o k1, if (k1 o k2) == k1. */
/* (x o k1) o k2 ==> x o (k1 o k2) */
/* (x o k1) o k2 ==> x o k1, if (k1 o k2) == k1. */
/* (x o k1) o k2 ==> x o (k1 o k2) */
/* (b o1 a) o2 b ==> b; (a o1 b) o2 b ==> b */
/* a o2 (a o1 b) ==> a; a o2 (b o1 a) ==> a */
/* -- Array bounds check elimination -------------------------------------- */
/* Eliminate ABC across PHIs to handle t[i-1] forwarding case.
/* Eliminate ABC for constants.
/* Already performed CSE. */
/* Eliminate invariant ABC inside loop. */
/* Invariant ABC marked as PTR. Drop if op1 is invariant, too. */
/* -- Commutativity ------------------------------------------------------- */
/* The refs of commutative ops are canonicalized. Lower refs go to the right.
/* Move lower ref to the right. */
/* For non-numbers only: x == x ==> drop; x ~= x ==> fail */
/* For non-numbers only: x <=> x ==> drop; x <> x ==> fail */
/* Move lower ref to the right. */
/* GT <-> LT, GE <-> LE, does not affect U */
/* x o x ==> x */
/* i xor i ==> 0 */
/* -- Simplification of compound expressions ------------------------------ */
/* Turn: string.sub(str, a, b) == kstr
/* Handle string lengths 0, 1, 2, 3, 4. */
/* Creates shorter immediates. */
/* Handle string lengths 0 or 1. */
/* Prefer unsigned loads. */
/* Caveat: fins/fleft/fright is no longer valid after emitir. */
/* NE is not expanded since this would need an OR of two conds. */
/* Only handle the constant length case. */
/* A 4 byte load for length 3 is ok -- all strings have an extra NUL. */
/* -- Loads --------------------------------------------------------------- */
/* Loads cannot be folded or passed on to CSE in general.
/* From HREF fwd (see below). Must eliminate, not supported by fwd/backend. */
/* Upvalue refs are really loads, but there are no corresponding stores.
/* We can safely FOLD/CSE array/hash refs and field loads, since there
/* Strings are immutable, so we can safely FOLD/CSE the related FLOAD. */
/* The C type ID of cdata objects is immutable. */
/* Get the contents of immutable cdata objects. */
/* No PHI barrier needed. CNEW/CNEWI op1 is const. */
/* Pointer, int and int64 cdata objects are immutable. */
/* Fold even across PHI to avoid allocations. */
/* Vararg loads have no corresponding stores. */
/* All other field loads need alias analysis. */
/* This is for LOOP only. Recording handles SLOADs internally. */
/* Only fold for KKPTR. The pointer _and_ the contents must be const. */
/* -- Write barriers ------------------------------------------------------ */
/* Write barriers are amenable to CSE, but not across any incremental
/* CSE across GC step? */
/* Raw emit. Assumes fins is left intact by CSE. */
/* New tables are always white and never need a barrier. */
/* Except across a GC step. */
/* -- Stores and allocations ---------------------------------------------- */
/* Stores and allocations cannot be folded or passed on to CSE in general.
/* Treated like a store. */
/* Safeguard fallback. */
/* Modifies BASE. */
/* ------------------------------------------------------------------------ */
/* Every entry in the generated hash table is a 32 bit pattern:
/* ------------------------------------------------------------------------ */
/* Fold IR instruction. */
/* Folding disabled? Chain to CSE, but not for loads/stores/allocs. */
/* No FOLD, forwarding or CSE? Emit raw IR for loads, except for SLOAD. */
/* No FOLD or DSE? Emit raw IR for stores. */
/* Fold engine start/retry point. */
/* Construct key from opcode and operand opcodes (unless literal/none). */
/* Literal mask. Must include IRCONV_*MASK. */
/* Check for a match in order from most specific to least specific. */
/* Lookup key in semi-perfect hash table. */
/* Exhausted folding. Pass on to CSE. */
/* Return value processing, ordered by frequency. */
/* -- Common-Subexpression Elimination ------------------------------------ */
/* CSE an IR instruction. This is very fast due to the skip-list chains. */
/* Avoid narrow to wide store-to-load forwarding stall */
/* Limited search for same operands in per-opcode chain. */
/* Relies on lit < REF_BIAS. */
/* Common subexpression found. */
/* Otherwise emit IR (inlined for speed). */
/* CSE with explicit search limit. */
/* ------------------------------------------------------------------------ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_opt_loop.c
/*
/* Loop optimization:
/* Some local macros to save typing. Undef'd at the end. */
/* Pass IR on to next optimization in chain (FOLD). */
/* Emit raw IR without passing through optimizations. */
/* -- PHI elimination ----------------------------------------------------- */
/* Emit or eliminate collected PHIs. */
/* Pass #1: mark redundant and potentially redundant PHIs. */
/* Invariants are redundant. */
/* Quick check for simple recurrences failed, need pass2. */
/* Pass #2: traverse variant part and clear marks of non-redundant PHIs. */
/* ORDER IR */
/* Pass #3: add PHIs for variant slots without a corresponding SLOAD. */
/* Unmark potential uses, too. */
/* Pass #4: propagate non-redundant PHIs. */
/* Propagate only from unmarked PHIs. */
/* Right ref points to other PHI? */
/* Mark that PHI as non-redundant. */
/* Retry. */
/* Pass #5: emit PHI instructions or eliminate PHIs. */
/* Emit PHI if not marked. */
/* Otherwise eliminate PHI. */
/* -- Loop unrolling using copy-substitution ------------------------------ */
/* Copy-substitute snapshot. */
/* Guard inbetween? */
/* Add new snapshot. */
/* Otherwise overwrite previous snapshot. */
/* Setup new snapshot. */
/* Substitute snapshot slots. */
/* Copy slot from loop map. */
/* Copy substituted slot from snapshot map. */
/* Shadowed loop slot. */
/* Copy remaining loop slots. */
/* Copy PC + frame links. */
/* Unroll loop. */
/* Use temp buffer for substitution table.
/* LOOP separates the pre-roll from the loop body. */
/* Grow snapshot buffer and map for copy-substituted snapshots.
/* The loop snapshot is used for fallback substitutions. */
/* The PC of snapshot #0 and the loop snapshot must match. */
/* Replace PC with temporary sentinel. */
/* Start substitution with snapshot #1 (#0 is empty for root traces). */
/* Copy and substitute all recorded instructions and snapshots. */
/* Instruction belongs to next snapshot? */
/* Copy-substitute it. */
/* Substitute instruction operands. */
/* Regular invariant ins? */
/* Shortcut. */
/* Re-emit substituted instruction to the FOLD/CSE/etc. pipeline. */
/* Get this first, since emitir may invalidate ir. */
/* Loop-carried dependency? */
/* Potential PHI? */
/* Check all loop-carried dependencies for type instability. */
/* Fix int->num. */
/* Fix num->int. */
/* May need an extra PHI for a CONV. */
/* Drop redundant snapshot. */
/* Restore PC. */
/* Undo any partial changes made by the loop optimization. */
/* Restore PC. */
/* Remove backprop. cache entries. */
/* Remove flags. */
/* Protected callback for loop optimization. */
/* Loop optimization. */
/* Trace error? */
/* Type instability. */
/* Guard would always fail. */
/* Unrolling via recording fixes many cases, e.g. a flipped boolean. */
/* But do not unroll forever. */
/* Remove error object. */
/* Loop optimization failed, continue recording. */
/* Propagate all other errors. */
/* Loop optimization is ok. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_opt_mem.c
/*
/* Some local macros to save typing. Undef'd at the end. */
/*
/* Return values from alias analysis. */
/* The two refs CANNOT alias (exact). */
/* The two refs MAY alias (inexact). */
/* The two refs MUST alias (exact). */
/* -- ALOAD/HLOAD forwarding and ASTORE/HSTORE elimination ---------------- */
/* Simplified escape analysis: check for intervening stores. */
/* The ref that might be stored. */
/* Reference was stored and might alias. */
/* Reference was not stored. */
/* Alias analysis for two different table references. */
/* Disambiguate new allocations. */
/* Two different allocations never alias. */
/* At least one allocation? */
/* Anything else: we just don't know. */
/* Alias analysis for array and hash access using key-based disambiguation. */
/* Shortcut for same refs. */
/* Same key. Check for same table with different ref (NEWREF vs. HREF). */
/* Same key, same table. */
/* Same key, possibly different table. */
/* Different constant keys. */
/* Disambiguate array references based on index arithmetic. */
/* Gather base and offset from t[base] or t[base+-ofs]. */
/* t[base+-ofs] vs. t[base]. */
/* t[base] vs. t[base+-ofs]. */
/* t[base+-o1] vs. t[base+-o2] and o1 != o2. */
/* Disambiguate hash references based on the type of their keys. */
/* Different key types. */
/* Same table, cannot disambiguate keys. */
/* Try to disambiguate tables. */
/* Array and hash load forwarding. */
/* Search limit. */
/* Search for conflicting stores. */
/* Continue searching. */
/* Limit search for load. */
/* Store forwarding. */
/* No conflicting store (yet): const-fold loads from allocations. */
/* A NEWREF with a number key may end up pointing to the array part.
/* NEWREF inhibits CSE for HREF, and dependent FLOADs from HREFK/AREF.
/* Continue searching. */
/* Conflicting store. */
/* Store forwarding. */
/* Othwerwise: don't intern as a constant. */
/* Try to find a matching load. Below the conflicting store, if any. */
/* Load forwarding. */
/* Conflict or no match. */
/* Reassociate ALOAD across PHIs to handle t[i-1] forwarding case. */
/* ALOAD forwarding. */
/* HLOAD forwarding. */
/* HREFK forwarding. */
/* Forward from NEWREF. */
/* No conflicting NEWREF: key location unchanged for HREFK of TDUP. */
/* Drop HREFK guard. */
/* Check whether HREF of TNEW/TDUP can be folded to niltv. */
/* Search limit. */
/* The key for an ASTORE may end up in the hash part after a NEWREF. */
/* Conflict. */
/* Search for conflicting stores. */
/* Conflict. */
/* No conflict. Can fold to niltv. */
/* Check whether there's no aliasing NEWREF for the left operand. */
/* Conflict. */
/* No conflict. Can safely FOLD/CSE. */
/* ASTORE/HSTORE elimination. */
/* xREF reference. */
/* Stored value reference. */
/* Search for redundant or conflicting stores. */
/* Continue searching. */
/* Store to MAYBE the same location. */
/* Conflict if the value is different. */
/* Otherwise continue searching. */
/* Store to the same location. */
/* Same value: drop the new store. */
/* Different value: try to eliminate the redundant store. */
/* Quick check to avoid crossing LOOP. */
/* Check for any intervening guards (includes conflicting loads). */
/* No elimination possible. */
/* Remove redundant store from chain and replace with NOP. */
/* Now emit the new store instead. */
/* Otherwise we have a conflict or simply no match. */
/* -- ULOAD forwarding ---------------------------------------------------- */
/* The current alias analysis for upvalues is very simplistic. It only
/* Different UREFx type. */
/* Same function. */
/* Same function, same upvalue idx. */
/* Same function, different upvalue idx. */
/* Different functions, check disambiguation hash values. */
/* Upvalues with different hash values cannot alias. */
/* No conclusion can be drawn for same hash value. */
/* ULOAD forwarding. */
/* Search limit. */
/* Search for conflicting stores. */
/* Continue searching. */
/* Limit search for load. */
/* Store forwarding. */
/* Try to find a matching load. Below the conflicting store, if any. */
/* Match for identical or equal UREFx (non-CSEable UREFO). */
/* USTORE elimination. */
/* xREF reference. */
/* Stored value reference. */
/* Search for redundant or conflicting stores. */
/* Continue searching. */
/* Store to MAYBE the same location. */
/* Conflict if the value is different. */
/* Otherwise continue searching. */
/* Store to the same location. */
/* Same value: drop the new store. */
/* Different value: try to eliminate the redundant store. */
/* Quick check to avoid crossing LOOP. */
/* Check for any intervening guards (includes conflicting loads). */
/* No elimination possible. */
/* Remove redundant store from chain and replace with NOP. */
/* Remove OBAR, too. */
/* Now emit the new store instead. */
/* Otherwise we have a conflict or simply no match. */
/* -- FLOAD forwarding and FSTORE elimination ----------------------------- */
/* Alias analysis for field access.
/* Different fields. */
/* Same field, same object. */
/* Disambiguate tables. */
/* Same field, possibly different object. */
/* Only the loads for mutable fields end up here (see FOLD). */
/* Object reference. */
/* Field ID. */
/* Search limit. */
/* Search for conflicting stores. */
/* Continue searching. */
/* Limit search for load. */
/* Store forwarding. */
/* No conflicting store: const-fold field loads from allocations. */
/* Try to find a matching load. Below the conflicting store, if any. */
/* FSTORE elimination. */
/* FREF reference. */
/* Stored value reference. */
/* Search for redundant or conflicting stores. */
/* Continue searching. */
/* Conflict if the value is different. */
/* Otherwise continue searching. */
/* Same value: drop the new store. */
/* Different value: try to eliminate the redundant store. */
/* Quick check to avoid crossing LOOP. */
/* Check for any intervening guards or conflicting loads. */
/* No elimination possible. */
/* Remove redundant store from chain and replace with NOP. */
/* Now emit the new store instead. */
/* Otherwise we have a conflict or simply no match. */
/* -- XLOAD forwarding and XSTORE elimination ----------------------------- */
/* Find cdata allocation for a reference (if any). */
/* Left-recursion. */
/* Flatten right-recursion. */
/* Alias analysis for two cdata allocations. */
/* Same allocation or neither is an allocation. */
/* Two different allocations never alias. */
/* Alias analysis for XLOAD/XSTORE. */
/* Shortcut for same refs with identical type. */
/* Offset-based disambiguation. */
/* Treat constified pointers like base vs. base+offset. */
/* This implements (very) strict aliasing rules.
/* Same-sized, same-kind. May need to convert. */
/* Non-overlapping base+-o1 vs. base+-o2. */
/* NYI: extract, extend or reinterpret bits (int <-> fp). */
/* Overlapping or type punning: force reload. */
/* NYI: structural disambiguation. */
/* Try to disambiguate allocations. */
/* Return CSEd reference or 0. Caveat: swaps lower ref to the right! */
/* Reassociate index references. */
/* Get constant offset. */
/* Add of base + index. */
/* Index ref > base ref for loop-carried dependences. Only check op1. */
/* Determine index shifts. Don't bother with IR_MUL here. */
/* A non-reassociated add. Must be a loop-carried dependence. */
/* Try to CSE the reassociated chain. Give up if not found. */
/* Success, found a reassociated index reference. Phew. */
/* Failure. */
/* XLOAD forwarding. */
/* Search limit. */
/* Search for conflicting stores. */
/* Continue searching. */
/* Limit search for load. */
/* Emit conversion if the loaded type doesn't match the forwarded type. */
/* Trunc + sign-extend. */
/* Trunc + zero-extend. */
/* Store forwarding. */
/* Try to find a matching load. Below the conflicting store, if any. */
/* CSE for XLOAD depends on the type, but not on the IRXLOAD_* flags. */
/* Reassociate XLOAD across PHIs to handle a[i-1] forwarding case. */
/* Skip stores that have already been checked. */
/* Retry with the reassociated reference. */
/* XSTORE elimination. */
/* Search limit. */
/* Stored value reference. */
/* Search for redundant or conflicting stores. */
/* Continue searching. */
/* Conflict if the value is different. */
/* Otherwise continue searching. */
/* Same value: drop the new store. */
/* Different value: try to eliminate the redundant store. */
/* Quick check to avoid crossing LOOP. */
/* Check for any intervening guards or any XLOADs (no AA performed). */
/* No elimination possible. */
/* Remove redundant store from chain and replace with NOP. */
/* Now emit the new store instead. */
/* Otherwise we have a conflict or simply no match. */
/* -- Forwarding of lj_tab_len -------------------------------------------- */
/* This is rather simplistic right now, but better than nothing. */
/* Table reference. */
/* Search limit. */
/* Any ASTORE is a conflict and limits the search. */
/* Search for conflicting HSTORE with numeric key. */
/* Conflicting store found, limits search for TLEN. */
/* Try to find a matching load. Below the conflicting store, if any. */
/* -- ASTORE/HSTORE previous type analysis -------------------------------- */
/* Check whether the previous value for a table store is non-nil.
/* First check stores. */
/* Same xREF. */
/* A nil store MAY alias, but a non-nil store MUST alias. */
/* Must check any nil store. */
/* Same key type MAY alias. Need ALOAD check due to multiple int types. */
/* A nil store with same const key or var key MAY alias. */
/* Different const keys CANNOT alias. */
/* Different key types CANNOT alias. */
/* Other non-nil stores MAY alias. */
/* Check loads since nothing could be derived from stores. */
/* Same xREF. */
/* A nil load MAY alias, but a non-nil load MUST alias. */
/* Other non-nil loads MAY alias. */
/* Nothing derived at all, previous value MAY be nil. */
/* ------------------------------------------------------------------------ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_opt_narrow.c
/*
/* Rationale for narrowing optimizations:
/* Some local macros to save typing. Undef'd at the end. */
/* Pass IR on to next optimization in chain (FOLD). */
/* -- Elimination of narrowing type conversions --------------------------- */
/* Narrowing of index expressions and bit operations is demand-driven. The
/* Maximum backpropagation depth and maximum stack size. */
/* The stack machine has a 32 bit instruction format: [IROpT | IRRef1]
/* Push ref. */
/* Push conversion of ref. */
/* Push sign-extension of ref. */
/* Push KINT ref. The next code holds an int32_t. */
/* Context used for narrowing of type conversions. */
/* JIT compiler state. */
/* Current stack pointer. */
/* Maximum stack pointer minus redzone. */
/* Conversion mode (IRCONV_*). */
/* Destination type: IRT_INT or IRT_I64. */
/* Stack holding stack-machine code. */
/* Lookup a reference in the backpropagation cache. */
/* Stronger checks are ok, too. */
/* Add an entry to the backpropagation cache. */
/* Backpropagate overflow stripping. */
/* Path too deep, need to backtrack. */
/* Backpropagate narrowing conversion. Return number of needed conversions. */
/* Path too deep. */
/* Check the easy cases first. */
/* Undo conversion. */
/* Sign-extend integer. */
/* Narrow FP constant. */
/* Allows a wider range of constants. */
/* Only if const doesn't lose precision. */
/* But always truncate to 32 bits. */
/* Only if constant is a small integer. */
/* Never narrow other FP constants (this is rare). */
/* Try to CSE the conversion. Stronger checks are ok, too. */
/* Already there, no additional conversion needed. */
/* Backpropagate across ADD/SUB. */
/* Try cache lookup first. */
/* Inner conversions need a stronger check. */
/* Try sign-extending from an existing (checked) conversion to int. */
/* Limit total number of conversions. */
/* Too many conversions, need to backtrack. */
/* Otherwise add a conversion. */
/* Emit the conversions collected during backpropagation. */
/* The fins fields must be saved now -- emitir() overwrites them. */
/* List of instructions from backpropagation. */
/* Recycle the stack to store operands. */
/* Simple stack machine to process the ins. list. */
/* Raw emit avoids a loop. */
/* Regular IROpT. Pops two operands and pushes one result. */
/* Omit some overflow checks for array indexing. See comments above. */
/* Otherwise cache a stronger check. */
/* Add to cache. */
/* Narrow a type conversion of an arithmetic operation. */
/* Used only in the backpropagation cache. */
/* -- Narrowing of implicit conversions ----------------------------------- */
/* Recursively strip overflow checks. */
/* The IR may be reallocated. */
/* Narrow array index. */
/* Conversion may be narrowed, too. See above. */
/* Omit some overflow checks for array indexing. See comments above. */
/* Narrow conversion to integer operand (overflow undefined). */
/* Conversion may be narrowed, too. See above. */
/*
/* Narrow conversion to bitop operand (overflow wrapped). */
/* Conversion may be narrowed, too. See above. */
/*
/* Narrow C array index (overflow undefined). */
/* Undefined overflow semantics allow stripping of ADDOV, SUBOV and MULOV. */
/* -- Narrowing of arithmetic operators ----------------------------------- */
/* Check whether a number fits into an int32_t (-0 is ok, too). */
/* Convert string to number. Error out for non-numeric string values. */
/* Would need an inverted STRTO for this rare and useless case. */
/* Convert in-place. Value used below. */
/* Punt if non-numeric. */
/* Narrowing of arithmetic operations. */
/* Must not narrow MUL in non-DUALNUM variant, because it loses -0. */
/* Narrowing of unary minus operator. */
/* Narrowing of modulo operator. */
/* b % c ==> b - floor(b/c)*c */
/* Narrowing of power operator or math.pow. */
/* Left arg is always treated as an FP number. */
/* Narrowing must be unconditional to preserve (-x)^i semantics. */
/* Split pow is faster for bigger exponents. But do this only for (+k)^i. */
/* Guarded conversion to integer! */
/* Range guard: -65536 <= i <= 65536 */
/* FOLD covers most cases, but some are easier to do here. */
/* 1 ^ x ==> 1 */
/* x ^ 0.5 ==> sqrt(x) */
/* Split up b^c into exp2(c*log2(b)). Assembler may rejoin later. */
/* -- Predictive narrowing of induction variables ------------------------- */
/* Narrow a single runtime value. */
/* Narrow the FORL index type by looking at the runtime values. */
/* Narrow only if the runtime values of start/stop/step are all integers. */
/* And if the loop index can't possibly overflow. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_opt_sink.c
/*
/* Some local macros to save typing. Undef'd at the end. */
/* Check whether the store ref points to an eligible allocation. */
/* Non-constant key. */
/* Unhandled reference type (for XSTORE). */
/* Not an allocation. */
/* Return allocation. */
/* Recursively check whether a value depends on a PHI. */
/* Check whether a value is a sinkable PHI or loop-invariant. */
/* Sinkable PHI. */
/* Otherwise the value must be loop-invariant. */
/* Constant (non-PHI). */
/* Mark non-sinkable allocations using single-pass backward propagation.
/* Finished. */
/* IRCALL_lj_tab_len */
/* Mark ref for remaining loads. */
/* Mark table for remaining loads. */
/* Mark ineligible ref. */
/* Mark stored value. */
/* Mark ineligible allocation. */
/* fallthrough */
/* Mark stored value. */
/* Mark (potentially) stored values. */
/* Clear PHI value counts. */
/* Propagate mark. */
/* Mark all instructions referenced by a snapshot. */
/* Iteratively remark PHI refs with differing marks or PHI value counts. */
/* Sweep instructions and tag sunken allocations and stores. */
/* Signal present SINK tags to assembler. */
/* Allocation sinking and store sinking.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_opt_split.c
/*
/* SPLIT pass:
/* Some local macros to save typing. Undef'd at the end. */
/* Directly emit the transformed IR without updating chains etc. */
/* Emit a (checked) number to integer conversion. */
/* Emit a CALLN with one split 64 bit argument. */
/* Emit a CALLN with one split 64 bit argument and a 32 bit argument. */
/* Emit a CALLN with two split 64 bit arguments. */
/* Get a pointer to the other 32 bit word (LE: hiword, BE: loword). */
/* Reassociate address. */
/* Substitute references of a snapshot. */
/* Transform the old IR to the new IR. */
/* Copy old IR to buffer. */
/* Bias hiword substitution table and old IR. Loword kept in field prev. */
/* Remove all IR instructions, but retain IR constants. */
/* Process constants and fixed references. */
/* Split up 64 bit constant. */
/* Identity substitution for loword. */
/* Process old IR instructions. */
/* Copy-substitute old instruction to new instruction. */
/* Loword substitution. */
/* Split 64 bit instructions. */
/* Turn into INT op. */
/* Note: hi ref = lo ref + 1! Required for SNAP_SOFTFPNUM logic. */
/* Try to rejoin pow from EXP2, MUL and LOG2. */
/* Recycle first two args from LOG2. */
/* Pass through loword. */
/* Convert from int to number. */
/* fallthrough */
/* Save/undo the emit of the lo XLOAD. */
/* Insert the hiref ADD. */
/* Re-emit lo XLOAD immediately before hi XLOAD. */
/* Conversion to number. Others handled below. */
/* Drop useless PHIs. */
/* Drop joining HIOP. */
/* Turn into INT op. */
/* Use plain op for hiword if loword cannot produce a carry/borrow. */
/* Pass through loword. */
/* fallthrough */
/* Conversion to 64 bit integer. Others handled below. */
/* NUM to 64 bit int conv. */
/* FLOAT to 64 bit int conv. */
/* FP to 64 bit int conv. */
/* 64/64 bit cast. */
/* Drop cast, since assembler doesn't care. But fwd both parts. */
/* Sign-extend to 64 bit. */
/* May have been reallocated. */
/* Pass through loword. */
/* hi = bsar(lo, 31). */
/* Zero-extend to 64 bit. */
/* Drop useless PHIs. */
/* Drop joining HIOP. */
/* Comparisons. */
/* Convert from number to int. */
/* Drop guard. */
/* See above, too. */
/* Conversion from 64 bit int. */
/* Drop unused HIOP. */
/* 64 bit integer to FP conversion. */
/* Truncate to lower 32 bits. */
/* Forward loword. */
/* Replace with NOP to avoid messing up the snapshot logic. */
/* Drop unused HIOP. */
/* Drop unused HIOP. */
/* Align 64 bit arguments. */
/* Needed by assembler. */
/* Store hiword substitution. */
/* Substitution for last snapshot. */
/* Add PHI marks. */
/* Protected callback for split pass. */
/* Slow, but sure way to check whether a SPLIT pass is needed. */
/* Nope. */
/* SPLIT pass. */
/* Verify flag. */
/* Completely reset the trace to avoid inconsistent dump on abort. */
/* Propagate errors. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_parse.c
/*
/* -- Parser structures and definitions ----------------------------------- */
/* Expression kinds. */
/* Constant expressions must be first and in this order: */
/* sval = string value */
/* nval = number value */
/* nval = cdata value, not treated as a constant expression */
/* Non-constant expressions follow: */
/* info = local register, aux = vstack index */
/* info = upvalue index, aux = vstack index */
/* sval = string value */
/* info = table register, aux = index reg/byte/string const */
/* info = instruction PC */
/* info = instruction PC */
/* info = result register */
/* info = instruction PC, aux = base */
/* Expression descriptor. */
/* Primary info. */
/* Secondary info. */
/* Number value. */
/* String value. */
/* True condition jump list. */
/* False condition jump list. */
/* Macros for expressions. */
/* Initialize expression. */
/* Check number constant for +-0. */
/* Per-function linked list of scope blocks. */
/* Link to outer scope. */
/* Start of block-local variables. */
/* Number of active vars outside the scope. */
/* Scope flags. */
/* Scope is a (breakable) loop. */
/* Break used in scope. */
/* Goto or label used in scope. */
/* Upvalue in scope. */
/* Do not close upvalues. */
/* Index into variable stack. */
/* Variable/goto/label info. */
/* R/W variable. */
/* Pending goto. */
/* Label. */
/* Per-function state. */
/* Hash table for constants. */
/* Lexer state. */
/* Lua state. */
/* Current scope. */
/* Enclosing function. */
/* Next bytecode position. */
/* Bytecode position of last jump target. */
/* Pending jump list to next bytecode. */
/* First free register. */
/* Number of active local variables. */
/* Number of lua_Number/GCobj constants */
/* First line of the function definition. */
/* Base of bytecode stack. */
/* Limit of bytecode stack. */
/* Base of variable stack for this function. */
/* Prototype flags. */
/* Number of parameters. */
/* Fixed frame size. */
/* Number of upvalues */
/* Map from register to variable idx. */
/* Map from upvalue to variable idx. */
/* Temporary upvalue map. */
/* Binary and unary operators. ORDER OPR */
/* ORDER ARITH */
/* -- Error handling ------------------------------------------------------ */
/* -- Management of constants --------------------------------------------- */
/* Return bytecode encoding for primitive constant. */
/* Add a number constant. */
/* Add a GC object constant. */
/* NOBARRIER: the key is new or kept alive. */
/* Add a string constant. */
/* Anchor string constant to avoid GC. */
/* NOBARRIER: the key is new or kept alive. */
/* Anchor cdata to avoid GC. */
/* NOBARRIER: the key is new or kept alive. */
/* -- Jump list handling -------------------------------------------------- */
/* Get next element in jump list. */
/* Check if any of the instructions on the jump list produce no value. */
/* Patch register of test instructions. */
/* Nothing to store or already in the right register. */
/* Cannot patch other instructions. */
/* Drop values for all instructions on jump list. */
/* Patch jump instruction to target. */
/* Append to jump list. */
/* Find last element. */
/* Patch jump list and preserve produced values. */
/* Jump to target with value. */
/* Jump to default target. */
/* Jump to following instruction. Append to list of pending jumps. */
/* Patch jump list to target. */
/* -- Bytecode register allocator ----------------------------------------- */
/* Bump frame size. */
/* Reserve registers. */
/* Free register. */
/* Free register for expression. */
/* -- Bytecode emitter ---------------------------------------------------- */
/* Emit bytecode instruction. */
/* -- Bytecode emitter for expressions ------------------------------------ */
/* Discharge non-constant expression to any register. */
/* Emit bytecode to set a range of registers to nil. */
/* No jumps to current position? */
/* Try to merge with the previous instruction. */
/* Replace KPRI. */
/* Can we connect both ranges? */
/* Patch previous instruction range. */
/* Emit new instruction or replace old instruction. */
/* Discharge an expression to a specific register. Ignore branches. */
/* Forward declaration. */
/* Discharge an expression to a specific register. */
/* Add it to the true jump list. */
/* Discharge expression with branches. */
/* Discharge an expression to the next free register. */
/* Discharge an expression to any register. */
/* Already in a register. */
/* Discharge to temp. register. */
/* Discharge to next register. */
/* Partially discharge expression to a value. */
/* Emit store for LHS expression. */
/* Free late alloced key reg to avoid assert on free of value reg. */
/* This can only happen when called from expr_table(). */
/* Emit method lookup expression. */
/* Copy object to first argument. */
/* -- Bytecode emitter for branches --------------------------------------- */
/* Emit unconditional branch. */
/* Invert branch condition of bytecode instruction. */
/* Emit conditional branch. */
/* Emit branch on true condition. */
/* Never jump. */
/* Emit branch on false condition. */
/* Never jump. */
/* -- Bytecode emitter for operators -------------------------------------- */
/* Try constant-folding of arithmetic operators. */
/* Avoid NaN and -0 as consts. */
/* Emit arithmetic operator. */
/* Must discharge 2nd operand first since VINDEXED might free regs. */
/* 1st operand discharged by bcemit_binop_left, but need KNUM/KSHORT. */
/* Avoid two consts to satisfy bytecode constraints. */
/* Using expr_free might cause asserts if the order is wrong. */
/* Emit comparison operator. */
/* Need constant in 2nd arg. */
/* First arg must be in a reg. */
/* GT -> LT, GE -> LE */
/* Swap operands. */
/* Using expr_free might cause asserts if the order is wrong. */
/* Fixup left side of binary operator. */
/* Emit binary operator. */
/* List must be closed. */
/* List must be closed. */
/* Emit unary operator. */
/* Swap true and false lists. */
/* Constant-fold negations. */
/* Fold in-place since cdata is not interned. */
/* Avoid folding to -0. */
/* -- Lexer support ------------------------------------------------------- */
/* Check and consume optional token. */
/* Check and consume token. */
/* Check for matching token. */
/* Check for string token. */
/* -- Variable handling --------------------------------------------------- */
/* Define a new local variable. */
/* NOBARRIER: name is anchored in fs->kt and ls->vstack is not a GCobj. */
/* Add local variables. */
/* Remove local variables. */
/* Lookup local variable name. */
/* Not found. */
/* Lookup or add upvalue index. */
/* Already exists. */
/* Otherwise create a new one. */
/* Forward declaration. */
/* Recursively lookup variables in enclosing functions. */
/* Local in this function? */
/* Scope now has an upvalue. */
/* Var in outer func? */
/* Yes, make it an upvalue here. */
/* Not found in any function, must be a global. */
/* Global. */
/* Lookup variable name. */
/* -- Goto an label handling ---------------------------------------------- */
/* Add a new goto or label. */
/* NOBARRIER: name is anchored in fs->kt and ls->vstack is not a GCobj. */
/* Patch goto to jump to label. */
/* Invalidate pending goto. */
/* Patch goto to close upvalues. */
/* Jump to UCLO. */
/* Turn into UCLO. */
/* Resolve pending forward gotos for label. */
/* Fixup remaining gotos and labels for scope. */
/* Only consider remaining valid gotos/labels. */
/* Invalidate label that goes out of scope. */
/* Resolve pending backward gotos. */
/* Propagate goto or break to outer scope. */
/* No outer scope: undefined goto label or no loop. */
/* Find existing label. */
/* -- Scope handling ------------------------------------------------------ */
/* Begin a scope. */
/* End a scope. */
/* Drop break label immediately. */
/* Need the fixup step to propagate the breaks. */
/* Mark scope as having an upvalue. */
/* -- Function state management ------------------------------------------- */
/* Fixup bytecode for prototype. */
/* Fixup upvalues for child prototype, step #2. */
/* Fixup constants for prototype. */
/* Fixup upvalues for prototype, step #1. */
/* Prepare lineinfo for prototype. */
/* Fixup lineinfo for prototype. */
/* Resize buffer if needed. */
/* Add string to buffer. */
/* Add ULEB128 value to buffer. */
/* Prepare variable info for prototype. */
/* Copy to temp. string buffer. */
/* Store upvalue names. */
/* Store local variable names and compressed ranges. */
/* Terminator for varinfo. */
/* Fixup variable info for prototype. */
/* Copy from temp. string buffer. */
/* Initialize with empty debug info, if disabled. */
/* Check if bytecode op returns. */
/* Fixup return instruction for prototype. */
/* Need final return. */
/* Handled above. */
/* May need to fixup returns encoded before first function was created. */
/* Copy original instruction. */
/* Replace with UCLO plus branch. */
/* We're done. */
/* Finish a FuncState and return the new prototype. */
/* Apply final fixups. */
/* Calculate total size of prototype including all colocated arrays. */
/* Allocate prototype and initialize its fields. */
/* Close potentially uninitialized gap between bc and kgc. */
/* Pop table of constants. */
/* Reset variable stack. */
/* Initialize a new FuncState. */
/* Append to list. */
/* Minimum frame size. */
/* Anchor table of constants in stack to avoid being collected. */
/* -- Expressions --------------------------------------------------------- */
/* Forward declaration. */
/* Return string expression. */
/* Return index expression. */
/* Already called: expr_toval(fs, e). */
/* 256..511: const byte key */
/* 256..511: const byte key */
/* -256..-1: const string key */
/* 0..255: register */
/* Parse index expression with named field. */
/* Skip dot or colon. */
/* Parse index expression with brackets. */
/* Skip '['. */
/* Get value of constant expression. */
/* Parse table constructor expression. */
/* First array index. */
/* Number of hash entries. */
/* Already calls expr_toval. */
/* Create template table on demand. */
/* Add const key/value to template table. */
/* Otherwise create dummy string key (avoids lj_tab_newkey). */
/* Preserve key with table itself as value. */
/* Fix this later, after all resizes. */
/* Biased integer to avoid denormals. */
/* Make expr relocable if possible. */
/* May have been changed by expr_index. */
/* Construct TNEW RD: hhhhhaaaaaaaaaaa. */
/* Fix value for dummy keys in template table. */
/* Turn value into nil. */
/* Parse function parameters. */
/* Forward declaration. */
/* Parse body of a function. */
/* Placeholder. */
/* May have been reallocated. */
/* Store new prototype in the constant array of the parent. */
/* Parse expression list. Last expression is left open. */
/* Parse function argument list. */
/* f(). */
/* f(a, b, g()) or f(a, b, ...). */
/* Pass on multiple results. */
/* Silence compiler. */
/* Base register for call. */
/* Leave one result by default. */
/* Parse primary expression. */
/* Parse prefix expression. */
/* Parse multiple expression suffixes. */
/* Parse simple expression. */
/* Vararg. */
/* Table constructor. */
/* Manage syntactic levels to avoid blowing up the stack. */
/* Convert token to binary operator. */
/* Priorities for each binary operator. ORDER OPR. */
/* Left priority. */
/* Right priority. */
/* ADD SUB MUL DIV MOD */
/* POW CONCAT (right associative) */
/* EQ NE */
/* LT GE GT LE */
/* AND OR */
/* Priority for unary operators. */
/* Forward declaration. */
/* Parse unary expression. */
/* Parse binary expressions with priority higher than the limit. */
/* Parse binary expression with higher priority. */
/* Return unconsumed binary operator (if any). */
/* Parse expression. */
/* Priority 0: parse whole expression. */
/* Assign expression to the next register. */
/* Parse conditional expression. */
/* -- Assignments --------------------------------------------------------- */
/* List of LHS variables. */
/* LHS variable. */
/* Link to previous LHS variable. */
/* Eliminate write-after-read hazards for local variable assignment. */
/* Check against this variable. */
/* Rename to this temp. register (if needed). */
/* t[i], t = 1, 2 */
/* t[i], i = 1, 2 */
/* Rename conflicting variable. */
/* Adjust LHS/RHS of an assignment. */
/* Compensate for the VCALL itself. */
/* Fixup call results. */
/* Close last expression. */
/* Leftover LHS are set to nil. */
/* Drop leftover regs. */
/* Recursively parse assignment statement. */
/* Collect LHS list and recurse upwards. */
/* Parse RHS. */
/* Vararg assignment. */
/* Multiple call results. */
/* Base of call is not relocatable. */
/* Assign RHS to LHS and recurse downwards. */
/* Parse call statement or assignment. */
/* Function call statement. */
/* No results. */
/* Start of an assignment. */
/* Parse 'local' statement. */
/* Local function declaration. */
/* bcemit_store(fs, &v, &b) without setting VSTACK_VAR_RW. */
/* The upvalue is in scope, but the local is only valid after the store. */
/* Local variable declaration. */
/* Collect LHS. */
/* Optional RHS. */
/* Or implicitly set to nil. */
/* Parse 'function' statement. */
/* Skip 'function'. */
/* Parse function name. */
/* Multiple dot-separated fields. */
/* Optional colon to signify method call. */
/* Set line for the store. */
/* -- Control transfer statements ----------------------------------------- */
/* Check for end of block. */
/* Parse 'return' statement. */
/* Skip 'return'. */
/* Bare return. */
/* Return with one or more values. */
/* Receives the _last_ expression in the list. */
/* Return one result. */
/* Check for tail call. */
/* It doesn't pay off to add BC_VARGT just for 'return ...'. */
/* Can return the result from any register. */
/* Append all results from a call. */
/* Force contiguous registers. */
/* May need to close upvalues first. */
/* Parse 'break' statement. */
/* Parse 'goto' statement. */
/* Treat backwards goto within same scope like a loop. */
/* No BC range check. */
/* Parse label. */
/* Skip '::'. */
/* Recursively parse trailing statements: labels and ';' (Lua 5.2 only). */
/* Trailing label is considered to be outside of scope. */
/* -- Blocks, loops and conditional statements ---------------------------- */
/* Parse a block. */
/* Parse 'while' statement. */
/* Skip 'while'. */
/* Parse 'repeat' statement. */
/* Breakable loop scope. */
/* Inner scope. */
/* Skip 'repeat'. */
/* Parse condition (still inside inner scope). */
/* No upvalues? Just end inner scope. */
/* Otherwise generate: cond: UCLO+JMP out, !cond: UCLO+JMP loop. */
/* Break from loop and close upvalues. */
/* End inner scope and close upvalues. */
/* Jump backwards if !cond. */
/* End loop scope. */
/* Parse numeric 'for'. */
/* Hidden control variables. */
/* Visible copy of index variable. */
/* Default step is 1. */
/* Hidden control variables. */
/* Scope for visible variables. */
/* Perform loop inversion. Loop control instructions are at the end. */
/* Fix line for control ins. */
/* Try to predict whether the iterator is next() and specialize the bytecode.
/* There's no inverse index (yet), so lookup the strings. */
/* Parse 'for' iterator. */
/* Hidden control variables. */
/* Visible variables returned from iterator. */
/* The iterator needs another 3 slots (func + 2 args). */
/* Hidden control variables. */
/* Scope for visible variables. */
/* Perform loop inversion. Loop control instructions are at the end. */
/* Fix line for control ins. */
/* Parse 'for' statement. */
/* Skip 'for'. */
/* Get first variable name. */
/* Resolve break list. */
/* Parse condition and 'then' block. */
/* Skip 'if' or 'elseif'. */
/* Parse 'if' statement. */
/* Parse multiple 'elseif' blocks. */
/* Parse optional 'else' block. */
/* Skip 'else'. */
/* -- Parse statements ---------------------------------------------------- */
/* Parse a statement. Returns 1 if it must be the last one in a chunk. */
/* Must be last. */
/* Must be last in Lua 5.1. */
/* else: fallthrough */
/* A chunk is a list of statements optionally separated by semicolons. */
/* Free registers after each stmt. */
/* Entry point of bytecode parser. */
/* Anchor chunkname string. */
/* Main chunk is always a vararg func. */
/* Placeholder. */
/* Read-ahead first token. */
/* Drop chunkname. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_record.c
/*
/* Some local macros to save typing. Undef'd at the end. */
/* Pass IR on to next optimization in chain (FOLD). */
/* Emit raw IR without passing through optimizations. */
/* -- Sanity checks ------------------------------------------------------- */
/* Sanity check the whole IR -- sloooow. */
/* Compare stack slots and frames of the recorder and the VM. */
/* Could be IRT_INT etc., too. */
/* Compare constants. */
/* -- Type handling and specialization ------------------------------------ */
/* Note: these functions return tagged references (TRef). */
/* Specialize a slot to a specific type. Note: slot can be negative! */
/* Caller may set IRT_GUARD in t. */
/* Specialize a slot to the runtime type. Note: slot can be negative! */
/* Canonicalize primitive refs. */
/* Get TRef from slot. Load slot and specialize if not done already. */
/* Get TRef for current function. */
/* Compare for raw object equality.
/* Shortcut, also handles primitives. */
/* Widen mixed number/int comparisons to number/number comparison. */
/* Two different types are never equal. */
/* Constify a value. Returns 0 for non-representable object types. */
/* Can't represent lightuserdata (pointless). */
/* -- Record loop ops ----------------------------------------------------- */
/* Loop event. */
/* Loop is left or not entered. */
/* Loop is entered with a low iteration count left. */
/* Loop is entered. */
/* Canonicalize slots: convert integers to numbers. */
/* Stop recording. */
/* Looping back at the same stack level? */
/* Shall we try to create a loop? */
/* Do not canonicalize or we lose the narrowing. */
/* Otherwise ensure we always link to the root trace. */
/* Note: all loop ops must set J->pc to the following instruction! */
/* Add loop snapshot. */
/* In case recording continues. */
/* Search bytecode backwards for a int/num constant slot initializer. */
/* This algorithm is rather simplistic and assumes quite a bit about
/* First try to find the last instruction that stores to this slot. */
/* Multiple results, e.g. from a CALL or KNIL. */
/* Found const. initializer. */
/* Now try to verify there's no forward jump across it. */
/* Conditional assignment. */
/* -0 is ok here. */
/* Type mismatch. */
/* Non-constant initializer. */
/* No assignment to this slot found? */
/* Load and optionally convert a FORI argument from a slot. */
/* Peek before FORI to find a const initializer. Otherwise load from slot. */
/* Return the direction of the FOR loop iterator.
/* Simulate the runtime behavior of the FOR loop iterator. */
/* Record checks for FOR loop overflow and step direction. */
/* Non-constant step: need a guard for the direction. */
/* Add hoistable overflow checks for a narrowed FORL index. */
/* Constant stop: optimize check away or to a range check for step. */
/* Stop+step variable: need full overflow check. */
/* ADDOV is weak. Avoid dead result. */
/* Constant step: optimize overflow check to a range check for stop. */
/* Record a FORL instruction. */
/* Record FORL/JFORL or FORI/JFORI. */
/* Handle FORL/JFORL opcodes. */
/* Handle FORI/JFORI opcodes. */
/* Record ITERL/JITERL. */
/* Looping back? */
/* Copy result of ITERC to control var. */
/* Record LOOP/JLOOP. Now, that was easy. */
/* Check if a loop repeatedly failed to trace because it didn't loop back. */
/* Handle the case when an interpreted loop op is hit. */
/* Same loop? */
/* Must loop back to form a root trace. */
/* Looping root trace. */
/* Entering inner loop? */
/* It's usually better to abort here and wait until the inner loop
/* Root trace hit an inner loop. */
/* Limit loop unrolling. */
/* Side trace enters an inner loop. */
/* Limit loop unrolling. */
/* Side trace continues across a loop that's left or not entered. */
/* Handle the case when an already compiled loop op is hit. */
/* Root trace hit an inner loop. */
/* Better let the inner loop spawn a side trace back here. */
/* Side trace enters a compiled loop. */
/* Cannot continue across a compiled loop op. */
/* Form an extra loop. */
/* Link to the loop. */
/* Side trace continues across a loop that's left or not entered. */
/* -- Record calls and returns -------------------------------------------- */
/* Specialize to the runtime value of the called function or its prototype. */
/* Too many closures created? Probably not a monomorphic function. */
/* Specialize to prototype instead. */
/* Prevent GC of proto. */
/* Otherwise specialize to the function (closure) value itself. */
/* Record call setup. */
/* Ensure func and all args have a reference. */
/* Resolve __call metamethod. */
/* Shift arguments up. */
/* Replace function. */
/* Record call. */
/* Bump frame. */
/* Record tail call. */
/* Move func + args down. */
/* Note: the new TREF_FRAME is now at J->base[-1] (even for slot #0). */
/* Tailcalls can form a loop, so count towards the loop unroll limit. */
/* Check unroll limits for down-recursion. */
/* Record return. */
/* Ensure all results have a reference. */
/* Immediately resolve pcall() returns. */
/* Prepend true to results. */
/* Return to lower frame via interpreter for unhandled cases. */
/* NYI: specialize to frame type and return directly, not via RET*. */
/* Purge dead slots. */
/* Return to interpreter. */
/* NYI: return of vararg func to lower frame. */
/* Return to Lua frame. */
/* Down-recursion. */
/* Adjust results. */
/* Return to a frame that is part of the trace. */
/* Return to lower frame would leave the loop in a root trace. */
/* Tailcalled to ff with side-effects. */
/* No way to insert snapshot here. */
/* Return to lower frame. Guard for the target we return to. */
/* Shift result slots up and clear the slots of the new frame below. */
/* Return to continuation frame. */
/* Copy result to destination slot. */
/* Nothing to do here. */
/* Result type already specialized. */
/* NYI: handle return to C frame. */
/* -- Metamethod handling ------------------------------------------------- */
/* Prepare to record call to metamethod. */
/* Clear frame gap to avoid resurrecting previous refs. */
/* Record metamethod lookup. */
/* The metatables of special userdata objects are treated as immutable. */
/* Specialize to the C library namespace object. */
/* Specialize to the type of userdata. */
/* No metamethod. */
/* Treat metamethod or index table as immutable, too. */
/* Dummy value for comparison semantics. */
/* Got metamethod or index table. */
/* Specialize to base metatable. Must flush mcode in lua_setmetatable(). */
/* No metamethod. */
/* The cdata metatable is treated as immutable. */
/* 1 if metamethod found, 0 if not. */
/* No metamethod. */
/* Record call to arithmetic metamethod. */
/* Set up metamethod call first to save ix->tab and ix->tabv. */
/* Lookup mm on 1st operand. */
/* Lookup mm on 2nd operand. */
/* No result yet. */
/* Record call to __len metamethod. */
/* No result yet. */
/* Call a comparison metamethod. */
/* Record call to equality comparison metamethod (for tab and udata only). */
/* Lookup mm on 1st operand. */
/* Avoid the 2nd lookup and the objcmp if the metatables are equal. */
/* Lookup metamethod on 2nd operand and compare both. */
/* Record call to ordered comparison metamethods (for arbitrary objects). */
/* Try __le + __lt or only __lt. */
/* Lookup mm on 1st operand. */
/* Lookup mm on 2nd operand. */
/* Lookup mm on 1st operand. */
/* Avoid the 2nd lookup and the objcmp if the metatables are equal. */
/* Lookup metamethod on 2nd operand and compare both. */
/* Lookup failed. Retry with  __lt and swapped operands. */
/* Already at __lt. Interpreter will throw. */
/* Setup call to cdata comparison metamethod. */
/* -- Indexed access ------------------------------------------------------ */
/* Record bounds-check. */
/* Try to emit invariant bounds checks. */
/* Handle constant offsets. */
/* Got scalar evolution analysis results for this reference? */
/* Runtime value for stop of loop is within bounds? */
/* Emit invariant bounds check for stop. */
/* Emit invariant bounds check for start, if not const or negative. */
/* Emit regular bounds check. */
/* Record indexed key lookup. */
/* Lookup previous value. */
/* Integer keys are looked up in the array part first. */
/* Potential array key? */
/* Currently an array key? */
/* Currently not in array (may be an array extension)? */
/* Inv. bounds check. */
/* Canonicalize 0 or +-0.0 to +0.0. */
/* And continue with the hash lookup. */
/* We can rule out const numbers which failed the integerness test
/* True sparse tables have an empty array part. */
/* Guard that the array part stays empty. */
/* Otherwise the key is located in the hash part. */
/* Shortcut for empty hash part. */
/* Guard that the hash part stays empty. */
/* Hash keys are based on numbers, not ints. */
/* Optimize lookup of constant hash keys. */
/* Fall back to a regular hash lookup. */
/* Determine whether a key is NOT one of the fast metamethod names. */
/* MUST be one the fast metamethod names. */
/* Variable string key MAY be a metamethod name. */
/* CANNOT be a metamethod name. */
/* Record indexed load/store. */
/* Handle non-table lookup. */
/* Never call raw lj_record_idx() on non-table. */
/* Handle metamethod call. */
/* mobj(tab, key, val) */
/* res = mobj(tab, key) */
/* No result yet. */
/* Otherwise retry lookup with metaobject. */
/* First catch nil and NaN keys for tables. */
/* Better fail early. */
/* Record the key lookup. */
/* The lj_meta_tset() inconsistency is gone, but better play safe. */
/* Indexed load */
/* Canonicalize primitives. */
/* Indexed store. */
/* Previous value was nil? */
/* Need to duplicate the hasmm check for the early guards. */
/* Guard for nil value. */
/* Need to insert a new key. */
/* NEWREF needs a TValue as a key. */
/* NEWREF already takes care of the key barrier. */
/* Cannot derive that the previous value was non-nil, must do checks. */
/* Guard against store to niltv. */
/* Metamethod lookup required? */
/* A check for NULL metatable is cheaper (hoistable) than a load. */
/* Guard for non-nil value. */
/* Previous non-nil value kept the key alive. */
/* Convert int to number before storing. */
/* Invalidate neg. metamethod cache for stores with certain string keys. */
/* -- Upvalue access ------------------------------------------------------ */
/* Check whether upvalue is immutable and ok to constify. */
/* Don't constify objects that may retain large amounts of memory. */
/* Record upvalue load/store. */
/* Try to constify immutable upvalue. */
/* Late specialization of current function. */
/* Note: this effectively limits LJ_MAX_UPVAL to 127. */
/* In current stack? */
/* Aliases an SSA slot? */
/* Note: slot number may be negative! */
/* Upvalue load */
/* Canonicalize primitive refs. */
/* Upvalue store. */
/* Convert int to number before storing. */
/* -- Record calls to Lua functions --------------------------------------- */
/* Check unroll limits for calls. */
/* Vararg frame still missing. */
/* Count frames with same prototype. */
/* Tail-recursion. */
/* Up-recursion. */
/* Possible tail- or up-recursion. */
/* Flush trace that only returns. */
/* Set a small, pseudo-random hotcount for a quick retry of JFUNC*. */
/* Record Lua function setup. */
/* Fill up missing parameters with nil. */
/* The remaining slots should never be read before they are written. */
/* Record Lua vararg function setup. */
/* Copy function up. */
/* Copy fixarg slots up and set their original slots to nil. */
/* Record entry to a Lua function. */
/* Record entry to an already compiled function. */
/* Trace returns to interpreter? */
/* Temporarily unpatch JFUNC* to continue recording across function. */
/* Cannot continue across a compiled function. */
/* Extra tail-recursion. */
/* Link to the function. */
/* -- Vararg handling ----------------------------------------------------- */
/* Detect y = select(x, ...) idiom. */
/* Record vararg instruction. */
/* Simple case: varargs defined on-trace. */
/* Unknown number of varargs passed to trace. */
/* Known fixed number of results. */
/* Canonicalize primitives. */
/* y = select(x, ...) */
/* Bias for 1-based index. */
/* Compute size. */
/* Canonicalize primitives. */
/* Skip CALLM + select. */
/* -- Record allocations -------------------------------------------------- */
/* -- Record bytecode ops ------------------------------------------------- */
/* Prepare for comparison. */
/* Prevent merging with snapshot #0 (GC exit) since we fixup the PC. */
/* Fixup comparison. */
/* Set PC to opposite target to avoid re-recording the comp. in side trace. */
/* Shrink last snapshot if possible. */
/* Record the next bytecode instruction (_before_ it's executed). */
/* Perform post-processing action before recording the next instruction. */
/* Fixup comparison. */
/* fallthrough */
/* Fixup and emit pending guard. */
/* Fixup and emit pending guard and snapshot. */
/* Flip guard to opposite. */
/* False -> true. */
/* Emit pending guard. */
/* fallthrough */
/* Fixup stack slot (if any). */
/* Constify stack slots (if any). */
/* Suppress recording of retried fast function. */
/* Need snapshot before recording next bytecode (e.g. after a store). */
/* Skip some bytecodes. */
/* Record only closed loops for root traces. */
/* Keep a copy of the runtime values of var/num/str operands. */
/* Handled later. */
/* Upgrade rc to 'rd'. */
/* Handled later. */
/* Handled later. */
/* -- Comparison ops ---------------------------------------------------- */
/* Emit nothing for two numeric or string consts. */
/* Widen mixed number/int comparisons to number/number comparison. */
/* Force metamethod for different types. */
/* Interpreter will throw for two different types. */
/* ISGE/ISGT are unordered. */
/* Emit nothing for two non-table, non-udata consts. */
/* Only check __eq if different, but same type. */
/* -- Unary test and copy ops ------------------------------------------- */
/* Don't store if condition is not true. */
/* fallthrough */
/* Type specialization suffices. */
/* Shrink used slots. */
/* -- Unary ops --------------------------------------------------------- */
/* Type specialization already forces const result. */
/* -- Arithmetic ops ---------------------------------------------------- */
/* Swap rb/rc and rbv/rcv. rav is temp. */
/* fallthrough */
/* -- Constant and move ops --------------------------------------------- */
/* Clear gap of method call to avoid resurrecting previous refs. */
/* -- Upvalue and function ops ------------------------------------------ */
/* -- Table ops --------------------------------------------------------- */
/* fallthrough */
/* -- Calls and vararg handling ----------------------------------------- */
/* Do the actual copy now because lj_record_call needs the values. */
/* L->top is set to L->base+ra+rc+NARGS-1+1. See lj_dispatch_ins(). */
/* fallthrough */
/* fallthrough */
/* -- Returns ----------------------------------------------------------- */
/* L->top is set to L->base+ra+rc+NRESULTS-1, see lj_dispatch_ins(). */
/* fallthrough */
/* -- Loops and branches ------------------------------------------------ */
/* Link to existing loop. */
/* Continue tracing if the loop is not entered. */
/* Shrink used slots. */
/* -- Function headers -------------------------------------------------- */
/* Cannot happen. No hotcall counting for varag funcs. */
/* fallthrough */
/* rc == 0 if we have no result yet, e.g. pending __index metamethod call. */
/* Limit the number of recorded IR instructions. */
/* -- Recording setup ----------------------------------------------------- */
/* Setup recording for a root trace started by a hot loop. */
/* Determine the next PC and the bytecode range for the loop. */
/* Only check BC range for real loops, but not for "repeat until true". */
/* No bytecode range check for down-recursive root traces. */
/* No bytecode range check for root traces started by a hot call. */
/* Setup for recording a new trace. */
/* Initialize state related to current trace. */
/* Invoking function is at base[-1]. */
/* Means no limit. */
/* Emit instructions for fixed references. Also triggers initial IR alloc. */
/* Side trace. */
/* Check whether we could at least potentially form an extra loop. */
/* We can narrow a FORL for some side traces, too. */
/* Prevent forming an extra loop. */
/* Root trace. */
/* Note: the loop instruction itself is recorded at the end and not
/* Regularly check for instruction/line hooks from compiled code and
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_snap.c
/*
/* Pass IR on to next optimization in chain (FOLD). */
/* Emit raw IR without passing through optimizations. */
/* -- Snapshot buffer allocation ------------------------------------------ */
/* Grow snapshot buffer. */
/* Grow snapshot map buffer. */
/* -- Snapshot generation ------------------------------------------------- */
/* Add all modified slots to the snapshot. */
/* Limits SLOAD restore elimination. */
/* No need to snapshot unmodified non-inherited slots. */
/* No need to restore readonly slots and unmodified non-parent slots. */
/* Add frame links at the end of the snapshot. */
/* The current PC is always the first entry. */
/* Backwards traversal of all frames above base. */
/* Take a snapshot of the current stack. */
/* Conservative estimate. */
/* Add or merge a snapshot. */
/* Merge if no ins. inbetween or if requested and no guard inbetween. */
/* But preserve snap #0 PC. */
/* -- Snapshot modification ----------------------------------------------- */
/* Find unused slots with reaching-definitions bytecode data-flow analysis. */
/* Avoid errors for harmless reads beyond maxslot. */
/* Treat open upvalues as used. */
/* Scan through following bytecode and check for uses/defs. */
/* NYI: will abort, anyway. */
/* unreachable */
/* Purge dead slots before the next snapshot. */
/* Purge dead slots. */
/* Shrink last snapshot. */
/* Remove unused slots from snapshot. */
/* Only copy used slots. */
/* Move PC + frame links down. */
/* Free up space in map. */
/* -- Snapshot access ----------------------------------------------------- */
/* Initialize a Bloom Filter with all renamed refs.
/* Process matching renames to find the original RegSP. */
/* Copy RegSP from parent snapshot to the parent links of the IR. */
/* -- Snapshot replay ----------------------------------------------------- */
/* Replay constant from parent trace. */
/* Only have to deal with constants that can occur in stack slots. */
/* Continuation. */
/* De-duplicate parent reference. */
/* Emit parent reference with de-duplication. */
/* Check whether a sunk store corresponds to an allocation. Slow path. */
/* Check whether a sunk store corresponds to an allocation. Fast path. */
/* Fast check. */
/* Replay snapshot state to setup side trace. */
/* Emit IR for slots inherited from parent snapshot. */
/* The bloom filter avoids O(nent^2) overhead for de-duping slots. */
/* Same as TREF_* flags. */
/* Emit dependent PVALs. */
/* Replay sunk instructions. */
/* De-dup allocs. */
/* Emit joining HIOP. */
/* Need explicit GC step _after_ initial snapshot. */
/* -- Snapshot restore ---------------------------------------------------- */
/* Restore a value from the trace exit state. */
/* Restore constant slot. */
/* Restore from spill slot. */
/* 64 bit lightuserdata which may escape already has the tag bits. */
/* PRI refs never have a spill slot. */
/* Restore from register. */
/* 64 bit lightuserdata which may escape already has the tag bits. */
/* Restore raw data from the trace exit state. */
/* Note: this assumes CNEWI is never used for SOFTFP split numbers. */
/* PPC FPRs are always doubles. */
/* Unsink allocation from the trace exit state. Unsink sunk stores. */
/* NOBARRIER: The table is new (marked white). */
/* NOBARRIER: The table is new (marked white). */
/* Restore interpreter state from exit state with the help of a snapshot. */
/* For now, snapno == exitno. */
/* Set interpreter PC to the next PC to get correct error messages. */
/* Make sure the stack is big enough for the slots from the snapshot. */
/* Fill stack slots with data from the registers and spill slots. */
/* Preserve link to previous frame in slot #0. */
/* De-duplicate sunk allocations. */
/* Overwrite tag with frame link. */
/* Compute current stack top. */
/* fallthrough */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_state.c
/*
/* -- Stack handling ------------------------------------------------------ */
/* Stack sizes. */
/* Min. stack size. */
/* Max. stack size. */
/* Starting stack size. */
/* Explanation of LJ_STACK_EXTRA:
/* Resize stack slots and adjust pointers in state. */
/* Clear new slots. */
/* Relimit stack after error, in case the limit was overdrawn. */
/* Try to shrink the stack (called from GC). */
/* Avoid stack shrinking while handling stack overflow. */
/* Don't shrink stack of live trace. */
/* Try to grow stack. */
/* Overflow while handling overflow? */
/* Allocate basic stack for new state. */
/* Needed for curr_funcisL() on empty stack. */
/* Clear new slots. */
/* -- State handling ------------------------------------------------------ */
/* Open parts that may cause memory-allocation errors. */
/* NOBARRIER: State initialization, all objects are white. */
/* Preallocate memory error msg. */
/* Prevent free. */
/* Avoid touching the stack upon memory error. */
/* Memory allocation error: free partial state. */
/* Frame pop omitted. */
/* Only the main thread can be closed. */
/* Separate udata which have GC metamethods. */
/* Separate udata again. */
/* Until nothing is left to do. */
/* NOBARRIER: The lua_State is new (marked white). */
/* init stack */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_str.c
/*
/* -- String interning ---------------------------------------------------- */
/* Ordered compare of strings. Assumes string data is 4-byte aligned. */
/* Note: innocuous access up to end of string + 3. */
/* Fast string data comparison. Caveat: unaligned access to 1st string! */
/* Note: innocuous access up to end of string + 3. */
/* Resize the string hash table (grow and shrink). */
/* No resizing during GC traversal or if already too big. */
/* Rehash old table. */
/* Follow each hash chain and reinsert all strings. */
/* NOBARRIER: The string table is a GC root. */
/* Intern a string and return string object. */
/* Compute string hash. Constants taken from lookup3 hash by Bob Jenkins. */
/* Caveat: unaligned access! */
/* Check if the string has already been interned. */
/* Resurrect if dead. Can only happen with fixstring() (keywords). */
/* Return existing string. */
/* Slow path: end of string is too close to a page boundary. */
/* Resurrect if dead. Can only happen with fixstring() (keywords). */
/* Return existing string. */
/* Nope, create a new string. */
/* Zero-terminate string. */
/* Add it to string hash table. */
/* NOBARRIER: The string table is a GC root. */
/* Allow a 100% load factor. */
/* Grow string table. */
/* Return newly interned string. */
/* -- Type conversions ---------------------------------------------------- */
/* Print number to buffer. Canonicalizes non-finite values. */
/* Finite? */
/* Print integer to buffer. Returns pointer to start. */
/* Convert number to string. */
/* Convert integer to string. */
/* -- String formatting --------------------------------------------------- */
/* Push formatted message as a string object to Lua stack. va_list variant. */
/* This function only handles %s, %c, %d, %f and %p formats. */
/* Shorten output for 64 bit pointers. */
/* Push formatted message as a string object to Lua stack. Vararg variant. */
/* -- Buffer handling ----------------------------------------------------- */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_strscan.c
/*
/* -- Scanning numbers ---------------------------------------------------- */
/*
/* Definitions for circular decimal digit buffer (base 100 = 2 digits/byte). */
/* 772 + extra are sufficient. */
/* Helpers for circular buffer. */
/* Final conversion to double. */
/* Avoid double rounding for denormals. */
/* NYI: all of this generates way too much code on 32 bit CPUs. */
/* Convert to double using a signed int64_t conversion, then rescale. */
/* Parse hexadecimal number. */
/* Scan hex digits. */
/* Summarize rounding-effect of excess digits. */
/* Format-specific handling. */
/* Fast path for 32 bit integers. */
/* fallthrough */
/* Reduce range then convert to double. */
/* Parse octal number. */
/* Scan octal digits. */
/* Format-specific handling. */
/* fallthrough */
/* Parse decimal number. */
/* Scan unaligned leading digit. */
/* Scan aligned double-digits. */
/* Scan and realign trailing digit. */
/* Summarize rounding-effect of excess digits. */
/* Simplify exponent. */
/* Only got zeros. */
/* Fast path for numbers in integer format (but handles e.g. 1e6, too). */
/* No overflow? */
/* Format-specific handling. */
/* Fast path for 32 bit integers. */
/* fallthrough */
/* Fast path for plain numbers < 2^63. */
/* Slow non-integer path. */
/* Handle simple overflow/underflow. */
/* Scale up until we have at least 17 or 18 integer part digits. */
/* Div/mod 100. */
/* Scale down until no more than 17 or 18 integer part digits remain. */
/* Collect integer part digits and convert to rescaled double. */
/* Gather round bit from remaining digits. */
/* Scan string containing a number. Returns format. Returns value in o. */
/* Remove leading space, parse sign and non-numbers. */
/* Parse "inf", "infinity" or "nan". */
/* Parse regular number. */
/* Determine base and skip leading zeros. */
/* Preliminary digit and decimal point scan. */
/* For fast path below. */
/* Handle decimal point. */
/* Skip trailing zeros. */
/* Parse exponent. */
/* Parse suffix. */
/* I (IMAG), U (U32), LL (I64), ULL/LLU (U64), L (long), UL/LU (ulong). */
/* NYI: f (float). Not needed until cp_number() handles non-integers. */
/* Fast path for decimal 32 bit integers. */
/* Dispatch to base-specific parser. */
/* Try to convert number to integer, if requested. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_tab.c
/*
/* -- Object hashing ------------------------------------------------------ */
/* Hash values are masked with the table hash mask and used as an index. */
/* String hashes are precomputed when they are interned. */
/* Hash an arbitrary key and return its anchor position in the hash table. */
/* Only hash 32 bits of lightuserdata on a 64 bit CPU. Good enough? */
/* -- Table creation and destruction -------------------------------------- */
/* Create new hash part for table. */
/*
/* Clear hash part of table. */
/* Clear array part of table. */
/* Create a new table. Note: the slots are not initialized (yet). */
/* First try to colocate the array part. */
/* Otherwise separately allocate the array part. */
/* In case the array allocation fails. */
/* Create a new table.
/* Duplicate a table. */
/* Keys with metamethod names may be present. */
/* An inlined loop beats memcpy for < 512 bytes. */
/* Don't use copyTV here, since it asserts on a copy of a dead key. */
/* Free a table. */
/* -- Table resizing ------------------------------------------------------ */
/* Resize a table to fit the new array/hash part sizes. */
/* Array part grows? */
/* A colocated array must be separated and copied. */
/* Mark as separated (colo < 0). */
/* Clear newly allocated slots. */
/* Create new (empty) hash part. */
/* Array part shrinks? */
/* Note: This 'shrinks' even colocated arrays. */
/* Reinsert old array values. */
/* Physically shrink only separated arrays. */
/* Reinsert pairs from old hash part. */
/* -- Table getters ------------------------------------------------------- */
/* Else use the generic lookup. */
/* -- Table setters ------------------------------------------------------- */
/* Insert new key. Use Brent's variation to optimize the chain length. */
/* No free node found? */
/* Rehash table. */
/* Retry key insertion. */
/* Colliding node not the main node? */
/* Find predecessor. */
/* Relink chain. */
/* Copy colliding node into free node and free main node. */
/* Rechain pseudo-resurrected string keys with colliding hashes. */
/* Otherwise use free node. */
/* Insert into chain. */
/* Invalidate negative metamethod cache. */
/* Else use the generic lookup. */
/* -- Table traversal ----------------------------------------------------- */
/* Get the traversal index of a key. */
/* Array key indexes: [0..t->asize-1] */
/* Array key indexes: [0..t->asize-1] */
/* Hash key indexes: [t->asize..t->asize+t->nmask] */
/* ITERN was despecialized while running. */
/* unreachable */
/* A nil key starts the traversal. */
/* Advance to the next step in a table traversal. */
/* Find predecessor key index. */
/* First traverse the array keys. */
/* Then traverse the hash keys. */
/* End of traversal. */
/* -- Table length calculation -------------------------------------------- */
/* i is zero or a present index */
/* find `i' and `j' such that i is present and j is not */
/* overflow? */
/* table was built with bad purposes: resort to linear search */
/* now do a binary search between them */
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_trace.c
/*
/* -- Error handling ------------------------------------------------------ */
/* Synchronous abort with error message. */
/* No error info. */
/* Synchronous abort with error message and error info. */
/* -- Trace management ---------------------------------------------------- */
/* The current trace is first assembled in J->cur. The variable length
/* Find a free trace number. */
/* Need to grow trace array. */
/* Too many traces. */
/*
/* Allocate space for copy of trace. */
/* Save current trace by copying and compacting it. */
/* Re-enable compiling a prototype by unpatching any modified bytecode. */
/* Unpatch the bytecode modified by a root trace. */
/* No need to unpatch branches in parent traces (yet). */
/* Already unpatched. */
/* Flush a root trace. */
/* First unpatch any modified bytecode. */
/* Unlink root trace from chain anchored in prototype. */
/* Trace is first in chain. Easy. */
/* Otherwise search in chain of root traces. */
/* Unlink from chain. */
/* Flush a trace. Only root traces are considered. */
/* Flush all traces associated with a prototype. */
/* Flush all traces. */
/* Clear penalty cache. */
/* Free the whole machine code and invalidate all exit stub groups. */
/* Initialize JIT compiler state. */
/* Initialize SIMD constants. */
/* Free everything associated with the JIT compiler state. */
/* This assumes all traces have already been freed. */
/* -- Penalties and blacklisting ------------------------------------------ */
/* Blacklist a bytecode instruction. */
/* Penalize a bytecode instruction. */
/* Cache slot found? */
/* First try to bump its hotcount several times. */
/* Blacklist it, if that didn't help. */
/* Assign a new penalty cache slot. */
/* -- Trace compiler state machine ---------------------------------------- */
/* Start tracing. */
/* JIT disabled for this proto? */
/* Lazy bytecode patching to disable hotcount events. */
/* Silently ignored. */
/* Get a new trace number. */
/* No free trace? */
/* Silently ignored. */
/* Setup enough of the current trace to be able to send the vmevent. */
/* Stop tracing. */
/* Do this first. May throw OOM. */
/* Patch FORI, too. */
/* fallthrough */
/* Patch bytecode of starting instruction in root trace. */
/* Add to root trace chain in prototype. */
/* Patch exit branch in parent to side trace entry. */
/* Avoid compiling a side trace twice (stack resizing uses parent exit). */
/* Add to side trace chain in root trace. */
/* Commit new mcode only after all patching is done. */
/* Start a new root trace for down-recursion. */
/* Restart recording at the return instruction. */
/* NYI: down-recursion with RETM. */
/* Abort tracing. */
/* Remove error object */
/* Retry ASM with new MCode area. */
/* Penalize or blacklist starting bytecode instruction. */
/* Is there anything to abort? */
/* Stack may be resized. */
/* Find original Lua function call to generate a better error message. */
/* Drop aborted trace after the vmevent (which may still access it). */
/* Remove error object */
/* Perform pending re-patch of a bytecode instruction. */
/* State machine for the trace compiler. Protected callback. */
/* trace_start() may change state. */
/* Save/restore tmptv state for trace recorder. */
/* Loop optimization failed? */
/* Try to continue recording. */
/* Needed by assembler. */
/* Trace aborted asynchronously. */
/* fallthrough */
/* -- Event handling ------------------------------------------------------ */
/* A bytecode instruction is about to be executed. Record it. */
/* Note: J->L must already be set. pc is the true bytecode PC here. */
/* A hotcount triggered. Start recording a root trace. */
/* Note: pc is the interpreter bytecode PC here. It's offset by 1. */
/* Reset hotcount. */
/* Only start a new trace if not recording or inside __gc call or vmevent. */
/* Root trace. */
/* Check for a hot side exit. If yes, start recording a side trace. */
/* J->parent is non-zero for a side trace. */
/* Tiny struct to pass data to protected call. */
/* Pointer to exit state. */
/* Restart interpreter at this PC. */
/* Need to protect lj_snap_restore because it may throw. */
/* Inherit error function. */
/* Push all registers from exit state. */
/* Determine trace number from pc of exit instruction. */
/* A trace exited. Restore interpreter state. */
/* Treat stack check like a parent exit. */
/* Return negated error code. */
/* Exited because of GC: drive GC forward. */
/* Return MULTRES or 0. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_udata.c
/*
/* Not finalized. */
/* NOBARRIER: The GCudata is new (marked white). */
/* Chain to userdata list (after main thread). */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_vmevent.c
/*
/* No handler: cache this fact. */
/* Disable all events. */
/* Really shouldn't use stderr here, but where else to complain? */
/* Restore event mask, but not if not modified. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\lj_vmmath.c
/*
/* -- Helper functions for generated machine code ------------------------- */
/* Wrapper functions to avoid linker issues on OSX. */
/* This must be checked before using this function. */
/* Unsigned x^k. */
/* Signed x^k. */
/* Computes fpm(x) for extended math functions. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\luajit.c
/*
/* unused arg. */
/* Avoid luaL_error -- a C hook doesn't add an extra frame. */
/* if another SIGINT happens before lstop,
/* Non-string error object? Try metamethod. */
/* Return non-string error object. */
/* Replace object by result of __tostring metamethod. */
/* function index */
/* push traceback function */
/* put it under chunk and args */
/* remove traceback function */
/* force a complete garbage collection in case of errors */
/* Get jit.* module table. */
/* count total number of arguments */
/* number of arguments to the script */
/* remove global */
/* else... */
/* no input */
/* repeat until gets a complete line */
/* cannot try to add lines? */
/* no more input? */
/* add a new line... */
/* ...between the two lines */
/* join them */
/* remove line */
/* any result to print? */
/* clear stack */
/* collect arguments */
/* stdin */
/* Load add-on module. */
/* Drop module table. */
/* Run command with options. */
/* Split arguments. */
/* JIT engine control command: try jit library first or load add-on module. */
/* Get jit.* module table. */
/* Lookup library function. */
/* Drop non-function and jit.* table, keep module name. */
/* Drop jit.* table. */
/* Drop module name. */
/* Optimization flags. */
/* Get jit.opt.* module table. */
/* Save or list bytecode. */
/* check that argument has no extra characters at the end */
/* Not an option? */
/* Check option. */
/* fallthrough */
/* LuaJIT extension */
/* LuaJIT extension */
/* LuaJIT extension */
/* invalid option */
/* option */
/* stop if file fails */
/* LuaJIT extension */
/* LuaJIT extension */
/* LuaJIT extension */
/* status OK */
/* linker-enforced version check */
/* invalid args? */
/* stop collector during initialization */
/* open libraries */
/* executes stdin as a file */
/* create state */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\host\buildvm.c
/*
/* ------------------------------------------------------------------------ */
/* DynASM glue definitions. */
/* Glue macros for DynASM. */
/* ------------------------------------------------------------------------ */
/* Avoid trouble if cross-compiling for an x86 target. Speed doesn't matter. */
/* Embed architecture-specific DynASM encoder. */
/* Embed generated architecture-specific backend. */
/* ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------ */
/* Emit code as raw bytes. Only used for DynASM debugging. */
/* -- Build machine code -------------------------------------------------- */
/* Keep @plt. */
/* MSVC doesn't like strdup. */
/* Collect external relocations. */
/* Encode symbol offset of .text. */
/* Encode symbol offset of 0. */
/* Naive insertion sort. Performance doesn't matter here. */
/* Build the machine code. */
/* Initialize DynASM structures. */
/* Call arch-specific backend to emit the code. */
/* Finalize the code. */
/* Allocate symbol table and bytecode offsets. */
/* Collect the opcodes (PC labels). */
/* Collect the globals (named labels). */
/* Skip the _Z symbols. */
/* Close the address range. */
/* -- Generate VM enums --------------------------------------------------- */
/* Emit C source code for bytecode-related definitions. */
/* This is a generated file. DO NOT EDIT! */\n\n");
/* Emit VM definitions as Lua code for debug modules. */
/* -- Argument parsing ---------------------------------------------------- */
/* Build mode names. */
/* Print usage information and exit. */
/* Parse the output mode name. */
/* Parse arguments. */
/* Yuck. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\host\buildvm_asm.c
/*
/* ------------------------------------------------------------------------ */
/* Emit bytes piecewise as assembler text. */
/* Emit relocation */
/* BUILD_machasm for relative relocations handled below. */
/* Emit relocation for the incredibly stupid OSX assembler. */
/* Emit words piecewise as assembler text. */
/* Emit relocation as part of an instruction. */
/* Emit an assembler label. */
/* Emit alignment. */
/* ------------------------------------------------------------------------ */
/* Emit assembler source code. */
/* This should really be moved into buildvm_arm.dasc. */
/* Soft-float ABI + SPE. */
/* Hard-float ABI. */
/* fallthrough */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\host\buildvm_fold.c
/*
/* Context for the folding hash table generator. */
/* Try to fill the hash table with keys using the hash parameters. */
/* Avoid zero rotates. */
/* Collision on primary slot. */
/* Collision on secondary slot. */
/* Try to move the colliding key, if possible. */
/* Cannot resolve collision. */
/* Move colliding key to secondary slot. */
/* Collision. */
/* Success, all keys could be stored. */
/* Print the generated hash table. */
/* Exhaustive search for the shortest semi-perfect hash table. */
/* Search for the smallest hash table with an odd size. */
/* First try all shift hash combinations. */
/* Then try all rotate hash combinations. */
/* Parse one token of a fold rule. */
/* Parse a fold rule. */
/* Simple insertion sort to detect duplicates. */
/* Emit C source code for IR folding hash table. */
/* We don't care about analyzing lines longer than that. */
/* This is a generated file. DO NOT EDIT! */\n\n");
/* The prefix must be at the start of a line, otherwise it's ignored. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\host\buildvm_lib.c
/*
/* Context for library definitions. */
/* +2 for caller. */
/* Hash table size. */
/* Bump hash table size. */
/* Set env. */
/* Bump hash table size. */
/* Emit C source code for library function definitions. */
/* This is a generated file. DO NOT EDIT! */\n\n");
/* We don't care about analyzing lines longer than that. */
/* Simplistic pre-processor. Only handles top-level #if/#endif. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\host\buildvm_peobj.c
/*
/* Context for PE object emitter. */
/* -- PE object definitions ----------------------------------------------- */
/* PE header. */
/* PE section. */
/* PE relocation. */
/* Cannot use sizeof, because it pads up to the max. alignment. */
/* PE symbol table entry. */
/* PE symbol table auxiliary entry for a section. */
/* Cannot use sizeof, because it pads up to the max. alignment. */
/* PE object CPU specific defines. */
/* MS: REL32, GNU: DISP32. */
/* 60=r+x, 50=align16, 20=code. */
/* MS: REL32, GNU: DISP32. */
/* 60=r+x, 50=align16, 20=code. */
/* 60=r+x, 40=align8, 20=code. */
/* Section numbers (0-based). */
/* Symbol types. */
/* Symbol storage class. */
/* -- PE object emitter --------------------------------------------------- */
/* Emit PE object symbol. */
/* Pass 1: only calculate string table length. */
/* 1-based section number. */
/* Emit PE object section symbol. */
/* Pass 1: no output. */
/* 1-based section number. */
/* Emit Windows PE object file. */
/* Fill in PE sections. */
/* Flags: 60 = read+execute, 50 = align16, 20 = code. */
/* Flags: 40 = read, 30 = align4, 40 = initialized data. */
/* See below. */
/* Flags: 40 = read, 30 = align4, 40 = initialized data. */
/* Flags: 40 = read, 30 = align4, 40 = initialized data. */
/* Fill in PE header. */
/* Timestamp is optional. */
/* Compute the size of the symbol table:
/* Symbol for lj_err_unwind_win64. */
/* Write PE object header and all sections. */
/* Write .text section. */
/* Byteswap .text section. */
/* Reloc syms are after .text sym. */
/* Write .pdata section. */
/* Start of .text, end of .text and .xdata. */
/* Write .xdata section. */
/* Ver. 1, uhandler/ehandler, prolog size 0. */
/* Number of unwind codes, no frame pointer. */
/* Stack offset 4*8+8 = aword*5. */
/* Push rbx. */
/* Push rsi. */
/* Push rdi. */
/* Push rbp. */
/* Alignment. */
/* Relocated address of exception handler. */
/* Ver. 1, no handler, prolog size 0. */
/* Number of unwind codes, fp = rbp, fpofs = 16. */
/* set_fpreg. */
/* stack offset 0*8+8 = aword*1. */
/* Push rbx. */
/* Push rbp. */
/* Write .rdata$Z section. */
/* Write symbol table. */
/* 1st pass: collect string sizes. */
/* Mark as SafeSEH compliant. */
/* 2nd pass: alloc strtab, write syms and copy strings. */
/* Write string table. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luaJIT\src\host\minilua.c
/* This is a heavily customized and minimized copy of Lua 5.1.5. */
/* It's only used to build LuaJIT. It does NOT have all standard functions! */
/******************************************************************************
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luasocket\auxiliar.c
/*=========================================================================*\
/*=========================================================================*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* mt */
/* create __index table to place methods */
/* mt,"__index" */
/* mt,"__index",it */
/* put class name into class metatable */
/* mt,"__index",it,"class" */
/* mt,"__index",it,"class",classname */
/* mt,"__index",it */
/* pass all methods that start with _ to the metatable, and all others
/* mt,"__index",it */
/* mt */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luasocket\buffer.c
/*=========================================================================*\
/*=========================================================================*\
/* min and max macros */
/*=========================================================================*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* check if there was an error */
/* push time elapsed during operation as the last return value */
/*-------------------------------------------------------------------------*\
/* initialize buffer with optional extra prefix
/* receive new patterns */
/* get a fixed number of bytes (minus what was already partially
/* check if there was an error */
/* we can't push anyting in the stack before pushing the
/* push time elapsed during operation as the last return value */
/*-------------------------------------------------------------------------*\
/*=========================================================================*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* we ignore all \r's */
/* found '\n' */
/* skip '\n' too */
/* we are done */
/* reached the end of the buffer */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luasocket\compat.c
/*
/* fill the table with given functions */
/* copy upvalues to the top */
/* closure with those upvalues */
/* remove upvalues */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luasocket\except.c
/*=========================================================================*\
/*=========================================================================*\
/* except functions */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* metatable for wrapped exceptions */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luasocket\inet.c
/*=========================================================================*\
/*=========================================================================*\
/* DNS functions */
/*=========================================================================*\
/*-------------------------------------------------------------------------*\
/*=========================================================================*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*=========================================================================*\
/*-------------------------------------------------------------------------*\
/* 65535 = 5 bytes + 0 to terminate it */
/*-------------------------------------------------------------------------*\
/* 65535 = 5 bytes + 0 to terminate it */
/*=========================================================================*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* try resolving */
/* create new socket if necessary. if there was no
/* set non-blocking before connect */
/* try connecting to remote address */
/* if success or timeout is zero, break out of loop */
/* here, if err is set, we failed */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* translate luasocket special values to C */
/* try resolving */
/* iterate over resolved addresses until one is good */
/* try binding to local address */
/* keep trying unless bind succeeded */
/* set to non-blocking after bind */
/* cleanup and return error */
/* here, if err is set, we failed */
/*-------------------------------------------------------------------------*\
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luasocket\io.c
/*=========================================================================*\
/*=========================================================================*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luasocket\luasocket.c
/*=========================================================================*\
/*=========================================================================*\
/*=========================================================================*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* export functions (and leave namespace table on top of stack) */
/* make version string available to scripts */
/*-------------------------------------------------------------------------*\
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luasocket\mime.c
/*=========================================================================*\
/*=========================================================================*\
/*=========================================================================*\
/* code support functions */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*=========================================================================*\
/*-------------------------------------------------------------------------*\
/* make version string available to scripts */
/* initialize lookup tables */
/*=========================================================================*\
/*-------------------------------------------------------------------------*\
/* end of input black-hole */
/* if last line has not been terminated, add a line break */
/* otherwise, we are done */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* ignore invalid characters */
/* decode atom */
/* take care of paddding */
/* need more data */
/*-------------------------------------------------------------------------*\
/* end-of-input blackhole */
/* make sure we don't confuse buffer stuff with arguments */
/* process first part of the input */
/* if second part is nil, we are done */
/* if the output is empty  and the input is nil, return nil */
/* otherwise process the second part */
/*-------------------------------------------------------------------------*\
/* end-of-input blackhole */
/* make sure we don't confuse buffer stuff with arguments */
/* process first part of the input */
/* if second is nil, we are done */
/* if the output is empty  and the input is nil, return nil */
/* otherwise, process the rest of the input */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* deal with all characters we can have */
/* might be the CR of a CRLF sequence */
/* might be a space and that has to be quoted if last in line */
/* if it is the last, quote it and we are done */
/* might have to be quoted always */
/* might never have to be quoted */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* end-of-input blackhole */
/* make sure we don't confuse buffer stuff with arguments */
/* process first part of input */
/* if second part is nil, we are done */
/* otherwise process rest of input */
/*-------------------------------------------------------------------------*\
/* deal with all characters we can deal */
/* if we have an escape character */
/* eliminate soft line break */
/* decode quoted representation */
/* if it is an invalid, do not decode */
/*-------------------------------------------------------------------------*\
/* end-of-input blackhole */
/* make sure we don't confuse buffer stuff with arguments */
/* process first part of input */
/* if second part is nil, we are done */
/* otherwise process rest of input */
/*-------------------------------------------------------------------------*\
/* end-of-input blackhole */
/* process all input */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* end of input blackhole */
/* process all input */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* end-of-input blackhole */
/* process all input */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luasocket\options.c
/*=========================================================================*\
/*=========================================================================*\
/*=========================================================================*\
/*-------------------------------------------------------------------------*\
/* obj, name, ... */
/* obj, name, ... */
/* enables reuse of local address */
/* enables reuse of local port */
/* disables the Naggle algorithm */
/* obj, name, table */
/* obj, name */
/* obj, name, ip */
/*=========================================================================*\
/* obj, name, table */
/* obj, opt-name, table */
/* By default we listen to interface on default route
/* obj, name, bool */
/* obj, name, int */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luasocket\select.c
/*=========================================================================*\
/*=========================================================================*\
/* functions in library namespace */
/*=========================================================================*\
/*-------------------------------------------------------------------------*\
/*=========================================================================*\
/*-------------------------------------------------------------------------*\
/*=========================================================================*\
/* nil is the same as an empty table */
/* otherwise we need it to be a table */
/* getfd figures out if this is a socket */
/* make sure we don't overflow the fd_set */
/* keep track of the largest descriptor so far */
/* make sure we can map back from descriptor to the object */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luasocket\serial.c
/*=========================================================================*\
/*
/*=========================================================================*\
/* serial object methods */
/*-------------------------------------------------------------------------*\
/* create classes */
/* create class groups */
/*=========================================================================*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* this is very dangerous, but can be handy for those that are brave enough */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*=========================================================================*\
/*-------------------------------------------------------------------------*\
/* allocate unix object */
/* open serial device */
/*printf("open %s on %d\n", path, sock);*/
/* set its type as client object */
/* initialize remaining structure fields */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luasocket\tcp.c
/*=========================================================================*\
/*=========================================================================*\
/* tcp object methods */
/* socket option handlers */
/* functions in library namespace */
/*-------------------------------------------------------------------------*\
/* create classes */
/* create class groups */
/* define library functions */
/*=========================================================================*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* this is very dangerous, but can be handy for those that are brave enough */
/*-------------------------------------------------------------------------*\
/* if successful, push client socket */
/* initialize structure fields */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* make sure we try to connect only to the same family */
/* have to set the class even if it failed due to non-blocking connects */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* turn master object into a server object */
/*-------------------------------------------------------------------------*\
/* SHUT_RD,  SHUT_WR,  SHUT_RDWR  have  the value 0, 1, 2, so we can use method index directly */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*=========================================================================*\
/*-------------------------------------------------------------------------*\
/* set its type as master object */
/* if family is AF_UNSPEC, we leave the socket invalid and
/* initialize tcp structure */
/* allow user to pick local address and port */
/* try to connect to remote address and port */
/* make sure we try to connect only to the same family */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luasocket\timeout.c
/*=========================================================================*\
/* min and max macros */
/*=========================================================================*\
/*=========================================================================*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* Windows file time (time since January 1, 1601 (UTC)) */
/* convert to Unix Epoch time (time since January 1, 1970 (UTC)) */
/* Unix Epoch time (time since January 1, 1970 (UTC)) */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*=========================================================================*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luasocket\udp.c
/*=========================================================================*\
/* min and max macros */
/*=========================================================================*\
/* udp object methods */
/* socket options for setoption */
/* socket options for getoption */
/* functions in library namespace */
/*-------------------------------------------------------------------------*\
/* create classes */
/* create class groups */
/* define library functions */
/* export default UDP size */
/*=========================================================================*\
/* a 'closed' error on an unconnected means the target address was not
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* create socket if on first sendto if AF_UNSPEC was set */
/*-------------------------------------------------------------------------*\
/* Unlike TCP, recv() of zero is not closed, but a zero-length packet. */
/*-------------------------------------------------------------------------*\
/* Unlike TCP, recv() of zero is not closed, but a zero-length packet. */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* this is very dangerous, but can be handy for those that are brave enough */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* make sure we try to connect only to the same family */
/* we ignore possible errors because Mac OS X always
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*=========================================================================*\
/*-------------------------------------------------------------------------*\
/* allocate udp object */
/* if family is AF_UNSPEC, we leave the socket invalid and
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luasocket\unix.c
/*=========================================================================*\
/*-------------------------------------------------------------------------*\
/* Look up socket.unix.stream in the socket.unix table (which is the first
/* Replace the stack entry for the socket.unix table with the
/* Call socket.unix.stream, passing along any arguments. */
/* Pass along the return values from socket.unix.stream. */
/*-------------------------------------------------------------------------*\
/* Add backwards compatibility aliases "tcp" and "udp" for the "stream" and
/* Add a backwards compatibility function and a metatable setup to call it
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luasocket\unixdgram.c
/*=========================================================================*\
/*=========================================================================*\
/* unixdgram object methods */
/* socket option handlers */
/* functions in library namespace */
/*-------------------------------------------------------------------------*\
/* create classes */
/* create class groups */
/*=========================================================================*\
/* a 'closed' error on an unconnected means the target address was not
/*-------------------------------------------------------------------------*\
/* Unlike STREAM, recv() of zero is not closed, but a zero-length packet. */
/*-------------------------------------------------------------------------*\
/* Unlike STREAM, recv() of zero is not closed, but a zero-length packet. */
/* the path may be empty, when client send without bind */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* this is very dangerous, but can be handy for those that are brave enough */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* turn unconnected object into a connected object */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*=========================================================================*\
/*-------------------------------------------------------------------------*\
/* try to allocate a system socket */
/* allocate unixdgram object */
/* set its type as master object */
/* initialize remaining structure fields */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luasocket\unixstream.c
/*=========================================================================*\
/*=========================================================================*\
/* unixstream object methods */
/* socket option handlers */
/* functions in library namespace */
/*-------------------------------------------------------------------------*\
/* create classes */
/* create class groups */
/*=========================================================================*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* this is very dangerous, but can be handy for those that are brave enough */
/*-------------------------------------------------------------------------*\
/* if successful, push client socket */
/* initialize structure fields */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* turn master object into a client object */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* turn master object into a server object */
/*-------------------------------------------------------------------------*\
/* SHUT_RD,  SHUT_WR,  SHUT_RDWR  have  the value 0, 1, 2, so we can use method index directly */
/*-------------------------------------------------------------------------*\
/*=========================================================================*\
/*-------------------------------------------------------------------------*\
/* try to allocate a system socket */
/* allocate unixstream object */
/* set its type as master object */
/* initialize remaining structure fields */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luasocket\usocket.c
/*=========================================================================*\
/*-------------------------------------------------------------------------*\
/* optimize timeout == 0 case */
/* optimize timeout == 0 case */
/* must set bits within loop, because select may have modifed them */
/*-------------------------------------------------------------------------*\
/* installs a handler to ignore sigpipe or it will crash us */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* timeout = 0 means no wait */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* avoid calling on closed sockets */
/* call connect until done or failed without being interrupted */
/* if connection failed immediately, return error code */
/* zero timeout case optimization */
/* wait until we have the result of the connection attempt or timeout */
/*-------------------------------------------------------------------------*\
/* can't reach here */
/*-------------------------------------------------------------------------*\
/* avoid making system calls on closed sockets */
/* loop until we send something or we give up on error */
/* if we sent anything, we are done */
/* EPIPE means the connection was closed */
/* EPROTOTYPE means the connection is being closed (on Yosemite!)*/
/* we call was interrupted, just try again */
/* if failed fatal reason, report error */
/* wait until we can send something or we timeout */
/* can't reach here */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* avoid making system calls on closed sockets */
/* loop until we send something or we give up on error */
/* if we sent anything, we are done */
/* EPIPE means the connection was closed */
/* EPROTOTYPE means the connection is being closed (on Yosemite!)*/
/* we call was interrupted, just try again */
/* if failed fatal reason, report error */
/* wait until we can send something or we timeout */
/* can't reach here */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\luasocket\wsocket.c
/*=========================================================================*\
/* WinSock doesn't have a strerror... */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* optimize timeout == 0 case */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* close can take a long time on WIN32 */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* don't call on closed socket */
/* ask system to connect */
/* make sure the system is trying to connect */
/* zero timeout case optimization */
/* we wait until something happens */
/* give windows time to set the error (yes, disgusting) */
/* find out why we failed */
/* we KNOW there was an error. if 'why' is 0, we will return
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* try to get client socket */
/* find out why we failed */
/* if we failed because there was no connectoin, keep trying */
/* call select to avoid busy wait */
/*-------------------------------------------------------------------------*\
/* avoid making system calls on closed sockets */
/* loop until we send something or we give up on error */
/* try to send something */
/* if we sent something, we are done */
/* deal with failure */
/* we can only proceed if there was no serious error */
/* avoid busy wait */
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/* On UDP, a connreset simply means the previous send failed.
/*-------------------------------------------------------------------------*\
/* On UDP, a connreset simply means the previous send failed.
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
/*-------------------------------------------------------------------------*\
// "Permission denied";
// "Socket type not supported";
// "Address family not supported by protocol family";
// "Address already in use";
// "Connection reset by peer";
// "Socket is already connected";
// "Connection timed out";
// "Connection refused";
// "Host not found";
// "Nonrecoverable name lookup error";
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\mikktspace\mikktspace.c
/** \file mikktspace/mikktspace.c
/**
// internal structure
// could possibly use FLT_EPSILON instead
// might change this to an epsilon based test
// 
// normalized first order face derivatives
// original magnitudes
// determines if the current and the next triangle are a quad.
// this is to average back into quads.
// this if is important. Due to floating point precision
// averaging when ts0==ts1 will cause a slight difference
// which results in tangent space splits later on
// degen triangles
// count nr_triangles
// verify all call-backs have been set
// count triangles on supported faces
// allocate memory for an index list
// make an initial triangle --> face index list
// make a welded index list of identical positions and attributes (pos, norm, texc)
//printf("gen welded index list begin\n");
//printf("gen welded index list end\n");
// Mark all degenerate triangles
// degenerate
// mark all triangle pairs that belong to a quad with only one
// good triangle. These need special treatment in DegenEpilogue().
// Additionally, move all good triangles to the start of
// pTriInfos[] and piTriListIn[] without changing order and
// put the degenerate triangles last.
// evaluate triangle level attributes and neighbor list
//printf("gen neighbors list begin\n");
//printf("gen neighbors list end\n");
// based on the 4 rules, identify groups based on connectivity
//printf("gen 4rule groups begin\n");
//printf("gen 4rule groups end\n");
//
// make tspaces, each group is split up into subgroups if necessary
// based on fAngularThreshold. Finally a tangent space is made for
// every resulting subgroup
//printf("gen tspaces begin\n");
//printf("gen tspaces end\n");
// clean up
// if an allocation in GenerateTSpaces() failed
// clean up and return false
// degenerate quads with one good triangle will be fixed by copying a space from
// the good triangle to the coinciding vertex.
// all other degenerate triangles will just copy a space from any good triangle
// with the same welded index in piTriListIn[].
// I've decided to let degenerate triangles and group-with-anythings
// vary between left/right hand coordinate systems at the vertices.
// All healthy triangles on the other hand are built to always be either or.
// force the coordinate system orientation to be uniform for every face.
/*// force the coordinate system orientation to be uniform for every face.
// (this is already the case for good triangles but not for
// degenerate ones and those with bGroupWithAnything==true)
// tspace was not derived from a group
// look for a space created in GenerateTSpaces() by iCounter>0
// set data
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// it is IMPORTANT that this function is called to evaluate the hash since
// inlining could potentially reorder instructions and generate different
// results for the same effective input value fVal.
// Generate bounding box
// make allocations
// count amount of elements in each cell unit
// evaluate start index of each cell.
// insert vertices
// vertex i has been inserted.
// verify the count
// find maximum amount of entries in any hash entry
// complete the merge
// extract table of cell k and amount of entries in it
// make bbox
// terminate recursion when the separation/average value
// is no longer strictly between fMin and fMax values.
// complete the weld
//if (vP==vP2 && vN==vN2 && vT==vT2)
// merge if previously found
// at least 2 entries
// separate (by fSep) all points between iL_in and iR_in in pTmpVert[]
// only need to weld when there is more than 1 instance of the (x,y,z)
// weld all left of fSep
// weld all right of (or equal to) fSep
// this can be optimized further using a tree structure or more hashing.
// merge if previously found
// if we found our own
// next
// need an order independent way to evaluate
// tspace on quads. This is done by splitting
// along the shortest diagonal.
// next
// next
// next
// next
// return total amount of tspaces
/////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////
// returns the texture area times 2
// pTriInfos[f].iFlag is cleared in GenerateInitialVerticesIndexList() which is called before this function.
// generate neighbor info list
// assumed bad
// evaluate first order derivatives
// initial values
//assert(fSignedAreaSTx2!=0);
// eq 18
// eq 19
// evaluate magnitudes prior to normalization of vOs and vOt
// if this is a good triangle
// force otherwise healthy quads to a fixed orientation
// this is a quad
// bad triangles should already have been removed by
// DegenPrologue(), but just in case check bIsDeg_a and bIsDeg_a are false
// if this happens the quad has extremely bad mapping!!
//printf("found quad with bad mapping\n");
// force match
// clear first
// copy bit
// match up edge pairs
/////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////
/* quiet warnings in non debug mode */
// if not assigned to a group
// neighbor
/* quiet warnings in non debug mode */
// neighbor
/* quiet warnings in non debug mode */
// update offset
// since the groups are disjoint a triangle can never
// belong to more than 3 groups. Subsequently something
// is completely screwed if this assertion ever hits.
// track down vertex
// early out
// first to group with a group-with-anything triangle
// determines it's orientation.
// This is the only existing order dependency in the code!!
/////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////
// make initial allocations
// triangles
// triangle number
// is normalized already
// project
// original face number
// triangle number
// project
// make sure triangles which belong to the same quad are joined.
// sanity check
// sort pTmpMembers
// could replace with a random seed?
// look for an existing match
// assign tangent space index
//piTempTangIndices[f*3+index] = iUniqueTspaces+l;
// if no match was found we allocate a new subgroup
// insert new subgroup
// clean up and return false
// output tspace
// update counter
// update counter
// clean up and offset iUniqueTspaces
// clean up
// only valid triangles get to add their contribution
// project
// project
// weight contribution by the angle
// between the two edge vectors
// normalize
// Random
// Random end
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
// build array of edges
// could replace with a random seed?
// put minimum index in i0
// put maximum index in i1
// record face number
// sort over all edges by i0, this is the pricy one.
// sort channel 0 which is i0
// sub sort over i1, should be fast.
// could replace this with a 64 bit int sort over (i0,i1)
// with i0 as msb in the quicksort call above.
//const int iElems = i-iL;
// sort channel 1 which is i1
// sub sort over f, which should be fast.
// this step is to remain compliant with BuildNeighborsSlow() when
// more than 2 triangles use the same edge (such as a butterfly topology).
//const int iElems = i-iL;
// sort channel 2 which is f
// pair up, adjacent triangles
// 0,1 or 2
// resolve index ordering and edge_num
// get true index ordering
// flip i0_B and i1_B
// resolve index ordering and edge_num
//assert(!(i0_A==i1_B && i1_A==i0_B));
//assert(pTriInfos[t].FaceNeighbors[edgenum_B]==-1);
// if unassigned
// search for a neighbor
// in rev order
//assert(!(i0_A==i1_B && i1_A==i0_B));
// assign neighbors
//assert(pTriInfos[t].FaceNeighbors[j]==-1);
// early out
// Random
// Random end
// resolve ordering and edge number
// test if first index is on the edge
// test if second index is on the edge
// first edge
// third edge
// only second and third index is on the edge
// second edge
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// Degenerate triangles ////////////////////////////////////
// locate quads with only one good triangle
// this is a quad
// reorder list so all degen triangles are moved to the back
// without reordering the good triangles
// search for the first good triangle.
// swap triangle t0 and t1
// this is not supposed to happen
// code will still work.
// deal with degenerate triangles
// punishment for degenerate triangles is O(N^2)
// degenerate triangles on a quad with one good triangle are skipped
// here but processed in the next loop
// search through the good triangles
// copy tspace
// deal with degenerate quads with one good triangle
// this triangle belongs to a quad where the
// other triangle is degenerate
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\minizip\ioapi.c
/* ioapi.h -- IO base function header for compress/uncompress .zip
//www.winimage.com/zLibDll/minizip.html )
//result42.com )
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\minizip\iowin32.c
/* iowin32.c -- IO base function header for compress/uncompress .zip
//www.winimage.com/zLibDll/minizip.html )
//www.winimage.com/zLibDll/minizip.html )
//result42.com )
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\minizip\miniunz.c
/*
//www.winimage.com/zLibDll/minizip.html )
//www.winimage.com/zLibDll/minizip.html )
//result42.com )
/*
/* change_file_date : change the date/time of a file
/* mymkdir and change_file_date are not 100 % portable
//www.winimage.com/zLibDll/unzip.html\n\n");
/* to avoid compatibility problem , we do here the conversion */
/* display a '*' if the file is crypted */
/* 2:fast , 3 : extra fast*/
/* some zipfile don't contain directory alone before file */
/* don't lose the error */
/* strncpy doesnt append the trailing NULL, of the string is too long. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\minizip\minizip.c
/*
//www.winimage.com/zLibDll/minizip.html )
//www.winimage.com/zLibDll/minizip.html )
//result42.com )
/* name of file to get info on */
/* return value: access, modific. and creation times */
/* dostime */
/* name of file to get info on */
/* return value: access, modific. and creation times */
/* dostime */
/* results of stat() */
/* strncpy doesnt append the trailing NULL, of the string is too long. */
/* not all systems allow stat'ing a file with / appended */
/* name of file to get info on */
/* return value: access, modific. and creation times */
/* dostime */
//www.winimage.com/zLibDll/minizip.html\n\n");
/* calculate the CRC32 of a file,
/* strncpy doesnt append the trailing NULL, of the string is too long. */
/* if the file don't exist, we not append file */
/*
/* The path name saved, should not include a leading slash. */
/*if it did, windows/xp and dynazip couldn't read the zip file. */
/*should the zip file contain any path at all?*/
// base filename follows last slash.
/**/
/* comment*/,
/* -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY, */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\minizip\mztools.c
/*
/* Code */
/* File entry */
/* crc */
/* compressed size */
/* uncompressed sz */
/* file name length */
/* extra field length */
/* Header */
/* Filename */
/* Extra field */
/* Data */
/* Central directory entry */
/* disk # */
/* int attrb */
/* ext attrb */
/* Header */
/* Filename */
/* Extra field */
/* Comment field */
/* Success */
/* Final central directory  */
// "ZIP File recovered by zlib/minizip/mztools";
/* disk # */
/* disk # */
/* hack */
/* hack */
/* size of CD */
/* offset to CD */
/* comment */
/* Header */
/* Comment field */
/* Final merge (file + central directory) */
/* Close */
/* Wipe temporary file */
/* Number of recovered entries */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\minizip\unzip.c
/* unzip.c -- IO for uncompress .zip files using zlib
//www.winimage.com/zLibDll/minizip.html )
//www.winimage.com/zLibDll/minizip.html )
//result42.com )
//ftp.info-zip.org/pub/infozip/license.html
/* compile with -Dlocal if your debugger can't find static symbols */
//www.winimage.com/zLibDll";
/* unz_file_info_interntal contain internal info about a file in zipfile*/
/* relative offset of local header 8 bytes */
/* file_in_zip_read_info_s contain internal information about a file in zipfile,
/* internal buffer for compressed data */
/* zLib stream structure for inflate */
/* bzLib stream structure for bziped */
/* position in byte on the zipfile, for fseek*/
/* flag set if stream structure is initialised*/
/* offset of the local extra field */
/* size of the local extra field */
/* position in the local extra field in read*/
/* crc32 of all data uncompressed */
/* crc32 we must obtain after decompress all */
/* number of byte to be decompressed */
/*number of byte to be obtained after decomp*/
/* io structore of the zipfile */
/* compression method (0==store) */
/* byte before the zipfile, (>0 for sfx)*/
/* unz64_s contain internal information about the zipfile
/* io structore of the zipfile */
/* public global information */
/* byte before the zipfile, (>0 for sfx)*/
/* number of the current file in the zipfile*/
/* pos of the current file in the central dir*/
/* flag about the usability of the current file*/
/* position of the beginning of the central dir*/
/* size of the central directory  */
/* offset of start of central directory with
/* public info about the current file in zip*/
/* private info about it*/
/* structure about the current
/* keys defining the pseudo-random sequence */
/* ===========================================================================
/* ===========================================================================
/* My own strcmpi / strcasecmp */
/*
/*
/* maximum size of global comment */
/*
/* maximum size of global comment */
/* Zip64 end of central directory locator */
/* the signature, already checked */
/* number of the disk with the start of the zip64 end of  central directory */
/* relative offset of the zip64 end of central directory record */
/* total number of disks */
/* Goto end of central directory record */
/* the signature */
/*
/* number of the current dist, used for
/* number the the disk with central dir, used
/* total number of entries in
/* the signature, already checked */
/* size of zip64 end of central directory record */
/* version made by */
/* version needed to extract */
/* number of this disk */
/* number of the disk with the start of the central directory */
/* total number of entries in the central directory on this disk */
/* total number of entries in the central directory */
/* size of the central directory */
/* offset of start of central directory with respect to the
/* the signature, already checked */
/* number of this disk */
/* number of the disk with the start of the central directory */
/* total number of entries in the central dir on this disk */
/* total number of entries in the central dir */
/* size of the central directory */
/* offset of start of central directory with respect to the
/* zipfile comment length */
/*
/*
/* to do : check if number_entry is not truncated */
/*
/*
/* we check the magic */
// relative offset of local header
// Read extrafield
// since lSeek now points to after the extra field we need to move back
/* ZIP64 extra fields */
/* Relative Header offset */
/* Disk Start Number */
/*
/*
/*
/* 2^16 files overflow hack */
/*
/* We remember the 'current' position in the file so that we can jump
/* Save the current state */
/* We failed, so restore the state of the 'current file' to where we
/*
// Contributed by Ryan Haksi (mailto://cryogen@infoserve.net)
// I need random access
//
// Further optimization could be realized by adding an ability
// to cache the directory in memory. The goal being a single
// comprehensive file read to put the file I need in a memory.
/*
// offset in file
// # of file
/* jump to the right spot */
/* set the current file */
/* return results */
/*
///////////////////////////////////////////
/*
/*
/* #ifdef HAVE_BZIP2 */
/* #endif */
/* date/time */
/* crc */
/* size compr */
/* size uncompr */
/*
/* offset of the local extra field */
/* size of the local extra field */
/* #ifdef HAVE_BZIP2 */
/* #endif */
/* windowBits is passed < 0 to tell that there is no zlib header.
/** Addition for GDAL : START */
//UNZ_PARAMERROR;
//UNZ_PARAMERROR;
/** Addition for GDAL : END */
/*
// end Z_BZIP2ED
/*
/*
/*
/*
/*
/*
/* Additions by RX '2004 */
//UNZ_PARAMERROR;
//UNZ_PARAMERROR;
/* hack */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\minizip\zip.c
/* zip.c -- IO on .zip files using zlib
//www.winimage.com/zLibDll/minizip.html )
//www.winimage.com/zLibDll/minizip.html )
//result42.com )
/* compile with -Dlocal if your debugger can't find static symbols */
/* platform depedent */
//(16384)
/*
/* I've found an old Unix (a SunOS 4.1.3_U1) without all SEEK_* defined.... */
// NOT sure that this work on ALL platform
//www.winimage.com/zLibDll";
/* 46 */
/* for future use and alignement */
/* zLib stream structure for inflate */
/* bzLib stream structure for bziped */
/* 1 is stream is initialised */
/* last written byte in buffered_data */
/* offset of the local header of the file
/* central header data for the current file */
/* size of the central header for cur file */
/* Extra bytes allocated to the centralheader but that are not used */
/* flag of the file currently writing */
/* compression method of file currenty wr.*/
/* 1 for directly writing raw data */
/* buffer contain compressed data to be writ*/
/* Add ZIP64 extened information in the extra field */
/* keys defining the pseudo-random sequence */
/* io structore of the zipfile */
/* datablock with central dir in construction*/
/* 1 if a file in the zip is currently writ.*/
/* info on the file curretly writing */
/* position of the beginning of the zipfile */
/****************************************************************************/
/* ===========================================================================
/* data overflow - hack for ZIP64 (X Roche) */
/* data overflow - hack for ZIP64 */
/****************************************************************************/
/****************************************************************************/
/* ===========================================================================
/*
/* maximum size of global comment */
/*
/* maximum size of global comment */
// Signature "0x07064b50" Zip64 end of central directory locater
/* Zip64 end of central directory locator */
/* the signature, already checked */
/* number of the disk with the start of the zip64 end of  central directory */
/* relative offset of the zip64 end of central directory record */
/* total number of disks */
/* Goto Zip64 end of central directory record */
/* the signature */
// signature of 'Zip64 end of central directory'
/* byte before the zipfile, (>0 for sfx)*/
/* size of the central directory  */
/* offset of start of central directory */
/* number of the current dist, used for
/* number the the disk with central dir, used
/* total number of entries in
// check first if we find a ZIP64 record
/* disable to allow appending to empty ZIP archive
/* the signature, already checked */
/* size of zip64 end of central directory record */
/* version made by */
/* version needed to extract */
/* number of this disk */
/* number of the disk with the start of the central directory */
/* total number of entries in the central directory on this disk */
/* total number of entries in the central directory */
/* size of the central directory */
/* offset of start of central directory with respect to the
// TODO..
// read the comment from the standard central header.
// Read End of central Directory info
/* the signature, already checked */
/* number of this disk */
/* number of the disk with the start of the central directory */
/* total number of entries in the central dir on this disk */
/* total number of entries in the central dir */
/* size of the central directory */
/* offset of start of central directory with respect to the starting disk number */
/* zipfile global comment length */
/* !NO_ADDFILEINEXISTINGZIP*/
/************************************************************/
/* now we add file in a zipfile */
// Read and Cache Central Directory Records
/* !NO_ADDFILEINEXISTINGZIP*/
/* !NO_ADDFILEINEXISTINGZIP*/
/* write the local header */
/* version needed to extract */
/* version needed to extract */
// CRC / Compressed size / Uncompressed size will be filled in later and rewritten later
/* crc 32, unknown */
/* compressed size, unknown */
/* compressed size, unknown */
/* uncompressed size, unknown */
/* uncompressed size, unknown */
// write the Zip64 extended info
// Remember position of Zip64 extended info for the local file header. (needed when we update size after done with file)
/*
// Extra space we have reserved in case we need to add ZIP64 extra info data
/* version info */
/*crc*/
/*compr size*/
/*uncompr size*/
/*disk nm start*/
// Init BZip stuff here
/*init_keys(password,zi->ci.keys,zi->ci.pcrc_32_tab);*/
//          uLong uTotalOutBefore_hi = zi->ci.bstream.total_out_hi32;
// while(...)
/* this is normal */
// update Current Item crc and sizes,
/*version Made by*/
/*version needed*/
/*crc*/
/*compr size*/
/*compr size*/
/// set internal file attributes field
/*uncompr size*/
/*uncompr size*/
// Add ZIP64 extra info field for uncompressed size
// Add ZIP64 extra info field for compressed size
// Add ZIP64 extra info field for relative offset to local file header of current file
// we can not write more data to the buffer that we have room for.
// Add Extra Information Header for 'ZIP64 information'
// HeaderID
// DataSize
// Update how much extra free space we got in the memory buffer
// and increase the centralheader size so the new ZIP64 fields are included
// ( 4 below is the size of HeaderID and DataSize field )
// Update the extra info size field
// Update the LocalFileHeader with the new values.
/* crc 32, unknown */
// Update the size in the ZIP64 extended field.
/* compressed size, unknown */
/* uncompressed size, unknown */
/* compressed size, unknown */
/* uncompressed size, unknown */
/*num disks*/
/* number of the disk with the start of the central directory */
/*relative offset*/
/* Relative offset to the Zip64EndOfCentralDirectory */
/*total disks*/ /* Do not support spawning of disk so always say 1 here*/
/* number of the disk with the start of the central directory */
/* size of this 'zip64 end of central directory' */
// why ZPOS64_T of this ?
/* version made by */
/* version needed */
/* number of this disk */
/* number of the disk with the start of the central directory */
/* total number of entries in the central dir on this disk */
/* total number of entries in the central dir */
/* size of the central directory */
/* offset of start of central directory with respect to the starting disk number */
/*signature*/
/* number of this disk */
/* number of the disk with the start of the central directory */
/* total number of entries in the central dir on this disk */
// use value in ZIP64 record
/* total number of entries in the central dir */
// use value in ZIP64 record
/* size of the central directory */
/* offset of start of central directory with respect to the starting disk number */
// Header found.
// skip it. do not copy to temp buffer
// Extra Info block should not be removed, So copy it to the temp buffer.
// clean old extra info block.
// copy the new extra info block over the old
// set the new extra info size
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\adler32.c
/* adler32.c -- compute the Adler-32 checksum of a data stream
/* @(#) $Id$ */
/* largest prime smaller than 65536 */
/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
/* use NO_DIVIDE if your processor does not do division in hardware --
/* note that this assumes BASE is 65521, where 65536 % 65521 == 15
/* this assumes a is not negative */ \
/* ========================================================================= */
/* split Adler-32 into component sums */
/* in case user likes doing a byte at a time, keep it fast */
/* initial Adler-32 value (deferred check for len == 1 speed) */
/* in case short lengths are provided, keep it somewhat fast */
/* only added so many BASE's */
/* do length NMAX blocks -- requires just one modulo operation */
/* NMAX is divisible by 16 */
/* 16 sums unrolled */
/* do remaining bytes (less than NMAX, still just one modulo) */
/* avoid modulos if none remaining */
/* return recombined sums */
/* ========================================================================= */
/* for negative len, return invalid adler32 as a clue for debugging */
/* the derivation of this formula is left as an exercise for the reader */
/* assumes len2 >= 0 */
/* ========================================================================= */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\compress.c
/* compress.c -- compress a memory buffer
/* @(#) $Id$ */
/* ===========================================================================
/* Check for source > 64K on 16-bit machine: */
/* ===========================================================================
/* ===========================================================================
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\crc32.c
/* crc32.c -- compute the CRC-32 of a data stream
/* @(#) $Id$ */
/*
/* !DYNAMIC_CRC_TABLE */
/* MAKECRCH */
/* for STDC and FAR definitions */
/* Definitions for doing the crc four data bytes at a time. */
/* BYFOUR */
/* Local functions for crc concatenation */
/* MAKECRCH */
/*
/* polynomial exclusive-or pattern */
/* terms of polynomial defining this crc (except x^32): */
/* flag to limit concurrent making */
/* See if another task is already doing this (not thread-safe, but better
/* make exclusive-or pattern from polynomial (0xedb88320UL) */
/* generate a crc for every 8-bit value */
/* generate crc for each value followed by one, two, and three zeros,
/* BYFOUR */
/* not first */
/* wait for the other guy to finish (not efficient, but rare) */
/* write out CRC tables to crc32.h */
/* crc32.h -- tables for rapid CRC calculation\n");
/* BYFOUR */
/* MAKECRCH */
/* MAKECRCH */
/* !DYNAMIC_CRC_TABLE */
/* ========================================================================
/* DYNAMIC_CRC_TABLE */
/* =========================================================================
/* DYNAMIC_CRC_TABLE */
/* ========================================================================= */
/* ========================================================================= */
/* DYNAMIC_CRC_TABLE */
/* BYFOUR */
/* ========================================================================= */
/* ========================================================================= */
/* ========================================================================= */
/* ========================================================================= */
/* BYFOUR */
/* dimension of GF(2) vectors (length of CRC) */
/* ========================================================================= */
/* ========================================================================= */
/* ========================================================================= */
/* even-power-of-two zeros operator */
/* odd-power-of-two zeros operator */
/* degenerate case (also disallow negative lengths) */
/* put operator for one zero bit in odd */
/* CRC-32 polynomial */
/* put operator for two zero bits in even */
/* put operator for four zero bits in odd */
/* apply len2 zeros to crc1 (first square will put the operator for one
/* apply zeros operator for this bit of len2 */
/* if no more bits set, then done */
/* another iteration of the loop with odd and even swapped */
/* if no more bits set, then done */
/* return combined crc */
/* ========================================================================= */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\deflate.c
/* deflate.c -- compress data using the deflation algorithm
/*
//tools.ietf.org/html/rfc1951
/* @(#) $Id$ */
/*
/* ===========================================================================
/* block not completed, need more input or more output */
/* block flush performed */
/* finish started, need only more output at next deflate */
/* finish done, accept no more input or output */
/* Compression function. Returns the block state after the call. */
/* asm code initialization */
/* ===========================================================================
/* Tail of hash chains */
/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
/* Values for max_lazy_match, good_match and max_chain_length, depending on
/* reduce lazy search above this match length */
/* do not perform lazy search above this match length */
/* quit search above this match length */
/*      good lazy nice chain */
/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
/* 1 */ {4,    4,  8,    4, deflate_fast}}; /* max speed, no lazy matches */
/*      good lazy nice chain */
/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
/* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */
/* 2 */ {4,    5, 16,    8, deflate_fast},
/* 3 */ {4,    6, 32,   32, deflate_fast},
/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
/* 5 */ {8,   16, 32,   32, deflate_slow},
/* 6 */ {8,   16, 128, 128, deflate_slow},
/* 7 */ {8,   32, 128, 256, deflate_slow},
/* 8 */ {32, 128, 258, 1024, deflate_slow},
/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */
/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
/* result of memcmp for equal strings */
/* for buggy compilers */
/* rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH */
/* ===========================================================================
/* ===========================================================================
/* ===========================================================================
/* ========================================================================= */
/* To do: ignore strm->next_in if we use it as window */
/* ========================================================================= */
/* We overlay pending_buf and d_buf+l_buf. This works since the average
/* suppress zlib wrapper */
/* write gzip wrapper instead */
/* until 256-byte window bug fixed */
/* nothing written to s->window yet */
/* 16K elements by default */
/* ========================================================================= */
/* when using zlib wrappers, compute Adler-32 for provided dictionary */
/* avoid computing Adler-32 in read_buf */
/* if dictionary would fill window, just replace the history */
/* already empty otherwise */
/* use the tail */
/* insert dictionary into window and hash */
/* ========================================================================= */
/* use zfree if we ever allocate msg dynamically */
/* was made negative by deflate(..., Z_FINISH); */
/* ========================================================================= */
/* ========================================================================= */
/* ========================================================================= */
/* ========================================================================= */
/* ========================================================================= */
/* Flush the last buffer: */
/* ========================================================================= */
/* =========================================================================
/* conservative upper bound for compressed data */
/* if can't get parameters, return conservative bound plus zlib wrapper */
/* compute wrapper length */
/* raw deflate */
/* zlib wrapper */
/* gzip wrapper */
/* user-supplied gzip header */
/* for compiler happiness */
/* if not default parameters, return conservative bound */
/* default settings: return tight bound for that case */
/* =========================================================================
/* =========================================================================
/* ========================================================================= */
/* value of flush param for previous deflate call */
/* just in case */
/* Write the header */
/* Save the adler32 of the preset dictionary: */
/* start of bytes to update crc */
/* start of bytes to update crc */
/* start of bytes to update crc */
/* Flush as much pending output as possible */
/* Since avail_out is 0, deflate will be called again with
/* Make sure there is something to do and avoid duplicate consecutive
/* User must not provide more input after the first FINISH: */
/* Start a new block or continue the current one.
/* avoid BUF_ERROR next call, see above */
/* If flush != Z_NO_FLUSH && avail_out == 0, the next call
/* FULL_FLUSH or SYNC_FLUSH */
/* For a full flush, this empty block will be recognized
/* forget history */
/* avoid BUF_ERROR at next call, see above */
/* Write the trailer */
/* If avail_out is zero, the application will call deflate again
/* write the trailer only once! */
/* ========================================================================= */
/* Deallocate in reverse order of allocations: */
/* =========================================================================
/* following zmemcpy do not work for 16-bit MSDOS */
/* MAXSEG_64K */
/* ===========================================================================
/* ===========================================================================
/* Set the default configuration parameters:
/* initialize the asm code */
/* ===========================================================================
/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
/* current match */
/* max hash chain length */
/* current string */
/* matched string */
/* length of current match */
/* best match length so far */
/* stop if match long enough */
/* Stop when cur_match becomes <= limit. To simplify the code,
/* Compare two bytes at a time. Note: this is not always beneficial.
/* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
/* Do not waste too much time if we already have a good match: */
/* Do not look for matches beyond the end of the input. This is necessary
/* Skip to next match if the match length cannot increase
/* This code assumes sizeof(unsigned short) == 2. Do not use
/* It is not necessary to compare scan[2] and match[2] since they are
/* The funny "do {}" generates better code on most compilers */
/* Here, scan <= window+strstart+257 */
/* UNALIGNED_OK */
/* The check at best_len-1 can be removed because it will be made
/* We check for insufficient lookahead only every 8th comparison;
/* UNALIGNED_OK */
/* ASMV */
/* FASTEST */
/* ---------------------------------------------------------------------------
/* current match */
/* current string */
/* matched string */
/* length of current match */
/* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
/* Return failure if the match length is less than 2:
/* The check at best_len-1 can be removed because it will be made
/* We check for insufficient lookahead only every 8th comparison;
/* FASTEST */
/* ===========================================================================
/* check that the match is indeed a match */
/* DEBUG */
/* ===========================================================================
/* Amount of free space at the end of the window. */
/* Deal with !@#$% 64K limit: */
/* Very unlikely, but possible on 16 bit machine if
/* If the window is almost full and there is insufficient lookahead,
/* we now have strstart >= MAX_DIST */
/* Slide the hash table (could be avoided with 32 bit values
/* If n is not on any hash chain, prev[n] is garbage but
/* If there was no sliding:
/* Initialize the hash value now that we have some input: */
/* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
/* If the WIN_INIT bytes after the end of the current data have never been
/* Previous high water mark below current data -- zero WIN_INIT
/* High water mark at or above current data, but below current data
/* ===========================================================================
/* Same but force premature exit if necessary. */
/* ===========================================================================
/* Stored blocks are limited to 0xffff bytes, pending_buf is limited
/* Copy as much as possible from input to output: */
/* Fill the window as much as possible: */
/* flush the current block */
/* Emit a stored block if pending_buf will be full: */
/* strstart == 0 is possible when wraparound on 16-bit machine */
/* Flush if we may have to slide, otherwise block_start may become
/* ===========================================================================
/* head of the hash chain */
/* set if current block must be flushed */
/* Make sure that we always have enough lookahead, except
/* flush the current block */
/* Insert the string window[strstart .. strstart+2] in the
/* Find the longest match, discarding those <= prev_length.
/* To simplify the code, we prevent matches with the string
/* longest_match() sets match_start */
/* Insert new strings in the hash table only if the match length
/* string at strstart already in table */
/* strstart never exceeds WSIZE-MAX_MATCH, so there are
/* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
/* No match, output a literal byte */
/* ===========================================================================
/* head of hash chain */
/* set if current block must be flushed */
/* Process the input block. */
/* Make sure that we always have enough lookahead, except
/* flush the current block */
/* Insert the string window[strstart .. strstart+2] in the
/* Find the longest match, discarding those <= prev_length.
/* To simplify the code, we prevent matches with the string
/* longest_match() sets match_start */
/* If prev_match is also MIN_MATCH, match_start is garbage
/* If there was a match at the previous step and the current
/* Do not insert strings in hash table beyond this. */
/* Insert in hash table all strings up to the end of the match.
/* If there was no match at the previous position, output a
/* There is no previous match to compare with, wait for
/* FASTEST */
/* ===========================================================================
/* set if current block must be flushed */
/* byte at distance one to match */
/* scan goes up to strend for length of run */
/* Make sure that we always have enough lookahead, except
/* flush the current block */
/* See how many times the previous byte repeats */
/* Emit match if have run of MIN_MATCH or longer, else emit literal */
/* No match, output a literal byte */
/* ===========================================================================
/* set if current block must be flushed */
/* Make sure that we have a literal to write. */
/* flush the current block */
/* Output a literal byte */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\gzclose.c
/* gzclose.c -- zlib gzclose() function
/* gzclose() is in a separate file so that it is linked in only if it is used.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\gzlib.c
/* gzlib.c -- zlib functions common to reading and writing gzip files
/* Local functions */
/* Map the Windows error number in ERROR to a locale-dependent error message
/* Default language */
/* If there is an \r\n appended, zap it.  */
/* UNDER_CE */
/* Reset gzip file state */
/* no output data available */
/* for reading ... */
/* not at end of file */
/* have not read past end yet */
/* look for gzip header */
/* no seek request pending */
/* clear error */
/* no uncompressed data yet */
/* no input data yet */
/* Open a gzip file either by name or file descriptor. */
/* check input */
/* allocate gzFile structure to return */
/* no buffers allocated yet */
/* requested buffer size */
/* no error message yet */
/* interpret mode */
/* can't read and write at the same time */
/* ignore -- will request binary anyway */
/* could consider as an error, but just ignore */
/* must provide an "r", "w", or "a" */
/* can't force transparent read */
/* for empty file */
/* save the path name for error messages */
/* compute the flags for open() */
/* open the file with the appropriate flags (or just use fd) */
/* simplify later checks */
/* save the current position for rewinding (only if reading) */
/* initialize stream */
/* return stream */
/* -- see zlib.h -- */
/* -- see zlib.h -- */
/* -- see zlib.h -- */
/* identifier for error messages */
/* for debugging */
/* for debugging */
/* -- see zlib.h -- */
/* -- see zlib.h -- */
/* get internal structure and check integrity */
/* make sure we haven't already allocated memory */
/* check and set requested size */
/* need two bytes to check magic header */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're reading and that there's no error */
/* back up and start over */
/* -- see zlib.h -- */
/* get internal structure and check integrity */
/* check that there's no error */
/* can only seek from start or relative to current position */
/* normalize offset to a SEEK_CUR specification */
/* if within raw area while reading, just go there */
/* calculate skip amount, rewinding if needed for back seek when reading */
/* writing -- can't go backwards */
/* before start of file! */
/* rewind, then skip to offset */
/* if reading, skip what's in output buffer (one less gzgetc() check) */
/* request skip (if not zero) */
/* -- see zlib.h -- */
/* -- see zlib.h -- */
/* get internal structure and check integrity */
/* return position */
/* -- see zlib.h -- */
/* -- see zlib.h -- */
/* get internal structure and check integrity */
/* compute and return effective offset in file */
/* reading */
/* don't count buffered input */
/* -- see zlib.h -- */
/* -- see zlib.h -- */
/* get internal structure and check integrity */
/* return end-of-file state */
/* -- see zlib.h -- */
/* get internal structure and check integrity */
/* return error information */
/* -- see zlib.h -- */
/* get internal structure and check integrity */
/* clear error and end-of-file */
/* Create an error message in allocated memory and set state->err and
/* free previously allocated message and clear */
/* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */
/* set error code, and if no message, then done */
/* for an out of memory error, return literal string when requested */
/* construct error message with path */
/* portably return maximum value for an int (when limits.h presumed not
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\gzread.c
/* gzread.c -- zlib functions for reading gzip files
/* Local functions */
/* Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from
/* Load up input buffer and set eof flag if last data loaded -- return -1 on
/* copy what's there to the start */
/* Look for gzip header, set up for inflate or copy.  state->x.have must be 0.
/* allocate read buffers and inflate memory */
/* allocate buffers */
/* allocate inflate memory */
/* gunzip */
/* get at least the magic bytes in the input buffer */
/* look for gzip magic bytes -- if there, do gzip decoding (note: there is
/* no gzip header -- if we were decoding gzip before, then this is trailing
/* doing raw i/o, copy any leftover input to output -- this assumes that
/* Decompress from input to the provided next_out and avail_out in the state.
/* fill output buffer up to end of deflate stream */
/* get more input for inflate() */
/* decompress and handle errors */
/* deflate stream invalid */
/* update available output */
/* if the gzip stream completed successfully, look for another */
/* good decompression */
/* Fetch data and put it in the output buffer.  Assumes state->x.have is 0.
/* -> LOOK, COPY (only if never GZIP), or GZIP */
/* -> COPY */
/* -> GZIP or LOOK (if end of gzip stream) */
/* Skip len uncompressed bytes of output.  Return -1 on error, 0 on success. */
/* skip over len bytes or reach end-of-file, whichever comes first */
/* skip over whatever is in output buffer */
/* output buffer empty -- return if we're at the end of the input */
/* need more data to skip -- load up output buffer */
/* get more output, looking for header if required */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're reading and that there's no (serious) error */
/* since an int is returned, make sure len fits in one, otherwise return
/* if len is zero, avoid unnecessary operations */
/* process a skip request */
/* get len bytes to buf, or less than len if at the end */
/* first just try copying data from the output buffer */
/* output buffer empty -- return if we're at the end of the input */
/* tried to read past end */
/* need output data -- for small len or new stream load up our output
/* get more output, looking for header if required */
/* no progress yet -- go back to copy above */
/* the copy above assures that we will leave with space in the
/* large len -- read directly into user buffer */
/* read directly */
/* large len -- decompress directly into user buffer */
/* state->how == GZIP */
/* update progress */
/* return number of bytes read into user buffer (will fit in int) */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're reading and that there's no (serious) error */
/* try output buffer (no need to check for skip request) */
/* nothing there -- try gzread() */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're reading and that there's no (serious) error */
/* process a skip request */
/* can't push EOF */
/* if output buffer empty, put byte at end (allows more pushing) */
/* if no room, give up (must have already done a gzungetc()) */
/* slide output data if needed and insert byte before existing data */
/* -- see zlib.h -- */
/* check parameters and get internal structure */
/* check that we're reading and that there's no (serious) error */
/* process a skip request */
/* copy output bytes up to new line or len - 1, whichever comes first --
/* assure that something is in the output buffer */
/* error */
/* end of file */
/* read past end */
/* return what we have */
/* look for end-of-line in current output buffer */
/* copy through end-of-line, or remainder if not found */
/* return terminated string, or if nothing, end of file */
/* -- see zlib.h -- */
/* get internal structure */
/* if the state is not known, but we can find out, then do so (this is
/* return 1 if transparent, 0 if processing a gzip stream */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're reading */
/* free memory and close file */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\gzwrite.c
/* gzwrite.c -- zlib functions for writing gzip files
/* Local functions */
/* Initialize state for writing a gzip file.  Mark initialization by setting
/* allocate input buffer */
/* only need output buffer and deflate state if compressing */
/* allocate output buffer */
/* allocate deflate memory, set up for gzip compression */
/* mark state as initialized */
/* initialize write buffer if compressing */
/* Compress whatever is at avail_in and next_in and write to the output file.
/* allocate memory if this is the first time through */
/* write directly if requested */
/* run deflate() on provided input until it produces no more output */
/* write out current buffer contents if full, or if flushing, but if
/* compress */
/* if that completed a deflate stream, allow another to start */
/* all done, no errors */
/* Compress len zeros to output.  Return -1 on error, 0 on success. */
/* consume whatever's left in the input buffer */
/* compress len zeros (len guaranteed > 0) */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're writing and that there's no error */
/* since an int is returned, make sure len fits in one, otherwise return
/* if len is zero, avoid unnecessary operations */
/* allocate memory if this is the first time through */
/* check for seek request */
/* for small len, copy to input buffer, otherwise compress directly */
/* copy to input buffer, compress when full */
/* consume whatever's left in the input buffer */
/* directly compress user buffer to file */
/* input was all buffered or compressed (put will fit in int) */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're writing and that there's no error */
/* check for seek request */
/* try writing to input buffer for speed (state->size == 0 if buffer not
/* no room in buffer or not initialized, use gz_write() */
/* -- see zlib.h -- */
/* write string */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're writing and that there's no error */
/* make sure we have some buffer space */
/* check for seek request */
/* consume whatever's left in the input buffer */
/* do the printf() into the input buffer, put length in len */
/* check that printf() results fit in buffer */
/* update buffer and position, defer compression until needed */
/* !STDC && !Z_HAVE_STDARG_H */
/* -- see zlib.h -- */
/* get internal structure */
/* check that can really pass pointer in ints */
/* check that we're writing and that there's no error */
/* make sure we have some buffer space */
/* check for seek request */
/* consume whatever's left in the input buffer */
/* do the printf() into the input buffer, put length in len */
/* check that printf() results fit in buffer */
/* update buffer and position, defer compression until needed */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're writing and that there's no error */
/* check flush parameter */
/* check for seek request */
/* compress remaining data with requested flush */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're writing and that there's no error */
/* if no change is requested, then do nothing */
/* check for seek request */
/* change compression parameters for subsequent input */
/* flush previous input with previous parameters before changing */
/* -- see zlib.h -- */
/* get internal structure */
/* check that we're writing */
/* check for seek request */
/* flush, free memory, and close file */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\infback.c
/* infback.c -- inflate using a call-back interface
/*
/* function prototypes */
/*
/* in case we return an error */
/*
/* build fixed huffman tables if first call (may not be thread safe) */
/* literal/length table */
/* distance table */
/* do this just once */
/* !BUILDFIXED */
/* BUILDFIXED */
/* Macros for inflateBack(): */
/* Load returned state from inflate_fast() */
/* Set state from registers for inflate_fast() */
/* Clear the input bit accumulator */
/* Assure that some input is available.  If input is requested, but denied,
/* Get a byte of input into the bit accumulator, or return from inflateBack()
/* Assure that there are at least n bits in the bit accumulator.  If there is
/* Return the low n bits of the bit accumulator (n < 16) */
/* Remove n bits from the bit accumulator */
/* Remove zero to seven bits as needed to go to a byte boundary */
/* Assure that some output space is available, by writing out the window
/*
/* next input */
/* next output */
/* available input and output */
/* bit buffer */
/* bits in bit buffer */
/* number of stored or match bytes to copy */
/* where to copy match bytes from */
/* current decoding table entry */
/* parent table entry */
/* length to copy for repeats, bits to drop */
/* return code */
/* permutation of code lengths */
/* Check that the strm exists and that the state was initialized */
/* Reset the state */
/* Inflate until end of block marked as last */
/* determine and dispatch block type */
/* stored block */
/* fixed block */
/* decode codes */
/* dynamic block */
/* get and verify stored block length */
/* go to byte boundary */
/* copy stored block from input to output */
/* get dynamic table entries descriptor */
/* get code length code lengths (not a typo) */
/* get length and distance code code lengths */
/* handle error breaks in while */
/* check for end-of-block code (better have one) */
/* build code tables -- note: do not change the lenbits or distbits
/* use inflate_fast() if we have enough input and output */
/* get a literal, length, or end-of-block code */
/* process literal */
/* process end of block */
/* invalid code */
/* length code -- get extra bits, if any */
/* get distance code */
/* get distance extra bits, if any */
/* copy match from window to output */
/* inflate stream terminated properly -- write leftover output */
/* can't happen, but makes compilers happy */
/* Return unused input */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\inffast.c
/* inffast.c -- fast decoding
/* Allow machine dependent optimization for post-increment or pre-increment.
/*
/* inflate()'s starting value for strm->avail_out */
/* local strm->next_in */
/* have enough input while in < last */
/* local strm->next_out */
/* inflate()'s initial strm->next_out */
/* while out < end, enough space available */
/* maximum distance from zlib header */
/* window size or zero if not using window */
/* valid bytes in the window */
/* window write index */
/* allocated sliding window, if wsize != 0 */
/* local strm->hold */
/* local strm->bits */
/* local strm->lencode */
/* local strm->distcode */
/* mask for first level of length codes */
/* mask for first level of distance codes */
/* retrieved table entry */
/* code bits, operation, extra bits, or */
/*  window position, window bytes to copy */
/* match length, unused bytes */
/* match distance */
/* where to copy match from */
/* copy state to local variables */
/* decode literals and length/distances until end-of-block or not enough
/* literal */
/* length base */
/* number of extra bits */
/* distance base */
/* number of extra bits */
/* max distance in output */
/* see if copy from window */
/* distance back in window */
/* very common case */
/* some from window */
/* rest from output */
/* wrap around window */
/* some from end of window */
/* some from start of window */
/* rest from output */
/* contiguous in window */
/* some from window */
/* rest from output */
/* copy direct from output */
/* minimum length is three */
/* 2nd level distance code */
/* 2nd level length code */
/* end-of-block */
/* return unused bytes (on entry, bits < 8, so in won't go too far back) */
/* update state and return */
/*
/* !ASMINF */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\inflate.c
/* inflate.c -- zlib decompression
/*
/* function prototypes */
/* to support ill-conceived Java test suite */
/* get the state */
/* extract wrap request from windowBits parameter */
/* set number of window bits, free window if different */
/* update state and reset the rest of it */
/* in case we return an error */
/*
/* build fixed huffman tables if first call (may not be thread safe) */
/* literal/length table */
/* distance table */
/* do this just once */
/* !BUILDFIXED */
/* BUILDFIXED */
/*
/* inffixed.h -- table for decoding fixed codes");
/* WARNING: this file should *not* be used by applications.");
/* MAKEFIXED */
/*
/* if it hasn't been done already, allocate space for the window */
/* if window not in use yet, initialize */
/* copy state->wsize or less output bytes into the circular window */
/* Macros for inflate(): */
/* check function to use adler32() for zlib or crc32() for gzip */
/* check macros for header crc */
/* Load registers with state in inflate() for speed */
/* Restore state from registers in inflate() */
/* Clear the input bit accumulator */
/* Get a byte of input into the bit accumulator, or return from inflate()
/* Assure that there are at least n bits in the bit accumulator.  If there is
/* Return the low n bits of the bit accumulator (n < 16) */
/* Remove n bits from the bit accumulator */
/* Remove zero to seven bits as needed to go to a byte boundary */
/*
/* next input */
/* next output */
/* available input and output */
/* bit buffer */
/* bits in bit buffer */
/* save starting available input and output */
/* number of stored or match bytes to copy */
/* where to copy match bytes from */
/* current decoding table entry */
/* parent table entry */
/* length to copy for repeats, bits to drop */
/* return code */
/* buffer for gzip header crc calculation */
/* permutation of code lengths */
/* skip check */
/* gzip header */
/* expect zlib header */
/* check if zlib header allowed */
/* stored block */
/* fixed block */
/* decode codes */
/* dynamic block */
/* go to byte boundary */
/* handle error breaks in while */
/* check for end-of-block code (better have one) */
/* build code tables -- note: do not change the lenbits or distbits
/* copy from window */
/* copy from output */
/*
/* check state */
/* copy dictionary */
/* check state */
/* check for correct dictionary identifier */
/* copy dictionary to window using updatewindow(), which will amend the
/* check state */
/* save header structure */
/*
/* number of bytes to look at or looked at */
/* temporary to save total_in and total_out */
/* to restore bit buffer to byte string */
/* check parameters */
/* if first time, start search in bit buffer */
/* search available input */
/* return no joy or set up to restart inflate() on a new block */
/*
/* check input */
/* allocate space */
/* copy state */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\inftrees.c
/* inftrees.c -- generate Huffman trees for efficient decoding
/*
/*
/* a code's length in bits */
/* index of code symbols */
/* minimum and maximum code lengths */
/* number of index bits for root table */
/* number of index bits for current table */
/* code bits to drop for sub-table */
/* number of prefix codes available */
/* code entries in table used */
/* Huffman code */
/* for incrementing code, index */
/* index for replicating entries */
/* low bits for current root entry */
/* mask for low root bits */
/* table entry for duplication */
/* next available space in table */
/* base value table to use */
/* extra bits table to use */
/* use base and extra for symbol > end */
/* number of codes of each length */
/* offsets in table for each length */
/* Length codes 257..285 base */
/* Length codes 257..285 extra */
/* Distance codes 0..29 base */
/* Distance codes 0..29 extra */
/*
/* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
/* bound code lengths, force root to be within code lengths */
/* no symbols to code at all */
/* invalid code marker */
/* make a table to force an error */
/* no symbols, but wait for decoding to report error */
/* check for an over-subscribed or incomplete set of lengths */
/* over-subscribed */
/* incomplete set */
/* generate offsets into symbol table for each length for sorting */
/* sort symbols by length, by symbol order within each length */
/*
/* set up for code type */
/* dummy value--not used */
/* DISTS */
/* initialize state for loop */
/* starting code */
/* starting code symbol */
/* starting code length */
/* current table to fill in */
/* current table index bits */
/* current bits to drop from code for index */
/* trigger new sub-table when len > root */
/* use root table entries */
/* mask for comparing low */
/* check available table space */
/* process all codes and make table entries */
/* create table entry */
/* end of block */
/* replicate for those indices with low len bits equal to huff */
/* save offset to next table */
/* backwards increment the len-bit code huff */
/* go to next symbol, update count, len */
/* create new sub-table if needed */
/* if first time, transition to sub-tables */
/* increment past last table */
/* here min is 1 << curr */
/* determine length of next table */
/* check for enough space */
/* point entry in root table to sub-table */
/* fill in remaining table entry if code is incomplete (guaranteed to have
/* invalid code marker */
/* set return parameters */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\trees.c
/* trees.c -- output deflated data using Huffman coding
/*
/* @(#) $Id$ */
/* #define GEN_TREES_H */
/* ===========================================================================
/* Bit length codes must not exceed MAX_BL_BITS bits */
/* end of block literal code */
/* repeat previous bit length 3-6 times (2 bits of repeat count) */
/* repeat a zero length 3-10 times  (3 bits of repeat count) */
/* repeat a zero length 11-138 times  (7 bits of repeat count) */
/* extra bits for each length code */
/* extra bits for each distance code */
/* extra bits for each bit length code */
/* The lengths of the bit length codes are sent in order of decreasing
/* ===========================================================================
/* see definition of array dist_code below */
/* non ANSI compilers may not accept trees.h */
/* The static literal tree. Since the bit lengths are imposed, there is no
/* The static distance tree. (Actually a trivial tree since all codes use
/* Distance codes. The first 256 values correspond to the distances
/* length code for each normalized match length (0 == MIN_MATCH) */
/* First normalized length for each code (0 = MIN_MATCH) */
/* First normalized distance for each code (0 = distance of 1) */
/* GEN_TREES_H */
/* static tree or NULL */
/* extra bits for each code or NULL */
/* base index for extra_bits */
/* max number of elements in the tree */
/* max bit length for the codes */
/* ===========================================================================
/* Send a code of the given tree. c and tree must not have side effects */
/* DEBUG */
/* ===========================================================================
/* ===========================================================================
/* value to send */
/* number of bits */
/* If not enough room in bi_buf, use (valid) bits from bi_buf and
/* !DEBUG */
/* DEBUG */
/* the arguments must not have side effects */
/* ===========================================================================
/* iterates over tree elements */
/* bit counter */
/* length value */
/* code value */
/* distance index */
/* number of codes at each bit length for an optimal tree */
/* For some embedded targets, global variables are not initialized: */
/* Initialize the mapping length (0..255) -> length code (0..28) */
/* Note that the length 255 (match length 258) can be represented
/* Initialize the mapping dist (0..32K) -> dist code (0..29) */
/* from now on, all distances are divided by 128 */
/* Construct the codes of the static literal tree */
/* Codes 286 and 287 do not exist, but we must include them in the
/* The static distance tree is trivial: */
/* defined(GEN_TREES_H) || !defined(STDC) */
/* ===========================================================================
/* header created automatically with -DGEN_TREES_H */\n\n");
/* GEN_TREES_H */
/* ===========================================================================
/* Initialize the first block of the first file: */
/* ===========================================================================
/* iterates over tree elements */
/* Initialize the trees. */
/* Index within the heap array of least frequent node in the Huffman tree */
/* ===========================================================================
/* ===========================================================================
/* ===========================================================================
/* the tree to restore */
/* node to move down */
/* left son of k */
/* Set j to the smallest of the two sons: */
/* Exit if v is smaller than both sons */
/* Exchange v with the smallest son */
/* And continue down the tree, setting j to the left son of k */
/* ===========================================================================
/* the tree descriptor */
/* heap index */
/* iterate over the tree elements */
/* bit length */
/* extra bits */
/* frequency */
/* number of elements with bit length too large */
/* In a first pass, compute the optimal bit lengths (which may
/* root of the heap */
/* We overwrite tree[n].Dad which is no longer needed */
/* not a leaf node */
/* This happens for example on obj2 and pic of the Calgary corpus */
/* Find the first bit length which could increase: */
/* move one leaf down the tree */
/* move one overflow item as its brother */
/* The brother of the overflow item also moves one step up,
/* Now recompute all bit lengths, scanning in increasing frequency.
/* ===========================================================================
/* the tree to decorate */
/* largest code with non zero frequency */
/* number of codes at each bit length */
/* next code value for each bit length */
/* running code value */
/* bit index */
/* code index */
/* The distribution counts are first used to generate the code values
/* Check that the bit counts in bl_count are consistent. The last code
/* Now reverse the bits */
/* ===========================================================================
/* the tree descriptor */
/* iterate over heap elements */
/* largest code with non zero frequency */
/* new node being created */
/* Construct the initial heap, with least frequent element in
/* The pkzip format requires that at least one distance code exists,
/* node is 0 or 1 so it does not have extra bits */
/* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
/* Construct the Huffman tree by repeatedly combining the least two
/* next internal node of the tree */
/* n = node of least frequency */
/* m = node of next least frequency */
/* keep the nodes sorted by frequency */
/* Create a new node father of n and m */
/* and insert the new node in the heap */
/* At this point, the fields freq and dad are set. We can now
/* The field len is now set, we can generate the bit codes */
/* ===========================================================================
/* the tree to be scanned */
/* and its largest code of non zero frequency */
/* iterates over all tree elements */
/* last emitted length */
/* length of current code */
/* length of next code */
/* repeat count of the current code */
/* max repeat count */
/* min repeat count */
/* guard */
/* ===========================================================================
/* the tree to be scanned */
/* and its largest code of non zero frequency */
/* iterates over all tree elements */
/* last emitted length */
/* length of current code */
/* length of next code */
/* repeat count of the current code */
/* max repeat count */
/* min repeat count */
/* tree[max_code+1].Len = -1; */  /* guard already set */
/* ===========================================================================
/* index of last bit length code of non zero freq */
/* Determine the bit length frequencies for literal and distance trees */
/* Build the bit length tree: */
/* opt_len now includes the length of the tree representations, except
/* Determine the number of bit length codes to send. The pkzip format
/* Update opt_len to include the bit length tree and counts */
/* ===========================================================================
/* number of codes for each tree */
/* index in bl_order */
/* not +255 as stated in appnote.txt */
/* not -3 as stated in appnote.txt */
/* literal tree */
/* distance tree */
/* ===========================================================================
/* input block */
/* length of input block */
/* one if this is the last block for a file */
/* send block type */
/* with header */
/* ===========================================================================
/* ===========================================================================
/* 3 for block type, 7 for EOB */
/* ===========================================================================
/* input block, or NULL if too old */
/* length of input block */
/* one if this is the last block for a file */
/* opt_len and static_len in bytes */
/* index of last bit length code of non zero freq */
/* Build the Huffman trees unless a stored block is forced */
/* Check if the file is binary or text */
/* Construct the literal and distance trees */
/* At this point, opt_len and static_len are the total bit lengths of
/* Build the bit length tree for the above two trees, and get the index
/* Determine the best encoding. Compute the block lengths in bytes. */
/* force a stored block */
/* force stored block */
/* 4: two words for the lengths */
/* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
/* force static trees */
/* The above check is made mod 2^32, for files larger than 512 MB
/* align on byte boundary */
/* ===========================================================================
/* distance of matched string */
/* match length-MIN_MATCH or unmatched char (if dist==0) */
/* lc is the unmatched char */
/* Here, lc is the match length - MIN_MATCH */
/* dist = match distance - 1 */
/* Try to guess if it is profitable to stop the current block here */
/* Compute an upper bound for the compressed length */
/* We avoid equality with lit_bufsize because of wraparound at 64K
/* ===========================================================================
/* literal tree */
/* distance tree */
/* distance of matched string */
/* match length or unmatched char (if dist == 0) */
/* running index in l_buf */
/* the code to send */
/* number of extra bits to send */
/* send a literal byte */
/* Here, lc is the match length - MIN_MATCH */
/* send the length code */
/* send the extra length bits */
/* dist is now the match distance - 1 */
/* send the distance code */
/* send the extra distance bits */
/* literal or match pair ? */
/* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
/* ===========================================================================
/* black_mask is the bit mask of black-listed bytes
/* Check for non-textual ("black-listed") bytes. */
/* Check for textual ("white-listed") bytes. */
/* There are no "black-listed" or "white-listed" bytes:
/* ===========================================================================
/* the value to invert */
/* its bit length */
/* ===========================================================================
/* ===========================================================================
/* ===========================================================================
/* the input data */
/* its length */
/* true if block header must be written */
/* align on byte boundary */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\uncompr.c
/* uncompr.c -- decompress a memory buffer
/* @(#) $Id$ */
/* ===========================================================================
/* Check for source > 64K on 16-bit machine: */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\zutil.c
/* zutil.c -- target dependent utility functions for the compression library
/* @(#) $Id$ */
/* for buggy compilers */
/* Z_NEED_DICT       2  */
/* Z_STREAM_END      1  */
/* Z_OK              0  */
/* Z_ERRNO         (-1) */
/* Z_STREAM_ERROR  (-2) */
/* Z_DATA_ERROR    (-3) */
/* Z_MEM_ERROR     (-4) */
/* Z_BUF_ERROR     (-5) */
/* Z_VERSION_ERROR (-6) */
/* exported to allow conversion of error code to string for compress() and
/* The Microsoft C Run-Time Library for Windows CE doesn't have
/* ??? to be unrolled */
/* ??? to be unrolled */
/* Turbo C in 16-bit mode */
/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
/* 10*64K = 640K */
/* This table is used to remember the original form of pointers
/* just to make some compilers happy */
/* If we allocate less than 65520 bytes, we assume that farmalloc
/* Normalize the pointer to seg:0 */
/* object < 64K */
/* Find the original pointer */
/* just to make some compilers happy */
/* __TURBOC__ */
/* Microsoft C in 16-bit mode */
/* to make compiler happy */
/* to make compiler happy */
/* M_I86 */
/* SYS16BIT */
/* Any system without a special alloc function */
/* make compiler happy */
/* make compiler happy */
/* MY_ZCALLOC */
/* !Z_SOLO */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\blast\blast.c
/* blast.c
/*
/* for setjmp(), longjmp(), and jmp_buf */
/* prototype for blast() */
/* for local function definitions */
/* maximum code length */
/* maximum window size */
/* input and output state */
/* input state */
/* input function provided by user */
/* opaque information passed to infun() */
/* next input location */
/* available input at in */
/* bit buffer */
/* number of bits in bit buffer */
/* input limit error return state for bits() and decode() */
/* output state */
/* output function provided by user */
/* opaque information passed to outfun() */
/* index of next write location in out[] */
/* true to check distances (for first 4K) */
/* output buffer and sliding window */
/*
/* bit accumulator */
/* load at least need bits into val */
/* out of input */
/* load eight bits */
/* drop need bits and update buffer, always zero to seven bits left */
/* return need bits, zeroing the bits above that */
/*
/* number of symbols of each length */
/* canonically ordered symbols */
/*
/* current number of bits in code */
/* len bits being decoded */
/* first code of length len */
/* number of codes of length len */
/* index of first code of length len in symbol table */
/* bits from stream */
/* bits left in next or left to process */
/* next number of codes */
/* invert code */
/* if length len, return symbol */
/* else update for next length */
/* out of input */
/* ran out of codes */
/*
/* current symbol when stepping through length[] */
/* current length when stepping through h->count[] */
/* number of possible codes left of current length */
/* offsets in symbol table for each length */
/* code lengths */
/* convert compact repeat counts into symbol bit length list */
/* count number of codes of each length */
/* assumes lengths are within bounds */
/* no codes! */
/* complete, but decode() will fail */
/* check for an over-subscribed or incomplete set of lengths */
/* one possible code of zero length */
/* one more bit, double codes left */
/* deduct count from possible codes */
/* over-subscribed--return negative */
/* left > 0 means incomplete */
/* generate offsets into symbol table for each length for sorting */
/*
/* return zero for complete set, positive for incomplete set */
/*
/* true if literals are coded */
/* log2(dictionary size) - 6 */
/* decoded symbol, extra bits for distance */
/* length for copy */
/* distance for copy */
/* copy counter */
/* copy pointers */
/* build tables once */
/* litcode memory */
/* lencode memory */
/* distcode memory */
/* length code */
/* length code */
/* distance code */
/* bit lengths of literal codes */
/* bit lengths of length codes 0..15 */
/* bit lengths of distance codes 0..63 */
/* base for length codes */
/* extra bits for length codes */
/* set up decoding tables (once--might not be thread-safe) */
/* read header */
/* decode literals and length/distance pairs */
/* get length */
/* end code */
/* get distance */
/* distance too far back */
/* copy length bytes from distance bytes back */
/* get literal and write it */
/* See comments in blast.h */
/* input/output state */
/* return value */
/* initialize input state */
/* initialize output state */
/* return if bits() or decode() tries to read past available input */
/* if came back here via longjmp(), */
/*  then skip decomp(), return error */
/* decompress */
/* write any leftover output and update the error code if needed */
/* Example of how to use blast() */
/* Decompress a PKWare Compression Library stream from stdin to stdout */
/* decompress to stdout */
/* see if there are any leftover bytes */
/* return blast() error code */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\dotzlib\DotZLib\AssemblyInfo.cs
//
// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers
// by using the '*' as shown below:
//
// In order to sign your assembly you must specify a key to use. Refer to the
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing.
//
// Notes:
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\dotzlib\DotZLib\ChecksumImpl.cs
//
//  Copyright Henrik Ravn 2004
//
// Use, modification and distribution are subject to the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
/// <summary>
/// Implements the common functionality needed for all <see cref="ChecksumGenerator"/>s
/// </summary>
/// <example></example>
/// <summary>
/// The value of the current checksum
/// </summary>
/// <summary>
/// Initializes a new instance of the checksum generator base - the current checksum is
/// set to zero
/// </summary>
/// <summary>
/// Initializes a new instance of the checksum generator basewith a specified value
/// </summary>
/// <param name="initialValue">The value to set the current checksum to</param>
/// <summary>
/// Resets the current checksum to zero
/// </summary>
/// <summary>
/// Gets the current checksum value
/// </summary>
/// <summary>
/// Updates the current checksum with part of an array of bytes
/// </summary>
/// <param name="data">The data to update the checksum with</param>
/// <param name="offset">Where in <c>data</c> to start updating</param>
/// <param name="count">The number of bytes from <c>data</c> to use</param>
/// <exception cref="ArgumentException">The sum of offset and count is larger than the length of <c>data</c></exception>
/// <exception cref="NullReferenceException"><c>data</c> is a null reference</exception>
/// <exception cref="ArgumentOutOfRangeException">Offset or count is negative.</exception>
/// <remarks>All the other <c>Update</c> methods are implmeneted in terms of this one.
/// This is therefore the only method a derived class has to implement</remarks>
/// <summary>
/// Updates the current checksum with an array of bytes.
/// </summary>
/// <param name="data">The data to update the checksum with</param>
/// <summary>
/// Updates the current checksum with the data from a string
/// </summary>
/// <param name="data">The string to update the checksum with</param>
/// <remarks>The characters in the string are converted by the UTF-8 encoding</remarks>
/// <summary>
/// Updates the current checksum with the data from a string, using a specific encoding
/// </summary>
/// <param name="data">The string to update the checksum with</param>
/// <param name="encoding">The encoding to use</param>
/// <summary>
/// Implements a CRC32 checksum generator
/// </summary>
/// <summary>
/// Initializes a new instance of the CRC32 checksum generator
/// </summary>
/// <summary>
/// Initializes a new instance of the CRC32 checksum generator with a specified value
/// </summary>
/// <param name="initialValue">The value to set the current checksum to</param>
/// <summary>
/// Updates the current checksum with part of an array of bytes
/// </summary>
/// <param name="data">The data to update the checksum with</param>
/// <param name="offset">Where in <c>data</c> to start updating</param>
/// <param name="count">The number of bytes from <c>data</c> to use</param>
/// <exception cref="ArgumentException">The sum of offset and count is larger than the length of <c>data</c></exception>
/// <exception cref="NullReferenceException"><c>data</c> is a null reference</exception>
/// <exception cref="ArgumentOutOfRangeException">Offset or count is negative.</exception>
/// <summary>
/// Implements a checksum generator that computes the Adler checksum on data
/// </summary>
/// <summary>
/// Initializes a new instance of the Adler checksum generator
/// </summary>
/// <summary>
/// Initializes a new instance of the Adler checksum generator with a specified value
/// </summary>
/// <param name="initialValue">The value to set the current checksum to</param>
/// <summary>
/// Updates the current checksum with part of an array of bytes
/// </summary>
/// <param name="data">The data to update the checksum with</param>
/// <param name="offset">Where in <c>data</c> to start updating</param>
/// <param name="count">The number of bytes from <c>data</c> to use</param>
/// <exception cref="ArgumentException">The sum of offset and count is larger than the length of <c>data</c></exception>
/// <exception cref="NullReferenceException"><c>data</c> is a null reference</exception>
/// <exception cref="ArgumentOutOfRangeException">Offset or count is negative.</exception>
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\dotzlib\DotZLib\CircularBuffer.cs
//
//  Copyright Henrik Ravn 2004
//
// Use, modification and distribution are subject to the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
/// <summary>
/// This class implements a circular buffer
/// </summary>
// no room
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\dotzlib\DotZLib\CodecBase.cs
//
//  Copyright Henrik Ravn 2004
//
// Use, modification and distribution are subject to the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
/// <summary>
/// Implements the common functionality needed for all <see cref="Codec"/>s
/// </summary>
/// <summary>
/// Instance of the internal zlib buffer structure that is
/// passed to all functions in the zlib dll
/// </summary>
/// <summary>
/// True if the object instance has been disposed, false otherwise
/// </summary>
/// <summary>
/// The size of the internal buffers
/// </summary>
/// <summary>
/// Initializes a new instance of the <c>CodeBase</c> class.
/// </summary>
/// <summary>
/// Occurs when more processed data are available.
/// </summary>
/// <summary>
/// Fires the <see cref="DataAvailable"/> event
/// </summary>
/// <summary>
/// Adds more data to the codec to be processed.
/// </summary>
/// <param name="data">Byte array containing the data to be added to the codec</param>
/// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>
/// <summary>
/// Adds more data to the codec to be processed.
/// </summary>
/// <param name="data">Byte array containing the data to be added to the codec</param>
/// <param name="offset">The index of the first byte to add from <c>data</c></param>
/// <param name="count">The number of bytes to add</param>
/// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>
/// <remarks>This must be implemented by a derived class</remarks>
/// <summary>
/// Finishes up any pending data that needs to be processed and handled.
/// </summary>
/// <remarks>This must be implemented by a derived class</remarks>
/// <summary>
/// Gets the checksum of the data that has been added so far
/// </summary>
/// <summary>
/// Destroys this instance
/// </summary>
/// <summary>
/// Releases any unmanaged resources and calls the <see cref="CleanUp()"/> method of the derived class
/// </summary>
/// <summary>
/// Performs any codec specific cleanup
/// </summary>
/// <remarks>This must be implemented by a derived class</remarks>
// performs the release of the handles and calls the dereived CleanUp()
/// <summary>
/// Copies a number of bytes to the internal codec buffer - ready for proccesing
/// </summary>
/// <param name="data">The byte array that contains the data to copy</param>
/// <param name="startIndex">The index of the first byte to copy</param>
/// <param name="count">The number of bytes to copy from <c>data</c></param>
/// <summary>
/// Resets the internal output buffers to a known state - ready for processing
/// </summary>
/// <summary>
/// Updates the running checksum property
/// </summary>
/// <param name="newSum">The new checksum value</param>
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\dotzlib\DotZLib\Deflater.cs
//
//  Copyright Henrik Ravn 2004
//
// Use, modification and distribution are subject to the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
/// <summary>
/// Implements a data compressor, using the deflate algorithm in the ZLib dll
/// </summary>
/// <summary>
/// Constructs an new instance of the <c>Deflater</c>
/// </summary>
/// <param name="level">The compression level to use for this <c>Deflater</c></param>
/// <summary>
/// Adds more data to the codec to be processed.
/// </summary>
/// <param name="data">Byte array containing the data to be added to the codec</param>
/// <param name="offset">The index of the first byte to add from <c>data</c></param>
/// <param name="count">The number of bytes to add</param>
/// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>
/// <summary>
/// Finishes up any pending data that needs to be processed and handled.
/// </summary>
/// <summary>
/// Closes the internal zlib deflate stream
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\dotzlib\DotZLib\DotZLib.cs
//
//  Copyright Henrik Ravn 2004
//
// Use, modification and distribution are subject to the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
/// <summary>
/// Defines constants for the various flush types used with zlib
/// </summary>
// internal mapping of the zlib zstream structure for marshalling
/// <summary>
/// Defines constants for the available compression levels in zlib
/// </summary>
/// <summary>
/// The default compression level with a reasonable compromise between compression and speed
/// </summary>
/// <summary>
/// No compression at all. The data are passed straight through.
/// </summary>
/// <summary>
/// The maximum compression rate available.
/// </summary>
/// <summary>
/// The fastest available compression level.
/// </summary>
/// <summary>
/// The exception that is thrown when an error occurs on the zlib dll
/// </summary>
/// <summary>
/// Initializes a new instance of the <see cref="ZLibException"/> class with a specified
/// error message and error code
/// </summary>
/// <param name="errorCode">The zlib error code that caused the exception</param>
/// <param name="msg">A message that (hopefully) describes the error</param>
/// <summary>
/// Initializes a new instance of the <see cref="ZLibException"/> class with a specified
/// error code
/// </summary>
/// <param name="errorCode">The zlib error code that caused the exception</param>
/// <summary>
/// Declares methods and properties that enables a running checksum to be calculated
/// </summary>
/// <summary>
/// Gets the current value of the checksum
/// </summary>
/// <summary>
/// Clears the current checksum to 0
/// </summary>
/// <summary>
/// Updates the current checksum with an array of bytes
/// </summary>
/// <param name="data">The data to update the checksum with</param>
/// <summary>
/// Updates the current checksum with part of an array of bytes
/// </summary>
/// <param name="data">The data to update the checksum with</param>
/// <param name="offset">Where in <c>data</c> to start updating</param>
/// <param name="count">The number of bytes from <c>data</c> to use</param>
/// <exception cref="ArgumentException">The sum of offset and count is larger than the length of <c>data</c></exception>
/// <exception cref="ArgumentNullException"><c>data</c> is a null reference</exception>
/// <exception cref="ArgumentOutOfRangeException">Offset or count is negative.</exception>
/// <summary>
/// Updates the current checksum with the data from a string
/// </summary>
/// <param name="data">The string to update the checksum with</param>
/// <remarks>The characters in the string are converted by the UTF-8 encoding</remarks>
/// <summary>
/// Updates the current checksum with the data from a string, using a specific encoding
/// </summary>
/// <param name="data">The string to update the checksum with</param>
/// <param name="encoding">The encoding to use</param>
/// <summary>
/// Represents the method that will be called from a codec when new data
/// are available.
/// </summary>
/// <paramref name="data">The byte array containing the processed data</paramref>
/// <paramref name="startIndex">The index of the first processed byte in <c>data</c></paramref>
/// <paramref name="count">The number of processed bytes available</paramref>
/// <remarks>On return from this method, the data may be overwritten, so grab it while you can.
/// You cannot assume that startIndex will be zero.
/// </remarks>
/// <summary>
/// Declares methods and events for implementing compressors/decompressors
/// </summary>
/// <summary>
/// Occurs when more processed data are available.
/// </summary>
/// <summary>
/// Adds more data to the codec to be processed.
/// </summary>
/// <param name="data">Byte array containing the data to be added to the codec</param>
/// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>
/// <summary>
/// Adds more data to the codec to be processed.
/// </summary>
/// <param name="data">Byte array containing the data to be added to the codec</param>
/// <param name="offset">The index of the first byte to add from <c>data</c></param>
/// <param name="count">The number of bytes to add</param>
/// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>
/// <summary>
/// Finishes up any pending data that needs to be processed and handled.
/// </summary>
/// <summary>
/// Gets the checksum of the data that has been added so far
/// </summary>
/// <summary>
/// Encapsulates general information about the ZLib library
/// </summary>
// helper function that unpacks a bitsize mask
/// <summary>
/// Constructs an instance of the <c>Info</c> class.
/// </summary>
/// <summary>
/// True if the library is compiled with debug info
/// </summary>
/// <summary>
/// True if the library is compiled with assembly optimizations
/// </summary>
/// <summary>
/// Gets the size of the unsigned int that was compiled into Zlib
/// </summary>
/// <summary>
/// Gets the size of the unsigned long that was compiled into Zlib
/// </summary>
/// <summary>
/// Gets the size of the pointers that were compiled into Zlib
/// </summary>
/// <summary>
/// Gets the size of the z_off_t type that was compiled into Zlib
/// </summary>
/// <summary>
/// Gets the version of ZLib as a string, e.g. "1.2.1"
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\dotzlib\DotZLib\GZipStream.cs
//
//  Copyright Henrik Ravn 2004
//
// Use, modification and distribution are subject to the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
/// <summary>
/// Implements a compressed <see cref="Stream"/>, in GZip (.gz) format.
/// </summary>
/// <summary>
/// Creates a new file as a writeable GZipStream
/// </summary>
/// <param name="fileName">The name of the compressed file to create</param>
/// <param name="level">The compression level to use when adding data</param>
/// <exception cref="ZLibException">If an error occurred in the internal zlib function</exception>
/// <summary>
/// Opens an existing file as a readable GZipStream
/// </summary>
/// <param name="fileName">The name of the file to open</param>
/// <exception cref="ZLibException">If an error occurred in the internal zlib function</exception>
/// <summary>
/// Returns true of this stream can be read from, false otherwise
/// </summary>
/// <summary>
/// Returns false.
/// </summary>
/// <summary>
/// Returns true if this tsream is writeable, false otherwise
/// </summary>
/// <summary>
/// Destroys this instance
/// </summary>
/// <summary>
/// Closes the external file handle
/// </summary>
// Does the actual closing of the file handle.
/// <summary>
/// Attempts to read a number of bytes from the stream.
/// </summary>
/// <param name="buffer">The destination data buffer</param>
/// <param name="offset">The index of the first destination byte in <c>buffer</c></param>
/// <param name="count">The number of bytes requested</param>
/// <returns>The number of bytes read</returns>
/// <exception cref="ArgumentNullException">If <c>buffer</c> is null</exception>
/// <exception cref="ArgumentOutOfRangeException">If <c>count</c> or <c>offset</c> are negative</exception>
/// <exception cref="ArgumentException">If <c>offset</c>  + <c>count</c> is &gt; buffer.Length</exception>
/// <exception cref="NotSupportedException">If this stream is not readable.</exception>
/// <exception cref="ObjectDisposedException">If this stream has been disposed.</exception>
/// <summary>
/// Attempts to read a single byte from the stream.
/// </summary>
/// <returns>The byte that was read, or -1 in case of error or End-Of-File</returns>
/// <summary>
/// Writes a number of bytes to the stream
/// </summary>
/// <param name="buffer"></param>
/// <param name="offset"></param>
/// <param name="count"></param>
/// <exception cref="ArgumentNullException">If <c>buffer</c> is null</exception>
/// <exception cref="ArgumentOutOfRangeException">If <c>count</c> or <c>offset</c> are negative</exception>
/// <exception cref="ArgumentException">If <c>offset</c>  + <c>count</c> is &gt; buffer.Length</exception>
/// <exception cref="NotSupportedException">If this stream is not writeable.</exception>
/// <exception cref="ObjectDisposedException">If this stream has been disposed.</exception>
/// <summary>
/// Writes a single byte to the stream
/// </summary>
/// <param name="value">The byte to add to the stream.</param>
/// <exception cref="NotSupportedException">If this stream is not writeable.</exception>
/// <exception cref="ObjectDisposedException">If this stream has been disposed.</exception>
/// <summary>
/// Not supported.
/// </summary>
/// <param name="value"></param>
/// <exception cref="NotSupportedException">Always thrown</exception>
/// <summary>
///  Not suppported.
/// </summary>
/// <param name="offset"></param>
/// <param name="origin"></param>
/// <returns></returns>
/// <exception cref="NotSupportedException">Always thrown</exception>
/// <summary>
/// Flushes the <c>GZipStream</c>.
/// </summary>
/// <remarks>In this implementation, this method does nothing. This is because excessive
/// flushing may degrade the achievable compression rates.</remarks>
// left empty on purpose
/// <summary>
/// Gets/sets the current position in the <c>GZipStream</c>. Not suppported.
/// </summary>
/// <remarks>In this implementation this property is not supported</remarks>
/// <exception cref="NotSupportedException">Always thrown</exception>
/// <summary>
/// Gets the size of the stream. Not suppported.
/// </summary>
/// <remarks>In this implementation this property is not supported</remarks>
/// <exception cref="NotSupportedException">Always thrown</exception>
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\dotzlib\DotZLib\Inflater.cs
//
//  Copyright Henrik Ravn 2004
//
// Use, modification and distribution are subject to the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
/// <summary>
/// Implements a data decompressor, using the inflate algorithm in the ZLib dll
/// </summary>
/// <summary>
/// Constructs an new instance of the <c>Inflater</c>
/// </summary>
/// <summary>
/// Adds more data to the codec to be processed.
/// </summary>
/// <param name="data">Byte array containing the data to be added to the codec</param>
/// <param name="offset">The index of the first byte to add from <c>data</c></param>
/// <param name="count">The number of bytes to add</param>
/// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>
/// <summary>
/// Finishes up any pending data that needs to be processed and handled.
/// </summary>
/// <summary>
/// Closes the internal zlib inflate stream
/// </summary>
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\dotzlib\DotZLib\UnitTests.cs
//
// © Copyright Henrik Ravn 2004
//
// Use, modification and distribution are subject to the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
// uncomment the define below to include unit tests
//#define nunit
// Unit tests for the DotZLib class library
// ----------------------------------------
//
// Use this with NUnit 2 from http://www.nunit.org
//
// helper methods
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\infback9\infback9.c
/* infback9.c -- inflate deflate64 data using a call-back interface
/*
/* in case we return an error */
/*
/* literal/length table */
/* distance table */
/* write tables */
/* inffix9.h -- table for decoding deflate64 fixed codes");
/* WARNING: this file should *not* be used by applications.");
/* MAKEFIXED */
/* Macros for inflateBack(): */
/* Clear the input bit accumulator */
/* Assure that some input is available.  If input is requested, but denied,
/* Get a byte of input into the bit accumulator, or return from inflateBack()
/* Assure that there are at least n bits in the bit accumulator.  If there is
/* Return the low n bits of the bit accumulator (n <= 16) */
/* Remove n bits from the bit accumulator */
/* Remove zero to seven bits as needed to go to a byte boundary */
/* Assure that some output space is available, by writing out the window
/*
/* next input */
/* next output */
/* available input */
/* available output */
/* current inflate mode */
/* true if processing last block */
/* true if the window has wrapped */
/* allocated sliding window, if needed */
/* bit buffer */
/* bits in bit buffer */
/* extra bits needed */
/* literal or length of data to copy */
/* distance back to copy string from */
/* number of stored or match bytes to copy */
/* where to copy match bytes from */
/* starting table for length/literal codes */
/* starting table for distance codes */
/* index bits for lencode */
/* index bits for distcode */
/* current decoding table entry */
/* parent table entry */
/* length to copy for repeats, bits to drop */
/* return code */
/* permutation of code lengths */
/* Check that the strm exists and that the state was initialized */
/* Reset the state */
/* Inflate until end of block marked as last */
/* determine and dispatch block type */
/* stored block */
/* fixed block */
/* decode codes */
/* dynamic block */
/* get and verify stored block length */
/* go to byte boundary */
/* copy stored block from input to output */
/* get dynamic table entries descriptor */
/* get code length code lengths (not a typo) */
/* get length and distance code code lengths */
/* handle error breaks in while */
/* check for end-of-block code (better have one) */
/* build code tables -- note: do not change the lenbits or distbits
/* get a literal, length, or end-of-block code */
/* process literal */
/* process end of block */
/* invalid code */
/* length code -- get extra bits, if any */
/* get distance code */
/* get distance extra bits, if any */
/* copy match from window to output */
/* inflate stream terminated properly -- write leftover output */
/* can't happen, but makes compilers happy */
/* Return unused input */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\infback9\inftree9.c
/* inftree9.c -- generate Huffman trees for efficient decoding
/*
/*
/* a code's length in bits */
/* index of code symbols */
/* minimum and maximum code lengths */
/* number of index bits for root table */
/* number of index bits for current table */
/* code bits to drop for sub-table */
/* number of prefix codes available */
/* code entries in table used */
/* Huffman code */
/* for incrementing code, index */
/* index for replicating entries */
/* low bits for current root entry */
/* mask for low root bits */
/* table entry for duplication */
/* next available space in table */
/* base value table to use */
/* extra bits table to use */
/* use base and extra for symbol > end */
/* number of codes of each length */
/* offsets in table for each length */
/* Length codes 257..285 base */
/* Length codes 257..285 extra */
/* Distance codes 0..31 base */
/* Distance codes 0..31 extra */
/*
/* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
/* bound code lengths, force root to be within code lengths */
/* no codes! */
/* check for an over-subscribed or incomplete set of lengths */
/* over-subscribed */
/* incomplete set */
/* generate offsets into symbol table for each length for sorting */
/* sort symbols by length, by symbol order within each length */
/*
/* set up for code type */
/* dummy value--not used */
/* DISTS */
/* initialize state for loop */
/* starting code */
/* starting code symbol */
/* starting code length */
/* current table to fill in */
/* current table index bits */
/* current bits to drop from code for index */
/* trigger new sub-table when len > root */
/* use root table entries */
/* mask for comparing low */
/* check available table space */
/* process all codes and make table entries */
/* create table entry */
/* end of block */
/* replicate for those indices with low len bits equal to huff */
/* backwards increment the len-bit code huff */
/* go to next symbol, update count, len */
/* create new sub-table if needed */
/* if first time, transition to sub-tables */
/* increment past last table */
/* determine length of next table */
/* check for enough space */
/* point entry in root table to sub-table */
/*
/* invalid code marker */
/* when done with sub-table, drop back to root table */
/* put invalid code marker in table */
/* backwards increment the len-bit code huff */
/* set return parameters */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\inflate86\inffas86.c
/* inffas86.c is a hand tuned assembler version of
//fedora.linux.duke.edu/fc1_x86_64
//www.eetbeetee.com/zlib/ and http://www.charm.net/~christop/zlib/
/* Mark Adler's comments from inffast.c: */
/*
/* inflate()'s starting value for strm->avail_out */
/* 64   32                               x86  x86_64 */
/* ar offset                              register */
/*  0    0 */ void *esp;                /* esp save */
/*  8    4 */ void *ebp;                /* ebp save */
/* 16    8 */ unsigned char FAR *in;    /* esi rsi  local strm->next_in */
/* 24   12 */ unsigned char FAR *last;  /*     r9   while in < last */
/* 32   16 */ unsigned char FAR *out;   /* edi rdi  local strm->next_out */
/* 40   20 */ unsigned char FAR *beg;   /*          inflate()'s init next_out */
/* 48   24 */ unsigned char FAR *end;   /*     r10  while out < end */
/* 56   28 */ unsigned char FAR *window;/*          size of window, wsize!=0 */
/* 64   32 */ code const FAR *lcode;    /* ebp rbp  local strm->lencode */
/* 72   36 */ code const FAR *dcode;    /*     r11  local strm->distcode */
/* 80   40 */ unsigned long hold;       /* edx rdx  local strm->hold */
/* 88   44 */ unsigned bits;            /* ebx rbx  local strm->bits */
/* 92   48 */ unsigned wsize;           /*          window size */
/* 96   52 */ unsigned write;           /*          window write index */
/*100   56 */ unsigned lmask;           /*     r12  mask for lcode */
/*104   60 */ unsigned dmask;           /*     r13  mask for dcode */
/*108   64 */ unsigned len;             /*     r14  match length */
/*112   68 */ unsigned dist;            /*     r15  match distance */
/*116   72 */ unsigned status;          /*          set when state chng*/
/* copy state to local variables */
/* decode literals and length/distances until end-of-block or not enough
/* align in on 1/2 hold size boundary */
/* save regs rbp and rsp */
/* make rsp point to &ar */
/* rsi  = in */
/* rdi  = out */
/* r9   = last */
/* r10  = end */
/* rbp  = lcode */
/* r11  = dcode */
/* rdx  = hold */
/* ebx  = bits */
/* r12d = lmask */
/* r13d = dmask */
/* r14d = len */
/* r15d = dist */
/* if only one decode left */
/* r8 = lmask */
/* eax = *(uint *)in++ */
/* cl = bits, needs it for shifting */
/* bits += 32 */
/* hold |= *((uint *)in)++ << bits */
/* r8 = lmask */
/* if (32 < bits) */
/* eax = *(uint *)in++ */
/* cl = bits, needs it for shifting */
/* bits += 32 */
/* hold |= *((uint *)in)++ << bits */
/* r8 &= hold */
/* eax = lcode[hold & lmask] */
/* cl = this.bits */
/* bits -= this.bits */
/* hold >>= this.bits */
/* if (op != 0) 45.7% */
/* r8 = lmask */
/* output this.val char */
/* r8 &= hold */
/* eax = lcode[hold & lmask] */
/* cl = this.bits */
/* bits -= this.bits */
/* hold >>= this.bits */
/* if (op != 0) 45.7% */
/* output this.val char */
/* len = this */
/* len = this.val */
/* if ((op & 16) == 0) 8% */
/* op &= 15 */
/* if (!op) */
/* eax &= hold */
/* len += hold & mask[op] */
/* r8 = dmask */
/* if (32 < bits) */
/* eax = *(uint *)in++ */
/* cl = bits, needs it for shifting */
/* bits += 32 */
/* hold |= *((uint *)in)++ << bits */
/* r8 &= hold */
/* eax = dcode[hold & dmask] */
/* dist = this */
/* dist = this.val */
/* bits -= this.bits */
/* hold >>= this.bits */
/* cl = this.op */
/* if ((op & 16) == 0) */
/* op &= 15 */
/* (1 << op) - 1 */
/* eax &= hold */
/* dist += hold & ((1 << op) - 1) */
/* save in so from can use it's reg */
/* nbytes = out - beg */
/* if (dist > nbytes) 4.2% */
/* ecx = len */
/* from = out - dist */
/* if len % 2 == 0 */
/* move in back to %rsi, toss from */
/* move in back to %rsi, toss from */
/* if dist 1, is a memset */
/* if out == beg, outside window */
/* ecx = len */
/* if ((op & 64) != 0) */
/* eax &= hold */
/* eax += len */
/* eax = lcode[val+(hold&mask[op])]*/
/* if ((op & 64) != 0) */
/* eax &= hold */
/* eax += dist */
/* eax = dcode[val+(hold&mask[op])]*/
/* ecx = nbytes */
/* eax = wsize, prepare for dist cmp */
/* nbytes = -nbytes */
/* if (dist > wsize) */
/* nbytes = dist - nbytes */
/* if (write != 0) */
/* from  = window */
/* eax  -= nbytes */
/* from += wsize - nbytes */
/* eax = len */
/* if (nbytes >= len) */
/* eax -= nbytes */
/* from = &out[ -dist ] */
/* eax = write */
/* if (write >= nbytes) */
/* from  = wsize */
/* from += window */
/* from += write */
/* from -= nbytes */
/* nbytes -= write */
/* eax = len */
/* if (nbytes >= len) */
/* len -= nbytes */
/* from = window */
/* nbytes = write */
/* if (nbytes >= len) */
/* len -= nbytes */
/* from = out - dist */
/* rsi = window */
/* from += write - nbytes */
/* eax = len */
/* if (nbytes >= len) */
/* len -= nbytes */
/* from = out - dist */
/* if (nbytes >= len) */
/* ecx = len */
/* move in back to %esi, toss from */
/* put in, out, bits, and hold back into ar and pop esp */
/* in */
/* out */
/* bits */
/* hold */
/* restore rbp and rsp */
/* save esp, ebp */
/* esi = in */
/* edi = out */
/* edx = hold */
/* ebx = bits */
/* ebp = lcode */
/* out < end */
/* in < last */
/* if (15 < bits) */
/* al = *(ushort *)in++ */
/* cl = bits, needs it for shifting */
/* bits += 16 */
/* hold |= *((ushort *)in)++ << bits */
/* eax = lmask */
/* eax &= hold */
/* eax = lcode[hold & lmask] */
/* cl = this.bits */
/* bits -= this.bits */
/* hold >>= this.bits */
/* if (op != 0) 45.7% */
/* output this.val char */
/* len = this */
/* len = this.val */
/* save len */
/* if ((op & 16) == 0) 8% */
/* op &= 15 */
/* if (!op) */
/* if (op <= bits) */
/* stash op in ch, freeing cl */
/* al = *(ushort *)in++ */
/* cl = bits, needs it for shifting */
/* bits += 16 */
/* hold |= *((ushort *)in)++ << bits */
/* move op back to ecx */
/* eax &= hold */
/* len += hold & mask[op] */
/* if (15 < bits) */
/* al = *(ushort *)in++ */
/* cl = bits, needs it for shifting */
/* bits += 16 */
/* hold |= *((ushort *)in)++ << bits */
/* eax = dmask */
/* ecx = dcode */
/* eax &= hold */
/* eax = dcode[hold & dmask] */
/* dist = this */
/* dist = this.val */
/* bits -= this.bits */
/* hold >>= this.bits */
/* cl = this.op */
/* if ((op & 16) == 0) */
/* op &= 15 */
/* if (op <= bits) 97.6% */
/* stash op in ch, freeing cl */
/* al = *(ushort *)in++ */
/* cl = bits, needs it for shifting */
/* bits += 16 */
/* hold |= *((ushort *)in)++ << bits */
/* move op back to ecx */
/* (1 << op) - 1 */
/* eax &= hold */
/* dist += hold & ((1 << op) - 1) */
/* save in so from can use it's reg */
/* nbytes = out - beg */
/* if (dist > nbytes) 4.2% */
/* ecx = len */
/* from = out - dist */
/* if len % 2 == 0 */
/* move in back to %esi, toss from */
/* ebp = lcode */
/* move in back to %esi, toss from */
/* ebp = lcode */
/* if dist 1, is a memset */
/* out == beg, if outside window */
/* ecx = len */
/* ebp = lcode */
/* if ((op & 64) != 0) */
/* eax &= hold */
/* eax += len */
/* eax = lcode[val+(hold&mask[op])]*/
/* if ((op & 64) != 0) */
/* eax &= hold */
/* eax += dist */
/* ecx = dcode */
/* eax = dcode[val+(hold&mask[op])]*/
/* eax = wsize */
/* nbytes = -nbytes */
/* from = window */
/* if (dist > wsize) */
/* nbytes = dist - nbytes */
/* if (write != 0) */
/* from += wsize - nbytes */
/* eax = len */
/* if (nbytes >= len) */
/* len -= nbytes */
/* from = out - dist */
/* eax = write */
/* if (write >= nbytes) */
/* from += wsize */
/* from += write */
/* from -= nbytes */
/* nbytes -= write */
/* eax = len */
/* if (nbytes >= len) */
/* len -= nbytes */
/* from = window */
/* nbytes = write */
/* if (nbytes >= len) */
/* len -= nbytes */
/* from = out - dist */
/* from += write - nbytes */
/* eax = len */
/* if (nbytes >= len) */
/* len -= nbytes */
/* from = out - dist */
/* if (nbytes >= len) */
/* move in back to %esi, toss from */
/* ebp = lcode */
/* put in, out, bits, and hold back into ar and pop esp */
/* save in */
/* save out */
/* save bits */
/* save hold */
/* restore esp, ebp */
/* save esp, ebp */
/* esi = in */
/* edi = out */
/* edx = hold */
/* ebx = bits */
/* ebp = lcode */
/* if (15 < bits) */
/* al = *(ushort *)in++ */
/* cl = bits, needs it for shifting */
/* bits += 16 */
/* hold |= *((ushort *)in)++ << bits */
/* eax = lmask */
/* eax &= hold */
/* eax = lcode[hold & lmask] */
/* cl = this.bits */
/* bits -= this.bits */
/* hold >>= this.bits */
/* if (op != 0) 45.7% */
/* output this.val char */
/* len = this */
/* len = this.val */
/* save len */
/* if ((op & 16) == 0) 8% */
/* op &= 15 */
/* if (!op) */
/* if (op <= bits) */
/* stash op in ch, freeing cl */
/* al = *(ushort *)in++ */
/* cl = bits, needs it for shifting */
/* bits += 16 */
/* hold |= *((ushort *)in)++ << bits */
/* move op back to ecx */
/* eax &= hold */
/* len += hold & mask[op] */
/* if (15 < bits) */
/* al = *(ushort *)in++ */
/* cl = bits, needs it for shifting */
/* bits += 16 */
/* hold |= *((ushort *)in)++ << bits */
/* eax = dmask */
/* ecx = dcode */
/* eax &= hold */
/* eax = dcode[hold & dmask] */
/* dist = this */
/* dist = this.val */
/* bits -= this.bits */
/* hold >>= this.bits */
/* cl = this.op */
/* if ((op & 16) == 0) */
/* op &= 15 */
/* if (op <= bits) 97.6% */
/* stash op in ch, freeing cl */
/* al = *(ushort *)in++ */
/* cl = bits, needs it for shifting */
/* bits += 16 */
/* hold |= *((ushort *)in)++ << bits */
/* move op back to ecx */
/* (1 << op) - 1 */
/* eax &= hold */
/* dist += hold & ((1 << op) - 1) */
/* save in so from can use it's reg */
/* nbytes = out - beg */
/* if (dist > nbytes) 4.2% */
/* ecx = len */
/* from = out - dist */
/* move in back to %esi, toss from */
/* ebp = lcode */
/* move in back to %esi, toss from */
/* ebp = lcode */
/* if dist 1, is a memset */
/* out == beg, if outside window */
/* ecx = len */
/* memset out with from[-1] */
/* ebp = lcode */
/* if ((op & 64) != 0) */
/* eax &= hold */
/* eax += len */
/* eax = lcode[val+(hold&mask[op])]*/
/* if ((op & 64) != 0) */
/* eax &= hold */
/* eax += dist */
/* ecx = dcode */
/* eax = dcode[val+(hold&mask[op])]*/
/* eax = wsize */
/* nbytes = -nbytes */
/* from = window */
/* if (dist > wsize) */
/* nbytes = dist - nbytes */
/* if (write != 0) */
/* from += wsize - nbytes */
/* eax = len */
/* if (nbytes >= len) */
/* len -= nbytes */
/* from = out - dist */
/* eax = write */
/* if (write >= nbytes) */
/* from += wsize */
/* from += write */
/* from -= nbytes */
/* nbytes -= write */
/* eax = len */
/* if (nbytes >= len) */
/* len -= nbytes */
/* from = window */
/* nbytes = write */
/* if (nbytes >= len) */
/* len -= nbytes */
/* from = out - dist */
/* from += write - nbytes */
/* eax = len */
/* if (nbytes >= len) */
/* len -= nbytes */
/* from = out - dist */
/* move in back to %esi, toss from */
/* ebp = lcode */
/* put in, out, bits, and hold back into ar and pop esp */
/* save in */
/* save out */
/* save bits */
/* save hold */
/* restore esp, ebp */
/* return unused bytes (on entry, bits < 8, so in won't go too far back) */
/* update state and return */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\masmx64\inffas8664.c
/* inffas8664.c is a hand tuned assembler version of inffast.c - fast decoding
//fedora.linux.duke.edu/fc1_x86_64
//www.eetbeetee.com/zlib/ and http://www.charm.net/~christop/zlib/
/* Mark Adler's comments from inffast.c: */
/*
/* 64   32                               x86  x86_64 */
/* ar offset                              register */
/*  0    0 */ void *esp;                /* esp save */
/*  8    4 */ void *ebp;                /* ebp save */
/* 16    8 */ unsigned char FAR *in;    /* esi rsi  local strm->next_in */
/* 24   12 */ unsigned char FAR *last;  /*     r9   while in < last */
/* 32   16 */ unsigned char FAR *out;   /* edi rdi  local strm->next_out */
/* 40   20 */ unsigned char FAR *beg;   /*          inflate()'s init next_out */
/* 48   24 */ unsigned char FAR *end;   /*     r10  while out < end */
/* 56   28 */ unsigned char FAR *window;/*          size of window, wsize!=0 */
/* 64   32 */ code const FAR *lcode;    /* ebp rbp  local strm->lencode */
/* 72   36 */ code const FAR *dcode;    /*     r11  local strm->distcode */
/* 80   40 */ size_t /*unsigned long */hold;       /* edx rdx  local strm->hold */
/* 88   44 */ unsigned bits;            /* ebx rbx  local strm->bits */
/* 92   48 */ unsigned wsize;           /*          window size */
/* 96   52 */ unsigned write;           /*          window write index */
/*100   56 */ unsigned lmask;           /*     r12  mask for lcode */
/*104   60 */ unsigned dmask;           /*     r13  mask for dcode */
/*108   64 */ unsigned len;             /*     r14  match length */
/*112   68 */ unsigned dist;            /*     r15  match distance */
/*116   72 */ unsigned status;          /*          set when state chng*/
/* inflate()'s starting value for strm->avail_out */
/* copy state to local variables */
/* decode literals and length/distances until end-of-block or not enough
/* align in on 1/2 hold size boundary */
/* return unused bytes (on entry, bits < 8, so in won't go too far back) */
/* update state and return */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\minizip\ioapi.c
/* ioapi.h -- IO base function header for compress/uncompress .zip
//www.winimage.com/zLibDll/minizip.html )
//result42.com )
// In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\minizip\iowin32.c
/* iowin32.c -- IO base function header for compress/uncompress .zip
//www.winimage.com/zLibDll/minizip.html )
//www.winimage.com/zLibDll/minizip.html )
//result42.com )
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\minizip\miniunz.c
/*
//www.winimage.com/zLibDll/minizip.html )
//www.winimage.com/zLibDll/minizip.html )
//result42.com )
// In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions
/*
/* change_file_date : change the date/time of a file
/* mymkdir and change_file_date are not 100 % portable
//www.winimage.com/zLibDll/unzip.html\n\n");
/* to avoid compatibility problem , we do here the conversion */
/* display a '*' if the file is crypted */
/* 2:fast , 3 : extra fast*/
/* some zipfile don't contain directory alone before file */
/* don't lose the error */
/* strncpy doesnt append the trailing NULL, of the string is too long. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\minizip\minizip.c
/*
//www.winimage.com/zLibDll/minizip.html )
//www.winimage.com/zLibDll/minizip.html )
//result42.com )
// In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions
/* name of file to get info on */
/* return value: access, modific. and creation times */
/* dostime */
/* name of file to get info on */
/* return value: access, modific. and creation times */
/* dostime */
/* results of stat() */
/* strncpy doesnt append the trailing NULL, of the string is too long. */
/* not all systems allow stat'ing a file with / appended */
/* name of file to get info on */
/* return value: access, modific. and creation times */
/* dostime */
//www.winimage.com/zLibDll/minizip.html\n\n");
/* calculate the CRC32 of a file,
/* strncpy doesnt append the trailing NULL, of the string is too long. */
/* if the file don't exist, we not append file */
/*
/* The path name saved, should not include a leading slash. */
/*if it did, windows/xp and dynazip couldn't read the zip file. */
/*should the zip file contain any path at all?*/
// base filename follows last slash.
/**/
/* comment*/,
/* -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY, */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\minizip\mztools.c
/*
/* Code */
/* File entry */
/* crc */
/* compressed size */
/* uncompressed sz */
/* file name length */
/* extra field length */
/* Header */
/* Filename */
/* Extra field */
/* Data */
/* Central directory entry */
/* disk # */
/* int attrb */
/* ext attrb */
/* Header */
/* Filename */
/* Extra field */
/* Comment field */
/* Success */
/* Final central directory  */
// "ZIP File recovered by zlib/minizip/mztools";
/* disk # */
/* disk # */
/* hack */
/* hack */
/* size of CD */
/* offset to CD */
/* comment */
/* Header */
/* Comment field */
/* Final merge (file + central directory) */
/* Close */
/* Wipe temporary file */
/* Number of recovered entries */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\minizip\unzip.c
/* unzip.c -- IO for uncompress .zip files using zlib
//www.winimage.com/zLibDll/minizip.html )
//www.winimage.com/zLibDll/minizip.html )
//result42.com )
//ftp.info-zip.org/pub/infozip/license.html
/* compile with -Dlocal if your debugger can't find static symbols */
//www.winimage.com/zLibDll";
/* unz_file_info_interntal contain internal info about a file in zipfile*/
/* relative offset of local header 8 bytes */
/* file_in_zip_read_info_s contain internal information about a file in zipfile,
/* internal buffer for compressed data */
/* zLib stream structure for inflate */
/* bzLib stream structure for bziped */
/* position in byte on the zipfile, for fseek*/
/* flag set if stream structure is initialised*/
/* offset of the local extra field */
/* size of the local extra field */
/* position in the local extra field in read*/
/* crc32 of all data uncompressed */
/* crc32 we must obtain after decompress all */
/* number of byte to be decompressed */
/*number of byte to be obtained after decomp*/
/* io structore of the zipfile */
/* compression method (0==store) */
/* byte before the zipfile, (>0 for sfx)*/
/* unz64_s contain internal information about the zipfile
/* io structore of the zipfile */
/* public global information */
/* byte before the zipfile, (>0 for sfx)*/
/* number of the current file in the zipfile*/
/* pos of the current file in the central dir*/
/* flag about the usability of the current file*/
/* position of the beginning of the central dir*/
/* size of the central directory  */
/* offset of start of central directory with
/* public info about the current file in zip*/
/* private info about it*/
/* structure about the current
/* keys defining the pseudo-random sequence */
/* ===========================================================================
/* ===========================================================================
/* My own strcmpi / strcasecmp */
/*
/*
/* maximum size of global comment */
/*
/* maximum size of global comment */
/* Zip64 end of central directory locator */
/* the signature, already checked */
/* number of the disk with the start of the zip64 end of  central directory */
/* relative offset of the zip64 end of central directory record */
/* total number of disks */
/* Goto end of central directory record */
/* the signature */
/*
/* number of the current dist, used for
/* number the the disk with central dir, used
/* total number of entries in
/* the signature, already checked */
/* size of zip64 end of central directory record */
/* version made by */
/* version needed to extract */
/* number of this disk */
/* number of the disk with the start of the central directory */
/* total number of entries in the central directory on this disk */
/* total number of entries in the central directory */
/* size of the central directory */
/* offset of start of central directory with respect to the
/* the signature, already checked */
/* number of this disk */
/* number of the disk with the start of the central directory */
/* total number of entries in the central dir on this disk */
/* total number of entries in the central dir */
/* size of the central directory */
/* offset of start of central directory with respect to the
/* zipfile comment length */
/*
/*
/* to do : check if number_entry is not truncated */
/*
/*
/* we check the magic */
// relative offset of local header
// Read extrafield
// since lSeek now points to after the extra field we need to move back
/* ZIP64 extra fields */
/* Relative Header offset */
/* Disk Start Number */
/*
/*
/*
/* 2^16 files overflow hack */
/*
/* We remember the 'current' position in the file so that we can jump
/* Save the current state */
/* We failed, so restore the state of the 'current file' to where we
/*
// Contributed by Ryan Haksi (mailto://cryogen@infoserve.net)
// I need random access
//
// Further optimization could be realized by adding an ability
// to cache the directory in memory. The goal being a single
// comprehensive file read to put the file I need in a memory.
/*
// offset in file
// # of file
/* jump to the right spot */
/* set the current file */
/* return results */
/*
///////////////////////////////////////////
/*
/*
/* #ifdef HAVE_BZIP2 */
/* #endif */
/* date/time */
/* crc */
/* size compr */
/* size uncompr */
/*
/* offset of the local extra field */
/* size of the local extra field */
/* #ifdef HAVE_BZIP2 */
/* #endif */
/* windowBits is passed < 0 to tell that there is no zlib header.
/** Addition for GDAL : START */
//UNZ_PARAMERROR;
//UNZ_PARAMERROR;
/** Addition for GDAL : END */
/*
// end Z_BZIP2ED
/*
/*
/*
/*
/*
/*
/* Additions by RX '2004 */
//UNZ_PARAMERROR;
//UNZ_PARAMERROR;
/* hack */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\minizip\zip.c
/* zip.c -- IO on .zip files using zlib
//www.winimage.com/zLibDll/minizip.html )
//www.winimage.com/zLibDll/minizip.html )
//result42.com )
/* compile with -Dlocal if your debugger can't find static symbols */
/* platform depedent */
//(16384)
/*
/* I've found an old Unix (a SunOS 4.1.3_U1) without all SEEK_* defined.... */
// NOT sure that this work on ALL platform
//www.winimage.com/zLibDll";
/* 46 */
/* for future use and alignement */
/* zLib stream structure for inflate */
/* bzLib stream structure for bziped */
/* 1 is stream is initialised */
/* last written byte in buffered_data */
/* offset of the local header of the file
/* central header data for the current file */
/* size of the central header for cur file */
/* Extra bytes allocated to the centralheader but that are not used */
/* flag of the file currently writing */
/* compression method of file currenty wr.*/
/* 1 for directly writing raw data */
/* buffer contain compressed data to be writ*/
/* Add ZIP64 extened information in the extra field */
/* keys defining the pseudo-random sequence */
/* io structore of the zipfile */
/* datablock with central dir in construction*/
/* 1 if a file in the zip is currently writ.*/
/* info on the file curretly writing */
/* position of the beginning of the zipfile */
/****************************************************************************/
/* ===========================================================================
/* data overflow - hack for ZIP64 (X Roche) */
/* data overflow - hack for ZIP64 */
/****************************************************************************/
/****************************************************************************/
/* ===========================================================================
/*
/* maximum size of global comment */
/*
/* maximum size of global comment */
// Signature "0x07064b50" Zip64 end of central directory locater
/* Zip64 end of central directory locator */
/* the signature, already checked */
/* number of the disk with the start of the zip64 end of  central directory */
/* relative offset of the zip64 end of central directory record */
/* total number of disks */
/* Goto Zip64 end of central directory record */
/* the signature */
// signature of 'Zip64 end of central directory'
/* byte before the zipfile, (>0 for sfx)*/
/* size of the central directory  */
/* offset of start of central directory */
/* number of the current dist, used for
/* number the the disk with central dir, used
/* total number of entries in
// check first if we find a ZIP64 record
/* disable to allow appending to empty ZIP archive
/* the signature, already checked */
/* size of zip64 end of central directory record */
/* version made by */
/* version needed to extract */
/* number of this disk */
/* number of the disk with the start of the central directory */
/* total number of entries in the central directory on this disk */
/* total number of entries in the central directory */
/* size of the central directory */
/* offset of start of central directory with respect to the
// TODO..
// read the comment from the standard central header.
// Read End of central Directory info
/* the signature, already checked */
/* number of this disk */
/* number of the disk with the start of the central directory */
/* total number of entries in the central dir on this disk */
/* total number of entries in the central dir */
/* size of the central directory */
/* offset of start of central directory with respect to the starting disk number */
/* zipfile global comment length */
/* !NO_ADDFILEINEXISTINGZIP*/
/************************************************************/
/* now we add file in a zipfile */
// Read and Cache Central Directory Records
/* !NO_ADDFILEINEXISTINGZIP*/
/* !NO_ADDFILEINEXISTINGZIP*/
/* write the local header */
/* version needed to extract */
/* version needed to extract */
// CRC / Compressed size / Uncompressed size will be filled in later and rewritten later
/* crc 32, unknown */
/* compressed size, unknown */
/* compressed size, unknown */
/* uncompressed size, unknown */
/* uncompressed size, unknown */
// write the Zip64 extended info
// Remember position of Zip64 extended info for the local file header. (needed when we update size after done with file)
/*
// Extra space we have reserved in case we need to add ZIP64 extra info data
/* version info */
/*crc*/
/*compr size*/
/*uncompr size*/
/*disk nm start*/
// Init BZip stuff here
/*init_keys(password,zi->ci.keys,zi->ci.pcrc_32_tab);*/
//          uLong uTotalOutBefore_hi = zi->ci.bstream.total_out_hi32;
// while(...)
/* this is normal */
// update Current Item crc and sizes,
/*version Made by*/
/*version needed*/
/*crc*/
/*compr size*/
/*compr size*/
/// set internal file attributes field
/*uncompr size*/
/*uncompr size*/
// Add ZIP64 extra info field for uncompressed size
// Add ZIP64 extra info field for compressed size
// Add ZIP64 extra info field for relative offset to local file header of current file
// we can not write more data to the buffer that we have room for.
// Add Extra Information Header for 'ZIP64 information'
// HeaderID
// DataSize
// Update how much extra free space we got in the memory buffer
// and increase the centralheader size so the new ZIP64 fields are included
// ( 4 below is the size of HeaderID and DataSize field )
// Update the extra info size field
// Update the LocalFileHeader with the new values.
/* crc 32, unknown */
// Update the size in the ZIP64 extended field.
/* compressed size, unknown */
/* uncompressed size, unknown */
// Caller passed zip64 = 0, so no room for zip64 info -> fatal
/* compressed size, unknown */
/* uncompressed size, unknown */
/*num disks*/
/* number of the disk with the start of the central directory */
/*relative offset*/
/* Relative offset to the Zip64EndOfCentralDirectory */
/*total disks*/ /* Do not support spawning of disk so always say 1 here*/
/* number of the disk with the start of the central directory */
/* size of this 'zip64 end of central directory' */
// why ZPOS64_T of this ?
/* version made by */
/* version needed */
/* number of this disk */
/* number of the disk with the start of the central directory */
/* total number of entries in the central dir on this disk */
/* total number of entries in the central dir */
/* size of the central directory */
/* offset of start of central directory with respect to the starting disk number */
/*signature*/
/* number of this disk */
/* number of the disk with the start of the central directory */
/* total number of entries in the central dir on this disk */
// use value in ZIP64 record
/* total number of entries in the central dir */
// use value in ZIP64 record
/* size of the central directory */
/* offset of start of central directory with respect to the starting disk number */
// Header found.
// skip it. do not copy to temp buffer
// Extra Info block should not be removed, So copy it to the temp buffer.
// clean old extra info block.
// copy the new extra info block over the old
// set the new extra info size
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\puff\puff.c
/*
//www.zlib.org/rfc-deflate.html
/*
/* for setjmp(), longjmp(), and jmp_buf */
/* prototype for puff() */
/* for local function definitions */
/*
/* maximum bits in a code */
/* maximum number of literal/length codes */
/* maximum number of distance codes */
/* maximum codes lengths to read */
/* number of fixed literal/length codes */
/* input and output state */
/* output state */
/* output buffer */
/* available space at out */
/* bytes written to out so far */
/* input state */
/* input buffer */
/* available input at in */
/* bytes read so far */
/* bit buffer */
/* number of bits in bit buffer */
/* input limit error return state for bits() and decode() */
/*
/* bit accumulator (can use up to 20 bits) */
/* load at least need bits into val */
/* out of input */
/* load eight bits */
/* drop need bits and update buffer, always zero to seven bits left */
/* return need bits, zeroing the bits above that */
/*
/* length of stored block */
/* discard leftover bits from current byte (assumes s->bitcnt < 8) */
/* get length and check against its one's complement */
/* not enough input */
/* didn't match complement! */
/* copy len bytes from in to out */
/* not enough input */
/* not enough output space */
/* just scanning */
/* done with a valid stored block */
/*
/* number of symbols of each length */
/* canonically ordered symbols */
/*
/* current number of bits in code */
/* len bits being decoded */
/* first code of length len */
/* number of codes of length len */
/* index of first code of length len in symbol table */
/* get next bit */
/* if length len, return symbol */
/* else update for next length */
/* ran out of codes */
/*
/* !SLOW */
/* current number of bits in code */
/* len bits being decoded */
/* first code of length len */
/* number of codes of length len */
/* index of first code of length len in symbol table */
/* bits from stream */
/* bits left in next or left to process */
/* next number of codes */
/* if length len, return symbol */
/* else update for next length */
/* out of input */
/* ran out of codes */
/* SLOW */
/*
/* current symbol when stepping through length[] */
/* current length when stepping through h->count[] */
/* number of possible codes left of current length */
/* offsets in symbol table for each length */
/* count number of codes of each length */
/* assumes lengths are within bounds */
/* no codes! */
/* complete, but decode() will fail */
/* check for an over-subscribed or incomplete set of lengths */
/* one possible code of zero length */
/* one more bit, double codes left */
/* deduct count from possible codes */
/* over-subscribed--return negative */
/* left > 0 means incomplete */
/* generate offsets into symbol table for each length for sorting */
/*
/* return zero for complete set, positive for incomplete set */
/*
/* decoded symbol */
/* length for copy */
/* distance for copy */
/* Size base for length codes 257..285 */
/* Extra bits for length codes 257..285 */
/* Offset base for distance codes 0..29 */
/* Extra bits for distance codes 0..29 */
/* decode literals and length/distance pairs */
/* invalid symbol */
/* literal: symbol is the byte */
/* write out the literal */
/* length */
/* get and compute length */
/* invalid fixed code */
/* get and check distance */
/* invalid symbol */
/* distance too far back */
/* copy length bytes from distance bytes back */
/* end of block symbol */
/* done with a valid fixed or dynamic block */
/*
/* build fixed huffman tables if first call (may not be thread safe) */
/* construct lencode and distcode */
/* literal/length table */
/* distance table */
/* do this just once */
/* decode data until end-of-block code */
/*
/* number of lengths in descriptor */
/* index of lengths[] */
/* construct() return value */
/* descriptor code lengths */
/* lencode memory */
/* distcode memory */
/* length and distance codes */
/* permutation of code length codes */
/* construct lencode and distcode */
/* get number of lengths in each table, check lengths */
/* bad counts */
/* read code length code lengths (really), missing lengths are zero */
/* build huffman table for code lengths codes (use lencode temporarily) */
/* require complete code set here */
/* read length/literal and distance code length tables */
/* decoded value */
/* last length to repeat */
/* invalid symbol */
/* length in 0..15 */
/* repeat instruction */
/* assume repeating zeros */
/* repeat last length 3..6 times */
/* no last length! */
/* last length */
/* repeat zero 3..10 times */
/* == 18, repeat zero 11..138 times */
/* too many lengths! */
/* repeat last or zero symbol times */
/* check for end-of-block code -- there better be one! */
/* build huffman table for literal/length codes */
/* incomplete code ok only for single length 1 code */
/* build huffman table for distance codes */
/* incomplete code ok only for single length 1 code */
/* decode data until end-of-block code */
/*
/* pointer to destination pointer */
/* amount of output space */
/* pointer to source data pointer */
/* amount of input available */
/* input/output state */
/* block information */
/* return value */
/* initialize output state */
/* ignored if dest is NIL */
/* initialize input state */
/* return if bits() or decode() tries to read past available input */
/* if came back here via longjmp() */
/* then skip do-loop, return error */
/* process blocks until last block or error */
/* one if last block */
/* block type 0..3 */
/* type == 3, invalid */
/* return with error */
/* update the lengths and return */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\puff\pufftest.c
/*
/* Example of how to use puff().
/* Return size times approximately the cube root of 2, keeping the result as 1,
/* Read the input file *name, or stdin if name is NULL, into allocated memory.
/* process arguments */
/* test inflate data with offset skip */
/* if requested, inflate again and write decompressd data to stdout */
/* clean up */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\testzlib\testzlib.c
// see http://msdn2.microsoft.com/library/twchhe95(en-us,vs.80).aspx for __rdtsc
//   printf("rdtsc = %I64x\n",__rdtsc());
// printf("rdtsc = %I64x\n",__rdtsc());
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/BlueshiftEngine-master\BlueshiftEngine-master\Source\ThirdParty\zlib\contrib\untgz\untgz.c
/*
/* values used in typeflag field */
/* regular file */
/* regular file */
/* link */
/* reserved */
/* character special */
/* block special */
/* directory */
/* FIFO special */
/* reserved */
/* GNU tar extensions */
/* file names from dumped directory */
/* long link name */
/* long file name */
/* continuation of file from another volume */
/* file name that does not fit into main hdr */
/* sparse file */
/* tape/volume header */
/* tar header */
/* byte offset */
/*   0 */
/* 100 */
/* 108 */
/* 116 */
/* 124 */
/* 136 */
/* 148 */
/* 156 */
/* 157 */
/* 257 */
/* 263 */
/* 265 */
/* 297 */
/* 329 */
/* 337 */
/* 345 */
/* 500 */
/* return the file name of the TGZ archive */
/* or NULL if it does not exist */
/* error message for the filename */
/* convert octal digits to int */
/* on error return -1 */
/* convert time_t to string */
/* use the "YYYY/MM/DD hh:mm:ss" format */
/* set file time */
/* push file attributes */
/* restore file attributes */
/* match regular expression */
/* recursive mkdir */
/* abort on ENOENT; ignore other errors like "directory already exists" */
/* return 1 if OK */
/*        0 on error */
/* no arguments given (untgz tgzarchive) */
/* ignore this for the moment being */
/* tar file list or extract */
/*
/* force error exit */
/* force I/O cleanup */
/*
/*
/*
/*
/* try creating directory */
/*
/*
/* ============================================================ */
/* ============================================================ */
/* disable argument globbing in MinGW */
/*
