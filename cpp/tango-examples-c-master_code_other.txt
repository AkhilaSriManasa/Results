________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_augmented_reality_example\app\src\main\java\com\projecttango\examples\cpp\augmentedreality\AugmentedRealityActivity.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// GLSurfaceView and its renderer, all of the graphic content is rendered
// through OpenGL ES 2.0 in the native code.
// Screen size for normalizing the touch input for orbiting the render camera.
// Tango Service connection.
// The following code block does setup and connection to Tango.
// Handle this if you need to gracefully shutdown/retry
// in the event that Tango itself crashes/gets upgraded while running.
// Setting content view of this activity and getting the mIsAutoRecovery
// flag from StartActivity.
// OpenGL view where all of the graphics are drawn
// Configure OpenGL renderer
// Configure OpenGL renderer. The RENDERMODE_WHEN_DIRTY is set explicitly
// for reducing the CPU load. The request render function call is triggered
// by the onTextureAvailable callback from the Tango Service in the native
// code.
// Request onGlSurfaceDrawFrame on the glSurfaceView. This function is called from the
// native code, and it is triggered from the onTextureAvailable callback from
// the Tango Service.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_augmented_reality_example\app\src\main\java\com\projecttango\examples\cpp\augmentedreality\AugmentedRealityRenderer.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Render loop of the Gl context.
// Called when the surface size changes.
// Called when the surface is created or recreated.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_augmented_reality_example\app\src\main\java\com\projecttango\examples\cpp\augmentedreality\package-info.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_augmented_reality_example\app\src\main\java\com\projecttango\examples\cpp\augmentedreality\TangoJNINative.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// This project depends on tango_client_api, so we need to make sure we load
// the correct library first.
/**
/**
/**
/**
/**
/**
/**
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_basic_examples\hello_area_description\src\main\java\com\projecttango\examples\cpp\helloareadescription\AdfData.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_basic_examples\hello_area_description\src\main\java\com\projecttango\examples\cpp\helloareadescription\AdfUuidArrayAdapter.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_basic_examples\hello_area_description\src\main\java\com\projecttango\examples\cpp\helloareadescription\AdfUuidListViewActivity.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Tango service connection.
// Handle this if you need to gracefully shutdown/retry
// in the event that Tango itself crashes/gets upgraded while running.
// Get API ADF ListView Ready
// Get App Space ADF List View Ready
// Delete the ADF from Tango space and update the Tango ADF Listview.
// Delete the ADF from Tango space and update the Tango ADF Listview.
// Export the ADF into application package folder and update the Listview.
// Delete an ADF from App space and update the App space ADF Listview.
// Import an ADF from app space to Tango space.
// Check which request we're responding to
// Make sure the request was successful
/**
/**
// Nothing to do here.
/**
/**
/*
/**
/**
/**
// Update App space ADF Listview.
// Update Tango space ADF Listview.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_basic_examples\hello_area_description\src\main\java\com\projecttango\examples\cpp\helloareadescription\AreaDescriptionActivity.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Tag for debug logging.
// The interval at which we'll update our UI debug text in milliseconds.
// This is the rate at which we query our native wrapper around the tango
// service for pose and event information.
// Flag that controls whether user wants to run area learning mode.
// Flag that controls whether user wants to load the latest area description.
// Screen size for normalizing the touch input for orbiting the render camera.
// Long-running task to save an ADF.
// Handles the debug text UI update loop.
// Tango Service connection.
// Display loaded ADF's UUID.
// Handle this if you need to gracefully shutdown/retry
// in the event that Tango itself crashes/gets upgraded while running.
// Start the debug text UI update loop.
// Stop the debug text UI update loop.
/**
/**
/**
// Continue running.
/**
/**
/**
/**
// Note: this method is not called from the UI thread. We read mSaveAdfTask into
// a local variable because the UI thread may null-out the member variable at any time.
/**
// Get user's input from the StartActivity.
/**
// Querying screen size, used for computing the normalized touch point.
// Disable save ADF button until Tango relocalizes to the current ADF.
// Hide to save ADF button if leanring mode is off.
// UUID is generated after the ADF is saved.
/**
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_basic_examples\hello_area_description\src\main\java\com\projecttango\examples\cpp\helloareadescription\package-info.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_basic_examples\hello_area_description\src\main\java\com\projecttango\examples\cpp\helloareadescription\SaveAdfDialog.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_basic_examples\hello_area_description\src\main\java\com\projecttango\examples\cpp\helloareadescription\SaveAdfTask.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
// This example implementation returns an empty-string on failure.
/**
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_basic_examples\hello_area_description\src\main\java\com\projecttango\examples\cpp\helloareadescription\SetAdfNameDialog.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_basic_examples\hello_area_description\src\main\java\com\projecttango\examples\cpp\helloareadescription\StartActivity.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// The unique key string for storing user's input.
// Key string for load/save Area Description Files.
// Permission request action.
// UI elements.
// Setup UI elements and listeners.
/**
/**
/**
/**
// The result of the permission activity.
//
// Note that when the permission activity is dismissed, the
// AreaDescription's onResume() callback is called. As the
// TangoService is connected in the onResume() function, we do not call
// connect here.
// Call the permission intent for the Tango Service to ask for permissions.
// All permission types can be found here:
//   https://developers.google.com/project-tango/apis/c/c-user-permissions
// After the permission activity is dismissed, we will receive a callback
// function onActivityResult() with user's result.
// Start the main area description activity and pass in user's configuration.
// Start the ADF list activity.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_basic_examples\hello_area_description\src\main\java\com\projecttango\examples\cpp\helloareadescription\TangoJniNative.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// This project depends on tango_client_api, so we need to make sure we load
// the correct library first.
/**
/*
/**
/**
/**
/**
/**
/**
/**
/**
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_basic_examples\hello_area_description\src\main\java\com\projecttango\examples\cpp\helloareadescription\Util.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
//com.google.atap.tango.PermissionStatusProvider/" +
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_basic_examples\hello_depth_perception\src\main\java\com\projecttango\examples\cpp\hellodepthperception\DepthPerceptionActivity.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Tango Service connection.
// Handle this if you need to gracefully shutdown/retry
// in the event that Tango itself crashes/gets upgraded while running.
// Setting content view of this activity.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_basic_examples\hello_depth_perception\src\main\java\com\projecttango\examples\cpp\hellodepthperception\package-info.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_basic_examples\hello_depth_perception\src\main\java\com\projecttango\examples\cpp\hellodepthperception\TangoJniNative.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// This project depends on tango_client_api, so we need to make sure we load
// the correct library first.
/**
/*
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_basic_examples\hello_motion_tracking\src\main\java\com\projecttango\examples\cpp\hellomotiontracking\HelloMotionTrackingActivity.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Tango Service connection.
// Handle this if you need to gracefully shutdown/retry
// in the event that Tango itself crashes/gets upgraded while running.
// Disconnect from Tango Service, release all the resources that the app is
// holding from Tango Service.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_basic_examples\hello_motion_tracking\src\main\java\com\projecttango\examples\cpp\hellomotiontracking\package-info.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_basic_examples\hello_motion_tracking\src\main\java\com\projecttango\examples\cpp\hellomotiontracking\TangoJniNative.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// This project depends on tango_client_api, so we need to make sure we load
// the correct library first.
/**
/*
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_basic_examples\hello_video\src\main\java\com\projecttango\examples\cpp\hellovideo\HelloVideoActivity.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Handle this if you need to gracefully shutdown/retry
// in the event that Tango itself crashes/gets upgraded while running.
// Register for display orientation change updates.
// Configure OpenGL renderer
/**
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_basic_examples\hello_video\src\main\java\com\projecttango\examples\cpp\hellovideo\HelloVideoRenderer.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Render loop of the Gl context.
// Called when the surface size changes.
// Called when the surface is created or recreated.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_basic_examples\hello_video\src\main\java\com\projecttango\examples\cpp\hellovideo\package-info.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_basic_examples\hello_video\src\main\java\com\projecttango\examples\cpp\hellovideo\TangoJniNative.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
/**
/**
/**
/**
/**
/**
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_example_util\app\src\main\java\com\projecttango\examples\cpp\util\package-info.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_example_util\app\src\main\java\com\projecttango\examples\cpp\util\TangoInitializationHelper.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
/**
// User doesn't have the latest packagename for TangoCore, fallback to the previous name.
// User doesn't have a Java-fied TangoCore at all; fallback to the deprecated approach
// of doing nothing and letting the native side auto-init to the system-service version
// of Tango.
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_marker_detection_example\app\src\main\java\com\projecttango\examples\cpp\markerdetection\MarkerDetectionActivity.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// GLSurfaceView and its renderer, all of the graphic content is rendered
// through OpenGL ES 2.0 in the native code.
// Screen size for normalizing the touch input for orbiting the render camera.
// Tango Service connection.
// The following code block does setup and connection to Tango.
// Handle this if you need to gracefully shutdown/retry
// in the event that Tango itself crashes/gets upgraded while running.
// Setting content view of this activity and getting the mIsAutoRecovery
// flag from StartActivity.
// OpenGL view where all of the graphics are drawn
// Configure OpenGL renderer
// Configure OpenGL renderer. The RENDERMODE_WHEN_DIRTY is set explicitly
// for reducing the CPU load. The request render function call is triggered
// by the onTextureAvailable callback from the Tango Service in the native
// code.
// Request onGlSurfaceDrawFrame on the glSurfaceView. This function is called from the
// native code, and it is triggered from the onTextureAvailable callback from
// the Tango Service.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_marker_detection_example\app\src\main\java\com\projecttango\examples\cpp\markerdetection\MarkerDetectionRenderer.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Render loop of the Gl context.
// Called when the surface size changes.
// Called when the surface is created or recreated.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_marker_detection_example\app\src\main\java\com\projecttango\examples\cpp\markerdetection\package-info.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_marker_detection_example\app\src\main\java\com\projecttango\examples\cpp\markerdetection\TangoJNINative.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// This project depends on tango_client_api, so we need to make sure we load
// the correct library first.
/**
/**
/**
/**
/**
/**
/**
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_mesh_builder_example\app\src\main\java\com\projecttango\examples\cpp\meshbuilder\MeshBuilderActivity.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// The minimum Tango Core version required from this application.
// The package name of Tang Core, used for checking minimum Tango Core version.
// Tag for debug logging.
// GLSurfaceView and its renderer, all of the graphic content is rendered
// through OpenGL ES 2.0 in the native code.
// Tango Service connection.
// Synchronization around MeshBuilderActivity object is to avoid
// Tango disconnect in the middle of the connecting operation.
// Handle this if you need to gracefully shutdown/retry
// in the event that Tango itself crashes/gets upgraded while running.
// Setup UI elements and listeners.
// OpenGL view where all of the graphics are drawn
// Configure OpenGL renderer
// Configure OpenGL renderer
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_mesh_builder_example\app\src\main\java\com\projecttango\examples\cpp\meshbuilder\MeshBuilderRenderer.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Render loop of the Gl context.
// Called when the surface size changes.
// Called when the surface is created or recreated.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_mesh_builder_example\app\src\main\java\com\projecttango\examples\cpp\meshbuilder\package-info.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_mesh_builder_example\app\src\main\java\com\projecttango\examples\cpp\meshbuilder\TangoJNINative.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// This project depends on tango_client_api, so we need to make sure we load
// the correct library first.
/**
/**
/**
/**
// Allocate OpenGL resources for rendering.
// Setup the view port width and height.
// Main render loop.
// Called when the toggle button is clicked
// Called when the clear button is clicked
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_motion_tracking_example\app\src\main\java\com\projecttango\examples\cpp\motiontracking\MotionTrackingActivity.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// GLSurfaceView and its renderer, all of the graphic content is rendered
// through OpenGL ES 2.0 in the native code.
// Tango Service connection.
// Handle this if you need to gracefully shutdown/retry
// in the event that Tango itself crashes/gets upgraded while running.
// OpenGL view where all of the graphics are drawn.
// Configure OpenGL renderer.
// Configure OpenGL renderer.
// Check the current screen rotation and set it to the renderer.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_motion_tracking_example\app\src\main\java\com\projecttango\examples\cpp\motiontracking\MotionTrackingRenderer.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Render loop of the Gl context.
// Called when the surface size changes.
// Called when the surface is created or recreated.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_motion_tracking_example\app\src\main\java\com\projecttango\examples\cpp\motiontracking\package-info.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_motion_tracking_example\app\src\main\java\com\projecttango\examples\cpp\motiontracking\TangoJNINative.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// This project depends on tango_client_api, so we need to make sure we load
// the correct library first.
/**
/**
/**
/**
/**
/**
/**
//developer.android.com/reference/android/view/Surface.html#ROTATION_0
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_plane_fitting_example\app\src\main\java\com\projecttango\examples\cpp\planefitting\GLSurfaceRenderer.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Render loop of the GL context.
// Called when the surface size changes.
// Called when the surface is created or recreated.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_plane_fitting_example\app\src\main\java\com\projecttango\examples\cpp\planefitting\MainActivity.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// GLSurfaceView and renderer, all of the graphic content is rendered
// through OpenGL ES 2.0 in native code.
// Tango Service connection.
// Handle this if you need to gracefully shutdown/retry
// in the event that Tango itself crashes/gets upgraded while running.
// Register for display orientation change updates.
// Ensure that handling of the touch event is run on the GL thread
// rather than Android UI thread. This ensures we can modify
// rendering state without locking.  This event triggers a plane
// fit.
// Pass device's camera sensor rotation to native layer.
// This parameter is important for Tango to render video overlay and
// virtual objects in the correct device orientation.
// OpenGL view where all of the graphics are drawn.
// Configure the OpenGL renderer.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_plane_fitting_example\app\src\main\java\com\projecttango\examples\cpp\planefitting\package-info.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_plane_fitting_example\app\src\main\java\com\projecttango\examples\cpp\planefitting\TangoJNINative.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// This project depends on tango_client_api, so we need to make sure we load
// the correct library first.
/**
/**
/**
/**
// Setup the view port width and height.
// Main render loop.
// Respond to a touch event.
// Respond to a display change.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_point_cloud_example\app\src\main\java\com\projecttango\examples\cpp\pointcloud\package-info.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_point_cloud_example\app\src\main\java\com\projecttango\examples\cpp\pointcloud\PointcloudActivity.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// The minimum Tango Core version required from this application.
// The package name of Tang Core, used for checking minimum Tango Core version.
// Tag for debug logging.
// The interval at which we'll update our UI debug text in milliseconds.
// This is the rate at which we query our native wrapper around the tango
// service for pose and event information.
// GLSurfaceView and renderer, all of the graphic content is rendered
// through OpenGL ES 2.0 in native code.
// Screen size for normalizing the touch input for orbiting the render camera.
// A flag to check if the Tango Service is connected. This flag avoids the
// program attempting to disconnect from the service while it is not
// connected.This is especially important in the onPause() callback for the
// activity class.
// Handles the debug text UI update loop.
// Tango Service connection.
// Handle this if you need to gracefully shutdown/retry
// in the event that Tango itself crashes/gets upgraded while running.
// Query screen size, the screen size is used for computing the normalized
// touch point.
// Setting content view of this activity.
// Buttons for selecting camera view and Set up button click listeners.
// OpenGL view where all of the graphics are drawn.
// Configure OpenGL renderer
// Configure the OpenGL renderer.
// Stop the debug text UI update loop.
// Handle button clicks.
// Pass the touch event to the native layer for camera control.
// Single touch to rotate the camera around the device.
// Two fingers to zoom in and out.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_point_cloud_example\app\src\main\java\com\projecttango\examples\cpp\pointcloud\Renderer.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Render loop of the Gl context.
// Called when the surface size changes.
// Called when the surface is created or recreated.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_point_cloud_example\app\src\main\java\com\projecttango\examples\cpp\pointcloud\TangoJNINative.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// This project depends on tango_client_api, so we need to make sure we load
// the correct library first.
/**
/**
/**
// Allocate OpenGL resources for rendering.
// Setup the view port width and height.
// Main render loop.
// Set the render camera's viewing angle:
//   first person, third person, or top down.
// Get total point count in current depth frame.
// Pass touch events to the native layer.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_point_to_point_example\app\src\main\java\com\projecttango\examples\cpp\pointtopoint\GLSurfaceRenderer.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Render loop of the GL context.
// Called when the surface size changes.
// Called when the surface is created or recreated.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_point_to_point_example\app\src\main\java\com\projecttango\examples\cpp\pointtopoint\MainActivity.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// The interval at which we'll update our UI debug text in milliseconds.
// This is the rate at which we query our native wrapper around the tango
// service for pose and event information.
// GLSurfaceView and renderer, all of the graphic content is rendered
// through OpenGL ES 2.0 in native code.
// Current frame's pose information.
// Handles the debug text UI update loop.
// Tango Service connection.
// Handle this if you need to gracefully shutdown/retry
// in the event that Tango itself crashes/gets upgraded while running.
// Register for display orientation change updates.
// Text views for Tango library versions
// Ensure that handling of the touch event is run on the GL thread
// rather than Android UI thread. This ensures we can modify
// rendering state without locking.  This event triggers a point
// placement.
// Pass device's camera sensor rotation and display rotation to native layer.
// These two parameter are important for Tango to render video overlay and
// virtual objects in the correct device orientation.
// OpenGL view where all of the graphics are drawn.
// Configure the OpenGL renderer.
// Is the view now checked?
// Start the debug text UI update loop.
// Debug text UI update loop, updating at 10Hz.
// Update the debug text UI.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_point_to_point_example\app\src\main\java\com\projecttango\examples\cpp\pointtopoint\package-info.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_point_to_point_example\app\src\main\java\com\projecttango\examples\cpp\pointtopoint\TangoJNINative.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// This project depends on tango_client_api, so we need to make sure we load
// the correct library first.
/**
/**
/**
// Allocate OpenGL resources for rendering and register the color
// camera texture.
// Use bilateral filtering to upsample point cloud.
// Get the distance between the two selected points.
// Setup the view port width and height.
// Main render loop.
// Respond to a touch event.
// Respond to a display change.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_rgb_depth_sync_example\app\src\main\java\com\projecttango\examples\cpp\rgbdepthsync\GLSurfaceRenderer.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_rgb_depth_sync_example\app\src\main\java\com\projecttango\examples\cpp\rgbdepthsync\MainActivity.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// The minimum Tango Core version required from this application.
// For all current Tango devices, color camera is in the camera id 0.
// Tango Service connection.
// Handle this if you need to gracefully shutdown/retry
// in the event that Tango itself crashes/gets upgraded while running.
// OpenGL view where all of the graphics are drawn
// Configure OpenGL renderer
// We moved most of the onResume lifecycle calls to the surfaceCreated,
// surfaceCreated will be called after the GLSurface is created.
// Pass device's camera sensor rotation and display rotation to native layer.
// These two parameter are important for Tango to render video overlay and
// virtual objects in the correct device orientation.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_rgb_depth_sync_example\app\src\main\java\com\projecttango\examples\cpp\rgbdepthsync\package-info.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_rgb_depth_sync_example\app\src\main\java\com\projecttango\examples\cpp\rgbdepthsync\TangoJNINative.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// This project depends on tango_client_api, so we need to make sure we load
// the correct library first.
/**
/**
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_video_stabilization_experiment\app\src\main\java\com\projecttango\experiments\cpp\videostabilization\package-info.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_video_stabilization_experiment\app\src\main\java\com\projecttango\experiments\cpp\videostabilization\TangoJNINative.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// This project depends on tango_client_api, so we need to make sure we load
// the correct library first.
/**
/**
/**
/**
/**
/**
/**
/**
/**
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_video_stabilization_experiment\app\src\main\java\com\projecttango\experiments\cpp\videostabilization\VideoStabilizationActivity.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// GLSurfaceView and its renderer, all of the graphic content is rendered
// through OpenGL ES 2.0 in the native code.
// Screen size for normalizing the touch input for orbiting the render camera.
// Tango Service connection.
// The following code block does setup and connection to Tango.
// Handle this if you need to gracefully shutdown/retry
// in the event that Tango itself crashes/gets upgraded while running.
// Querying screen size, used for computing the normalized touch point.
// Setting content view of this activity and getting the mIsAutoRecovery
// flag from StartActivity.
// OpenGL view where all of the graphics are drawn
// Configure OpenGL renderer
// Video stabilization switch.
// Configure OpenGL renderer. The RENDERMODE_WHEN_DIRTY is set explicitly
// for reducing the CPU load. The request render function call is triggered
// by the onTextureAvailable callback from the Tango Service in the native
// code.
// Request render on the glSurfaceView. This function is called from the
// native code, and it is triggered from the onTextureAvailable callback from
// the Tango Service.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\cpp_video_stabilization_experiment\app\src\main\java\com\projecttango\experiments\cpp\videostabilization\VideoStabilizationRenderer.java
/*
//www.apache.org/licenses/LICENSE-2.0
/**
// Render loop of the Gl context.
// Called when the surface size changes.
// Called when the surface is created or recreated.
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\autofit\afangles.c
/***************************************************************************/
/*                                                                         */
/*  afangles.c                                                             */
/*                                                                         */
/*    Routines used to compute vector angles with limited accuracy         */
/*    and very high speed.  It also contains sorting routines (body).      */
/*                                                                         */
/*  Copyright 2003, 2004, 2005, 2006 by                                    */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*
/*
/* the following table has been automatically generated with */
/* the `mather.py' Python script                             */
/* check trivial cases */
/* 0 */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\autofit\afcjk.c
/***************************************************************************/
/*                                                                         */
/*  afcjk.c                                                                */
/*                                                                         */
/*    Auto-fitter hinting routines for CJK script (body).                  */
/*                                                                         */
/*  Copyright 2006, 2007, 2008, 2009, 2010 by                              */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*
//www.kde.gr.jp/~akito/patch/freetype2/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****              C J K   G L O B A L   M E T R I C S              *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* TODO are there blues? */
/* latin's version would suffice */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****              C J K   G L Y P H   A N A L Y S I S              *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* a segment is round if it doesn't have successive */
/* on-curve points.                                 */
/* now compare each segment to the others */
/* the fake segments are for metrics hinting only */
/*
/* seg2 < seg1 < link1 < link2 */
/*********************************************************************/
/*                                                                   */
/* We begin by generating a sorted table of edges for the current    */
/* direction.  To do so, we simply scan each segment and try to find */
/* an edge in our table that corresponds to its position.            */
/*                                                                   */
/* If no edge is found, we create and insert a new edge in the       */
/* sorted table.  Otherwise, we simply add the segment to the edge's */
/* list which is then processed in the second step to compute the    */
/* edge's properties.                                                */
/*                                                                   */
/* Note that the edges table is sorted along the segment/edge        */
/* position.                                                         */
/*                                                                   */
/*********************************************************************/
/* look for an edge corresponding to the segment */
/* check whether all linked segments of the candidate edge */
/* can make a single edge.                                 */
/* insert a new edge in the list and */
/* sort according to the position    */
/* add the segment to the new edge's list */
/* if an edge was found, simply add the segment to the edge's */
/* list                                                       */
/*********************************************************************/
/*                                                                   */
/* Good, we now compute each edge's properties according to segments */
/* found on its position.  Basically, these are as follows.          */
/*                                                                   */
/*  - edge's main direction                                          */
/*  - stem edge, serif edge or both (which defaults to stem then)    */
/*  - rounded edge, straight or both (which defaults to straight)    */
/*  - link for edge                                                  */
/*                                                                   */
/*********************************************************************/
/* first of all, set the `edge' field in each segment -- this is     */
/* required in order to compute edge links                           */
/*                                                                   */
/* Note that removing this loop and setting the `edge' field of each */
/* segment directly in the code above slows down execution speed for */
/* some reasons on platforms like the Sun.                           */
/* now compute each edge properties */
/* does it contain round segments?    */
/* does it contain straight segments? */
/* check for roundness of segment */
/* check for links -- if seg->serif is set, then seg->link must */
/* be ignored                                                   */
/* set the round/straight flags */
/* get rid of serifs if link is set                 */
/* XXX: This gets rid of many unpleasant artefacts! */
/*      Example: the `c' in cour.pfa at size 13     */
/*
/* compute flags depending on render mode, etc. */
/*
/*
/*
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****          C J K   G L Y P H   G R I D - F I T T I N G          *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* snap a given width in scaled coordinates to one of the */
/* current standard widths                                */
/* compute the snapped width of a given stem */
/* smooth hinting process: very lightly quantize the stem width */
/* strong hinting process: snap the stem width to integer pixels */
/* in the case of vertical hinting, always round */
/* the stem heights to integer pixels            */
/* monochrome horizontal hinting: snap widths to integer pixels */
/* with a different threshold                                   */
/* for horizontal anti-aliased hinting, we adopt a more subtle */
/* approach: we strengthen small stems, round stems whose size */
/* is between 1 and 2 pixels to an integer, otherwise nothing  */
/* round otherwise to prevent color fringes in LCD mode */
/* align one stem edge relative to the previous stem edge */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                    E D G E   H I N T I N G                      ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* now we align all stem edges. */
/* skip all non-stem edges */
/* now align the stem */
/* 0 */
/* make sure that lowercase m's maintain their symmetry */
/* In general, lowercase m's have six vertical edges if they are sans */
/* serif, or twelve if they are with serifs.  This implementation is  */
/* based on that assumption, and seems to work very well with most    */
/* faces.  However, if for a certain face this assumption is not      */
/* true, the m is just rendered like before.  In addition, any stem   */
/* correction will only be applied to symmetrical glyphs (even if the */
/* glyph is not an m), so the potential for unwanted distortion is    */
/* relatively low.                                                    */
/* We don't handle horizontal edges since we can't easily assure that */
/* the third (lowest) stem aligns with the base line; it might end up */
/* one pixel higher or lower.                                         */
/* move the serifs along with the stem */
/*
/* move the points of each segment     */
/* in each edge to the edge's position */
/* analyze glyph outline */
/* grid-fit the outline */
/* AF_USE_WARPER */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                C J K   S C R I P T   C L A S S                *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* why this? */
/* CJK Radicals Supplement                 */
/* Kangxi Radicals                         */
/* CJK Symbols and Punctuation             */
/* Hiragana                                */
/* Katakana                                */
/* Bopomofo                                */
/* Hangul Compatibility Jamo               */
/* Bopomofo Extended                       */
/* CJK Strokes                             */
/* Katakana Phonetic Extensions            */
/* Enclosed CJK Letters and Months         */
/* CJK Compatibility                       */
/* CJK Unified Ideographs Extension A      */
/* Yijing Hexagram Symbols                 */
/* CJK Unified Ideographs                  */
/* CJK Compatibility Ideographs            */
/* CJK Compatibility Forms                 */
/* Halfwidth and Fullwidth Forms           */
/* CJK Unified Ideographs Extension B      */
/* CJK Compatibility Ideographs Supplement */
/* !AF_CONFIG_OPTION_CJK */
/* !AF_CONFIG_OPTION_CJK */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\autofit\afdummy.c
/***************************************************************************/
/*                                                                         */
/*  afdummy.c                                                              */
/*                                                                         */
/*    Auto-fitter dummy routines to be used if no hinting should be        */
/*    performed (body).                                                    */
/*                                                                         */
/*  Copyright 2003, 2004, 2005 by                                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\autofit\afglobal.c
/***************************************************************************/
/*                                                                         */
/*  afglobal.c                                                             */
/*                                                                         */
/*    Auto-fitter routines to compute global hinting values (body).        */
/*                                                                         */
/*  Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 by            */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* when updating this table, don't forget to update 
/* populate this list when you add new scripts */
/* do not remove */
/* FT_CONFIG_OPTION_PIC */
/* index of default script in `af_script_classes' */
/* a bit mask indicating an uncovered glyph       */
/* if this flag is set, we have an ASCII digit    */
/*
/* same as face->num_glyphs */
/* Compute the script index of each glyph within a given face. */
/* the value 255 means `uncovered glyph' */
/*
/* scan each script in a Unicode charmap */
/*
/* mark ASCII digits */
/*
/* no need to free this one! */
/* create the global metrics object when needed */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\autofit\afhints.c
/***************************************************************************/
/*                                                                         */
/*  afhints.c                                                              */
/*                                                                         */
/*    Auto-fitter hinting routines (body).                                 */
/*                                                                         */
/*  Copyright 2003, 2004, 2005, 2006, 2007, 2009, 2010 by                  */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* we want the edge with same position and minor direction */
/* to appear before those in the major one in the list     */
/* A function to dump the array of linked segments. */
/*
/* !AF_DEBUG */
/* these empty stubs are only used to link the `ftgrid' test program */
/* when debugging is disabled                                        */
/* !AF_DEBUG */
/* compute the direction value of a given vector */
/* long and short arm lengths */
/* candidate direction        */
/* dy < dx */
/*
/* first of all, reallocate the contours array when necessary */
/*
/* We can't rely on the value of `FT_Outline.flags' to know the fill   */
/* direction used for a glyph, given that some fonts are broken (e.g., */
/* the Arphic ones).  We thus recompute it each time we need to.       */
/*                                                                     */
/* compute coordinates & Bezier flags, next and prev */
/* set-up the contours array */
/* compute directions of in & out vectors */
/****************************************************************
/****************************************************************
/* hint the strong points -- this is equivalent to the TrueType `IP' */
/* hinting instruction                                               */
/* point position */
/* if this point is candidate to weak interpolation, we       */
/* interpolate it after all strong points have been processed */
/* is the point before the first edge? */
/* is the point after the last edge? */
/* find enclosing edges */
/* for small edge counts, a linear search is better */
/* we are on the edge */
/* assert( before && after && before != after ) */
/* save the point position */
/****************************************************************
/* PASS 1: Move segment points to edge positions */
/* find first touched point */
/* no touched point in contour */
/* skip any touched neighbhours */
/* find the next touched point, if any */
/* interpolate between last_touched and point */
/* special case: only one point was touched */
/* interpolate the last part */
/* now save the interpolated values back to x/y */
/* AF_USE_WARPER */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\autofit\afindic.c
/***************************************************************************/
/*                                                                         */
/*  afindic.c                                                              */
/*                                                                         */
/*    Auto-fitter hinting routines for Indic scripts (body).               */
/*                                                                         */
/*  Copyright 2007 by                                                      */
/*  Rahul Bhalerao <rahul.bhalerao@redhat.com>, <b.rahul.pm@gmail.com>.    */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* use CJK routines */
/* use CJK routines */
/* use CJK routines */
/* use CJK routines */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                I N D I C   S C R I P T   C L A S S            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* why this? */
/* Indic Range */
/* !AF_CONFIG_OPTION_INDIC */
/* !AF_CONFIG_OPTION_INDIC */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\autofit\aflatin.c
/***************************************************************************/
/*                                                                         */
/*  aflatin.c                                                              */
/*                                                                         */
/*    Auto-fitter hinting routines for latin script (body).                */
/*                                                                         */
/*  Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 by            */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****            L A T I N   G L O B A L   M E T R I C S            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* scan the array of segments in each direction */
/* we only consider stem segments there! */
/* let's try 20% of the smallest width */
/* we compute the blues simply by loading each character from the    */
/* 'af_latin_blue_chars[blues]' string, then compute its top-most or */
/* bottom-most points (depending on `AF_IS_TOP_BLUE')                */
/* same as points.y */
/* load the character in the face -- skip unknown or empty ones */
/* now compute min or max point indices and coordinates */
/* make compiler happy */
/* ditto */
/* ditto */
/* Avoid single-point contours since they are never rasterized. */
/* In some fonts, they correspond to mark attachment points     */
/* which are way outside of the glyph's real outline.           */
/* now check whether the point belongs to a straight or round   */
/* segment; we first need to find in which contour the extremum */
/* lies, then inspect its previous and next points              */
/* now look for the previous and next points that are not on the */
/* same Y coordinate.  Threshold the `closeness'...              */
/* now, set the `round' flag depending on the segment's kind */
/*
/* we have computed the contents of the `rounds' and `flats' tables, */
/* now determine the reference and overshoot position of the blue -- */
/* we simply take the median value after a simple sort               */
/* there are sometimes problems: if the overshoot position of top     */
/* zones is under its reference position, or the opposite for bottom  */
/* zones.  We must thus check everything there and correct the errors */
/*
/* check whether all ASCII digits have the same advance width; */
/* digit `0' is 0x30 in all supported charmaps                 */
/* end of list */
/* do we have a latin charmap in there? */
/* For now, compute the standard width and height from the `o'. */
/*
/* scale *= 0.98 */
/* scale the standard widths */
/* an extra-light axis corresponds to a standard width that is */
/* smaller than 0.75 pixels                                    */
/* scale the blue zones */
/* a blue zone is only active if it is less than 3/4 pixels tall */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****           L A T I N   G L Y P H   A N A L Y S I S             *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* set up (u,v) in each point */
/* do each contour separately */
/* minimum segment pos != min_coord */
/* maximum segment pos != max_coord */
/* skip singletons -- just in case */
/* we are already on an edge, try to locate its start */
/* we are just leaving an edge; record a new segment! */
/* a segment is round if either its first or last point */
/* is a control point                                   */
/* compute segment size */
/* fallthrough */
/* now exit if we are at the start/end point */
/* this is the start of a new segment! */
/* clear all segment fields */
/* contours */
/* now slightly increase the height of segments when this makes */
/* sense -- this is used to better detect and ignore serifs     */
/* now compare each segment to the others */
/* the fake segments are introduced to hint the metrics -- */
/* we must never link them to anything                     */
/* now, compute the `serif' segments */
/*
/*********************************************************************/
/*                                                                   */
/* We will begin by generating a sorted table of edges for the       */
/* current direction.  To do so, we simply scan each segment and try */
/* to find an edge in our table that corresponds to its position.    */
/*                                                                   */
/* If no edge is found, we create and insert a new edge in the       */
/* sorted table.  Otherwise, we simply add the segment to the edge's */
/* list which will be processed in the second step to compute the    */
/* edge's properties.                                                */
/*                                                                   */
/* Note that the edges table is sorted along the segment/edge        */
/* position.                                                         */
/*                                                                   */
/*********************************************************************/
/* A special case for serif edges: If they are smaller than */
/* 1.5 pixels we ignore them.                               */
/* look for an edge corresponding to the segment */
/* insert a new edge in the list and */
/* sort according to the position    */
/* add the segment to the new edge's list */
/* if an edge was found, simply add the segment to the edge's */
/* list                                                       */
/*********************************************************************/
/*                                                                   */
/* Good, we will now compute each edge's properties according to     */
/* segments found on its position.  Basically, these are:            */
/*                                                                   */
/*  - edge's main direction                                          */
/*  - stem edge, serif edge or both (which defaults to stem then)    */
/*  - rounded edge, straight or both (which defaults to straight)    */
/*  - link for edge                                                  */
/*                                                                   */
/*********************************************************************/
/* first of all, set the `edge' field in each segment -- this is */
/* required in order to compute edge links                       */
/*
/* now, compute each edge properties */
/* does it contain round segments?    */
/* does it contain straight segments? */
/* number of upwards segments         */
/* number of downwards segments       */
/* check for roundness of segment */
/* check for segment direction */
/* check for links -- if seg->serif is set, then seg->link must */
/* be ignored                                                   */
/* set the round/straight flags */
/* set the edge's main direction */
/* both up and down! */
/* gets rid of serifs if link is set                */
/* XXX: This gets rid of many unpleasant artefacts! */
/*      Example: the `c' in cour.pfa at size 13     */
/* compute which blue zones are active, i.e. have their scaled */
/* size < 3/4 pixels                                           */
/* for each horizontal edge search the blue zone which is closest */
/* initial threshold */
/* compute the initial threshold as a fraction of the EM size */
/* skip inactive blue zones (i.e., those that are too small) */
/* if it is a top zone, check for right edges -- if it is a bottom */
/* zone, check for left edges                                      */
/*                                                                 */
/* of course, that's for TrueType                                  */
/* if it is a top zone, the edge must be against the major    */
/* direction; if it is a bottom zone, it must be in the major */
/* direction                                                  */
/* first of all, compare it to the reference position */
/* now, compare it to the overshoot position if the edge is     */
/* rounded, and if the edge is over the reference position of a */
/* top zone, or under the reference position of a bottom zone   */
/*
/* compute flags depending on render mode, etc. */
/* #ifdef AF_USE_WARPER */
/*
/*
/*
/*
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****        L A T I N   G L Y P H   G R I D - F I T T I N G        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* snap a given width in scaled coordinates to one of the */
/* current standard widths                                */
/* compute the snapped width of a given stem */
/* smooth hinting process: very lightly quantize the stem width */
/* leave the widths of serifs alone */
/* compare to standard width */
/* strong hinting process: snap the stem width to integer pixels */
/* in the case of vertical hinting, always round */
/* the stem heights to integer pixels            */
/* monochrome horizontal hinting: snap widths to integer pixels */
/* with a different threshold                                   */
/* for horizontal anti-aliased hinting, we adopt a more subtle */
/* approach: we strengthen small stems, round stems whose size */
/* is between 1 and 2 pixels to an integer, otherwise nothing  */
/* We only round to an integer width if the corresponding */
/* distortion is less than 1/4 pixel.  Otherwise this     */
/* makes everything worse since the diagonals, which are  */
/* not hinted, appear a lot bolder or thinner than the    */
/* vertical stems.                                        */
/* round otherwise to prevent color fringes in LCD mode */
/* align one stem edge relative to the previous stem edge */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                    E D G E   H I N T I N G                      ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* we begin by aligning all stems relative to the blue zone */
/* if needed -- that's only for horizontal edges            */
/* now we will align all stem edges, trying to maintain the */
/* relative order of stems in the glyph                     */
/* skip all non-stem edges */
/* now align the stem */
/* this should not happen, but it's better to be safe */
/* make sure that lowercase m's maintain their symmetry */
/* In general, lowercase m's have six vertical edges if they are sans */
/* serif, or twelve if they are with serifs.  This implementation is  */
/* based on that assumption, and seems to work very well with most    */
/* faces.  However, if for a certain face this assumption is not      */
/* true, the m is just rendered like before.  In addition, any stem   */
/* correction will only be applied to symmetrical glyphs (even if the */
/* glyph is not an m), so the potential for unwanted distortion is    */
/* relatively low.                                                    */
/* We don't handle horizontal edges since we can't easily assure that */
/* the third (lowest) stem aligns with the base line; it might end up */
/* one pixel higher or lower.                                         */
/* move the serifs along with the stem */
/*
/* analyze glyph outline */
/* grid-fit the outline */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****              L A T I N   S C R I P T   C L A S S              *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* XXX: this should probably fine tuned to differentiate better between */
/*      scripts...                                                      */
/* Basic Latin (no control chars) */
/* Latin-1 Supplement (no control chars) */
/* Latin Extended-A */
/* Latin Extended-B */
/* IPA Extensions */
/* Spacing Modifier Letters */
/* Combining Diacritical Marks */
/* Greek and Coptic */
/* Cyrillic */
/* Cyrillic Supplement */
/* Phonetic Extensions */
/* Phonetic Extensions Supplement */
/* Combining Diacritical Marks Supplement */
/* Latin Extended Additional */
/* Greek Extended */
/* General Punctuation */
/* Superscripts and Subscripts */
/* Currency Symbols */
/* Number Forms */
/* Enclosed Alphanumerics */
/* Latin Extended-C */
/* Cyrillic Extended-A */
/* Cyrillic Extended-B */
/* Latin Extended-D */
/* Alphab. Present. Forms (Latin Ligs) */
/* Mathematical Alphanumeric Symbols */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\autofit\aflatin2.c
/***************************************************************************/
/*                                                                         */
/*  aflatin.c                                                              */
/*                                                                         */
/*    Auto-fitter hinting routines for latin script (body).                */
/*                                                                         */
/*  Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 by            */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****            L A T I N   G L O B A L   M E T R I C S            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* scan the array of segments in each direction */
/* we only consider stem segments there! */
/* let's try 20% of the smallest width */
/* we compute the blues simply by loading each character from the    */
/* 'af_latin2_blue_chars[blues]' string, then compute its top-most or */
/* bottom-most points (depending on `AF_IS_TOP_BLUE')                */
/* load the character in the face -- skip unknown or empty ones */
/* now compute min or max point indices and coordinates */
/* make compiler happy */
/* ditto */
/* ditto */
/* Avoid single-point contours since they are never rasterized. */
/* In some fonts, they correspond to mark attachment points     */
/* which are way outside of the glyph's real outline.           */
/* now check whether the point belongs to a straight or round   */
/* segment; we first need to find in which contour the extremum */
/* lies, then inspect its previous and next points              */
/* now look for the previous and next points that are not on the */
/* same Y coordinate.  Threshold the `closeness'...              */
/* now, set the `round' flag depending on the segment's kind */
/*
/* we have computed the contents of the `rounds' and `flats' tables, */
/* now determine the reference and overshoot position of the blue -- */
/* we simply take the median value after a simple sort               */
/* there are sometimes problems: if the overshoot position of top     */
/* zones is under its reference position, or the opposite for bottom  */
/* zones.  We must thus check everything there and correct the errors */
/*
/* check whether all ASCII digits have the same advance width; */
/* digit `0' is 0x30 in all supported charmaps                 */
/* end of list */
/* do we have a latin charmap in there? */
/* For now, compute the standard width and height from the `o'. */
/*
/* scale the standard widths */
/* an extra-light axis corresponds to a standard width that is */
/* smaller than 0.75 pixels                                    */
/* scale the blue zones */
/* a blue zone is only active if it is less than 3/4 pixels tall */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****           L A T I N   G L Y P H   A N A L Y S I S             *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* set up (u,v) in each point */
/* do each contour separately */
/* skip singletons -- just in case */
/* already on an edge ?, backtrack to find its start */
/* otherwise, find first segment start, if any */
/* we're at the start of a new segment */
/* record new segment */
/* a segment is round if it doesn't have successive */
/* on-curve points.                                 */
/* this can happen in the case of a degenerate contour
/* jump to the start of the next segment, if any */
/* contours */
/* now slightly increase the height of segments when this makes */
/* sense -- this is used to better detect and ignore serifs     */
/* place all segments with a negative direction to the start
/* now compare each segment to the others */
/* the fake segments are introduced to hint the metrics -- */
/* we must never link them to anything                     */
/* now, compute the `serif' segments */
/*
/*********************************************************************/
/*                                                                   */
/* We will begin by generating a sorted table of edges for the       */
/* current direction.  To do so, we simply scan each segment and try */
/* to find an edge in our table that corresponds to its position.    */
/*                                                                   */
/* If no edge is found, we create and insert a new edge in the       */
/* sorted table.  Otherwise, we simply add the segment to the edge's */
/* list which will be processed in the second step to compute the    */
/* edge's properties.                                                */
/*                                                                   */
/* Note that the edges table is sorted along the segment/edge        */
/* position.                                                         */
/*                                                                   */
/*********************************************************************/
/* A special case for serif edges: If they are smaller than */
/* 1.5 pixels we ignore them.                               */
/* unlink this serif, it is too distant from its reference stem */
/* look for an edge corresponding to the segment */
/* insert a new edge in the list and */
/* sort according to the position    */
/* add the segment to the new edge's list */
/* if an edge was found, simply add the segment to the edge's */
/* list                                                       */
/*********************************************************************/
/*                                                                   */
/* Good, we will now compute each edge's properties according to     */
/* segments found on its position.  Basically, these are:            */
/*                                                                   */
/*  - edge's main direction                                          */
/*  - stem edge, serif edge or both (which defaults to stem then)    */
/*  - rounded edge, straight or both (which defaults to straight)    */
/*  - link for edge                                                  */
/*                                                                   */
/*********************************************************************/
/* first of all, set the `edge' field in each segment -- this is */
/* required in order to compute edge links                       */
/*
/* now, compute each edge properties */
/* does it contain round segments?    */
/* does it contain straight segments? */
/* number of upwards segments         */
/* number of downwards segments       */
/* check for roundness of segment */
/* check for segment direction */
/* check for links -- if seg->serif is set, then seg->link must */
/* be ignored                                                   */
/* set the round/straight flags */
/* set the edge's main direction */
/* both up and down! */
/* gets rid of serifs if link is set                */
/* XXX: This gets rid of many unpleasant artefacts! */
/*      Example: the `c' in cour.pfa at size 13     */
/* initial threshold */
/* compute the initial threshold as a fraction of the EM size */
/* compute which blue zones are active, i.e. have their scaled */
/* size < 3/4 pixels                                           */
/* for each horizontal edge search the blue zone which is closest */
/* skip inactive blue zones (i.e., those that are too small) */
/* if it is a top zone, check for right edges -- if it is a bottom */
/* zone, check for left edges                                      */
/*                                                                 */
/* of course, that's for TrueType                                  */
/* if it is a top zone, the edge must be against the major    */
/* direction; if it is a bottom zone, it must be in the major */
/* direction                                                  */
/* if it's a rounded edge, compare it to the overshoot position */
/* if it's a flat edge, compare it to the reference position    */
/* now, compare it to the overshoot position if the edge is     */
/* rounded, and if the edge is over the reference position of a */
/* top zone, or under the reference position of a bottom zone   */
/*
/* compute flags depending on render mode, etc. */
/* #ifdef AF_USE_WARPER */
/*
/*
/*
/*
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****        L A T I N   G L Y P H   G R I D - F I T T I N G        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* snap a given width in scaled coordinates to one of the */
/* current standard widths                                */
/* compute the snapped width of a given stem */
/* smooth hinting process: very lightly quantize the stem width */
/* leave the widths of serifs alone */
/* compare to standard width */
/* strong hinting process: snap the stem width to integer pixels */
/* in the case of vertical hinting, always round */
/* the stem heights to integer pixels            */
/* monochrome horizontal hinting: snap widths to integer pixels */
/* with a different threshold                                   */
/* for horizontal anti-aliased hinting, we adopt a more subtle */
/* approach: we strengthen small stems, round stems whose size */
/* is between 1 and 2 pixels to an integer, otherwise nothing  */
/* We only round to an integer width if the corresponding */
/* distortion is less than 1/4 pixel.  Otherwise this     */
/* makes everything worse since the diagonals, which are  */
/* not hinted, appear a lot bolder or thinner than the    */
/* vertical stems.                                        */
/* round otherwise to prevent color fringes in LCD mode */
/* align one stem edge relative to the previous stem edge */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                    E D G E   H I N T I N G                      ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* we begin by aligning all stems relative to the blue zone */
/* if needed -- that's only for horizontal edges            */
/* now we will align all stem edges, trying to maintain the */
/* relative order of stems in the glyph                     */
/* skip all non-stem edges */
/* now align the stem */
/* this should not happen, but it's better to be safe */
/* we want to compare several displacement, and choose
/* note: don't even try to fit tiny stems */
/* if the span is within a single pixel, don't touch it */
/* we want to avoid the absolute worst case which is
/* snapping the left edge to the grid */
/* snapping the right edge to the grid */
/* now find the best displacement */
/* make sure that lowercase m's maintain their symmetry */
/* In general, lowercase m's have six vertical edges if they are sans */
/* serif, or twelve if they are with serifs.  This implementation is  */
/* based on that assumption, and seems to work very well with most    */
/* faces.  However, if for a certain face this assumption is not      */
/* true, the m is just rendered like before.  In addition, any stem   */
/* correction will only be applied to symmetrical glyphs (even if the */
/* glyph is not an m), so the potential for unwanted distortion is    */
/* relatively low.                                                    */
/* We don't handle horizontal edges since we can't easily assure that */
/* the third (lowest) stem aligns with the base line; it might end up */
/* one pixel higher or lower.                                         */
/* move the serifs along with the stem */
/*
/* analyze glyph outline */
/* grid-fit the outline */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****              L A T I N   S C R I P T   C L A S S              *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* XXX: TODO: Add new Unicode ranges here! */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\autofit\afloader.c
/***************************************************************************/
/*                                                                         */
/*  afloader.c                                                             */
/*                                                                         */
/*    Auto-fitter glyph loading routines (body).                           */
/*                                                                         */
/*  Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009 by                  */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* set linear metrics */
/* translate the loaded glyph when an internal transform is needed */
/* copy the outline points in the loader's current               */
/* extra points which is used to keep original glyph coordinates */
/* compute original horizontal phantom points (and ignore */
/* vertical ones)                                         */
/* be sure to check for spacing glyphs */
/* now load the slot image into the auto-outline and run the */
/* automatic hinting process                                 */
/* we now need to hint the metrics according to the change in */
/* width/positioning that occurred during the hinting process */
/* leftmost edge  */
/* rightmost edge */
/* remember unhinted values to later account */
/* for rounding errors                       */
/* prefer too much space over too little space */
/* for very small sizes                        */
/* good, we simply add the glyph to our loader's base */
/* first of all, copy the subglyph descriptors in the glyph loader */
/* now, read each subglyph independently */
/* gloader.current.subglyphs can change during glyph loading due */
/* to re-allocation -- we must recompute the current subglyph on */
/* each iteration                                                */
/* recompute subglyph pointer */
/* now perform the transform required for this subglyph */
/* apply offset */
/* for now, only use the current point coordinates;    */
/* we may consider another approach in the near future */
/* we don't support other formats (yet?) */
/* transform the hinted outline if needed */
/* we must translate our final outline by -pp1.x and compute */
/* the new metrics                                           */
/* for mono-width fonts (like Andale, Courier, etc.) we need */
/* to keep the original rounded advance width; ditto for     */
/* digits if all have the same advance width                 */
/* Set delta values to 0.  Otherwise code that uses them is */
/* going to ruin the fixed advance width.                   */
/* non-spacing glyphs must stay as-is */
/* now copy outline into glyph slot */
/* XXX: TODO: add support for sub-pixel hinting */
/* XXX: TODO: add support for sub-pixel hinting */
/* XXX: fix this */
/* XXX: undocumented hook to activate the latin2 hinter */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\autofit\afmodule.c
/***************************************************************************/
/*                                                                         */
/*  afmodule.c                                                             */
/*                                                                         */
/*    Auto-fitter module implementation (body).                            */
/*                                                                         */
/*  Copyright 2003, 2004, 2005, 2006 by                                    */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* version 1.0 of the autofitter  */
/* requires FreeType 2.0 or above */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\autofit\afpic.c
/***************************************************************************/
/*                                                                         */
/*  afpic.c                                                                */
/*                                                                         */
/*    The FreeType position independent code services for autofit module.  */
/*                                                                         */
/*  Copyright 2009, 2010 by                                                */
/*  Oran Agra and Mickey Gabel.                                            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* forward declaration of PIC init functions from afmodule.c */
/* forward declaration of PIC init functions from script classes */
/* allocate pointer, clear and set global container pointer */
/* initialize pointer table - this is how the module usually expects this data */
/* add call to initialization function when you add new scripts */
/*Exit:*/
/* FT_CONFIG_OPTION_PIC */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\autofit\afwarp.c
/***************************************************************************/
/*                                                                         */
/*  afwarp.c                                                               */
/*                                                                         */
/*    Auto-fitter warping algorithm (body).                                */
/*                                                                         */
/*  Copyright 2006, 2007 by                                                */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* compute minimum and maximum indices */
/* find best score */
/* get original scaling transformation */
/* get X1 and X2, minimum and maximum in original coordinates */
/* no scaling, just translation */
/* !AF_USE_WARPER */
/* make compiler happy */
/* !AF_USE_WARPER */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\autofit\autofit.c
/***************************************************************************/
/*                                                                         */
/*  autofit.c                                                              */
/*                                                                         */
/*    Auto-fitter module (body).                                           */
/*                                                                         */
/*  Copyright 2003, 2004, 2005, 2006, 2007 by                              */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\basepic.c
/***************************************************************************/
/*                                                                         */
/*  basepic.c                                                              */
/*                                                                         */
/*    The FreeType position independent code services for base.            */
/*                                                                         */
/*  Copyright 2009 by                                                      */
/*  Oran Agra and Mickey Gabel.                                            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* forward declaration of PIC init functions from ftglyph.c */
/* forward declaration of PIC init functions from ftinit.c */
/* Destroy default module classes (in case FT_Add_Default_Modules was used) */
/* allocate pointer, clear and set global container pointer */
/* initialize default modules list and pointers */
/* initialize pointer table - this is how the module usually expects this data */
/* FT_CONFIG_OPTION_PIC */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftadvanc.c
/***************************************************************************/
/*                                                                         */
/*  ftadvanc.c                                                             */
/*                                                                         */
/*    Quick computation of advance widths (body).                          */
/*                                                                         */
/*  Copyright 2008, 2009 by                                                */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* this must be the same scaling as to get linear{Hori,Vert}Advance */
/* (see `FT_Load_Glyph' implementation in src/base/ftobjs.c)        */
/* at the moment, we can perform fast advance retrieval only in */
/* the following cases:                                         */
/*                                                              */
/*  - unscaled load                                             */
/*  - unhinted load                                             */
/*  - light-hinted load                                         */
/* documentation is in ftadvanc.h */
/* documentation is in ftadvanc.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftapi.c
/***************************************************************************/
/*                                                                         */
/*  ftapi.c                                                                */
/*                                                                         */
/*    The FreeType compatibility functions (body).                         */
/*                                                                         */
/*  Copyright 2002 by                                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                                                                 ****/
/****                 C O M P A T I B I L I T Y                       ****/
/****                                                                 ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* backwards compatibility API */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftbase.c
/***************************************************************************/
/*                                                                         */
/*  ftbase.c                                                               */
/*                                                                         */
/*    Single object library component (body only).                         */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2006, 2007, 2008, 2009 by       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftbbox.c
/***************************************************************************/
/*                                                                         */
/*  ftbbox.c                                                               */
/*                                                                         */
/*    FreeType bbox computation (body).                                    */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2004, 2006, 2010 by                         */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used        */
/*  modified and distributed under the terms of the FreeType project       */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* This component has a _single_ role: to compute exact outline bounding */
/* boxes.                                                                */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    BBox_Move_To                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    This function is used as a `move_to' and `line_to' emitter during  */
/*    FT_Outline_Decompose().  It simply records the destination point   */
/*    in `user->last'; no further computations are necessary since we    */
/*    use the cbox as the starting bbox which must be refined.           */
/*                                                                       */
/* <Input>                                                               */
/*    to   :: A pointer to the destination vector.                       */
/*                                                                       */
/* <InOut>                                                               */
/*    user :: A pointer to the current walk context.                     */
/*                                                                       */
/* <Return>                                                              */
/*    Always 0.  Needed for the interface only.                          */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    BBox_Conic_Check                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Finds the extrema of a 1-dimensional conic Bezier curve and update */
/*    a bounding range.  This version uses direct computation, as it     */
/*    doesn't need square roots.                                         */
/*                                                                       */
/* <Input>                                                               */
/*    y1  :: The start coordinate.                                       */
/*                                                                       */
/*    y2  :: The coordinate of the control point.                        */
/*                                                                       */
/*    y3  :: The end coordinate.                                         */
/*                                                                       */
/* <InOut>                                                               */
/*    min :: The address of the current minimum.                         */
/*                                                                       */
/*    max :: The address of the current maximum.                         */
/*                                                                       */
/* flat arc */
/* ascending arc */
/* descending arc */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    BBox_Conic_To                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    This function is used as a `conic_to' emitter during               */
/*    FT_Outline_Decompose().  It checks a conic Bezier curve with the   */
/*    current bounding box, and computes its extrema if necessary to     */
/*    update it.                                                         */
/*                                                                       */
/* <Input>                                                               */
/*    control :: A pointer to a control point.                           */
/*                                                                       */
/*    to      :: A pointer to the destination vector.                    */
/*                                                                       */
/* <InOut>                                                               */
/*    user    :: The address of the current walk context.                */
/*                                                                       */
/* <Return>                                                              */
/*    Always 0.  Needed for the interface only.                          */
/*                                                                       */
/* <Note>                                                                */
/*    In the case of a non-monotonous arc, we compute directly the       */
/*    extremum coordinates, as it is sufficiently fast.                  */
/*                                                                       */
/* we don't need to check `to' since it is always an `on' point, thus */
/* within the bbox                                                    */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    BBox_Cubic_Check                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Finds the extrema of a 1-dimensional cubic Bezier curve and        */
/*    updates a bounding range.  This version uses splitting because we  */
/*    don't want to use square roots and extra accuracy.                 */
/*                                                                       */
/* <Input>                                                               */
/*    p1  :: The start coordinate.                                       */
/*                                                                       */
/*    p2  :: The coordinate of the first control point.                  */
/*                                                                       */
/*    p3  :: The coordinate of the second control point.                 */
/*                                                                       */
/*    p4  :: The end coordinate.                                         */
/*                                                                       */
/* <InOut>                                                               */
/*    min :: The address of the current minimum.                         */
/*                                                                       */
/*    max :: The address of the current maximum.                         */
/*                                                                       */
/* flat */
/* ascending */
/* descending */
/* unknown direction -- split the arc in two */
/* FT_Pos    a = y4 - 3*y3 + 3*y2 - y1; */
/* The polynomial is                      */
/*                                        */
/*    P(x) = a*x^3 + 3b*x^2 + 3c*x + d  , */
/*                                        */
/*   dP/dx = 3a*x^2 + 6b*x + 3c         . */
/*                                        */
/* However, we also have                  */
/*                                        */
/*   dP/dx(u) = 0                       , */
/*                                        */
/* which implies by subtraction that      */
/*                                        */
/*   P(u) = b*u^2 + 2c*u + d            . */
/* always compare first and last points */
/* now, try to see if there are split points here */
/* flat or ascending arc test */
/* y1 > y4 */
/* descending arc test */
/* There are some split points.  Find them. */
/* We need to solve `ax^2+2bx+c' here, without floating points!      */
/* The trick is to normalize to a different representation in order  */
/* to use our 16.16 fixed point routines.                            */
/*                                                                   */
/* We compute FT_MulFix(b,b) and FT_MulFix(a,c) after normalization. */
/* These values must fit into a single 16.16 value.                  */
/*                                                                   */
/* We normalize a, b, and c to `8.16' fixed float values to ensure   */
/* that its product is held in a `16.16' value.                      */
/* The following computation is based on the fact that for   */
/* any value `y', if `n' is the position of the most         */
/* significant bit of `abs(y)' (starting from 0 for the      */
/* least significant bit), then `y' is in the range          */
/*                                                           */
/*   -2^n..2^n-1                                             */
/*                                                           */
/* We want to shift `a', `b', and `c' concurrently in order  */
/* to ensure that they all fit in 8.16 values, which maps    */
/* to the integer range `-2^23..2^23-1'.                     */
/*                                                           */
/* Necessarily, we need to shift `a', `b', and `c' so that   */
/* the most significant bit of its absolute values is at     */
/* _most_ at position 23.                                    */
/*                                                           */
/* We begin by computing `t1' as the bitwise `OR' of the     */
/* absolute values of `a', `b', `c'.                         */
/* Now we can be sure that the most significant bit of `t1'  */
/* is the most significant bit of either `a', `b', or `c',   */
/* depending on the greatest integer range of the particular */
/* variable.                                                 */
/*                                                           */
/* Next, we compute the `shift', by shifting `t1' as many    */
/* times as necessary to move its MSB to position 23.  This  */
/* corresponds to a value of `t1' that is in the range       */
/* 0x40_0000..0x7F_FFFF.                                     */
/*                                                           */
/* Finally, we shift `a', `b', and `c' by the same amount.   */
/* This ensures that all values are now in the range         */
/* -2^23..2^23, i.e., they are now expressed as 8.16         */
/* fixed-float numbers.  This also means that we are using   */
/* 24 bits of precision to compute the zeros, independently  */
/* of the range of the original polynomial coefficients.     */
/*                                                           */
/* This algorithm should ensure reasonably accurate values   */
/* for the zeros.  Note that they are only expressed with    */
/* 16 bits when computing the extrema (the zeros need to     */
/* be in 0..1 exclusive to be considered part of the arc).   */
/* all coefficients are 0! */
/* this loses some bits of precision, but we use 24 of them */
/* for the computation anyway                               */
/* handle a == 0 */
/* solve the equation now */
/* there is a single split point at -b/a */
/* there are two solutions; we need to filter them */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    BBox_Cubic_To                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    This function is used as a `cubic_to' emitter during               */
/*    FT_Outline_Decompose().  It checks a cubic Bezier curve with the   */
/*    current bounding box, and computes its extrema if necessary to     */
/*    update it.                                                         */
/*                                                                       */
/* <Input>                                                               */
/*    control1 :: A pointer to the first control point.                  */
/*                                                                       */
/*    control2 :: A pointer to the second control point.                 */
/*                                                                       */
/*    to       :: A pointer to the destination vector.                   */
/*                                                                       */
/* <InOut>                                                               */
/*    user     :: The address of the current walk context.               */
/*                                                                       */
/* <Return>                                                              */
/*    Always 0.  Needed for the interface only.                          */
/*                                                                       */
/* <Note>                                                                */
/*    In the case of a non-monotonous arc, we don't compute directly     */
/*    extremum coordinates, we subdivide instead.                        */
/*                                                                       */
/* we don't need to check `to' since it is always an `on' point, thus */
/* within the bbox                                                    */
/* documentation is in ftbbox.h */
/* if outline is empty, return (0,0,0,0) */
/* We compute the control box as well as the bounding box of  */
/* all `on' points in the outline.  Then, if the two boxes    */
/* coincide, we exit immediately.                             */
/* update control box */
/* update bbox for `on' points only */
/* test two boxes for equality */
/* the two boxes are different, now walk over the outline to */
/* get the Bezier arc extrema.                               */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftbdf.c
/***************************************************************************/
/*                                                                         */
/*  ftbdf.c                                                                */
/*                                                                         */
/*    FreeType API for accessing BDF-specific strings (body).              */
/*                                                                         */
/*  Copyright 2002, 2003, 2004 by                                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* documentation is in ftbdf.h */
/* documentation is in ftbdf.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftbitmap.c
/***************************************************************************/
/*                                                                         */
/*  ftbitmap.c                                                             */
/*                                                                         */
/*    FreeType utility functions for bitmaps (body).                       */
/*                                                                         */
/*  Copyright 2004, 2005, 2006, 2007, 2008, 2009 by                        */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* documentation is in ftbitmap.h */
/* documentation is in ftbitmap.h */
/* if no need to allocate memory */
/* zero the padding */
/* set pitch only, width and height are left untouched */
/* documentation is in ftbitmap.h */
/* for each row */
/*
/* the maximum value of 8 for `xstr' comes from here */
/*
/* documentation is in ftbitmap.h */
/* get the full bytes */
/* avoid a byte->int cast on each line */
/* get remaining pixels (if any) */
/* get the full bytes */
/* get the full bytes */
/* documentation is in ftbitmap.h */
/* documentation is in ftbitmap.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftcalc.c
/***************************************************************************/
/*                                                                         */
/*  ftcalc.c                                                               */
/*                                                                         */
/*    Arithmetic computations (body).                                      */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2008 by             */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* Support for 1-complement arithmetic has been totally dropped in this  */
/* release.  You can still write your own code if you need it.           */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* Implementing basic computation routines.                              */
/*                                                                       */
/* FT_MulDiv(), FT_MulFix(), FT_DivFix(), FT_RoundFix(), FT_CeilFix(),   */
/* and FT_FloorFix() are declared in freetype.h.                         */
/*                                                                       */
/*************************************************************************/
/* we need to define a 64-bits data type here */
/* FT_LONG64 */
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* The following three functions are available regardless of whether */
/* FT_LONG64 is defined.                                             */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* documentation is in ftcalc.h */
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/* documentation is in freetype.h */
/* documentation is in ftcalc.h */
/* TT_USE_BYTECODE_INTERPRETER */
/* documentation is in freetype.h */
/* FT_MULFIX_ASSEMBLER */
/* documentation is in freetype.h */
/* check for division by 0 */
/* compute result directly */
/* !FT_LONG64 */
/* Check carry overflow of i1 + i2 */
/* Check carry overflow of i1 + lo */
/* documentation is in freetype.h */
/* The FT_MulDiv function has been optimized thanks to ideas from      */
/* Graham Asher.  The trick is to optimize computation when everything */
/* fits within 32-bits (a rather common case).                         */
/*                                                                     */
/*  we compute 'a*b+c/2', then divide it by 'c'. (positive values)     */
/*                                                                     */
/*  46340 is FLOOR(SQRT(2^31-1)).                                      */
/*                                                                     */
/*  if ( a <= 46340 && b <= 46340 ) then ( a*b <= 0x7FFEA810 )         */
/*                                                                     */
/*  0x7FFFFFFF - 0x7FFEA810 = 0x157F0                                  */
/*                                                                     */
/*  if ( c < 0x157F0*2 ) then ( a*b+c/2 <= 0x7FFFFFFF )                */
/*                                                                     */
/*  and 2*0x157F0 = 176096                                             */
/*                                                                     */
/* XXX: this function does not allow 64-bit arguments */
/* TT_USE_BYTECODE_INTERPRETER */
/* documentation is in freetype.h */
/*
/*
/* 0 */
/* 0 */
/* documentation is in freetype.h */
/* XXX: this function does not allow 64-bit arguments */
/* check for division by 0 */
/* compute result directly */
/* we need more bits; we have to do it by hand */
/* documentation is in ftcalc.h */
/* apparently, the second version of this code is not compiled correctly */
/* on Mac machines with the MPW C compiler..  tsk, tsk, tsk...           */
/* Shortcut */
/* we know y is to be treated as unsigned here */
/* Return Max/Min Int32 if division overflow. */
/* This includes division by zero!            */
/* 0 */
/* Shortcut */
/* 0 */
/* 0 */
/* FT_LONG64 */
/* documentation is in ftglyph.h */
/* documentation is in ftglyph.h */
/* compute discriminant */
/* matrix can't be inverted */
/* documentation is in ftcalc.h */
/* documentation is in ftcalc.h */
/* documentation is in ftcalc.h */
/* documentation is in ftcalc.h */
/* avoid overflow on 16-bit system */
/* deal with the trivial cases quickly */
/* general case */
/* XXX: this function does not allow 64-bit arguments */
/* XXX: only the sign of return value, +1/0/-1 must be used */
/* documentation is in ftcalc.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftcid.c
/***************************************************************************/
/*                                                                         */
/*  ftcid.c                                                                */
/*                                                                         */
/*    FreeType API for accessing CID font information.                     */
/*                                                                         */
/*  Copyright 2007, 2009 by Derek Clegg, Michael Toftdal.                  */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* documentation is in ftcid.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftdbgmem.c
/***************************************************************************/
/*                                                                         */
/*  ftdbgmem.c                                                             */
/*                                                                         */
/*    Memory debugger (body).                                              */
/*                                                                         */
/*  Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2009 by                  */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* `Keep alive' means that freed blocks aren't released
/*
/* current number of allocated blocks */
/* max. number of allocated blocks    */
/* total number of blocks allocated   */
/* current cumulative allocated size */
/* maximum cumulative allocated size */
/* total cumulative allocated size   */
/* current maximum allocated size */
/*
/*
/* < 0 if the block was freed */
/*
/*
/* remove all blocks from the table, revealing leaked ones */
/* remove all sources */
/* cast to FT_PtrDist first since void* can be larger */
/* than FT_UInt32 and GCC 4.1.1 emits a warning       */
/* This block was already freed.  Our memory is now completely */
/* corrupted!                                                  */
/* This can only happen in keep-alive mode.                    */
/* This block was already allocated.  This means that our memory */
/* is also corrupted!                                            */
/* we need to create a new node in this table */
/* this is an allocation */
/* we are growing or shrinking a reallocated block */
/* we are allocating a new block */
/* scramble the node's content for additional safety */
/* we simply invert the node's size to indicate that the node */
/* was freed.                                                 */
/* return NULL if the maximum number of allocations was reached */
/* return NULL if this allocation would overflow the maximum heap size */
/* unlikely, but possible */
/* the following is valid according to ANSI C */
/* while the following is allowed in ANSI C also, we abort since */
/* such case should be handled by FreeType.                      */
/* check `cur_size' value */
/* return NULL if the maximum number of allocations was reached */
/* return NULL if this allocation would overflow the maximum heap size */
/* !FT_DEBUG_MEMORY */
/* ANSI C doesn't like empty source files */
/* !FT_DEBUG_MEMORY */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftdebug.c
/***************************************************************************/
/*                                                                         */
/*  ftdebug.c                                                              */
/*                                                                         */
/*    Debugging and logging component (body).                              */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2004, 2008 by                               */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* This component contains various macros and functions used to ease the */
/* debugging of the FreeType engine.  Its main purpose is in assertion   */
/* checking, tracing, and error detection.                               */
/*                                                                       */
/* There are now three debugging modes:                                  */
/*                                                                       */
/* - trace mode                                                          */
/*                                                                       */
/*   Error and trace messages are sent to the log file (which can be the */
/*   standard error output).                                             */
/*                                                                       */
/* - error mode                                                          */
/*                                                                       */
/*   Only error messages are generated.                                  */
/*                                                                       */
/* - release mode:                                                       */
/*                                                                       */
/*   No error message is sent or generated.  The code is free from any   */
/*   debugging parts.                                                    */
/*                                                                       */
/*************************************************************************/
/* documentation is in ftdebug.h */
/* documentation is in ftdebug.h */
/* FT_DEBUG_LEVEL_ERROR */
/* array of trace levels, initialized to 0 */
/* define array of trace toggle names */
/* documentation is in ftdebug.h */
/* documentation is in ftdebug.h */
/*************************************************************************/
/*                                                                       */
/* Initialize the tracing sub-system.  This is done by retrieving the    */
/* value of the `FT2_DEBUG' environment variable.  It must be a list of  */
/* toggles, separated by spaces, `;', or `,'.  Example:                  */
/*                                                                       */
/*    export FT2_DEBUG="any:3 memory:7 stream:5"                         */
/*                                                                       */
/* This requests that all levels be set to 3, except the trace level for */
/* the memory and stream components which are set to 7 and 5,            */
/* respectively.                                                         */
/*                                                                       */
/* See the file <include/freetype/internal/fttrace.h> for details of the */
/* available toggle names.                                               */
/*                                                                       */
/* The level must be between 0 and 7; 0 means quiet (except for serious  */
/* runtime errors), and 7 means _very_ verbose.                          */
/*                                                                       */
/* skip leading whitespace and separators */
/* read toggle name, followed by ':' */
/* read level */
/* special case for `any' */
/* !FT_DEBUG_LEVEL_TRACE */
/* nothing */
/* !FT_DEBUG_LEVEL_TRACE */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftfstype.c
/***************************************************************************/
/*                                                                         */
/*  ftfstype.c                                                             */
/*                                                                         */
/*    FreeType utility file to access FSType data (body).                  */
/*                                                                         */
/*  Copyright 2008, 2009 by                                                */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* documentation is in freetype.h */
/* first, try to get the fs_type directly from the font */
/* look at FSType before fsType for Type42 */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftgasp.c
/***************************************************************************/
/*                                                                         */
/*  ftgasp.c                                                               */
/*                                                                         */
/*    Access of TrueType's `gasp' table (body).                            */
/*                                                                         */
/*  Copyright 2007 by                                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* ensure that we don't have spurious bits */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftgloadr.c
/***************************************************************************/
/*                                                                         */
/*  ftgloadr.c                                                             */
/*                                                                         */
/*    The FreeType glyph loader (body).                                    */
/*                                                                         */
/*  Copyright 2002, 2003, 2004, 2005, 2006, 2010 by                        */
/*  David Turner, Robert Wilhelm, and Werner Lemberg                       */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                                                               *****/
/*****                    G L Y P H   L O A D E R                    *****/
/*****                                                               *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The glyph loader is a simple object which is used to load a set of    */
/* glyphs easily.  It is critical for the correct loading of composites. */
/*                                                                       */
/* Ideally, one can see it as a stack of abstract `glyph' objects.       */
/*                                                                       */
/*   loader.base     Is really the bottom of the stack.  It describes a  */
/*                   single glyph image made of the juxtaposition of     */
/*                   several glyphs (those `in the stack').              */
/*                                                                       */
/*   loader.current  Describes the top of the stack, on which a new      */
/*                   glyph can be loaded.                                */
/*                                                                       */
/*   Rewind          Clears the stack.                                   */
/*   Prepare         Set up `loader.current' for addition of a new glyph */
/*                   image.                                              */
/*   Add             Add the `current' glyph image to the `base' one,    */
/*                   and prepare for another one.                        */
/*                                                                       */
/* The glyph loader is now a base object.  Each driver used to           */
/* re-implement it in one way or the other, which wasted code and        */
/* energy.                                                               */
/*                                                                       */
/*************************************************************************/
/* create a new glyph loader */
/* rewind the glyph loader - reset counters to 0 */
/* reset the glyph loader, frees all allocated tables */
/* and starts from zero                               */
/* delete a glyph loader */
/* re-adjust the `current' outline fields */
/* handle extra points table - if any */
/* re-adjust the `current' subglyphs field */
/* Ensure that we can add `n_points' and `n_contours' to our glyph.      */
/* This function reallocates its outline tables if necessary.  Note that */
/* it DOESN'T change the number of points within the loader!             */
/*                                                                       */
/* check points & tags */
/* check contours */
/* Ensure that we can add `n_subglyphs' to our glyph. this function */
/* reallocates its subglyphs table if necessary.  Note that it DOES */
/* NOT change the number of subglyphs within the loader!            */
/*                                                                  */
/* prepare loader for the addition of a new glyph on top of the base one */
/* add current glyph to the base image - and prepare for another */
/* adjust contours count in newest outline */
/* prepare for another new glyph image */
/* do we need to copy the extra points? */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftglyph.c
/***************************************************************************/
/*                                                                         */
/*  ftglyph.c                                                              */
/*                                                                         */
/*    FreeType convenience functions to handle glyphs (body).              */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2007, 2008, 2010 by       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/*  This file contains the definition of several convenience functions   */
/*  that can be used by client applications to easily retrieve glyph     */
/*  bitmaps and outlines from a given face.                              */
/*                                                                       */
/*  These functions should be optional if you are writing a font server  */
/*  or text layout engine on top of FreeType.  However, they are pretty  */
/*  handy for many other simple uses of the library.                     */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****   FT_BitmapGlyph support                                        ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/* do lazy copying whenever possible */
/* FT_Glyph_TransformFunc */
/* FT_Glyph_PrepareFunc   */
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****   FT_OutlineGlyph support                                       ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/* check format in glyph slot */
/* allocate new outline */
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****   FT_Glyph class and API                                        ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/* documentation is in ftglyph.h */
/* check arguments */
/* documentation is in ftglyph.h */
/* if it is a bitmap, that's easy :-) */
/* if it is an outline */
/* try to find a renderer that supports the glyph image format */
/* create FT_Glyph object */
/* copy advance while converting it to 16.16 format */
/* now import the image from the glyph slot */
/* if an error occurred, destroy the glyph */
/* documentation is in ftglyph.h */
/* transform glyph image */
/* transform advance vector */
/* documentation is in ftglyph.h */
/* retrieve bbox in 26.6 coordinates */
/* perform grid fitting if needed */
/* convert to integer pixels if needed */
/* documentation is in ftglyph.h */
/* check argument */
/* we render the glyph into a glyph bitmap using a `dummy' glyph slot */
/* then calling FT_Render_Glyph_Internal()                            */
/* when called with a bitmap glyph, do nothing and return successfully */
/* create result bitmap glyph */
/* if `origin' is set, translate the glyph image */
/* prepare dummy slot for rendering */
/* in case of success, copy the bitmap to the glyph bitmap */
/* copy advance */
/* documentation is in ftglyph.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftgxval.c
/***************************************************************************/
/*                                                                         */
/*  ftgxval.c                                                              */
/*                                                                         */
/*    FreeType API for validating TrueTyepGX/AAT tables (body).            */
/*                                                                         */
/*  Copyright 2004, 2005, 2006, 2010 by                                    */
/*  Masatake YAMATO, Redhat K.K,                                           */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/* documentation is in ftgxval.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftinit.c
/***************************************************************************/
/*                                                                         */
/*  ftinit.c                                                               */
/*                                                                         */
/*    FreeType initialization layer (body).                                */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2005, 2007, 2009 by                         */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/*  The purpose of this file is to implement the following two           */
/*  functions:                                                           */
/*                                                                       */
/*  FT_Add_Default_Modules():                                            */
/*     This function is used to add the set of default modules to a      */
/*     fresh new library object.  The set is taken from the header file  */
/*     `freetype/config/ftmodule.h'.  See the document `FreeType 2.0     */
/*     Build System' for more information.                               */
/*                                                                       */
/*  FT_Init_FreeType():                                                  */
/*     This function creates a system object for the current platform,   */
/*     builds a library out of it, then calls FT_Default_Drivers().      */
/*                                                                       */
/*  Note that even if FT_Init_FreeType() uses the implementation of the  */
/*  system object defined at build time, client applications are still   */
/*  able to provide their own `ftsystem.c'.                              */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* FT_CONFIG_OPTION_PIC */
/* declare the module's class creation/destruction functions */
/* count all module classes */
/* destroy all module classes */  
/* initialize all module classes and the pointer table */
/* initialize all pointers to 0, especially the last one */
/* FT_CONFIG_OPTION_PIC */
/* documentation is in ftmodapi.h */
/* test for valid `library' delayed to FT_Add_Module() */
/* notify errors, but don't stop */
/* documentation is in freetype.h */
/* First of all, allocate a new system object -- this function is part */
/* of the system-specific component, i.e. `ftsystem.c'.                */
/* build a library out of it, then fill it with the set of */
/* default drivers.                                        */
/* documentation is in freetype.h */
/* Discard the library object */
/* discard memory manager */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftlcdfil.c
/***************************************************************************/
/*                                                                         */
/*  ftlcdfil.c                                                             */
/*                                                                         */
/*    FreeType API for color filtering of subpixel bitmap glyphs (body).   */
/*                                                                         */
/*  Copyright 2006, 2008, 2009, 2010 by                                    */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* define USE_LEGACY to implement the legacy filter */
/* FIR filter used by the default and light filters */
/* horizontal in-place FIR filter */
/* vertical in-place FIR filter */
/* intra-pixel filter used by the legacy filter */
/* horizontal in-place intra-pixel filter */
/* USE_LEGACY */
/* the values here sum up to a value larger than 256, */
/* providing a cheap gamma correction                 */
/* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
/* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftmac.c
/***************************************************************************/
/*                                                                         */
/*  ftmac.c                                                                */
/*                                                                         */
/*    Mac FOND support.  Written by just@letterror.com.                    */
/*  Heavily modified by mpsuzuki, George Williams, and Sean McBride.       */
/*                                                                         */
/*  This file is for Mac OS X only; see builds/mac/ftoldmac.c for          */
/*  classic platforms built by MPW.                                        */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,         */
/*            2009 by                                                      */
/*  Just van Rossum, David Turner, Robert Wilhelm, and Werner Lemberg.     */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*
/* This is for Mac OS X.  Without redefinition, OS_INLINE */
/* expands to `static inline' which doesn't survive the   */
/* -ansi compilation flag of GCC.                         */
/* `configure' checks the availability of `ResourceIndex' strictly */
/* and sets HAVE_TYPE_RESOURCE_INDEX 1 or 0 always.  If it is      */
/* not set (e.g., a build without `configure'), the availability   */
/* is guessed from the SDK version.                                */
/* !HAVE_TYPE_RESOURCE_INDEX */
/* PATH_MAX */
/* Don't want warnings about our own use of deprecated functions. */
/* since Mac OS X 10.1 */
/* Set PREFER_LWFN to 1 if LWFN (Type 1) is preferred over
/* This function is deprecated because FSSpec is deprecated in Mac OS X  */
/* Private function.                                         */
/* The FSSpec type has been discouraged for a long time,     */
/* unfortunately an FSRef replacement API for                */
/* ATSFontGetFileSpecification() is only available in        */
/* Mac OS X 10.5 and later.                                  */
/* No 64bit Carbon API on legacy platforms */
/* 32bit Carbon API on legacy platforms */
/* face_index calculation by searching preceding fontIDs */
/* with same FSRef                                       */
/* This function is deprecated because FSSpec is deprecated in Mac OS X  */
/* at present, no support for dfont format */
/* fallback to original resource-fork font */
/* Return the file type for given pathname */
/* Given a PostScript font name, create the Macintosh LWFN file name. */
/* The count is 1 greater than the value in the FOND.  */
/* Isn't that cute? :-)                                */
/* Look inside the FOND data, answer whether there should be an SFNT
/* the maximum faces in a FOND is 48, size of StyleTable.indexes[] */
/* Let's do a little range checking before we get too excited here */
/* add on the face_index! */
/* if the face at this index is not scalable,
/* Pathname for FSRef can be in various formats: HFS, HFS+, and POSIX. */
/* We should not extract parent directory by string manipulation.      */
/* now we have absolute dirname in path_lwfn */
/* Read Type 1 data from the POST resources inside the LWFN file,
/* First pass: load all POST resources, and determine the size of */
/* the output buffer.                                             */
/* we are done */
/* just the end code */
/* code + 4 bytes chunk length */
/* detect integer overflows */
/* Second pass: append all POST data to the buffer, add PFB fields. */
/* Glue all consecutive chunks of the same type together.           */
/* we are done */
/* we are done adding a chunk, fill in the size field */
/* the end */
/* binary segment */
/* ASCII segment */
/* save for later */
/* make space for size field */
/* Create a new FT_Face from a file path to an LWFN file. */
/* PFB is already loaded, useless anymore */
/* Create a new FT_Face from an SFNT resource, specified by res ID. */
/* Create a new FT_Face from a file path to a suitcase file. */
/* documentation is in ftmac.h */
/* Common function to load a new FT_Face from a resource file. */
/* LWFN is a (very) specific file format, check for it explicitly */
/* Otherwise the file type doesn't matter (there are more than  */
/* `FFIL' and `tfil').  Just try opening it as a font suitcase; */
/* if it works, fine.                                           */
/* let it fall through to normal loader (.ttf, .otf, etc.); */
/* we signal this by returning no error and no FT_Face      */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    FT_New_Face                                                        */
/*                                                                       */
/* <Description>                                                         */
/*    This is the Mac-specific implementation of FT_New_Face.  In        */
/*    addition to the standard FT_New_Face() functionality, it also      */
/*    accepts pathnames to Mac suitcase files.  For further              */
/*    documentation see the original FT_New_Face() in freetype.h.        */
/*                                                                       */
/* test for valid `library' and `aface' delayed to FT_Open_Face() */
/* try resourcefork based font: LWFN, FFIL */
/* let it fall through to normal loader (.ttf, .otf, etc.) */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    FT_New_Face_From_FSRef                                             */
/*                                                                       */
/* <Description>                                                         */
/*    FT_New_Face_From_FSRef is identical to FT_New_Face except it       */
/*    accepts an FSRef instead of a path.                                */
/*                                                                       */
/* This function is deprecated because Carbon data types (FSRef)         */
/* are not cross-platform, and thus not suitable for the freetype API.   */
/* fallback to datafork font */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    FT_New_Face_From_FSSpec                                            */
/*                                                                       */
/* <Description>                                                         */
/*    FT_New_Face_From_FSSpec is identical to FT_New_Face except it      */
/*    accepts an FSSpec instead of a path.                               */
/*                                                                       */
/* This function is deprecated because FSSpec is deprecated in Mac OS X  */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftmm.c
/***************************************************************************/
/*                                                                         */
/*  ftmm.c                                                                 */
/*                                                                         */
/*    Multiple Master font support (body).                                 */
/*                                                                         */
/*  Copyright 1996-2001, 2003, 2004, 2009 by                               */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* documentation is in ftmm.h */
/* documentation is in ftmm.h */
/* documentation is in ftmm.h */
/* documentation is in ftmm.h */
/* documentation is in ftmm.h */
/* documentation is in ftmm.h */
/* This is exactly the same as the previous function.  It exists for */
/* orthogonality.                                                    */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftobjs.c
/***************************************************************************/
/*                                                                         */
/*  ftobjs.c                                                               */
/*                                                                         */
/*    The FreeType private base classes (body).                            */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,   */
/*            2010 by                                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* for SFNT_Load_Table_Func */
/* This function doesn't work!  None should call it. */
/* since the cast below also disables the compiler's */
/* type check, we introduce a dummy variable, which  */
/* will be optimized away                            */
/* throw away volatileness; use `jump_buffer' or the  */
/* compiler may warn about an unused local variable   */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                                                                 ****/
/****                           S T R E A M                           ****/
/****                                                                 ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* create a new input stream from an FT_Open_Args structure */
/*                                                          */
/* create a memory-based stream */
/* create a normal system stream */
/* use an existing, user-provided stream */
/* in this case, we do not need to allocate a new stream object */
/* since the caller is responsible for closing it himself       */
/* just to be certain */
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                                                                 ****/
/****               FACE, SIZE & GLYPH SLOT OBJECTS                   ****/
/****                                                                 ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* assume that the bitmap buffer was stolen or not */
/* allocated from the heap                         */
/* free bitmap if needed */
/* clear all public fields in the glyph slot */
/* `slot->bitmap.buffer' has been handled by ft_glyphslot_free_bitmap */
/* free bitmap buffer if needed */
/* slot->internal might be NULL in out-of-memory situations */
/* free glyph loader */
/* documentation is in ftobjs.h */
/* documentation is in ftobjs.h */
/* Remove slot from its parent face's list */
/* documentation is in freetype.h */
/* set transform_flags bit flag 0 if `matrix' isn't the identity */
/* set transform_flags bit flag 1 if `delta' isn't the null vector */
/* GRID_FIT_METRICS */
/* documentation is in freetype.h */
/* The validity test for `glyph_index' is performed by the */
/* font drivers.                                           */
/* resolve load flags dependencies */
/*
/* try to load embedded bitmaps first if available            */
/*                                                            */
/* XXX: This is really a temporary hack that should disappear */
/*      promptly with FreeType 2.1!                           */
/*                                                            */
/* since the auto-hinter calls FT_Load_Glyph by itself, */
/* make sure that glyphs aren't transformed             */
/* load auto-hinted outline */
/* check that the loaded outline is correct */
/* compute the advance */
/* compute the linear advance in 16.16 pixels */
/* it's tricky! */
/* now, transform the glyph image if needed */
/* get renderer */
/* apply `standard' transformation if no renderer is available */
/* transform advance */
/* do we need to render the image now? */
/* documentation is in freetype.h */
/* destructor for sizes list */
/* finalize client-specific data */
/* finalize format-specific stuff */
/* destructor for faces list */
/* discard auto-hinting data */
/* Discard glyph slots for this face.                           */
/* Beware!  FT_Done_GlyphSlot() changes the field `face->glyph' */
/* discard all sizes for this face */
/* now discard client data */
/* discard charmaps */
/* finalize format-specific stuff */
/* close the stream for this face if needed */
/* get rid of it */
/* check whether we need to drop the driver's glyph loader */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    find_unicode_charmap                                               */
/*                                                                       */
/* <Description>                                                         */
/*    This function finds a Unicode charmap, if there is one.            */
/*    And if there is more than one, it tries to favour the more         */
/*    extensive one, i.e., one that supports UCS-4 against those which   */
/*    are limited to the BMP (said UCS-2 encoding.)                      */
/*                                                                       */
/*    This function is called from open_face() (just below), and also    */
/*    from FT_Select_Charmap( ..., FT_ENCODING_UNICODE ).                */
/*                                                                       */
/* caller should have already checked that `face' is valid */
/*
/* Since the `interesting' table, with IDs (3,10), is normally the */
/* last one, we loop backwards.  This loses with type1 fonts with  */
/* non-BMP characters (<.0001%), this wins with .ttf with non-BMP  */
/* chars (.01% ?), and this is the same about 99.99% of the time!  */
/* points after the last one */
/* XXX If some new encodings to represent UCS-4 are added, */
/*     they should be added here.                          */
/* We do not have any UCS-4 charmap.                */
/* Do the loop again and search for UCS-2 charmaps. */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    find_variant_selector_charmap                                      */
/*                                                                       */
/* <Description>                                                         */
/*    This function finds the variant selector charmap, if there is one. */
/*    There can only be one (platform=0, specific=5, format=14).         */
/*                                                                       */
/* caller should have already checked that `face' is valid */
/* points after the last one */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    open_face                                                          */
/*                                                                       */
/* <Description>                                                         */
/*    This function does some work for FT_Open_Face().                   */
/*                                                                       */
/* allocate the face object and perform basic initialization */
/* select Unicode charmap by default */
/* if no Unicode charmap can be found, FT_Err_Invalid_CharMap_Handle */
/* is returned.                                                      */
/* no error should happen, but we want to play safe */
/* there's a Mac-specific extended implementation of FT_New_Face() */
/* in src/base/ftmac.c                                             */
/* documentation is in freetype.h */
/* test for valid `library' and `aface' delayed to FT_Open_Face() */
/* defined( FT_MACINTOSH ) && !defined( DARWIN_NO_CARBON ) */
/* documentation is in freetype.h */
/* test for valid `library' and `face' delayed to FT_Open_Face() */
/* The behavior here is very similar to that in base/ftmac.c, but it     */
/* is designed to work on non-mac systems, so no mac specific calls.     */
/*                                                                       */
/* We look at the file and determine if it is a mac dfont file or a mac  */
/* resource file, or a macbinary file containing a mac resource file.    */
/*                                                                       */
/* Unlike ftmac I'm not going to look at a `FOND'.  I don't really see   */
/* the point, especially since there may be multiple `FOND' resources.   */
/* Instead I'll just look for `sfnt' and `POST' resources, ordered as    */
/* they occur in the file.                                               */
/*                                                                       */
/* Note that multiple `POST' resources do not mean multiple postscript   */
/* fonts; they all get jammed together to make what is essentially a     */
/* pfb file.                                                             */
/*                                                                       */
/* We aren't interested in `NFNT' or `FONT' bitmap resources.            */
/*                                                                       */
/* As soon as we get an `sfnt' load it into memory and pass it off to    */
/* FT_Open_Face.                                                         */
/*                                                                       */
/* If we have a (set of) `POST' resources, massage them into a (memory)  */
/* pfb file and pass that to FT_Open_Face.  (As with ftmac.c I'm not     */
/* going to try to save the kerning info.  After all that lives in the   */
/* `FOND' which isn't in the file containing the `POST' resources so     */
/* we don't really have access to it.                                    */
/* Finalizer for a memory stream; gets called by FT_Done_Face(). */
/* It frees the memory it uses.                                  */
/* From ftmac.c.                                                 */
/* Create a new memory stream from a buffer and a size. */
/* From ftmac.c.                                        */
/* Create a new FT_Face given a buffer and a driver name. */
/* from ftmac.c */
/* At this point, face_index has served its purpose;      */
/* whoever calls this function has already used it to     */
/* locate the correct font data.  We should not propagate */
/* this index to FT_Open_Face() (unless it is negative).  */
/* Look up `TYP1' or `CID ' table from sfnt table directory.       */
/* `offset' and `length' must exclude the binary header in tables. */
/* Type 1 and CID-keyed font drivers should recognize sfnt-wrapped */
/* format too.  Here, since we can't expect that the TrueType font */
/* driver is loaded unconditially, we must parse the font by       */
/* ourselves.  We are only interested in the name of the table and */
/* the offset.                                                     */
/* TODO: support for sfnt-wrapped PS/CID in TTC format */
/* version check for 'typ1' (should be ignored?) */
/* skip binary search header */
/* The resource header says we've got resource_cnt `POST' (type1) */
/* resources in this file.  They all need to be coalesced into    */
/* one lump which gets passed on to the type1 driver.             */
/* Here can be only one PostScript font in a file so face_index   */
/* must be 0 (or -1).                                             */
/*                                                                */
/* Find the length of all the POST resources, concatenated.  Assume */
/* worst case (each resource in its own section).                   */
/* Ascii section */
/* 4-byte length, fill in later */
/* Comment, should not be loaded */
/* the flags are part of the resource, so rlen >= 2.  */
/* but some fonts declare rlen = 0 for empty fragment */
/* End of font mark */
/* 4-byte length, fill in later */
/* The resource header says we've got resource_cnt `sfnt'      */
/* (TrueType/OpenType) resources in this file.  Look through   */
/* them for the one indicated by face_index, load it into mem, */
/* pass it on the the truetype driver and return it.           */
/*                                                             */
/* rewind sfnt stream before open_face_PS_from_sfnt_stream() */
/* Check for a valid resource fork header, or a valid dfont    */
/* header.  In a resource fork the first 16 bytes are repeated */
/* at the location specified by bytes 4-7.  In a dfont bytes   */
/* 4-7 point to 16 bytes of zeroes instead.                    */
/*                                                             */
/* POST exists in an LWFN providing a single face */
/* Check for a valid macbinary header, and if we find one   */
/* check that the (flattened) resource fork in it is valid. */
/*                                                          */
/* 0 */
/* Caller (load_mac_face) requires FT_Err_Unknown_File_Format. */
/* Check for some macintosh formats without Carbon framework.    */
/* Is this a macbinary file?  If so look at the resource fork.   */
/* Is this a mac dfont file?                                     */
/* Is this an old style resource fork? (in data)                 */
/* Else call load_face_in_embedded_rfork to try extra rules      */
/* (defined in `ftrfork.c').                                     */
/*                                                               */
/* !FT_MACINTOSH && FT_CONFIG_OPTION_MAC_FONTS */
/* documentation is in freetype.h */
/* test for valid `library' delayed to */
/* FT_Stream_New()                     */
/* create input stream */
/* If the font driver is specified in the `args' structure, use */
/* it.  Otherwise, we scan the list of registered drivers.      */
/* not all modules are drivers, so check... */
/* check each font driver for an appropriate format */
/* not all modules are font drivers, so check... */
/* TrueType but essential tables are missing */
/* If we are on the mac, and we get an FT_Err_Invalid_Stream_Operation */
/* it may be because we have an empty data fork, so we need to check   */
/* the resource fork.                                                  */
/* We don't want to go to Success here.  We've already done that. */
/* On the other hand, if we succeeded we still need to close this */
/* stream (we opened a different stream which extracted the       */
/* interesting information out of this stream here.  That stream  */
/* will still be open and the face will point to it).             */
/* !FT_MACINTOSH && FT_CONFIG_OPTION_MAC_FONTS */
/* no driver is able to handle this format */
/* set the FT_FACE_FLAG_EXTERNAL_STREAM bit for FT_Done_Face */
/* add the face object to its driver's list */
/* don't assume driver is the same as face->driver, so use */
/* face->driver instead.                                   */
/* now allocate a glyph slot object for the face */
/* finally, allocate a size object for the face */
/* some checks */
/* initialize internal face data */
/* documentation is in freetype.h */
/* test for valid `face' delayed to FT_Attach_Stream() */
/* documentation is in freetype.h */
/* test for valid `parameters' delayed to FT_Stream_New() */
/* we implement FT_Attach_Stream in each driver through the */
/* `attach_file' interface                                  */
/* close the attached stream */
/* documentation is in freetype.h */
/* find face in driver's list */
/* remove face object from the driver's list */
/* now destroy the object proper */
/* documentation is in ftobjs.h */
/* Allocate new size object and perform basic initialisation */
/* for now, do not use any internal fields in size objects */
/* in case of success, add to the face's list */
/* documentation is in ftobjs.h */
/* documentation is in ftobjs.h */
/* FT_Bitmap_Size doesn't provide enough info... */
/* documentation is in ftobjs.h */
/* compensate for glyph with bbox above/below the baseline */
/* the factor 1.2 is a heuristical value */
/* Compute root ascender, descender, test height, and max_advance */
/* !GRID_FIT_METRICS */
/* !GRID_FIT_METRICS */
/* to be on the safe side */
/* determine scales */
/* calculate the ppems */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/*
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* use `>=' to avoid potential compiler warning on 16bit platforms */
/* documentation is in freetype.h */
/* we scale down kerning values for small ppem values */
/* to avoid that rounding makes them too big.         */
/* `25' has been determined heuristically.            */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* FT_ENCODING_UNICODE is special.  We try to find the `best' Unicode */
/* charmap available, i.e., one with UCS-4 characters, if possible.   */
/*                                                                    */
/* This is done by find_unicode_charmap() above, to share code.       */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* remove it from our list of charmaps */
/* add it to our list of charmaps */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* clean up buffer */
/* documentation is in freetype.h */
/* documentation is in tttables.h */
/* documentation is in tttables.h */
/* documentation is in tttables.h */
/* documentation is in tttables.h */
/* documentation is in tttables.h */
/* documentation is in ftsizes.h */
/* we don't need anything more complex than that; all size objects */
/* are already listed by the face                                  */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                                                                 ****/
/****                        R E N D E R E R S                        ****/
/****                                                                 ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* lookup a renderer by glyph format in the library's list */
/* allocate raster object if needed */
/* add to list */
/* release raster object, if any */
/* remove from list */
/* documentation is in ftrender.h */
/* test for valid `library' delayed to FT_Lookup_Renderer() */
/* documentation is in ftrender.h */
/* if it is already a bitmap, no need to do anything */
/* already a bitmap, don't do anything */
/* small shortcut for the very common case */
/* FT_Err_Cannot_Render_Glyph is returned if the render mode   */
/* is unsupported by the current renderer for this glyph image */
/* format.                                                     */
/* now, look for another renderer that supports the same */
/* format.                                               */
/* if we changed the current renderer for the glyph image format */
/* we need to select it as the next current one                  */
/* documentation is in freetype.h */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                                                                 ****/
/****                         M O D U L E S                           ****/
/****                                                                 ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Destroy_Module                                                     */
/*                                                                       */
/* <Description>                                                         */
/*    Destroys a given module object.  For drivers, this also destroys   */
/*    all child faces.                                                   */
/*                                                                       */
/* <InOut>                                                               */
/*     module :: A handle to the target driver object.                   */
/*                                                                       */
/* <Note>                                                                */
/*     The driver _must_ be LOCKED!                                      */
/*                                                                       */
/* finalize client-data - before anything else */
/* if the module is a renderer */
/* if the module is a font driver, add some steps */
/* finalize the module object */
/* discard it */
/* documentation is in ftmodapi.h */
/* check freetype version */
/* look for a module with the same name in the library's table */
/* this installed module has the same name, compare their versions */
/* remove the module from our list, then exit the loop to replace */
/* it by our new version..                                        */
/* allocate module object */
/* base initialization */
/* check whether the module is a renderer - this must be performed */
/* before the normal module initialization                         */
/* add to the renderers list */
/* is the module a auto-hinter? */
/* if the module is a font driver */
/* allocate glyph loader if needed */
/* add module to the library's table */
/* documentation is in ftmodapi.h */
/* documentation is in ftobjs.h */
/* test for valid `library' delayed to FT_Get_Module() */
/* first, look for the service in the module
/* we didn't find it, look in all other modules then
/* documentation is in ftmodapi.h */
/* try to find the module from the table, then remove it from there */
/* remove it from the table */
/* destroy the module */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                                                                 ****/
/****                         L I B R A R Y                           ****/
/****                                                                 ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* documentation is in ftmodapi.h */
/* init debugging support */
/* first of all, allocate the library object */
/* initialize position independent code containers */
/* allocate the render pool */
/* That's ok now */
/* documentation is in freetype.h */
/* documentation is in ftmodapi.h */
/* Discard client-data */
/* Close all faces in the library.  If we don't do
/* Close all other modules in the library */
/* XXX Modules are removed in the reversed order so that  */
/* type42 module is removed before truetype module.  This */
/* avoids double free in some occasions.  It is a hack.   */
/* Destroy raster objects */
/* Destroy pic container contents */
/* documentation is in ftmodapi.h */
/* documentation is in ftmodapi.h */
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/* documentation is in freetype.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftotval.c
/***************************************************************************/
/*                                                                         */
/*  ftotval.c                                                              */
/*                                                                         */
/*    FreeType API for validating OpenType tables (body).                  */
/*                                                                         */
/*  Copyright 2004, 2006, 2008, 2010 by                                    */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* documentation is in ftotval.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftoutln.c
/***************************************************************************/
/*                                                                         */
/*  ftoutln.c                                                              */
/*                                                                         */
/*    FreeType outline management (body).                                  */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 by */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* All functions are declared in freetype.h.                             */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* documentation is in ftoutln.h */
/* index of contour in outline     */
/* index of first point in contour */
/* current point's state           */
/* index of last point in contour */
/* A contour cannot start with a cubic control point! */
/* check first point to determine origin */
/* first point is conic control.  Yes, this happens. */
/* start at last point if it is on the curve */
/* if both first and last points are conic,         */
/* start at their middle and record its position    */
/* for closure                                      */
/* emit a single line_to */
/* consume conic arcs */
/* FT_CURVE_TAG_CUBIC */
/* close the contour with a line segment */
/* documentation is in ftoutln.h */
/* documentation is in ftoutln.h */
/* empty glyph? */
/* check point and contour counts */
/* note that we don't accept empty contours */
/* XXX: check the tags array */
/* documentation is in ftoutln.h */
/* copy all flags, except the `FT_OUTLINE_OWNER' one */
/* documentation is in ftoutln.h */
/* check for valid `outline' in FT_Outline_Done_Internal() */
/* documentation is in ftoutln.h */
/* documentation is in ftoutln.h */
/* documentation is in ftoutln.h */
/* reverse point table */
/* reverse tags table */
/* documentation is in ftoutln.h */
/* FT_Err_Cannot_Render_Glyph is returned if the render mode   */
/* is unsupported by the current renderer for this glyph image */
/* format                                                      */
/* now, look for another renderer that supports the same */
/* format                                                */
/* if we changed the current renderer for the glyph image format */
/* we need to select it as the next current one                  */
/* documentation is in ftoutln.h */
/* other checks are delayed to FT_Outline_Render() */
/* documentation is in freetype.h */
/* documentation is in ftoutln.h */
/* Is a point in some contour?                     */
/*                                                 */
/* We treat every point of the contour as if it    */
/* it were ON.  That is, we allow false positives, */
/* but disallow false negatives.  (XXX really?)    */
/* a and b are on the same side */
/* This version differs from the public one in that each */
/* part (contour not enclosed in another contour) of the */
/* outline is checked for orientation.  This is          */
/* necessary for some buggy CJK fonts.                   */
/* skip degenerate contours */
/* check the orientation of the contour */
/* 0 */
/* documentation is in ftoutln.h */
/* compute the in and out vectors */
/* documentation is in ftoutln.h */
/* We use the nonzero winding rule to find the orientation.       */
/* Since glyph outlines behave much more `regular' than arbitrary */
/* cubic or quadratic curves, this test deals with the polygon    */
/* only which is spanned up by the control points.                */
/* skip degenerate contours */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftpatent.c
/***************************************************************************/
/*                                                                         */
/*  ftpatent.c                                                             */
/*                                                                         */
/*    FreeType API for checking patented TrueType bytecode instructions    */
/*    (body).                                                              */
/*                                                                         */
/*  Copyright 2007, 2008, 2010 by David Turner.                            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
// */
/* SPvTL // */
/* SPvTL +  */
// */
/* SFvTL // */
/* SFvTL +  */
/* SPvFS    */
/* SFvFS    */
/* DELTAP2 */
/* DELTAP3 */
/* DELTAC0 */
/* DELTAC1 */
/* DELTAC2 */
/* simple glyph */
/* compound glyph */
/* now read each component */
/* ARGS_ARE_WORDS */
/* WE_HAVE_A_SCALE */
/* WE_HAVE_X_Y_SCALE */
/* WE_HAVE_A_2x2 */
/* WE_HAVE_INSTRUCTIONS */
/* MORE_COMPONENTS */
/* documentation is in freetype.h */
/* documentation is in freetype.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftpfr.c
/***************************************************************************/
/*                                                                         */
/*  ftpfr.c                                                                */
/*                                                                         */
/*    FreeType API for accessing PFR-specific data (body).                 */
/*                                                                         */
/*  Copyright 2002, 2003, 2004, 2008, 2010 by                              */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* check the format */
/* documentation is in ftpfr.h */
/* this is not a PFR font */
/* documentation is in ftpfr.h */
/* documentation is in ftpfr.h */
/* XXX: TODO: PROVIDE ADVANCE-LOADING METHOD TO ALL FONT DRIVERS */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftpic.c
/***************************************************************************/
/*                                                                         */
/*  ftpic.c                                                                */
/*                                                                         */
/*    The FreeType position independent code services (body).              */
/*                                                                         */
/*  Copyright 2009 by                                                      */
/*  Oran Agra and Mickey Gabel.                                            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* documentation is in ftpic.h */
/* Destroy the contents of the container. */
/* FT_CONFIG_OPTION_PIC */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftrfork.c
/***************************************************************************/
/*                                                                         */
/*  ftrfork.c                                                              */
/*                                                                         */
/*    Embedded resource forks accessor (body).                             */
/*                                                                         */
/*  Copyright 2004, 2005, 2006, 2007, 2008, 2009, 2010 by                  */
/*  Masatake YAMATO and Redhat K.K.                                        */
/*                                                                         */
/*  FT_Raccess_Get_HeaderInfo() and raccess_guess_darwin_hfsplus() are     */
/*  derived from ftobjs.c.                                                 */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/* Development of the code in this file is support of                      */
/* Information-technology Promotion Agency, Japan.                         */
/***************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                                                                 ****/
/****               Resource fork directory access                    ****/
/****                                                                 ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* map_len = head[12] .. head[15] */
/* make it be different */
/* If we have reached this point then it is probably a mac resource */
/* file.  Now, does it contain any interesting resources?           */
/* Skip handle to next resource map, the file resource number, and  */
/* attributes.                                                      */
/* skip handle to next resource map */
/* skip file resource number */
/* skip attributes */
/* resource name */
/* mbz */
/* XXX: duplicated reference ID,
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                                                                 ****/
/****                     Guessing functions                          ****/
/****                                                                 ****/
/****            When you add a new guessing function,                ****/
/****           update FT_RACCESS_N_RULES in ftrfork.h.               ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                       Helper functions                          ****/
/****                                                                 ****/
/*************************************************************************/
/*
/*
/* filler */
/* offset + length */
/* !FT_CONFIG_OPTION_GUESSING_EMBEDDED_RFORK */
/*************************************************************************/
/*                  Dummy function; just sets errors                     */
/*************************************************************************/
/* !FT_CONFIG_OPTION_GUESSING_EMBEDDED_RFORK */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftsnames.c
/***************************************************************************/
/*                                                                         */
/*  ftsnames.c                                                             */
/*                                                                         */
/*    Simple interface to access SFNT name tables (which are used          */
/*    to hold font names, copyright info, notices, etc.) (body).           */
/*                                                                         */
/*    This is _not_ used to retrieve glyph names!                          */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2009 by                                     */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* documentation is in ftsnames.h */
/* documentation is in ftsnames.h */
/* load name on demand */
/* TT_CONFIG_OPTION_SFNT_NAMES */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftstream.c
/***************************************************************************/
/*                                                                         */
/*  ftstream.c                                                             */
/*                                                                         */
/*    I/O stream support (body).                                           */
/*                                                                         */
/*  Copyright 2000-2001, 2002, 2004, 2005, 2006, 2008, 2009, 2010 by       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* note that seeking to the first position after the file is valid */
/* equivalent to FT_Stream_ExitFrame(), with no memory block release */
/* check for nested frame access */
/* allocate the frame in memory */
/* simple sanity check */
/* assume _ft_debug_file and _ft_debug_lineno are already set */
/* read it */
/* check current and new position */
/* set cursor */
/* IMPORTANT: The assertion stream->cursor != 0 was removed, given    */
/*            that it is possible to access a frame of length 0 in    */
/*            some weird fonts (usually, when accessing an array of   */
/*            0 records, like in some strange kern tables).           */
/*                                                                    */
/*  In this case, the loader code handles the 0-length table          */
/*  gracefully; however, stream.cursor is really set to 0 by the      */
/*  FT_Stream_EnterFrame() call, and this is not an error.            */
/*                                                                    */
/* access a new frame */
/* loop! */
/* read a byte sequence */
/* skip some bytes      */
/* read a single byte */
/* read a 2-byte big-endian short */
/* read a 2-byte little-endian short */
/* read a 4-byte big-endian long */
/* read a 4-byte little-endian long */
/* read a 3-byte big-endian long */
/* read a 3-byte little-endian long */
/* otherwise, exit the loop */
/* now, compute the signed value is necessary */
/* finally, store the value in the object */
/* for 64-bit systems */
/* go to next field */
/* close the frame if it was opened by this read */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftstroke.c
/***************************************************************************/
/*                                                                         */
/*  ftstroke.c                                                             */
/*                                                                         */
/*    FreeType path stroker (body).                                        */
/*                                                                         */
/*  Copyright 2002, 2003, 2004, 2005, 2006, 2008, 2009, 2010 by            */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* documentation is in ftstroke.h */
/* documentation is in ftstroke.h */
/***************************************************************************/
/***************************************************************************/
/*****                                                                 *****/
/*****                       BEZIER COMPUTATIONS                       *****/
/*****                                                                 *****/
/***************************************************************************/
/***************************************************************************/
/* basically a point */
/* close2 */
/***************************************************************************/
/***************************************************************************/
/*****                                                                 *****/
/*****                       STROKE BORDERS                            *****/
/*****                                                                 *****/
/***************************************************************************/
/***************************************************************************/
/* on-curve point  */
/* cubic off-point */
/* sub-path start  */
/* sub-path end    */
/* index of current sub-path start point */
/* don't record empty paths! */
/* copy the last point to the start of this sub-path, since */
/* it contains the `adjusted' starting coordinates          */
/* reverse the points */
/* then the tags */
/* move last point */
/* add one point */
/* compute start point */
/* compute end point */
/* compute first and second control points */
/* add cubic arc */
/* process the rest of the arc ?? */
/* close current open path if any ? */
/* copy point locations */
/* copy tags */
/* copy contours */
/***************************************************************************/
/***************************************************************************/
/*****                                                                 *****/
/*****                           STROKER                               *****/
/*****                                                                 *****/
/***************************************************************************/
/***************************************************************************/
/* documentation is in ftstroke.h */
/* documentation is in ftstroke.h */
/* documentation is in ftstroke.h */
/* documentation is in ftstroke.h */
/* creates a circular arc at a corner or cap */
/* adds a cap at the end of an opened path */
/* add a round cap */
/* add a square cap */
/* add a butt ending */
/* process an inside corner, i.e. compute intersection */
/* compute median angle */
/* TODO: find better criterion to switch off the optimization */
/* process an outside corner, i.e. compute bevel/miter/round */
/* this is a mitered or beveled corner */
/* FT_Sin(x) = 0 for x <= 57 */
/* this is a miter (broken angle) */
/* compute middle point */
/* compute first angle point */
/* compute second angle point */
/* finally, add a movable end point */
/* this is a bevel (intersection) */
/* now add end point */
/* no specific corner processing is required if the turn is 0 */
/* when we turn to the right, the inside side is 0 */
/* otherwise, the inside side is 1 */
/* process the inside side */
/* process the outside side */
/* add two points to the left and right borders corresponding to the */
/* start of the subpath                                              */
/* save angle for last cap */
/* documentation is in ftstroke.h */
/* process corner if necessary */
/* This is the first segment of a subpath.  We need to     */
/* add a point to each border at their respective starting */
/* point locations.                                        */
/* process the current corner */
/* now add a line segment to both the `inside' and `outside' paths */
/* documentation is in ftstroke.h */
/* remove compiler warnings */
/* process corner if necessary */
/* the arc's angle is small enough; we can add it directly to each */
/* border                                                          */
/* compute control point */
/* compute end point */
/* documentation is in ftstroke.h */
/* remove compiler warnings */
/* process corner if necessary */
/* the arc's angle is small enough; we can add it directly to each */
/* border                                                          */
/* compute control points */
/* compute end point */
/* documentation is in ftstroke.h */
/* We cannot process the first point, because there is not enough      */
/* information regarding its corner/cap.  The latter will be processed */
/* in the `FT_Stroker_EndSubPath' routine.                             */
/*                                                                     */
/* record the subpath start point for each border */
/* switch begin/end tags if necessary */
/* documentation is in ftstroke.h */
/* there's a lot of magic in this function! */
/* All right, this is an opened path, we need to add a cap between */
/* right & left, add the reverse of left, then add a final cap     */
/* between left & right.                                           */
/* add reversed points from `left' to `right' */
/* now add the final cap */
/* Now end the right subpath accordingly.  The left one is */
/* rewind and doesn't need further processing.             */
/* close the path if needed */
/* process the corner */
/* no specific corner processing is required if the turn is 0 */
/* when we turn to the right, the inside side is 0 */
/* otherwise, the inside side is 1 */
/* process the outside side */
/* then end our two subpaths */
/* documentation is in ftstroke.h */
/* documentation is in ftstroke.h */
/* documentation is in ftstroke.h */
/* documentation is in ftstroke.h */
/* documentation is in ftstroke.h */
/*
/* index of contour in outline     */
/* index of first point in contour */
/* current point's state           */
/* index of last point in contour */
/* skip empty points; we don't stroke these */
/* A contour cannot start with a cubic control point! */
/* check first point to determine origin */
/* First point is conic control.  Yes, this happens. */
/* start at last point if it is on the curve */
/* if both first and last points are conic, */
/* start at their middle                    */
/* emit a single line_to */
/* consume conic arcs */
/* FT_CURVE_TAG_CUBIC */
/* declare an extern to access ft_outline_glyph_class global allocated 
/* documentation is in ftstroke.h */
/* documentation is in ftstroke.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftsynth.c
/***************************************************************************/
/*                                                                         */
/*  ftsynth.c                                                              */
/*                                                                         */
/*    FreeType synthesizing code for emboldening and slanting (body).      */
/*                                                                         */
/*  Copyright 2000-2001, 2002, 2003, 2004, 2005, 2006, 2010 by             */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****   EXPERIMENTAL OBLIQUING SUPPORT                                ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/* documentation is in ftsynth.h */
/* only oblique outline glyphs */
/* we don't touch the advance width */
/* For italic, simply apply a shear transform, with an angle */
/* of about 12 degrees.                                      */
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****   EXPERIMENTAL EMBOLDENING/OUTLINING SUPPORT                    ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/* documentation is in ftsynth.h */
/* some reasonable strength */
/* ignore error */
/* this is more than enough for most glyphs; if you need accurate */
/* values, you have to call FT_Outline_Get_CBox                   */
/* round to full pixels */
/*
/* XXX: 16-bit overflow case must be excluded before here */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftsystem.c
/***************************************************************************/
/*                                                                         */
/*  ftsystem.c                                                             */
/*                                                                         */
/*    ANSI-specific FreeType low-level system interface (body).            */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2006, 2008, 2009, 2010 by                   */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* This file contains the default interface used by FreeType to access   */
/* low-level, i.e. memory management, i/o access as well as thread       */
/* synchronisation.  It can be replaced by user-specific routines if     */
/* necessary.                                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/*                       MEMORY MANAGEMENT INTERFACE                     */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* It is not necessary to do any error checking for the                  */
/* allocation-related functions.  This will be done by the higher level  */
/* routines like ft_mem_alloc() or ft_mem_realloc().                     */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    ft_alloc                                                           */
/*                                                                       */
/* <Description>                                                         */
/*    The memory allocation function.                                    */
/*                                                                       */
/* <Input>                                                               */
/*    memory :: A pointer to the memory object.                          */
/*                                                                       */
/*    size   :: The requested size in bytes.                             */
/*                                                                       */
/* <Return>                                                              */
/*    The address of newly allocated block.                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    ft_realloc                                                         */
/*                                                                       */
/* <Description>                                                         */
/*    The memory reallocation function.                                  */
/*                                                                       */
/* <Input>                                                               */
/*    memory   :: A pointer to the memory object.                        */
/*                                                                       */
/*    cur_size :: The current size of the allocated memory block.        */
/*                                                                       */
/*    new_size :: The newly requested size in bytes.                     */
/*                                                                       */
/*    block    :: The current address of the block in memory.            */
/*                                                                       */
/* <Return>                                                              */
/*    The address of the reallocated memory block.                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    ft_free                                                            */
/*                                                                       */
/* <Description>                                                         */
/*    The memory release function.                                       */
/*                                                                       */
/* <Input>                                                               */
/*    memory  :: A pointer to the memory object.                         */
/*                                                                       */
/*    block   :: The address of block in memory to be freed.             */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/*                     RESOURCE MANAGEMENT INTERFACE                     */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* We use the macro STREAM_FILE for convenience to extract the       */
/* system-specific stream handle from a given FreeType stream object */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    ft_ansi_stream_close                                               */
/*                                                                       */
/* <Description>                                                         */
/*    The function to close a stream.                                    */
/*                                                                       */
/* <Input>                                                               */
/*    stream :: A pointer to the stream object.                          */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    ft_ansi_stream_io                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    The function to open a stream.                                     */
/*                                                                       */
/* <Input>                                                               */
/*    stream :: A pointer to the stream object.                          */
/*                                                                       */
/*    offset :: The position in the data stream to start reading.        */
/*                                                                       */
/*    buffer :: The address of buffer to store the read data.            */
/*                                                                       */
/*    count  :: The number of bytes to read from the stream.             */
/*                                                                       */
/* <Return>                                                              */
/*    The number of bytes actually read.  If `count' is zero (this is,   */
/*    the function is used for seeking), a non-zero return value         */
/*    indicates an error.                                                */
/*                                                                       */
/* documentation is in ftstream.h */
/* documentation is in ftobjs.h */
/* documentation is in ftobjs.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\fttrigon.c
/***************************************************************************/
/*                                                                         */
/*  fttrigon.c                                                             */
/*                                                                         */
/*    FreeType trigonometric functions (body).                             */
/*                                                                         */
/*  Copyright 2001, 2002, 2003, 2004, 2005 by                              */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* the following is 0.2715717684432231 * 2^30 */
/* this table was generated for FT_PI = 180L << 16, i.e. degrees */
/* the Cordic shrink factor, multiplied by 2^32 */
/* 0x4585BA38UL */
/* multiply a given value by the CORDIC shrink factor */
/* !FT_CONFIG_HAS_INT64 */
/* multiply a given value by the CORDIC shrink factor */
/* constant */
/* constant */
/* can't overflow */
/* !FT_CONFIG_HAS_INT64 */
/* determine msb bit index in `shift' */
/* 0 */
/* 0 */
/* Get angle between -90 and 90 degrees */
/* Initial pseudorotation, with left shift */
/* Subsequent pseudorotations, with right shifts */
/* Get the vector into the right half plane */
/* Rotate positive */
/* Subtract angle */
/* Rotate negative */
/* Add angle */
/* Rotate positive */
/* Rotate negative */
/* round theta */
/* documentation is in fttrigon.h */
/* documentation is in fttrigon.h */
/* documentation is in fttrigon.h */
/* documentation is in fttrigon.h */
/* documentation is in fttrigon.h */
/* these macros return 0 for positive numbers,
/* documentation is in fttrigon.h */
/* documentation is in fttrigon.h */
/* handle trivial cases */
/* general case */
/* documentation is in fttrigon.h */
/* documentation is in fttrigon.h */
/* documentation is in fttrigon.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\fttype1.c
/***************************************************************************/
/*                                                                         */
/*  fttype1.c                                                              */
/*                                                                         */
/*    FreeType utility file for PS names support (body).                   */
/*                                                                         */
/*  Copyright 2002, 2003, 2004 by                                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* documentation is in t1tables.h */
/* documentation is in t1tables.h */
/* documentation is in t1tables.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftutil.c
/***************************************************************************/
/*                                                                         */
/*  ftutil.c                                                               */
/*                                                                         */
/*    FreeType utility file for memory and list management (body).         */
/*                                                                         */
/*  Copyright 2002, 2004, 2005, 2006, 2007 by                              */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                                                               *****/
/*****               M E M O R Y   M A N A G E M E N T               *****/
/*****                                                               *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* may help catch/prevent security issues */
/* Note that we now accept `item_size == 0' as a valid parameter, in
/* may help catch/prevent nasty security issues */
/* always zero-terminate */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                                                               *****/
/*****            D O U B L Y   L I N K E D   L I S T S              *****/
/*****                                                               *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* documentation is in ftlist.h */
/* documentation is in ftlist.h */
/* documentation is in ftlist.h */
/* documentation is in ftlist.h */
/* documentation is in ftlist.h */
/* check whether we are already on top of the list */
/* documentation is in ftlist.h */
/* documentation is in ftlist.h */
/*
/* clear lowest bit */
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftwinfnt.c
/***************************************************************************/
/*                                                                         */
/*  ftwinfnt.c                                                             */
/*                                                                         */
/*    FreeType API for accessing Windows FNT specific info (body).         */
/*                                                                         */
/*  Copyright 2003, 2004 by                                                */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* documentation is in ftwinfnt.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\base\ftxf86.c
/***************************************************************************/
/*                                                                         */
/*  ftxf86.c                                                               */
/*                                                                         */
/*    FreeType utility file for X11 support (body).                        */
/*                                                                         */
/*  Copyright 2002, 2003, 2004 by                                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* documentation is in ftxf86.h */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\bdf\bdf.c
/*  bdf.c
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\bdf\bdfdrivr.c
/*  bdfdrivr.c
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* ftobjs.h: FT_CMap->clazz->size */
/* num_encodings */
/* encodings->glyph */
/* increase glyph index by 1 --              */
/* we reserve slot 0 for the undefined glyph */
/* num_encodings */
/* encodings->glyph */
/* same as BDF_encoding_el.enc */
/* increase glyph index by 1 --              */
/* we reserve slot 0 for the undefined glyph */
/* XXX: result should be changed to indicate an overflow error */
/* separate elements with a space */
/* need to convert spaces to dashes for */
/* add_style_name and setwidth_name     */
/* BDF_Face */
/* BDF_Face */
/* FZ XXX: options semantics */
/* we have a bdf font: let's construct the face object */
/* FZ XXX: TO DO: FT_FACE_FLAGS_VERTICAL   */
/* FZ XXX: I need a font to implement this */
/* the number of glyphs (with one slot for the undefined glyph */
/* at position 0 and all unencoded glyphs)                     */
/* convert from 722.7 decipoints to 72 points per inch */
/* encoding table */
/* charmaps */
/* Uh, oh, compare first letters manually to avoid dependency */
/* on locales.                                                */
/* initial platform/encoding should indicate unset status? */
/* Select default charmap */
/* otherwise assume Adobe standard encoding */
/* Select default charmap */
/* index 0 is the undefined glyph */
/* slot, bitmap => freetype, glyph => bdflib */
/* same as FT_Bitmap.pitch */
/* note: we don't allocate a new array to hold the bitmap; */
/*       we can simply point to it                         */
/*
/*
/*
/* FT_Size_InitFunc */
/* FT_Size_DoneFunc */
/* FT_Slot_InitFunc */
/* FT_Slot_DoneFunc */
/* FT_Face_GetKerningFunc   */
/* FT_Face_AttachFunc       */
/* FT_Face_GetAdvancesFunc  */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\bdf\bdflib.c
/*
/*************************************************************************/
/*                                                                       */
/*  This file is based on bdf.c,v 1.22 2000/03/16 20:08:50               */
/*                                                                       */
/*  taken from Mark Leisher's xmbdfed package                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* Default BDF font options.                                             */
/*                                                                       */
/*************************************************************************/
/* Correct metrics.               */
/* Preserve unencoded glyphs.     */
/* Preserve comments.             */
/* Default spacing.               */
/*************************************************************************/
/*                                                                       */
/* Builtin BDF font properties.                                          */
/*                                                                       */
/*************************************************************************/
/* List of most properties that might appear in a font.  Doesn't include */
/* the RAW_* and AXIS_* properties in X11R6 polymorphic fonts.           */
/*************************************************************************/
/*                                                                       */
/* Hash table utilities for the properties.                              */
/*                                                                       */
/*************************************************************************/
/* XXX: Replace this with FreeType's hash functions */
/* Mocklisp hash function. */
/*************************************************************************/
/*                                                                       */
/* Utility types and functions.                                          */
/*                                                                       */
/*************************************************************************/
/* Function type for parsing lines of a BDF font. */
/* List structure for splitting lines into fields. */
/* Structure used while loading BDF fonts. */
/* same as _bdf_list_t.used */
/* same as _bdf_list_t.size */
/* An empty string for empty fields. */
/* XXX eliminate this */
/* Initialize the list. */
/* If the line is empty, then simply return. */
/* In the original code, if the `separators' parameter is NULL or */
/* empty, the list is split into individual bytes.  We don't need */
/* this, so an error is signaled.                                 */
/* Prepare the separator bitmap. */
/* If the very last character of the separator string is a plus, then */
/* set the `mult' flag to indicate that multiple separators should be */
/* collapsed into one.                                                */
/* Break the line up into fields. */
/* Collect everything that is not a separator. */
/* Resize the list if necessary. */
/* Assign the field appropriately. */
/* If multiple separators should be collapsed, do it now by */
/* setting all the separator characters to 0.               */
/* Don't collapse multiple separators by making them 0, so just */
/* make the one encountered 0.                                  */
/* Finally, NULL-terminate the list. */
/* this value cannot be stored in a 'char' */
/* initial size and allocation of the input buffer */
/* make compiler happy */
/* should we skip an optional character like \n or \r? */
/* try to find the end of the line */
/* if we hit the end of the buffer, try shifting its content */
/* or even resizing it                                       */
/* last line in file doesn't end in \r or \n */
/* ignore it then exit                       */
/* this line is definitely too long; try resizing the input */
/* buffer a bit to handle it.                               */
/* limit ourselves to 64KByte */
/* Temporarily NUL-terminate the line. */
/* XXX: Use encoding independent value for 0x1a */
/* Redo if we have encountered CHARS without properties. */
/* XXX: make this work with EBCDIC also */
/* Routine to convert an ASCII string into an unsigned long integer. */
/* Make sure the radix is something recognizable.  Default to 10. */
/* Check for the special hex prefix. */
/* Routine to convert an ASCII string into an signed long integer. */
/* Make sure the radix is something recognizable.  Default to 10. */
/* Check for a minus sign. */
/* Check for the special hex prefix. */
/* Routine to convert an ASCII string into an signed short integer. */
/* Make sure the radix is something recognizable.  Default to 10. */
/* Check for a minus. */
/* Check for the special hex prefix. */
/* Routine to compare two glyphs by encoding so they can be sorted. */
/* First check to see if the property has      */
/* already been added or not.  If it has, then */
/* simply ignore it.                           */
/*************************************************************************/
/*                                                                       */
/* BDF font file parsing flags and functions.                            */
/*                                                                       */
/*************************************************************************/
/* Parse flags. */
/* Auto correction messages. */
/* Error messages. */
/* Set the spacing from the font name if it exists, or set it to the */
/* default specified in the options.                                 */
/* Limit ourselves to 256 characters in the font name. */
/* Determine whether the property is an atom or not.  If it is, then */
/* clean it up so the double quotes are removed if they exist.       */
/* Restore the character that was saved before any return can happen. */
/* If the property exists and is not an atom, just return here. */
/* The property is an atom.  Trim all leading and trailing whitespace */
/* and double quotes for the atom value.                              */
/* Trim the leading whitespace if it exists. */
/* Trim the leading double quote if it exists. */
/* Trim the trailing whitespace if it exists. */
/* Trim the trailing double quote if it exists. */
/* First, check to see if the property already exists in the font. */
/* The property already exists in the font, so simply replace */
/* the value of the property with the current value.          */
/* Delete the current atom if it exists. */
/* See whether this property type exists yet or not. */
/* If not, create it.                                */
/* Allocate another property if this is overflow. */
/* If the property happens to be a comment, then it doesn't need */
/* to be added to the internal hash table.                       */
/* Add the property to the font property table. */
/* Some special cases need to be handled here.  The DEFAULT_CHAR       */
/* property needs to be located if it exists in the property list, the */
/* FONT_ASCENT and FONT_DESCENT need to be assigned if they are        */
/* present, and the SPACING property should override the default       */
/* spacing.                                                            */
/* Actually parse the glyph info and bitmaps. */
/* only used in debug mode */
/* Check for a comment. */
/* The very first thing expected is the number of glyphs. */
/* Make sure the number of glyphs is non-zero. */
/* Limit ourselves to 1,114,112 glyphs in the font (this is the */
/* number of code points available in Unicode).                 */
/* Check for the ENDFONT field. */
/* Sort the glyphs by encoding. */
/* Check for the ENDCHAR field. */
/* Check to see whether a glyph is being scanned but should be */
/* ignored because it is an unencoded glyph.                   */
/* Check for the STARTCHAR field. */
/* Set the character name in the parse info first until the */
/* encoding can be checked for an unencoded character.      */
/* Check for the ENCODING field. */
/* Missing STARTCHAR field. */
/* Check that the encoding is in the range [0,65536] because        */
/* otherwise p->have (a bitmap with static size) overflows.         */
/* Check to see whether this encoding has already been encountered. */
/* If it has then change it to unencoded so it gets added if        */
/* indicated.                                                       */
/* Emit a message saying a glyph has been moved to the */
/* unencoded area.                                     */
/* Make sure there are enough glyphs allocated in case the */
/* number of characters happen to be wrong.                */
/* Reset the initial glyph info. */
/* Unencoded glyph.  Check to see whether it should */
/* be added or not.                                 */
/* Allocate the next unencoded glyph. */
/* Free up the glyph name if the unencoded shouldn't be */
/* kept.                                                */
/* Clear the flags that might be added when width and height are */
/* checked for consistency.                                      */
/* Point at the glyph being constructed. */
/* Check to see whether a bitmap is being constructed. */
/* If there are more rows than are specified in the glyph metrics, */
/* ignore the remaining lines.                                     */
/* Only collect the number of nibbles indicated by the glyph     */
/* metrics.  If there are more columns, they are simply ignored. */
/* Remove possible garbage at the right. */
/* If any line has extra columns, indicate they have been removed. */
/* Expect the SWIDTH (scalable width) field next. */
/* Missing ENCODING field. */
/* Expect the DWIDTH (scalable width) field next. */
/* Missing SWIDTH field.  Emit an auto correction message and set */
/* the scalable width from the device width.                      */
/* Expect the BBX field next. */
/* Generate the ascent and descent of the character. */
/* Determine the overall font bounding box as the characters are */
/* loaded so corrections can be done later if indicated.         */
/* Missing DWIDTH field.  Emit an auto correction message and set */
/* the device width to the glyph width.                           */
/* If the BDF_CORRECT_METRICS flag is set, then adjust the SWIDTH */
/* value if necessary.                                            */
/* Determine the point size of the glyph. */
/* And finally, gather up the bitmap. */
/* Missing BBX field. */
/* Allocate enough space for the bitmap. */
/* Load the font properties. */
/* Check for the end of the properties. */
/* If the FONT_ASCENT or FONT_DESCENT properties have not been      */
/* encountered yet, then make sure they are added as properties and */
/* make sure they are set from the font bounding box info.          */
/*                                                                  */
/* This is *always* done regardless of the options, because X11     */
/* requires these two fields to compile fonts.                      */
/* Ignore the _XFREE86_GLYPH_RANGES properties. */
/* Handle COMMENT fields and properties in a special way to preserve */
/* the spacing.                                                      */
/* Load the font header. */
/* only used in debug mode */
/* Check for a comment.  This is done to handle those fonts that have */
/* comments before the STARTFONT line for some reason.                */
/* here font is not defined! */
/* No STARTFONT field is a good indication of a problem. */
/* setup */
/* Check for the start of the properties. */
/* Missing the FONTBOUNDINGBOX field. */
/* at this point, `p->font' can't be NULL */
/* Check for the FONTBOUNDINGBOX field. */
/* Missing the SIZE field. */
/* The next thing to check for is the FONT field. */
/* Allowing multiple `FONT' lines (which is invalid) doesn't hurt... */
/* If the font name is an XLFD name, set the spacing to the one in  */
/* the font name.  If there is no spacing fall back on the default. */
/* Check for the SIZE field. */
/* Missing the FONT field. */
/* Check for the bits per pixel field. */
/* Only values 1, 2, 4, 8 are allowed. */
/* select next higher value */
/* Check for the CHARS field -- font properties are optional */
/* Missing the FONTBOUNDINGBOX field. */
/* Add the two standard X11 properties which are required */
/* for compiling fonts.                                   */
/* A special return value. */
/*************************************************************************/
/*                                                                       */
/* API.                                                                  */
/*                                                                       */
/*************************************************************************/
/* make compiler happy */
/* only during font creation */
/* If the font is not proportional, set the font's monowidth */
/* field to the width of the font bounding box.              */
/* If the number of glyphs loaded is not that of the original count, */
/* indicate the difference.                                          */
/* Once the font has been loaded, adjust the overall font metrics if */
/* necessary.                                                        */
/* The ENDFONT field was never reached or did not exist. */
/* Error happened while parsing header. */
/* Error happened when parsing glyphs. */
/* Make sure the comments are NULL terminated if they exist. */
/* Free up the internal hash table of property names. */
/* Free up the comment info. */
/* Free up the properties. */
/* Free up the character info. */
/* Free up the overflow storage if it was used. */
/* bdf_cleanup */
/* Free up the user defined properties. */
/* FREE( font ); */ /* XXX Fixme */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\cache\ftcache.c
/***************************************************************************/
/*                                                                         */
/*  ftcache.c                                                              */
/*                                                                         */
/*    The FreeType Caching sub-system (body only).                         */
/*                                                                         */
/*  Copyright 2000-2001, 2003 by                                           */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\cache\ftcbasic.c
/***************************************************************************/
/*                                                                         */
/*  ftcbasic.c                                                             */
/*                                                                         */
/*    The FreeType basic cache interface (body).                           */
/*                                                                         */
/*  Copyright 2003, 2004, 2005, 2006, 2007, 2009, 2010 by                  */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*
/*
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/*
/* we will now load the glyph image */
/* ok, copy it */
/* we must call this function to avoid this node from appearing
/*
/* FTC_MruNode_ResetFunc */
/* FTC_MruNode_DoneFunc  */
/* documentation is in ftcache.h */
/* documentation is in ftcache.h */
/* make compiler happy */
/* some argument checks are delayed to FTC_Cache_Lookup */
/*
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/* make compilers happy */
/* inlining is about 50% faster! */
/* documentation is in ftcache.h */
/* make compiler happy */
/* some argument checks are delayed to FTC_Cache_Lookup */
/* FT_Load_Glyph(), FT_Load_Char() take FT_UInt flags */
/* yet another backwards-legacy structure */
/* monochrome bitmap */
/* anti-aliased bitmap */
/* scaled outline */
/* convert image type flags to load flags */
/* determine load flags, depending on the font description's */
/* image type                                                */
/* disable embedded bitmaps loading if necessary */
/* we want an outline, don't load embedded bitmaps */
/* always render glyphs to bitmaps */
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/*
/* FTC_MruNode_ResetFunc */
/* FTC_MruNode_DoneFunc  */
/* documentation is in ftcache.h */
/* documentation is in ftcache.h */
/* make compiler happy */
/* other argument checks delayed to FTC_Cache_Lookup */
/*  This one is a major hack used to detect whether we are passed a
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/* make compilers happy */
/* beware, the hash must be the same for all glyph ranges! */
/* inlining is about 50% faster! */
/* documentation is in ftcache.h */
/* make compiler happy */
/* other argument checks delayed to FTC_Cache_Lookup */
/* FT_Load_Glyph(), FT_Load_Char() take FT_UInt flags */
/* beware, the hash must be the same for all glyph ranges! */
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\cache\ftccache.c
/***************************************************************************/
/*                                                                         */
/*  ftccache.c                                                             */
/*                                                                         */
/*    The FreeType internal cache interface (body).                        */
/*                                                                         */
/*  Copyright 2000-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010 by */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* this one _must_ be a power of 2! */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                   CACHE NODE DEFINITIONS                      *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* add a new node to the head of the manager's circular MRU list */
/* remove a node from the manager's MRU list */
/* move a node to the head of the manager's MRU list */
/* !FTC_INLINE */
/* Note that this function cannot fail.  If we cannot re-size the
/* number of buckets */
/* do we need to shrink the buckets array? */
/* try to expand the buckets array _before_ splitting
/* if we can't expand the array, leave immediately */
/* split a single bucket */
/* do we need to expand the buckets array? */
/* if we can't shrink the array, leave immediately */
/* the hash table is balanced */
/* remove a node from its cache's hash table */
/* add a node to the `top' of its cache's hash table */
/* remove a node from the cache manager */
/* find node's cache */
/* remove node from mru list */
/* remove node from cache's hash table */
/* now finalize it */
/* check, just in case of general corruption :-) */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    ABSTRACT CACHE CLASS                       *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* remove node from mru list */
/* now finalize it */
/*
/* don't assume that the cache has the same number of buckets, since
/* move to head of MRU list */
/* !FTC_INLINE */
/* remove all nodes in the free list */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\cache\ftccmap.c
/***************************************************************************/
/*                                                                         */
/*  ftccmap.c                                                              */
/*                                                                         */
/*    FreeType CharMap cache (body)                                        */
/*                                                                         */
/*  Copyright 2000-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,   */
/*            2010 by                                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* FT_CONFIG_OLD_INTERNALS */
/*************************************************************************/
/*                                                                       */
/* Each FTC_CMapNode contains a simple array to map a range of character */
/* codes to equivalent glyph indices.                                    */
/*                                                                       */
/* For now, the implementation is very basic: Each node maps a range of  */
/* 128 consecutive character codes to their corresponding glyph indices. */
/*                                                                       */
/* We could do more complex things, but I don't think it is really very  */
/* useful.                                                               */
/*                                                                       */
/*************************************************************************/
/* number of glyph indices / character code per node */
/* compute a query/node hash */
/* the charmap query */
/* the cmap cache node */
/* first character in node */
/* array of glyph indices  */
/* if (indices[n] == FTC_CMAP_UNKNOWN), we assume that the corresponding */
/* glyph indices haven't been queried through FT_Get_Glyph_Index() yet   */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                        CHARMAP NODES                          *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* initialize a new cmap node */
/* compute the weight of a given cmap node */
/* compare a cmap node to a given query */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    GLYPH IMAGE CACHE                          *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* documentation is in ftcache.h */
/*
/* documentation is in ftcache.h */
/* Treat a negative cmap index as a special value, meaning that you */
/* don't want to change the FT_Face's character map through this    */
/* call.  This can be useful if the face requester callback already */
/* sets the face's charmap to the appropriate value.                */
/*
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/* something rotten can happen with rogue clients */
/* XXX: should return appropriate error */
/* something rotten can happen with rogue clients */
/* XXX: should return appropriate error */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\cache\ftcglyph.c
/***************************************************************************/
/*                                                                         */
/*  ftcglyph.c                                                             */
/*                                                                         */
/*    FreeType Glyph Image (FT_Glyph) cache (body).                        */
/*                                                                         */
/*  Copyright 2000-2001, 2003, 2004, 2006, 2009 by                         */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* create a new chunk node, setting its cache index and ref count */
/* finalize the node */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      CHUNK SETS                               *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* no maximum here! */
/* 0 */
/* 0 */
/* prevent the family from being destroyed too early when an        */
/* out-of-memory condition occurs during glyph node initialization. */
/* !FTC_INLINE */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\cache\ftcimage.c
/***************************************************************************/
/*                                                                         */
/*  ftcimage.c                                                             */
/*                                                                         */
/*    FreeType Image cache (body).                                         */
/*                                                                         */
/*  Copyright 2000-2001, 2003, 2004, 2006, 2010 by                         */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* finalize a given glyph image node */
/* initialize a new glyph image node */
/* initialize its inner fields */
/* we will now load the glyph image */
/* 0 */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\cache\ftcmanag.c
/***************************************************************************/
/*                                                                         */
/*  ftcmanag.c                                                             */
/*                                                                         */
/*    FreeType Cache Manager (body).                                       */
/*                                                                         */
/*  Copyright 2000-2001, 2002, 2003, 2004, 2005, 2006, 2008, 2009, 2010 by */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* helper function used by ftc_face_node_done */
/* documentation is in ftcache.h */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    FACE MRU IMPLEMENTATION                    *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* destroy initial size object; it will be re-created later */
/* we must begin by removing all scalers for the target face */
/* from the manager's list                                   */
/* all right, we can discard the face now */
/* FTC_MruNode_ResetFunc */
/* documentation is in ftcache.h */
/* we break encapsulation for the sake of speed */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    CACHE MANAGER ROUTINES                     *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* documentation is in ftcache.h */
/* documentation is in ftcache.h */
/* now discard all caches */
/* discard faces and sizes */
/* documentation is in ftcache.h */
/* XXX: FIXME: flush the caches? */
/* check node weights */
/* check circular list */
/* FT_DEBUG_ERROR */
/* `Compress' the manager's data, i.e., get rid of old cache nodes */
/* that are not referenced anymore in order to limit the total     */
/* memory used by the cache.                                       */
/* documentation is in ftcmanag.h */
/* go to last node -- it's a circular list */
/* documentation is in ftcmanag.h */
/* THIS IS VERY IMPORTANT!  IT WILL WRETCH THE MANAGER */
/* IF IT IS NOT SET CORRECTLY                          */
/* try to remove `count' nodes from the list */
/* empty list! */
/* go to last node - it's a circular list */
/* don't touch locked nodes */
/* documentation is in ftcache.h */
/* this will remove all FTC_SizeNode that correspond to
/* documentation is in ftcache.h */
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\cache\ftcmru.c
/***************************************************************************/
/*                                                                         */
/*  ftcmru.c                                                               */
/*                                                                         */
/*    FreeType MRU support (body).                                         */
/*                                                                         */
/*  Copyright 2003, 2004, 2006, 2009 by                                    */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* FTC_INLINE */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\cache\ftcsbits.c
/***************************************************************************/
/*                                                                         */
/*  ftcsbits.c                                                             */
/*                                                                         */
/*    FreeType sbits manager (body).                                       */
/*                                                                         */
/*  Copyright 2000-2001, 2002, 2003, 2004, 2005, 2006, 2009, 2010 by       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     SBIT CACHE NODES                          *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*
/* FT_GlyphSlot->advance.{x|y} */
/* Check that our values fit into 8-bit containers!       */
/* If this is not the case, our bitmap is too large       */
/* and we will leave it as `missing' with sbit.buffer = 0 */
/* horizontal advance in pixels */
/* copy the bitmap into a new buffer -- ignore error */
/* now, compute size */
/* glyph loading successful */
/* ignore the errors that might have occurred --   */
/* we mark unloaded glyphs with `sbit.buffer == 0' */
/* and `width == 255', `height == 0'               */
/*                                                 */
/* the node itself */
/* add the size of a given glyph image */
/* 0 */
/* check if we need to load the glyph bitmap now */
/*
/* lock node to prevent flushing */
/* in retry loop                 */
/* unlock the node */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\cff\cff.c
/***************************************************************************/
/*                                                                         */
/*  cff.c                                                                  */
/*                                                                         */
/*    FreeType OpenType driver component (body only).                      */
/*                                                                         */
/*  Copyright 1996-2001, 2002 by                                           */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\cff\cffcmap.c
/***************************************************************************/
/*                                                                         */
/*  cffcmap.c                                                              */
/*                                                                         */
/*    CFF character mapping table (cmap) support (body).                   */
/*                                                                         */
/*  Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2010 by                  */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****           CFF STANDARD (AND EXPERT) ENCODING CMAPS            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****              CFF SYNTHETIC UNICODE ENCODING CMAP              *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* can't build Unicode map for CID-keyed font */
/* because we don't know glyph names.         */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\cff\cffdrivr.c
/***************************************************************************/
/*                                                                         */
/*  cffdrivr.c                                                             */
/*                                                                         */
/*    OpenType font driver implementation (body).                          */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,   */
/*            2010 by                                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                                                                 ****/
/****                          F A C E S                              ****/
/****                                                                 ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    cff_get_kerning                                                    */
/*                                                                       */
/* <Description>                                                         */
/*    A driver method used to return the kerning vector between two      */
/*    glyphs of the same face.                                           */
/*                                                                       */
/* <Input>                                                               */
/*    face        :: A handle to the source face object.                 */
/*                                                                       */
/*    left_glyph  :: The index of the left glyph in the kern pair.       */
/*                                                                       */
/*    right_glyph :: The index of the right glyph in the kern pair.      */
/*                                                                       */
/* <Output>                                                              */
/*    kerning     :: The kerning vector.  This is in font units for      */
/*                   scalable formats, and in pixels for fixed-sizes     */
/*                   formats.                                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* <Note>                                                                */
/*    Only horizontal layouts (left-to-right & right-to-left) are        */
/*    supported by this function.  Other layouts, or more sophisticated  */
/*    kernings, are out of scope of this method (the basic driver        */
/*    interface is meant to be simple).                                  */
/*                                                                       */
/*    They can be implemented by format-specific interfaces.             */
/*                                                                       */
/* TT_Face */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Load_Glyph                                                         */
/*                                                                       */
/* <Description>                                                         */
/*    A driver method used to load a glyph within a given glyph slot.    */
/*                                                                       */
/* <Input>                                                               */
/*    slot        :: A handle to the target slot object where the glyph  */
/*                   will be loaded.                                     */
/*                                                                       */
/*    size        :: A handle to the source face size at which the glyph */
/*                   must be scaled, loaded, etc.                        */
/*                                                                       */
/*    glyph_index :: The index of the glyph in the font file.            */
/*                                                                       */
/*    load_flags  :: A flag indicating what to load for this glyph.  The */
/*                   FT_LOAD_??? constants can be used to control the    */
/*                   glyph loading process (e.g., whether the outline    */
/*                   should be scaled, whether to load bitmaps or not,   */
/*                   whether to hint the outline, etc).                  */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* CFF_GlyphSlot */
/* CFF_Size      */
/* check whether we want a scaled outline or bitmap */
/* reset the size object if necessary */
/* these two objects must have the same parent */
/* now load the glyph outline if necessary */
/* force drop-out mode to 2 - irrelevant now */
/* slot->outline.dropout_mode = 2; */
/*
/* first, locate the sid in the charset table */
/* now, lookup the name itself */
/*
/* unsupported with CFF fonts */
/*
/*
/*
/*
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                                                                 ****/
/****                D R I V E R  I N T E R F A C E                   ****/
/****                                                                 ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* CFF_Driver */
/* we pass our request to the `sfnt' module */
/* The FT_DriverInterface structure is defined in ftdriver.h. */
/* module-specific interface */
/* now the specific driver fields */
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/* FT_Face_AttachFunc      */
/* FT_Face_GetAdvancesFunc */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\cff\cffgload.c
/***************************************************************************/
/*                                                                         */
/*  cffgload.c                                                             */
/*                                                                         */
/*    OpenType Glyph Loader (body).                                        */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,   */
/*            2010 by                                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* deprecated, acts as no-op */
/* Type 1 opcodes: invalid but seen in real life */
/* do not remove */
/* count values which have the `CFF_COUNT_CHECK_WIDTH' flag set are  */
/* used for checking the width and requested numbers of arguments    */
/* only; they are set to zero afterwards                             */
/* the other two flags are informative only and unused currently     */
/* unknown */
/* rmoveto */
/* rlineto */
/* rrcurveto */
/* flex */
/* endchar */
/* hstem */
/* hintmask */
/* cntrmask */
/* dotsection */
/* abs */
/* blend */
/* drop */
/* put */
/* and */
/* callsubr */
/* hsbw */
/* seac */
/* sbw */
/* setcurrentpoint */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/**********                                                      *********/
/**********                                                      *********/
/**********             GENERIC CHARSTRING PARSING               *********/
/**********                                                      *********/
/**********                                                      *********/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    cff_builder_init                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Initializes a given glyph builder.                                 */
/*                                                                       */
/* <InOut>                                                               */
/*    builder :: A pointer to the glyph builder to initialize.           */
/*                                                                       */
/* <Input>                                                               */
/*    face    :: The current face object.                                */
/*                                                                       */
/*    size    :: The current size object.                                */
/*                                                                       */
/*    glyph   :: The current glyph object.                               */
/*                                                                       */
/*    hinting :: Whether hinting is active.                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    cff_builder_done                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Finalizes a given glyph builder.  Its contents can still be used   */
/*    after the call, but the function saves important information       */
/*    within the corresponding glyph slot.                               */
/*                                                                       */
/* <Input>                                                               */
/*    builder :: A pointer to the glyph builder to finalize.             */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    cff_compute_bias                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Computes the bias value in dependence of the number of glyph       */
/*    subroutines.                                                       */
/*                                                                       */
/* <Input>                                                               */
/*    in_charstring_type :: The `CharstringType' value of the top DICT   */
/*                          dictionary.                                  */
/*                                                                       */
/*    num_subrs          :: The number of glyph subroutines.             */
/*                                                                       */
/* <Return>                                                              */
/*    The bias value.                                                    */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    cff_decoder_init                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Initializes a given glyph decoder.                                 */
/*                                                                       */
/* <InOut>                                                               */
/*    decoder :: A pointer to the glyph builder to initialize.           */
/*                                                                       */
/* <Input>                                                               */
/*    face      :: The current face object.                              */
/*                                                                       */
/*    size      :: The current size object.                              */
/*                                                                       */
/*    slot      :: The current glyph object.                             */
/*                                                                       */
/*    hinting   :: Whether hinting is active.                            */
/*                                                                       */
/*    hint_mode :: The hinting mode.                                     */
/*                                                                       */
/* clear everything */
/* initialize builder */
/* initialize Type2 decoder */
/* this function is used to select the subfont */
/* and the locals subrs array                  */
/* manage CID fonts */
/* for CFFs without subfonts, this value has already been set */
/* check that there is enough space for `count' more points */
/* add a new point, do not check space */
/* check space for a new on-curve point, then add it */
/* check space for a new contour, then add it */
/* if a path was begun, add its first on-curve point */
/* test whether we are building a new contour */
/* close the current contour */
/* We must not include the last point in the path if it */
/* is located on the first point.                       */
/* `delete' last point only if it coincides with the first    */
/* point and if it is not a control point (which can happen). */
/* Don't add contours only consisting of one point, i.e., */
/* check whether begin point and last point are the same. */
/* CID-keyed fonts don't have glyph names */
/* check range of standard char code */
/* Get code to SID mapping from `cff_standard_encoding'. */
/* For incremental fonts get the character data using the */
/* callback function.                                     */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* For incremental fonts get the character data using the */
/* callback function.                                     */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* Incremental fonts don't necessarily have valid charsets.        */
/* They use the character code, not the glyph index, in this case. */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* If we are trying to load a composite glyph, do not load the */
/* accent character and return the array of subglyphs.         */
/* reallocate subglyph array if necessary */
/* subglyph 0 = base character */
/* subglyph 1 = accent character */
/* set up remaining glyph fields */
/* First load `bchar' in builder */
/* the seac operator must not be nested */
/* Save the left bearing, advance and glyph width of the base */
/* character as they will be erased by the next load.         */
/* Now load `achar' on top of the base outline. */
/* the seac operator must not be nested */
/* Restore the left side bearing, advance and glyph width */
/* of the base character.                                 */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    cff_decoder_parse_charstrings                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Parses a given Type 2 charstrings program.                         */
/*                                                                       */
/* <InOut>                                                               */
/*    decoder         :: The current Type 1 decoder.                     */
/*                                                                       */
/* <Input>                                                               */
/*    charstring_base :: The base of the charstring stream.              */
/*                                                                       */
/*    charstring_len  :: The length in bytes of the charstring stream.   */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* set default width */
/* compute random seed from stack address of parameter */
/* initialize the decoder */
/* begin hints recording session, if any */
/* now execute loop */
/********************************************************************/
/*                                                                  */
/* Decode operator or operand                                       */
/*                                                                  */
/* this is an operand, push it on the stack */
/* The specification says that normally arguments are to be taken */
/* from the bottom of the stack.  However, this seems not to be   */
/* correct, at least for Acroread 7.0.8 on GNU/Linux: It pops the */
/* arguments similar to a PS interpreter.                         */
/* find operator */
/* this is actually the Type1 vstem3 operator */
/* this is actually the Type1 hstem3 operator */
/* decrement ip for syntax error message */
/* check arguments */
/* If `nominal_width' is non-zero, the number is really a      */
/* difference against `nominal_width'.  Else, the number here  */
/* is truly a width, not a difference against `nominal_width'. */
/* If the font does not set `nominal_width', then              */
/* `nominal_width' defaults to zero, and so we can set         */
/* `glyph_width' to `nominal_width' plus number on the stack   */
/* -- for either case.                                         */
/* If there is a width specified for endchar, we either have */
/* 1 argument or 5 arguments.  We like to argue.             */
/* we only want the advance width; stop here */
/* Consumed an argument. */
/* At this point, `args' points to the first argument of the  */
/* operand in case `req_args' isn't zero.  Otherwise, we have */
/* to adjust `args' manually.                                 */
/* Note that we only pop arguments from the stack which we    */
/* really need and can digest so that we can continue in case */
/* of superfluous stack elements.                             */
/* the number of arguments is always even here */
/* implement vstem when needed --                        */
/* the specification doesn't say it, but this also works */
/* with the 'cntrmask' operator                          */
/*                                                       */
/* In a valid charstring there must be at least one byte */
/* after `hintmask' or `cntrmask' (e.g., for a `return'  */
/* instruction).  Additionally, there must be space for  */
/* `num_hints' bits.                                     */
/* if num_args isn't of the form 4n or 4n+1, */
/* we reduce it to 4n+1                      */
/* if num_args isn't of the form 4n or 4n+1, */
/* we reduce it to 4n+1                      */
/* if num_args isn't of the form 8n, 8n+1, 8n+4, or 8n+5, */
/* we reduce it to the largest one which fits             */
/* first, add the line segments */
/* then the curve */
/* first, add the curves */
/* then the final line */
/* adding five more points: 4 control points, 1 on-curve point */
/* -- make sure we have enough space for the start point if it */
/* needs to be added                                           */
/* record the starting point's y position for later use */
/* first control point */
/* second control point */
/* join point; on curve, with y-value the same as the last */
/* control point's y-value                                 */
/* third control point, with y-value the same as the join */
/* point's y-value                                        */
/* fourth control point */
/* ending point, with y-value the same as the start   */
/* adding six more points; 4 control points, 2 on-curve points */
/* record the starting point's y-position for later use */
/* first control point */
/* second control point */
/* join point; on curve, with y-value the same as the last */
/* control point's y-value                                 */
/* third control point, with y-value the same as the join */
/* point's y-value                                        */
/* fourth control point */
/* ending point, with y-value the same as the start point's */
/* y-value -- we don't add this point, though               */
/* record start x, y values for */
/* alter use                    */
/* used in horizontal/vertical  */
/* algorithm below              */
/* adding six more points; 4 control points, 2 on-curve points */
/* record the starting point's x, y position for later use */
/* XXX: figure out whether this is supposed to be a horizontal */
/*      or vertical flex; the Type 2 specification is vague... */
/* grab up to the last argument */
/* strange test, but here it is... */
/* is last operand an x- or y-delta? */
/* add current outline to the glyph slot */
/* return now! */
/* We are going to emulate the seac operator. */
/* Save glyph width so that the subglyphs don't overwrite it. */
/* close hints recording session */
/* apply hints to the loaded glyph outline now */
/* add current outline to the glyph slot */
/* return now! */
/* nothing */
/* this operator is deprecated and ignored by the parser */
/* this is an invalid Type 2 operator; however, there        */
/* exist fonts which are incorrectly converted from probably */
/* Type 1 to CFF, and some parsers seem to accept it         */
/* this is an invalid Type 2 operator; however, there        */
/* exist fonts which are incorrectly converted from probably */
/* Type 1 to CFF, and some parsers seem to accept it         */
/* this is an invalid Type 2 operator; however, there        */
/* exist fonts which are incorrectly converted from probably */
/* Type 1 to CFF, and some parsers seem to accept it         */
/* this is an invalid Type 2 operator; however, there        */
/* exist fonts which are incorrectly converted from probably */
/* Type 1 to CFF, and some parsers seem to accept it         */
/* this is an invalid Type 2 operator; however, there        */
/* exist fonts which are incorrectly converted from probably */
/* Type 1 to CFF, and some parsers seem to accept it         */
/* subsequent `pop' operands should add the arguments,       */
/* this is the implementation described for `unknown' other  */
/* subroutines in the Type1 spec.                            */
/* this is an invalid Type 2 operator; however, there        */
/* exist fonts which are incorrectly converted from probably */
/* Type 1 to CFF, and some parsers seem to accept it         */
/* save current instruction pointer */
/* save current instruction pointer */
/* general operator processing */
/* while ip < limit */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/**********                                                      *********/
/**********                                                      *********/
/**********            COMPUTE THE MAXIMUM ADVANCE WIDTH         *********/
/**********                                                      *********/
/**********    The following code is in charge of computing      *********/
/**********    the maximum advance width of the font.  It        *********/
/**********    quickly processes each glyph charstring to        *********/
/**********    extract the value from either a `sbw' or `seac'   *********/
/**********    operator.                                         *********/
/**********                                                      *********/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* unused until we support pure CFF fonts */
/* Initialize load decoder */
/* For each glyph, parse the glyph charstring and extract */
/* the advance width.                                     */
/* now get load the unscaled outline */
/* ignore the error if one has occurred -- skip to next glyph */
/* 0 */
/* in a CID-keyed font, consider `glyph_index' as a CID and map */
/* it immediately to the real glyph_index -- if it isn't a      */
/* subsetted font, glyph_indices and CIDs are identical, though */
/* don't handle CID 0 (.notdef) which is directly mapped to GID 0 */
/* try to load embedded bitmap if any              */
/*                                                 */
/* XXX: The convention should be emphasized in     */
/*      the documents because it can be confusing. */
/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
/* return immediately if we only want the embedded bitmaps */
/* if we have a CID subfont, use its matrix (which has already */
/* been multiplied with the root matrix)                       */
/* this scaling is only relevant if the PS hinter isn't active */
/* by default */
/* now load the unscaled outline */
/* Control data and length may not be available for incremental */
/* fonts.                                                       */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* We set control_data and control_len if charstrings is loaded. */
/* See how charstring loads at cff_index_access_element() in     */
/* cffload.c.                                                    */
/* save new glyph tables */
/* Incremental fonts can optionally override the metrics. */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* Now, set the metrics -- this is rather simple, as   */
/* the left side bearing is the xMin, and the top side */
/* bearing the yMax.                                   */
/* For composite glyphs, return only left side bearing and */
/* advance width.                                          */
/* copy the _unscaled_ advance width */
/* get the vertical metrics from the vtmx table if we have one */
/* make up vertical ones */
/* scale the outline and the metrics */
/* First of all, scale the points */
/* Then scale the metrics */
/* compute the other metrics */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\cff\cffload.c
/***************************************************************************/
/*                                                                         */
/*  cffload.c                                                              */
/*                                                                         */
/*    OpenType and CFF data/program tables loader (body).                  */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,   */
/*            2010 by                                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* 1 */
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* read an offset from the index's stream current position */
/* there is at least one element; read the offset size,           */
/* then access the offset table to compute the index's total size */
/* load the data */
/* skip the data */
/* Allocate a table containing pointers to an index's elements. */
/* The `pool' argument makes this function convert the index    */
/* entries to C-style strings (this is, NULL-terminated).       */
/* at this point, `idx->offsets' can't be NULL */
/* sanity check */
/* empty slot + two sanity checks for invalid offset tables */
/* compute start and end offsets */
/* load offsets from file or the offset table */
/* use offsets table */
/* access element */
/* this index was completely loaded in memory, that's easy */
/* this index is still on disk/file, access it through a frame */
/* empty index element */
/* get an entry from Name INDEX */
/* get an entry from String INDEX */
/* value 0xFFFFU indicates a missing dictionary entry */
/* if it is not a standard string, return it */
/* CID-keyed CFF fonts don't have glyph names */
/* this is a standard string */
/*************************************************************************/
/*************************************************************************/
/***                                                                   ***/
/***   FD Select table support                                         ***/
/***                                                                   ***/
/*************************************************************************/
/*************************************************************************/
/* read format */
/* clear cache */
/* format 0, that's simple */
/* format 3, a tad more complex */
/* hmm... that's wrong */
/* first, compare to cache */
/* then, lookup the ranges array */
/* update cache */
/*************************************************************************/
/*************************************************************************/
/***                                                                   ***/
/***   CFF font support                                                ***/
/***                                                                   ***/
/*************************************************************************/
/*************************************************************************/
/* When multiple GIDs map to the same CID, we choose the lowest */
/* GID.  This is not described in any spec, but it matches the  */
/* behaviour of recent Acroread versions.                       */
/* If the the offset is greater than 2, we have to parse the */
/* charset table.                                            */
/* Get the format of the table. */
/* Allocate memory for sids. */
/* assign the .notdef glyph */
/* this constant is given in the CFF specification */
/* Read the first glyph sid of the range. */
/* Read the number of glyphs in the range.  */
/* check whether the range contains at least one valid glyph; */
/* the constant is given in the CFF specification             */
/* try to rescue some of the SIDs if `nleft' is too large */
/* Fill in the range of sids -- `nleft + 1' glyphs. */
/* Parse default tables corresponding to offset == 0, 1, or 2.  */
/* CFF specification intimates the following:                   */
/*                                                              */
/* In order to use a predefined charset, the following must be  */
/* true: The charset constructed for the glyphs in the font's   */
/* charstrings dictionary must match the predefined charset in  */
/* the first num_glyphs.                                        */
/* record charset type */
/* Allocate memory for sids. */
/* Copy the predefined charset into the allocated memory. */
/* Allocate memory for sids. */
/* Copy the predefined charset into the allocated memory.     */
/* Allocate memory for sids. */
/* Copy the predefined charset into the allocated memory.     */
/* we have to invert the `sids' array for subsetted CID-keyed fonts */
/* Clean up if there was an error. */
/* Check for charset->sids.  If we do not have this, we fail. */
/* Zero out the code to gid/sid mappings. */
/* Note: The encoding table in a CFF font is indexed by glyph index;  */
/* the first encoded glyph index is 1.  Hence, we read the character  */
/* code (`glyph_code') at index j and make the assignment:            */
/*                                                                    */
/*    encoding->codes[glyph_code] = j + 1                             */
/*                                                                    */
/* We also make the assignment:                                       */
/*                                                                    */
/*    encoding->sids[glyph_code] = charset->sids[j + 1]               */
/*                                                                    */
/* This gives us both a code to GID and a code to SID mapping.        */
/* we need to parse the table to determine its size */
/* By convention, GID 0 is always ".notdef" and is never */
/* coded in the font.  Hence, the number of codes found  */
/* in the table is `count+1'.                            */
/*                                                       */
/* Make sure j is not too big. */
/* Assign code to GID mapping. */
/* Assign code to SID mapping. */
/* Parse the Format1 ranges. */
/* Read the first glyph code of the range. */
/* Read the number of codes in the range. */
/* Increment nleft, so we read `nleft + 1' codes/sids. */
/* compute max number of character codes */
/* Fill in the range of codes/sids. */
/* Make sure k is not too big. */
/* Assign code to GID mapping. */
/* Assign code to SID mapping. */
/* simple check; one never knows what can be found in a font */
/* Parse supplemental encodings, if any. */
/* count supplements */
/* Read supplemental glyph code. */
/* Read the SID associated with this glyph code. */
/* Assign code to SID mapping. */
/* First, look up GID which has been assigned to */
/* SID glyph_sid.                                */
/* We take into account the fact a CFF font can use a predefined */
/* encoding without containing all of the glyphs encoded by this */
/* encoding (see the note at the end of section 12 in the CFF    */
/* specification).                                               */
/* First, copy the code to SID mapping. */
/* First, copy the code to SID mapping. */
/* Construct code to GID mapping from code to SID mapping */
/* and charset.                                           */
/* Clean up if there was an error. */
/* set defaults */
/* we use the implementation specific SID value 0xFFFF to indicate */
/* missing entries                                                 */
/* if it is a CID font, we stop there */
/* parse the private dictionary, if any */
/* set defaults */
/* ensure that `num_blue_values' is even */
/* read the local subrs, if any */
/* read CFF font header */
/* check format */
/* skip the rest of the header */
/* read the name, top dict, string and global subrs index */
/* well, we don't really forget the `disabled' fonts... */
/* in case of a font format check, simply exit now */
/* now, parse the top-level font dictionary */
/* now, check for a CID font */
/* this is a CID-keyed font, we must now allocate a table of */
/* sub-fonts, then load each of them separately              */
/* allocate & read each font dict independently */
/* set up pointer table */
/* now load each subfont independently */
/* now load the FD Select array */
/* read the charstrings index now */
/* read the Charset and Encoding tables if available */
/* CID-keyed CFFs don't have an encoding */
/* get the font name (/CIDFontName for CID-keyed fonts, */
/* /FontName otherwise)                                 */
/* release font dictionaries, but only if working with */
/* a CID keyed CFF font                                */
/* the subfonts array has been allocated as a single block */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\cff\cffobjs.c
/***************************************************************************/
/*                                                                         */
/*  cffobjs.c                                                              */
/*                                                                         */
/*    OpenType objects manager (body).                                     */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,   */
/*            2010 by                                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/*                            SIZE FUNCTIONS                             */
/*                                                                       */
/*  Note that we store the global hints in the size's `internal' root    */
/*  field.                                                               */
/*                                                                       */
/*************************************************************************/
/* CFF_Size */
/* `internal' is freed by destroy_size (in ftobjs.c) */
/* CFF and Type 1 private dictionaries have slightly different      */
/* structures; we need to synthesize a Type 1 dictionary on the fly */
/* CFF_Size */
/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
/*************************************************************************/
/*                                                                       */
/*                            SLOT  FUNCTIONS                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/*                           FACE  FUNCTIONS                             */
/*                                                                       */
/*************************************************************************/
/* Strip all subset prefixes of the form `ABCDEF+'.  Usually, there */
/* is only one, but font names like `APCOOG+JFABTD+FuturaBQ-Bold'   */
/* have been seen in the wild.                                      */
/* ASCII uppercase letters */
/* CFF_Face */
/* create input stream from resource */
/* check whether we have a valid OpenType file */
/* `OTTO'; OpenType/CFF font */
/* if we are performing a simple font format check, exit immediately */
/* UNDOCUMENTED!  A CFF in an SFNT can have only a single font. */
/* now, the font can be either an OpenType/CFF font, or an SVG CEF */
/* font; in the latter case it doesn't have a `head' table         */
/* load font directory */
/* load the `cmap' table explicitly */
/* XXX: we don't load the GPOS table, as OpenType Layout     */
/* support will be added later to a layout library on top of */
/* FreeType 2                                                */
/* now load the CFF part of the file */
/* rewind to start of file; we are going to load a pure-CFF font */
/* now load and parse the CFF table in the file */
/* Complement the root flags with some interesting information. */
/* Note that this is only necessary for pure CFF and CEF fonts; */
/* SFNT based fonts use the `name' table instead.               */
/* we need the `PSNames' module for CFF and CEF formats */
/* which aren't CID-keyed                               */
/* Normalize the font matrix so that `matrix->xx' is 1; the */
/* scaling is done with `units_per_em' then (at this point, */
/* it already contains the scaling factor, but without      */
/* normalization of the matrix).                            */
/*                                                          */
/* Note that the offsets must be expressed in integer font  */
/* units.                                                   */
/* if *upm is larger than 100*1000 we divide by 1000 --     */
/* this can happen if e.g. there is no top-font FontMatrix  */
/* and the subfont FontMatrix already contains the complete */
/* scaling for the subfont (see section 5.11 of the PLRM)   */
/* 100 is a heuristic value */
/* set up num_faces */
/* compute number of glyphs */
/* set global bbox, as well as EM size */
/* no `U' suffix here to 0xFFFF! */
/* retrieve font family & style name */
/* We try to extract the style name from the full name.   */
/* We need to ignore spaces and dashes during the search. */
/* skip common characters at the start of both strings */
/* ignore spaces and dashes in full name during comparison */
/* ignore spaces and dashes in family name during comparison */
/* The full name begins with the same characters as the  */
/* family name, with spaces and dashes removed.  In this */
/* case, the remaining string in `fullp' will be used as */
/* the style name.                                       */
/* do we have a `/FontName' for a CID-keyed font? */
/* assume "Regular" style if we don't know better */
/*******************************************************************/
/*                                                                 */
/* Compute face flags.                                             */
/*                                                                 */
/* scalable outlines */
/* horizontal data   */
/* has native hinter */
/* fixed width font? */
/* XXX: WE DO NOT SUPPORT KERNING METRICS IN THE GPOS TABLE FOR NOW */
/* kerning available? */
/*******************************************************************/
/*                                                                 */
/* Compute style flags.                                            */
/*                                                                 */
/* double check */
/* CID-keyed CFF fonts don't have glyph names -- the SFNT loader */
/* has unset this flag because of the 3.0 `post' table.          */
/*******************************************************************/
/*                                                                 */
/* Compute char maps.                                              */
/*                                                                 */
/* Try to synthesize a Unicode charmap if there is none available */
/* already.  If an OpenType font contains a Unicode "cmap", we    */
/* will use it, whatever be in the CFF part of the file.          */
/* Windows Unicode? */
/* Apple Unicode platform id? */
/* Apple Unicode */
/* since CID-keyed fonts don't contain glyph names, we can't */
/* construct a cmap                                          */
/* we didn't find a Unicode charmap -- synthesize one */
/* if no Unicode charmap was previously selected, select this one */
/* Adobe platform id */
/* CFF_Face */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\cff\cffparse.c
/***************************************************************************/
/*                                                                         */
/*  cffparse.c                                                             */
/*                                                                         */
/*    CFF token stream parser (body)                                       */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2007, 2008, 2009, 2010 by       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* read an integer */
/* read a real */
/* First of all, read the integer part. */
/* If we entered this iteration with phase == 4, we need to */
/* read a new byte.  This also skips past the initial 0x1E. */
/* Make sure we don't read past the end. */
/* Get the nibble. */
/* Increase exponent if we can't add the digit. */
/* Skip leading zeros. */
/* Read fraction part, if any. */
/* If we entered this iteration with phase == 4, we need */
/* to read a new byte.                                   */
/* Make sure we don't read past the end. */
/* Get the nibble. */
/* Skip leading zeros if possible. */
/* Only add digit if we don't overflow. */
/* Read exponent, if any. */
/* If we entered this iteration with phase == 4, */
/* we need to read a new byte.                   */
/* Make sure we don't read past the end. */
/* Get the nibble. */
/* Arbitrarily limit exponent. */
/* We don't check `power_ten' and `exponent_add'. */
/* Only use `fraction_length'. */
/* Make `scaling' as small as possible. */
/* Check for overflow and underflow. */
/* Remove non-significant digits. */
/* this can only happen if exponent was non-zero */
/* Convert into 16.16 format. */
/* read a number, either integer or real */
/* read a floating point number, either integer or real */
/* read a floating point number, either integer or real, */
/* but return `10^scaling' times the number read in      */
/* read a floating point number, either integer or real,     */
/* and return it as precise as possible -- `scaling' returns */
/* the scaling factor (as a power of 10)                     */
/* We expect a well-formed font matrix, this is, the matrix elements */
/* `xx' and `yy' are of approximately the same magnitude.  To avoid  */
/* loss of precision, we use the magnitude of element `xx' to scale  */
/* all other elements.  The scaling factor is then contained in the  */
/* `units_per_em' value.                                             */
/* Return default matrix in case of unlikely values. */
/* FT_CONFIG_OPTION_PIC */
/*{ 0, 0, 0, 0, 0, 0, 0 }*/
/* FT_CONFIG_OPTION_PIC */
/* it's a number; we will push its position on the stack */
/* now, skip it */
/* skip real number */
/* An unterminated floating point number at the */
/* end of a dictionary is invalid but harmless. */
/* This is not a number, hence it's an operator.  Compute its code */
/* and look for it in our current list.                            */
/* two byte operator */
/* we found our field's handler; read it */
/* check that we have enough arguments -- except for */
/* delta encoded arrays, which can be empty          */
/* for 64-bit systems */
/* store count */
/* for 64-bit systems */
/* callback */
/* this is an unknown operator, or it is unsupported; */
/* we will ignore it for now.                         */
/* clear stack */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\cff\cffpic.c
/***************************************************************************/
/*                                                                         */
/*  cffpic.c                                                               */
/*                                                                         */
/*    The FreeType position independent code services for cff module.      */
/*                                                                         */
/*  Copyright 2009, 2010 by                                                */
/*  Oran Agra and Mickey Gabel.                                            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* forward declaration of PIC init functions from cffdrivr.c */
/* forward declaration of PIC init functions from cffparse.c */
/* forward declaration of PIC init functions from cffcmap.c */
/* allocate pointer, clear and set global container pointer */
/* initialize pointer table - this is how the module usually expects this data */
/* FT_CONFIG_OPTION_PIC */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\cid\cidgload.c
/***************************************************************************/
/*                                                                         */
/*  cidgload.c                                                             */
/*                                                                         */
/*    CID-keyed Type1 Glyph Loader (body).                                 */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010 by */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* For incremental fonts get the character data using */
/* the callback function.                             */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* For ordinary fonts read the CID font dictionary index */
/* and charstring offset from the CIDMap.                */
/* Now set up the subrs array and parse the charstrings. */
/* Set up subrs */
/* Set up font matrix */
/* Decode the charstring. */
/* Adjustment for seed bytes. */
/* Decrypt only if lenIV >= 0. */
/* Incremental fonts can optionally override the metrics. */
/* FT_CONFIG_OPTION_INCREMENTAL */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/**********                                                      *********/
/**********                                                      *********/
/**********            COMPUTE THE MAXIMUM ADVANCE WIDTH         *********/
/**********                                                      *********/
/**********    The following code is in charge of computing      *********/
/**********    the maximum advance width of the font.  It        *********/
/**********    quickly processes each glyph charstring to        *********/
/**********    extract the value from either a `sbw' or `seac'   *********/
/**********    operator.                                         *********/
/**********                                                      *********/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* Initialize load decoder */
/* size       */
/* glyph slot */
/* glyph names! XXX */
/* blend == 0 */
/* hinting == 0 */
/* TODO: initialize decoder.len_buildchar and decoder.buildchar */
/*       if we ever support CID-keyed multiple master fonts     */
/* for each glyph, parse the glyph charstring and extract */
/* the advance width                                      */
/* now get load the unscaled outline */
/* ignore the error if one occurred - skip to next glyph */
/* 0 */
/* CID_GlyphSlot */
/* CID_Size      */
/* glyph names -- XXX */
/* blend == 0 */
/* TODO: initialize decoder.len_buildchar and decoder.buildchar */
/*       if we ever support CID-keyed multiple master fonts     */
/* set up the decoder */
/* save new glyph tables */
/* now set the metrics -- this is rather simple, as    */
/* the left side bearing is the xMin, and the top side */
/* bearing the yMax                                    */
/* for composite glyphs, return only left side bearing and */
/* advance width                                           */
/* copy the _unscaled_ advance width */
/* make up vertical ones */
/* apply the font matrix */
/* scale the outline and the metrics */
/* First of all, scale the points */
/* Then scale the metrics */
/* compute the other metrics */
/* make up vertical ones */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\cid\cidload.c
/***************************************************************************/
/*                                                                         */
/*  cidload.c                                                              */
/*                                                                         */
/*    CID-keyed Type1 font loader (body).                                  */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2009 by             */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* read a single offset */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    TYPE 1 SYMBOL PARSING                      *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* if the keyword has a dedicated callback, call it */
/* we must now compute the address of our target object */
/* now, load the keyword data in the object's field(s) */
/* Set units per EM based on FontMatrix values.  We set the value to */
/* `1000/temp_scale', because temp_scale was already multiplied by   */
/* 1000 (in `t1_tofixed', from psobjs.c).                            */
/* we need to scale the values by 1.0/temp[3] */
/* note that the font offsets are expressed in integer font units */
/* this is a callback function; */
/* we must return an error code */
/* don't forget to set a few defaults */
/* default value for lenIV */
/* by mistake, `expansion_factor' appears both in PS_PrivateRec */
/* and CID_FaceDictRec (both are public header files and can't  */
/* changed); we simply copy the value                           */
/* look for `%ADOBeginFontDict' */
/* if /FDArray was found, then cid->num_dicts is > 0, and */
/* we can start increasing parser->num_dict               */
/* no error can occur in cid_parser_skip_spaces */
/* look for immediates */
/* now compare the immediate name to the keyword table */
/* we found it - run the parsing callback */
/* read the subrmap and the subrs of each font dict */
/* reallocate offsets array if needed */
/* read the subrmap's offsets */
/* now, compute the size of subrs charstrings, */
/* allocate, and read them                     */
/* set up pointers */
/* decrypt subroutines, but only if lenIV >= 0 */
/* finalize parser */
/* we must convert the data section from hexadecimal to binary */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\cid\cidobjs.c
/***************************************************************************/
/*                                                                         */
/*  cidobjs.c                                                              */
/*                                                                         */
/*    CID objects manager (body).                                          */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2008, 2010 by       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/*                            SLOT  FUNCTIONS                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/*                           SIZE  FUNCTIONS                             */
/*                                                                       */
/*************************************************************************/
/* CID_Size */
/* CID_Size */
/*************************************************************************/
/*                                                                       */
/*                           FACE  FUNCTIONS                             */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    cid_face_done                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Finalizes a given face object.                                     */
/*                                                                       */
/* <Input>                                                               */
/*    face :: A pointer to the face object to destroy.                   */
/*                                                                       */
/* CID_Face */
/* release subrs */
/* release FontInfo strings */
/* release font dictionaries */
/* release other strings */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    cid_face_init                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Initializes a given CID face object.                               */
/*                                                                       */
/* <Input>                                                               */
/*    stream     :: The source font stream.                              */
/*                                                                       */
/*    face_index :: The index of the font face in the resource.          */
/*                                                                       */
/*    num_params :: Number of additional generic parameters.  Ignored.   */
/*                                                                       */
/*    params     :: Additional generic parameters.  Ignored.             */
/*                                                                       */
/* <InOut>                                                               */
/*    face       :: The newly built face object.                         */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* CID_Face */
/* open the tokenizer; this will also check the font format */
/* if we just wanted to check the format, leave successfully now */
/* check the face index */
/* XXX: handle CID fonts with more than a single face */
/* now load the font program into the face object */
/* initialize the face object fields */
/* set up root face fields */
/* scalable outlines */
/* horizontal data   */
/* has native hinter */
/* XXX: TODO: add kerning with .afm support */
/* get style name -- be careful, some broken fonts only */
/* have a /FontName dictionary entry!                   */
/* assume "Regular" style if we don't know better */
/* do we have a `/FontName'? */
/* compute style flags */
/* no embedded bitmap support */
/* no `U' suffix here to 0xFFFF! */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    cid_driver_init                                                    */
/*                                                                       */
/* <Description>                                                         */
/*    Initializes a given CID driver object.                             */
/*                                                                       */
/* <Input>                                                               */
/*    driver :: A handle to the target driver object.                    */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    cid_driver_done                                                    */
/*                                                                       */
/* <Description>                                                         */
/*    Finalizes a given CID driver.                                      */
/*                                                                       */
/* <Input>                                                               */
/*    driver :: A handle to the target CID driver.                       */
/*                                                                       */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\cid\cidparse.c
/***************************************************************************/
/*                                                                         */
/*  cidparse.c                                                             */
/*                                                                         */
/*    CID-keyed Type1 parser (body).                                       */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009 by       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    INPUT STREAM PARSER                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* first of all, check the font format in the header */
/* now, read the rest of the file until we find */
/* `StartData' or `/sfnts'                      */
/* same as signed FT_Stream->size */
/* same as signed FT_Stream->size */
/* save offset of binary data after `StartData' */
/* We have found the start of the binary data or the `/sfnts' token. */
/* Now rewind and extract the frame corresponding to this PostScript */
/* section.                                                          */
/* Finally, we check whether `StartData' or `/sfnts' was real --  */
/* it could be in a comment or string.  We also get the arguments */
/* of `StartData' to find out whether the data is represented in  */
/* binary or hex format.                                          */
/* we haven't found the correct `StartData'; go back and continue */
/* searching                                                      */
/* always free the private dictionary */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\cid\cidriver.c
/***************************************************************************/
/*                                                                         */
/*  cidriver.c                                                             */
/*                                                                         */
/*    CID driver interface (body).                                         */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2006, 2008, 2009 by             */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*
/*
/* unsupported with CID fonts */
/* unsupported                */
/*
/* cid driver is only used for CID keyed fonts */
/* identity mapping */
/*
/* first of all, the FT_Module_Class fields */
/* module name           */
/* version 1.0 of driver */
/* requires FreeType 2.0 */
/* then the other font drivers fields */
/* FT_Face_GetKerningFunc  */
/* FT_Face_AttachFunc      */
/* FT_Face_GetAdvancesFunc */
/* FT_Size_SelectFunc      */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\cid\type1cid.c
/***************************************************************************/
/*                                                                         */
/*  type1cid.c                                                             */
/*                                                                         */
/*    FreeType OpenType driver component (body only).                      */
/*                                                                         */
/*  Copyright 1996-2001 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gxvalid\gxvalid.c
/***************************************************************************/
/*                                                                         */
/*  gxvalid.c                                                              */
/*                                                                         */
/*    FreeType validator for TrueTypeGX/AAT tables (body only).            */
/*                                                                         */
/*  Copyright 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K.,       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gxvalid\gxvbsln.c
/***************************************************************************/
/*                                                                         */
/*  gxvbsln.c                                                              */
/*                                                                         */
/*    TrueTypeGX/AAT bsln table validation (body).                         */
/*                                                                         */
/*  Copyright 2004, 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K., */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      Data and Types                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      UTILITY FUNCTIONS                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*
/* XXX: check range ? */
/* deltas */
/* No ctlPoints here. */
/* deltas */
/* mappingData */
/* stdGlyph */
/* Record the position of ctlPoints */
/* ctlPoints */
/* stdGlyph + ctlPoints */
/* mappingData */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                         bsln TABLE                            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* only version 1.0 is defined (1996) */
/* only format 1, 2, 3 are defined (1996) */
/* arch-tag: ebe81143-fdaa-4c68-a4d1-b57227daa3bc
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gxvalid\gxvcommn.c
/***************************************************************************/
/*                                                                         */
/*  gxvcommn.c                                                             */
/*                                                                         */
/*    TrueTypeGX/AAT common tables validation (body).                      */
/*                                                                         */
/*  Copyright 2004, 2005, 2009, 2010                                       */
/*  by suzuki toshiya, Masatake YAMATO, Red Hat K.K.,                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                       16bit offset sorter                     *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                       32bit offset sorter                     *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****               scan value array and get min & max              *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                       BINSEARCHHEADER                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                         LOOKUP TABLE                          *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* ================= Simple Array Format 0 Lookup Table ================ */
/* some fonts have too-short fmt0 array */
/* ================= Segment Single Format 2 Loolup Table ============== */
/*
/* lastGlyph */
/* firstGlyph */
/* ftxvalidator silently skips such an entry */
/* ================= Segment Array Format 4 Lookup Table =============== */
/* ftxvalidator silently skips such an entry */
/* ================= Segment Table Format 6 Lookup Table =============== */
/* ================= Trimmed Array Format 8 Lookup Table =============== */
/* firstGlyph + glyphCount */
/* valueArray */
/* 0 */
/* 1 */
/* 2 */
/* 3 */
/* 4 */
/* 5 */
/* 6 */
/* 7 */
/* 8 */
/* lookuptbl_head may be used in fmt4 transit function. */
/* format */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          Glyph ID                             *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                        CONTROL POINT                          *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          SFNT NAME                            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* make compiler happy */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          STATE TABLE                          *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* -------------------------- Class Table --------------------------- */
/*
/* Classes 0, 2, and 3 are predefined */
/* following classes should not appear in class array */
/* end of text */
/* out of bounds */
/* end of line */
/* out of bounds */
/* user-defined: 4 - ( stateSize - 1 ) */
/* assign glyph to undefined state */
/* scan max ClassID in use */
/* XXX: Check Range? */
/* --------------------------- State Array ----------------------------- */
/* for the non-debugging case */
/*
/* read if enough to read another state */
/* --------------------------- Entry Table ----------------------------- */
/* ftxvalidator and FontValidator both warn and continue */
/* make compiler happy */
/* =========================== State Table ============================= */
/* offset to Class(Sub)Table */
/* offset to StateArray */
/* offset to EntryTable */
/* 0:start of text, 1:start of line are predefined */
/* ================= eXtended State Table (for morx) =================== */
/*
/* XXX: check range? */
/* for the non-debugging case */
/*
/* read if enough to read another state */
/* make compiler happy */
/* StateHeader members */
/* offset to Class(Sub)Table */
/* offset to StateArray */
/* offset to EntryTable */
/* XXX: check range? */
/* 0:start of text, 1:start of line are predefined */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                        Table overlapping                      *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gxvalid\gxvfeat.c
/***************************************************************************/
/*                                                                         */
/*  gxvfeat.c                                                              */
/*                                                                         */
/*    TrueTypeGX/AAT feat table validation (body).                         */
/*                                                                         */
/*  Copyright 2004, 2005, 2008 by                                          */
/*  suzuki toshiya, Masatake YAMATO, Red Hat K.K.,                         */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      Data and Types                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      UTILITY FUNCTIONS                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* Don't use here. Apple is reserved. */
/* If we have exclusive setting, the setting should be odd. */
/* feature + nSettings + settingTable + featureFlags */
/* If exclusive, check whether default setting is in the range. */
/* setting + nameIndex */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                         feat TABLE                            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* version + featureNameCount + none_0 + none_1  */
/* Version */
/* skip (none) and (none) */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gxvalid\gxvfgen.c
/***************************************************************************/
/*                                                                         */
/*  gxfgen.c                                                               */
/*                                                                         */
/*    Generate feature registry data for gxv `feat' validator.             */
/*    This program is derived from gxfeatreg.c in gxlayout.                */
/*                                                                         */
/*  Copyright 2004, 2005, 2006 by Masatake YAMATO and Redhat K.K.          */
/*                                                                         */
/*  This file may only be used,                                            */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/*  gxfeatreg.c                                                            */
/*                                                                         */
/*    Database of font features pre-defined by Apple Computer, Inc.        */
//developer.apple.com/fonts/Registry/                           */
/*    http://developer.apple.com/fonts/Registry/                           */
/*    (body).                                                              */
/*                                                                         */
/*  Copyright 2003 by                                                      */
/*  Masatake YAMATO and Redhat K.K.                                        */
/*                                                                         */
/*  This file may only be used,                                            */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* Development of gxfeatreg.c is supported by                              */
/* Information-technology Promotion Agency, Japan.                         */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* This file is compiled as a stand-alone executable.                      */
/* This file is never compiled into `libfreetype2'.                        */
/* The output of this file is used in `gxvfeat.c'.                         */
/* ----------------------------------------------------------------------- */
/* Compile: gcc `pkg-config --cflags freetype2` gxvfgen.c -o gxvfgen       */
/* Run: ./gxvfgen > tmp.c                                                  */
/*                                                                         */
/***************************************************************************/
/*******************************************************************/
/* WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING */
/*******************************************************************/
/*
/*******************************************************************/
/* WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING */
/*******************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      Data and Types                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* 0 */
/* 1 */
/* 2 */
/* 3 */
/* 4 */
/* "Substitute Vertical Forms", */
/* 5 */
/* "Linguistic Rearrangement", */
/* 6 */
/* 7 */
/* 8 */
/* 9 */
/* 10 */
/* "Normal Position", */
/* 11 */
/* 12 */
/* 13 */
/* "Prevent Overlap", */
/* 14 */
/* 15 */
/* 16 */
/* 17 */
/* TODO */
/* 18 */
/* TODO */
/* 19 */
/* 20 */
/* count => 12 */
/* 21 */
/* 22 */
/* Here after Newer */  { /* 23 */
/* 24 */
/* 25 */
/* 26 */
/* 27-30 */
/* 31-35 */
/* 36-40 */
/* 40-45 */
/* 46-50 */
/* 51-55 */
/* 56-60 */
/* 61-65 */
/* 66-70 */
/* 71-75 */
/* 76-80 */
/* 81-85 */
/* 86-90 */
/* 91-95 */
/* 96-98 */
/* 99 */ {                   /* 100 => 22 */
/* 101 => 25 */
/* 102 => 26 */
/* 103 */
/* 104 => 1 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                         Generator                             *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* Generated from %s */\n", __FILE__ );
/* Do nothing */
/* %s */\n",
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gxvalid\gxvjust.c
/***************************************************************************/
/*                                                                         */
/*  gxvjust.c                                                              */
/*                                                                         */
/*    TrueTypeGX/AAT just table validation (body).                         */
/*                                                                         */
/*  Copyright 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K.,       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*
//developer.apple.com/fonts/TTRefMan/RM06/Chap6just.html
/* TODO: decode flags for human readability */
/* Apple misspelled "Threshhold" */
/* parse single actSubrecord */
/* Stretch glyph action: no actionData */
/* subtable_length is set by gxv_LookupTable_validate() */
/* TODO: validate markClass & currentClass */
/* subtable_length is set by gxv_LookupTable_validate() */
/* subtable_length is set by gxv_LookupTable_validate() */
/*
/*
/* Version 1.0 (always:2000) */
/* format 0 (always:2000) */
/* validate justData */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gxvalid\gxvkern.c
/***************************************************************************/
/*                                                                         */
/*  gxvkern.c                                                              */
/*                                                                         */
/*    TrueTypeGX/AAT kern table validation (body).                         */
/*                                                                         */
/*  Copyright 2004, 2005, 2006, 2007                                       */
/*  by suzuki toshiya, Masatake YAMATO, Red Hat K.K.,                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      Data and Types                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      SUBTABLE VALIDATORS                      *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* ============================= format 0 ============================== */
/* left */
/* right */
/* Pairs of left and right GIDs must be unique and sorted. */
/* skip the kern value */
/* nPairs, searchRange, entrySelector, rangeShift */
/* ============================= format 1 ============================== */
/*
/*
/* ================ Data for Class-Based Subtables 2, 3 ================ */
/* ============================= format 2 ============================== */
/* ---------------------- format 2 specific data ----------------------- */
/* -------------------------- utility functions ----------------------- */
/* ============================= format 3 ============================== */
/*
/*
/*
/*
/* new Apple-dialect */
/* reserved bits = 0 */
/* classic Apple-dialect */
/* check expected flags, but don't check if MS-dialect is impossible */
/* reserved bits = 0 */
/* format 1 requires GX State Machine, too new for classic */
/* classic Microsoft-dialect */
/* reserved bits = 0 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                            MAIN                               *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* MS only: subtable version, unused */
/* MS: 16bit, Apple: 32bit*/
/* Apple only */
/* subtable format */
/* Apple: length_hi MS: version */
/* Apple: length_lo MS: length */
/* formats 1, 2, 3 require the position of the start of this subtable */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                         kern TABLE                            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* p should be 32bit-aligned? */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gxvalid\gxvlcar.c
/***************************************************************************/
/*                                                                         */
/*  gxvlcar.c                                                              */
/*                                                                         */
/*    TrueTypeGX/AAT lcar table validation (body).                         */
/*                                                                         */
/*  Copyright 2004, 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K., */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      Data and Types                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      UTILITY FUNCTIONS                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*
/* XXX: check range? */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          lcar TABLE                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gxvalid\gxvmod.c
/***************************************************************************/
/*                                                                         */
/*  gxvmod.c                                                               */
/*                                                                         */
/*    FreeType's TrueTypeGX/AAT validation module implementation (body).   */
/*                                                                         */
/*  Copyright 2004, 2005, 2006                                             */
/*  by suzuki toshiya, Masatake YAMATO, Red Hat K.K.,                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* load tables */
/* validate tables */
/* Set results */
/* without volatile on `error' GCC 4.1.1. emits:                         */
/*  warning: variable 'error' might be clobbered by 'longjmp' or 'vfork' */
/* this warning seems spurious but ---                                   */
/* module-specific interface */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gxvalid\gxvmort.c
/***************************************************************************/
/*                                                                         */
/*  gxvmort.c                                                              */
/*                                                                         */
/*    TrueTypeGX/AAT mort table validation (body).                         */
/*                                                                         */
/*  Copyright 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K.,       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* nSettings in gxvfeat.c is halved for exclusive on/off settings */
/* TODO: enableFlags must be unique value in specified chain?  */
/*
/* 0 */
/* 1 */
/* 2 */
/* 3 */
/* 4 */
/* 5 */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gxvalid\gxvmort0.c
/***************************************************************************/
/*                                                                         */
/*  gxvmort0.c                                                             */
/*                                                                         */
/*    TrueTypeGX/AAT mort table validation                                 */
/*    body for type0 (Indic Script Rearrangement) subtable.                */
/*                                                                         */
/*  Copyright 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K.,       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* for the non-debugging */
/* case                  */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gxvalid\gxvmort1.c
/***************************************************************************/
/*                                                                         */
/*  gxvmort1.c                                                             */
/*                                                                         */
/*    TrueTypeGX/AAT mort table validation                                 */
/*    body for type1 (Contextual Substitution) subtable.                   */
/*                                                                         */
/*  Copyright 2005, 2007 by suzuki toshiya, Masatake YAMATO, Red Hat K.K., */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* XXX: check range? */
/* TODO: min_gid & max_gid comparison with ClassTable contents */
/*
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gxvalid\gxvmort2.c
/***************************************************************************/
/*                                                                         */
/*  gxvmort2.c                                                             */
/*                                                                         */
/*    TrueTypeGX/AAT mort table validation                                 */
/*    body for type2 (Ligature Substitution) subtable.                     */
/*                                                                         */
/*  Copyright 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K.,       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* access ligActionTable */
/* FontValidator, ftxvalidator, ftxdumperfuser warn but continue */
/* FontValidator, ftxvalidator, ftxdumperfuser warn but continue */
/* validate entry in ligActionTable */
/* Apple does not give specification of ligatureTable format */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gxvalid\gxvmort4.c
/***************************************************************************/
/*                                                                         */
/*  gxvmort4.c                                                             */
/*                                                                         */
/*    TrueTypeGX/AAT mort table validation                                 */
/*    body for type4 (Non-Contextual Glyph Substitution) subtable.         */
/*                                                                         */
/*  Copyright 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K.,       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*
/* XXX: check range? */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gxvalid\gxvmort5.c
/***************************************************************************/
/*                                                                         */
/*  gxvmort5.c                                                             */
/*                                                                         */
/*    TrueTypeGX/AAT mort table validation                                 */
/*    body for type5 (Contextual Glyph Insertion) subtable.                */
/*                                                                         */
/*  Copyright 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K.,       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*
/*
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gxvalid\gxvmorx.c
/***************************************************************************/
/*                                                                         */
/*  gxvmorx.c                                                              */
/*                                                                         */
/*    TrueTypeGX/AAT morx table validation (body).                         */
/*                                                                         */
/*  Copyright 2005, 2008 by                                                */
/*  suzuki toshiya, Masatake YAMATO, Red Hat K.K.,                         */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* 0 */
/* 1 */
/* 2 */
/* 3 */
/* 4 */
/* 5 */
/* morx coverage consists of mort_coverage & 16bit padding */
/* feature-array of morx is same with that of mort */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gxvalid\gxvmorx0.c
/***************************************************************************/
/*                                                                         */
/*  gxvmorx0.c                                                             */
/*                                                                         */
/*    TrueTypeGX/AAT morx table validation                                 */
/*    body for type0 (Indic Script Rearrangement) subtable.                */
/*                                                                         */
/*  Copyright 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K.,       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gxvalid\gxvmorx1.c
/***************************************************************************/
/*                                                                         */
/*  gxvmorx1.c                                                             */
/*                                                                         */
/*    TrueTypeGX/AAT morx table validation                                 */
/*    body for type1 (Contextual Substitution) subtable.                   */
/*                                                                         */
/*  Copyright 2005, 2007 by suzuki toshiya, Masatake YAMATO, Red Hat K.K., */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* for the non-debugging case */
/* XXX: check range? */
/*
/* TODO: calculate offset/length for each lookupTables */
/* TODO: overlapping of lookupTables in substitutionTable */
/*
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gxvalid\gxvmorx2.c
/***************************************************************************/
/*                                                                         */
/*  gxvmorx2.c                                                             */
/*                                                                         */
/*    TrueTypeGX/AAT morx table validation                                 */
/*    body for type2 (Ligature Substitution) subtable.                     */
/*                                                                         */
/*  Copyright 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K.,       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* access ligActionTable */
/* validate entry in ligActionTable */
/* Apple does not give specification of ligatureTable format */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gxvalid\gxvmorx4.c
/***************************************************************************/
/*                                                                         */
/*  gxvmorx4.c                                                             */
/*                                                                         */
/*    TrueTypeGX/AAT morx table validation                                 */
/*    body for "morx" type4 (Non-Contextual Glyph Substitution) subtable.  */
/*                                                                         */
/*  Copyright 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K.,       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gxvalid\gxvmorx5.c
/***************************************************************************/
/*                                                                         */
/*  gxvmorx5.c                                                             */
/*                                                                         */
/*    TrueTypeGX/AAT morx table validation                                 */
/*    body for type5 (Contextual Glyph Insertion) subtable.                */
/*                                                                         */
/*  Copyright 2005, 2007 by suzuki toshiya, Masatake YAMATO, Red Hat K.K., */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gxvalid\gxvopbd.c
/***************************************************************************/
/*                                                                         */
/*  gxvopbd.c                                                              */
/*                                                                         */
/*    TrueTypeGX/AAT opbd table validation (body).                         */
/*                                                                         */
/*  Copyright 2004, 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K., */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      Data and Types                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      UTILITY FUNCTIONS                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* offset in LookupTable is measured from the head of opbd table */
/* format 1, value is ctrl pt. */
/* format 0, value is distance */
/*
/* XXX: check range? */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                         opbd TABLE                            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* only 0x00010000 is defined (1996) */
/* only values 0 and 1 are defined (1996) */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gxvalid\gxvprop.c
/***************************************************************************/
/*                                                                         */
/*  gxvprop.c                                                              */
/*                                                                         */
/*    TrueTypeGX/AAT prop table validation (body).                         */
/*                                                                         */
/*  Copyright 2004, 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K., */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      Data and Types                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      UTILITY FUNCTIONS                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* Pass 0 as GLYPH to check the default property */
/* Top bit is set: negative */
/* Calculate the absolute offset */
/* The gid for complement must be greater than 0 */
/* The gid for complement must be the face. */
/* this is introduced in version 2.0 */
/* TODO: Too restricted. Use the validation level. */
/*
/* XXX: check range? */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                         prop TABLE                            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* only versions 1.0, 2.0, 3.0 are defined (1996) */
/* only formats 0x0000, 0x0001 are defined (1996) */
/* format == 1 */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gxvalid\gxvtrak.c
/***************************************************************************/
/*                                                                         */
/*  gxvtrak.c                                                              */
/*                                                                         */
/*    TrueTypeGX/AAT trak table validation (body).                         */
/*                                                                         */
/*  Copyright 2004, 2005 by suzuki toshiya, Masatake YAMATO, Red Hat K.K., */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* gxvalid is derived from both gxlayout module and otvalid module.        */
/* Development of gxlayout is supported by the Information-technology      */
/* Promotion Agency(IPA), Japan.                                           */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      Data and Types                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*
//developer.apple.com/fonts/TTRefMan/RM06/Chap6trak.html
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      UTILITY FUNCTIONS                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* read the header of trackData */
/* validate trackTable */
/* sizeTable is array of FT_Fixed, don't check contents */
/* validate trackValueOffet */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          trak TABLE                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* Version 1.0 (always:1996) */
/* format 0 (always:1996) */
/* Reserved Fixed Value (always) */
/* validate trackData */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gzip\adler32.c
/* adler32.c -- compute the Adler-32 checksum of a data stream
/* @(#) $Id$ */
/* largest prime smaller than 65536 */
/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
/* ========================================================================= */
/* adler, buf, len) */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gzip\ftgzip.c
/***************************************************************************/
/*                                                                         */
/*  ftgzip.c                                                               */
/*                                                                         */
/*    FreeType support for .gz compressed files.                           */
/*                                                                         */
/*  This optional component relies on zlib.  It should mainly be used to   */
/*  parse compressed PCF fonts, as found with many X11 server              */
/*  distributions.                                                         */
/*                                                                         */
/*  Copyright 2002, 2003, 2004, 2005, 2006, 2009, 2010 by                  */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* !FT_CONFIG_OPTION_SYSTEM_ZLIB */
/* In this case, we include our own modified sources of the ZLib    */
/* within the "ftgzip" component.  The modifications were necessary */
/* to #include all files without conflicts, as well as preventing   */
/* the definition of "extern" functions that may cause linking      */
/* conflicts when a program is linked with both FreeType and the    */
/* original ZLib.                                                   */
/* prevent all zcalloc() & zfree() in zutils.c */
/* we can't use asm-optimized sources here! */
/* Urgh.  `inflate_mask' must not be declared twice -- C++ doesn't like
/* infutil.c must be included before infcodes.c */
/* !FT_CONFIG_OPTION_SYSTEM_ZLIB */
/***************************************************************************/
/***************************************************************************/
/*****                                                                 *****/
/*****            Z L I B   M E M O R Y   M A N A G E M E N T          *****/
/*****                                                                 *****/
/***************************************************************************/
/***************************************************************************/
/* it is better to use FreeType memory routines instead of raw
/* !SYSTEM_ZLIB && !USE_ZLIB_ZCALLOC */
/***************************************************************************/
/***************************************************************************/
/*****                                                                 *****/
/*****               Z L I B   F I L E   D E S C R I P T O R           *****/
/*****                                                                 *****/
/***************************************************************************/
/***************************************************************************/
/* parent/source stream        */
/* embedding stream            */
/* memory allocator            */
/* zlib input stream           */
/* starting position, after .gz header */
/* input read buffer  */
/* output buffer      */
/* position in output */
/* gzip flag byte */
/* bit 0 set: file probably ascii text */
/* bit 1 set: header CRC present */
/* bit 2 set: extra field present */
/* bit 3 set: original file name present */
/* bit 4 set: file comment present */
/* bits 5..7: reserved */
/* check and skip .gz header - we don't support `transparent' compression */
/* head[0] && head[1] are the magic numbers;    */
/* head[2] is the method, and head[3] the flags */
/* skip time, xflags and os code */
/* skip the extra field */
/* skip original file name */
/* skip .gz comment */
/* skip CRC */
/* check and skip .gz header */
/* initialize zlib -- there is no zlib header in the compressed stream */
/* clear the rest */
/* fill output buffer; `count' must be <= FT_GZIP_BUFFER_SIZE */
/* Reset inflate stream if we're seeking backwards.        */
/* Yes, that is not too efficient, but it saves memory :-) */
/* skip unwanted bytes */
/* now read the data */
/***************************************************************************/
/***************************************************************************/
/*****                                                                 *****/
/*****               G Z   E M B E D D I N G   S T R E A M             *****/
/*****                                                                 *****/
/***************************************************************************/
/***************************************************************************/
/* finalize gzip file descriptor */
/*
/*
/* don't know the real size! */
/* !FT_CONFIG_OPTION_USE_ZLIB */
/* !FT_CONFIG_OPTION_USE_ZLIB */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gzip\infblock.c
/* infblock.c -- interpret and process block types to last block
/* simplify the use of the inflate_huft type with some defines */
/* Table for deflate from PKZIP's appnote.txt. */
/* Order of the bit length code lengths */
/*
/* s, z, c) */
/* z, c, w) */
/* s, z, r) */
/* temporary storage */
/* bit buffer */
/* bits in bit buffer */
/* input data pointer */
/* bytes available there */
/* output window write pointer */
/* bytes to end of window or read pointer */
/* copy input/output information to locals (UPDATE macro restores) */
/* process input based on current state */
/* stored */
/* go to byte boundary */
/* get length of stored block */
/* fixed */
/* dynamic */
/* illegal */
/* dump bits */
/* c == 16..18 */
/* must be <= 9 for lookahead assumptions */
/* must be <= 9 for lookahead assumptions */
/* s, z) */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gzip\infcodes.c
/* infcodes.c -- process literals and length/distance pairs
/* simplify the use of the inflate_huft type with some defines */
/* waiting for "i:"=input, "o:"=output, "x:"=nothing */
/* x: set up for LEN */
/* i: get length/literal/eob next */
/* i: getting length extra (have base) */
/* i: get distance next */
/* i: getting distance extra */
/* o: copying bytes in window, waiting for space */
/* o: got literal, waiting for output space */
/* o: got eob, possibly still output waiting */
/* x: got eob and all data flushed */
/* x: got error */
/* inflate codes private state */
/* mode */
/* current inflate_codes mode */
/* mode dependent information */
/* pointer into tree */
/* bits needed */
/* if LEN or DIST, where in tree */
/* if LIT, literal */
/* bits to get for extra */
/* distance back to copy from */
/* if EXT or COPY, where and how much */
/* submode */
/* mode independent information */
/* ltree bits decoded per branch */
/* dtree bits decoder per branch */
/* literal/length/eob tree */
/* distance tree */
/* bl, bd, tl, td, z) */
/* need separate declaration for Borland C++ */
/* s, z, r) */
/* temporary storage */
/* temporary pointer */
/* extra bits or operation */
/* bit buffer */
/* bits in bit buffer */
/* input data pointer */
/* bytes available there */
/* output window write pointer */
/* bytes to end of window or read pointer */
/* pointer to copy strings from */
/* codes state */
/* copy input/output information to locals (UPDATE macro restores) */
/* process input and output based on current state */
/* waiting for "i:"=input, "o:"=output, "x:"=nothing */
/* x: set up for LEN */
/* !SLOW */
/* i: get length/literal/eob next */
/* literal */
/* length */
/* next table */
/* end of block */
/* invalid code */
/* i: getting length extra (have base) */
/* i: get distance next */
/* distance */
/* next table */
/* invalid code */
/* i: getting distance extra */
/* o: copying bytes in window, waiting for space */
/* modulo window size-"while" instead */
/* of "if" handles invalid distances */
/* o: got literal, waiting for output space */
/* o: got eob, possibly more output */
/* return unused byte, if any */
/* can always return one */
/* x: got error */
/* Some dumb compilers complain without this */
/* c, z) */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gzip\inflate.c
/* inflate.c -- zlib interface to inflate modules
/* waiting for method byte */
/* waiting for flag byte */
/* four dictionary check bytes to go */
/* three dictionary check bytes to go */
/* two dictionary check bytes to go */
/* one dictionary check byte to go */
/* waiting for inflateSetDictionary */
/* decompressing blocks */
/* four check bytes to go */
/* three check bytes to go */
/* two check bytes to go */
/* one check byte to go */
/* finished check, done */
/* got an error--stay here */
/* inflate private state */
/* mode */
/* current inflate mode */
/* mode dependent information */
/* if FLAGS, method byte */
/* computed check value */
/* stream check value */
/* if CHECK, check values to compare */
/* if BAD, inflateSync's marker bytes count */
/* submode */
/* mode independent information */
/* flag for no wrapper */
/* log2(window size)  (8..15, defaults to 15) */
/* current inflate_blocks state */
/* z) */
/* z) */
/* z, w, version, stream_size) */
/* initialize state */
/* handle undocumented nowrap option (no zlib header or check) */
/* set window size */
/* create inflate_blocks state */
/* reset state */
/* z, f) */
/* can't try inflateSync */
/* can't try inflateSync */
/* can't try inflateSync */
/* can try inflateSync */
/* can try inflateSync */
/* can't try inflateSync */
/* Some dumb compilers complain without this */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gzip\inftrees.c
/* inftrees.c -- generate Huffman trees for efficient decoding
/* non ANSI compilers may not accept inffixed.h */
/*
/* simplify the use of the inflate_huft type with some defines */
/* code lengths in bits */
/* number of codes */
/* number of "simple" codes */
/* list of base values for non-simple codes */
/* list of extra bits for non-simple codes */
/* result: starting table */
/* maximum lookup bits (returns actual) */
/* space for trees */
/* hufts used in space */
/* space for values */
/* Tables for deflate from PKZIP's appnote.txt. */
/* Copy lengths for literal codes 257..285 */
/* see note #13 above about 258 */
/* Extra bits for literal codes 257..285 */
/* 112==invalid */
/* Copy offsets for distance codes 0..29 */
/* Extra bits for distance codes */
/*
/* If BMAX needs to be larger than 16, then h and x[] should be uLong. */
/* maximum bit length of any code */
/* b, n, s, d, e, t, m, hp, hn, v) */
/* code lengths in bits (all assumed <= BMAX) */
/* number of codes (assumed <= 288) */
/* number of simple-valued codes (0..s-1) */
/* list of base values for non-simple codes */
/* list of extra bits for non-simple codes */
/* result: starting table */
/* maximum lookup bits, returns actual */
/* space for trees */
/* hufts used in space */
/* working area: values in order of bit length */
/* Given a list of code lengths and a maximum table size, make a set of
/* counter for codes of length k */
/* bit length count table */
/* i repeats in table every f entries */
/* maximum code length */
/* table level */
/* counter, current code */
/* counter */
/* number of bits in current code */
/* bits per table (returned in m) */
/* (1 << w) - 1, to avoid cc -O bug on HP */
/* pointer into c[], b[], or v[] */
/* points to current table */
/* table entry for structure assignment */
/* table stack */
/* bits before this table == (l * h) */
/* bit offsets, then code stack */
/* pointer into x */
/* number of dummy codes added */
/* number of entries in current table */
/* Make compiler happy */
/* Generate counts for each bit length */
/* clear c[]--assume BMAX+1 is 16 */
/* assume all entries <= BMAX */
/* null input--all zero length codes */
/* Find minimum and maximum length, bound *m by those */
/* minimum code length */
/* maximum code length */
/* Adjust last length count to fill out codes, if needed */
/* Generate starting offsets into the value table for each length */
/* note that i == g from above */
/* Make a table of values in order of bit lengths */
/* set n to length of v */
/* Generate the Huffman codes and for each, make the table entries */
/* first Huffman code is zero */
/* grab values in bit order */
/* no tables yet--level -1 */
/* bits decoded == (l * h) */
/* just to keep compilers happy */
/* ditto */
/* ditto */
/* go through the bit lengths (k already is bits in shortest code) */
/* here i is the Huffman code of length k bits for value *p */
/* make tables up to required level */
/* previous table always l bits */
/* compute minimum size table less than or equal to l bits */
/* table size upper limit */
/* try a k-w bit table */
/* too few codes for k-w bit table */
/* deduct codes from patterns left */
/* try smaller tables up to z bits */
/* enough codes to use up j bits */
/* else deduct codes from patterns */
/* table entries for j-bit table */
/* allocate new table */
/* (note: doesn't matter for fixed) */
/* overflow of MANY */
/* connect to last table, if there is one */
/* save pattern for backing up */
/* bits to dump before this table */
/* bits in this table */
/* offset to this table */
/* connect to last table */
/* first table is returned result */
/* set up table entry in r */
/* out of values--invalid code */
/* 256 is end-of-block */
/* simple code is just the value */
/* non-simple--look up in lists */
/* fill code-like entries with r */
/* backwards increment the k-bit code i */
/* backup over finished tables */
/* needed on HP, cc -O bug */
/* don't need to update q */
/* Return Z_BUF_ERROR if we were given an incomplete table */
/* c, bb, tb, hp, z) */
/* 19 code lengths */
/* bits tree desired/actual depth */
/* bits tree result */
/* space for trees */
/* for messages */
/* hufts used in space */
/* work area for huft_build */
/* nl, nd, c, bl, bd, tl, td, hp, z) */
/* number of literal/length codes */
/* number of distance codes */
/* that many (total) code lengths */
/* literal desired/actual bit depth */
/* distance desired/actual bit depth */
/* literal/length tree result */
/* distance tree result */
/* space for trees */
/* for messages */
/* hufts used in space */
/* work area for huft_build */
/* allocate work area */
/* build literal/length tree */
/* build distance tree */
/* done */
/* build fixed tables only once--keep them here */
/* number of hufts used by fixed tables */
/* bl, bd, tl, td, z) */
/* literal desired/actual bit depth */
/* distance desired/actual bit depth */
/* literal/length tree result */
/* distance tree result */
/* for memory allocation */
/* build fixed tables if not already */
/* temporary variable */
/* number of hufts used in fixed_mem */
/* length list for huft_build */
/* work area for huft_build */
/* allocate memory */
/* literal table */
/* distance table */
/* done */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gzip\infutil.c
/* inflate_util.c -- data and routines common to blocks and codes
/* And'ing with mask[n] masks the lower n bits */
/* copy as much as possible from the sliding window to the output area */
/* s, z, r) */
/* local copies of source and destination pointers */
/* compute number of bytes to copy as far as end of window */
/* update counters */
/* update check information */
/* copy as far as end of window */
/* see if more to copy at beginning of window */
/* wrap pointers */
/* compute bytes to copy */
/* update counters */
/* update check information */
/* copy */
/* update pointers */
/* done */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\gzip\zutil.c
/* zutil.c -- target dependent utility functions for the compression library
/* @(#) $Id$ */
/* ??? to be unrolled */
/* ??? to be unrolled */
/* Small and medium model in Turbo C are for now limited to near allocation
/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
/* 10*64K = 640K */
/* This table is used to remember the original form of pointers
/* just to make some compilers happy */
/* If we allocate less than 65520 bytes, we assume that farmalloc
/* Normalize the pointer to seg:0 */
/* object < 64K */
/* Find the original pointer */
/* just to make some compilers happy */
/* MSDOS && __TURBOC__ */
/* Microsoft C in 16-bit mode */
/* to make compiler happy */
/* to make compiler happy */
/* MSC */
/* Any system without a special alloc function */
/* make compiler happy */
/* make compiler happy */
/* MY_ZCALLOC */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\lzw\ftlzw.c
/***************************************************************************/
/*                                                                         */
/*  ftlzw.c                                                                */
/*                                                                         */
/*    FreeType support for .Z compressed files.                            */
/*                                                                         */
/*  This optional component relies on NetBSD's zopen().  It should mainly  */
/*  be used to parse compressed PCF fonts, as found with many X11 server   */
/*  distributions.                                                         */
/*                                                                         */
/*  Copyright 2004, 2005, 2006, 2009, 2010 by                              */
/*  Albert Chin-A-Young.                                                   */
/*                                                                         */
/*  Based on code in src/gzip/ftgzip.c, Copyright 2004 by                  */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/*****                                                                 *****/
/*****                  M E M O R Y   M A N A G E M E N T              *****/
/*****                                                                 *****/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/***************************************************************************/
/*****                                                                 *****/
/*****                   F I L E   D E S C R I P T O R                 *****/
/*****                                                                 *****/
/***************************************************************************/
/***************************************************************************/
/* parent/source stream        */
/* embedding stream            */
/* memory allocator            */
/* lzw decompressor state      */
/* output buffer      */
/* position in output */
/* check and skip .Z header */
/* head[0] && head[1] are the magic numbers */
/* check and skip .Z header */
/* initialize internal lzw variable */
/* clear the rest */
/* fill output buffer; `count' must be <= FT_LZW_BUFFER_SIZE */
/* first, we skip what we can from the output buffer */
/* next, we skip as many bytes remaining as possible */
/* not enough bytes */
/* seeking backwards. */
/* If the new position is within the output buffer, simply       */
/* decrement pointers, otherwise we reset the stream completely! */
/* skip unwanted bytes */
/* now read the data */
/***************************************************************************/
/***************************************************************************/
/*****                                                                 *****/
/*****            L Z W   E M B E D D I N G   S T R E A M              *****/
/*****                                                                 *****/
/***************************************************************************/
/***************************************************************************/
/* finalize lzw file descriptor */
/*
/* don't know the real size! */
/* !FT_CONFIG_OPTION_USE_LZW */
/* !FT_CONFIG_OPTION_USE_LZW */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\lzw\ftzopen.c
/***************************************************************************/
/*                                                                         */
/*  ftzopen.c                                                              */
/*                                                                         */
/*    FreeType support for .Z compressed files.                            */
/*                                                                         */
/*  This optional component relies on NetBSD's zopen().  It should mainly  */
/*  be used to parse compressed PCF fonts, as found with many X11 server   */
/*  distributions.                                                         */
/*                                                                         */
/*  Copyright 2005, 2006, 2007, 2009 by David Turner.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* WHY? */
/* end of file */
/* grow the character stack */
/* grow the prefix/suffix arrays */
/* first allocation -> 9 bits */
/* don't grow too fast */
/*
/* now adjust `suffix' and move the data accordingly */
/* skip magic bytes, and read max_bits + block_flag */
/* fall-through */
/* why not LZW_FIRST-256 ? */
/* save code for later */
/* special case for KwKwKwK */
/* fall-through */
/* now create new entry */
/* state == EOF */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\otvalid\otvalid.c
/***************************************************************************/
/*                                                                         */
/*  otvalid.c                                                              */
/*                                                                         */
/*    FreeType validator for OpenType tables (body only).                  */
/*                                                                         */
/*  Copyright 2004, 2007 by                                                */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\otvalid\otvbase.c
/***************************************************************************/
/*                                                                         */
/*  otvbase.c                                                              */
/*                                                                         */
/*    OpenType BASE table validation (body).                               */
/*                                                                         */
/*  Copyright 2004, 2007 by                                                */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* skip Coordinate */
/* BaseCoordFormat1 */
/* BaseCoordFormat2 */
/* ReferenceGlyph, BaseCoordPoint */
/* BaseCoordFormat3 */
/* DeviceTable */
/* BaselineTag */
/* skip DefaultIndex */
/* BaseCoord */
/* FeatMinMaxRecord */
/* skip FeatureTableTag */
/* BaseLangSysRecord */
/* skip BaseLangSysTag */
/* BaseScriptRecord */
/* skip BaseScriptTag */
/* BaseScript */
/* BaseScriptList */
/* Version */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\otvalid\otvcommn.c
/***************************************************************************/
/*                                                                         */
/*  otvcommn.c                                                             */
/*                                                                         */
/*    OpenType common tables validation (body).                            */
/*                                                                         */
/*  Copyright 2004, 2005, 2006, 2007 by                                    */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                       COVERAGE TABLE                          *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* CoverageFormat1 */
/* GlyphArray */
/* CoverageFormat2 */
/* RangeRecord */
/* Generally, a coverage table offset has an associated count field.  */
/* The number of glyphs in the table should match this field.  If     */
/* there is no associated count, a value of -1 tells us not to check. */
/* skip CoverageFormat and Glyph/RangeCount */
/* Glyph/RangeCount */
/* Glyph/RangeCount */
/* skip StartCoverageIndex */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                   CLASS DEFINITION TABLE                      *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* ClassDefFormat1 */
/* ClassValueArray */
/* ClassDefFormat2 */
/* ClassRangeRecord */
/* skip Class */
/* no need to check glyph indices used as input to class definition   */
/* tables since even invalid glyph indices return a meaningful result */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      DEVICE TABLE                             *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* DeltaValue */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                         LOOKUPS                               *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* uses valid->type_count */
/* uses valid->type_funcs */
/* skip LookupFlag */
/* SubTable */
/* uses valid->lookup_count */
/* Lookup */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                        FEATURES                               *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* uses valid->lookup_count */
/* skip FeatureParams (unused) */
/* LookupListIndex */
/* sets valid->lookup_count */
/* FeatureRecord */
/* skip FeatureTag */
/* Feature */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                       LANGUAGE SYSTEM                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* uses valid->extra1 (number of features) */
/* skip LookupOrder (unused) */
/* FeatureIndex */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                           SCRIPTS                             *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* LangSysRecord */
/* skip LangSysTag */
/* LangSys */
/* sets valid->extra1 (number of features) */
/* ScriptRecord */
/* skip ScriptTag */
/* Script */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      UTILITY FUNCTIONS                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*
/* skip Format */
/* uses valid->extra1 (if > 0: array value limit) */
/* `ux' in the function's name is not really correct since only x-1 */
/* elements are tested                                              */
/* uses valid->extra1 (array value limit) */
/* `uy' in the function's name is not really correct since only y-1 */
/* elements are tested                                              */
/* uses valid->extra1 (array value limit) */
/* sets valid->extra1 (valid->lookup_count) */
/* skip Format */
/* uses valid->lookup_count */
/* skip Format */
/* sets valid->extra1 (valid->lookup_count)    */
/* skip Format */
/* uses valid->lookup_count */
/* skip Format */
/* LookupList */
/* LookupCount */
/* Lookup */
/* LookupFlag */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\otvalid\otvgdef.c
/***************************************************************************/
/*                                                                         */
/*  otvgdef.c                                                              */
/*                                                                         */
/*    OpenType GDEF table validation (body).                               */
/*                                                                         */
/*  Copyright 2004, 2005, 2007 by                                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      UTILITY FUNCTIONS                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets valid->extra1 (0)           */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                       LIGATURE CARETS                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* CaretValueFormat1 */
/* skip Coordinate, no test */
/* CaretValueFormat2 */
/* skip CaretValuePoint, no test */
/* CaretValueFormat3 */
/* skip Coordinate */
/* DeviceTable */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                         GDEF TABLE                            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets valid->glyph_count */
/* Version */
/* MarkAttachClassDef has been added to the OpenType */
/* specification without increasing GDEF's version,  */
/* so we use this ugly hack to find out whether the  */
/* table is needed actually.                         */
/* OpenType >= 1.2 */
/* OpenType < 1.2  */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\otvalid\otvgpos.c
/***************************************************************************/
/*                                                                         */
/*  otvgpos.c                                                              */
/*                                                                         */
/*    OpenType GPOS table validation (body).                               */
/*                                                                         */
/*  Copyright 2002, 2004, 2005, 2006, 2007, 2008 by                        */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      UTILITY FUNCTIONS                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* uses valid->extra1 (counter)                             */
/* uses valid->extra2 (boolean to handle NULL anchor field) */
/* sets valid->extra1 (class count) */
/* skip PosFormat */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                        VALUE RECORDS                          *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* uses valid->extra3 (pointer to base table) */
/* display `format' in dual representation */
/* XPlacement, YPlacement, XAdvance, YAdvance */
/* XPlaDevice, YPlaDevice, XAdvDevice, YAdvDevice */
/* XXX: this value is usually too small, especially if the current */
/* ValueRecord is part of an array -- getting the correct table    */
/* size is probably not worth the trouble                          */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                           ANCHORS                             *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* skip XCoordinate and YCoordinate */
/* AnchorPoint */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                         MARK ARRAYS                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* MarkRecord */
/* skip Class */
/* MarkAnchor */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     GPOS LOOKUP TYPE 1                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets valid->extra3 (pointer to base table) */
/* SinglePosFormat1 */
/* Value */
/* SinglePosFormat2 */
/* Value */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     GPOS LOOKUP TYPE 2                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* PairValueRecord */
/* skip SecondGlyph */
/* Value1 */
/* Value2 */
/* sets valid->extra3 (pointer to base table) */
/* PairPosFormat1 */
/* PairSetOffset */
/* PairPosFormat2 */
/* Class1Record */
/* Class2Record */
/* Value1 */
/* Value2 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     GPOS LOOKUP TYPE 3                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* CursivePosFormat1 */
/* EntryExitRecord */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     GPOS LOOKUP TYPE 4                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* UNDOCUMENTED (in OpenType 1.5):              */
/* BaseRecord tables can contain NULL pointers. */
/* sets valid->extra2 (1) */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     GPOS LOOKUP TYPE 5                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets valid->extra2 (1) */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     GPOS LOOKUP TYPE 6                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets valid->extra2 (0) */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     GPOS LOOKUP TYPE 7                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets valid->extra1 (lookup count) */
/* no need to check glyph indices/classes used as input for these */
/* context rules since even invalid glyph indices/classes return  */
/* meaningful results                                             */
/* no need to check glyph indices/classes used as input for these */
/* context rules since even invalid glyph indices/classes return  */
/* meaningful results                                             */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     GPOS LOOKUP TYPE 8                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets valid->extra1 (lookup count) */
/* no need to check glyph indices/classes used as input for these */
/* context rules since even invalid glyph indices/classes return  */
/* meaningful results                                             */
/* no need to check glyph indices/classes used as input for these */
/* context rules since even invalid glyph indices/classes return  */
/* meaningful results                                             */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     GPOS LOOKUP TYPE 9                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* uses valid->type_funcs */
/* ExtensionPosFormat1 */
/* sets valid->type_count */
/* sets valid->type_funcs */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          GPOS TABLE                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets valid->glyph_count */
/* Version */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\otvalid\otvgsub.c
/***************************************************************************/
/*                                                                         */
/*  otvgsub.c                                                              */
/*                                                                         */
/*    OpenType GSUB table validation (body).                               */
/*                                                                         */
/*  Copyright 2004, 2005, 2007 by                                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                  GSUB LOOKUP TYPE 1                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* uses valid->glyph_count */
/* SingleSubstFormat1 */
/* SingleSubstFormat2 */
/* Substitute */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                  GSUB LOOKUP TYPE 2                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets valid->extra1 (glyph count) */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    GSUB LOOKUP TYPE 3                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets valid->extra1 (glyph count) */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    GSUB LOOKUP TYPE 4                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* uses valid->glyph_count */
/* Component */
/* no need to check the Component glyph indices */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                  GSUB LOOKUP TYPE 5                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets valid->extra1 (lookup count) */
/* no need to check glyph indices/classes used as input for these */
/* context rules since even invalid glyph indices/classes return  */
/* meaningful results                                             */
/* no need to check glyph indices/classes used as input for these */
/* context rules since even invalid glyph indices/classes return  */
/* meaningful results                                             */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    GSUB LOOKUP TYPE 6                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets valid->extra1 (lookup count)            */
/* no need to check glyph indices/classes used as input for these */
/* context rules since even invalid glyph indices/classes return  */
/* meaningful results                                             */
/* no need to check glyph indices/classes used as input for these */
/* context rules since even invalid glyph indices/classes return  */
/* meaningful results                                             */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    GSUB LOOKUP TYPE 7                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* uses valid->type_funcs */
/* ExtensionSubstFormat1 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    GSUB LOOKUP TYPE 8                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* uses valid->glyph_count */
/* ReverseChainSingleSubstFormat1 */
/* Substitute */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          GSUB TABLE                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets valid->type_count  */
/* sets valid->type_funcs  */
/* sets valid->glyph_count */
/* Version */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\otvalid\otvjstf.c
/***************************************************************************/
/*                                                                         */
/*  otvjstf.c                                                              */
/*                                                                         */
/*    OpenType JSTF table validation (body).                               */
/*                                                                         */
/*  Copyright 2004, 2007 by                                                */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* uses valid->extra1 (GSUB lookup count) */
/* uses valid->extra2 (GPOS lookup count) */
/* sets valid->extra1 (counter)           */
/* XXX: check lookup types? */
/* XXX: check lookup types? */
/* sets valid->extra (glyph count)               */
/* sets valid->func1 (otv_JstfPriority_validate) */
/* JstfLangSysRecord */
/* skip JstfLangSysTag */
/* sets valid->extra1 (GSUB lookup count) */
/* sets valid->extra2 (GPOS lookup count) */
/* sets valid->glyph_count                */
/* Version */
/* JstfScriptRecord */
/* skip JstfScriptTag */
/* JstfScript */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\otvalid\otvmath.c
/***************************************************************************/
/*                                                                         */
/*  otvmath.c                                                              */
/*                                                                         */
/*    OpenType MATH table validation (body).                               */
/*                                                                         */
/*  Copyright 2007, 2008 by                                                */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  Written by George Williams.                                            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                  MATH TYPOGRAPHIC CONSTANTS                   *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* 56 constants, 51 have device tables */
/* First 4 constants have no device tables */
/* skip the value */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                   MATH ITALICS CORRECTION                     *****/
/*****                 MATH TOP ACCENT ATTACHMENT                    *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* only used if tracing is active */
/* Skip the value */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                           MATH KERNING                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* OTV_NAME_ENTER( "MathKern" );*/
/* Heights */
/* Skip the value */
/* One more Kerning value */
/* Skip the value */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                         MATH GLYPH INFO                       *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* Italic correction and Top Accent Attachment have the same format */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    MATH GLYPH CONSTRUCTION                    *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* OTV_NAME_ENTER( "GlyphAssembly" ); */
/* Skip the Italics Correction value */
/* skip the Start, End, Full, and Flags fields */
/* OTV_EXIT; */
/* OTV_NAME_ENTER( "MathGlyphConstruction" ); */
/* skip the size */
/* OTV_EXIT; */
/* Skip the MinConnectorOverlap constant */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          MATH TABLE                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* sets valid->glyph_count */
/* Version */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\otvalid\otvmod.c
/***************************************************************************/
/*                                                                         */
/*  otvmod.c                                                               */
/*                                                                         */
/*    FreeType's OpenType validation module implementation (body).         */
/*                                                                         */
/*  Copyright 2004, 2005, 2006, 2007, 2008 by                              */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*
/* load tables */
/* validate tables */
/* Can't return this as API is frozen */
/* module-specific interface */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\pcf\pcf.c
/*  pcf.c
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\pcf\pcfdrivr.c
/*  pcfdrivr.c
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* PCF_CMap */
/* PCF_CMap */
/* PCF_CMap */
/* PCF_CMap */
/* XXX: result should be changed to indicate an overflow error */
/* PCF_Face */
/* free properties */
/* close gzip/LZW stream if any */
/* PCF_Face */
/* this didn't work, try gzip support! */
/* FT_CONFIG_OPTION_USE_ZLIB */
/* this didn't work, try LZW support! */
/* FT_CONFIG_OPTION_USE_LZW */
/* !(FT_CONFIG_OPTION_USE_ZLIB || FT_CONFIG_OPTION_USE_LZW) */
/* set up charmap */
/* Uh, oh, compare first letters manually to avoid dependency
/* initial platform/encoding should indicate unset status? */
/* Select default charmap */
/* error */
/* XXX: to do: are there cases that need repadding the bitmap? */
/*
/* Apparently, the PCF driver loads all properties as signed integers!
/*
/* FT_Size_InitFunc */
/* FT_Size_DoneFunc */
/* FT_Slot_InitFunc */
/* FT_Slot_DoneFunc */
/* FT_Face_GetKerningFunc  */
/* FT_Face_AttachFunc      */
/* FT_Face_GetAdvancesFunc */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\pcf\pcfread.c
/*  pcfread.c
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* Sort tables and check for overlaps.  Because they are almost      */
/* always ordered already, an in-place bubble sort with simultaneous */
/* boundary checking seems appropriate.                              */
/* parsing normal metrics */
/* the following sets `error' but doesn't return in case of failure */
/* parsing compressed metrics */
/* same as PCF_Toc->count */
/* same as PCF_Toc->count */
/* rough estimate */
/* pad the property array                                            */
/*                                                                   */
/* clever here - nprops is the same as the number of odd-units read, */
/* as only isStringProp are odd length   (Keith Packard)             */
/*                                                                   */
/* rough estimate */
/* rough estimate */
/* XXX: PCF_Face->nmetrics is singed FT_Long, see pcf.h */
/* only used for debugging */
/* rough estimate */
/* I'm not sure about this */
/* separate elements with a space */
/* need to convert spaces to dashes for */
/* add_style_name and setwidth_name     */
/* Use the old accelerators if no BDF accelerators are in the file. */
/* metrics */
/* bitmaps */
/* encodings */
/* BDF style accelerators (i.e. bounds based on encoded glyphs) */
/* XXX: TO DO: inkmetrics and glyph_names are missing */
/* now construct the face object */
/*
/* convert from 722.7 decipoints to 72 points per inch */
/* set up charset */
/* This is done to respect the behaviour of the original */
/* PCF font driver.                                      */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\pcf\pcfutil.c
/*
/* $XFree86: xc/lib/font/util/utilbitmap.c,v 1.3 1999/08/22 08:58:58 dawes Exp $ */
/*
/* Modified for use with FreeType */
/*
/*
/*
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\pfr\pfr.c
/***************************************************************************/
/*                                                                         */
/*  pfr.c                                                                  */
/*                                                                         */
/*    FreeType PFR driver component.                                       */
/*                                                                         */
/*  Copyright 2002 by                                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\pfr\pfrcmap.c
/***************************************************************************/
/*                                                                         */
/*  pfrcmap.c                                                              */
/*                                                                         */
/*    FreeType PFR cmap handling (body).                                   */
/*                                                                         */
/*  Copyright 2002, 2007, 2009 by                                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* just for safety, check that the character entries are correctly */
/* sorted in increasing character code order                       */
/* we didn't find it, but we have a pair just above it */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\pfr\pfrdrivr.c
/***************************************************************************/
/*                                                                         */
/*  pfrdrivr.c                                                             */
/*                                                                         */
/*    FreeType PFR driver interface (body).                                */
/*                                                                         */
/*  Copyright 2002, 2003, 2004, 2006, 2008, 2010 by                        */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* PFR_Face */
/* convert from metrics to outline units when necessary */
/*
/* PFR_Face */
/* PFR_Face */
/*
/* FT_Size_InitFunc */
/* FT_Size_DoneFunc */
/* FT_Face_AttachFunc      */
/* FT_Face_GetAdvancesFunc */
/* FT_Size_RequestFunc */
/* FT_Size_SelectFunc  */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\pfr\pfrgload.c
/***************************************************************************/
/*                                                                         */
/*  pfrgload.c                                                             */
/*                                                                         */
/*    FreeType PFR glyph loader (body).                                    */
/*                                                                         */
/*  Copyright 2002, 2003, 2005, 2007, 2010 by                              */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* for macro definitions */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      PFR GLYPH BUILDER                        *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* close current contour, if any */
/* compute first and last point indices in current glyph outline */
/* if the last point falls on the same location than the first one */
/* we need to delete it                                            */
/* don't add empty contours */
/* reset glyph to start the loading of a new glyph */
/* check that we have begun a new path */
/* check that we have begun a new path */
/* close current contour if any */
/* indicate that a new contour has started */
/* check that there is space for a new contour and a new point */
/* add new start point */
/* close current contour if any */
/* merge the current glyph into the stack */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      PFR GLYPH LOADER                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* load a simple glyph */
/* test for composite glyphs */
/* re-allocate array when necessary */
/* XXX: for now we ignore the secondary stroke and edge definitions */
/*      since we don't want to support native PFR hinting           */
/*                                                                  */
/* now load a simple glyph */
/***************************************************************/
/*  read instruction                                           */
/*                                                             */
/* end glyph */
/* general line operation */
/* move to inside contour  */
/* move to outside contour */
/* horizontal line to */
/* vertical line to */
/* horizontal to vertical curve */
/* vertical to horizontal curve */
/* general curve to */
/***********************************************************/
/*  now read arguments                                     */
/*                                                         */
/* read the X argument */
/* 8-bit index */
/* 16-bit value */
/* 8-bit delta */
/* read the Y argument */
/* 8-bit index */
/* 16-bit absolute value */
/* 8-bit delta */
/* read the additional format flag for the general curve */
/* save the previous point */
/***********************************************************/
/*  finally, execute instruction                           */
/*                                                         */
/* end glyph => EXIT */
/* line operations */
/* move to inside contour  */
/* move to outside contour */
/* curve operations */
/* test error condition */
/* for (;;) */
/* load a composite/compound glyph */
/* test for composite glyphs */
/* ignore extra items when present */
/*                                 */
/* we can't rely on the FT_GlyphLoader to load sub-glyphs, because   */
/* the PFR format is dumb, using direct file offsets to point to the */
/* sub-glyphs (instead of glyph indices).  Sigh.                     */
/*                                                                   */
/* For now, we load the list of sub-glyphs into a different array    */
/* but this will prevent us from using the auto-hinter at its best   */
/* quality.                                                          */
/*                                                                   */
/* we arbitrarily limit the number of subglyphs */
/* to avoid endless recursion                   */
/* read scale when available */
/* read offset */
/* read glyph position and size now */
/* this is a compound glyph - load it */
/* now, load each individual glyph */
/* note that `glyph->subs' might have been re-allocated */
/* translate and eventually scale the new glyph points */
/* proceed to next sub-glyph */
/* load a simple glyph */
/* initialize glyph loader */
/* load the glyph, recursively when needed */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\pfr\pfrload.c
/***************************************************************************/
/*                                                                         */
/*  pfrload.c                                                              */
/*                                                                         */
/*    FreeType PFR loader (body).                                          */
/*                                                                         */
/*  Copyright 2002, 2003, 2004, 2005, 2007, 2009, 2010 by                  */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          EXTRA ITEMS                          *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          PFR HEADER                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* read header directly */
/* make a few adjustments to the header */
/* check signature and header size */
/* "PFR0" */
/* CR/LF  */
/***********************************************************************/
/***********************************************************************/
/*****                                                             *****/
/*****                    PFR LOGICAL FONTS                        *****/
/*****                                                             *****/
/***********************************************************************/
/***********************************************************************/
/* save logical font size and offset */
/* now, check the rest of the table before loading it */
/***********************************************************************/
/***********************************************************************/
/*****                                                             *****/
/*****                    PFR PHYSICAL FONTS                       *****/
/*****                                                             *****/
/***********************************************************************/
/***********************************************************************/
/* load bitmap strikes lists */
/* skip bctSize */
/* re-allocate when needed */
/* Load font ID.  This is a so-called "unique" name that is rather
/* copy font ID name, and terminate it for safety */
/* load stem snap tables */
/* load kerning pair data */
/* load first and last pairs into the item to speed up */
/* lookup later...                                     */
/* add new item to the current list */
/* empty item! */
/* Loads a name from the auxiliary data.  Since this extracts undocumented
/* check that each character is ASCII for making sure not to
/* get the standard advance for non-proportional fonts */
/* load the extra items when present */
/* In certain fonts, the auxiliary bytes contain interesting  */
/* information. These are not in the specification but can be */
/* guessed by looking at the content of a few PFR0 fonts.     */
/* this seems to correspond to the font's family name,
/* this seems to correspond to the font's style name,
/* read the blue values */
/* read the character descriptors */
/* that's it! */
/* save position of bitmap info */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\pfr\pfrobjs.c
/***************************************************************************/
/*                                                                         */
/*  pfrobjs.c                                                              */
/*                                                                         */
/*    FreeType PFR object methods (body).                                  */
/*                                                                         */
/*  Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 by            */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     FACE OBJECT METHODS                       *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* PFR_Face */
/* we don't want dangling pointers */
/* finalize the physical font record */
/* no need to finalize the logical font or the header */
/* load the header and check it */
/* check face index */
/* load the face */
/* now load the physical font descriptor */
/* now set up all root face fields */
/* if all characters point to the same gps_offset 0, we */
/* assume that the font only contains bitmaps           */
/* not scalable */
/* If no family name was found in the "undocumented" auxiliary
/* note that the style name can be NULL in certain PFR fonts,
/* now compute maximum advance width */
/* create charmap */
/* Select default charmap */
/* check whether we've loaded any kerning pairs */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    SLOT OBJECT METHOD                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* PFR_Slot */
/* PFR_Slot */
/* PFR_Slot */
/* PFR_Size */
/* try to load an embedded bitmap */
/* load the glyph outline (FT_LOAD_NO_RECURSE isn't supported) */
/* copy outline data */
/* compute the advance vector */
/* make-up vertical metrics(?) */
/* some fonts seem to be broken here! */
/* Apply the font matrix, if any.                 */
/* TODO: Test existing fonts with unusual matrix  */
/* whether we have to adjust Units per EM.        */
/* scale when needed */
/* scale outline points */
/* scale the advance */
/* compute the rest of the metrics */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      KERNING METHOD                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* PFR_Face */
/* convert glyph indices to character codes */
/* now search the list of kerning items */
/* we found an item, now parse it and find the value if any */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\pfr\pfrsbit.c
/***************************************************************************/
/*                                                                         */
/*  pfrsbit.c                                                              */
/*                                                                         */
/*    FreeType PFR bitmap loader (body).                                   */
/*                                                                         */
/*  Copyright 2002, 2003, 2006, 2009, 2010 by                              */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      PFR BIT WRITER                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* current line start                    */
/* line size in bytes                    */
/* width in pixels/bits                  */
/* number of remaining rows to scan      */
/* total number of bits to draw          */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                  BITMAP DATA DECODING                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* check that we are not outside of the table -- */
/* this is possible with broken fonts...         */
/* Not found */
/* load bitmap metrics.  "*padvance" must be set to the default value */
/* before calling this function...                                    */
/*                                                                    */
/* blank image */
/* packed bits */
/* RLE1 */
/* RLE2 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     BITMAP LOADING                            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* Look-up a bitmap strike corresponding to the current */
/* character dimensions                                 */
/* couldn't find it */
/* Now lookup the glyph's position within the file */
/* Access data directly in the frame to speed lookups */
/* Could not find a bitmap program string for this glyph */
/* get the bitmap metrics */
/* compute linear advance */
/* compute default advance, i.e., scaled advance.  This can be */
/* overridden in the bitmap header of certain glyphs.          */
/*
/* Set up glyph bitmap and metrics */
/* XXX: needs casts to fit FT_Bitmap.{width|rows|pitch} */
/* XXX: needs casts to fit FT_Glyph_Metrics.{width|height} */
/* XXX: needs casts fit FT_GlyphSlotRec.bitmap_{left|top} */
/* Allocate and read bitmap data */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\psaux\afmparse.c
/***************************************************************************/
/*                                                                         */
/*  afmparse.c                                                             */
/*                                                                         */
/*    AFM parser (body).                                                   */
/*                                                                         */
/*  Copyright 2006, 2007, 2008, 2009, 2010 by                              */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/*    AFM_Stream                                                           */
/*                                                                         */
/* The use of AFM_Stream is largely inspired by parseAFM.[ch] from t1lib.  */
/*                                                                         */
/*                                                                         */
/* this works because empty lines are ignored */
/* column separator; there is no `column' in the spec actually */
/* make stupid compiler happy */
/* read a key or value in current column */
/* read a string (i.e., read to EOL) */
/* scan to eol */
/*************************************************************************/
/*                                                                       */
/*    AFM_Parser                                                         */
/*                                                                       */
/*                                                                       */
/* all keys defined in Ch. 7-10 of 5004.AFM_Spec.pdf */
/*
/* make stupid compiler happy */
/* skip current line */
/* skip empty line */
/* skip current column */
/* skip empty column */
/* don't skip the first line during the first call */
/* is this correct? */
/* compare two kerning pairs */
/* fall through since we only support kern data */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\psaux\psaux.c
/***************************************************************************/
/*                                                                         */
/*  psaux.c                                                                */
/*                                                                         */
/*    FreeType auxiliary PostScript driver component (body only).          */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2006 by                                     */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\psaux\psauxmod.c
/***************************************************************************/
/*                                                                         */
/*  psauxmod.c                                                             */
/*                                                                         */
/*    FreeType auxiliary PostScript module implementation (body).          */
/*                                                                         */
/*  Copyright 2000-2001, 2002, 2003, 2006 by                               */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* module-specific interface */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\psaux\psconv.c
/***************************************************************************/
/*                                                                         */
/*  psconv.c                                                               */
/*                                                                         */
/*    Some convenience conversions (body).                                 */
/*                                                                         */
/*  Copyright 2006, 2008, 2009 by                                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* The following array is used by various functions to quickly convert */
/* digits (both decimal and non-decimal) into numbers.                 */
/* ASCII */
/* 0x00 */
/* no character >= 0x80 can represent a valid number */
/* 'A' == 65 */
/* EBCDIC */
/* 0x80 */
/* no character < 0x80 can represent a valid number */
/* 'A' == 193 */
/* read the decimal part */
/* read exponent, if any */
/* no break */
/* 0 */
/* we try to process two nibbles at a time to be as fast as possible */
/* 0 */
/* 0 */
/* 0 */
/* 0 */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\psaux\psobjs.c
/***************************************************************************/
/*                                                                         */
/*  psobjs.c                                                               */
/*                                                                         */
/*    Auxiliary functions for PostScript fonts (body).                     */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,   */
/*            2010 by                                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                             PS_TABLE                          *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    ps_table_new                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    Initializes a PS_Table.                                            */
/*                                                                       */
/* <InOut>                                                               */
/*    table  :: The address of the target table.                         */
/*                                                                       */
/* <Input>                                                               */
/*    count  :: The table size = the maximum number of elements.         */
/*                                                                       */
/*    memory :: The memory object to use for all subsequent              */
/*              reallocations.                                           */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* allocate new base block */
/* copy elements and shift offsets */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    ps_table_add                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    Adds an object to a PS_Table, possibly growing its memory block.   */
/*                                                                       */
/* <InOut>                                                               */
/*    table  :: The target table.                                        */
/*                                                                       */
/* <Input>                                                               */
/*    idx    :: The index of the object in the table.                    */
/*                                                                       */
/*    object :: The address of the object to copy in memory.             */
/*                                                                       */
/*    length :: The length in bytes of the source object.                */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.  An error is returned if a  */
/*    reallocation fails.                                                */
/*                                                                       */
/* grow the base block if needed */
/* increase size by 25% and round up to the nearest multiple
/* add the object to the base block and adjust offset */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    ps_table_done                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Finalizes a PS_TableRec (i.e., reallocate it to its current        */
/*    cursor).                                                           */
/*                                                                       */
/* <InOut>                                                               */
/*    table :: The target table.                                         */
/*                                                                       */
/* <Note>                                                                */
/*    This function does NOT release the heap's memory block.  It is up  */
/*    to the caller to clean it, or reference it in its own structures.  */
/*                                                                       */
/* should never fail, because rec.cursor <= rec.size */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                            T1 PARSER                          *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* first character must be already part of the comment */
/* According to the PLRM, a comment is equal to a space. */
/* first character must be `(';                               */
/* *acur is positioned at the character after the closing `)' */
/* Red Book 3rd ed., section `Literal Text Strings', p. 29:     */
/* A backslash can introduce three different types              */
/* of escape sequences:                                         */
/*   - a special escaped char like \r, \n, etc.                 */
/*   - a one-, two-, or three-digit octal number                */
/*   - none of the above in which case the backslash is ignored */
/* error (or to be ignored?) */
/* skip `special' escape */
/* skip octal escape or ignore backslash */
/* first character must be `<' */
/* All whitespace characters are ignored. */
/* first character must be the opening brace that */
/* starts the procedure                           */
/* NB: [ and ] need not match:                    */
/* `/foo {[} def' is a valid PostScript fragment, */
/* even within a Type1 font                       */
/***********************************************************************/
/*                                                                     */
/* All exported parsing routines handle leading whitespace and stop at */
/* the first character which isn't part of the just handled token.     */
/*                                                                     */
/***********************************************************************/
/* Note: PostScript allows any non-delimiting, non-whitespace        */
/*       character in a name (PS Ref Manual, 3rd ed, p31).           */
/*       PostScript delimiters are (, ), <, >, [, ], {, }, /, and %. */
/* this also skips comments */
/* self-delimiting, single-character tokens */
/* skip balanced expressions (procedures and strings) */
/* {...} */
/* (...) */
/* <...> */
/* << */
/* >> */
/* anything else */
/* *cur might be invalid (e.g., ')' or '}'), but this   */
/* is handled by the test `cur == parser->cursor' below */
/* `token' here means either something between balanced delimiters */
/* or the next token; the delimiters are not removed.              */
/* first of all, skip leading whitespace */
/************* check for literal string *****************/
/************* check for programs/array *****************/
/************* check for table/array ********************/
/* XXX: in theory we should also look for "<<"          */
/*      since this is semantically equivalent to "[";   */
/*      in practice it doesn't matter (?)               */
/* we need this to catch `[ ]' */
/* XXX: this is wrong because it does not      */
/*      skip comments, procedures, and strings */
/* we need this to catch `[XXX ]' */
/* ************ otherwise, it is any token **************/
/* NB: `tokens' can be NULL if we only want to count */
/* the number of array elements                      */
/* this also handles leading whitespace */
/* don't include outermost delimiters */
/* first character must be a delimiter or a part of a number */
/* NB: `coords' can be NULL if we just want to skip the      */
/*     array; in this case we ignore `max_coords'            */
/* check for the beginning of an array; otherwise, only one number */
/* will be read                                                    */
/* now, read the coordinates */
/* skip whitespace in front of data */
/* call PS_Conv_ToFixed() even if coords == NULL */
/* to properly parse number at `cur'             */
/* first character must be a delimiter or a part of a number */
/* NB: `values' can be NULL if we just want to skip the      */
/*     array; in this case we ignore `max_values'            */
/* Check for the beginning of an array.  Otherwise, only one number */
/* will be read.                                                    */
/* now, read the values */
/* skip whitespace in front of data */
/* call PS_Conv_ToFixed() even if coords == NULL */
/* to properly parse number at `cur'             */
/* XXX: some stupid fonts have a `Notice' or `Copyright' string     */
/*      that simply doesn't begin with an opening parenthesis, even */
/*      though they have a closing one!  E.g. "amuncial.pfb"        */
/*                                                                  */
/*      We must deal with these ill-fated cases there.  Note that   */
/*      these fonts didn't work with the old Type 1 driver as the   */
/*      notice/copyright was not recognized as a valid string token */
/*      and made the old token parser commit errors.                */
/* skip the opening parenthesis, if there is one */
/* then, count its length */
/* now copy the string */
/* 0 */
/* return 1 if we find `true', 0 otherwise */
/* load a simple field (i.e. non-table) into the current list of objects */
/* this also skips leading whitespace */
/* we must detect arrays in /FontBBox */
/* don't include delimiters */
/* if this is an array and we have no blend, an error occurs */
/* don't include delimiters */
/* fall through */
/* for 64-bit systems */
/* we allow both a string or a name   */
/* for cases like /FontName (foo) def */
/* don't include leading `/' */
/* don't include delimiting parentheses    */
/* XXX we don't handle <<...>> here        */
/* XXX should we convert octal escapes?    */
/*     if so, what encoding should we use? */
/* for this to work (FT_String**)q must have been */
/* initialized to NULL                            */
/* an error occurred */
/* obsolete -- keep for reference */
/* we store the elements count if necessary;           */
/* we further assume that `count_offset' can't be zero */
/* we now load each element, adjusting the field.offset on each one */
/* obsolete -- keep for reference */
/* first character must be `<' if `delimiters' is non-zero */
/* 0 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                            T1 BUILDER                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    t1_builder_init                                                    */
/*                                                                       */
/* <Description>                                                         */
/*    Initializes a given glyph builder.                                 */
/*                                                                       */
/* <InOut>                                                               */
/*    builder :: A pointer to the glyph builder to initialize.           */
/*                                                                       */
/* <Input>                                                               */
/*    face    :: The current face object.                                */
/*                                                                       */
/*    size    :: The current size object.                                */
/*                                                                       */
/*    glyph   :: The current glyph object.                               */
/*                                                                       */
/*    hinting :: Whether hinting should be applied.                      */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    t1_builder_done                                                    */
/*                                                                       */
/* <Description>                                                         */
/*    Finalizes a given glyph builder.  Its contents can still be used   */
/*    after the call, but the function saves important information       */
/*    within the corresponding glyph slot.                               */
/*                                                                       */
/* <Input>                                                               */
/*    builder :: A pointer to the glyph builder to finalize.             */
/*                                                                       */
/* check that there is enough space for `count' more points */
/* add a new point, do not check space */
/* check space for a new on-curve point, then add it */
/* check space for a new contour, then add it */
/* this might happen in invalid fonts */
/* if a path was begun, add its first on-curve point */
/* test whether we are building a new contour */
/* close the current contour */
/* We must not include the last point in the path if it */
/* is located on the first point.                       */
/* `delete' last point only if it coincides with the first */
/* point and it is not a control point (which can happen). */
/* Don't add contours only consisting of one point, i.e.,  */
/* check whether the first and the last point is the same. */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                            OTHER                              *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\psaux\t1cmap.c
/***************************************************************************/
/*                                                                         */
/*  t1cmap.c                                                               */
/*                                                                         */
/*    Type 1 character map support (body).                                 */
/*                                                                         */
/*  Copyright 2002, 2003, 2006, 2007 by                                    */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****          TYPE1 STANDARD (AND EXPERT) ENCODING CMAPS           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* convert character code to Adobe SID string */
/* look for the corresponding glyph name */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    TYPE1 CUSTOM ENCODING CMAP                 *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****            TYPE1 SYNTHETIC UNICODE ENCODING CMAP              *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\psaux\t1decode.c
/***************************************************************************/
/*                                                                         */
/*  t1decode.c                                                             */
/*                                                                         */
/*    PostScript Type 1 decoding routines (body).                          */
/*                                                                         */
/*  Copyright 2000-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009    */
/*            2010 by                                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* never remove this one */
/* none */
/* endchar */
/* hsbw */
/* seac */
/* sbw */
/* closepath */
/* hlineto */
/* hmoveto */
/* hvcurveto */
/* rlineto */
/* rmoveto */
/* rrcurveto */
/* vhcurveto */
/* vlineto */
/* vmoveto */
/* dotsection */
/* hstem */
/* hstem3 */
/* vstem */
/* vstem3 */
/* div */
/* callothersubr */
/* callsubr */
/* pop */
/* return */
/* setcurrentpoint */
/* opcode 15 (undocumented and obsolete) */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    t1_lookup_glyph_by_stdcharcode                                     */
/*                                                                       */
/* <Description>                                                         */
/*    Looks up a given glyph by its StandardEncoding charcode.  Used to  */
/*    implement the SEAC Type 1 operator.                                */
/*                                                                       */
/* <Input>                                                               */
/*    face     :: The current face object.                               */
/*                                                                       */
/*    charcode :: The character code to look for.                        */
/*                                                                       */
/* <Return>                                                              */
/*    A glyph index in the font face.  Returns -1 if the corresponding   */
/*    glyph wasn't found.                                                */
/*                                                                       */
/* check range of standard char code */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    t1operator_seac                                                    */
/*                                                                       */
/* <Description>                                                         */
/*    Implements the `seac' Type 1 operator for a Type 1 decoder.        */
/*                                                                       */
/* <Input>                                                               */
/*    decoder :: The current CID decoder.                                */
/*                                                                       */
/*    asb     :: The accent's side bearing.                              */
/*                                                                       */
/*    adx     :: The horizontal offset of the accent.                    */
/*                                                                       */
/*    ady     :: The vertical offset of the accent.                      */
/*                                                                       */
/*    bchar   :: The base character's StandardEncoding charcode.         */
/*                                                                       */
/*    achar   :: The accent character's StandardEncoding charcode.       */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* seac weirdness */
/* `glyph_names' is set to 0 for CID fonts which do not */
/* include an encoding.  How can we deal with these?    */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* the caller must handle the font encoding also */
/* if we are trying to load a composite glyph, do not load the */
/* accent character and return the array of subglyphs.         */
/* reallocate subglyph array if necessary */
/* subglyph 0 = base character */
/* subglyph 1 = accent character */
/* set up remaining glyph fields */
/* First load `bchar' in builder */
/* now load the unscaled outline */
/* prepare loader */
/* the seac operator must not be nested */
/* save the left bearing and width of the base character */
/* as they will be erased by the next load.              */
/* Now load `achar' on top of */
/* the base outline           */
/* the seac operator must not be nested */
/* restore the left side bearing and   */
/* advance width of the base character */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    t1_decoder_parse_charstrings                                       */
/*                                                                       */
/* <Description>                                                         */
/*    Parses a given Type 1 charstrings program.                         */
/*                                                                       */
/* <Input>                                                               */
/*    decoder         :: The current Type 1 decoder.                     */
/*                                                                       */
/*    charstring_base :: The base address of the charstring stream.      */
/*                                                                       */
/*    charstring_len  :: The length in bytes of the charstring stream.   */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* we don't want to touch the source code -- use macro trick */
/* compute random seed from stack address of parameter */
/* First of all, initialize the decoder */
/* a font that reads BuildCharArray without setting */
/* its values first is buggy, but ...               */
/* begin hints recording session, if any */
/* now, execute loop */
/*********************************************************************/
/*                                                                   */
/* Decode operator or operand                                        */
/*                                                                   */
/*                                                                   */
/* first of all, decompress operator or value */
/* undocumented, obsolete operator */
/* four bytes integer */
/* According to the specification, values > 32000 or < -32000 must */
/* be followed by a `div' operator to make the result be in the    */
/* range [-32000;32000].  We expect that the second argument of    */
/* `div' is not a large number.  Additionally, we don't handle     */
/* stuff like `<large1> <large2> <num> div <num> div' or           */
/* <large1> <large2> <num> div div'.  This is probably not allowed */
/* anyway.                                                         */
/* all operands have been transferred by previous pops */
/*********************************************************************/
/*                                                                   */
/*  Push value on stack, or process operator                         */
/*                                                                   */
/*                                                                   */
/* callothersubr */
/***********************************************************/
/*                                                         */
/* remove all operands to callothersubr from the stack     */
/*                                                         */
/* for handled othersubrs, where we know the number of     */
/* arguments, we increase the stack by the value of        */
/* known_othersubr_result_cnt                              */
/*                                                         */
/* for unhandled othersubrs the following pops adjust the  */
/* stack pointer as necessary                              */
/* XXX TODO: The checks to `arg_count == <whatever>'       */
/* might not be correct; an othersubr expects a certain    */
/* number of operands on the PostScript stack (as opposed  */
/* to the T1 stack) but it doesn't have to put them there  */
/* by itself; previous othersubrs might have left the      */
/* operands there if they were not followed by an          */
/* appropriate number of pops                              */
/*                                                         */
/* On the other hand, Adobe Reader 7.0.8 for Linux doesn't */
/* accept a font that contains charstrings like            */
/*                                                         */
/*     100 200 2 20 callothersubr                          */
/*     300 1 20 callothersubr pop                          */
/*                                                         */
/* Perhaps this is the reason why BuildCharArray exists.   */
/* start flex feature */
/* add flex vectors */
/* note that we should not add a point for index 0; */
/* this will move our current position to the flex  */
/* point without adding any point to the outline    */
/* end flex feature */
/* the two `results' are popped by the following setcurrentpoint */
/* change hints */
/* counter control hints, clear stack */
/* multiple masters */
/* we want to compute:                                   */
/*                                                       */
/*  a0*w0 + a1*w1 + ... + ak*wk                          */
/*                                                       */
/* but we only have the a0, a1-a0, a2-a0, .. ak-a0       */
/* however, given that w0 + w1 + ... + wk == 1, we can   */
/* rewrite it easily as:                                 */
/*                                                       */
/*  a0 + (a1-a0)*w1 + (a2-a0)*w2 + .. + (ak-a0)*wk       */
/*                                                       */
/* where k == num_designs-1                              */
/*                                                       */
/* I guess that's why it's written in this `compact'     */
/* form.                                                 */
/*                                                       */
/* <idx> 1 19 callothersubr                             */
/* => replace elements starting from index cvi( <idx> ) */
/*    of BuildCharArray with WeightVector               */
/* <arg1> <arg2> 2 20 callothersubr pop   */
/* ==> push <arg1> + <arg2> onto T1 stack */
/* XXX (over|under)flow */
/* <arg1> <arg2> 2 21 callothersubr pop   */
/* ==> push <arg1> - <arg2> onto T1 stack */
/* XXX (over|under)flow */
/* <arg1> <arg2> 2 22 callothersubr pop   */
/* ==> push <arg1> * <arg2> onto T1 stack */
/* <arg1> <arg2> 2 23 callothersubr pop   */
/* ==> push <arg1> / <arg2> onto T1 stack */
/* <val> <idx> 2 24 callothersubr               */
/* ==> set BuildCharArray[cvi( <idx> )] = <val> */
/* <idx> 1 25 callothersubr pop        */
/* ==> push BuildCharArray[cvi( idx )] */
/*     onto T1 stack                   */
/* <val> mark <idx> ==> set BuildCharArray[cvi( <idx> )] = <val>, */
/*                      leave mark on T1 stack                    */
/* <val> <idx>      ==> set BuildCharArray[cvi( <idx> )] = <val>  */
/* <res1> <res2> <val1> <val2> 4 27 callothersubr pop */
/* ==> push <res1> onto T1 stack if <val1> <= <val2>, */
/*     otherwise push <res2>                          */
/* 0 28 callothersubr pop                               */
/* => push random value from interval [0, 1) onto stack */
/* general operator */
/* XXX Operators usually take their operands from the        */
/*     bottom of the stack, i.e., the operands are           */
/*     decoder->stack[0], ..., decoder->stack[num_args - 1]; */
/*     only div, callsubr, and callothersubr are different.  */
/*     In practice it doesn't matter (?).                    */
/* FT_DEBUG_LEVEL_TRACE */
/* close hints recording session */
/* apply hints to the loaded glyph outline now */
/* add current outline to the glyph slot */
/* the compiler should optimize away this empty loop but ... */
/* FT_DEBUG_LEVEL_TRACE */
/* return now! */
/* the `metrics_only' indicates that we only want to compute */
/* the glyph's metrics (lsb + advance width), not load the   */
/* rest of it; so exit immediately                           */
/* the `metrics_only' indicates that we only want to compute */
/* the glyph's metrics (lsb + advance width), not load the   */
/* rest of it; so exit immediately                           */
/* if there is no path, `closepath' is a no-op */
/* if `large_int' is set, we divide unscaled numbers; */
/* otherwise, we divide numbers in 16.16 format --    */
/* in both cases, it is the same operation            */
/* save current instruction pointer */
/* The Type 1 driver stores subroutines without the seed bytes. */
/* The CID driver stores subroutines with seed bytes.  This     */
/* case is taken care of when decoder->subrs_len == 0.          */
/* We are using subroutines from a CID font.  We must adjust */
/* for the seed bytes.                                       */
/* ignore, we pushed the operands ourselves */
/* `push' the operand to callothersubr onto the stack */
/* record horizontal hint */
/* top[0] += builder->left_bearing.y; */
/* record horizontal counter-controlled hints */
/* record vertical hint */
/* record vertical counter-controlled hints */
/* From the T1 specification, section 6.4:                */
/*                                                        */
/*   The setcurrentpoint command is used only in          */
/*   conjunction with results from OtherSubrs procedures. */
/* known_othersubr_result_cnt != 0 is already handled     */
/* above.                                                 */
/* Note, however, that both Ghostscript and Adobe         */
/* Distiller handle this situation by silently ignoring   */
/* the inappropriate `setcurrentpoint' instruction.  So   */
/* we do the same.                                        */
/* nothing to do except to pop the two arguments */
/* XXX Operators usually clear the operand stack;  */
/*     only div, callsubr, callothersubr, pop, and */
/*     return are different.                       */
/*     In practice it doesn't matter (?).          */
/* general operator processing */
/* while ip < limit */
/* parse a single Type 1 glyph */
/* initialize T1 decoder */
/* retrieve PSNames interface from list of current modules */
/* decoder->buildchar and decoder->len_buildchar have to be  */
/* initialized by the caller since we cannot know the length */
/* of the BuildCharArray                                     */
/* finalize T1 decoder */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\pshinter\pshalgo.c
/***************************************************************************/
/*                                                                         */
/*  pshalgo.c                                                              */
/*                                                                         */
/*    PostScript hinting algorithm (body).                                 */
/*                                                                         */
/*  Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010   */
/*            by                                                           */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used        */
/*  modified and distributed under the terms of the FreeType project       */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* compute inflection points to optimize `S' */
/* and similar glyphs                        */
/* slightly increase the contrast of smooth  */
/* hinting                                   */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                  BASIC HINTS RECORDINGS                       *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* return true if two stem hints overlap */
/* destroy hints table */
/* deactivate all hints in a table */
/* internal function to record a new hint */
/* ignore active hints */
/* now scan the current active hint set to check */
/* whether `hint' overlaps with another hint     */
/* create hints table */
/* allocate our tables */
/* initialize the `table->hints' array */
/* we now need to determine the initial `parent' stems; first  */
/* activate the hints that are given by the initial hint masks */
/* finally, do a linear parse in case some hints were left alone */
/* now, sort the hints; they are guaranteed to not overlap */
/* so we can compare their "org_pos" field directly        */
/* a simple bubble sort will do, since in 99% of cases, the hints */
/* will be already sorted -- and the sort will be linear          */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****               HINTS GRID-FITTING AND OPTIMIZATION             *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* 0 */
/* DEBUG_HINTER */
/* ignore stem alignments when requested through the hint flags */
/* perform stem snapping when requested - this is necessary
/* check blue zones for horizontal stems */
/* the top of the stem is aligned against a blue zone */
/* the bottom of the stem is aligned against a blue zone */
/* both edges of the stem are aligned against blue zones */
/* ensure that parent is already fitted */
/* keep original relation between hints, this is, use the */
/* scaled distance between the centers of the hints to    */
/* compute the new position                               */
/* Stem adjustment tries to snap stem widths to standard
/* the stem is less than one pixel; we will center it
/* This is a special case where we also widen the stem
/* This is a very small stem; we simply align it to the
/* this is a ghost stem; we simply round it */
/* now that we have a good hinted stem width, try to position */
/* the stem along a pixel grid integer coordinate             */
/* don't touch */
/* not used for now, experimental */
/*
/* ignore stem alignments when requested through the hint flags */
/* check blue zones for horizontal stems */
/* the top of the stem is aligned against a blue zone */
/* the bottom of the stem is aligned against a blue zone */
/* both edges of the stem are aligned against blue zones */
/* ensure that parent is already fitted */
/* Stems less than one pixel wide are easy -- we want to
/* Position stems other to minimize the amount of mid-grays.
/* len > 64 */
/* We choose between B) and C) above based on the amount
/* switch */
/* 0 */
/* DEBUG_HINTER*/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                POINTS INTERPOLATION ROUTINES                  *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* DEBUG_ZONES */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    HINTER GLYPH MANAGEMENT                    *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* deal with the trivial cases quickly */
/* general case */
/* !1 */
/* compute all inflex points in a given glyph */
/* we need at least 4 points to create an inflection point */
/* compute first segment in contour */
/* extend the segment start whenever possible */
/* now, process all segments in the contour */
/* first, extend current segment's end whenever possible */
/* COMPUTE_INFLEXS */
/* |dy| <<< |dx|  means a near-horizontal segment */
/* |dx| <<< |dy|  means a near-vertical segment */
/* load outline point coordinates into hinter glyph */
/* save hinted point coordinates back to outline */
/* clear all fields */
/* allocate and setup points + contours arrays */
/* detect smooth points */
/* COMPUTE_INFLEXS */
/* now deal with hints tables */
/* compute all extrema in a glyph for a given dimension */
/* first of all, compute all local extrema */
/* local maximum */
/* before->org_u > point->org_u */
/* local minimum */
/* for  */
/* for each extremum, determine its direction along the */
/* orthogonal axis                                      */
/* major_dir is the direction for points on the bottom/left of the stem; */
/* Points on the top/right of the stem will have a direction of          */
/* -major_dir.                                                           */
/* treat extrema as special cases for stem edge alignment */
/* 1 */
/* the accepted shift for strong points in fractional pixels */
/* the maximum shift value in font units */
/* find strong points in a glyph */
/* a point is `strong' if it is located on a stem edge and       */
/* has an `in' or `out' tangent parallel to the hint's direction */
/* process secondary hints to `selected' points */
/* the `endchar' op can reduce the number of points */
/* process primary hints for all points */
/* now, certain points may have been attached to a hint and */
/* not marked as strong; update their flags then            */
/* find points in a glyph which are in a blue zone and have `in' or */
/* `out' tangents parallel to the horizontal axis                   */
/* check tangents */
/* skip strong points */
/* look up top zones */
/* look up bottom zones */
/* interpolate strong points with the help of hinted coordinates */
/* first technique: a point is strong if it is a local extremum */
/* first count the number of strong points */
/* nothing to do here */
/* allocate an array to store a list of points, */
/* stored in increasing org_u order             */
/* now try to interpolate all normal points */
/* sometimes, some local extrema are smooth points */
/* find best enclosing point coordinates then interpolate */
/* point before the first strong point */
/* point is after last strong point */
/* now interpolate point between before and after */
/* 1 */
/* interpolate other points */
/* count the number of strong points in this contour */
/* if there are less than 2 fitted points in the contour, we */
/* simply scale and eventually translate the contour points  */
/* there are more than 2 strong points in this contour; we */
/* need to interpolate weak points between them            */
/* skip consecutive fitted points */
/* find next fitted point after unfitted one */
/* now interpolate between them */
/* on the left of the interpolation zone */
/* on the right on the interpolation zone */
/* within the interpolation zone */
/* keep going until all points in the contours have been processed */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     HIGH-LEVEL INTERFACE                      *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* something to do? */
/* DEBUG_HINTER */
/* try to optimize the y_scale so that the top of non-capital letters
/* load outline coordinates into glyph */
/* compute local extrema */
/* compute aligned stem/hints positions */
/* find strong points, align them, then interpolate others */
/* save hinted coordinates back to outline */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\pshinter\pshglob.c
/***************************************************************************/
/*                                                                         */
/*  pshglob.c                                                              */
/*                                                                         */
/*    PostScript hinter global hinting management (body).                  */
/*    Inspired by the new auto-hinter module.                              */
/*                                                                         */
/*  Copyright 2001, 2002, 2003, 2004, 2006, 2010 by                        */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used        */
/*  modified and distributed under the terms of the FreeType project       */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                       STANDARD WIDTHS                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* scale the widths/heights table */
/* standard width/height */
/* org_width is is font units, result in device pixels, 26.6 format */
/* 0 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                       BLUE ZONES                              *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* read blue zone entry, and select target top/bottom zone */
/* insert into sorted table */
/* we have two zones on the same reference position -- */
/* only keep the largest one                           */
/* Re-read blue zones from the original fonts and store them into out */
/* private structure.  This function re-orders, sanitizes and         */
/* fuzz-expands the zones as well.                                    */
/* read the input blue zones, and build two sorted tables  */
/* (one for the top zones, the other for the bottom zones) */
/* first, the blues */
/* sanitize top table */
/* sanitize bottom table */
/* expand top and bottom tables with blue fuzz */
/* expand the bottom of the lowest zone normally */
/* expand the top and bottom of intermediate zones;    */
/* checking that the interval is smaller than the fuzz */
/* expand the top of the highest zone normally */
/* reset the blues table when the device transform changes */
/*                                                        */
/* Determine whether we need to suppress overshoots or    */
/* not.  We simply need to compare the vertical scale     */
/* parameter to the raw bluescale value.  Here is why:    */
/*                                                        */
/*   We need to suppress overshoots for all pointsizes.   */
/*   At 300dpi that satisfies:                            */
/*                                                        */
/*      pointsize < 240*bluescale + 0.49                  */
/*                                                        */
/*   This corresponds to:                                 */
/*                                                        */
/*      pixelsize < 1000*bluescale + 49/24                */
/*                                                        */
/*      scale*EM_Size < 1000*bluescale + 49/24            */
/*                                                        */
/*   However, for normal Type 1 fonts, EM_Size is 1000!   */
/*   We thus only check:                                  */
/*                                                        */
/*      scale < bluescale + 49/24000                      */
/*                                                        */
/*   which we shorten to                                  */
/*                                                        */
/*      "scale < bluescale"                               */
/*                                                        */
/* Note that `blue_scale' is stored 1000 times its real   */
/* value, and that `scale' converts from font units to    */
/* fractional pixels.                                     */
/*                                                        */
/* 1000 / 64 = 125 / 8 */
/*                                                        */
/*  The blue threshold is the font units distance under   */
/*  which overshoots are suppressed due to the BlueShift  */
/*  even if the scale is greater than BlueScale.          */
/*                                                        */
/*  It is the smallest distance such that                 */
/*                                                        */
/*    dist <= BlueShift && dist*scale <= 0.5 pixels       */
/*                                                        */
/* round scaled reference position */
/* process the families now */
/* try to find a family zone whose reference position is less */
/* than 1 pixel far from the current zone                     */
/* look up stem top in top zones table */
/* look up stem bottom in bottom zones table */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                        GLOBAL HINTS                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* copy standard widths */
/* copy standard heights */
/* copy blue zones */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\pshinter\pshinter.c
/***************************************************************************/
/*                                                                         */
/*  pshinter.c                                                             */
/*                                                                         */
/*    FreeType PostScript Hinting module                                   */
/*                                                                         */
/*  Copyright 2001, 2003 by                                                */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\pshinter\pshmod.c
/***************************************************************************/
/*                                                                         */
/*  pshmod.c                                                               */
/*                                                                         */
/*    FreeType PostScript hinter module implementation (body).             */
/*                                                                         */
/*  Copyright 2001, 2002, 2007 by                                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* the Postscript Hinter module structure */
/* finalize module */
/* initialize module, create hints recorder and the interface */
/* returns global hints interface */
/* return Type 1 hints interface */
/* return Type 2 hints interface */
/* module-specific interface */
/* no additional interface for now */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\pshinter\pshpic.c
/***************************************************************************/
/*                                                                         */
/*  pshpic.c                                                               */
/*                                                                         */
/*    The FreeType position independent code services for pshinter module. */
/*                                                                         */
/*  Copyright 2009, 2010 by                                                */
/*  Oran Agra and Mickey Gabel.                                            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* forward declaration of PIC init functions from pshmod.c */
/* allocate pointer, clear and set global container pointer */
/* add call to initialization function when you add new scripts */
/*Exit:*/
/* FT_CONFIG_OPTION_PIC */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\pshinter\pshrec.c
/***************************************************************************/
/*                                                                         */
/*  pshrec.c                                                               */
/*                                                                         */
/*    FreeType PostScript hints recorder (body).                           */
/*                                                                         */
/*  Copyright 2001, 2002, 2003, 2004, 2007, 2009 by                        */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      PS_HINT MANAGEMENT                       *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* destroy hints table */
/* ensure that a table can contain "count" elements */
/* try to grow the table */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      PS_MASK MANAGEMENT                       *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* destroy mask */
/* ensure that a mask can contain "count" bits */
/* test a bit value in a given mask */
/* clear a given bit */
/* set a given bit, possibly grow the mask */
/* destroy mask table */
/* ensure that a mask table can contain "count" masks */
/* allocate a new mask in a table */
/* return last hint mask in a table, create one if the table is empty */
/* set a new mask to a given bit range */
/* now, copy bits */
/* test whether two masks in a table intersect */
/* merge two masks, used by ps_mask_table_merge_all */
/* swap index1 and index2 so that index1 < index2 */
/* we need to merge the bitsets of index1 and index2 with a */
/* simple union                                             */
/* if "count2" is greater than "count1", we need to grow the */
/* first bitset, and clear the highest bits                  */
/* merge (unite) the bitsets */
/* Now, remove "mask2" from the list.  We need to keep the masks */
/* sorted in order of importance, so move table elements.        */
/* number of masks to move */
/* move to end of table for reuse */
/* Try to merge all masks in a given table.  This is used to merge */
/* all counter masks into independent counter "paths".             */
/*                                                                 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    PS_DIMENSION MANAGEMENT                    *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* finalize a given dimension */
/* initialize a given dimension */
/* set a bit at a given index in the current hint mask */
/* get last hint mask */
/* set the end point in a mask, called from "End" & "Reset" methods */
/* set the end point in the current mask, then create a new empty one */
/* (called by "Reset" method)                                         */
/* end current mask */
/* allocate new one */
/* set a new mask, called from the "T2Stem" method */
/* reset current mask, if any */
/* set bits in new mask */
/* add a new single stem (called from "T1Stem" method) */
/* detect ghost stem */
/* now, lookup stem in the current hints table */
/* we need to create a new hint in the table */
/* now, store the hint in the current mask */
/* add a "hstem3/vstem3" counter to our dimension table */
/* try to find an existing counter mask that already uses */
/* one of these stems here                                */
/* create a new counter when needed */
/* now, set the bits for our hints in the counter mask */
/* end of recording session for a given dimension */
/* end hint mask table */
/* merge all counter masks into independent "paths" */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    PS_RECORDER MANAGEMENT                     *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* destroy hints */
/* initialize a hints for a new session */
/* add one or more stems to the current hints table */
/* limit "dimension" to 0..1 */
/* record the stems in the current hints/masks table */
/* Type 1 "hstem" or "vstem" operator */
/* Type 2 "hstem" or "vstem" operator */
/* add one Type1 counter stem to the current hints table */
/* limit "dimension" to 0..1 */
/* there must be 6 elements in the 'stem' array */
/* add the three stems to our hints/masks table */
/* now, add the hints to the counters table */
/* reset hints (only with Type 1 hints) */
/* invalid hint type */
/* Type2 "hintmask" operator, add a new hintmask to each direction */
/* check bit count; must be equal to current total hint count */
/* simply ignore the operator */
/* set-up new horizontal and vertical hint mask now */
/* check bit count, must be equal to current total hint count */
/* simply ignore the operator */
/* set-up new horizontal and vertical hint mask now */
/* end recording session */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                TYPE 1 HINTS RECORDING INTERFACE               *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                TYPE 2 HINTS RECORDING INTERFACE               *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* determine number of stems to write */
/* compute integer stem positions in font units */
/* compute lengths */
/* add them to the current dimension */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\psnames\psmodule.c
/***************************************************************************/
/*                                                                         */
/*  psmodule.c                                                             */
/*                                                                         */
/*    PSNames module implementation (body).                                */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2005, 2006, 2007, 2008 by             */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* Return the Unicode value corresponding to a given glyph.  Note that */
/* we do deal with glyph variants by detecting a non-initial dot in    */
/* the name, as in `A.swash' or `e.final'; in this case, the           */
/* VARIANT_BIT is set in the return value.                             */
/*                                                                     */
/* If the name begins with `uni', then the glyph name may be a */
/* hard-coded unicode character code.                          */
/* determine whether the next four characters following are */
/* hexadecimal.                                             */
/* XXX: Add code to deal with ligatures, i.e. glyph names like */
/*      `uniXXXXYYYYZZZZ'...                                   */
/* Exit if a non-uppercase hexadecimal character was found   */
/* -- this also catches character codes below `0' since such */
/* negative numbers cast to `unsigned int' are far too big.  */
/* there must be exactly four hex digits */
/* If the name begins with `u', followed by four to six uppercase */
/* hexadecimal digits, it is a hard-coded unicode character code. */
/* Look for a non-initial dot in the glyph name in order to */
/* find variants like `A.swash', `e.final', etc.            */
/* now look up the glyph in the Adobe Glyph List */
/* ft_qsort callback to sort the unicode map */
/* sort base glyphs before glyph variants */
/* support for extra glyphs not handled (well) in AGL; */
/* we add extra mappings for them if necessary         */
/* WGL 4 */
/* Romanian */
/* mark this extra glyph as a candidate for the cmap */
/* disable this extra glyph from being added to the cmap */
/* Build a table that maps Unicode values to glyph indices. */
/* we first allocate the table */
/* This glyph name has an additional representation. */
/* Add it to the cmap.                               */
/* now compress the table a bit */
/* No unicode chars here! */
/* Reallocate if the number of used entries is much smaller. */
/* Sort the table in increasing order of unicode values, */
/* taking care of glyph variants.                        */
/* Perform a binary search on the table. */
/* remember match but continue search for base glyph */
/* we have a variant glyph */
/* we didn't find it; check whether we have a map just above it */
/* FT_CONFIG_OPTION_ADOBE_GLYPH_LIST */
/* FT_CONFIG_OPTION_ADOBE_GLYPH_LIST */
/* FT_CONFIG_OPTION_POSTSCRIPT_NAMES */
/* this is not a font driver, nor a renderer */
/* driver name                         */
/* driver version                      */
/* driver requires FreeType 2 or above */
/* module specific interface */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\psnames\psnames.c
/***************************************************************************/
/*                                                                         */
/*  psnames.c                                                              */
/*                                                                         */
/*    FreeType PSNames module component (body only).                       */
/*                                                                         */
/*  Copyright 1996-2001 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\psnames\pspic.c
/***************************************************************************/
/*                                                                         */
/*  pspic.c                                                                */
/*                                                                         */
/*    The FreeType position independent code services for psnames module.  */
/*                                                                         */
/*  Copyright 2009, 2010 by                                                */
/*  Oran Agra and Mickey Gabel.                                            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* forward declaration of PIC init functions from psmodule.c */
/* allocate pointer, clear and set global container pointer */
/* initialize pointer table - this is how the module usually expects this data */
/* FT_CONFIG_OPTION_PIC */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\raster\ftraster.c
/***************************************************************************/
/*                                                                         */
/*  ftraster.c                                                             */
/*                                                                         */
/*    The FreeType glyph rasterizer (body).                                */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2005, 2007, 2008, 2009, 2010 by       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* This file can be compiled without the rest of the FreeType engine, by */
/* defining the _STANDALONE_ macro when compiling it.  You also need to  */
/* put the files `ftimage.h' and `ftmisc.h' into the $(incdir)           */
/* directory.  Typically, you should do something like                   */
/*                                                                       */
/* - copy `src/raster/ftraster.c' (this file) to your current directory  */
/*                                                                       */
/* - copy `include/freetype/ftimage.h' and `src/raster/ftmisc.h'         */
/*   to your current directory                                           */
/*                                                                       */
/* - compile `ftraster' with the _STANDALONE_ macro defined, as in       */
/*                                                                       */
/*     cc -c -D_STANDALONE_ ftraster.c                                   */
/*                                                                       */
/* The renderer can be initialized with a call to                        */
/* `ft_standard_raster.raster_new'; a bitmap can be generated            */
/* with a call to `ft_standard_raster.raster_render'.                    */
/*                                                                       */
/* See the comments and documentation in the file `ftimage.h' for more   */
/* details on how the raster works.                                      */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* This is a rewrite of the FreeType 1.x scan-line converter             */
/*                                                                       */
/*************************************************************************/
/* for memset */
/* !_STANDALONE_ */
/* for FT_MulDiv only */
/* !_STANDALONE_ */
/*************************************************************************/
/*                                                                       */
/* A simple technical note on how the raster works                       */
/* -----------------------------------------------                       */
/*                                                                       */
/*   Converting an outline into a bitmap is achieved in several steps:   */
/*                                                                       */
/*   1 - Decomposing the outline into successive `profiles'.  Each       */
/*       profile is simply an array of scanline intersections on a given */
/*       dimension.  A profile's main attributes are                     */
/*                                                                       */
/*       o its scanline position boundaries, i.e. `Ymin' and `Ymax'      */
/*                                                                       */
/*       o an array of intersection coordinates for each scanline        */
/*         between `Ymin' and `Ymax'                                     */
/*                                                                       */
/*       o a direction, indicating whether it was built going `up' or    */
/*         `down', as this is very important for filling rules           */
/*                                                                       */
/*       o its drop-out mode                                             */
/*                                                                       */
/*   2 - Sweeping the target map's scanlines in order to compute segment */
/*       `spans' which are then filled.  Additionally, this pass         */
/*       performs drop-out control.                                      */
/*                                                                       */
/*   The outline data is parsed during step 1 only.  The profiles are    */
/*   built from the bottom of the render pool, used as a stack.  The     */
/*   following graphics shows the profile list under construction:       */
/*                                                                       */
/*     __________________________________________________________ _ _    */
/*    |         |                 |         |                 |          */
/*    | profile | coordinates for | profile | coordinates for |-->       */
/*    |    1    |  profile 1      |    2    |  profile 2      |-->       */
/*    |_________|_________________|_________|_________________|__ _ _    */
/*                                                                       */
/*    ^                                                       ^          */
/*    |                                                       |          */
/* start of render pool                                      top         */
/*                                                                       */
/*   The top of the profile stack is kept in the `top' variable.         */
/*                                                                       */
/*   As you can see, a profile record is pushed on top of the render     */
/*   pool, which is then followed by its coordinates/intersections.  If  */
/*   a change of direction is detected in the outline, a new profile is  */
/*   generated until the end of the outline.                             */
/*                                                                       */
/*   Note that when all profiles have been generated, the function       */
/*   Finalize_Profile_Table() is used to record, for each profile, its   */
/*   bottom-most scanline as well as the scanline above its upmost       */
/*   boundary.  These positions are called `y-turns' because they (sort  */
/*   of) correspond to local extrema.  They are stored in a sorted list  */
/*   built from the top of the render pool as a downwards stack:         */
/*                                                                       */
/*      _ _ _______________________________________                      */
/*                            |                    |                     */
/*                         <--| sorted list of     |                     */
/*                         <--|  extrema scanlines |                     */
/*      _ _ __________________|____________________|                     */
/*                                                                       */
/*                            ^                    ^                     */
/*                            |                    |                     */
/*                         maxBuff           sizeBuff = end of pool      */
/*                                                                       */
/*   This list is later used during the sweep phase in order to          */
/*   optimize performance (see technical note on the sweep below).       */
/*                                                                       */
/*   Of course, the raster detects whether the two stacks collide and    */
/*   handles the situation properly.                                     */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/**                                                                     **/
/**  CONFIGURATION MACROS                                               **/
/**                                                                     **/
/*************************************************************************/
/*************************************************************************/
/* define DEBUG_RASTER if you want to compile a debugging version */
/* #define DEBUG_RASTER */
/* define FT_RASTER_OPTION_ANTI_ALIASING if you want to support */
/* 5-levels anti-aliasing                                       */
/* #define FT_RASTER_OPTION_ANTI_ALIASING */
/* The size of the two-lines intermediate bitmap used */
/* for anti-aliasing, in bytes.                       */
/*************************************************************************/
/*************************************************************************/
/**                                                                     **/
/**  OTHER MACROS (do not change)                                       **/
/**                                                                     **/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* This macro is used to indicate that a function parameter is unused. */
/* Its purpose is simply to reduce compiler warnings.  Note also that  */
/* simply defining it as `(void)x' doesn't avoid warnings with certain */
/* ANSI compilers (e.g. LCC).                                          */
/* Disable the tracing mechanism for simplicity -- developers can      */
/* activate it easily by redefining these two macros.                  */
/* nothing */
/* nothing */
/* nothing */
/* nothing */
/* !_STANDALONE_ */
/* for FT_TRACE() and FT_ERROR() */
/* !_STANDALONE_ */
/* FMulDiv means `Fast MulDiv'; it is used in case where `b' is       */
/* typically a small value and the result of a*b is known to fit into */
/* 32 bits.                                                           */
/* On the other hand, SMulDiv means `Slow MulDiv', and is used typically */
/* for clipping computations.  It simply uses the FT_MulDiv() function   */
/* defined in `ftcalc.h'.                                                */
/* The rasterizer is a very general purpose component; please leave */
/* the following redefinitions there (you never know your target    */
/* environment).                                                    */
/* The maximum number of stacked Bezier curves. */
/* Setting this constant to more than 32 is a   */
/* pure waste of space.                         */
/* fractional bits of *input* coordinates */
/*************************************************************************/
/*************************************************************************/
/**                                                                     **/
/**  SIMPLE TYPE DECLARATIONS                                           **/
/**                                                                     **/
/*************************************************************************/
/*************************************************************************/
/* values for the `flags' bit field */
/* States of each line, arc, and profile */
/* current coordinate during sweep          */
/* link to next profile (various purposes)  */
/* start of profile's data in render pool   */
/* Bit 0-2: drop-out mode                   */
/* Bit 3: profile orientation (up/down)     */
/* Bit 4: is top profile?                   */
/* Bit 5: is bottom profile?                */
/* profile's height in scanlines            */
/* profile's starting scanline              */
/* number of lines to step before this      */
/* profile becomes drawable                 */
/* next profile in same contour, used       */
/* during drop-out control                  */
/* Simple record used to implement a stack of bands, required */
/* by the sub-banding mechanism                               */
/* band's minimum */
/* band's maximum */
/* void */
/* void */
/* void */
/* void */
/* !FT_STATIC_RASTER */
/* !FT_STATIC_RASTER */
/* prototypes used for sweep function dispatch */
/* NOTE: These operations are only valid on 2's complement processors */
/* The most used variables are positioned at the top of the structure. */
/* Thus, their offset can be coded with less opcodes, resulting in a   */
/* smaller executable.                                                 */
/* precision related variables         */
/* == precision_shift   for bitmaps    */
/* == precision_shift+1 for pixmaps    */
/* The profiles buffer                 */
/* Render pool size                    */
/* Profiles buffer size                */
/* Current cursor in buffer            */
/* number of Y-turns in outline        */
/* current Bezier arc pointer          */
/* target bitmap width                 */
/* target bitmap buffer                */
/* target pixmap buffer                */
/* current number of profiles          */
/* signals a fresh new profile which   */
/* `start' field must be completed     */
/* signals that the last arc ended     */
/* exactly on a scanline.  Allows      */
/* removal of doublets                 */
/* current profile                     */
/* head of linked list of profiles     */
/* contour's first profile in case     */
/* of impact                           */
/* rendering state                     */
/* description of target bit/pixmap    */
/* current offset in target bitmap     */
/* current offset in target pixmap     */
/* sweep's increment in target bitmap  */
/* current min x during gray rendering */
/* current max x during gray rendering */
/* dispatch variables */
/* current drop_out control method     */
/* indicates whether a horizontal pass */
/* should be performed to control      */
/* drop-out accurately when calling    */
/* Render_Glyph.  Note that there is   */
/* no horizontal pass during gray      */
/* rendering.                          */
/* The Bezier stack               */
/* band stack used for sub-banding     */
/* band stack top                      */
/* Intermediate table used to render the   */
/* graylevels pixmaps.                     */
/* gray_lines is a buffer holding two      */
/* monochrome scanlines                    */
/* width in bytes of one monochrome        */
/* intermediate scanline of gray_lines.    */
/* Each gray pixel takes 2 bits long there */
/* The gray_lines must hold 2 lines, thus with size */
/* in bytes of at least `gray_width*2'.             */
/* FT_RASTER_ANTI_ALIASING */
/* !FT_STATIC_RASTER */
/* !FT_STATIC_RASTER */
/* A lookup table used to quickly count set bits in four gray 2x2 */
/* cells.  The values of the table have been produced with the    */
/* following code:                                                */
/*                                                                */
/*   for ( i = 0; i < 256; i++ )                                  */
/*   {                                                            */
/*     l = 0;                                                     */
/*     j = i;                                                     */
/*                                                                */
/*     for ( c = 0; c < 4; c++ )                                  */
/*     {                                                          */
/*       l <<= 4;                                                 */
/*                                                                */
/*       if ( j & 0x80 ) l++;                                     */
/*       if ( j & 0x40 ) l++;                                     */
/*                                                                */
/*       j = ( j << 2 ) & 0xFF;                                   */
/*     }                                                          */
/*     printf( "0x%04X", l );                                     */
/*   }                                                            */
/*                                                                */
/* FT_RASTER_OPTION_ANTI_ALIASING */
/*************************************************************************/
/*************************************************************************/
/**                                                                     **/
/**  PROFILES COMPUTATION                                               **/
/**                                                                     **/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Set_High_Precision                                                 */
/*                                                                       */
/* <Description>                                                         */
/*    Set precision variables according to param flag.                   */
/*                                                                       */
/* <Input>                                                               */
/*    High :: Set to True for high precision (typically for ppem < 18),  */
/*            false otherwise.                                           */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    New_Profile                                                        */
/*                                                                       */
/* <Description>                                                         */
/*    Create a new profile in the render pool.                           */
/*                                                                       */
/* <Input>                                                               */
/*    aState    :: The state/orientation of the new profile.             */
/*                                                                       */
/*    overshoot :: Whether the profile's unrounded start position        */
/*                 differs by at least a half pixel.                     */
/*                                                                       */
/* <Return>                                                              */
/*   SUCCESS on success.  FAILURE in case of overflow or of incoherent   */
/*   profile.                                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    End_Profile                                                        */
/*                                                                       */
/* <Description>                                                         */
/*    Finalize the current profile.                                      */
/*                                                                       */
/* <Input>                                                               */
/*    overshoot :: Whether the profile's unrounded end position differs  */
/*                 by at least a half pixel.                             */
/*                                                                       */
/* <Return>                                                              */
/*    SUCCESS on success.  FAILURE in case of overflow or incoherency.   */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Insert_Y_Turn                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Insert a salient into the sorted list placed on top of the render  */
/*    pool.                                                              */
/*                                                                       */
/* <Input>                                                               */
/*    New y scanline position.                                           */
/*                                                                       */
/* <Return>                                                              */
/*    SUCCESS on success.  FAILURE in case of overflow.                  */
/*                                                                       */
/* look for first y value that is <= */
/* if it is <, simply insert it, ignore if == */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Finalize_Profile_Table                                             */
/*                                                                       */
/* <Description>                                                         */
/*    Adjust all links in the profiles list.                             */
/*                                                                       */
/* <Return>                                                              */
/*    SUCCESS on success.  FAILURE in case of overflow.                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Split_Conic                                                        */
/*                                                                       */
/* <Description>                                                         */
/*    Subdivide one conic Bezier into two joint sub-arcs in the Bezier   */
/*    stack.                                                             */
/*                                                                       */
/* <Input>                                                               */
/*    None (subdivided Bezier is taken from the top of the stack).       */
/*                                                                       */
/* <Note>                                                                */
/*    This routine is the `beef' of this component.  It is  _the_ inner  */
/*    loop that should be optimized to hell to get the best performance. */
/*                                                                       */
/* hand optimized.  gcc doesn't seem to be too good at common      */
/* expression substitution and instruction scheduling ;-)          */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Split_Cubic                                                        */
/*                                                                       */
/* <Description>                                                         */
/*    Subdivide a third-order Bezier arc into two joint sub-arcs in the  */
/*    Bezier stack.                                                      */
/*                                                                       */
/* <Note>                                                                */
/*    This routine is the `beef' of the component.  It is one of _the_   */
/*    inner loops that should be optimized like hell to get the best     */
/*    performance.                                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Line_Up                                                            */
/*                                                                       */
/* <Description>                                                         */
/*    Compute the x-coordinates of an ascending line segment and store   */
/*    them in the render pool.                                           */
/*                                                                       */
/* <Input>                                                               */
/*    x1   :: The x-coordinate of the segment's start point.             */
/*                                                                       */
/*    y1   :: The y-coordinate of the segment's start point.             */
/*                                                                       */
/*    x2   :: The x-coordinate of the segment's end point.               */
/*                                                                       */
/*    y2   :: The y-coordinate of the segment's end point.               */
/*                                                                       */
/*    miny :: A lower vertical clipping bound value.                     */
/*                                                                       */
/*    maxy :: An upper vertical clipping bound value.                    */
/*                                                                       */
/* <Return>                                                              */
/*    SUCCESS on success, FAILURE on render pool overflow.               */
/*                                                                       */
/* XXX: is `Short' sufficient? */
/* Take care: miny-y1 can be a very large value; we use     */
/*            a slow MulDiv function to avoid clipping bugs */
/* x2 += FMulDiv( Dx, maxy - y2, Dy );  UNNECESSARY */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Line_Down                                                          */
/*                                                                       */
/* <Description>                                                         */
/*    Compute the x-coordinates of an descending line segment and store  */
/*    them in the render pool.                                           */
/*                                                                       */
/* <Input>                                                               */
/*    x1   :: The x-coordinate of the segment's start point.             */
/*                                                                       */
/*    y1   :: The y-coordinate of the segment's start point.             */
/*                                                                       */
/*    x2   :: The x-coordinate of the segment's end point.               */
/*                                                                       */
/*    y2   :: The y-coordinate of the segment's end point.               */
/*                                                                       */
/*    miny :: A lower vertical clipping bound value.                     */
/*                                                                       */
/*    maxy :: An upper vertical clipping bound value.                    */
/*                                                                       */
/* <Return>                                                              */
/*    SUCCESS on success, FAILURE on render pool overflow.               */
/*                                                                       */
/* A function type describing the functions used to split Bezier arcs */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Bezier_Up                                                          */
/*                                                                       */
/* <Description>                                                         */
/*    Compute the x-coordinates of an ascending Bezier arc and store     */
/*    them in the render pool.                                           */
/*                                                                       */
/* <Input>                                                               */
/*    degree   :: The degree of the Bezier arc (either 2 or 3).          */
/*                                                                       */
/*    splitter :: The function to split Bezier arcs.                     */
/*                                                                       */
/*    miny     :: A lower vertical clipping bound value.                 */
/*                                                                       */
/*    maxy     :: An upper vertical clipping bound value.                */
/*                                                                       */
/* <Return>                                                              */
/*    SUCCESS on success, FAILURE on render pool overflow.               */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Bezier_Down                                                        */
/*                                                                       */
/* <Description>                                                         */
/*    Compute the x-coordinates of an descending Bezier arc and store    */
/*    them in the render pool.                                           */
/*                                                                       */
/* <Input>                                                               */
/*    degree   :: The degree of the Bezier arc (either 2 or 3).          */
/*                                                                       */
/*    splitter :: The function to split Bezier arcs.                     */
/*                                                                       */
/*    miny     :: A lower vertical clipping bound value.                 */
/*                                                                       */
/*    maxy     :: An upper vertical clipping bound value.                */
/*                                                                       */
/* <Return>                                                              */
/*    SUCCESS on success, FAILURE on render pool overflow.               */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Line_To                                                            */
/*                                                                       */
/* <Description>                                                         */
/*    Inject a new line segment and adjust the Profiles list.            */
/*                                                                       */
/* <Input>                                                               */
/*   x :: The x-coordinate of the segment's end point (its start point   */
/*        is stored in `lastX').                                         */
/*                                                                       */
/*   y :: The y-coordinate of the segment's end point (its start point   */
/*        is stored in `lastY').                                         */
/*                                                                       */
/* <Return>                                                              */
/*   SUCCESS on success, FAILURE on render pool overflow or incorrect    */
/*   profile.                                                            */
/*                                                                       */
/* First, detect a change of direction */
/* Then compute the lines */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Conic_To                                                           */
/*                                                                       */
/* <Description>                                                         */
/*    Inject a new conic arc and adjust the profile list.                */
/*                                                                       */
/* <Input>                                                               */
/*   cx :: The x-coordinate of the arc's new control point.              */
/*                                                                       */
/*   cy :: The y-coordinate of the arc's new control point.              */
/*                                                                       */
/*   x  :: The x-coordinate of the arc's end point (its start point is   */
/*         stored in `lastX').                                           */
/*                                                                       */
/*   y  :: The y-coordinate of the arc's end point (its start point is   */
/*         stored in `lastY').                                           */
/*                                                                       */
/* <Return>                                                              */
/*   SUCCESS on success, FAILURE on render pool overflow or incorrect    */
/*   profile.                                                            */
/*                                                                       */
/* first, categorize the Bezier arc */
/* this arc has no given direction, split it! */
/* this arc is flat, ignore it and pop it from the Bezier stack */
/* the arc is y-monotonous, either ascending or descending */
/* detect a change of direction                            */
/* finalize current profile if any */
/* create a new profile */
/* now call the appropriate routine */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Cubic_To                                                           */
/*                                                                       */
/* <Description>                                                         */
/*    Inject a new cubic arc and adjust the profile list.                */
/*                                                                       */
/* <Input>                                                               */
/*   cx1 :: The x-coordinate of the arc's first new control point.       */
/*                                                                       */
/*   cy1 :: The y-coordinate of the arc's first new control point.       */
/*                                                                       */
/*   cx2 :: The x-coordinate of the arc's second new control point.      */
/*                                                                       */
/*   cy2 :: The y-coordinate of the arc's second new control point.      */
/*                                                                       */
/*   x   :: The x-coordinate of the arc's end point (its start point is  */
/*          stored in `lastX').                                          */
/*                                                                       */
/*   y   :: The y-coordinate of the arc's end point (its start point is  */
/*          stored in `lastY').                                          */
/*                                                                       */
/* <Return>                                                              */
/*   SUCCESS on success, FAILURE on render pool overflow or incorrect    */
/*   profile.                                                            */
/*                                                                       */
/* first, categorize the Bezier arc */
/* this arc has no given direction, split it! */
/* this arc is flat, ignore it and pop it from the Bezier stack */
/* detect a change of direction */
/* finalize current profile if any */
/* compute intersections */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Decompose_Curve                                                    */
/*                                                                       */
/* <Description>                                                         */
/*    Scan the outline arrays in order to emit individual segments and   */
/*    Beziers by calling Line_To() and Bezier_To().  It handles all      */
/*    weird cases, like when the first point is off the curve, or when   */
/*    there are simply no `on' points in the contour!                    */
/*                                                                       */
/* <Input>                                                               */
/*    first   :: The index of the first point in the contour.            */
/*                                                                       */
/*    last    :: The index of the last point in the contour.             */
/*                                                                       */
/*    flipped :: If set, flip the direction of the curve.                */
/*                                                                       */
/* <Return>                                                              */
/*    SUCCESS on success, FAILURE on error.                              */
/*                                                                       */
/* current point's state           */
/* set scan mode if necessary */
/* A contour cannot start with a cubic control point! */
/* check first point to determine origin */
/* first point is conic control.  Yes, this happens. */
/* start at last point if it is on the curve */
/* if both first and last points are conic,         */
/* start at their middle and record its position    */
/* for closure                                      */
/* emit a single line_to */
/* consume conic arcs */
/* FT_CURVE_TAG_CUBIC */
/* close the contour with a line segment */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Convert_Glyph                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Convert a glyph into a series of segments and arcs and make a      */
/*    profiles list with them.                                           */
/*                                                                       */
/* <Input>                                                               */
/*    flipped :: If set, flip the direction of curve.                    */
/*                                                                       */
/* <Return>                                                              */
/*    SUCCESS on success, FAILURE if any error was encountered during    */
/*    rendering.                                                         */
/*                                                                       */
/* we must now check whether the extreme arcs join or not */
/* Note that ras.gProfile can be nil if the contour was too small */
/* to be drawn.                                                   */
/* close the `next profile in contour' linked list */
/*************************************************************************/
/*************************************************************************/
/**                                                                     **/
/**  SCAN-LINE SWEEPS AND DRAWING                                       **/
/**                                                                     **/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/*  Init_Linked                                                          */
/*                                                                       */
/*    Initializes an empty linked list.                                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/*  InsNew                                                               */
/*                                                                       */
/*    Inserts a new profile in a linked list.                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/*  DelOld                                                               */
/*                                                                       */
/*    Removes an old profile from a linked list.                         */
/*                                                                       */
/* we should never get there, unless the profile was not part of */
/* the list.                                                     */
/*************************************************************************/
/*                                                                       */
/*  Sort                                                                 */
/*                                                                       */
/*    Sorts a trace list.  In 95%, the list is already sorted.  We need  */
/*    an algorithm which is fast in this case.  Bubble sort is enough    */
/*    and simple.                                                        */
/*                                                                       */
/* First, set the new X coordinate of each profile */
/* Then sort them */
/*************************************************************************/
/*                                                                       */
/*  Vertical Sweep Procedure Set                                         */
/*                                                                       */
/*  These four routines are used during the vertical black/white sweep   */
/*  phase by the generic Draw_Sweep() function.                          */
/*                                                                       */
/*************************************************************************/
/* Drop-out control */
/* memset() is slower than the following code on many platforms. */
/* This is due to the fact that, in the vast majority of cases,  */
/* the span length in bytes is relatively small.                 */
/* Drop-out control */
/*   e2            x2                    x1           e1   */
/*                                                         */
/*                 ^                     |                 */
/*                 |                     |                 */
/*   +-------------+---------------------+------------+    */
/*                 |                     |                 */
/*                 |                     v                 */
/*                                                         */
/* pixel         contour              contour       pixel  */
/* center                                           center */
/* drop-out mode    scan conversion rules (as defined in OpenType) */
/* --------------------------------------------------------------- */
/*  0                1, 2, 3                                       */
/*  1                1, 2, 4                                       */
/*  2                1, 2                                          */
/*  3                same as mode 2                                */
/*  4                1, 2, 5                                       */
/*  5                1, 2, 6                                       */
/*  6, 7             same as mode 2                                */
/* simple drop-outs including stubs */
/* smart drop-outs including stubs */
/* simple drop-outs excluding stubs */
/* smart drop-outs excluding stubs  */
/* Drop-out Control Rules #4 and #6 */
/* The specification neither provides an exact definition */
/* of a `stub' nor gives exact rules to exclude them.     */
/*                                                        */
/* Here the constraints we use to recognize a stub.       */
/*                                                        */
/*  upper stub:                                           */
/*                                                        */
/*   - P_Left and P_Right are in the same contour         */
/*   - P_Right is the successor of P_Left in that contour */
/*   - y is the top of P_Left and P_Right                 */
/*                                                        */
/*  lower stub:                                           */
/*                                                        */
/*   - P_Left and P_Right are in the same contour         */
/*   - P_Left is the successor of P_Right in that contour */
/*   - y is the bottom of P_Left                          */
/*                                                        */
/* We draw a stub if the following constraints are met.   */
/*                                                        */
/*   - for an upper or lower stub, there is top or bottom */
/*     overshoot, respectively                            */
/*   - the covered interval is greater or equal to a half */
/*     pixel                                              */
/* upper stub test */
/* lower stub test */
/* modes 2, 3, 6, 7 */
/* no drop-out control */
/* check that the other pixel isn't set */
/***********************************************************************/
/*                                                                     */
/*  Horizontal Sweep Procedure Set                                     */
/*                                                                     */
/*  These four routines are used during the horizontal black/white     */
/*  sweep phase by the generic Draw_Sweep() function.                  */
/*                                                                     */
/***********************************************************************/
/* nothing, really */
/* During the horizontal sweep, we only take care of drop-outs */
/* e1     +       <-- pixel center */
/*        |                        */
/* x1  ---+-->    <-- contour      */
/*        |                        */
/*        |                        */
/* x2  <--+---    <-- contour      */
/*        |                        */
/*        |                        */
/* e2     +       <-- pixel center */
/* simple drop-outs including stubs */
/* smart drop-outs including stubs */
/* simple drop-outs excluding stubs */
/* smart drop-outs excluding stubs  */
/* see Vertical_Sweep_Drop for details */
/* rightmost stub test */
/* leftmost stub test */
/* modes 2, 3, 6, 7 */
/* no drop-out control */
/* check that the other pixel isn't set */
/* Nothing, really */
/*************************************************************************/
/*                                                                       */
/*  Vertical Gray Sweep Procedure Set                                    */
/*                                                                       */
/*  These two routines are used during the vertical gray-levels sweep    */
/*  phase by the generic Draw_Sweep() function.                          */
/*                                                                       */
/*  NOTES                                                                */
/*                                                                       */
/*  - The target pixmap's width *must* be a multiple of 4.               */
/*                                                                       */
/*  - You have to use the function Vertical_Sweep_Span() for the gray    */
/*    span call.                                                         */
/*                                                                       */
/*************************************************************************/
/* nothing, really */
/* During the horizontal sweep, we only take care of drop-outs */
/* simple drop-outs including stubs */
/* smart drop-outs including stubs */
/* simple drop-outs excluding stubs */
/* smart drop-outs excluding stubs  */
/* see Vertical_Sweep_Drop for details */
/* rightmost stub test */
/* leftmost stub test */
/* modes 2, 3, 6, 7 */
/* no drop-out control */
/* FT_RASTER_OPTION_ANTI_ALIASING */
/*************************************************************************/
/*                                                                       */
/*  Generic Sweep Drawing routine                                        */
/*                                                                       */
/*************************************************************************/
/* initialize empty linked lists */
/* first, compute min and max Y */
/* check the Y-turns */
/* now initialize the sweep */
/* then compute the distance of each profile from min_Y */
/* let's go */
/* check waiting list for new activations */
/* sort the drawing lists */
/* let's trace */
/* a drop-out was detected */
/* mark profile for drop-out processing */
/* handle drop-outs _after_ the span drawing --       */
/* drop-out processing has been moved out of the loop */
/* for performance tuning                             */
/* now finalize the profiles that need it */
/* for gray-scaling, flush the bitmap scanline cache */
/* -- this is useful when debugging only */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Render_Single_Pass                                                 */
/*                                                                       */
/* <Description>                                                         */
/*    Perform one sweep with sub-banding.                                */
/*                                                                       */
/* <Input>                                                               */
/*    flipped :: If set, flip the direction of the outline.              */
/*                                                                       */
/* <Return>                                                              */
/*    Renderer error code.                                               */
/*                                                                       */
/* sub-banding */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Render_Glyph                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    Render a glyph in a bitmap.  Sub-banding if needed.                */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* Vertical Sweep */
/* Horizontal Sweep */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Render_Gray_Glyph                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Render a glyph with grayscaling.  Sub-banding if needed.           */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* Vertical Sweep */
/* Horizontal Sweep */
/* !FT_RASTER_OPTION_ANTI_ALIASING */
/* !FT_RASTER_OPTION_ANTI_ALIASING */
/* set default 5-levels gray palette */
/**** RASTER OBJECT CREATION: In standalone mode, we simply use *****/
/****                         a static object.                  *****/
/* nothing */
/* !_STANDALONE_ */
/* !_STANDALONE_ */
/* set 5-levels gray palette */
/* return immediately if the outline is empty */
/* this version of the raster does not support direct rendering, sorry */
/* nothing to do */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\raster\ftrend1.c
/***************************************************************************/
/*                                                                         */
/*  ftrend1.c                                                              */
/*                                                                         */
/*    The FreeType glyph rasterizer interface (body).                      */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2005, 2006 by                         */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* initialize renderer -- init its raster */
/* set render-specific mode */
/* we simply pass it to the raster */
/* transform a given glyph image */
/* return the glyph's control box */
/* convert a slot's glyph image into a bitmap */
/* check glyph image format */
/* check rendering mode */
/* raster1 is only capable of producing monochrome bitmaps */
/* raster5 is only capable of producing 5-gray-levels bitmaps */
/* FT_CONFIG_OPTION_PIC */
/* When PIC is enabled, we cannot get to the class object      */
/* so instead we check the final character in the class name   */
/* ("raster5" or "raster1"). Yes this is a hack.               */
/* The "correct" thing to do is have different render function */
/* for each of the classes.                                    */
/* raster1 is only capable of producing monochrome bitmaps */
/* raster5 is only capable of producing 5-gray-levels bitmaps */
/* FT_CONFIG_OPTION_PIC */
/* translate the outline to the new origin if needed */
/* compute the control box, and grid fit it */
/* release old bitmap buffer */
/* allocate new one, depends on pixel format */
/* we pad to 32 bits, only for backwards compatibility with FT 1.x */
/* translate outline to render it into the bitmap */
/* set up parameters */
/* render outline into the bitmap */
/* module specific interface */
/* This renderer is _NOT_ part of the default modules; you will need */
/* to register it by hand in your application.  It should only be    */
/* used for backwards-compatibility with FT 1.x anyway.              */
/*                                                                   */
/* module specific interface */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\raster\raster.c
/***************************************************************************/
/*                                                                         */
/*  raster.c                                                               */
/*                                                                         */
/*    FreeType monochrome rasterer module component (body only).           */
/*                                                                         */
/*  Copyright 1996-2001 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\raster\rastpic.c
/***************************************************************************/
/*                                                                         */
/*  rastpic.c                                                              */
/*                                                                         */
/*    The FreeType position independent code services for raster module.   */
/*                                                                         */
/*  Copyright 2009, 2010 by                                                */
/*  Oran Agra and Mickey Gabel.                                            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* forward declaration of PIC init functions from ftraster.c */
/* since this function also serve raster5 renderer, 
/* allocate pointer, clear and set global container pointer */
/* initialize pointer table - this is how the module usually expects this data */
/*Exit:*/
/* re-route these init and free functions to the above functions */
/* FT_CONFIG_OPTION_PIC */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\sfnt\sfdriver.c
/***************************************************************************/
/*                                                                         */
/*  sfdriver.c                                                             */
/*                                                                         */
/*    High-level SFNT driver interface (body).                             */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010 by */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*
/*
/* TT_CONFIG_OPTION_POSTSCRIPT_NAMES */
/*
/* shouldn't happen, but just in case to avoid memory leaks */
/* scan the name table to see whether we have a Postscript name here, */
/* either in Macintosh or Windows platform encodings                  */
/*
/* XXX: I don't know whether this is correct, since
/* TT_CONFIG_OPTION_BDF */
/*
/*
/*
/* nothing to do in this stub */
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/* see `ttload.h' */
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/* see `ttpost.h' */
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/* since version 2.1.8 */
/* since version 2.2 */
/* see `ttsbit.h' and `sfnt.h' */
/* not a font driver or renderer */
/* driver name                            */
/* driver version 1.0                     */
/* driver requires FreeType 2.0 or higher */
/* module specific interface */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\sfnt\sfnt.c
/***************************************************************************/
/*                                                                         */
/*  sfnt.c                                                                 */
/*                                                                         */
/*    Single object library component.                                     */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006 by                   */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\sfnt\sfntpic.c
/***************************************************************************/
/*                                                                         */
/*  sfntpic.c                                                              */
/*                                                                         */
/*    The FreeType position independent code services for sfnt module.     */
/*                                                                         */
/*  Copyright 2009, 2010 by                                                */
/*  Oran Agra and Mickey Gabel.                                            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* forward declaration of PIC init functions from sfdriver.c */
/* forward declaration of PIC init functions from ttcmap.c */
/* allocate pointer, clear and set global container pointer */
/* initialize pointer table - this is how the module usually expects this data */
/* FT_CONFIG_OPTION_PIC */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\sfnt\sfobjs.c
/***************************************************************************/
/*                                                                         */
/*  sfobjs.c                                                               */
/*                                                                         */
/*    SFNT object management (base).                                       */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 by */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* convert a UTF-16 name entry to ASCII */
/* convert an Apple Roman or symbol name entry to ASCII */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_get_name                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Returns a given ENGLISH name record in ASCII.                      */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: A handle to the source face object.                      */
/*                                                                       */
/*    nameid :: The name id of the name record to return.                */
/*                                                                       */
/* <InOut>                                                               */
/*    name   :: The address of a string pointer.  NULL if no name is     */
/*              present.                                                 */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* According to the OpenType 1.3 specification, only Microsoft or  */
/* Apple platform IDs might be used in the `name' table.  The      */
/* `Unicode' platform is reserved for the `cmap' table, and the    */
/* `ISO' one is deprecated.                                        */
/*                                                                 */
/* However, the Apple TrueType specification doesn't say the same  */
/* thing and goes to suggest that all Unicode `name' table entries */
/* should be coded in UTF-16 (in big-endian format I suppose).     */
/*                                                                 */
/* there is `languageID' to check there.  We should use this */
/* field only as a last solution when nothing else is        */
/* available.                                                */
/*                                                           */
/* This is a bit special because some fonts will use either    */
/* an English language id, or a Roman encoding id, to indicate */
/* the English version of its font name.                       */
/*                                                             */
/* we only take a non-English name when there is nothing */
/* else available in the font                            */
/*                                                       */
/* some fonts contain invalid Unicode or Macintosh formatted entries; */
/* we will thus favor names encoded in Windows formats if available   */
/* (provided it is an English name)                                   */
/*                                                                    */
/* all Unicode strings are encoded using UTF-16BE */
/* Apparently, if this value is found in a name table entry, it is */
/* documented as `full Unicode repertoire'.  Experience with the   */
/* MsGothic font shipped with Windows Vista shows that this really */
/* means UTF-16 encoded names (UCS-4 values are only used within   */
/* charmaps).                                                      */
/* Fill in face->ttc_header.  If the font is not a TTC, it is */
/* synthesized into a TTC with one offset table.              */
/* now read the offsets of each font in the file */
/* for now, parameters are unused */
/* check that we have a valid TrueType file */
/* Check parameters */
/* Load tables */
/* We now support two SFNT-based bitmapped font formats.  They */
/* are recognized easily as they do not include a `glyf'       */
/* table.                                                      */
/*                                                             */
/* The first format comes from Apple, and uses a table named   */
/* `bhed' instead of `head' to store the font header (using    */
/* the same format).  It also doesn't include horizontal and   */
/* vertical metrics tables (i.e. `hhea' and `vhea' tables are  */
/* missing).                                                   */
/*                                                             */
/* The other format comes from Microsoft, and is used with     */
/* WinCE/PocketPC.  It looks like a standard TTF, except that  */
/* it doesn't contain outlines.                                */
/*                                                             */
/* do we have outlines in there? */
/* if this font doesn't contain outlines, we try to load */
/* a `bhed' table                                        */
/* load the font header (`head' table) if this isn't an Apple */
/* sbit font file                                             */
/* the following tables are often not present in embedded TrueType */
/* fonts within PDF documents, so don't check for them.            */
/* the following tables are optional in PCL fonts -- */
/* don't check for errors                            */
/* do not load the metrics headers and tables if this is an Apple */
/* sbit font file                                                 */
/* load the `hhea' and `hmtx' tables */
/* If this is an incrementally loaded font and there are */
/* overriding metrics, tolerate a missing `hmtx' table.  */
/* No `hhea' table necessary for SFNT Mac fonts. */
/* If this is an incrementally loaded font and there are */
/* overriding metrics, tolerate a missing `hhea' table.  */
/* try to load the `vhea' and `vmtx' tables */
/* the optional tables */
/* embedded bitmap support */
/* a font which contains neither bitmaps nor outlines is */
/* still valid (although rather useless in most cases);  */
/* however, you can find such stripped fonts in PDFs     */
/* consider the kerning and gasp tables as optional */
/* Bit 8 of the `fsSelection' field in the `OS/2' table denotes  */
/* a WWS-only font face.  `WWS' stands for `weight', width', and */
/* `slope', a term used by Microsoft's Windows Presentation      */
/* Foundation (WPF).  This flag has been introduced in version   */
/* 1.5 of the OpenType specification (May 2008).                 */
/* now set up root fields */
/*********************************************************************/
/*                                                                   */
/* Compute face flags.                                               */
/*                                                                   */
/* scalable outlines */
/* The sfnt driver only supports bitmap fonts natively, thus we */
/* don't set FT_FACE_FLAG_HINTER.                               */
/* SFNT file format  */
/* horizontal data   */
/* fixed width font? */
/* vertical information? */
/* kerning available ? */
/* Don't bother to load the tables unless somebody asks for them. */
/* No need to do work which will (probably) not be used.          */
/*********************************************************************/
/*                                                                   */
/* Compute style flags.                                              */
/*                                                                   */
/* We have an OS/2 table; use the `fsSelection' field.  Bit 9 */
/* indicates an oblique font face.  This flag has been        */
/* introduced in version 1.5 of the OpenType specification.   */
/* bit 9 */
/* bit 0 */
/* bit 5 */
/* this is an old Mac font, use the header field */
/*********************************************************************/
/*                                                                   */
/* Polish the charmaps.                                              */
/*                                                                   */
/*   Try to set the charmap encoding according to the platform &     */
/*   encoding ID of each charmap.                                    */
/*                                                                   */
/* ignore errors */
/* set the encoding fields */
/* set 'root->charmap' to the first Unicode encoding we find */
/*
/* assume 72dpi */
/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
/* a font with no bitmaps and no outlines is scalable; */
/* it has only empty glyphs then                       */
/*********************************************************************/
/*                                                                   */
/*  Set up metrics.                                                  */
/*                                                                   */
/* XXX What about if outline header is missing */
/*     (e.g. sfnt wrapped bitmap)?             */
/* XXX: Computing the ascender/descender/height is very different */
/*      from what the specification tells you.  Apparently, we    */
/*      must be careful because                                   */
/*                                                                */
/*      - not all fonts have an OS/2 table; in this case, we take */
/*        the values in the horizontal header.  However, these    */
/*        values very often are not reliable.                     */
/*                                                                */
/*      - otherwise, the correct typographic values are in the    */
/*        sTypoAscender, sTypoDescender & sTypoLineGap fields.    */
/*                                                                */
/*        However, certain fonts have these fields set to 0.      */
/*        Rather, they have usWinAscent & usWinDescent correctly  */
/*        set (but with different values).                        */
/*                                                                */
/*      As an example, Arial Narrow is implemented through four   */
/*      files ARIALN.TTF, ARIALNI.TTF, ARIALNB.TTF & ARIALNBI.TTF */
/*                                                                */
/*      Strangely, all fonts have the same values in their        */
/*      sTypoXXX fields, except ARIALNB which sets them to 0.     */
/*                                                                */
/*      On the other hand, they all have different                */
/*      usWinAscent/Descent values -- as a conclusion, the OS/2   */
/*      table cannot be used to compute the text height reliably! */
/*                                                                */
/* The ascender/descender/height are computed from the OS/2 table */
/* when found.  Otherwise, they're taken from the horizontal      */
/* header.                                                        */
/*                                                                */
/* if the line_gap is 0, we add an extra 15% to the text height --  */
/* this computation is based on various versions of Times New Roman */
/* 0 */
/* some fonts have the OS/2 "sTypoAscender", "sTypoDescender" & */
/* "sTypoLineGap" fields set to 0, like ARIALNB.TTF             */
/* 0 */
//www.microsoft.com/OpenType/OTSpec/post.htm -- */
/* See http://www.microsoft.com/OpenType/OTSpec/post.htm -- */
/* Adjust underline position from top edge to centre of     */
/* stroke to convert TrueType meaning to FreeType meaning.  */
/* destroy the postscript names table if it is loaded */
/* destroy the embedded bitmaps table if it is loaded */
/* freeing the embedded BDF properties */
/* freeing the kerning table */
/* freeing the collection table */
/* freeing table directory */
/* simply release the 'cmap' table frame */
/* freeing the horizontal metrics */
/* freeing the vertical ones, if any */
/* freeing the gasp table */
/* freeing the name table */
/* freeing family and style name */
/* freeing sbit size table */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\sfnt\ttbdf.c
/***************************************************************************/
/*                                                                         */
/*  ttbdf.c                                                                */
/*                                                                         */
/*    TrueType and OpenType embedded BDF properties (body).                */
/*                                                                         */
/*  Copyright 2005, 2006, 2010 by                                          */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*
/* be a bit paranoid for invalid entries here */
/* string */
/* atoms */
/* check that the content is really 0-terminated */
/* TT_CONFIG_OPTION_BDF */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\sfnt\ttcmap.c
/***************************************************************************/
/*                                                                         */
/*  ttcmap.c                                                               */
/*                                                                         */
/*    TrueType character mapping table (cmap) support (body).              */
/*                                                                         */
/*  Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 by      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* must come before FT_INTERNAL_VALIDATE_H */
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                           FORMAT 0                            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* TABLE OVERVIEW                                                        */
/* --------------                                                        */
/*                                                                       */
/*   NAME        OFFSET         TYPE          DESCRIPTION                */
/*                                                                       */
/*   format      0              USHORT        must be 0                  */
/*   length      2              USHORT        table length in bytes      */
/*   language    4              USHORT        Mac language code          */
/*   glyph_ids   6              BYTE[256]     array of glyph indices     */
/*               262                                                     */
/*                                                                       */
/* check glyph indices whenever necessary */
/* go to glyph IDs */
/* TT_CONFIG_CMAP_FORMAT_0 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          FORMAT 2                             *****/
/*****                                                               *****/
/***** This is used for certain CJK encodings that encode text in a  *****/
/***** mixed 8/16 bits encoding along the following lines:           *****/
/*****                                                               *****/
/***** * Certain byte values correspond to an 8-bit character code   *****/
/*****   (typically in the range 0..127 for ASCII compatibility).    *****/
/*****                                                               *****/
/***** * Certain byte values signal the first byte of a 2-byte       *****/
/*****   character code (but these values are also valid as the      *****/
/*****   second byte of a 2-byte character).                         *****/
/*****                                                               *****/
/***** The following charmap lookup and iteration functions all      *****/
/***** assume that the value "charcode" correspond to following:     *****/
/*****                                                               *****/
/*****   - For one byte characters, "charcode" is simply the         *****/
/*****     character code.                                           *****/
/*****                                                               *****/
/*****   - For two byte characters, "charcode" is the 2-byte         *****/
/*****     character code in big endian format.  More exactly:       *****/
/*****                                                               *****/
/*****       (charcode >> 8)    is the first byte value              *****/
/*****       (charcode & 0xFF)  is the second byte value             *****/
/*****                                                               *****/
/***** Note that not all values of "charcode" are valid according    *****/
/***** to these rules, and the function moderately check the         *****/
/***** arguments.                                                    *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* TABLE OVERVIEW                                                        */
/* --------------                                                        */
/*                                                                       */
/*   NAME        OFFSET         TYPE            DESCRIPTION              */
/*                                                                       */
/*   format      0              USHORT          must be 2                */
/*   length      2              USHORT          table length in bytes    */
/*   language    4              USHORT          Mac language code        */
/*   keys        6              USHORT[256]     sub-header keys          */
/*   subs        518            SUBHEAD[NSUBS]  sub-headers array        */
/*   glyph_ids   518+NSUB*8     USHORT[]        glyph ID array           */
/*                                                                       */
/* The `keys' table is used to map charcode high-bytes to sub-headers.   */
/* The value of `NSUBS' is the number of sub-headers defined in the      */
/* table and is computed by finding the maximum of the `keys' table.     */
/*                                                                       */
/* Note that for any n, `keys[n]' is a byte offset within the `subs'     */
/* table, i.e., it is the corresponding sub-header index multiplied      */
/* by 8.                                                                 */
/*                                                                       */
/* Each sub-header has the following format:                             */
/*                                                                       */
/*   NAME        OFFSET      TYPE            DESCRIPTION                 */
/*                                                                       */
/*   first       0           USHORT          first valid low-byte        */
/*   count       2           USHORT          number of valid low-bytes   */
/*   delta       4           SHORT           see below                   */
/*   offset      6           USHORT          see below                   */
/*                                                                       */
/* A sub-header defines, for each high-byte, the range of valid          */
/* low-bytes within the charmap.  Note that the range defined by `first' */
/* and `count' must be completely included in the interval [0..255]      */
/* according to the specification.                                       */
/*                                                                       */
/* If a character code is contained within a given sub-header, then      */
/* mapping it to a glyph index is done as follows:                       */
/*                                                                       */
/* * The value of `offset' is read.  This is a _byte_ distance from the  */
/*   location of the `offset' field itself into a slice of the           */
/*   `glyph_ids' table.  Let's call it `slice' (it is a USHORT[] too).   */
/*                                                                       */
/* * The value `slice[char.lo - first]' is read.  If it is 0, there is   */
/*   no glyph for the charcode.  Otherwise, the value of `delta' is      */
/*   added to it (modulo 65536) to form a new glyph index.               */
/*                                                                       */
/* It is up to the validation routine to check that all offsets fall     */
/* within the glyph IDs table (and not within the `subs' table itself or */
/* outside of the CMap).                                                 */
/*                                                                       */
/* skip format */
/* keys table */
/* sub-headers */
/* glyph ID array */
/* parse keys to compute sub-headers count */
/* value must be multiple of 8 */
/* parse sub-headers */
/* many Dynalab fonts have empty sub-headers */
/* check range within 0..255 */
/* check offset */
/* check glyph IDs */
/* return sub header corresponding to a given character code */
/* NULL on invalid charcode                                  */
/* keys table */
/* subheaders table */
/* an 8-bit character code -- we use subHeader 0 in this case */
/* to test whether the character code is in the charmap       */
/*                                                            */
/* jump to first sub-header */
/* check that the sub-header for this byte is 0, which */
/* indicates that it is really a valid one-byte value  */
/* Otherwise, return 0                                 */
/*                                                     */
/* a 16-bit character code */
/* jump to key entry  */
/* jump to sub-header */
/* check that the high byte isn't a valid one-byte value */
/* jump to next sub-header, i.e. higher byte value */
/* TT_CONFIG_CMAP_FORMAT_2 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                           FORMAT 4                            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* TABLE OVERVIEW                                                        */
/* --------------                                                        */
/*                                                                       */
/*   NAME          OFFSET         TYPE              DESCRIPTION          */
/*                                                                       */
/*   format        0              USHORT            must be 4            */
/*   length        2              USHORT            table length         */
/*                                                  in bytes             */
/*   language      4              USHORT            Mac language code    */
/*                                                                       */
/*   segCountX2    6              USHORT            2*NUM_SEGS           */
/*   searchRange   8              USHORT            2*(1 << LOG_SEGS)    */
/*   entrySelector 10             USHORT            LOG_SEGS             */
/*   rangeShift    12             USHORT            segCountX2 -         */
/*                                                    searchRange        */
/*                                                                       */
/*   endCount      14             USHORT[NUM_SEGS]  end charcode for     */
/*                                                  each segment; last   */
/*                                                  is 0xFFFF            */
/*                                                                       */
/*   pad           14+NUM_SEGS*2  USHORT            padding              */
/*                                                                       */
/*   startCount    16+NUM_SEGS*2  USHORT[NUM_SEGS]  first charcode for   */
/*                                                  each segment         */
/*                                                                       */
/*   idDelta       16+NUM_SEGS*4  SHORT[NUM_SEGS]   delta for each       */
/*                                                  segment              */
/*   idOffset      16+NUM_SEGS*6  SHORT[NUM_SEGS]   range offset for     */
/*                                                  each segment; can be */
/*                                                  zero                 */
/*                                                                       */
/*   glyphIds      16+NUM_SEGS*8  USHORT[]          array of glyph ID    */
/*                                                  ranges               */
/*                                                                       */
/* Character codes are modelled by a series of ordered (increasing)      */
/* intervals called segments.  Each segment has start and end codes,     */
/* provided by the `startCount' and `endCount' arrays.  Segments must    */
/* not overlap, and the last segment should always contain the value     */
/* 0xFFFF for `endCount'.                                                */
/*                                                                       */
/* The fields `searchRange', `entrySelector' and `rangeShift' are better */
/* ignored (they are traces of over-engineering in the TrueType          */
/* specification).                                                       */
/*                                                                       */
/* Each segment also has a signed `delta', as well as an optional offset */
/* within the `glyphIds' table.                                          */
/*                                                                       */
/* If a segment's idOffset is 0, the glyph index corresponding to any    */
/* charcode within the segment is obtained by adding the value of        */
/* `idDelta' directly to the charcode, modulo 65536.                     */
/*                                                                       */
/* Otherwise, a glyph index is taken from the glyph IDs sub-array for    */
/* the segment, and the value of `idDelta' is added to it.               */
/*                                                                       */
/*                                                                       */
/* Finally, note that a lot of fonts contain an invalid last segment,    */
/* where `start' and `end' are correctly set to 0xFFFF but both `delta'  */
/* and `offset' are incorrect (e.g., `opens___.ttf' which comes with     */
/* OpenOffice.org).  We need special code to deal with them correctly.   */
/*                                                                       */
/* current charcode */
/* current glyph index */
/* some fonts have an incorrect last segment; */
/* we have to catch it                        */
/* we skip empty segments */
/* search the index of the charcode next to cmap->cur_charcode; */
/* caller should call tt_cmap4_set_range with proper range      */
/* before calling this function                                 */
/*                                                              */
/* we need to find another range */
/* skip format */
/* in certain fonts, the `length' field is invalid and goes */
/* out of bound.  We try to correct this here...            */
/* read segCountX2 */
/* check that we have an even value here */
/* check the search parameters - even though we never use them */
/*                                                             */
/* check the values of `searchRange', `entrySelector', `rangeShift' */
/* must be even values */
/* `search range' is the greatest power of 2 that is <= num_segs */
/* check last segment; its end count value must be 0xFFFF */
/* this test should be performed at default validation level; */
/* unfortunately, some popular Asian fonts have overlapping   */
/* ranges in their charmaps                                   */
/*                                                            */
/* allow overlapping segments, provided their start points */
/* and end points, respectively, are in ascending order    */
/*                                                         */
/* start of glyph ID array */
/* check that we point within the glyph IDs table only */
/* Some fonts handle the last segment incorrectly.  In */
/* theory, 0xFFFF might point to an ordinary glyph --  */
/* a cmap 4 is versatile and could be used for any     */
/* encoding, not only Unicode.  However, reality shows */
/* that far too many fonts are sloppy and incorrectly  */
/* set all fields but `start' and `end' for the last   */
/* segment if it contains only a single character.     */
/*                                                     */
/* We thus omit the test here, delaying it to the      */
/* routines which actually access the cmap.            */
/* check glyph indices within the segment range */
/* some fonts (erroneously?) use a range offset of 0xFFFF */
/* to mean missing glyph in cmap table                    */
/*                                                        */
/* linear search */
/* ends table   */
/* starts table */
/* some fonts have an incorrect last segment; */
/* we have to catch it                        */
/* make compiler happy */
/* binary search */
/* some fonts have an incorrect last segment; */
/* we have to catch it                        */
/* search the first segment containing `charcode' */
/* call the current segment `max' */
/* search in segments before the current segment */
/* no luck */
/* search in segments after the current segment */
/* still no luck */
/* end, start, delta, and offset are for the i'th segment */
/* if `charcode' is not in any segment, then `mid' is */
/* the segment nearest to `charcode'                  */
/*                                                    */
/* no need to search */
/* TT_CONFIG_CMAP_FORMAT_4 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          FORMAT 6                             *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* TABLE OVERVIEW                                                        */
/* --------------                                                        */
/*                                                                       */
/*   NAME        OFFSET          TYPE             DESCRIPTION            */
/*                                                                       */
/*   format       0              USHORT           must be 4              */
/*   length       2              USHORT           table length in bytes  */
/*   language     4              USHORT           Mac language code      */
/*                                                                       */
/*   first        6              USHORT           first segment code     */
/*   count        8              USHORT           segment size in chars  */
/*   glyphIds     10             USHORT[count]    glyph IDs              */
/*                                                                       */
/* A very simplified segment mapping.                                    */
/*                                                                       */
/* skip language and start index */
/* check glyph indices */
/* TT_CONFIG_CMAP_FORMAT_6 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          FORMAT 8                             *****/
/*****                                                               *****/
/***** It is hard to completely understand what the OpenType spec    *****/
/***** says about this format, but here is my conclusion.            *****/
/*****                                                               *****/
/***** The purpose of this format is to easily map UTF-16 text to    *****/
/***** glyph indices.  Basically, the `char_code' must be in one of  *****/
/***** the following formats:                                        *****/
/*****                                                               *****/
/*****   - A 16-bit value that isn't part of the Unicode Surrogates  *****/
/*****     Area (i.e. U+D800-U+DFFF).                                *****/
/*****                                                               *****/
/*****   - A 32-bit value, made of two surrogate values, i.e.. if    *****/
/*****     `char_code = (char_hi << 16) | char_lo', then both        *****/
/*****     `char_hi' and `char_lo' must be in the Surrogates Area.   *****/
/*****      Area.                                                    *****/
/*****                                                               *****/
/***** The `is32' table embedded in the charmap indicates whether a  *****/
/***** given 16-bit value is in the surrogates area or not.          *****/
/*****                                                               *****/
/***** So, for any given `char_code', we can assert the following:   *****/
/*****                                                               *****/
/*****   If `char_hi == 0' then we must have `is32[char_lo] == 0'.   *****/
/*****                                                               *****/
/*****   If `char_hi != 0' then we must have both                    *****/
/*****   `is32[char_hi] != 0' and `is32[char_lo] != 0'.              *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* TABLE OVERVIEW                                                        */
/* --------------                                                        */
/*                                                                       */
/*   NAME        OFFSET         TYPE        DESCRIPTION                  */
/*                                                                       */
/*   format      0              USHORT      must be 8                    */
/*   reserved    2              USHORT      reserved                     */
/*   length      4              ULONG       length in bytes              */
/*   language    8              ULONG       Mac language code            */
/*   is32        12             BYTE[8192]  32-bitness bitmap            */
/*   count       8204           ULONG       number of groups             */
/*                                                                       */
/* This header is followed by `count' groups of the following format:    */
/*                                                                       */
/*   start       0              ULONG       first charcode               */
/*   end         4              ULONG       last charcode                */
/*   startId     8              ULONG       start glyph ID for the group */
/*                                                                       */
/* skip `is32' array */
/* check groups, they must be in increasing order */
/* start_hi != 0; check that is32[i] is 1 for each i in */
/* the `hi' and `lo' of the range [start..end]          */
/* start_hi == 0; check that is32[i] is 0 for each i in */
/* the range [start..end]                               */
/* end_hi cannot be != 0! */
/* TT_CONFIG_CMAP_FORMAT_8 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          FORMAT 10                            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* TABLE OVERVIEW                                                        */
/* --------------                                                        */
/*                                                                       */
/*   NAME      OFFSET  TYPE               DESCRIPTION                    */
/*                                                                       */
/*   format     0      USHORT             must be 10                     */
/*   reserved   2      USHORT             reserved                       */
/*   length     4      ULONG              length in bytes                */
/*   language   8      ULONG              Mac language code              */
/*                                                                       */
/*   start     12      ULONG              first char in range            */
/*   count     16      ULONG              number of chars in range       */
/*   glyphIds  20      USHORT[count]      glyph indices covered          */
/*                                                                       */
/* check glyph indices */
/* TT_CONFIG_CMAP_FORMAT_10 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          FORMAT 12                            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* TABLE OVERVIEW                                                        */
/* --------------                                                        */
/*                                                                       */
/*   NAME        OFFSET     TYPE       DESCRIPTION                       */
/*                                                                       */
/*   format      0          USHORT     must be 12                        */
/*   reserved    2          USHORT     reserved                          */
/*   length      4          ULONG      length in bytes                   */
/*   language    8          ULONG      Mac language code                 */
/*   count       12         ULONG      number of groups                  */
/*               16                                                      */
/*                                                                       */
/* This header is followed by `count' groups of the following format:    */
/*                                                                       */
/*   start       0          ULONG      first charcode                    */
/*   end         4          ULONG      last charcode                     */
/*   startId     8          ULONG      start glyph ID for the group      */
/*                                                                       */
/* check groups, they must be in increasing order */
/* search the index of the charcode next to cmap->cur_charcode */
/* cmap->cur_group should be set up properly by caller         */
/*                                                             */
/* make compiler happy */
/* binary search */
/* if `char_code' is not in any group, then `mid' is */
/* the group nearest to `char_code'                  */
/*                                                   */
/* no need to search */
/* XXX: check cur_charcode overflow is expected */
/* XXX: check gindex overflow is expected */
/* TT_CONFIG_CMAP_FORMAT_12 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                          FORMAT 13                            *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* TABLE OVERVIEW                                                        */
/* --------------                                                        */
/*                                                                       */
/*   NAME        OFFSET     TYPE       DESCRIPTION                       */
/*                                                                       */
/*   format      0          USHORT     must be 13                        */
/*   reserved    2          USHORT     reserved                          */
/*   length      4          ULONG      length in bytes                   */
/*   language    8          ULONG      Mac language code                 */
/*   count       12         ULONG      number of groups                  */
/*               16                                                      */
/*                                                                       */
/* This header is followed by `count' groups of the following format:    */
/*                                                                       */
/*   start       0          ULONG      first charcode                    */
/*   end         4          ULONG      last charcode                     */
/*   glyphId     8          ULONG      glyph ID for the whole group      */
/*                                                                       */
/* check groups, they must be in increasing order */
/* search the index of the charcode next to cmap->cur_charcode */
/* cmap->cur_group should be set up properly by caller         */
/*                                                             */
/* make compiler happy */
/* binary search */
/* if `char_code' is not in any group, then `mid' is */
/* the group nearest to `char_code'                  */
/*                                                   */
/* no need to search */
/* TT_CONFIG_CMAP_FORMAT_13 */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                           FORMAT 14                           *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* TABLE OVERVIEW                                                        */
/* --------------                                                        */
/*                                                                       */
/*   NAME         OFFSET  TYPE    DESCRIPTION                            */
/*                                                                       */
/*   format         0     USHORT  must be 14                             */
/*   length         2     ULONG   table length in bytes                  */
/*   numSelector    6     ULONG   number of variation sel. records       */
/*                                                                       */
/* Followed by numSelector records, each of which looks like             */
/*                                                                       */
/*   varSelector    0     UINT24  Unicode codepoint of sel.              */
/*   defaultOff     3     ULONG   offset to a default UVS table          */
/*                                describing any variants to be found in */
/*                                the normal Unicode subtable.           */
/*   nonDefOff      7     ULONG   offset to a non-default UVS table      */
/*                                describing any variants not in the     */
/*                                standard cmap, with GIDs here          */
/* (either offset may be 0 NULL)                                         */
/*                                                                       */
/* Selectors are sorted by code point.                                   */
/*                                                                       */
/* A default Unicode Variation Selector (UVS) subtable is just a list of */
/* ranges of code points which are to be found in the standard cmap.  No */
/* glyph IDs (GIDs) here.                                                */
/*                                                                       */
/*   numRanges      0     ULONG   number of ranges following             */
/*                                                                       */
/* A range looks like                                                    */
/*                                                                       */
/*   uniStart       0     UINT24  code point of the first character in   */
/*                                this range                             */
/*   additionalCnt  3     UBYTE   count of additional characters in this */
/*                                range (zero means a range of a single  */
/*                                character)                             */
/*                                                                       */
/* Ranges are sorted by `uniStart'.                                      */
/*                                                                       */
/* A non-default Unicode Variation Selector (UVS) subtable is a list of  */
/* mappings from codepoint to GID.                                       */
/*                                                                       */
/*   numMappings    0     ULONG   number of mappings                     */
/*                                                                       */
/* A range looks like                                                    */
/*                                                                       */
/*   uniStart       0     UINT24  code point of the first character in   */
/*                                this range                             */
/*   GID            3     USHORT  and its GID                            */
/*                                                                       */
/* Ranges are sorted by `uniStart'.                                      */
/* This array is used to store the results of various
/* check selectors, they must be in increasing order */
/* we start lastVarSel at 1 because a variant selector value of 0
/* check the default table (these glyphs should be reached     */
/* through the normal Unicode cmap, no GIDs, just check order) */
/* end of Unicode */
/* and the non-default table (these glyphs are specified here) */
/* end of Unicode */
/* This can't happen */
/* This can't happen */
/* subtable 14 does not define a language field */
/* binary search */
/* binary search */
/* binary search */
/* This is the default variant of this charcode.  GID not stored */
/* here; stored in the normal Unicode charmap instead.           */
/* point to the first `cnt' field */
/* Both a default and a non-default glyph set?  That's probably not */
/* good font design, but the spec allows for it...                  */
/* If it is within the default range then ignore it -- */
/* that should not have happened                       */
/* If we get here then we have run out of all default ranges.   */
/* We have read one non-default mapping which we haven't stored */
/* and there may be others that need to be read.                */
/* If we get here then we have run out of all non-default     */
/* mappings.  We have read one default range which we haven't */
/* stored and there may be others that need to be read.       */
/* Format 14 extension functions */
/* TT_CONFIG_CMAP_FORMAT_14 */
/*FT_CONFIG_OPTION_PIC*/
/* allocate enough space for both the pointers +terminator and the class instances */
/* the location of the class instances follows the array of pointers */
/*FT_CONFIG_OPTION_PIC*/
/* parse the `cmap' table and build the corresponding TT_CMap objects */
/* in the current face                                                */
/*                                                                    */
/* only recognize format 0 */
/* will be filled later */
/* validate this cmap sub-table */
/* It might make sense to store the single variation selector */
/* cmap somewhere special.  But it would have to be in the    */
/* public FT_FaceRec, and we can't change that.               */
/* it is simpler to directly set `flags' than adding */
/* a parameter to FT_CMap_New                        */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\sfnt\ttkern.c
/***************************************************************************/
/*                                                                         */
/*  ttkern.c                                                               */
/*                                                                         */
/*    Load the basic TrueType kerning table.  This doesn't handle          */
/*    kerning data within the GPOS table at the moment.                    */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010 by */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* the kern table is optional; exit silently if it is missing */
/* the case of a malformed table */
/* skip version */
/* we only support up to 32 sub-tables */
/* skip version */
/* handle broken table */
/* only use horizontal kerning tables */
/* handle broken count */
/*
/* handle broken table */
/* handle broken count  */
/* binary search */
/* linear search */
/*
/* override or add */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\sfnt\ttload.c
/***************************************************************************/
/*                                                                         */
/*  ttload.c                                                               */
/*                                                                         */
/*    Load the basic TrueType tables, i.e., tables that can be either in   */
/*    TTF or OTF fonts (body).                                             */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,   */
/*            2010 by                                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_lookup_table                                               */
/*                                                                       */
/* <Description>                                                         */
/*    Looks for a TrueType table by name.                                */
/*                                                                       */
/* <Input>                                                               */
/*    face :: A face object handle.                                      */
/*                                                                       */
/*    tag  :: The searched tag.                                          */
/*                                                                       */
/* <Return>                                                              */
/*    A pointer to the table directory entry.  0 if not found.           */
/*                                                                       */
/* For compatibility with Windows, we consider    */
/* zero-length tables the same as missing tables. */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_goto_table                                                 */
/*                                                                       */
/* <Description>                                                         */
/*    Looks for a TrueType table by name, then seek a stream to it.      */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: A face object handle.                                    */
/*                                                                       */
/*    tag    :: The searched tag.                                        */
/*                                                                       */
/*    stream :: The stream to seek when the table is found.              */
/*                                                                       */
/* <Output>                                                              */
/*    length :: The length of the table if found, undefined otherwise.   */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* Here, we                                                         */
/*                                                                  */
/* - check that `num_tables' is valid (and adjust it if necessary)  */
/*                                                                  */
/* - look for a `head' table, check its size, and parse it to check */
/*   whether its `magic' field is correctly set                     */
/*                                                                  */
/* - errors (except errors returned by stream handling)             */
/*                                                                  */
/*     SFNT_Err_Unknown_File_Format:                                */
/*       no table is defined in directory, it is not sfnt-wrapped   */
/*       data                                                       */
/*     SFNT_Err_Table_Missing:                                      */
/*       table directory is valid, but essential tables             */
/*       (head/bhed/SING) are missing                               */
/*                                                                  */
/* we ignore invalid tables */
/*
/* if `sing' and `meta' tables are present, there is no `head' table */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_font_dir                                              */
/*                                                                       */
/* <Description>                                                         */
/*    Loads the header of a SFNT font file.                              */
/*                                                                       */
/* <Input>                                                               */
/*    face       :: A handle to the target face object.                  */
/*                                                                       */
/*    stream     :: The input stream.                                    */
/*                                                                       */
/* <Output>                                                              */
/*    sfnt       :: The SFNT header.                                     */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* <Note>                                                                */
/*    The stream cursor must be at the beginning of the font directory.  */
/*                                                                       */
/* read the offset table */
/* many fonts don't have these fields set correctly */
/* load the table directory */
/* check first */
/* ignore invalid tables */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_any                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Loads any font table into client memory.                           */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: The face object to look for.                             */
/*                                                                       */
/*    tag    :: The tag of table to load.  Use the value 0 if you want   */
/*              to access the whole font file, else set this parameter   */
/*              to a valid TrueType table tag that you can forge with    */
/*              the MAKE_TT_TAG macro.                                   */
/*                                                                       */
/*    offset :: The starting offset in the table (or the file if         */
/*              tag == 0).                                               */
/*                                                                       */
/*    length :: The address of the decision variable:                    */
/*                                                                       */
/*                If length == NULL:                                     */
/*                  Loads the whole table.  Returns an error if          */
/*                  `offset' == 0!                                       */
/*                                                                       */
/*                If *length == 0:                                       */
/*                  Exits immediately; returning the length of the given */
/*                  table or of the font file, depending on the value of */
/*                  `tag'.                                               */
/*                                                                       */
/*                If *length != 0:                                       */
/*                  Loads the next `length' bytes of table or font,      */
/*                  starting at offset `offset' (in table or font too).  */
/*                                                                       */
/* <Output>                                                              */
/*    buffer :: The address of target buffer.                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* look for tag in font directory */
/* tag == 0 -- the user wants to access the font file directly */
/* the `if' is syntactic sugar for picky compilers */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_generic_header                                        */
/*                                                                       */
/* <Description>                                                         */
/*    Loads the TrueType table `head' or `bhed'.                         */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/*    stream :: The input stream.                                        */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_max_profile                                           */
/*                                                                       */
/* <Description>                                                         */
/*    Loads the maximum profile into a face object.                      */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/*    stream :: The input stream.                                        */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* XXX: an adjustment that is necessary to load certain */
/*      broken fonts like `Keystrokes MT' :-(           */
/*                                                      */
/*   We allocate 64 function entries by default when    */
/*   the maxFunctionDefs field is null.                 */
/* we add 4 phantom points later */
/* we arbitrarily limit recursion to avoid stack exhaustion */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_names                                                 */
/*                                                                       */
/* <Description>                                                         */
/*    Loads the name records.                                            */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/*    stream :: The input stream.                                        */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* no FT_FRAME_START */
/* Some popular Asian fonts have an invalid `storageOffset' value   */
/* (it should be at least "6 + 12*num_names").  However, the string */
/* offsets, computed as "storageOffset + entry->stringOffset", are  */
/* valid pointers within the name table...                          */
/*                                                                  */
/* We thus can't check `storageOffset' right now.                   */
/*                                                                  */
/* Allocate the array of name records. */
/* Load the name records and determine how much storage is needed */
/* to hold the strings themselves.                                */
/* check that the name is not empty */
/* check that the name string is within the table */
/* invalid entry - ignore it */
/* everything went well, update face->num_names */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_free_names                                                 */
/*                                                                       */
/* <Description>                                                         */
/*    Frees the name records.                                            */
/*                                                                       */
/* <Input>                                                               */
/*    face :: A handle to the target face object.                        */
/*                                                                       */
/* free strings table */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_cmap                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Loads the cmap directory in a face object.  The cmaps themselves   */
/*    are loaded on demand in the `ttcmap.c' module.                     */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/*    stream :: A handle to the input stream.                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_os2                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Loads the OS2 table.                                               */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/*    stream :: A handle to the input stream.                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* We now support old Mac fonts where the OS/2 table doesn't  */
/* exist.  Simply put, we set the `version' field to 0xFFFF   */
/* and test this value each time we need to access the table. */
/* only version 1 tables */
/* only version 2 tables */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_postscript                                            */
/*                                                                       */
/* <Description>                                                         */
/*    Loads the Postscript table.                                        */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/*    stream :: A handle to the input stream.                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* we don't load the glyph names, we do that in another */
/* module (ttpost).                                     */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_pclt                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Loads the PCL 5 Table.                                             */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/*    stream :: A handle to the input stream.                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* optional table */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_gasp                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Loads the `gasp' table into a face object.                         */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/*    stream :: The input stream.                                        */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* the gasp table is optional */
/* only support versions 0 and 1 of the table */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\sfnt\ttmtx.c
/***************************************************************************/
/*                                                                         */
/*  ttmtx.c                                                                */
/*                                                                         */
/*    Load the metrics tables common to TTF and OTF fonts (body).          */
/*                                                                         */
/*  Copyright 2006, 2007, 2008, 2009 by                                    */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_hmtx                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Load the `hmtx' or `vmtx' table into a face object.                */
/*                                                                       */
/* <Input>                                                               */
/*    face     :: A handle to the target face object.                    */
/*                                                                       */
/*    stream   :: The input stream.                                      */
/*                                                                       */
/*    vertical :: A boolean flag.  If set, load `vmtx'.                  */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* !FT_CONFIG_OPTION_OLD_INTERNALS */
/* never trust derived values */
/* Adobe simply ignores this problem.  So we shall do the same. */
/* do we have an inconsistent number of metric values? */
/* We fill up the missing left side bearings with the     */
/* last valid value.  Since this will occur for buggy CJK */
/* fonts usually only, nothing serious will happen.       */
/* !FT_CONFIG_OPTION_OLD_INTERNALS */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_hhea                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Load the `hhea' or 'vhea' table into a face object.                */
/*                                                                       */
/* <Input>                                                               */
/*    face     :: A handle to the target face object.                    */
/*                                                                       */
/*    stream   :: The input stream.                                      */
/*                                                                       */
/*    vertical :: A boolean flag.  If set, load `vhea'.                  */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_get_metrics                                                */
/*                                                                       */
/* <Description>                                                         */
/*    Returns the horizontal or vertical metrics in font units for a     */
/*    given glyph.  The metrics are the left side bearing (resp. top     */
/*    side bearing) and advance width (resp. advance height).            */
/*                                                                       */
/* <Input>                                                               */
/*    header  :: A pointer to either the horizontal or vertical metrics  */
/*               structure.                                              */
/*                                                                       */
/*    idx     :: The glyph index.                                        */
/*                                                                       */
/* <Output>                                                              */
/*    bearing :: The bearing, either left side or top side.              */
/*                                                                       */
/*    advance :: The advance width resp. advance height.                 */
/*                                                                       */
/* !FT_CONFIG_OPTION_OLD_INTERNALS */
/* !FT_CONFIG_OPTION_OLD_INTERNALS */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\sfnt\ttpost.c
/***************************************************************************/
/*                                                                         */
/*  ttpost.c                                                               */
/*                                                                         */
/*    Postcript name table processing for TrueType and OpenType fonts      */
/*    (body).                                                              */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2006, 2007, 2008, 2009 by             */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The post table is not completely loaded by the core engine.  This     */
/* file loads the missing PS glyph names and implements an API to access */
/* them.                                                                 */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* If this configuration macro is defined, we rely on the `PSNames' */
/* module to grab the glyph names.                                  */
/* FT_CONFIG_OPTION_POSTSCRIPT_NAMES */
/* Otherwise, we ignore the `PSNames' module, and provide our own  */
/* table of Mac names.  Thus, it is possible to build a version of */
/* FreeType without the Type 1 driver & PSNames module.            */
/* the 258 default Mac PS glyph names */
/*   0 */
/*  10 */
/*  20 */
/*  30 */
/*  40 */
/*  50 */
/*  60 */
/*  70 */
/*  80 */
/*  90 */
/* 100 */
/* 110 */
/* 120 */
/* 130 */
/* 140 */
/* 150 */
/* 160 */
/* 170 */
/* 180 */
/* 190 */
/* 200 */
/* 210 */
/* 220 */
/* 230 */
/* 240 */
/* 250 */
/* FT_CONFIG_OPTION_POSTSCRIPT_NAMES */
/* UNDOCUMENTED!  The number of glyphs in this table can be smaller */
/* than the value in the maxp table (cf. cyberbit.ttf).             */
/* There already exist fonts which have more than 32768 glyph names */
/* in this table, so the test for this threshold has been dropped.  */
/* load the indices */
/* compute number of names stored in table */
/* now load the name strings */
/* all right, set table fields and exit successfully */
/* UNDOCUMENTED!  This value appears only in the Apple TT specs. */
/* check the number of glyphs */
/* now check the offset table */
/* OK, set table fields and exit successfully */
/* get a stream for the face's resource */
/* seek to the beginning of the PS names table */
/* go to beginning of subtable */
/* now read postscript table */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_get_ps_name                                                */
/*                                                                       */
/* <Description>                                                         */
/*    Get the PostScript glyph name of a glyph.                          */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: A handle to the parent face.                             */
/*                                                                       */
/*    idx    :: The glyph index.                                         */
/*                                                                       */
/* <InOut>                                                               */
/*    PSname :: The address of a string pointer.  Will be NULL in case   */
/*              of error, otherwise it is a pointer to the glyph name.   */
/*                                                                       */
/*              You must not modify the returned string!                 */
/*                                                                       */
/* <Output>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* `.notdef' by default */
/* paranoid checking */
/* paranoid checking */
/* nothing to do for format == 0x00030000L */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\sfnt\ttsbit.c
/***************************************************************************/
/*                                                                         */
/*  ttsbit.c                                                               */
/*                                                                         */
/*    TrueType and OpenType embedded bitmap support (body).                */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,   */
/*            2010 by                                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    blit_sbit                                                          */
/*                                                                       */
/* <Description>                                                         */
/*    Blits a bitmap from an input stream into a given target.  Supports */
/*    x and y offsets as well as byte padded lines.                      */
/*                                                                       */
/* <Input>                                                               */
/*    target      :: The target bitmap/pixmap.                           */
/*                                                                       */
/*    source      :: The input packed bitmap data.                       */
/*                                                                       */
/*    line_bits   :: The number of bits per line.                        */
/*                                                                       */
/*    byte_padded :: A flag which is true if lines are byte-padded.      */
/*                                                                       */
/*    x_offset    :: The horizontal offset.                              */
/*                                                                       */
/*    y_offset    :: The vertical offset.                                */
/*                                                                       */
/* <Note>                                                                */
/*    IMPORTANT: The x and y offsets are relative to the top corner of   */
/*               the target bitmap (unlike the normal TrueType           */
/*               convention).  A positive y offset indicates a downwards */
/*               direction!                                              */
/*                                                                       */
/* first of all, compute starting write position */
/***********************************************************************/
/*                                                                     */
/* We use the extra-classic `accumulator' trick to extract the bits    */
/* from the source byte stream.                                        */
/*                                                                     */
/* Namely, the variable `acc' is a 16-bit accumulator containing the   */
/* last `loaded' bits from the input stream.  The bits are shifted to  */
/* the upmost position in `acc'.                                       */
/*                                                                     */
/***********************************************************************/
/* clear accumulator   */
/* no bits were loaded */
/* current write cursor          */
/* # of bits to extract per line */
/* current write shift  */
/* first of all, read individual source bytes */
/* ensure that there are at least 8 bits in the accumulator */
/* now write one byte */
/* remove bits from accumulator */
/* restore `count' to correct value */
/* now write remaining bits (count < 8) */
/* ensure that there are at least `count' bits in the accumulator */
/* now write remaining bits */
/* now, skip to next line */
/* clear accumulator on byte-padded lines */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Load_SBit_Const_Metrics                                            */
/*                                                                       */
/* <Description>                                                         */
/*    Loads the metrics for `EBLC' index tables format 2 and 5.          */
/*                                                                       */
/* <Input>                                                               */
/*    range  :: The target range.                                        */
/*                                                                       */
/*    stream :: The input stream.                                        */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Load_SBit_Range_Codes                                              */
/*                                                                       */
/* <Description>                                                         */
/*    Loads the range codes for `EBLC' index tables format 4 and 5.      */
/*                                                                       */
/* <Input>                                                               */
/*    range        :: The target range.                                  */
/*                                                                       */
/*    stream       :: The input stream.                                  */
/*                                                                       */
/*    load_offsets :: A flag whether to load the glyph offset table.     */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* Allocate glyph offsets table if needed */
/* Allocate glyph codes table and access frame */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Load_SBit_Range                                                    */
/*                                                                       */
/* <Description>                                                         */
/*    Loads a given `EBLC' index/range table.                            */
/*                                                                       */
/* <Input>                                                               */
/*    range  :: The target range.                                        */
/*                                                                       */
/*    stream :: The input stream.                                        */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* variable metrics with 4-byte offsets */
/* variable metrics with 2-byte offsets */
/* XXX: BEWARE - see spec */
/* all glyphs have identical metrics */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_eblc                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Loads the table of embedded bitmap sizes for this face.            */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: The target face object.                                  */
/*                                                                       */
/*    stream :: The input stream.                                        */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* no FT_FRAME_START */
/* no FT_FRAME_START */
/* no FT_FRAME_START */
/* this table is optional */
/* check version number and strike count */
/* allocate the strikes table */
/* now read each strike table separately */
/* allocate the index ranges for each strike table */
/* read each range */
/* Now, read each index table */
/* Read the header */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_free_eblc                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Releases the embedded bitmap tables.                               */
/*                                                                       */
/* <Input>                                                               */
/*    face :: The target face object.                                    */
/*                                                                       */
/* release the glyph offsets and codes tables */
/* where appropriate                          */
/* XXX: Is this correct? */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    find_sbit_range                                                    */
/*                                                                       */
/* <Description>                                                         */
/*    Scans a given strike's ranges and return, for a given glyph        */
/*    index, the corresponding sbit range, and `EBDT' offset.            */
/*                                                                       */
/* <Input>                                                               */
/*    glyph_index   :: The glyph index.                                  */
/*                                                                       */
/*    strike        :: The source/current sbit strike.                   */
/*                                                                       */
/* <Output>                                                              */
/*    arange        :: The sbit range containing the glyph index.        */
/*                                                                       */
/*    aglyph_offset :: The offset of the glyph data in `EBDT' table.     */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means the glyph index was found.           */
/*                                                                       */
/* check whether the glyph index is within this strike's */
/* glyph range                                           */
/* scan all ranges in strike */
/* fall-through */
/* return successfully! */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_find_sbit_image                                                 */
/*                                                                       */
/* <Description>                                                         */
/*    Checks whether an embedded bitmap (an `sbit') exists for a given   */
/*    glyph, at a given strike.                                          */
/*                                                                       */
/* <Input>                                                               */
/*    face          :: The target face object.                           */
/*                                                                       */
/*    glyph_index   :: The glyph index.                                  */
/*                                                                       */
/*    strike_index  :: The current strike index.                         */
/*                                                                       */
/* <Output>                                                              */
/*    arange        :: The SBit range containing the glyph index.        */
/*                                                                       */
/*    astrike       :: The SBit strike containing the glyph index.       */
/*                                                                       */
/*    aglyph_offset :: The offset of the glyph data in `EBDT' table.     */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.  Returns                    */
/*    SFNT_Err_Invalid_Argument if no sbit exists for the requested      */
/*    glyph.                                                             */
/*                                                                       */
/* no embedded bitmap for this glyph in face */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_load_sbit_metrics                                               */
/*                                                                       */
/* <Description>                                                         */
/*    Gets the big metrics for a given SBit.                             */
/*                                                                       */
/* <Input>                                                               */
/*    stream      :: The input stream.                                   */
/*                                                                       */
/*    range       :: The SBit range containing the glyph.                */
/*                                                                       */
/* <Output>                                                              */
/*    big_metrics :: A big SBit metrics structure for the glyph.         */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* <Note>                                                                */
/*    The stream cursor must be positioned at the glyph's offset within  */
/*    the `EBDT' table before the call.                                  */
/*                                                                       */
/*    If the image format uses variable metrics, the stream cursor is    */
/*    positioned just after the metrics header in the `EBDT' table on    */
/*    function exit.                                                     */
/*                                                                       */
/* variable small metrics */
/* read small metrics */
/* convert it to a big metrics */
/* these metrics are made up at a higher level when */
/* needed.                                          */
/* variable big metrics */
/* constant metrics */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    crop_bitmap                                                        */
/*                                                                       */
/* <Description>                                                         */
/*    Crops a bitmap to its tightest bounding box, and adjusts its       */
/*    metrics.                                                           */
/*                                                                       */
/* <InOut>                                                               */
/*    map     :: The bitmap.                                             */
/*                                                                       */
/*    metrics :: The corresponding metrics structure.                    */
/*                                                                       */
/***********************************************************************/
/*                                                                     */
/* In this situation, some bounding boxes of embedded bitmaps are too  */
/* large.  We need to crop it to a reasonable size.                    */
/*                                                                     */
/*      ---------                                                      */
/*      |       |                -----                                 */
/*      |  ***  |                |***|                                 */
/*      |   *   |                | * |                                 */
/*      |   *   |    ------>     | * |                                 */
/*      |   *   |                | * |                                 */
/*      |   *   |                | * |                                 */
/*      |  ***  |                |***|                                 */
/*      ---------                -----                                 */
/*                                                                     */
/***********************************************************************/
/***********************************************************************/
/*                                                                     */
/* first of all, check the top-most lines of the bitmap, and remove    */
/* them if they're empty.                                              */
/*                                                                     */
/* the current line was empty - skip to next one */
/* check that we have at least one filled line */
/* now, crop the empty upper lines */
/***********************************************************************/
/*                                                                     */
/* second, crop the lower lines                                        */
/*                                                                     */
/* the current line was empty - skip to previous one */
/***********************************************************************/
/*                                                                     */
/* third, get rid of the space on the left side of the glyph           */
/*                                                                     */
/* shift the whole glyph one pixel to the left */
/***********************************************************************/
/*                                                                     */
/* finally, crop the bitmap width to get rid of the space on the right */
/* side of the glyph.                                                  */
/*                                                                     */
/* crop the whole glyph to the right */
/* all right, the bitmap was cropped */
/* check that the source bitmap fits into the target pixmap */
/* compute size of glyph image */
/* byte-padded formats */
/* invalid format */
/* Now read data and draw glyph into target pixmap       */
/* don't forget to multiply `x_offset' by `map->pix_bits' as */
/* the sbit blitter doesn't make a difference between pixmap */
/* depths.                                                   */
/* place stream at beginning of glyph data and read metrics */
/* This function is recursive.  At the top-level call, we  */
/* compute the dimensions of the higher-level glyph to     */
/* allocate the final pixmap buffer.                       */
/* check that there is no empty image */
/* exit successfully! */
/* single sbit image - load it */
/* compound format */
/* fallthrough */
/* invalid image format */
/* All right, we have a compound format.  First of all, read */
/* the array of elements.                                    */
/* Now recursively load each element glyph */
/* find the range for this element */
/* now load the element, recursively */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_sbit_image                                            */
/*                                                                       */
/* <Description>                                                         */
/*    Loads a given glyph sbit image from the font resource.  This also  */
/*    returns its metrics.                                               */
/*                                                                       */
/* <Input>                                                               */
/*    face         :: The target face object.                            */
/*                                                                       */
/*    strike_index :: The current strike index.                          */
/*                                                                       */
/*    glyph_index  :: The current glyph index.                           */
/*                                                                       */
/*    load_flags   :: The glyph load flags (the code checks for the flag */
/*                    FT_LOAD_CROP_BITMAP).                              */
/*                                                                       */
/*    stream       :: The input stream.                                  */
/*                                                                       */
/* <Output>                                                              */
/*    map          :: The target pixmap.                                 */
/*                                                                       */
/*    metrics      :: A big sbit metrics structure for the glyph image.  */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.  Returns an error if no     */
/*    glyph sbit exists for the index.                                   */
/*                                                                       */
/*  <Note>                                                               */
/*    The `map.buffer' field is always freed before the glyph is loaded. */
/*                                                                       */
/* Check whether there is a glyph sbit for the current index */
/* now, find the location of the `EBDT' table in */
/* the font file                                 */
/* setup vertical metrics if needed */
/* in case of a horizontal strike only */
/* some heuristic values */
/* Crop the bitmap now, unless specified otherwise */
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\sfnt\ttsbit0.c
/***************************************************************************/
/*                                                                         */
/*  ttsbit0.c                                                              */
/*                                                                         */
/*    TrueType and OpenType embedded bitmap support (body).                */
/*    This is a heap-optimized version.                                    */
/*                                                                         */
/*  Copyright 2005, 2006, 2007, 2008, 2009 by                              */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* This file is included by ttsbit.c */
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* this table is optional */
/*
/* hori.ascender  */
/* hori.descender */
/* XXX: Is this correct? */
/* min_origin_SB  */
/* max_width      */
/* min_advance_SB */
/* now find the strike corresponding to the index */
/* check that there is no empty image */
/* exit successfully! */
/* forward declaration */
/* check that we can write the glyph into the bitmap */
/* now do the blit */
/* the easy one */
/* x_pos > 0 */
/* all bits read and there are `x_pos + w' bits to be written */
/*
/* check that we can write the glyph into the bitmap */
/* now do the blit */
/* adjust `line' to point to the first byte of the bitmap */
/* the higher byte of `rval' is used as a buffer */
/* handle initial byte (in target bitmap) specially if necessary */
/* handle medial bytes */
/* handle final byte if necessary */
/* NB: a recursive call */
/* seek into the EBDT table now */
/* read the data, depending on the glyph format */
/* skip padding */
/* fall-through */
/*
/* ignore index offset */
/* overflow check */
/* now find the glyph's location and extend within the ebdt table */
/* 4-byte offsets relative to `image_offset' */
/* missing glyph */
/* big metrics, constant image size */
/* 2-byte offsets relative to 'image_offset' */
/* missing glyph */
/* sparse glyph array with (glyph,offset) pairs */
/* overflow check */
/* constant metrics with sparse glyph codes */
/* overflow check */
/* EOF */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\smooth\ftgrays.c
/***************************************************************************/
/*                                                                         */
/*  ftgrays.c                                                              */
/*                                                                         */
/*    A new `perfect' anti-aliasing renderer (body).                       */
/*                                                                         */
/*  Copyright 2000-2001, 2002, 2003, 2005, 2006, 2007, 2008, 2009, 2010 by */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* This file can be compiled without the rest of the FreeType engine, by */
/* defining the _STANDALONE_ macro when compiling it.  You also need to  */
/* put the files `ftgrays.h' and `ftimage.h' into the current            */
/* compilation directory.  Typically, you could do something like        */
/*                                                                       */
/* - copy `src/smooth/ftgrays.c' (this file) to your current directory   */
/*                                                                       */
/* - copy `include/freetype/ftimage.h' and `src/smooth/ftgrays.h' to the */
/*   same directory                                                      */
/*                                                                       */
/* - compile `ftgrays' with the _STANDALONE_ macro defined, as in        */
/*                                                                       */
/*     cc -c -D_STANDALONE_ ftgrays.c                                    */
/*                                                                       */
/* The renderer can be initialized with a call to                        */
/* `ft_gray_raster.raster_new'; an anti-aliased bitmap can be generated  */
/* with a call to `ft_gray_raster.raster_render'.                        */
/*                                                                       */
/* See the comments and documentation in the file `ftimage.h' for more   */
/* details on how the raster works.                                      */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* This is a new anti-aliasing scan-converter for FreeType 2.  The       */
/* algorithm used here is _very_ different from the one in the standard  */
/* `ftraster' module.  Actually, `ftgrays' computes the _exact_          */
/* coverage of the outline on each pixel cell.                           */
/*                                                                       */
/* It is based on ideas that I initially found in Raph Levien's          */
//www.levien.com/libart   */
/* excellent LibArt graphics library (see http://www.levien.com/libart   */
/* for more information, though the web pages do not tell anything       */
/* about the renderer; you'll have to dive into the source code to       */
/* understand how it works).                                             */
/*                                                                       */
/* Note, however, that this is a _very_ different implementation         */
/* compared to Raph's.  Coverage information is stored in a very         */
/* different way, and I don't use sorted vector paths.  Also, it doesn't */
/* use floating point values.                                            */
/*                                                                       */
/* This renderer has the following advantages:                           */
/*                                                                       */
/* - It doesn't need an intermediate bitmap.  Instead, one can supply a  */
/*   callback function that will be called by the renderer to draw gray  */
/*   spans on any target surface.  You can thus do direct composition on */
/*   any kind of bitmap, provided that you give the renderer the right   */
/*   callback.                                                           */
/*                                                                       */
/* - A perfect anti-aliaser, i.e., it computes the _exact_ coverage on   */
/*   each pixel cell.                                                    */
/*                                                                       */
/* - It performs a single pass on the outline (the `standard' FT2        */
/*   renderer makes two passes).                                         */
/*                                                                       */
/* - It can easily be modified to render to _any_ number of gray levels  */
/*   cheaply.                                                            */
/*                                                                       */
/* - For small (< 20) pixel sizes, it is faster than the standard        */
/*   renderer.                                                           */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* define this to dump debugging information */
/* #define FT_DEBUG_LEVEL_TRACE */
/* This macro is used to indicate that a function parameter is unused. */
/* Its purpose is simply to reduce compiler warnings.  Note also that  */
/* simply defining it as `(void)x' doesn't avoid warnings with certain */
/* ANSI compilers (e.g. LCC).                                          */
/* we only use level 5 & 7 tracing messages; cf. ftdebug.h */
/* we don't handle tracing levels in stand-alone mode; */
/* !FT_DEBUG_LEVEL_TRACE */
/* nothing */
/* nothing */
/* nothing */
/* !FT_DEBUG_LEVEL_TRACE */
/* !_STANDALONE_ */
/* !_STANDALONE_ */
/* as usual, for the speed hungry :-) */
/* FT_STATIC_RASTER */
/* empty */
/* empty */
/* empty */
/* empty */
/* FT_STATIC_RASTER */
/* must be at least 6 bits! */
/*************************************************************************/
/*                                                                       */
/*   TYPE DEFINITIONS                                                    */
/*                                                                       */
/* don't change the following types to FT_Int or FT_Pos, since we might */
/* need to define them to "float" or "double" when experimenting with   */
/* new algorithms                                                       */
/* integer scanline/pixel coordinate */
/* sub-pixel coordinate              */
/* determine the type used to store cell areas.  This normally takes at */
/* least PIXEL_BITS*2 + 1 bits.  On 16-bit systems, we need to use      */
/* `long' instead of `int', otherwise bad things happen                 */
/* PIXEL_BITS >= 8 */
/* approximately determine the size of integers using an ANSI-C header */
/* PIXEL_BITS >= 8 */
/* maximal number of gray spans in a call to the span callback */
/* same with TWorker.ex */
/* same with TWorker.cover */
/*************************************************************************/
/*                                                                       */
/* Initialize the cells table.                                           */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* Compute the outline bounding box.                                     */
/*                                                                       */
/* truncate the bounding box to integer pixels */
/*************************************************************************/
/*                                                                       */
/* Record the current cell in the table.                                 */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* Set the current cell to a new position.                               */
/*                                                                       */
/* Move the cell pointer to a new position.  We set the `invalid'      */
/* flag to indicate that the cell isn't part of those we're interested */
/* in during the render phase.  This means that:                       */
/*                                                                     */
/* . the new vertical position must be within min_ey..max_ey-1.        */
/* . the new horizontal position must be strictly less than max_ex     */
/*                                                                     */
/* Note that if a cell is to the left of the clipping region, it is    */
/* actually set to the (min_ex-1) horizontal position.                 */
/* All cells that are on the left of the clipping region go to the */
/* min_ex - 1 horizontal position.                                 */
/* are we moving to a different cell ? */
/* record the current one if it is valid */
/*************************************************************************/
/*                                                                       */
/* Start a new contour at a given cell.                                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* Render a scanline as one or more cells.                               */
/*                                                                       */
/* trivial case.  Happens often */
/* everything is located in a single cell.  That is easy! */
/*                                                        */
/* ok, we'll have to render a run of adjacent cells on the same */
/* scanline...                                                  */
/*                                                              */
/*************************************************************************/
/*                                                                       */
/* Render a given line as a series of scanlines.                         */
/*                                                                       */
/* if (ey2 >= ras.max_ey) ey2 = ras.max_ey-1; */
/* XXX: we should do something about the trivial case where dx == 0, */
/*      as it happens very often!                                    */
/* perform vertical clipping */
/* everything is on a single scanline */
/* vertical line - avoid calling gray_render_scanline */
/* ok, we have to render several scanlines */
/* a shortcut to speed things up */
/* we compute the mid-point directly in order to avoid */
/* calling gray_split_conic()                          */
/* check that the arc crosses the current band */
/* Recalculation of midpoint is needed only if */
/* UPSCALE and DOWNSCALE have any effect.      */
/* check that the arc crosses the current band */
/* record current cell, if any */
/* start to a new position */
/* first of all, compute the scanline offset */
/* For small-spans it is faster to do it by ourselves than
/* compute the coverage line's coverage, depending on the    */
/* outline fill rule                                         */
/*                                                           */
/* the coverage percentage is area/(PIXEL_BITS*PIXEL_BITS*2) */
/*                                                           */
/* use range 0..256 */
/* normal non-zero winding rule */
/* FT_Span.x is a 16-bit short, so limit our coordinates appropriately */
/* FT_Span.y is an integer, so limit our coordinates appropriately */
/* see whether we can add this span to the current list */
/* FT_DEBUG_LEVEL_TRACE */
/* add a gray span to the current list */
/* to be called while in the debugger --                                */
/* this function causes a compiler warning since it is unused otherwise */
/* FT_DEBUG_LEVEL_TRACE */
/*************************************************************************/
/*                                                                       */
/*  The following function should only compile in stand-alone mode,      */
/*  i.e., when building this component without the rest of FreeType.     */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    FT_Outline_Decompose                                               */
/*                                                                       */
/* <Description>                                                         */
/*    Walk over an outline's structure to decompose it into individual   */
/*    segments and Bézier arcs.  This function is also able to emit      */
/*    `move to' and `close to' operations to indicate the start and end  */
/*    of new contours in the outline.                                    */
/*                                                                       */
/* <Input>                                                               */
/*    outline        :: A pointer to the source target.                  */
/*                                                                       */
/*    func_interface :: A table of `emitters', i.e., function pointers   */
/*                      called during decomposition to indicate path     */
/*                      operations.                                      */
/*                                                                       */
/* <InOut>                                                               */
/*    user           :: A typeless pointer which is passed to each       */
/*                      emitter during the decomposition.  It can be     */
/*                      used to store the state during the               */
/*                      decomposition.                                   */
/*                                                                       */
/* <Return>                                                              */
/*    Error code.  0 means success.                                      */
/*                                                                       */
/* index of contour in outline     */
/* index of first point in contour */
/* current point's state           */
/* index of last point in contour */
/* A contour cannot start with a cubic control point! */
/* check first point to determine origin */
/* first point is conic control.  Yes, this happens. */
/* start at last point if it is on the curve */
/* if both first and last points are conic,         */
/* start at their middle and record its position    */
/* for closure                                      */
/* emit a single line_to */
/* consume conic arcs */
/* FT_CURVE_TAG_CUBIC */
/* close the contour with a line segment */
/* _STANDALONE_ */
/* Set up state in the raster object */
/* clip to target bitmap, exit if nothing to do */
/* simple heuristic used to speed up the bezier decomposition -- see */
/* the code in gray_render_conic() and gray_render_cubic() for more  */
/* details                                                           */
/* set up vertical bands */
/* render pool overflow; we will reduce the render band by half */
/* This is too complex for a single scanline; there must */
/* be some problems.                                     */
/* return immediately if the outline is empty */
/* if direct mode is not set, we must have a target bitmap */
/* nothing to do */
/* this version does not support monochrome rendering */
/* compute clipping box */
/* compute clip box from target pixmap */
/**** RASTER OBJECT CREATION: In stand-alone mode, we simply use *****/
/****                         a static object.                   *****/
/* nothing */
/* !_STANDALONE_ */
/* !_STANDALONE_ */
/* END */
/* Local Variables: */
/* coding: utf-8    */
/* End:             */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\smooth\ftsmooth.c
/***************************************************************************/
/*                                                                         */
/*  ftsmooth.c                                                             */
/*                                                                         */
/*    Anti-aliasing renderer interface (body).                             */
/*                                                                         */
/*  Copyright 2000-2001, 2002, 2003, 2004, 2005, 2006, 2009, 2010 by       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* initialize renderer -- init its raster */
/* sets render-specific mode */
/* we simply pass it to the raster */
/* transform a given glyph image */
/* return the glyph's control box */
/* convert a slot's glyph image into a bitmap */
/* check glyph image format */
/* check mode */
/* translate the outline to the new origin if needed */
/* compute the control box, and grid fit it */
/* release old bitmap buffer */
/* allocate new one */
/* Required check is ( pitch * height < FT_ULONG_MAX ),     */
/* but we care realistic cases only. Always pitch <= width. */
/* translate outline to render it into the bitmap */
/* set up parameters */
/* implode outline if needed */
/* render outline into the bitmap */
/* deflate outline if needed */
/* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
/* render outline into bitmap */
/* expand it horizontally */
/* expand it vertically */
/* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
/*
/* convert a slot's glyph image into a bitmap */
/* convert a slot's glyph image into a horizontal LCD bitmap */
/* convert a slot's glyph image into a vertical LCD bitmap */
/* module specific interface */
/* module specific interface */
/* module specific interface */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\smooth\ftspic.c
/***************************************************************************/
/*                                                                         */
/*  ftspic.c                                                               */
/*                                                                         */
/*    The FreeType position independent code services for smooth module.   */
/*                                                                         */
/*  Copyright 2009, 2010 by                                                */
/*  Oran Agra and Mickey Gabel.                                            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* forward declaration of PIC init functions from ftgrays.c */
/* since this function also serve smooth_lcd and smooth_lcdv renderers, 
/* allocate pointer, clear and set global container pointer */
/* initialize pointer table - this is how the module usually expects this data */
/*Exit:*/
/* re-route these init and free functions to the above functions */
/* FT_CONFIG_OPTION_PIC */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\smooth\smooth.c
/***************************************************************************/
/*                                                                         */
/*  smooth.c                                                               */
/*                                                                         */
/*    FreeType anti-aliasing rasterer module component (body only).        */
/*                                                                         */
/*  Copyright 1996-2001 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\tools\apinames.c
/*
/* output the list of names, one per line             */
/* output a Windows .DEF file for Visual C++ or Mingw */
/* output a Windows .DEF file for Borland C++         */
/* output a Watcom Linker Command File                */
/* compute hash value */
/* check for an pre-existing name */
/* add new name */
/* we must omit the .dll suffix from the library name */
/* LIST */
/* states of the line parser */
/* waiting for FT_EXPORT keyword and return type */
/* type was read, waiting for function name      */
/* skip leading whitespace */
/* skip empty lines */
/* sometimes, the name is just after the FT_EXPORT(...), so
/* fall-through */
/* the default */
/* '-' used as a single argument means read source file from stdin */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\tools\chktrcmp.py
#!/usr/bin/env python
#
# Check trace components in FreeType 2 source.
# Author: suzuki toshiya, 2009
#
# This code is explicitly into the public domain.
# --------------------------------------------------------------
# Parse command line options
#
# --------------------------------------------------------------
# Scan C source and header files using trace macros.
#
#define[ \t]+FT_COMPONENT[ \t]+trace_' )
# --------------------------------------------------------------
# Scan header file(s) defining trace macros.
#
# --------------------------------------------------------------
# Compare the used and defined trace macros.
#
# Trace component used in the implementations but not defined in fttrace.h."
# Trace component is defined but not used in the implementations."
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\tools\cordic.py
# compute arctangent table for CORDIC computations in fttrigon.c
#units  = 64*65536.0   # don't change !!
# compute range of "i"
# tangent value
# arctangent
# arctangent in FT_Angle units
# determine which integer value for angle gives the best tangent
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\tools\glnames.py
#!/usr/bin/env python
#
#
# FreeType 2 glyph name builder
#
# Copyright 1996-2000, 2003, 2005, 2007, 2008 by
# David Turner, Robert Wilhelm, and Werner Lemberg.
#
# This file is part of the FreeType project, and may only be used, modified,
# and distributed under the terms of the FreeType project license,
# LICENSE.TXT.  By continuing to use, modify, or distribute this file you
# indicate that you have read the license and understand and accept it
# fully.
# This table lists the glyphs according to the Macintosh specification.
# It is used by the TrueType Postscript names table.
#
# See
#
#   http://fonts.apple.com/TTRefMan/RM06/Chap6post.html
#
# for the official list.
#
# 0
# 10
# 20
# 30
# 40
# 50
# 60
# 70
# 80
# 90
# 100
# 110
# 120
# 130
# 140
# 150
# 160
# 170
# 180
# 190
# 200
# 210
# 220
# 230
# 240
# 250
# The list of standard `SID' glyph names.  For the official list,
# see Annex A of document at
#
#   http://partners.adobe.com/asn/developer/pdfs/tn/5176.CFF.pdf.
#
# 0
# 10
# 20
# 30
# 40
# 50
# 60
# 70
# 80
# 90
# 100
# 110
# 120
# 130
# 140
# 150
# 160
# 170
# 180
# 190
# 200
# 210
# 220
# 230
# 240
# 250
# 260
# 270
# 280
# 290
# 300
# 310
# 320
# 330
# 340
# 350
# 360
# 370
# 380
# 390
# This table maps character codes of the Adobe Standard Type 1
# encoding to glyph indices in the sid_standard_names table.
#
# This table maps character codes of the Adobe Expert Type 1
# encoding to glyph indices in the sid_standard_names table.
#
# This data has been taken literally from the file `glyphlist.txt',
# version 2.0, 22 Sept 2002.  It is available from
#
#   http://partners.adobe.com/asn/developer/typeforum/unicodegn.html
#   http://partners.adobe.com/public/developer/en/opentype/glyphlist.txt
#
# string table management
#
#define " + macro_name + "  " + repr( len( sublist ) ) + "\n\n" )
# We now store the Adobe Glyph List in compressed form.  The list is put
# into a data structure called `trie' (because it has a tree-like
# appearance).  Consider, for example, that you want to store the
# following name mapping:
#
#   A        => 1
#   Aacute   => 6
#   Abalon   => 2
#   Abstract => 4
#
# It is possible to store the entries as follows.
#
#   A => 1
#   |
#   +-acute => 6
#   |
#   +-b
#     |
#     +-alon => 2
#     |
#     +-stract => 4
#
# We see that each node in the trie has:
#
# - one or more `letters'
# - an optional value
# - zero or more child nodes
#
# The first step is to call
#
#   root = StringNode( "", 0 )
#   for word in map.values():
#     root.add( word, map[word] )
#
# which creates a large trie where each node has only one children.
#
# Executing
#
#   root = root.optimize()
#
# optimizes the trie by merging the letters of successive nodes whenever
# possible.
#
# Each node of the trie is stored as follows.
#
# - First the node's letter, according to the following scheme.  We
#   use the fact that in the AGL no name contains character codes > 127.
#
#     name         bitsize     description
#     ----------------------------------------------------------------
#     notlast            1     Set to 1 if this is not the last letter
#                              in the word.
#     ascii              7     The letter's ASCII value.
#
# - The letter is followed by a children count and the value of the
#   current key (if any).  Again we can do some optimization because all
#   AGL entries are from the BMP; this means that 16 bits are sufficient
#   to store its Unicode values.  Additionally, no node has more than
#   127 children.
#
#     name         bitsize     description
#     -----------------------------------------
#     hasvalue           1     Set to 1 if a 16-bit Unicode value follows.
#     num_children       7     Number of children.  Can be 0 only if
#                              `hasvalue' is set to 1.
#     value             16     Optional Unicode value.
#
# - A node is finished by a list of 16bit absolute offsets to the
#   children, which must be sorted in increasing order of their first
#   letter.
#
# For simplicity, all 16bit quantities are stored in big-endian order.
#
# The root node has first letter = 0, and no value.
#
# optimize all children first
# don't optimize if there's a value,
# if we don't have any child or if we
# have more than one child
# this is used during debugging
# write the letters
# write the count
#     print fields[1] + ' - ' + fields[0]
# `mac_extras' contains the list of glyph names in the Macintosh standard
# encoding which are not in the SID Standard Names.
#
# `base_list' contains the names of our final glyph names table.
# It consists of the `mac_extras' glyph names, followed by the SID
# standard names.
#
# dump final glyph list (mac extras + sid standard names)
#
# dump the AGL in its compressed form
#
#ifdef FT_CONFIG_OPTION_ADOBE_GLYPH_LIST
# write the lookup routine now
#
#endif /* FT_CONFIG_OPTION_ADOBE_GLYPH_LIST */
# generate unit test, or don't
#
# now write the unit test to check that everything works OK
#
#ifdef TEST\n\n" )
#include <stdlib.h>
#include <stdio.h>
#endif /* TEST */\n" )
# Now run the main routine
#
# END
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\tools\test_afm.c
/*
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\tools\test_bbox.c
/* for clock() */
/* SunOS 4.1.* does not define CLOCKS_PER_SEC, so include <sys/param.h> */
/* to get the HZ macro which is the equivalent.                         */
/* test bbox computations */
/* dummy outline #1 */
/* 408.9111, 535.3164 */
/* 455.8887, 634.3960 */
/* -37.8765, 786.2207 */
/* 164.6074, 535.3164 */
/* dummy outline #2 */
/* compute and display cbox */
/* compute and display bbox */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\tools\test_trig.c
/* the precision in 16.16 fixed float points of the checks. Expect */
/* between 2 and 5 noise LSB bits during operations, due to        */
/* rounding errors..                                               */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\tools\docmaker\content.py
#  Content (c) 2002, 2004, 2006, 2007, 2008, 2009
#    David Turner <david@freetype.org>
#
#  This file contains routines used to parse the content of documentation
#  comment blocks and build more structured objects out of them.
#
# this regular expression is used to detect code sequences. these
# are simply code fragments embedded in '{' and '}' like in:
#
#  {
#    x = y + z;
#    if ( zookoo == 2 )
#    {
#      foobar();
#    }
#  }
#
# note that indentation of the starting and ending accolades must be
# exactly the same. the code sequence can contain accolades at greater
# indentation
#
# this regular expression is used to isolate identifiers from
# other text
#
# we collect macros ending in `_H'; while outputting the object data, we use
# this info together with the object's file location to emit the appropriate
# header file macro and name before the object itself
#
#define\s{1,}(\w{1,}_H)\s{1,}<(.*)>' )
#############################################################################
#
# The DocCode class is used to store source code lines.
#
#   'self.lines' contains a set of source code lines that will be dumped as
#   HTML in a <PRE> tag.
#
#   The object is filled line by line by the parser; it strips the leading
#   "margin" space from each input line before storing it in 'self.lines'.
#
# remove margin spaces
#############################################################################
#
# The DocPara class is used to store "normal" text paragraph.
#
#   'self.words' contains the list of words that make up the paragraph
#
# current line
# current width
#############################################################################
#
#  The DocField class is used to store a list containing either DocPara or
#  DocCode objects. Each DocField also has an optional "name" which is used
#  when the object corresponds to a field or value definition
#
# can be None for normal paragraphs/sources
# list of items
# start parsing mode
# parsing code sequences
# parsing normal paragraph
# current code sequence indentation
# now analyze the markup lines to see if they contain paragraphs,
# code sequences or fields definitions
#
# are we parsing a code sequence ?
# that's it, we finished the code sequence
# nope, continue the code sequence
# start of code sequence ?
# save current lines
# switch to code extraction mode
# if the line is empty, we end the current paragraph,
# if any
# otherwise, simply add the line to the current
# paragraph
# unexpected end of code sequence
# this regular expression is used to detect field definitions
#
# we detected the start of a new field definition
# first, save the current one
# record field name
# ordered block names in section
# look up one block that contains a valid section description
# dictionary of documentation sections
# current documentation section
# list of chapters
# dictionary of header macros
# get rid of last line of markup if it's empty
# remove markup from line
# is it the start of a new markup section ?
# add current markup content
# this is a documentation comment, we need to catch
# all following normal blocks in the "follow" list
#
# process all sections to extract their abstract, description
# and ordered list of items
#
# process chapters to check that all sections are correctly
# listed there
# check that all sections are in a chapter
#
# create a new special chapter for all remaining sections
# when necessary
#
# compute block type from first markup tag
# compute block name from first markup paragraph
# detect new section starts
# detect new chapter
# now, compute the source lines relevant to this documentation
# block. We keep normal comments in for obvious reasons (??)
# collect header macro definitions
# we use "/* */" as a separator
# now strip the leading and trailing empty lines from the sources
# eof
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\tools\docmaker\docbeauty.py
#!/usr/bin/env python
#
#  DocBeauty (c) 2003, 2004, 2008 David Turner <david@freetype.org>
#
# This program is used to beautify the documentation comments used
# in the FreeType 2 public headers.
#
# now beautify the documentation "borders" themselves
# process options
#
# create context and processor
# retrieve the list of files to process
# if called from the command line
#
# eof
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\tools\docmaker\docmaker.py
#!/usr/bin/env python
#
#  DocMaker (c) 2002, 2004, 2008 David Turner <david@freetype.org>
#
# This program is a re-write of the original DocMaker took used
# to generate the API Reference of the FreeType font engine
# by converting in-source comments into structured HTML.
#
# This new version is capable of outputting XML data, as well
# as accepts more liberal formatting options.
#
# It also uses regular expression matching and substitution
# to speed things significantly.
#
# process options
#
# create context and processor
# retrieve the list of files to process
# process sections
# if called from the command line
#
# eof
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\tools\docmaker\formatter.py
#  Formatter (c) 2002, 2004, 2007, 2008 David Turner <david@freetype.org>
#
# This is the base Formatter class.  Its purpose is to convert
# a content processor's data into specific documents (i.e., table of
# contents, global index, and individual API reference indices).
#
# You need to sub-class it to output anything sensible.  For example,
# the file tohtml.py contains the definition of the HtmlFormatter sub-class
# used to output -- you guessed it -- HTML.
#
# store all blocks in a dictionary
# add enumeration values to the index, since this is useful
# duplicate name!
#
#  Formatting the table of contents
#
#
#  Formatting the index
#
#
#  Formatting a section
#
# always ignore first markup!
# eof
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\tools\docmaker\sources.py
#  Sources (c) 2002, 2003, 2004, 2006, 2007, 2008, 2009
#    David Turner <david@freetype.org>
#
#
# this file contains definitions of classes needed to decompose
# C sources files into a series of multi-line "blocks". There are
# two kinds of blocks:
#
#   - normal blocks, which contain source code or ordinary comments
#
#   - documentation blocks, which have restricted formatting, and
#     whose text always start with a documentation markup tag like
#     "<Function>", "<Type>", etc..
#
# the routines used to process the content of documentation blocks
# are not contained here, but in "content.py"
#
# the classes and methods found here only deal with text parsing
# and basic documentation block extraction
#
################################################################
##
##  BLOCK FORMAT PATTERN
##
##   A simple class containing compiled regular expressions used
##   to detect potential documentation format block comments within
##   C source code
##
##   note that the 'column' pattern must contain a group that will
##   be used to "unbox" the content of documentation comment blocks
##
#
# format 1 documentation comment blocks look like the following:
#
#    /************************************/
#    /*                                  */
#    /*                                  */
#    /*                                  */
#    /************************************/
#
# we define a few regular expressions here to detect them
#
# any number of whitespace
# followed by '/' and at least two asterisks then '/'
# probably followed by whitespace
# any number of whitespace
# followed by '/' and precisely one asterisk
# followed by anything (group 1)
# followed by one asterisk and a '/'
# probably followed by whitespace
#
# format 2 documentation comment blocks look like the following:
#
#    /************************************ (at least 2 asterisks)
#     *
#     *
#     *
#     *
#     **/       (1 or more asterisks at the end)
#
# we define a few regular expressions here to detect them
#
# any number of whitespace
# followed by '/' and at least two asterisks
# probably followed by whitespace
# any number of whitespace
# followed by precisely one asterisk not followed by `/'
# then anything (group1)
# any number of whitespace
# followed by at least one asterisk, then '/'
#
# the list of supported documentation block formats, we could add new ones
# relatively easily
#
#
# the following regular expressions corresponds to markup tags
# within the documentation comment blocks. they're equivalent
# despite their different syntax
#
# notice how each markup tag _must_ begin a new line
#
# <xxxx> format
# @xxxx: format
#
# the list of supported markup tags, we could add new ones relatively
# easily
#
#
# used to detect a cross-reference, after markup tags have been stripped
#
#
# used to detect italic and bold styles in paragraph text
#
#  _italic_
#  *bold*
#
# used to detect the end of commented source lines
#
#
# used to perform cross-reference within source output
#
#
# a list of reserved source keywords
#
#include |
#define  |
#undef   |
#if      |
#ifdef   |
#ifndef  |
#else    |
#endif   ) \\b''', re.VERBOSE )
################################################################
##
##  SOURCE BLOCK CLASS
##
##   A SourceProcessor is in charge of reading a C source file
##   and decomposing it into a series of different "SourceBlocks".
##   each one of these blocks can be made of the following data:
##
##   - A documentation comment block that starts with "/**" and
##     whose exact format will be discussed later
##
##   - normal sources lines, including comments
##
##   the important fields in a text block are the following ones:
##
##     self.lines   : a list of text lines for the corresponding block
##
##     self.content : for documentation comment blocks only, this is the
##                    block content that has been "unboxed" from its
##                    decoration. This is None for all other blocks
##                    (i.e. sources or ordinary comments with no starting
##                     markup tag)
##
# extract comment lines
# now, look for a markup tag
# debugging only - not used in normal operations
################################################################
##
##  SOURCE PROCESSOR CLASS
##
##   The SourceProcessor is in charge of reading a C source file
##   and decomposing it into a series of different "SourceBlock"
##   objects.
##
##   each one of these blocks can be made of the following data:
##
##   - A documentation comment block that starts with "/**" and
##     whose exact format will be discussed later
##
##   - normal sources lines, include comments
##
##
# strip trailing newlines, important on Windows machines!
# that's a normal block end, add it to 'lines' and
# create a new block
# that's a normal column line, add it to 'lines'
# humm.. this is an unexpected block end,
# create a new block, but don't process the line
# we need to process the line again
# record the last lines
# debugging only, not used in normal operations
# eof
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\tools\docmaker\tohtml.py
#  ToHTML (c) 2002, 2003, 2005, 2006, 2007, 2008
#    David Turner <david@freetype.org>
# The following defines the HTML header used by all generated pages.
#000000;
#FFFFFF; }
#0000EF; }
#51188E; }
#FF0000; }
# The HTML footer used by all generated pages.
# The header and footer used for each section.
# The header and footer used for code segments.
# Paragraph header and footer.
# Block header and footer.
# Description header/footer.
# Marker header/inter/footer combination.
#EEEEFF"><td><em><b>'
# Header location header/footer.
# Source code extracts header/footer.
#D6E8FF"><td><pre>\n'
# Chapter header/inter/footer.
# Index footer.
# TOC footer.
# source language keyword coloration/styling
# Translate a single line of source to HTML.  This will convert
# a "<" into "&lt.", ">" into "&gt.", etc.
# same as 'html_quote', but ignores left and right brackets
# clean the last empty lines
# The code footer should be directly appended to the last code
# line to avoid an additional blank line.
#" + block.name
# look for cross-references
# we detected a cross-reference to an unknown item
# look for italics and bolds
# convert `...' quotations into real left and right single quotes
# convert tilde into non-breakable space
# this is the current block name, if any
# this is a C keyword
# this is a known identifier
# we begin a new series of field or value definitions, we
# will record them in the 'table_fields' list before outputting
# all of them as a single table
#
#
#  Formatting the index
#
# block_index already contains the sorted list of index names
#
#  Formatting the table of content
#
#
#  Formatting sections
#
# XXX magic number
# print section synopsis
#' + name + '">' + name + '</a>'
# place html anchor if needed
# dump the block C source lines now
#           if not header:
#               sys.stderr.write( \
#                 'WARNING: No header macro for ' + block.source.filename + '.\n' )
# eof
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\tools\docmaker\utils.py
#  Utils (c) 2002, 2004, 2007, 2008  David Turner <david@freetype.org>
#
# current output directory
#
# This function is used to sort the index.  It is a simple lexicographical
# sort, except that it places capital letters before lowercase ones.
#
# Sort input_list, placing the elements of order_list in front.
#
# Open the standard output to a given project documentation file.  Use
# "output_dir" to determine the filename location if necessary and save the
# old stdout in a tuple that is returned by this function.
#
# Close the output that was returned by "close_output".
#
# Check output directory.
#
# sys.stderr.write( repr( sys.argv[1 :] ) + '\n' )
# sort files -- this is important because
# of the order of files
# now filter the file list to remove non-existing ones
# eof
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\tools\ftrandom\ftrandom.c
/* Copyright (C) 2005, 2007, 2008 by George Williams */
/*
/* modified by Werner Lemberg <wl@gnu.org>       */
/* This file is now part of the FreeType library */
/* No shift, no delta */
/* The font is erroneous, so if this fails that's ok. */
/* Try to guess the file type from the first few characters... */
/* ttf, otf, ttc files */
/* PFB header */
/* Random PostScript */
/* Bare CFF */
/* BDF */
/* PFR */
/* Windows FON */
/* If a time-out happens, then kill the child */
/* Anything that takes more than 20 seconds */
/* to parse and/or rasterize is an error.   */
/* This should never return */
/* EOF */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\truetype\truetype.c
/***************************************************************************/
/*                                                                         */
/*  truetype.c                                                             */
/*                                                                         */
/*    FreeType TrueType driver component (body only).                      */
/*                                                                         */
/*  Copyright 1996-2001, 2004, 2006 by                                     */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* driver interface    */
/* tables loader       */
/* glyph loader        */
/* object manager      */
/* gx distortable font */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\truetype\ttdriver.c
/***************************************************************************/
/*                                                                         */
/*  ttdriver.c                                                             */
/*                                                                         */
/*    TrueType font driver implementation (body).                          */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009    */
/*            2010 by                                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                                                                 ****/
/****                          F A C E S                              ****/
/****                                                                 ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_get_kerning                                                     */
/*                                                                       */
/* <Description>                                                         */
/*    A driver method used to return the kerning vector between two      */
/*    glyphs of the same face.                                           */
/*                                                                       */
/* <Input>                                                               */
/*    face        :: A handle to the source face object.                 */
/*                                                                       */
/*    left_glyph  :: The index of the left glyph in the kern pair.       */
/*                                                                       */
/*    right_glyph :: The index of the right glyph in the kern pair.      */
/*                                                                       */
/* <Output>                                                              */
/*    kerning     :: The kerning vector.  This is in font units for      */
/*                   scalable formats, and in pixels for fixed-sizes     */
/*                   formats.                                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* <Note>                                                                */
/*    Only horizontal layouts (left-to-right & right-to-left) are        */
/*    supported by this function.  Other layouts, or more sophisticated  */
/*    kernings, are out of scope of this method (the basic driver        */
/*    interface is meant to be simple).                                  */
/*                                                                       */
/*    They can be implemented by format-specific interfaces.             */
/*                                                                       */
/* TT_Face */
/* XXX: TODO: check for sbits */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                                                                 ****/
/****                           S I Z E S                             ****/
/****                                                                 ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* use the scaled metrics, even when tt_size_reset fails */
/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Load_Glyph                                                         */
/*                                                                       */
/* <Description>                                                         */
/*    A driver method used to load a glyph within a given glyph slot.    */
/*                                                                       */
/* <Input>                                                               */
/*    slot        :: A handle to the target slot object where the glyph  */
/*                   will be loaded.                                     */
/*                                                                       */
/*    size        :: A handle to the source face size at which the glyph */
/*                   must be scaled, loaded, etc.                        */
/*                                                                       */
/*    glyph_index :: The index of the glyph in the font file.            */
/*                                                                       */
/*    load_flags  :: A flag indicating what to load for this glyph.  The */
/*                   FT_LOAD_XXX constants can be used to control the    */
/*                   glyph loading process (e.g., whether the outline    */
/*                   should be scaled, whether to load bitmaps or not,   */
/*                   whether to hint the outline, etc).                  */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* TT_GlyphSlot */
/* TT_Size      */
/* both FT_LOAD_NO_HINTING and FT_LOAD_NO_AUTOHINT   */
/* are necessary to disable hinting for tricky fonts */          
/* now load the glyph outline if necessary */
/* force drop-out mode to 2 - irrelevant now */
/* slot->outline.dropout_mode = 2; */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/****                                                                 ****/
/****                                                                 ****/
/****                D R I V E R  I N T E R F A C E                   ****/
/****                                                                 ****/
/****                                                                 ****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* !TT_USE_BYTECODE_INTERPRETER */
/* TT_USE_BYTECODE_INTERPRETER */
/* TT_Driver */
/* only return the default interface from the SFNT module */
/* The FT_DriverInterface structure is defined in ftdriver.h. */
/* driver name                           */
/* driver version == 1.0                 */
/* driver requires FreeType 2.0 or above */
/* driver specific interface */
/* FT_Slot_DoneFunc */
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/* FT_CONFIG_OPTION_OLD_INTERNALS */
/* FT_Face_AttachFunc      */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\truetype\ttgload.c
/***************************************************************************/
/*                                                                         */
/*  ttgload.c                                                              */
/*                                                                         */
/*    TrueType Glyph Loader (body).                                        */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,   */
/*            2010 by                                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* Composite font flags.                                                 */
/*                                                                       */
/* reserved                        0x0010 */
/*************************************************************************/
/*                                                                       */
/* Returns the horizontal metrics in font units for a given glyph.  If   */
/* `check' is true, take care of monospaced fonts by returning the       */
/* advance width maximum.                                                */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* Returns the vertical metrics in font units for a given glyph.         */
/* Greg Hitchcock from Microsoft told us that if there were no `vmtx'    */
/* table, typoAscender/Descender from the `OS/2' table would be used     */
/* instead, and if there were no `OS/2' table, use ascender/descender    */
/* from the `hhea' table.  But that is not what Microsoft's rasterizer   */
/* apparently does: It uses the ppem value as the advance height, and    */
/* sets the top side bearing to be zero.                                 */
/*                                                                       */
/* The monospace `check' is probably not meaningful here, but we leave   */
/* it in for a consistent interface.                                     */
/*                                                                       */
/* Empirically determined, at variance with what MS said */
/* This is what MS said to do.  It isn't what they do, however. */
/* If this is an incrementally loaded font check whether there are */
/* overriding metrics for this glyph.                              */
/* GWW: Do I do the same for vertical metrics? */
/* 0 */
/* FT_CONFIG_OPTION_INCREMENTAL */
/*************************************************************************/
/*                                                                       */
/* Translates an array of coordinates.                                   */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* The following functions are used by default with TrueType fonts.      */
/* However, they can be replaced by alternatives if we need to support   */
/* TrueType-compressed formats (like MicroType) in the future.           */
/*                                                                       */
/*************************************************************************/
/* for non-debug mode */
/* the following line sets the `error' variable through macros! */
/* check that we can add the contours to the glyph */
/* reading the contours' endpoints & number of points */
/* check space for contours array + instructions count */
/* unordered contours: this is invalid */
/* note that we will add four phantom points later */
/* we'd better check the contours table right now */
/* reading the bytecode instructions */
/* TT_USE_BYTECODE_INTERPRETER */
/* reading the point tags */
/* reading the X coordinates */
/* the cast is for stupid compilers */
/* reading the Y coordinates */
/* the cast is for stupid compilers */
/* check that we can load a new subglyph */
/* check space */
/* check space */
/* read arguments */
/* read transform */
/* we must undo the FT_FRAME_ENTER in order to point */
/* to the composite instructions, if we find some.   */
/* We will process them later.                       */
/*                                                   */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Hint_Glyph                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Hint the glyph using the zone prepared by the caller.  Note that   */
/*    the zone is supposed to include four phantom points.               */
/*                                                                       */
/* save original point position in org */
/* Reset graphics state. */
/* XXX: UNDOCUMENTED! Hinting instructions of a composite glyph */
/*      completely refer to the (already) hinted subglyphs.     */
/* round pp2 and pp4 */
/* store drop-out mode in bits 5-7; set bit 2 also as a marker */
/* save glyph phantom points */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Process_Simple_Glyph                                            */
/*                                                                       */
/* <Description>                                                         */
/*    Once a simple glyph has been loaded, it needs to be processed.     */
/*    Usually, this means scaling and hinting through bytecode           */
/*    interpretation.                                                    */
/*                                                                       */
/* set phantom points */
/* Deltas apply to the unscaled data. */
/* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
/* scale the glyph */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Process_Composite_Component                                     */
/*                                                                       */
/* <Description>                                                         */
/*    Once a composite component has been loaded, it needs to be         */
/*    processed.  Usually, this means transforming and translating.      */
/*                                                                       */
/* perform the transform required for this subglyph */
/* get offset */
/* match l-th point of the newly loaded component to the k-th point */
/* of the previously loaded components.                             */
/* change to the point numbers used by our outline */
/* Use a default value dependent on                                     */
/* TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED.  This is useful for old TT */
/* fonts which don't set the xxx_COMPONENT_OFFSET bit.                  */
/*************************************************************************/
/*                                                                       */
/* This algorithm is what Apple documents.  But it doesn't work.         */
/*                                                                       */
/* 0 */
/*************************************************************************/
/*                                                                       */
/* This algorithm is a guess and works much better than the above.       */
/*                                                                       */
/* 0 */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Process_Composite_Glyph                                         */
/*                                                                       */
/* <Description>                                                         */
/*    This is slightly different from TT_Process_Simple_Glyph, in that   */
/*    its sole purpose is to hint the glyph.  Thus this function is      */
/*    only available when bytecode interpreter is enabled.               */
/*                                                                       */
/* make room for phantom points */
/* TT_Load_Composite_Glyph only gives us the offset of instructions */
/* so we read them here                                             */
/* check it */
/* acroread ignores this field, so we only do a rough safety check */
/* Some points are likely touched during execution of  */
/* instructions on components.  So let's untouch them. */
/* Calculate the four phantom points.                     */
/* The first two stand for horizontal origin and advance. */
/* The last two stand for vertical origin and advance.    */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    load_truetype_glyph                                                */
/*                                                                       */
/* <Description>                                                         */
/*    Loads a given truetype glyph.  Handles composites and uses a       */
/*    TT_Loader object.                                                  */
/*                                                                       */
/* some fonts have an incorrect value of `maxComponentDepth', */
/* thus we allow depth 1 to catch the majority of them        */
/* check glyph index */
/* Set `offset' to the start of the glyph relative to the start of */
/* the `glyf' table, and `byte_len' to the length of the glyph in  */
/* bytes.                                                          */
/* If we are loading glyph data via the incremental interface, set */
/* the loader stream to a memory stream reading the data returned  */
/* by the interface.                                               */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* for the incremental interface, `glyf_offset' is always zero */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* read glyph header first */
/* must initialize points before (possibly) overriding */
/* glyph metrics from the incremental interface        */
/* this must be done before scaling */
/* must initialize points before (possibly) overriding */
/* glyph metrics from the incremental interface        */
/***********************************************************************/
/***********************************************************************/
/***********************************************************************/
/* if it is a simple glyph, load it */
/* all data have been read */
/***********************************************************************/
/***********************************************************************/
/***********************************************************************/
/* otherwise, load a composite! */
/* position of composite instructions, if any */
/* for each subglyph, read composite header */
/* store the offset of instructions */
/* all data we need are read */
/* this provides additional offsets */
/* for each component's translation */
/* XXX: overflow check for subglyph->{arg1,arg2}.   */
/* deltas[i].{x,y} must be within signed 16-bit,    */
/* but the restriction of summed delta is not clear */
/* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
/* if the flag FT_LOAD_NO_RECURSE is set, we return the subglyph */
/* `as is' in the glyph slot (the client application will be     */
/* responsible for interpreting these data)...                   */
/*********************************************************************/
/*********************************************************************/
/*********************************************************************/
/* read each subglyph independently */
/* Each time we call load_truetype_glyph in this loop, the   */
/* value of `gloader.base.subglyphs' can change due to table */
/* reallocations.  We thus need to recompute the subglyph    */
/* pointer on each iteration.                                */
/* restore subglyph pointer */
/* gloader->base.outline consists of three parts:               */
/* 0 -(1)-> start_point -(2)-> num_base_points -(3)-> n_points. */
/*                                                              */
/* (1): exists from the beginning                               */
/* (2): components that have been loaded so far                 */
/* (3): the newly loaded component                              */
/* process the glyph */
/* invalid composite count (negative but not -1) */
/***********************************************************************/
/***********************************************************************/
/***********************************************************************/
/* get the device-independent horizontal advance; it is scaled later */
/* by the base layer.                                                */
/* the flag FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH was introduced to */
/* correctly support DynaLab fonts, which have an incorrect       */
/* `advance_Width_Max' field!  It is used, to my knowledge,       */
/* exclusively in the X-TrueType font server.                     */
/*                                                                */
/* we need to return the advance in font units in linearHoriAdvance, */
/* it will be scaled later by the base layer.                        */
/* adjust advance width to the value contained in the hdmx table */
/* set glyph dimensions */
/* Now take care of vertical metrics.  In the case where there is */
/* no vertical information within the font (relatively common),   */
/* create some metrics manually                                   */
/* scaled vertical top side bearing  */
/* scaled vertical advance height    */
/* Get the unscaled top bearing and advance height. */
/* XXX Compute top side bearing and advance height in  */
/*     Get_VMetrics instead of here.                   */
/* NOTE: The OS/2 values are the only `portable' ones, */
/*       which is why we use them, if there is an OS/2 */
/*       table in the font.  Otherwise, we use the     */
/*       values defined in the horizontal header.      */
/* If this is an incrementally loaded font see if there are */
/* overriding metrics for this glyph.                       */
/* GWW: Do vertical metrics get loaded incrementally too? */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* scale the metrics */
/* XXX: for now, we have no better algorithm for the lsb, but it */
/*      should work fine.                                        */
/*                                                               */
/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
/* load execution context */
/* query new execution context */
/* a change from mono to grayscale rendering (and vice versa) */
/* requires a re-execution of the CVT program                 */
/* see whether the cvt program has disabled hinting */
/* load default graphics state -- if needed */
/* TT_USE_BYTECODE_INTERPRETER */
/* seek to the beginning of the glyph table -- for Type 42 fonts     */
/* the table might be accessed from a Postscript stream or something */
/* else...                                                           */
/* get face's glyph loader */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Load_Glyph                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    A function used to load a single glyph within a given glyph slot,  */
/*    for a given size.                                                  */
/*                                                                       */
/* <Input>                                                               */
/*    glyph       :: A handle to a target slot object where the glyph    */
/*                   will be loaded.                                     */
/*                                                                       */
/*    size        :: A handle to the source face size at which the glyph */
/*                   must be scaled/loaded.                              */
/*                                                                       */
/*    glyph_index :: The index of the glyph in the font file.            */
/*                                                                       */
/*    load_flags  :: A flag indicating what to load for this glyph.  The */
/*                   FT_LOAD_XXX constants can be used to control the    */
/*                   glyph loading process (e.g., whether the outline    */
/*                   should be scaled, whether to load bitmaps or not,   */
/*                   whether to hint the outline, etc).                  */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* try to load embedded bitmap if any              */
/*                                                 */
/* XXX: The convention should be emphasized in     */
/*      the documents because it can be confusing. */
/* for the bbox we need the header only */
/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
/* if FT_LOAD_NO_SCALE is not set, `ttmetrics' must be valid */
/* main loading loop */
/* Translate array so that (0,0) is the glyph's origin.  Note  */
/* that this behaviour is independent on the value of bit 1 of */
/* the `flags' field in the `head' table -- at least major     */
/* applications like Acroread indicate that.                   */
/* convert scan conversion mode to FT_OUTLINE_XXX flags */
/* simple drop-outs including stubs */
/* simple drop-outs excluding stubs */
/* nothing; it's the default rendering mode */
/* smart drop-outs including stubs */
/* smart drop-outs excluding stubs  */
/* no drop-out control */
/* TT_USE_BYTECODE_INTERPRETER */
/* Set the `high precision' bit flag.                           */
/* This is _critical_ to get correct output for monochrome      */
/* TrueType glyphs at all sizes using the bytecode interpreter. */
/*                                                              */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\truetype\ttgxvar.c
/***************************************************************************/
/*                                                                         */
/*  ttgxvar.c                                                              */
/*                                                                         */
/*    TrueType GX Font Variation loader                                    */
/*                                                                         */
/*  Copyright 2004, 2005, 2006, 2007, 2008, 2009, 2010 by                  */
/*  David Turner, Robert Wilhelm, Werner Lemberg, and George Williams.     */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* Apple documents the `fvar', `gvar', `cvar', and `avar' tables at      */
/*                                                                       */
//developer.apple.com/fonts/TTRefMan/RM06/Chap6[fgca]var.html  */
/*   http://developer.apple.com/fonts/TTRefMan/RM06/Chap6[fgca]var.html  */
/*                                                                       */
/* The documentation for `fvar' is inconsistent.  At one point it says   */
/* that `countSizePairs' should be 3, at another point 2.  It should     */
/* be 2.                                                                 */
/*                                                                       */
/* The documentation for `gvar' is not intelligible; `cvar' refers you   */
/* to `gvar' and is thus also incomprehensible.                          */
/*                                                                       */
/* The documentation for `avar' appears correct, but Apple has no fonts  */
/* with an `avar' table, so it is hard to test.                          */
/*                                                                       */
/* Many thanks to John Jenkins (at Apple) in figuring this out.          */
/*                                                                       */
/*                                                                       */
/* Apple's `kern' table has some references to tuple indices, but as     */
/* there is no indication where these indices are defined, nor how to    */
/* interpolate the kerning values (different tuples have different       */
/* classes) this issue is ignored.                                       */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                       Internal Routines                       *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro ALL_POINTS is used in `ft_var_readpackedpoints'.  It        */
/* indicates that there is a delta for every point without needing to    */
/* enumerate all of them.                                                */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    ft_var_readpackedpoints                                            */
/*                                                                       */
/* <Description>                                                         */
/*    Read a set of points to which the following deltas will apply.     */
/*    Points are packed with a run length encoding.                      */
/*                                                                       */
/* <Input>                                                               */
/*    stream    :: The data stream.                                      */
/*                                                                       */
/* <Output>                                                              */
/*    point_cnt :: The number of points read.  A zero value means that   */
/*                 all points in the glyph will be affected, without     */
/*                 enumerating them individually.                        */
/*                                                                       */
/* <Return>                                                              */
/*    An array of FT_UShort containing the affected points or the        */
/*    special value ALL_POINTS.                                          */
/*                                                                       */
/* first point not included in runcount */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    ft_var_readpackeddeltas                                            */
/*                                                                       */
/* <Description>                                                         */
/*    Read a set of deltas.  These are packed slightly differently than  */
/*    points.  In particular there is no overall count.                  */
/*                                                                       */
/* <Input>                                                               */
/*    stream    :: The data stream.                                      */
/*                                                                       */
/*    delta_cnt :: The number of to be read.                             */
/*                                                                       */
/* <Return>                                                              */
/*    An array of FT_Short containing the deltas for the affected        */
/*    points.  (This only gets the deltas for one dimension.  It will    */
/*    generally be called twice, once for x, once for y.  When used in   */
/*    cvt table, it will only be called once.)                           */
/*                                                                       */
/* runcnt zeroes get added */
/* runcnt shorts from the stack */
/* runcnt signed bytes from the stack */
/* Bad format */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    ft_var_load_avar                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Parse the `avar' table if present.  It need not be, so we return   */
/*    nothing.                                                           */
/*                                                                       */
/* <InOut>                                                               */
/*    face :: The font face.                                             */
/*                                                                       */
/* Failure.  Free everything we have done so far.  We must do */
/* it right now since loading the `avar' table is optional.   */
/* convert to Fixed */
/* convert to Fixed */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    ft_var_load_gvar                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Parses the `gvar' table if present.  If `fvar' is there, `gvar'    */
/*    had better be there too.                                           */
/*                                                                       */
/* <InOut>                                                               */
/*    face :: The font face.                                             */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* long offsets (one more offset than glyphs, to mark size of last) */
/* short offsets (one more offset than glyphs, to mark size of last) */
/* XXX: Undocumented: `*2'! */
/* convert to FT_Fixed */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    ft_var_apply_tuple                                                 */
/*                                                                       */
/* <Description>                                                         */
/*    Figure out whether a given tuple (design) applies to the current   */
/*    blend, and if so, what is the scaling factor.                      */
/*                                                                       */
/* <Input>                                                               */
/*    blend           :: The current blend of the font.                  */
/*                                                                       */
/*    tupleIndex      :: A flag saying whether this is an intermediate   */
/*                       tuple or not.                                   */
/*                                                                       */
/*    tuple_coords    :: The coordinates of the tuple in normalized axis */
/*                       units.                                          */
/*                                                                       */
/*    im_start_coords :: The initial coordinates where this tuple starts */
/*                       to apply (for intermediate coordinates).        */
/*                                                                       */
/*    im_end_coords   :: The final coordinates after which this tuple no */
/*                       longer applies (for intermediate coordinates).  */
/*                                                                       */
/* <Return>                                                              */
/*    An FT_Fixed value containing the scaling factor.                   */
/*                                                                       */
/* It's not clear why (for intermediate tuples) we don't need     */
/* to check against start/end -- the documentation says we don't. */
/* Similarly, it's unclear why we don't need to scale along the   */
/* axis.                                                          */
/* not an intermediate tuple */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****               MULTIPLE MASTERS SERVICE FUNCTIONS              *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Get_MM_Var                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Check that the font's `fvar' table is valid, parse it, and return  */
/*    those data.                                                        */
/*                                                                       */
/* <InOut>                                                               */
/*    face   :: The font face.                                           */
/*              TT_Get_MM_Var initializes the blend structure.           */
/*                                                                       */
/* <Output>                                                              */
/*    master :: The `fvar' data (must be freed by caller).               */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* both `fvar' and `gvar' must be present */
/* axisCount limit implied by 16-bit instanceSize */
/* instanceCount limit implied by limited range of name IDs */
/* cannot overflow 32-bit arithmetic because of limits above */
/* meaningless in this context; each glyph */
/* may have a different number of designs  */
/* (or tuples, as called by Apple)         */
/* A Fixed */
/* A Fixed */
/* A Fixed */
/* flags = */ FT_GET_USHORT();
/* A Fixed */
/* standard PostScript names for some standard apple tags */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Set_MM_Blend                                                    */
/*                                                                       */
/* <Description>                                                         */
/*    Set the blend (normalized) coordinates for this instance of the    */
/*    font.  Check that the `gvar' table is reasonable and does some     */
/*    initial preparation.                                               */
/*                                                                       */
/* <InOut>                                                               */
/*    face       :: The font.                                            */
/*                  Initialize the blend structure with `gvar' data.     */
/*                                                                       */
/* <Input>                                                               */
/*    num_coords :: Must be the axis count of the font.                  */
/*                                                                       */
/*    coords     :: An array of num_coords, each between [-1,1].         */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* If we have not set the blend coordinates before this, then the  */
/* cvt table will still be what we read from the `cvt ' table and  */
/* we don't need to reload it.  We may need to change it though... */
/* If we don't change the blend coords then we don't need to do  */
/* anything to the cvt table.  It will be correct.  Otherwise we */
/* no longer have the original cvt (it was modified when we set  */
/* the blend last time), so we must reload and then modify it.   */
/* The cvt table has been loaded already; every time we change the */
/* blend we may need to reload and remodify the cvt table.         */
/* The original cvt table is in memory.  All we need to do is */
/* apply the `cvar' table (if any).                           */
/* The cvt table is correct for this set of coordinates. */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Set_Var_Design                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Set the coordinates for the instance, measured in the user         */
/*    coordinate system.  Parse the `avar' table (if present) to convert */
/*    from user to normalized coordinates.                               */
/*                                                                       */
/* <InOut>                                                               */
/*    face       :: The font face.                                       */
/*                  Initialize the blend struct with `gvar' data.        */
/*                                                                       */
/* <Input>                                                               */
/*    num_coords :: This must be the axis count of the font.             */
/*                                                                       */
/*    coords     :: A coordinate array with `num_coords' elements.       */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* Axis normalization is a two stage process.  First we normalize */
/* based on the [min,def,max] values for the axis to be [-1,0,1]. */
/* Then, if there's an `avar' table, we renormalize this range.   */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                     GX VAR PARSING ROUTINES                   *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_vary_cvt                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Modify the loaded cvt table according to the `cvar' table and the  */
/*    font's blend.                                                      */
/*                                                                       */
/* <InOut>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/* <Input>                                                               */
/*    stream :: A handle to the input stream.                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/*    Most errors are ignored.  It is perfectly valid not to have a      */
/*    `cvar' table even if there is a `gvar' and `fvar' table.           */
/*                                                                       */
/* The documentation implies there are flags packed into the        */
/* tuplecount, but John Jenkins says that shared points don't apply */
/* to `cvar', and no other flags are defined.                       */
/* There is no provision here for a global tuple coordinate section, */
/* so John says.  There are no tuple indices, just embedded tuples.  */
/* convert from        */
/* short frac to fixed */
/* skip this tuple; it makes no sense */
/* tuple isn't active for our blend */
/* global points not allowed,           */
/* if they aren't local, makes no sense */
/* failure, ignore it */;
/* this means that there are deltas for every entry in cvt */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Vary_Get_Glyph_Deltas                                           */
/*                                                                       */
/* <Description>                                                         */
/*    Load the appropriate deltas for the current glyph.                 */
/*                                                                       */
/* <Input>                                                               */
/*    face        :: A handle to the target face object.                 */
/*                                                                       */
/*    glyph_index :: The index of the glyph being modified.              */
/*                                                                       */
/*    n_points    :: The number of the points in the glyph, including    */
/*                   phantom points.                                     */
/*                                                                       */
/* <Output>                                                              */
/*    deltas      :: The array of points to change.                      */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* to be freed by the caller */
/* no variation data for this glyph */
/* each set of glyph variation data is formatted similarly to `cvar' */
/* (except we get shared points and global tuples)                   */
/* convert from        */
/* short frac to fixed */
/* tuple isn't active for our blend */
/* failure, ignore it */
/* this means that there are deltas for every point in the glyph */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_done_blend                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Frees the blend internal data structure.                           */
/*                                                                       */
/* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\truetype\ttinterp.c
/***************************************************************************/
/*                                                                         */
/*  ttinterp.c                                                             */
/*                                                                         */
/*    TrueType bytecode interpreter (body).                                */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,   */
/*            2010                                                         */
/*  by David Turner, Robert Wilhelm, and Werner Lemberg.                   */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* In order to detect infinite loops in the code, we set up a counter    */
/* within the run loop.  A single stroke of interpretation is now        */
/* limited to a maximal number of opcodes defined below.                 */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* There are two kinds of implementations:                               */
/*                                                                       */
/* a. static implementation                                              */
/*                                                                       */
/*    The current execution context is a static variable, which fields   */
/*    are accessed directly by the interpreter during execution.  The    */
/*    context is named `cur'.                                            */
/*                                                                       */
/*    This version is non-reentrant, of course.                          */
/*                                                                       */
/* b. indirect implementation                                            */
/*                                                                       */
/*    The current execution context is passed to _each_ function as its  */
/*    first argument, and each field is thus accessed indirectly.        */
/*                                                                       */
/*    This version is fully re-entrant.                                  */
/*                                                                       */
/* The idea is that an indirect implementation may be slower to execute  */
/* on low-end processors that are used in some systems (like 386s or     */
/* even 486s).                                                           */
/*                                                                       */
/* As a consequence, the indirect implementation is now the default, as  */
/* its performance costs can be considered negligible in our context.    */
/* Note, however, that we kept the same source with macros because:      */
/*                                                                       */
/* - The code is kept very close in design to the Pascal code used for   */
/*   development.                                                        */
/*                                                                       */
/* - It's much more readable that way!                                   */
/*                                                                       */
/* - It's still open to experimentation and tuning.                      */
/*                                                                       */
/*************************************************************************/
/* indirect implementation */
/* see ttobjs.h */
/*************************************************************************/
/*                                                                       */
/* This macro is used whenever `exec' is unused in a function, to avoid  */
/* stupid warnings from pedantic compilers.                              */
/*                                                                       */
/* static implementation */
/* static exec. context variable */
/* apparently, we have a _lot_ of direct indexing when accessing  */
/* the static `cur', which makes the code bigger (due to all the  */
/* four bytes addresses).                                         */
/* TT_CONFIG_OPTION_STATIC_INTERPRETER */
/*************************************************************************/
/*                                                                       */
/* The instruction argument stack.                                       */
/*                                                                       */
/* see ttobjs.h for EXEC_OP_ */
/*************************************************************************/
/*                                                                       */
/* This macro is used whenever `args' is unused in a function, to avoid  */
/* stupid warnings from pedantic compilers.                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* The following macros hide the use of EXEC_ARG and EXEC_ARG_ to        */
/* increase readability of the code.                                     */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* Instruction dispatch function, as used by the interpreter.            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* A simple bounds-checking macro.                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/*                        CODERANGE FUNCTIONS                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Goto_CodeRange                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Switches to a new code range (updates the code related elements in */
/*    `exec', and `IP').                                                 */
/*                                                                       */
/* <Input>                                                               */
/*    range :: The new execution code range.                             */
/*                                                                       */
/*    IP    :: The new IP in the new code range.                         */
/*                                                                       */
/* <InOut>                                                               */
/*    exec  :: The target execution context.                             */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* NOTE: Because the last instruction of a program may be a CALL */
/*       which will return to the first byte *after* the code    */
/*       range, we test for IP <= Size instead of IP < Size.     */
/*                                                               */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Set_CodeRange                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Sets a code range.                                                 */
/*                                                                       */
/* <Input>                                                               */
/*    range  :: The code range index.                                    */
/*                                                                       */
/*    base   :: The new code base.                                       */
/*                                                                       */
/*    length :: The range size in bytes.                                 */
/*                                                                       */
/* <InOut>                                                               */
/*    exec   :: The target execution context.                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Clear_CodeRange                                                 */
/*                                                                       */
/* <Description>                                                         */
/*    Clears a code range.                                               */
/*                                                                       */
/* <Input>                                                               */
/*    range :: The code range index.                                     */
/*                                                                       */
/* <InOut>                                                               */
/*    exec  :: The target execution context.                             */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* <Note>                                                                */
/*    Does not set the Error variable.                                   */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/*                   EXECUTION CONTEXT ROUTINES                          */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Done_Context                                                    */
/*                                                                       */
/* <Description>                                                         */
/*    Destroys a given context.                                          */
/*                                                                       */
/* <Input>                                                               */
/*    exec   :: A handle to the target execution context.                */
/*                                                                       */
/*    memory :: A handle to the parent memory object.                    */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* <Note>                                                                */
/*    Only the glyph loader and debugger should call this function.      */
/*                                                                       */
/* points zone */
/* free stack */
/* free call stack */
/* free glyph code range */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Init_Context                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    Initializes a context object.                                      */
/*                                                                       */
/* <Input>                                                               */
/*    memory :: A handle to the parent memory object.                    */
/*                                                                       */
/* <InOut>                                                               */
/*    exec   :: A handle to the target execution context.                */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* all values in the context are set to 0 already, but this is */
/* here as a remainder                                         */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Update_Max                                                         */
/*                                                                       */
/* <Description>                                                         */
/*    Checks the size of a buffer and reallocates it if necessary.       */
/*                                                                       */
/* <Input>                                                               */
/*    memory     :: A handle to the parent memory object.                */
/*                                                                       */
/*    multiplier :: The size in bytes of each element in the buffer.     */
/*                                                                       */
/*    new_max    :: The new capacity (size) of the buffer.               */
/*                                                                       */
/* <InOut>                                                               */
/*    size       :: The address of the buffer's current size expressed   */
/*                  in elements.                                         */
/*                                                                       */
/*    buff       :: The address of the buffer base pointer.              */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Load_Context                                                    */
/*                                                                       */
/* <Description>                                                         */
/*    Prepare an execution context for glyph hinting.                    */
/*                                                                       */
/* <Input>                                                               */
/*    face :: A handle to the source face object.                        */
/*                                                                       */
/*    size :: A handle to the source size object.                        */
/*                                                                       */
/* <InOut>                                                               */
/*    exec :: A handle to the target execution context.                  */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* <Note>                                                                */
/*    Only the glyph loader and debugger should call this function.      */
/*                                                                       */
/* set graphics state */
/* XXX: We reserve a little more elements on the stack to deal safely */
/*      with broken fonts like arialbs, courbs, timesbs, etc.         */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Save_Context                                                    */
/*                                                                       */
/* <Description>                                                         */
/*    Saves the code ranges in a `size' object.                          */
/*                                                                       */
/* <Input>                                                               */
/*    exec :: A handle to the source execution context.                  */
/*                                                                       */
/* <InOut>                                                               */
/*    size :: A handle to the target size object.                        */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* <Note>                                                                */
/*    Only the glyph loader and debugger should call this function.      */
/*                                                                       */
/* XXXX: Will probably disappear soon with all the code range */
/*       management, which is now rather obsolete.            */
/*                                                            */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    TT_Run_Context                                                     */
/*                                                                       */
/* <Description>                                                         */
/*    Executes one or more instructions in the execution context.        */
/*                                                                       */
/* <Input>                                                               */
/*    debug :: A Boolean flag.  If set, the function sets some internal  */
/*             variables and returns immediately, otherwise TT_RunIns()  */
/*             is called.                                                */
/*                                                                       */
/*             This is commented out currently.                          */
/*                                                                       */
/* <Input>                                                               */
/*    exec  :: A handle to the target execution context.                 */
/*                                                                       */
/* <Return>                                                              */
/*    TrueType error code.  0 means success.                             */
/*                                                                       */
/* <Note>                                                                */
/*    Only the glyph loader and debugger should call this function.      */
/*                                                                       */
/* some glyphs leave something on the stack. so we clean it */
/* before a new execution.                                  */
/* The default value for `scan_control' is documented as FALSE in the */
/* TrueType specification.  This is confusing since it implies a      */
/* Boolean value.  However, this is not the case, thus both the       */
/* default values of our `scan_type' and `scan_control' fields (which */
/* the documentation's `scan_control' variable is split into) are     */
/* zero.                                                              */
/* documentation is in ttinterp.h */
/* allocate object */
/* initialize it; in case of error this deallocates `exec' too */
/* store it into the driver */
/*************************************************************************/
/*                                                                       */
/* Before an opcode is executed, the interpreter verifies that there are */
/* enough arguments on the stack, with the help of the `Pop_Push_Count'  */
/* table.                                                                */
/*                                                                       */
/* For each opcode, the first column gives the number of arguments that  */
/* are popped from the stack; the second one gives the number of those   */
/* that are pushed in result.                                            */
/*                                                                       */
/* Opcodes which have a varying number of parameters in the data stream  */
/* (NPUSHB, NPUSHW) are handled specially; they have a negative value in */
/* the `opcode_length' table, and the value in `Pop_Push_Count' is set   */
/* to zero.                                                              */
/*                                                                       */
/*************************************************************************/
/* opcodes are gathered in groups of 16 */
/* please keep the spaces as they are   */
/*  SVTCA  y  */  PACK( 0, 0 ),
/*  SVTCA  x  */  PACK( 0, 0 ),
/*  SPvTCA y  */  PACK( 0, 0 ),
/*  SPvTCA x  */  PACK( 0, 0 ),
/*  SFvTCA y  */  PACK( 0, 0 ),
/*  SFvTCA x  */  PACK( 0, 0 ),
//  */  PACK( 2, 0 ),
/*  SPvTL //  */  PACK( 2, 0 ),
/*  SPvTL +   */  PACK( 2, 0 ),
//  */  PACK( 2, 0 ),
/*  SFvTL //  */  PACK( 2, 0 ),
/*  SFvTL +   */  PACK( 2, 0 ),
/*  SPvFS     */  PACK( 2, 0 ),
/*  SFvFS     */  PACK( 2, 0 ),
/*  GPV       */  PACK( 0, 2 ),
/*  GFV       */  PACK( 0, 2 ),
/*  SFvTPv    */  PACK( 0, 0 ),
/*  ISECT     */  PACK( 5, 0 ),
/*  SRP0      */  PACK( 1, 0 ),
/*  SRP1      */  PACK( 1, 0 ),
/*  SRP2      */  PACK( 1, 0 ),
/*  SZP0      */  PACK( 1, 0 ),
/*  SZP1      */  PACK( 1, 0 ),
/*  SZP2      */  PACK( 1, 0 ),
/*  SZPS      */  PACK( 1, 0 ),
/*  SLOOP     */  PACK( 1, 0 ),
/*  RTG       */  PACK( 0, 0 ),
/*  RTHG      */  PACK( 0, 0 ),
/*  SMD       */  PACK( 1, 0 ),
/*  ELSE      */  PACK( 0, 0 ),
/*  JMPR      */  PACK( 1, 0 ),
/*  SCvTCi    */  PACK( 1, 0 ),
/*  SSwCi     */  PACK( 1, 0 ),
/*  SSW       */  PACK( 1, 0 ),
/*  DUP       */  PACK( 1, 2 ),
/*  POP       */  PACK( 1, 0 ),
/*  CLEAR     */  PACK( 0, 0 ),
/*  SWAP      */  PACK( 2, 2 ),
/*  DEPTH     */  PACK( 0, 1 ),
/*  CINDEX    */  PACK( 1, 1 ),
/*  MINDEX    */  PACK( 1, 0 ),
/*  AlignPTS  */  PACK( 2, 0 ),
/*  INS_$28   */  PACK( 0, 0 ),
/*  UTP       */  PACK( 1, 0 ),
/*  LOOPCALL  */  PACK( 2, 0 ),
/*  CALL      */  PACK( 1, 0 ),
/*  FDEF      */  PACK( 1, 0 ),
/*  ENDF      */  PACK( 0, 0 ),
/*  MDAP[0]   */  PACK( 1, 0 ),
/*  MDAP[1]   */  PACK( 1, 0 ),
/*  IUP[0]    */  PACK( 0, 0 ),
/*  IUP[1]    */  PACK( 0, 0 ),
/*  SHP[0]    */  PACK( 0, 0 ),
/*  SHP[1]    */  PACK( 0, 0 ),
/*  SHC[0]    */  PACK( 1, 0 ),
/*  SHC[1]    */  PACK( 1, 0 ),
/*  SHZ[0]    */  PACK( 1, 0 ),
/*  SHZ[1]    */  PACK( 1, 0 ),
/*  SHPIX     */  PACK( 1, 0 ),
/*  IP        */  PACK( 0, 0 ),
/*  MSIRP[0]  */  PACK( 2, 0 ),
/*  MSIRP[1]  */  PACK( 2, 0 ),
/*  AlignRP   */  PACK( 0, 0 ),
/*  RTDG      */  PACK( 0, 0 ),
/*  MIAP[0]   */  PACK( 2, 0 ),
/*  MIAP[1]   */  PACK( 2, 0 ),
/*  NPushB    */  PACK( 0, 0 ),
/*  NPushW    */  PACK( 0, 0 ),
/*  WS        */  PACK( 2, 0 ),
/*  RS        */  PACK( 1, 1 ),
/*  WCvtP     */  PACK( 2, 0 ),
/*  RCvt      */  PACK( 1, 1 ),
/*  GC[0]     */  PACK( 1, 1 ),
/*  GC[1]     */  PACK( 1, 1 ),
/*  SCFS      */  PACK( 2, 0 ),
/*  MD[0]     */  PACK( 2, 1 ),
/*  MD[1]     */  PACK( 2, 1 ),
/*  MPPEM     */  PACK( 0, 1 ),
/*  MPS       */  PACK( 0, 1 ),
/*  FlipON    */  PACK( 0, 0 ),
/*  FlipOFF   */  PACK( 0, 0 ),
/*  DEBUG     */  PACK( 1, 0 ),
/*  LT        */  PACK( 2, 1 ),
/*  LTEQ      */  PACK( 2, 1 ),
/*  GT        */  PACK( 2, 1 ),
/*  GTEQ      */  PACK( 2, 1 ),
/*  EQ        */  PACK( 2, 1 ),
/*  NEQ       */  PACK( 2, 1 ),
/*  ODD       */  PACK( 1, 1 ),
/*  EVEN      */  PACK( 1, 1 ),
/*  IF        */  PACK( 1, 0 ),
/*  EIF       */  PACK( 0, 0 ),
/*  AND       */  PACK( 2, 1 ),
/*  OR        */  PACK( 2, 1 ),
/*  NOT       */  PACK( 1, 1 ),
/*  DeltaP1   */  PACK( 1, 0 ),
/*  SDB       */  PACK( 1, 0 ),
/*  SDS       */  PACK( 1, 0 ),
/*  ADD       */  PACK( 2, 1 ),
/*  SUB       */  PACK( 2, 1 ),
/*  DIV       */  PACK( 2, 1 ),
/*  MUL       */  PACK( 2, 1 ),
/*  ABS       */  PACK( 1, 1 ),
/*  NEG       */  PACK( 1, 1 ),
/*  FLOOR     */  PACK( 1, 1 ),
/*  CEILING   */  PACK( 1, 1 ),
/*  ROUND[0]  */  PACK( 1, 1 ),
/*  ROUND[1]  */  PACK( 1, 1 ),
/*  ROUND[2]  */  PACK( 1, 1 ),
/*  ROUND[3]  */  PACK( 1, 1 ),
/*  NROUND[0] */  PACK( 1, 1 ),
/*  NROUND[1] */  PACK( 1, 1 ),
/*  NROUND[2] */  PACK( 1, 1 ),
/*  NROUND[3] */  PACK( 1, 1 ),
/*  WCvtF     */  PACK( 2, 0 ),
/*  DeltaP2   */  PACK( 1, 0 ),
/*  DeltaP3   */  PACK( 1, 0 ),
/*  DeltaCn[0] */ PACK( 1, 0 ),
/*  DeltaCn[1] */ PACK( 1, 0 ),
/*  DeltaCn[2] */ PACK( 1, 0 ),
/*  SROUND    */  PACK( 1, 0 ),
/*  S45Round  */  PACK( 1, 0 ),
/*  JROT      */  PACK( 2, 0 ),
/*  JROF      */  PACK( 2, 0 ),
/*  ROFF      */  PACK( 0, 0 ),
/*  INS_$7B   */  PACK( 0, 0 ),
/*  RUTG      */  PACK( 0, 0 ),
/*  RDTG      */  PACK( 0, 0 ),
/*  SANGW     */  PACK( 1, 0 ),
/*  AA        */  PACK( 1, 0 ),
/*  FlipPT    */  PACK( 0, 0 ),
/*  FlipRgON  */  PACK( 2, 0 ),
/*  FlipRgOFF */  PACK( 2, 0 ),
/*  INS_$83   */  PACK( 0, 0 ),
/*  INS_$84   */  PACK( 0, 0 ),
/*  ScanCTRL  */  PACK( 1, 0 ),
/*  SDVPTL[0] */  PACK( 2, 0 ),
/*  SDVPTL[1] */  PACK( 2, 0 ),
/*  GetINFO   */  PACK( 1, 1 ),
/*  IDEF      */  PACK( 1, 0 ),
/*  ROLL      */  PACK( 3, 3 ),
/*  MAX       */  PACK( 2, 1 ),
/*  MIN       */  PACK( 2, 1 ),
/*  ScanTYPE  */  PACK( 1, 0 ),
/*  InstCTRL  */  PACK( 2, 0 ),
/*  INS_$8F   */  PACK( 0, 0 ),
/*  INS_$90  */   PACK( 0, 0 ),
/*  INS_$91  */   PACK( 0, 0 ),
/*  INS_$92  */   PACK( 0, 0 ),
/*  INS_$93  */   PACK( 0, 0 ),
/*  INS_$94  */   PACK( 0, 0 ),
/*  INS_$95  */   PACK( 0, 0 ),
/*  INS_$96  */   PACK( 0, 0 ),
/*  INS_$97  */   PACK( 0, 0 ),
/*  INS_$98  */   PACK( 0, 0 ),
/*  INS_$99  */   PACK( 0, 0 ),
/*  INS_$9A  */   PACK( 0, 0 ),
/*  INS_$9B  */   PACK( 0, 0 ),
/*  INS_$9C  */   PACK( 0, 0 ),
/*  INS_$9D  */   PACK( 0, 0 ),
/*  INS_$9E  */   PACK( 0, 0 ),
/*  INS_$9F  */   PACK( 0, 0 ),
/*  INS_$A0  */   PACK( 0, 0 ),
/*  INS_$A1  */   PACK( 0, 0 ),
/*  INS_$A2  */   PACK( 0, 0 ),
/*  INS_$A3  */   PACK( 0, 0 ),
/*  INS_$A4  */   PACK( 0, 0 ),
/*  INS_$A5  */   PACK( 0, 0 ),
/*  INS_$A6  */   PACK( 0, 0 ),
/*  INS_$A7  */   PACK( 0, 0 ),
/*  INS_$A8  */   PACK( 0, 0 ),
/*  INS_$A9  */   PACK( 0, 0 ),
/*  INS_$AA  */   PACK( 0, 0 ),
/*  INS_$AB  */   PACK( 0, 0 ),
/*  INS_$AC  */   PACK( 0, 0 ),
/*  INS_$AD  */   PACK( 0, 0 ),
/*  INS_$AE  */   PACK( 0, 0 ),
/*  INS_$AF  */   PACK( 0, 0 ),
/*  PushB[0]  */  PACK( 0, 1 ),
/*  PushB[1]  */  PACK( 0, 2 ),
/*  PushB[2]  */  PACK( 0, 3 ),
/*  PushB[3]  */  PACK( 0, 4 ),
/*  PushB[4]  */  PACK( 0, 5 ),
/*  PushB[5]  */  PACK( 0, 6 ),
/*  PushB[6]  */  PACK( 0, 7 ),
/*  PushB[7]  */  PACK( 0, 8 ),
/*  PushW[0]  */  PACK( 0, 1 ),
/*  PushW[1]  */  PACK( 0, 2 ),
/*  PushW[2]  */  PACK( 0, 3 ),
/*  PushW[3]  */  PACK( 0, 4 ),
/*  PushW[4]  */  PACK( 0, 5 ),
/*  PushW[5]  */  PACK( 0, 6 ),
/*  PushW[6]  */  PACK( 0, 7 ),
/*  PushW[7]  */  PACK( 0, 8 ),
/*  MDRP[00]  */  PACK( 1, 0 ),
/*  MDRP[01]  */  PACK( 1, 0 ),
/*  MDRP[02]  */  PACK( 1, 0 ),
/*  MDRP[03]  */  PACK( 1, 0 ),
/*  MDRP[04]  */  PACK( 1, 0 ),
/*  MDRP[05]  */  PACK( 1, 0 ),
/*  MDRP[06]  */  PACK( 1, 0 ),
/*  MDRP[07]  */  PACK( 1, 0 ),
/*  MDRP[08]  */  PACK( 1, 0 ),
/*  MDRP[09]  */  PACK( 1, 0 ),
/*  MDRP[10]  */  PACK( 1, 0 ),
/*  MDRP[11]  */  PACK( 1, 0 ),
/*  MDRP[12]  */  PACK( 1, 0 ),
/*  MDRP[13]  */  PACK( 1, 0 ),
/*  MDRP[14]  */  PACK( 1, 0 ),
/*  MDRP[15]  */  PACK( 1, 0 ),
/*  MDRP[16]  */  PACK( 1, 0 ),
/*  MDRP[17]  */  PACK( 1, 0 ),
/*  MDRP[18]  */  PACK( 1, 0 ),
/*  MDRP[19]  */  PACK( 1, 0 ),
/*  MDRP[20]  */  PACK( 1, 0 ),
/*  MDRP[21]  */  PACK( 1, 0 ),
/*  MDRP[22]  */  PACK( 1, 0 ),
/*  MDRP[23]  */  PACK( 1, 0 ),
/*  MDRP[24]  */  PACK( 1, 0 ),
/*  MDRP[25]  */  PACK( 1, 0 ),
/*  MDRP[26]  */  PACK( 1, 0 ),
/*  MDRP[27]  */  PACK( 1, 0 ),
/*  MDRP[28]  */  PACK( 1, 0 ),
/*  MDRP[29]  */  PACK( 1, 0 ),
/*  MDRP[30]  */  PACK( 1, 0 ),
/*  MDRP[31]  */  PACK( 1, 0 ),
/*  MIRP[00]  */  PACK( 2, 0 ),
/*  MIRP[01]  */  PACK( 2, 0 ),
/*  MIRP[02]  */  PACK( 2, 0 ),
/*  MIRP[03]  */  PACK( 2, 0 ),
/*  MIRP[04]  */  PACK( 2, 0 ),
/*  MIRP[05]  */  PACK( 2, 0 ),
/*  MIRP[06]  */  PACK( 2, 0 ),
/*  MIRP[07]  */  PACK( 2, 0 ),
/*  MIRP[08]  */  PACK( 2, 0 ),
/*  MIRP[09]  */  PACK( 2, 0 ),
/*  MIRP[10]  */  PACK( 2, 0 ),
/*  MIRP[11]  */  PACK( 2, 0 ),
/*  MIRP[12]  */  PACK( 2, 0 ),
/*  MIRP[13]  */  PACK( 2, 0 ),
/*  MIRP[14]  */  PACK( 2, 0 ),
/*  MIRP[15]  */  PACK( 2, 0 ),
/*  MIRP[16]  */  PACK( 2, 0 ),
/*  MIRP[17]  */  PACK( 2, 0 ),
/*  MIRP[18]  */  PACK( 2, 0 ),
/*  MIRP[19]  */  PACK( 2, 0 ),
/*  MIRP[20]  */  PACK( 2, 0 ),
/*  MIRP[21]  */  PACK( 2, 0 ),
/*  MIRP[22]  */  PACK( 2, 0 ),
/*  MIRP[23]  */  PACK( 2, 0 ),
/*  MIRP[24]  */  PACK( 2, 0 ),
/*  MIRP[25]  */  PACK( 2, 0 ),
/*  MIRP[26]  */  PACK( 2, 0 ),
/*  MIRP[27]  */  PACK( 2, 0 ),
/*  MIRP[28]  */  PACK( 2, 0 ),
/*  MIRP[29]  */  PACK( 2, 0 ),
/*  MIRP[30]  */  PACK( 2, 0 ),
/*  MIRP[31]  */  PACK( 2, 0 )
/* FT_DEBUG_LEVEL_TRACE */
/* rounding */
/* compute (a*b)/2^14 with maximal accuracy and rounding */
/* compute ax*bx as 64-bit value */
/* divide the result by 2^14 with rounding */
/* compute (ax*bx+ay*by)/2^14 with maximal accuracy and rounding */
/* compute ax*bx as 64-bit value */
/* compute ay*by as 64-bit value */
/* add them */
/* divide the result by 2^14 with rounding */
/* return length of given vector */
/* compute x*x as 64-bit value */
/* compute y*y as 64-bit value */
/* add them to get 'x*x+y*y' as 64-bit value */
/* compute the square root of this value */
/* this version uses FT_Vector_Length which computes the same value */
/* much, much faster..                                              */
/*                                                                  */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Current_Ratio                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Returns the current aspect ratio scaling factor depending on the   */
/*    projection vector's state and device resolutions.                  */
/*                                                                       */
/* <Return>                                                              */
/*    The aspect ratio in 16.16 format, always <= 1.0 .                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* Functions related to the control value table (CVT).                   */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    GetShortIns                                                        */
/*                                                                       */
/* <Description>                                                         */
/*    Returns a short integer taken from the instruction stream at       */
/*    address IP.                                                        */
/*                                                                       */
/* <Return>                                                              */
/*    Short read at code[IP].                                            */
/*                                                                       */
/* <Note>                                                                */
/*    This one could become a macro.                                     */
/*                                                                       */
/* Reading a byte stream so there is no endianess (DaveP) */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Ins_Goto_CodeRange                                                 */
/*                                                                       */
/* <Description>                                                         */
/*    Goes to a certain code range in the instruction stream.            */
/*                                                                       */
/* <Input>                                                               */
/*    aRange :: The index of the code range.                             */
/*                                                                       */
/*    aIP    :: The new IP address in the code range.                    */
/*                                                                       */
/* <Return>                                                              */
/*    SUCCESS or FAILURE.                                                */
/*                                                                       */
/* invalid coderange */
/* NOTE: Because the last instruction of a program may be a CALL */
/*       which will return to the first byte *after* the code    */
/*       range, we test for AIP <= Size, instead of AIP < Size.  */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Direct_Move                                                        */
/*                                                                       */
/* <Description>                                                         */
/*    Moves a point by a given distance along the freedom vector.  The   */
/*    point will be `touched'.                                           */
/*                                                                       */
/* <Input>                                                               */
/*    point    :: The index of the point to move.                        */
/*                                                                       */
/*    distance :: The distance to apply.                                 */
/*                                                                       */
/* <InOut>                                                               */
/*    zone     :: The affected glyph zone.                               */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Direct_Move_Orig                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Moves the *original* position of a point by a given distance along */
/*    the freedom vector.  Obviously, the point will not be `touched'.   */
/*                                                                       */
/* <Input>                                                               */
/*    point    :: The index of the point to move.                        */
/*                                                                       */
/*    distance :: The distance to apply.                                 */
/*                                                                       */
/* <InOut>                                                               */
/*    zone     :: The affected glyph zone.                               */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* Special versions of Direct_Move()                                     */
/*                                                                       */
/*   The following versions are used whenever both vectors are both      */
/*   along one of the coordinate unit vectors, i.e. in 90% of the cases. */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* Special versions of Direct_Move_Orig()                                */
/*                                                                       */
/*   The following versions are used whenever both vectors are both      */
/*   along one of the coordinate unit vectors, i.e. in 90% of the cases. */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Round_None                                                         */
/*                                                                       */
/* <Description>                                                         */
/*    Does not round, but adds engine compensation.                      */
/*                                                                       */
/* <Input>                                                               */
/*    distance     :: The distance (not) to round.                       */
/*                                                                       */
/*    compensation :: The engine compensation.                           */
/*                                                                       */
/* <Return>                                                              */
/*    The compensated distance.                                          */
/*                                                                       */
/* <Note>                                                                */
/*    The TrueType specification says very few about the relationship    */
/*    between rounding and engine compensation.  However, it seems from  */
/*    the description of super round that we should add the compensation */
/*    before rounding.                                                   */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Round_To_Grid                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Rounds value to grid after adding engine compensation.             */
/*                                                                       */
/* <Input>                                                               */
/*    distance     :: The distance to round.                             */
/*                                                                       */
/*    compensation :: The engine compensation.                           */
/*                                                                       */
/* <Return>                                                              */
/*    Rounded distance.                                                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Round_To_Half_Grid                                                 */
/*                                                                       */
/* <Description>                                                         */
/*    Rounds value to half grid after adding engine compensation.        */
/*                                                                       */
/* <Input>                                                               */
/*    distance     :: The distance to round.                             */
/*                                                                       */
/*    compensation :: The engine compensation.                           */
/*                                                                       */
/* <Return>                                                              */
/*    Rounded distance.                                                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Round_Down_To_Grid                                                 */
/*                                                                       */
/* <Description>                                                         */
/*    Rounds value down to grid after adding engine compensation.        */
/*                                                                       */
/* <Input>                                                               */
/*    distance     :: The distance to round.                             */
/*                                                                       */
/*    compensation :: The engine compensation.                           */
/*                                                                       */
/* <Return>                                                              */
/*    Rounded distance.                                                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Round_Up_To_Grid                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Rounds value up to grid after adding engine compensation.          */
/*                                                                       */
/* <Input>                                                               */
/*    distance     :: The distance to round.                             */
/*                                                                       */
/*    compensation :: The engine compensation.                           */
/*                                                                       */
/* <Return>                                                              */
/*    Rounded distance.                                                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Round_To_Double_Grid                                               */
/*                                                                       */
/* <Description>                                                         */
/*    Rounds value to double grid after adding engine compensation.      */
/*                                                                       */
/* <Input>                                                               */
/*    distance     :: The distance to round.                             */
/*                                                                       */
/*    compensation :: The engine compensation.                           */
/*                                                                       */
/* <Return>                                                              */
/*    Rounded distance.                                                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Round_Super                                                        */
/*                                                                       */
/* <Description>                                                         */
/*    Super-rounds value to grid after adding engine compensation.       */
/*                                                                       */
/* <Input>                                                               */
/*    distance     :: The distance to round.                             */
/*                                                                       */
/*    compensation :: The engine compensation.                           */
/*                                                                       */
/* <Return>                                                              */
/*    Rounded distance.                                                  */
/*                                                                       */
/* <Note>                                                                */
/*    The TrueType specification says very few about the relationship    */
/*    between rounding and engine compensation.  However, it seems from  */
/*    the description of super round that we should add the compensation */
/*    before rounding.                                                   */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Round_Super_45                                                     */
/*                                                                       */
/* <Description>                                                         */
/*    Super-rounds value to grid after adding engine compensation.       */
/*                                                                       */
/* <Input>                                                               */
/*    distance     :: The distance to round.                             */
/*                                                                       */
/*    compensation :: The engine compensation.                           */
/*                                                                       */
/* <Return>                                                              */
/*    Rounded distance.                                                  */
/*                                                                       */
/* <Note>                                                                */
/*    There is a separate function for Round_Super_45() as we may need   */
/*    greater precision.                                                 */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Compute_Round                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Sets the rounding mode.                                            */
/*                                                                       */
/* <Input>                                                               */
/*    round_mode :: The rounding mode to be used.                        */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    SetSuperRound                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Sets Super Round parameters.                                       */
/*                                                                       */
/* <Input>                                                               */
/*    GridPeriod :: Grid period                                          */
/*    selector   :: SROUND opcode                                        */
/*                                                                       */
/* This opcode is reserved, but... */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Project                                                            */
/*                                                                       */
/* <Description>                                                         */
/*    Computes the projection of vector given by (v2-v1) along the       */
/*    current projection vector.                                         */
/*                                                                       */
/* <Input>                                                               */
/*    v1 :: First input vector.                                          */
/*    v2 :: Second input vector.                                         */
/*                                                                       */
/* <Return>                                                              */
/*    The distance in F26dot6 format.                                    */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Dual_Project                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    Computes the projection of the vector given by (v2-v1) along the   */
/*    current dual vector.                                               */
/*                                                                       */
/* <Input>                                                               */
/*    v1 :: First input vector.                                          */
/*    v2 :: Second input vector.                                         */
/*                                                                       */
/* <Return>                                                              */
/*    The distance in F26dot6 format.                                    */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Project_x                                                          */
/*                                                                       */
/* <Description>                                                         */
/*    Computes the projection of the vector given by (v2-v1) along the   */
/*    horizontal axis.                                                   */
/*                                                                       */
/* <Input>                                                               */
/*    v1 :: First input vector.                                          */
/*    v2 :: Second input vector.                                         */
/*                                                                       */
/* <Return>                                                              */
/*    The distance in F26dot6 format.                                    */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Project_y                                                          */
/*                                                                       */
/* <Description>                                                         */
/*    Computes the projection of the vector given by (v2-v1) along the   */
/*    vertical axis.                                                     */
/*                                                                       */
/* <Input>                                                               */
/*    v1 :: First input vector.                                          */
/*    v2 :: Second input vector.                                         */
/*                                                                       */
/* <Return>                                                              */
/*    The distance in F26dot6 format.                                    */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Compute_Funcs                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Computes the projection and movement function pointers according   */
/*    to the current graphics state.                                     */
/*                                                                       */
/* If both vectors point rightwards along the x axis, set             */
/* `both-x-axis' true, otherwise set it false.  The x values only     */
/* need be tested because the vector has been normalised to a unit    */
/* vector of length 0x4000 = unity.                                   */
/* Throw away projection and freedom vector information */
/* because the patents don't allow them to be stored.   */
/* The relevant US Patents are 5155805 and 5325479.     */
/* Force recalculation of cached aspect ratio */
/* TT_CONFIG_OPTION_UNPATENTED_HINTING */
/* at small sizes, F_dot_P can become too small, resulting   */
/* in overflows and `spikes' in a number of glyphs like `w'. */
/* Disable cached aspect ratio */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Normalize                                                          */
/*                                                                       */
/* <Description>                                                         */
/*    Norms a vector.                                                    */
/*                                                                       */
/* <Input>                                                               */
/*    Vx :: The horizontal input vector coordinate.                      */
/*    Vy :: The vertical input vector coordinate.                        */
/*                                                                       */
/* <Output>                                                              */
/*    R  :: The normed unit vector.                                      */
/*                                                                       */
/* <Return>                                                              */
/*    Returns FAILURE if a vector parameter is zero.                     */
/*                                                                       */
/* <Note>                                                                */
/*    In case Vx and Vy are both zero, Normalize() returns SUCCESS, and  */
/*    R is undefined.                                                    */
/*                                                                       */
/* XXX: UNDOCUMENTED! It seems that it is possible to try   */
/*      to normalize the vector (0,0).  Return immediately. */
/* Now, we want that Sqrt( W ) = 0x4000 */
/* Or 0x10000000 <= W < 0x10004000        */
/* We need to increase W by a minimal amount */
/* We need to decrease W by a minimal amount */
/* Note that in various cases, we can only  */
/* compute a Sqrt(W) of 0x3FFF, eg. Vx = Vy */
/* Type conversion */
/* Type conversion */
/*************************************************************************/
/*                                                                       */
/* Here we start with the implementation of the various opcodes.         */
/*                                                                       */
/*************************************************************************/
/* counter clockwise rotation */
/* When not using the big switch statements, the interpreter uses a */
/* call table defined later below in this source.  Each opcode must */
/* thus have a corresponding function, even trivial ones.           */
/*                                                                  */
/* They are all defined there.                                      */
/* Only use low 16bits, then sign extend */ \
/* Only use low 16bits, then sign extend */ \
/* XXX: UNDOCUMENTED! or bug in the Windows engine?   */
/*                                                    */
/*      It seems that the value that is read here is  */
/*      expressed in 16.16 format rather than in font */
/*      units.                                        */
/*                                                    */
/* nothing */
/* Note: The pointSize should be irrelevant in a given font program; */
/*       we thus decide to return only the ppem.                     */
/* 0 */
/*************************************************************************/
/*                                                                       */
/* SVTCA[a]:     Set (F and P) Vectors to Coordinate Axis                */
/* Opcode range: 0x00-0x01                                               */
/* Stack:        -->                                                     */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SPVTCA[a]:    Set PVector to Coordinate Axis                          */
/* Opcode range: 0x02-0x03                                               */
/* Stack:        -->                                                     */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SFVTCA[a]:    Set FVector to Coordinate Axis                          */
/* Opcode range: 0x04-0x05                                               */
/* Stack:        -->                                                     */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SPVTL[a]:     Set PVector To Line                                     */
/* Opcode range: 0x06-0x07                                               */
/* Stack:        uint32 uint32 -->                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SFVTL[a]:     Set FVector To Line                                     */
/* Opcode range: 0x08-0x09                                               */
/* Stack:        uint32 uint32 -->                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SFVTPV[]:     Set FVector To PVector                                  */
/* Opcode range: 0x0E                                                    */
/* Stack:        -->                                                     */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SPVFS[]:      Set PVector From Stack                                  */
/* Opcode range: 0x0A                                                    */
/* Stack:        f2.14 f2.14 -->                                         */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SFVFS[]:      Set FVector From Stack                                  */
/* Opcode range: 0x0B                                                    */
/* Stack:        f2.14 f2.14 -->                                         */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* GPV[]:        Get Projection Vector                                   */
/* Opcode range: 0x0C                                                    */
/* Stack:        ef2.14 --> ef2.14                                       */
/*                                                                       */
/*************************************************************************/
/* GFV[]:        Get Freedom Vector                                      */
/* Opcode range: 0x0D                                                    */
/* Stack:        ef2.14 --> ef2.14                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SRP0[]:       Set Reference Point 0                                   */
/* Opcode range: 0x10                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SRP1[]:       Set Reference Point 1                                   */
/* Opcode range: 0x11                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SRP2[]:       Set Reference Point 2                                   */
/* Opcode range: 0x12                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* RTHG[]:       Round To Half Grid                                      */
/* Opcode range: 0x19                                                    */
/* Stack:        -->                                                     */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* RTG[]:        Round To Grid                                           */
/* Opcode range: 0x18                                                    */
/* Stack:        -->                                                     */
/*                                                                       */
/*************************************************************************/
/* RTDG[]:       Round To Double Grid                                    */
/* Opcode range: 0x3D                                                    */
/* Stack:        -->                                                     */
/*                                                                       */
/*************************************************************************/
/* RUTG[]:       Round Up To Grid                                        */
/* Opcode range: 0x7C                                                    */
/* Stack:        -->                                                     */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* RDTG[]:       Round Down To Grid                                      */
/* Opcode range: 0x7D                                                    */
/* Stack:        -->                                                     */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* ROFF[]:       Round OFF                                               */
/* Opcode range: 0x7A                                                    */
/* Stack:        -->                                                     */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SROUND[]:     Super ROUND                                             */
/* Opcode range: 0x76                                                    */
/* Stack:        Eint8 -->                                               */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* S45ROUND[]:   Super ROUND 45 degrees                                  */
/* Opcode range: 0x77                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SLOOP[]:      Set LOOP variable                                       */
/* Opcode range: 0x17                                                    */
/* Stack:        int32? -->                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SMD[]:        Set Minimum Distance                                    */
/* Opcode range: 0x1A                                                    */
/* Stack:        f26.6 -->                                               */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SCVTCI[]:     Set Control Value Table Cut In                          */
/* Opcode range: 0x1D                                                    */
/* Stack:        f26.6 -->                                               */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SSWCI[]:      Set Single Width Cut In                                 */
/* Opcode range: 0x1E                                                    */
/* Stack:        f26.6 -->                                               */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SSW[]:        Set Single Width                                        */
/* Opcode range: 0x1F                                                    */
/* Stack:        int32? -->                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* FLIPON[]:     Set auto-FLIP to ON                                     */
/* Opcode range: 0x4D                                                    */
/* Stack:        -->                                                     */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* FLIPOFF[]:    Set auto-FLIP to OFF                                    */
/* Opcode range: 0x4E                                                    */
/* Stack: -->                                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SANGW[]:      Set ANGle Weight                                        */
/* Opcode range: 0x7E                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/* instruction not supported anymore */
/*************************************************************************/
/*                                                                       */
/* SDB[]:        Set Delta Base                                          */
/* Opcode range: 0x5E                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SDS[]:        Set Delta Shift                                         */
/* Opcode range: 0x5F                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* MPPEM[]:      Measure Pixel Per EM                                    */
/* Opcode range: 0x4B                                                    */
/* Stack:        --> Euint16                                             */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* MPS[]:        Measure Point Size                                      */
/* Opcode range: 0x4C                                                    */
/* Stack:        --> Euint16                                             */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* DUP[]:        DUPlicate the top stack's element                       */
/* Opcode range: 0x20                                                    */
/* Stack:        StkElt --> StkElt StkElt                                */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* POP[]:        POP the stack's top element                             */
/* Opcode range: 0x21                                                    */
/* Stack:        StkElt -->                                              */
/*                                                                       */
/* nothing to do */
/*************************************************************************/
/*                                                                       */
/* CLEAR[]:      CLEAR the entire stack                                  */
/* Opcode range: 0x22                                                    */
/* Stack:        StkElt... -->                                           */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SWAP[]:       SWAP the stack's top two elements                       */
/* Opcode range: 0x23                                                    */
/* Stack:        2 * StkElt --> 2 * StkElt                               */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* DEPTH[]:      return the stack DEPTH                                  */
/* Opcode range: 0x24                                                    */
/* Stack:        --> uint32                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* CINDEX[]:     Copy INDEXed element                                    */
/* Opcode range: 0x25                                                    */
/* Stack:        int32 --> StkElt                                        */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* EIF[]:        End IF                                                  */
/* Opcode range: 0x59                                                    */
/* Stack:        -->                                                     */
/*                                                                       */
/* nothing to do */
/*************************************************************************/
/*                                                                       */
/* JROT[]:       Jump Relative On True                                   */
/* Opcode range: 0x78                                                    */
/* Stack:        StkElt int32 -->                                        */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* JMPR[]:       JuMP Relative                                           */
/* Opcode range: 0x1C                                                    */
/* Stack:        int32 -->                                               */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* JROF[]:       Jump Relative On False                                  */
/* Opcode range: 0x79                                                    */
/* Stack:        StkElt int32 -->                                        */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* LT[]:         Less Than                                               */
/* Opcode range: 0x50                                                    */
/* Stack:        int32? int32? --> bool                                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* LTEQ[]:       Less Than or EQual                                      */
/* Opcode range: 0x51                                                    */
/* Stack:        int32? int32? --> bool                                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* GT[]:         Greater Than                                            */
/* Opcode range: 0x52                                                    */
/* Stack:        int32? int32? --> bool                                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* GTEQ[]:       Greater Than or EQual                                   */
/* Opcode range: 0x53                                                    */
/* Stack:        int32? int32? --> bool                                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* EQ[]:         EQual                                                   */
/* Opcode range: 0x54                                                    */
/* Stack:        StkElt StkElt --> bool                                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* NEQ[]:        Not EQual                                               */
/* Opcode range: 0x55                                                    */
/* Stack:        StkElt StkElt --> bool                                  */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* ODD[]:        Is ODD                                                  */
/* Opcode range: 0x56                                                    */
/* Stack:        f26.6 --> bool                                          */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* EVEN[]:       Is EVEN                                                 */
/* Opcode range: 0x57                                                    */
/* Stack:        f26.6 --> bool                                          */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* AND[]:        logical AND                                             */
/* Opcode range: 0x5A                                                    */
/* Stack:        uint32 uint32 --> uint32                                */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* OR[]:         logical OR                                              */
/* Opcode range: 0x5B                                                    */
/* Stack:        uint32 uint32 --> uint32                                */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* NOT[]:        logical NOT                                             */
/* Opcode range: 0x5C                                                    */
/* Stack:        StkElt --> uint32                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* ADD[]:        ADD                                                     */
/* Opcode range: 0x60                                                    */
/* Stack:        f26.6 f26.6 --> f26.6                                   */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SUB[]:        SUBtract                                                */
/* Opcode range: 0x61                                                    */
/* Stack:        f26.6 f26.6 --> f26.6                                   */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* DIV[]:        DIVide                                                  */
/* Opcode range: 0x62                                                    */
/* Stack:        f26.6 f26.6 --> f26.6                                   */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* MUL[]:        MULtiply                                                */
/* Opcode range: 0x63                                                    */
/* Stack:        f26.6 f26.6 --> f26.6                                   */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* ABS[]:        ABSolute value                                          */
/* Opcode range: 0x64                                                    */
/* Stack:        f26.6 --> f26.6                                         */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* NEG[]:        NEGate                                                  */
/* Opcode range: 0x65                                                    */
/* Stack: f26.6 --> f26.6                                                */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* FLOOR[]:      FLOOR                                                   */
/* Opcode range: 0x66                                                    */
/* Stack:        f26.6 --> f26.6                                         */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* CEILING[]:    CEILING                                                 */
/* Opcode range: 0x67                                                    */
/* Stack:        f26.6 --> f26.6                                         */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* RS[]:         Read Store                                              */
/* Opcode range: 0x43                                                    */
/* Stack:        uint32 --> uint32                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* WS[]:         Write Store                                             */
/* Opcode range: 0x42                                                    */
/* Stack:        uint32 uint32 -->                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* WCVTP[]:      Write CVT in Pixel units                                */
/* Opcode range: 0x44                                                    */
/* Stack:        f26.6 uint32 -->                                        */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* WCVTF[]:      Write CVT in Funits                                     */
/* Opcode range: 0x70                                                    */
/* Stack:        uint32 uint32 -->                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* RCVT[]:       Read CVT                                                */
/* Opcode range: 0x45                                                    */
/* Stack:        uint32 --> f26.6                                        */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* AA[]:         Adjust Angle                                            */
/* Opcode range: 0x7F                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/* intentionally no longer supported */
/*************************************************************************/
/*                                                                       */
/* DEBUG[]:      DEBUG.  Unsupported.                                    */
/* Opcode range: 0x4F                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/* Note: The original instruction pops a value from the stack.           */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* ROUND[ab]:    ROUND value                                             */
/* Opcode range: 0x68-0x6B                                               */
/* Stack:        f26.6 --> f26.6                                         */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* NROUND[ab]:   No ROUNDing of value                                    */
/* Opcode range: 0x6C-0x6F                                               */
/* Stack:        f26.6 --> f26.6                                         */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* MAX[]:        MAXimum                                                 */
/* Opcode range: 0x68                                                    */
/* Stack:        int32? int32? --> int32                                 */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* MIN[]:        MINimum                                                 */
/* Opcode range: 0x69                                                    */
/* Stack:        int32? int32? --> int32                                 */
/*                                                                       */
/* !TT_CONFIG_OPTION_INTERPRETER_SWITCH */
/*************************************************************************/
/*                                                                       */
/* The following functions are called as is within the switch statement. */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* MINDEX[]:     Move INDEXed element                                    */
/* Opcode range: 0x26                                                    */
/* Stack:        int32? --> StkElt                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* ROLL[]:       ROLL top three elements                                 */
/* Opcode range: 0x8A                                                    */
/* Stack:        3 * StkElt --> 3 * StkElt                               */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* MANAGING THE FLOW OF CONTROL                                          */
/*                                                                       */
/*   Instructions appear in the specification's order.                   */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* IF[]:         IF test                                                 */
/* Opcode range: 0x58                                                    */
/* Stack:        StkElt -->                                              */
/*                                                                       */
/* IF */
/* ELSE */
/* EIF */
/*************************************************************************/
/*                                                                       */
/* ELSE[]:       ELSE                                                    */
/* Opcode range: 0x1B                                                    */
/* Stack:        -->                                                     */
/*                                                                       */
/* IF */
/* EIF */
/*************************************************************************/
/*                                                                       */
/* DEFINING AND USING FUNCTIONS AND INSTRUCTIONS                         */
/*                                                                       */
/*   Instructions appear in the specification's order.                   */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* FDEF[]:       Function DEFinition                                     */
/* Opcode range: 0x2C                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/* some font programs are broken enough to redefine functions! */
/* We will then parse the current table.                       */
/* check that there is enough room for new functions */
/* Although FDEF takes unsigned 32-bit integer,  */
/* func # must be within unsigned 16-bit integer */
/* Now skip the whole function definition. */
/* We don't allow nested IDEFS & FDEFs.    */
/* IDEF */
/* FDEF */
/* ENDF */
/*************************************************************************/
/*                                                                       */
/* ENDF[]:       END Function definition                                 */
/* Opcode range: 0x2D                                                    */
/* Stack:        -->                                                     */
/*                                                                       */
/* We encountered an ENDF without a call */
/* Loop through the current function */
/* Exit the current call frame.                      */
/* NOTE: If the last instruction of a program is a   */
/*       CALL or LOOPCALL, the return address is     */
/*       always out of the code range.  This is a    */
/*       valid address, and it is why we do not test */
/*       the result of Ins_Goto_CodeRange() here!    */
/*************************************************************************/
/*                                                                       */
/* CALL[]:       CALL function                                           */
/* Opcode range: 0x2B                                                    */
/* Stack:        uint32? -->                                             */
/*                                                                       */
/* first of all, check the index */
/* Except for some old Apple fonts, all functions in a TrueType */
/* font are defined in increasing order, starting from 0.  This */
/* means that we normally have                                  */
/*                                                              */
/*    CUR.maxFunc+1 == CUR.numFDefs                             */
/*    CUR.FDefs[n].opc == n for n in 0..CUR.maxFunc             */
/*                                                              */
/* If this isn't true, we need to look up the function table.   */
/* look up the FDefs table */
/* check that the function is active */
/* check the call stack */
/*************************************************************************/
/*                                                                       */
/* LOOPCALL[]:   LOOP and CALL function                                  */
/* Opcode range: 0x2A                                                    */
/* Stack:        uint32? Eint16? -->                                     */
/*                                                                       */
/* first of all, check the index */
/* Except for some old Apple fonts, all functions in a TrueType */
/* font are defined in increasing order, starting from 0.  This */
/* means that we normally have                                  */
/*                                                              */
/*    CUR.maxFunc+1 == CUR.numFDefs                             */
/*    CUR.FDefs[n].opc == n for n in 0..CUR.maxFunc             */
/*                                                              */
/* If this isn't true, we need to look up the function table.   */
/* look up the FDefs table */
/* check that the function is active */
/* check stack */
/*************************************************************************/
/*                                                                       */
/* IDEF[]:       Instruction DEFinition                                  */
/* Opcode range: 0x89                                                    */
/* Stack:        Eint8 -->                                               */
/*                                                                       */
/*  First of all, look for the same function in our table */
/* check that there is enough room for a new instruction */
/* opcode must be unsigned 8-bit integer */
/* Now skip the whole function definition. */
/* We don't allow nested IDEFs & FDEFs.    */
/* IDEF */
/* FDEF */
/* ENDF */
/*************************************************************************/
/*                                                                       */
/* PUSHING DATA ONTO THE INTERPRETER STACK                               */
/*                                                                       */
/*   Instructions appear in the specification's order.                   */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* NPUSHB[]:     PUSH N Bytes                                            */
/* Opcode range: 0x40                                                    */
/* Stack:        --> uint32...                                           */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* NPUSHW[]:     PUSH N Words                                            */
/* Opcode range: 0x41                                                    */
/* Stack:        --> int32...                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* PUSHB[abc]:   PUSH Bytes                                              */
/* Opcode range: 0xB0-0xB7                                               */
/* Stack:        --> uint32...                                           */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* PUSHW[abc]:   PUSH Words                                              */
/* Opcode range: 0xB8-0xBF                                               */
/* Stack:        --> int32...                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* MANAGING THE GRAPHICS STATE                                           */
/*                                                                       */
/*  Instructions appear in the specs' order.                             */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* GC[a]:        Get Coordinate projected onto                           */
/* Opcode range: 0x46-0x47                                               */
/* Stack:        uint32 --> f26.6                                        */
/*                                                                       */
/* BULLSHIT: Measures from the original glyph must be taken along the    */
/*           dual projection vector!                                     */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SCFS[]:       Set Coordinate From Stack                               */
/* Opcode range: 0x48                                                    */
/* Stack:        f26.6 uint32 -->                                        */
/*                                                                       */
/* Formula:                                                              */
/*                                                                       */
/*   OA := OA + ( value - OA.p )/( f.p ) * f                             */
/*                                                                       */
/* not part of the specs, but here for safety */
/*************************************************************************/
/*                                                                       */
/* MD[a]:        Measure Distance                                        */
/* Opcode range: 0x49-0x4A                                               */
/* Stack:        uint32 uint32 --> f26.6                                 */
/*                                                                       */
/* BULLSHIT: Measure taken in the original glyph must be along the dual  */
/*           projection vector.                                          */
/*                                                                       */
/* Second BULLSHIT: Flag attributes are inverted!                        */
/*                  0 => measure distance in original outline            */
/*                  1 => measure distance in grid-fitted outline         */
/*                                                                       */
/* Third one: `zp0 - zp1', and not `zp2 - zp1!                           */
/*                                                                       */
/* this should be faster */
/*************************************************************************/
/*                                                                       */
/* SDPVTL[a]:    Set Dual PVector to Line                                */
/* Opcode range: 0x86-0x87                                               */
/* Stack:        uint32 uint32 -->                                       */
/*                                                                       */
/* was FT_Int in pas type ERROR */
/* counter clockwise rotation */
/* counter clockwise rotation */
/*************************************************************************/
/*                                                                       */
/* SZP0[]:       Set Zone Pointer 0                                      */
/* Opcode range: 0x13                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SZP1[]:       Set Zone Pointer 1                                      */
/* Opcode range: 0x14                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SZP2[]:       Set Zone Pointer 2                                      */
/* Opcode range: 0x15                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SZPS[]:       Set Zone PointerS                                       */
/* Opcode range: 0x16                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* INSTCTRL[]:   INSTruction ConTRoL                                     */
/* Opcode range: 0x8e                                                    */
/* Stack:        int32 int32 -->                                         */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SCANCTRL[]:   SCAN ConTRoL                                            */
/* Opcode range: 0x85                                                    */
/* Stack:        uint32? -->                                             */
/*                                                                       */
/* Get Threshold */
/*************************************************************************/
/*                                                                       */
/* SCANTYPE[]:   SCAN TYPE                                               */
/* Opcode range: 0x8D                                                    */
/* Stack:        uint32? -->                                             */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* MANAGING OUTLINES                                                     */
/*                                                                       */
/*   Instructions appear in the specification's order.                   */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* FLIPPT[]:     FLIP PoinT                                              */
/* Opcode range: 0x80                                                    */
/* Stack:        uint32... -->                                           */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* FLIPRGON[]:   FLIP RanGe ON                                           */
/* Opcode range: 0x81                                                    */
/* Stack:        uint32 uint32 -->                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* FLIPRGOFF:    FLIP RanGe OFF                                          */
/* Opcode range: 0x82                                                    */
/* Stack:        uint32 uint32 -->                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* SHP[a]:       SHift Point by the last point                           */
/* Opcode range: 0x32-0x33                                               */
/* Stack:        uint32... -->                                           */
/*                                                                       */
/* XXX: UNDOCUMENTED! SHP touches the points */
/*************************************************************************/
/*                                                                       */
/* SHC[a]:       SHift Contour                                           */
/* Opcode range: 0x34-35                                                 */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/* XXX: this is probably wrong... at least it prevents memory */
/*      corruption when zp2 is the twilight zone              */
/* XXX: UNDOCUMENTED! SHC touches the points */
/*************************************************************************/
/*                                                                       */
/* SHZ[a]:       SHift Zone                                              */
/* Opcode range: 0x36-37                                                 */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/* XXX: UNDOCUMENTED! SHZ doesn't move the phantom points.  */
/*      Twilight zone has no contours, so use `n_points'.   */
/*      Normal zone's `n_points' includes phantoms, so must */
/*      use end of last contour.                            */
/* XXX: UNDOCUMENTED! SHZ doesn't touch the points */
/*************************************************************************/
/*                                                                       */
/* SHPIX[]:      SHift points by a PIXel amount                          */
/* Opcode range: 0x38                                                    */
/* Stack:        f26.6 uint32... -->                                     */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* MSIRP[a]:     Move Stack Indirect Relative Position                   */
/* Opcode range: 0x3A-0x3B                                               */
/* Stack:        f26.6 uint32 -->                                        */
/*                                                                       */
/* XXX: UNDOCUMENTED! behaviour */
/* if the point that is to be moved */
/* is in twilight zone              */
/*************************************************************************/
/*                                                                       */
/* MDAP[a]:      Move Direct Absolute Point                              */
/* Opcode range: 0x2E-0x2F                                               */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/* XXX: Is there some undocumented feature while in the */
/*      twilight zone? ?                                */
/*************************************************************************/
/*                                                                       */
/* MIAP[a]:      Move Indirect Absolute Point                            */
/* Opcode range: 0x3E-0x3F                                               */
/* Stack:        uint32 uint32 -->                                       */
/*                                                                       */
/* XXX: UNDOCUMENTED!                                */
/*                                                   */
/* The behaviour of an MIAP instruction is quite     */
/* different when used in the twilight zone.         */
/*                                                   */
/* First, no control value cut-in test is performed  */
/* as it would fail anyway.  Second, the original    */
/* point, i.e. (org_x,org_y) of zp0.point, is set    */
/* to the absolute, unrounded distance found in      */
/* the CVT.                                          */
/*                                                   */
/* This is used in the CVT programs of the Microsoft */
/* fonts Arial, Times, etc., in order to re-adjust   */
/* some key font heights.  It allows the use of the  */
/* IP instruction in the twilight zone, which        */
/* otherwise would be `illegal' according to the     */
/* specification.                                    */
/*                                                   */
/* We implement it with a special sequence for the   */
/* twilight zone.  This is a bad hack, but it seems  */
/* to work.                                          */
/* If in twilight zone */
/* rounding and control cutin flag */
/*************************************************************************/
/*                                                                       */
/* MDRP[abcde]:  Move Direct Relative Point                              */
/* Opcode range: 0xC0-0xDF                                               */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/* XXX: Is there some undocumented feature while in the */
/*      twilight zone?                                  */
/* XXX: UNDOCUMENTED: twilight zone special case */
/* this should be faster */
/* single width cut-in test */
/* round flag */
/* minimum distance flag */
/* now move the point */
/*************************************************************************/
/*                                                                       */
/* MIRP[abcde]:  Move Indirect Relative Point                            */
/* Opcode range: 0xE0-0xFF                                               */
/* Stack:        int32? uint32 -->                                       */
/*                                                                       */
/* XXX: UNDOCUMENTED! cvt[-1] = 0 always */
/* single width test */
/* XXX: UNDOCUMENTED! -- twilight zone */
/* auto-flip test */
/* control value cutin and round */
/* XXX: UNDOCUMENTED!  Only perform cut-in test when both points */
/*      refer to the same zone.                                  */
/* minimum distance test */
/* XXX: UNDOCUMENTED! */
/*************************************************************************/
/*                                                                       */
/* ALIGNRP[]:    ALIGN Relative Point                                    */
/* Opcode range: 0x3C                                                    */
/* Stack:        uint32 uint32... -->                                    */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* ISECT[]:      moves point to InterSECTion                             */
/* Opcode range: 0x0F                                                    */
/* Stack:        5 * uint32 -->                                          */
/*                                                                       */
/* else, take the middle of the middles of A and B */
/*************************************************************************/
/*                                                                       */
/* ALIGNPTS[]:   ALIGN PoinTS                                            */
/* Opcode range: 0x27                                                    */
/* Stack:        uint32 uint32 -->                                       */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* IP[]:         Interpolate Point                                       */
/* Opcode range: 0x39                                                    */
/* Stack:        uint32... -->                                           */
/*                                                                       */
/* SOMETIMES, DUMBER CODE IS BETTER CODE */
/*
/* XXX: There are some glyphs in some braindead but popular */
/*      fonts out there (e.g. [aeu]grave in monotype.ttf)   */
/*      calling IP[] with bad values of rp[12].             */
/*      Do something sane when this odd thing happens.      */
/* check point bounds */
/*************************************************************************/
/*                                                                       */
/* UTP[a]:       UnTouch Point                                           */
/* Opcode range: 0x29                                                    */
/* Stack:        uint32 -->                                              */
/*                                                                       */
/* Local variables for Ins_IUP: */
/* original and current coordinate */
/* arrays                          */
/* simple shift of untouched points */
/* interpolation */
/*************************************************************************/
/*                                                                       */
/* IUP[a]:       Interpolate Untouched Points                            */
/* Opcode range: 0x30-0x31                                               */
/* Stack:        -->                                                     */
/*                                                                       */
/* first point of contour        */
/* end point (last+1) of contour */
/* first touched point in contour   */
/* current touched point in contour */
/* current point   */
/* current contour */
/* ignore empty outlines */
/*************************************************************************/
/*                                                                       */
/* DELTAPn[]:    DELTA exceptions P1, P2, P3                             */
/* Opcode range: 0x5D,0x71,0x72                                          */
/* Stack:        uint32 (2 * uint32)... -->                              */
/*                                                                       */
/* Delta hinting is covered by US Patent 5159668. */
/* some points theoretically may occur more
/* XXX: Because some popular fonts contain some invalid DeltaP */
/*      instructions, we simply ignore them when the stacked   */
/*      point reference is off limit, rather than returning an */
/*      error.  As a delta instruction doesn't change a glyph  */
/*      in great ways, this shouldn't be a problem.            */
/*************************************************************************/
/*                                                                       */
/* DELTACn[]:    DELTA exceptions C1, C2, C3                             */
/* Opcode range: 0x73,0x74,0x75                                          */
/* Stack:        uint32 (2 * uint32)... -->                              */
/*                                                                       */
/* Delta hinting is covered by US Patent 5159668. */
/*************************************************************************/
/*                                                                       */
/* MISC. INSTRUCTIONS                                                    */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* GETINFO[]:    GET INFOrmation                                         */
/* Opcode range: 0x88                                                    */
/* Stack:        uint32 --> uint32                                       */
/*                                                                       */
/* We return MS rasterizer version 1.7 for the font scaler. */
/* Has the glyph been rotated? */
/* Has the glyph been stretched? */
/* Are we hinting for grayscale? */
/* Opcodes are gathered in groups of 16. */
/* Please keep the spaces as they are.   */
/*  SVTCA  y  */  Ins_SVTCA,
/*  SVTCA  x  */  Ins_SVTCA,
/*  SPvTCA y  */  Ins_SPVTCA,
/*  SPvTCA x  */  Ins_SPVTCA,
/*  SFvTCA y  */  Ins_SFVTCA,
/*  SFvTCA x  */  Ins_SFVTCA,
//  */  Ins_SPVTL,
/*  SPvTL //  */  Ins_SPVTL,
/*  SPvTL +   */  Ins_SPVTL,
//  */  Ins_SFVTL,
/*  SFvTL //  */  Ins_SFVTL,
/*  SFvTL +   */  Ins_SFVTL,
/*  SPvFS     */  Ins_SPVFS,
/*  SFvFS     */  Ins_SFVFS,
/*  GPV       */  Ins_GPV,
/*  GFV       */  Ins_GFV,
/*  SFvTPv    */  Ins_SFVTPV,
/*  ISECT     */  Ins_ISECT,
/*  SRP0      */  Ins_SRP0,
/*  SRP1      */  Ins_SRP1,
/*  SRP2      */  Ins_SRP2,
/*  SZP0      */  Ins_SZP0,
/*  SZP1      */  Ins_SZP1,
/*  SZP2      */  Ins_SZP2,
/*  SZPS      */  Ins_SZPS,
/*  SLOOP     */  Ins_SLOOP,
/*  RTG       */  Ins_RTG,
/*  RTHG      */  Ins_RTHG,
/*  SMD       */  Ins_SMD,
/*  ELSE      */  Ins_ELSE,
/*  JMPR      */  Ins_JMPR,
/*  SCvTCi    */  Ins_SCVTCI,
/*  SSwCi     */  Ins_SSWCI,
/*  SSW       */  Ins_SSW,
/*  DUP       */  Ins_DUP,
/*  POP       */  Ins_POP,
/*  CLEAR     */  Ins_CLEAR,
/*  SWAP      */  Ins_SWAP,
/*  DEPTH     */  Ins_DEPTH,
/*  CINDEX    */  Ins_CINDEX,
/*  MINDEX    */  Ins_MINDEX,
/*  AlignPTS  */  Ins_ALIGNPTS,
/*  INS_0x28  */  Ins_UNKNOWN,
/*  UTP       */  Ins_UTP,
/*  LOOPCALL  */  Ins_LOOPCALL,
/*  CALL      */  Ins_CALL,
/*  FDEF      */  Ins_FDEF,
/*  ENDF      */  Ins_ENDF,
/*  MDAP[0]   */  Ins_MDAP,
/*  MDAP[1]   */  Ins_MDAP,
/*  IUP[0]    */  Ins_IUP,
/*  IUP[1]    */  Ins_IUP,
/*  SHP[0]    */  Ins_SHP,
/*  SHP[1]    */  Ins_SHP,
/*  SHC[0]    */  Ins_SHC,
/*  SHC[1]    */  Ins_SHC,
/*  SHZ[0]    */  Ins_SHZ,
/*  SHZ[1]    */  Ins_SHZ,
/*  SHPIX     */  Ins_SHPIX,
/*  IP        */  Ins_IP,
/*  MSIRP[0]  */  Ins_MSIRP,
/*  MSIRP[1]  */  Ins_MSIRP,
/*  AlignRP   */  Ins_ALIGNRP,
/*  RTDG      */  Ins_RTDG,
/*  MIAP[0]   */  Ins_MIAP,
/*  MIAP[1]   */  Ins_MIAP,
/*  NPushB    */  Ins_NPUSHB,
/*  NPushW    */  Ins_NPUSHW,
/*  WS        */  Ins_WS,
/*  RS        */  Ins_RS,
/*  WCvtP     */  Ins_WCVTP,
/*  RCvt      */  Ins_RCVT,
/*  GC[0]     */  Ins_GC,
/*  GC[1]     */  Ins_GC,
/*  SCFS      */  Ins_SCFS,
/*  MD[0]     */  Ins_MD,
/*  MD[1]     */  Ins_MD,
/*  MPPEM     */  Ins_MPPEM,
/*  MPS       */  Ins_MPS,
/*  FlipON    */  Ins_FLIPON,
/*  FlipOFF   */  Ins_FLIPOFF,
/*  DEBUG     */  Ins_DEBUG,
/*  LT        */  Ins_LT,
/*  LTEQ      */  Ins_LTEQ,
/*  GT        */  Ins_GT,
/*  GTEQ      */  Ins_GTEQ,
/*  EQ        */  Ins_EQ,
/*  NEQ       */  Ins_NEQ,
/*  ODD       */  Ins_ODD,
/*  EVEN      */  Ins_EVEN,
/*  IF        */  Ins_IF,
/*  EIF       */  Ins_EIF,
/*  AND       */  Ins_AND,
/*  OR        */  Ins_OR,
/*  NOT       */  Ins_NOT,
/*  DeltaP1   */  Ins_DELTAP,
/*  SDB       */  Ins_SDB,
/*  SDS       */  Ins_SDS,
/*  ADD       */  Ins_ADD,
/*  SUB       */  Ins_SUB,
/*  DIV       */  Ins_DIV,
/*  MUL       */  Ins_MUL,
/*  ABS       */  Ins_ABS,
/*  NEG       */  Ins_NEG,
/*  FLOOR     */  Ins_FLOOR,
/*  CEILING   */  Ins_CEILING,
/*  ROUND[0]  */  Ins_ROUND,
/*  ROUND[1]  */  Ins_ROUND,
/*  ROUND[2]  */  Ins_ROUND,
/*  ROUND[3]  */  Ins_ROUND,
/*  NROUND[0] */  Ins_NROUND,
/*  NROUND[1] */  Ins_NROUND,
/*  NROUND[2] */  Ins_NROUND,
/*  NROUND[3] */  Ins_NROUND,
/*  WCvtF     */  Ins_WCVTF,
/*  DeltaP2   */  Ins_DELTAP,
/*  DeltaP3   */  Ins_DELTAP,
/*  DeltaCn[0] */ Ins_DELTAC,
/*  DeltaCn[1] */ Ins_DELTAC,
/*  DeltaCn[2] */ Ins_DELTAC,
/*  SROUND    */  Ins_SROUND,
/*  S45Round  */  Ins_S45ROUND,
/*  JROT      */  Ins_JROT,
/*  JROF      */  Ins_JROF,
/*  ROFF      */  Ins_ROFF,
/*  INS_0x7B  */  Ins_UNKNOWN,
/*  RUTG      */  Ins_RUTG,
/*  RDTG      */  Ins_RDTG,
/*  SANGW     */  Ins_SANGW,
/*  AA        */  Ins_AA,
/*  FlipPT    */  Ins_FLIPPT,
/*  FlipRgON  */  Ins_FLIPRGON,
/*  FlipRgOFF */  Ins_FLIPRGOFF,
/*  INS_0x83  */  Ins_UNKNOWN,
/*  INS_0x84  */  Ins_UNKNOWN,
/*  ScanCTRL  */  Ins_SCANCTRL,
/*  SDPVTL[0] */  Ins_SDPVTL,
/*  SDPVTL[1] */  Ins_SDPVTL,
/*  GetINFO   */  Ins_GETINFO,
/*  IDEF      */  Ins_IDEF,
/*  ROLL      */  Ins_ROLL,
/*  MAX       */  Ins_MAX,
/*  MIN       */  Ins_MIN,
/*  ScanTYPE  */  Ins_SCANTYPE,
/*  InstCTRL  */  Ins_INSTCTRL,
/*  INS_0x8F  */  Ins_UNKNOWN,
/*  INS_0x90  */   Ins_UNKNOWN,
/*  INS_0x91  */   Ins_UNKNOWN,
/*  INS_0x92  */   Ins_UNKNOWN,
/*  INS_0x93  */   Ins_UNKNOWN,
/*  INS_0x94  */   Ins_UNKNOWN,
/*  INS_0x95  */   Ins_UNKNOWN,
/*  INS_0x96  */   Ins_UNKNOWN,
/*  INS_0x97  */   Ins_UNKNOWN,
/*  INS_0x98  */   Ins_UNKNOWN,
/*  INS_0x99  */   Ins_UNKNOWN,
/*  INS_0x9A  */   Ins_UNKNOWN,
/*  INS_0x9B  */   Ins_UNKNOWN,
/*  INS_0x9C  */   Ins_UNKNOWN,
/*  INS_0x9D  */   Ins_UNKNOWN,
/*  INS_0x9E  */   Ins_UNKNOWN,
/*  INS_0x9F  */   Ins_UNKNOWN,
/*  INS_0xA0  */   Ins_UNKNOWN,
/*  INS_0xA1  */   Ins_UNKNOWN,
/*  INS_0xA2  */   Ins_UNKNOWN,
/*  INS_0xA3  */   Ins_UNKNOWN,
/*  INS_0xA4  */   Ins_UNKNOWN,
/*  INS_0xA5  */   Ins_UNKNOWN,
/*  INS_0xA6  */   Ins_UNKNOWN,
/*  INS_0xA7  */   Ins_UNKNOWN,
/*  INS_0xA8  */   Ins_UNKNOWN,
/*  INS_0xA9  */   Ins_UNKNOWN,
/*  INS_0xAA  */   Ins_UNKNOWN,
/*  INS_0xAB  */   Ins_UNKNOWN,
/*  INS_0xAC  */   Ins_UNKNOWN,
/*  INS_0xAD  */   Ins_UNKNOWN,
/*  INS_0xAE  */   Ins_UNKNOWN,
/*  INS_0xAF  */   Ins_UNKNOWN,
/*  PushB[0]  */  Ins_PUSHB,
/*  PushB[1]  */  Ins_PUSHB,
/*  PushB[2]  */  Ins_PUSHB,
/*  PushB[3]  */  Ins_PUSHB,
/*  PushB[4]  */  Ins_PUSHB,
/*  PushB[5]  */  Ins_PUSHB,
/*  PushB[6]  */  Ins_PUSHB,
/*  PushB[7]  */  Ins_PUSHB,
/*  PushW[0]  */  Ins_PUSHW,
/*  PushW[1]  */  Ins_PUSHW,
/*  PushW[2]  */  Ins_PUSHW,
/*  PushW[3]  */  Ins_PUSHW,
/*  PushW[4]  */  Ins_PUSHW,
/*  PushW[5]  */  Ins_PUSHW,
/*  PushW[6]  */  Ins_PUSHW,
/*  PushW[7]  */  Ins_PUSHW,
/*  MDRP[00]  */  Ins_MDRP,
/*  MDRP[01]  */  Ins_MDRP,
/*  MDRP[02]  */  Ins_MDRP,
/*  MDRP[03]  */  Ins_MDRP,
/*  MDRP[04]  */  Ins_MDRP,
/*  MDRP[05]  */  Ins_MDRP,
/*  MDRP[06]  */  Ins_MDRP,
/*  MDRP[07]  */  Ins_MDRP,
/*  MDRP[08]  */  Ins_MDRP,
/*  MDRP[09]  */  Ins_MDRP,
/*  MDRP[10]  */  Ins_MDRP,
/*  MDRP[11]  */  Ins_MDRP,
/*  MDRP[12]  */  Ins_MDRP,
/*  MDRP[13]  */  Ins_MDRP,
/*  MDRP[14]  */  Ins_MDRP,
/*  MDRP[15]  */  Ins_MDRP,
/*  MDRP[16]  */  Ins_MDRP,
/*  MDRP[17]  */  Ins_MDRP,
/*  MDRP[18]  */  Ins_MDRP,
/*  MDRP[19]  */  Ins_MDRP,
/*  MDRP[20]  */  Ins_MDRP,
/*  MDRP[21]  */  Ins_MDRP,
/*  MDRP[22]  */  Ins_MDRP,
/*  MDRP[23]  */  Ins_MDRP,
/*  MDRP[24]  */  Ins_MDRP,
/*  MDRP[25]  */  Ins_MDRP,
/*  MDRP[26]  */  Ins_MDRP,
/*  MDRP[27]  */  Ins_MDRP,
/*  MDRP[28]  */  Ins_MDRP,
/*  MDRP[29]  */  Ins_MDRP,
/*  MDRP[30]  */  Ins_MDRP,
/*  MDRP[31]  */  Ins_MDRP,
/*  MIRP[00]  */  Ins_MIRP,
/*  MIRP[01]  */  Ins_MIRP,
/*  MIRP[02]  */  Ins_MIRP,
/*  MIRP[03]  */  Ins_MIRP,
/*  MIRP[04]  */  Ins_MIRP,
/*  MIRP[05]  */  Ins_MIRP,
/*  MIRP[06]  */  Ins_MIRP,
/*  MIRP[07]  */  Ins_MIRP,
/*  MIRP[08]  */  Ins_MIRP,
/*  MIRP[09]  */  Ins_MIRP,
/*  MIRP[10]  */  Ins_MIRP,
/*  MIRP[11]  */  Ins_MIRP,
/*  MIRP[12]  */  Ins_MIRP,
/*  MIRP[13]  */  Ins_MIRP,
/*  MIRP[14]  */  Ins_MIRP,
/*  MIRP[15]  */  Ins_MIRP,
/*  MIRP[16]  */  Ins_MIRP,
/*  MIRP[17]  */  Ins_MIRP,
/*  MIRP[18]  */  Ins_MIRP,
/*  MIRP[19]  */  Ins_MIRP,
/*  MIRP[20]  */  Ins_MIRP,
/*  MIRP[21]  */  Ins_MIRP,
/*  MIRP[22]  */  Ins_MIRP,
/*  MIRP[23]  */  Ins_MIRP,
/*  MIRP[24]  */  Ins_MIRP,
/*  MIRP[25]  */  Ins_MIRP,
/*  MIRP[26]  */  Ins_MIRP,
/*  MIRP[27]  */  Ins_MIRP,
/*  MIRP[28]  */  Ins_MIRP,
/*  MIRP[29]  */  Ins_MIRP,
/*  MIRP[30]  */  Ins_MIRP,
/*  MIRP[31]  */  Ins_MIRP
/* !TT_CONFIG_OPTION_INTERPRETER_SWITCH */
/*************************************************************************/
/*                                                                       */
/* RUN                                                                   */
/*                                                                       */
/*  This function executes a run of opcodes.  It will exit in the        */
/*  following cases:                                                     */
/*                                                                       */
/*  - Errors (in which case it returns FALSE).                           */
/*                                                                       */
/*  - Reaching the end of the main code range (returns TRUE).            */
/*    Reaching the end of a code range within a function call is an      */
/*    error.                                                             */
/*                                                                       */
/*  - After executing one single opcode, if the flag `Instruction_Trap'  */
/*    is set to TRUE (returns TRUE).                                     */
/*                                                                       */
/*  On exit with TRUE, test IP < CodeSize to know whether it comes from  */
/*  an instruction trap or a normal termination.                         */
/*                                                                       */
/*                                                                       */
/*  Note: The documented DEBUG opcode pops a value from the stack.  This */
/*        behaviour is unsupported; here a DEBUG opcode is always an     */
/*        error.                                                         */
/*                                                                       */
/*                                                                       */
/* THIS IS THE INTERPRETER'S MAIN LOOP.                                  */
/*                                                                       */
/*  Instructions appear in the specification's order.                    */
/*                                                                       */
/*************************************************************************/
/* documentation is in ttinterp.h */
/* executed instructions counter */
/* set CVT functions */
/* non-square pixels, use the stretched routines */
/* square pixels, use normal routines */
/* First, let's check for empty stack and overflow */
/* `args' is the top of the stack once arguments have been popped. */
/* One can also interpret it as the index of the last argument.    */
/* `new_top' is the new top of the stack, after the instruction's */
/* execution.  `top' will be set to `new_top' after the `switch'  */
/* statement.                                                     */
/* SVTCA y  */
/* SVTCA x  */
/* SPvTCA y */
/* SPvTCA x */
/* SFvTCA y */
/* SFvTCA x */
// */
/* SPvTL // */
/* SPvTL +  */
// */
/* SFvTL // */
/* SFvTL +  */
/* SPvFS */
/* SFvFS */
/* GPV */
/* GFV */
/* SFvTPv */
/* ISECT  */
/* SRP0 */
/* SRP1 */
/* SRP2 */
/* SZP0 */
/* SZP1 */
/* SZP2 */
/* SZPS */
/* SLOOP */
/* RTG */
/* RTHG */
/* SMD */
/* ELSE */
/* JMPR */
/* SCVTCI */
/* SSWCI */
/* SSW */
/* DUP */
/* POP */
/* nothing :-) */
/* CLEAR */
/* SWAP */
/* DEPTH */
/* CINDEX */
/* MINDEX */
/* ALIGNPTS */
/* ???? */
/* UTP */
/* LOOPCALL */
/* CALL */
/* FDEF */
/* ENDF */
/* MDAP */
/* MDAP */
/* IUP */
/* IUP */
/* SHP */
/* SHP */
/* SHC */
/* SHC */
/* SHZ */
/* SHZ */
/* SHPIX */
/* IP    */
/* MSIRP */
/* MSIRP */
/* AlignRP */
/* RTDG */
/* MIAP */
/* MIAP */
/* NPUSHB */
/* NPUSHW */
/* WS */
/* RS */
/* WCVTP */
/* RCVT */
/* GC */
/* GC */
/* SCFS */
/* MD */
/* MD */
/* MPPEM */
/* MPS */
/* FLIPON */
/* FLIPOFF */
/* DEBUG */
/* LT */
/* LTEQ */
/* GT */
/* GTEQ */
/* EQ */
/* NEQ */
/* ODD */
/* EVEN */
/* IF */
/* EIF */
/* do nothing */
/* AND */
/* OR */
/* NOT */
/* DELTAP1 */
/* SDB */
/* SDS */
/* ADD */
/* SUB */
/* DIV */
/* MUL */
/* ABS */
/* NEG */
/* FLOOR */
/* CEILING */
/* ROUND */
/* ROUND */
/* ROUND */
/* ROUND */
/* NROUND */
/* NROUND */
/* NRRUND */
/* NROUND */
/* WCVTF */
/* DELTAP2 */
/* DELTAP3 */
/* DELTAC0 */
/* DELTAC1 */
/* DELTAC2 */
/* SROUND */
/* S45Round */
/* JROT */
/* JROF */
/* ROFF */
/* ???? */
/* RUTG */
/* RDTG */
/* SANGW */
/* AA    */
/* nothing - obsolete */
/* FLIPPT */
/* FLIPRGON */
/* FLIPRGOFF */
/* UNKNOWN */
/* UNKNOWN */
/* SCANCTRL */
/* SDPVTL */
/* SDPVTL */
/* GETINFO */
/* IDEF */
/* ROLL */
/* MAX */
/* MIN */
/* SCANTYPE */
/* INSTCTRL */
/* TT_CONFIG_OPTION_INTERPRETER_SWITCH */
/* looking for redefined instructions */
/* Unreachable code warning suppression.             */
/* Leave to remind in case a later change the editor */
/* to consider break;                                */
/* increment instruction counter and check if we didn't */
/* run this program for too long (e.g. infinite loops). */
/* TT_USE_BYTECODE_INTERPRETER */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\truetype\ttobjs.c
/***************************************************************************/
/*                                                                         */
/*  ttobjs.c                                                               */
/*                                                                         */
/*    Objects manager (body).                                              */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/*                       GLYPH ZONE FUNCTIONS                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_glyphzone_done                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Deallocate a glyph zone.                                           */
/*                                                                       */
/* <Input>                                                               */
/*    zone :: A pointer to the target glyph zone.                        */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_glyphzone_new                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Allocate a new glyph zone.                                         */
/*                                                                       */
/* <Input>                                                               */
/*    memory      :: A handle to the current memory object.              */
/*                                                                       */
/*    maxPoints   :: The capacity of glyph zone in points.               */
/*                                                                       */
/*    maxContours :: The capacity of glyph zone in contours.             */
/*                                                                       */
/* <Output>                                                              */
/*    zone        :: A pointer to the target glyph zone record.          */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* TT_USE_BYTECODE_INTERPRETER */
/* Compare the face with a list of well-known `tricky' fonts. */
/* This list shall be expanded as we find more of them.       */
/* dfkaisb.ttf */
/* kaiu.ttf */
/* htst3.ttf */
/* mingliu.ttf & mingliu.ttc */
/* mingliu.ttc */
/* mingli.ttf */
/* Note that we only check the face name at the moment; it might */
/* be worth to do more checks for a few special cases.           */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_init                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    Initialize a given TrueType face object.                           */
/*                                                                       */
/* <Input>                                                               */
/*    stream     :: The source font stream.                              */
/*                                                                       */
/*    face_index :: The index of the font face in the resource.          */
/*                                                                       */
/*    num_params :: Number of additional generic parameters.  Ignored.   */
/*                                                                       */
/*    params     :: Additional generic parameters.  Ignored.             */
/*                                                                       */
/* <InOut>                                                               */
/*    face       :: The newly built face object.                         */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* TT_Face */
/* create input stream from resource */
/* check that we have a valid TrueType file */
/* We must also be able to accept Mac/GX fonts, as well as OT ones. */
/* The 0x00020000 tag is completely undocumented; some fonts from   */
/* Arphic made for Chinese Windows 3.1 have this.                   */
/* MS fonts  */
/* CJK fonts for Win 3.1 */
/* Mac fonts */
/* If we are performing a simple font format check, exit immediately. */
/* Load font directory */
/* Determine whether unpatented hinting is to be used for this face. */
/* TT_CONFIG_OPTION_UNPATENTED_HINTING &&
/* initialize standard glyph loading routines */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_done                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    Finalize a given face object.                                      */
/*                                                                       */
/* <Input>                                                               */
/*    face :: A pointer to the face object to destroy.                   */
/*                                                                       */
/* TT_Face */
/* for `extended TrueType formats' (i.e. compressed versions) */
/* freeing the locations table */
/* freeing the CVT */
/* freeing the programs */
/*************************************************************************/
/*                                                                       */
/*                           SIZE  FUNCTIONS                             */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_size_run_fpgm                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Run the font program.                                              */
/*                                                                       */
/* <Input>                                                               */
/*    size :: A handle to the size object.                               */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* debugging instances have their own context */
/* allow font program execution */
/* disable CVT and glyph programs coderange */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_size_run_prep                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Run the control value program.                                     */
/*                                                                       */
/* <Input>                                                               */
/*    size :: A handle to the size object.                               */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* debugging instances have their own context */
/* save as default graphics state */
/* TT_USE_BYTECODE_INTERPRETER */
/* the debug context must be deleted by the debugger itself */
/* free storage area */
/* twilight zone */
/* Initialize bytecode-related fields in the size object.       */
/* We do this only if bytecode interpretation is really needed. */
/* Set default metrics */
/* set default compensation (all 0) */
/* allocate function defs, instruction defs, cvt, and storage area */
/* reserve twilight zone */
/* there are 4 phantom points (do we need this?) */
/* set `face->interpreter' according to the debug hook present */
/* Fine, now run the font program! */
/* rescale CVT when needed */
/* Scale the cvt values to the new ppem.          */
/* We use by default the y ppem to scale the CVT. */
/* all twilight points are originally zero */
/* clear storage area */
/* TT_USE_BYTECODE_INTERPRETER */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_size_init                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    Initialize a new TrueType size object.                             */
/*                                                                       */
/* <InOut>                                                               */
/*    size :: A handle to the size object.                               */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* TT_Size */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_size_done                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    The TrueType size object finalizer.                                */
/*                                                                       */
/* <Input>                                                               */
/*    size :: A handle to the target size object.                        */
/*                                                                       */
/* TT_Size */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_size_reset                                                      */
/*                                                                       */
/* <Description>                                                         */
/*    Reset a TrueType size when resolutions and character dimensions    */
/*    have been changed.                                                 */
/*                                                                       */
/* <Input>                                                               */
/*    size :: A handle to the target size object.                        */
/*                                                                       */
/* copy the result from base layer */
/* This bit flag, if set, indicates that the ppems must be       */
/* rounded to integers.  Nearly all TrueType fonts have this bit */
/* set, as hinting won't work really well otherwise.             */
/*                                                               */
/* compute new transformation */
/* TT_USE_BYTECODE_INTERPRETER */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_driver_init                                                     */
/*                                                                       */
/* <Description>                                                         */
/*    Initialize a given TrueType driver object.                         */
/*                                                                       */
/* <Input>                                                               */
/*    driver :: A handle to the target driver object.                    */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* TT_Driver */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_driver_done                                                     */
/*                                                                       */
/* <Description>                                                         */
/*    Finalize a given TrueType driver.                                  */
/*                                                                       */
/* <Input>                                                               */
/*    driver :: A handle to the target TrueType driver.                  */
/*                                                                       */
/* TT_Driver */
/* destroy the execution context */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_slot_init                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    Initialize a new slot object.                                      */
/*                                                                       */
/* <InOut>                                                               */
/*    slot :: A handle to the slot object.                               */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\truetype\ttpic.c
/***************************************************************************/
/*                                                                         */
/*  ttpic.c                                                                */
/*                                                                         */
/*    The FreeType position independent code services for truetype module. */
/*                                                                         */
/*  Copyright 2009, 2010 by                                                */
/*  Oran Agra and Mickey Gabel.                                            */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* forward declaration of PIC init functions from ttdriver.c */
/* allocate pointer, clear and set global container pointer */
/* initialize pointer table - this is how the module usually expects this data */
/* FT_CONFIG_OPTION_PIC */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\truetype\ttpload.c
/***************************************************************************/
/*                                                                         */
/*  ttpload.c                                                              */
/*                                                                         */
/*    TrueType-specific tables loader (body).                              */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2004, 2005, 2006, 2007, 2008, 2009 by       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_loca                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Load the locations table.                                          */
/*                                                                       */
/* <InOut>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/* <Input>                                                               */
/*    stream :: The input stream.                                        */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* we need the size of the `glyf' table for malformed `loca' tables */
/* it is possible that a font doesn't have a glyf table at all */
/* or its size is zero                                         */
/* we only handle the case where `maxp' gives a larger value */
/* compute the distance to next table in font file */
/*
/* The `loca' table must be ordered; it refers to the length of */
/* an entry as the difference between the current and the next  */
/* position.  However, there do exist (malformed) fonts which   */
/* don't obey this rule, so we are only able to provide an      */
/* upper bound for the size.                                    */
/*                                                              */
/* We get (intentionally) a wrong, non-zero result in case the  */
/* `glyf' table is missing.                                     */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_cvt                                                   */
/*                                                                       */
/* <Description>                                                         */
/*    Load the control value table into a face object.                   */
/*                                                                       */
/* <InOut>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/* <Input>                                                               */
/*    stream :: A handle to the input stream.                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* !TT_USE_BYTECODE_INTERPRETER */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_fpgm                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Load the font program.                                             */
/*                                                                       */
/* <InOut>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/* <Input>                                                               */
/*    stream :: A handle to the input stream.                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* The font program is optional */
/* !TT_USE_BYTECODE_INTERPRETER */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_prep                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Load the cvt program.                                              */
/*                                                                       */
/* <InOut>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/* <Input>                                                               */
/*    stream :: A handle to the input stream.                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* !TT_USE_BYTECODE_INTERPRETER */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    tt_face_load_hdmx                                                  */
/*                                                                       */
/* <Description>                                                         */
/*    Load the `hdmx' table into the face object.                        */
/*                                                                       */
/* <Input>                                                               */
/*    face   :: A handle to the target face object.                      */
/*                                                                       */
/*    stream :: A handle to the input stream.                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* this table is optional */
/* The maximum number of bytes in an hdmx device record is the */
/* maximum number of glyphs + 2; this is 0xFFFF + 2; this is   */
/* the reason why `record_size' is a long (which we read as    */
/* unsigned long for convenience).  In practice, two bytes     */
/* sufficient to hold the size value.                          */
/*                                                             */
/* There are at least two fonts, HANNOM-A and HANNOM-B version */
/* 2.0 (2005), which get this wrong: The upper two bytes of    */
/* the size value are set to 0xFF instead of 0x00.  We catch   */
/* and fix this.                                               */
/* The limit for `num_records' is a heuristic value. */
/*************************************************************************/
/*                                                                       */
/* Return the advance width table for a given pixel size if it is found  */
/* in the font's `hdmx' table (if any).                                  */
/*                                                                       */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\type1\t1afm.c
/***************************************************************************/
/*                                                                         */
/*  t1afm.c                                                                */
/*                                                                         */
/*    AFM support for Type 1 fonts (body).                                 */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,   */
/*            2010 by                                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* read a glyph name and return the equivalent glyph index */
/* PS string/name length must be < 16-bit */
/* compare two kerning pairs */
/* parse a PFM file -- for now, only read the kerning pairs */
/* Figure out how long the width table is.          */
/* This info is a little-endian short at offset 99. */
/* extension table is probably optional */
/* Kerning offset is 14 bytes from start of extensions table. */
/* zero offset means no table */
/* Actually, kerning pairs are simply optional! */
/* allocate the pairs */
/* now, read each kern pair */
/* PFM kerning data are stored by encoding rather than glyph index, */
/* so find the PostScript charmap of this font and install it       */
/* temporarily.  If we find no PostScript charmap, then just use    */
/* the default and hope it is the right one.                        */
/* check against PostScript pseudo platform */
/* Kerning info is stored as:             */
/*                                        */
/*   encoding of first glyph (1 byte)     */
/*   encoding of second glyph (1 byte)    */
/*   offset (little-endian short)         */
/* now, sort the kern pairs according to their glyph indices */
/* parse a metrics file -- either AFM or PFM depending on what */
/* it turns out to be                                          */
/* MS Windows allows versions up to 0x3FF without complaining */
/* no `U' suffix here to 0xFFFF! */
/* no `U' suffix here to 0x8000! */
/* find the kerning for a given glyph pair */
/* simple binary search */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\type1\t1driver.c
/***************************************************************************/
/*                                                                         */
/*  t1driver.c                                                             */
/*                                                                         */
/*    Type 1 driver interface (body).                                      */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2006, 2007, 2009 by             */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*
/*
/*
/*
/*
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    Get_Kerning                                                        */
/*                                                                       */
/* <Description>                                                         */
/*    A driver method used to return the kerning vector between two      */
/*    glyphs of the same face.                                           */
/*                                                                       */
/* <Input>                                                               */
/*    face        :: A handle to the source face object.                 */
/*                                                                       */
/*    left_glyph  :: The index of the left glyph in the kern pair.       */
/*                                                                       */
/*    right_glyph :: The index of the right glyph in the kern pair.      */
/*                                                                       */
/* <Output>                                                              */
/*    kerning     :: The kerning vector.  This is in font units for      */
/*                   scalable formats, and in pixels for fixed-sizes     */
/*                   formats.                                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* <Note>                                                                */
/*    Only horizontal layouts (left-to-right & right-to-left) are        */
/*    supported by this function.  Other layouts, or more sophisticated  */
/*    kernings are out of scope of this method (the basic driver         */
/*    interface is meant to be simple).                                  */
/*                                                                       */
/*    They can be implemented by format-specific interfaces.             */
/*                                                                       */
/* T1_CONFIG_OPTION_NO_AFM */
/* format interface */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\type1\t1gload.c
/***************************************************************************/
/*                                                                         */
/*  t1gload.c                                                              */
/*                                                                         */
/*    Type 1 Glyph Loader (body).                                          */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2008, 2009, 2010 by */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/**********                                                      *********/
/**********            COMPUTE THE MAXIMUM ADVANCE WIDTH         *********/
/**********                                                      *********/
/**********    The following code is in charge of computing      *********/
/**********    the maximum advance width of the font.  It        *********/
/**********    quickly processes each glyph charstring to        *********/
/**********    extract the value from either a `sbw' or `seac'   *********/
/**********    operator.                                         *********/
/**********                                                      *********/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* For incremental fonts get the character data using the */
/* callback function.                                     */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* For ordinary fonts get the character data stored in the face record. */
/* Incremental fonts can optionally override the metrics. */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* initialize load decoder */
/* size       */
/* glyph slot */
/* for each glyph, parse the glyph charstring and extract */
/* the advance width                                      */
/* now get load the unscaled outline */
/* ignore the error if one occurred - skip to next glyph */
/* size       */
/* glyph slot */
/* FT_CONFIG_OPTION_INCREMENTAL */
/* now load the unscaled outline */
/* save new glyph tables */
/* now, set the metrics -- this is rather simple, as   */
/* the left side bearing is the xMin, and the top side */
/* bearing the yMax                                    */
/* for composite glyphs, return only left side bearing and */
/* advance width                                           */
/* copy the _unscaled_ advance width */
/* make up vertical ones */
/* apply the font matrix, if any */
/* scale the outline and the metrics */
/* First of all, scale the points, if we are not hinting */
/* Then scale the metrics */
/* compute the other metrics */
/* make up vertical ones */
/* Set control data to the glyph charstrings.  Note that this is */
/* _not_ zero-terminated.                                        */
/* Set the control data to null - it is no longer available if   */
/* loaded incrementally.                                         */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\type1\t1load.c
/***************************************************************************/
/*                                                                         */
/*  t1load.c                                                               */
/*                                                                         */
/*    Type 1 font loader (body).                                           */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* This is the new and improved Type 1 data loader for FreeType 2.  The  */
/* old loader has several problems: it is slow, complex, difficult to    */
/* maintain, and contains incredible hacks to make it accept some        */
/* ill-formed Type 1 fonts without hiccup-ing.  Moreover, about 5% of    */
/* the Type 1 fonts on my machine still aren't loaded correctly by it.   */
/*                                                                       */
/* This version is much simpler, much faster and also easier to read and */
/* maintain by a great order of magnitude.  The idea behind it is to     */
/* _not_ try to read the Type 1 token stream with a state machine (i.e.  */
/* a Postscript-like interpreter) but rather to perform simple pattern   */
/* matching.                                                             */
/*                                                                       */
/* Indeed, nearly all data definitions follow a simple pattern like      */
/*                                                                       */
/*  ... /Field <data> ...                                                */
/*                                                                       */
/* where <data> can be a number, a boolean, a string, or an array of     */
/* numbers.  There are a few exceptions, namely the encoding, font name, */
/* charstrings, and subrs; they are handled with a special pattern       */
/* matching routine.                                                     */
/*                                                                       */
/* All other common cases are handled very simply.  The matching rules   */
/* are defined in the file `t1tokens.h' through the use of several       */
/* macros calls PARSE_XXX.  This file is included twice here; the first  */
/* time to generate parsing callback functions, the second time to       */
/* generate a table of keywords (with pointers to the associated         */
/* callback functions).                                                  */
/*                                                                       */
/* The function `parse_dict' simply scans *linearly* a given dictionary  */
/* (either the top-level or private one) and calls the appropriate       */
/* callback when it encounters an immediate keyword.                     */
/*                                                                       */
/* This is by far the fastest way one can find to parse and read all     */
/* data.                                                                 */
/*                                                                       */
/* This led to tremendous code size reduction.  Note that later, the     */
/* glyph loader will also be _greatly_ simplified, and the automatic     */
/* hinter will replace the clumsy `t1hinter'.                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                    MULTIPLE MASTERS SUPPORT                   *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* allocate design data if needed */
/* allocate the blend `private' and `font_info' dictionaries */
/* allocate axis data if needed */
/* allocate the blend design pos table if needed */
/*************************************************************************/
/*                                                                       */
/* Given a normalized (blend) coordinate, figure out the design          */
/* coordinate appropriate for that value.                                */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* Given a vector of weights, one for each design, figure out the        */
/* normalized axis coordinates which gave rise to those weights.         */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* Just a wrapper around T1_Get_Multi_Master to support the different    */
/*  arguments needed by the GX var distortable fonts.                    */
/*                                                                       */
/* Does not apply */
/* Point to axes after MM_Var struct */
/* Does not apply.  But this value is in range */
/* Does not apply */
/* Does not apply */
/* recompute the weight vector from the blend coordinates */
/* 1.0 fixed */
/* get current blend axis position */
/* compute the blend coordinates through the blend design map */
/* exact match? */
/* now interpolate if necessary */
/*************************************************************************/
/*                                                                       */
/* Just a wrapper around T1_Set_MM_Design to support the different       */
/* arguments needed by the GX var distortable fonts.                     */
/*                                                                       */
/* maximum axis count is 4 */
/* release design pos table */
/* release blend `private' and `font info' dictionaries */
/* release weight vectors */
/* release axis names */
/* release design map */
/* take an array of objects */
/* allocate blend if necessary */
/* each token is an immediate containing the name of the axis */
/* skip first slash, if any */
/* get the array of design tokens -- compute number of designs */
/* make compiler happy */
/* read axis/coordinates tokens */
/* now read each axis token into the design position */
/* now read each axis design map */
/* allocate design map data */
/* don't include delimiting brackets */
/* e.g., /BuildCharArray [0 0 0 0 0 0 0 0] def           */
/* we're only interested in the number of array elements */
/* T1_CONFIG_OPTION_NO_MM_SUPPORT */
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                      TYPE 1 SYMBOL PARSING                    *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/* if the keyword has a dedicated callback, call it */
/* now, the keyword is either a simple field, or a table of fields; */
/* we are now going to take care of it                              */
/* the binary data has one of the following formats */
/*                                                  */
/*   `size' [white*] RD white ....... ND            */
/*   `size' [white*] -| white ....... |-            */
/*                                                  */
/* `RD' or `-|' or something else */
/* there is only one whitespace char after the */
/* `RD' or `-|' token                          */
/* We now define the routines to handle the `/Encoding', `/Subrs', */
/* and `/CharStrings' dictionaries.                                */
/* Set Units per EM based on FontMatrix values.  We set the value to */
/* 1000 / temp_scale, because temp_scale was already multiplied by   */
/* 1000 (in t1_tofixed, from psobjs.c).                              */
/* we need to scale the values by 1.0/temp_scale */
/* note that the offsets must be expressed in integer font units */
/* if we have a number or `[', the encoding is an array, */
/* and we must load it now                               */
/* read the number of entries in the encoding; should be 256 */
/* we use a T1_Table to store our charnames */
/* We need to `zero' out encoding_table.elements */
/* Now we need to read records of the form                */
/*                                                        */
/*   ... charcode /charname ...                           */
/*                                                        */
/* for each entry in our table.                           */
/*                                                        */
/* We simply look for a number followed by an immediate   */
/* name.  Note that this ignores correctly the sequence   */
/* that is often seen in type1 fonts:                     */
/*                                                        */
/*   0 1 255 { 1 index exch /.notdef put } for dup        */
/*                                                        */
/* used to clean the encoding array before anything else. */
/*                                                        */
/* Alternatively, if the array is directly given as       */
/*                                                        */
/*   /Encoding [ ... ]                                    */
/*                                                        */
/* we only read immediates.                               */
/* we stop when we encounter a `def' or `]' */
/* check whether we've found an entry */
/* Since the current position is not updated for           */
/* immediates-only mode we would get an infinite loop if   */
/* we don't do anything here.                              */
/*                                                         */
/* This encoding array is not valid according to the type1 */
/* specification (it might be an encoding for a CID type1  */
/* font, however), so we conclude that this font is NOT a  */
/* type1 font.                                             */
/* Otherwise, we should have either `StandardEncoding', */
/* `ExpertEncoding', or `ISOLatin1Encoding'             */
/* test for empty array */
/* position the parser right before the `dup' of the first subr */
/* `array' */
/* initialize subrs array -- with synthetic fonts it is possible */
/* we get here twice                                             */
/* the format is simple:   */
/*                         */
/*   `index' + binary data */
/*                         */
/* If the next token isn't `dup' we are done. */
/* `dup' */
/* The binary string is followed by one token, e.g. `NP' */
/* (bound to `noaccess put') or by two separate tokens:  */
/* `noaccess' & `put'.  We position the parser right     */
/* before the next `dup', if any.                        */
/* `NP' or `|' or `noaccess' */
/* skip `put' */
/* with synthetic fonts it is possible we get here twice */
/* some fonts use a value of -1 for lenIV to indicate that */
/* the charstrings are unencoded                           */
/*                                                         */
/* thanks to Tom Kacvinsky for pointing this out           */
/*                                                         */
/* some fonts define empty subr records -- this is not totally */
/* compliant to the specification (which says they should at   */
/* least contain a `return'), but we support them anyway       */
/* t1_decrypt() shouldn't write to base -- make temporary copy */
/* some fonts like Optima-Oblique not only define the /CharStrings */
/* array but access it also                                        */
/* initialize tables, leaving space for addition of .notdef, */
/* if necessary, and a few other glyphs to handle buggy      */
/* fonts which have more glyphs than specified.              */
/* for some non-standard fonts like `Optima' which provides  */
/* different outlines depending on the resolution it is      */
/* possible to get here twice                                */
/* Initialize table for swapping index notdef_index and */
/* index 0 names and codes (if necessary).              */
/* the format is simple:        */
/*   `/glyphname' + binary data */
/* we stop when we find a `def' or `end' keyword */
/* There are fonts which have this: */
/*                                  */
/*   /CharStrings 118 dict def      */
/*   Private begin                  */
/*   CharStrings begin              */
/*   ...                            */
/*                                  */
/* To catch this we ignore `def' if */
/* no charstring has actually been  */
/* seen.                            */
/* skip `/' */
/* for some non-standard fonts like `Optima' which provides */
/* different outlines depending on the resolution it is     */
/* possible to get here twice                               */
/* add a trailing zero to the name table */
/* record index of /.notdef */
/* t1_decrypt() shouldn't write to base -- make temporary copy */
/* if /.notdef is found but does not occupy index 0, do our magic. */
/* Swap glyph in index 0 with /.notdef glyph.  First, add index 0  */
/* name and code entries to swap_table.  Then place notdef_index   */
/* name and code entries into swap_table.  Then swap name and code */
/* entries at indices notdef_index and 0 using values stored in    */
/* swap_table.                                                     */
/* Index 0 name */
/* Index 0 code */
/* Index notdef_index name */
/* Index notdef_index code */
/* notdef_index is already 0, or /.notdef is undefined in   */
/* charstrings dictionary.  Worry about /.notdef undefined. */
/* We take index 0 and add it to the end of the table(s)    */
/* and add our own /.notdef glyph to index 0.               */
/* 0 333 hsbw endchar */
/* we added a glyph. */
/*************************************************************************/
/*                                                                       */
/* Define the token field static variables.  This is a set of            */
/* T1_FieldRec variables.                                                */
/*                                                                       */
/*************************************************************************/
/* now add the special functions... */
/* look for `eexec' */
/* look for `closefile' which ends the eexec section */
/* in a synthetic font the base font starts after a           */
/* `FontDictionary' token that is placed after a Private dict */
/* check whether we have an integer */
/* in valid Type 1 fonts we don't see `RD' or `-|' directly */
/* since those tokens are handled by parse_subrs and        */
/* parse_charstrings                                        */
/* look for immediates */
/* now compare the immediate name to the keyword table */
/* We found it -- run the parsing callback!     */
/* We record every instance of every field      */
/* (until we reach the base font of a           */
/* synthetic font) to deal adequately with      */
/* multiple master fonts; this is also          */
/* necessary because later PostScript           */
/* definitions override earlier ones.           */
/* Once we encounter `FontDirectory' after      */
/* `/Private', we know that this is a synthetic */
/* font; except for `/CharStrings' we are not   */
/* interested in anything that follows this     */
/* `FontDirectory'.                             */
/* MM fonts have more than one /Private token at */
/* the top level; let's hope that all the junk   */
/* that follows the first /Private token is not  */
/* interesting to us.                            */
/* According to Adobe Tech Note #5175 (CID-Keyed */
/* Font Installation for ATM Software) a `begin' */
/* must be followed by exactly one `end', and    */
/* `begin' -- `end' pairs must be accurately     */
/* paired.  We could use this to distinguish     */
/* between the global Private and the Private    */
/* dict that is a member of the Blend dict.      */
/* initialize the tables -- simply set their `init' field to 0 */
/* finalize tables */
/* finalize parser */
/* default values */
/* ensure even-ness of `num_blue_values' */
/* we don't use it currently so just warn, reset, and ignore */
/* the following can happen for MM instances; we then treat the */
/* font as a normal PS font                                     */
/* another safety check */
/* T1_CONFIG_OPTION_NO_MM_SUPPORT */
/* now, propagate the subrs, charstrings, and glyphnames tables */
/* to the Type1 data                                            */
/* we copy the glyph names `block' and `elements' fields; */
/* the `lengths' field must be released later             */
/* we must now build type1.encoding when we have a custom array */
/* OK, we do the following: for each element in the encoding  */
/* table, look up the index of the glyph having the same name */
/* the index is then stored in type1.encoding.char_index, and */
/* a the name to type1.encoding.char_name                     */
/* Change min/max encoded char only if glyph name is */
/* not /.notdef                                      */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\type1\t1objs.c
/***************************************************************************/
/*                                                                         */
/*  t1objs.c                                                               */
/*                                                                         */
/*    Type 1 objects manager (body).                                       */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/*                            SIZE FUNCTIONS                             */
/*                                                                       */
/*  note that we store the global hints in the size's "internal" root    */
/*  field                                                                */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/*                            SLOT  FUNCTIONS                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/*                            FACE  FUNCTIONS                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    T1_Face_Done                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    The face object destructor.                                        */
/*                                                                       */
/* <Input>                                                               */
/*    face :: A typeless pointer to the face object to destroy.          */
/*                                                                       */
/* release multiple masters information */
/* release font info strings */
/* release top dictionary */
/* release afm data if present */
/* release unicode map, if any */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    T1_Face_Init                                                       */
/*                                                                       */
/* <Description>                                                         */
/*    The face object constructor.                                       */
/*                                                                       */
/* <Input>                                                               */
/*    stream     ::  input stream where to load font data.               */
/*                                                                       */
/*    face_index :: The index of the font face in the resource.          */
/*                                                                       */
/*    num_params :: Number of additional generic parameters.  Ignored.   */
/*                                                                       */
/*    params     :: Additional generic parameters.  Ignored.             */
/*                                                                       */
/* <InOut>                                                               */
/*    face       :: The face record to build.                            */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* open the tokenizer; this will also check the font format */
/* if we just wanted to check the format, leave successfully now */
/* check the face index */
/* now load the font program into the face object */
/* initialize the face object fields */
/* set up root face fields */
/* XXX: TODO -- add kerning with .afm support */
/* The following code to extract the family and the style is very   */
/* simplistic and might get some things wrong.  For a full-featured */
/* algorithm you might have a look at the whitepaper given at       */
/*                                                                  */
//blogs.msdn.com/text/archive/2007/04/23/wpf-font-selection-model.aspx */
/*   http://blogs.msdn.com/text/archive/2007/04/23/wpf-font-selection-model.aspx */
/* get style name -- be careful, some broken fonts only */
/* have a `/FontName' dictionary entry!                 */
/* do we have a `/FontName'? */
/* assume `Regular' style because we don't know better */
/* compute style flags */
/* no embedded bitmap support */
/* no `U' suffix here to 0xFFFF! */
/* Set units_per_EM if we didn't set it in parse_font_matrix. */
/* now compute the maximum advance width */
/* in case of error, keep the standard width */
/* clear error */
/* first of all, try to synthesize a Unicode charmap */
/* now, generate an Adobe Standard encoding when appropriate */
/* Select default charmap */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    T1_Driver_Init                                                     */
/*                                                                       */
/* <Description>                                                         */
/*    Initializes a given Type 1 driver object.                          */
/*                                                                       */
/* <Input>                                                               */
/*    driver :: A handle to the target driver object.                    */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    T1_Driver_Done                                                     */
/*                                                                       */
/* <Description>                                                         */
/*    Finalizes a given Type 1 driver.                                   */
/*                                                                       */
/* <Input>                                                               */
/*    driver :: A handle to the target Type 1 driver.                    */
/*                                                                       */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\type1\t1parse.c
/***************************************************************************/
/*                                                                         */
/*  t1parse.c                                                              */
/*                                                                         */
/*    Type 1 parser (body).                                                */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2008, 2009 by             */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The Type 1 parser is in charge of the following:                      */
/*                                                                       */
/*  - provide an implementation of a growing sequence of objects called  */
/*    a `T1_Table' (used to build various tables needed by the loader).  */
/*                                                                       */
/*  - opening .pfb and .pfa files to extract their top-level and private */
/*    dictionaries.                                                      */
/*                                                                       */
/*  - read numbers, arrays & strings from any dictionary.                */
/*                                                                       */
/* See `t1load.c' to see how data is loaded from the font file.          */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/*****                                                               *****/
/*****                   INPUT STREAM PARSER                         *****/
/*****                                                               *****/
/*************************************************************************/
/*************************************************************************/
/*************************************************************************/
/* see Adobe Technical Note 5040.Download_Fonts.pdf */
/* We assume that the first segment in a PFB is always encoded as   */
/* text.  This might be wrong (and the specification doesn't insist */
/* on that), but we have never seen a counterexample.               */
/* check the header format */
/******************************************************************/
/*                                                                */
/* Here a short summary of what is going on:                      */
/*                                                                */
/*   When creating a new Type 1 parser, we try to locate and load */
/*   the base dictionary if this is possible (i.e., for PFB       */
/*   files).  Otherwise, we load the whole font into memory.      */
/*                                                                */
/*   When `loading' the base dictionary, we only setup pointers   */
/*   in the case of a memory-based stream.  Otherwise, we         */
/*   allocate and load the base dictionary in it.                 */
/*                                                                */
/*   parser->in_pfb is set if we are in a binary (`.pfb') font.   */
/*   parser->in_memory is set if we have a memory stream.         */
/*                                                                */
/* try to compute the size of the base dictionary;     */
/* look for a Postscript binary file tag, i.e., 0x8001 */
/* assume that this is a PFA file for now; an error will */
/* be produced later when more things are checked        */
/* now, try to load `size' bytes of the `base' dictionary we */
/* found previously                                          */
/* if it is a memory-based resource, set up pointers */
/* check that the `size' field is valid */
/* read segment in memory -- this is clumsy, but so does the format */
/* always free the private dictionary */
/* free the base dictionary only when we have a disk stream */
/* in the case of the PFB format, the private dictionary can be  */
/* made of several segments.  We thus first read the number of   */
/* segments to compute the total size of the private dictionary  */
/* then re-read them into memory.                                */
/* Check that we have a private dictionary there */
/* and allocate private dictionary buffer        */
/* We have already `loaded' the whole PFA font file into memory; */
/* if this is a memory resource, allocate a new block to hold    */
/* the private dict.  Otherwise, simply overwrite into the base  */
/* dictionary block in the heap.                                 */
/* first of all, look at the `eexec' keyword */
/* 9 = 5 letters for `eexec' + */
/* newline + 4 chars           */
/* check whether `eexec' was real -- it could be in a comment */
/* or string (as e.g. in u003043t.gsf from ghostscript)       */
/* we haven't found the correct `eexec'; go back and continue */
/* searching                                                  */
/* now determine where to write the _encrypted_ binary private  */
/* dictionary.  We overwrite the base dictionary for disk-based */
/* resources and allocate a new block otherwise                 */
/* according to the Type1 spec, the first cipher byte must not be  */
/* an ASCII whitespace character code (blank, tab, carriage return */
/* or line feed).  We have seen Type 1 fonts with two line feed    */
/* characters...  So skip now all whitespace character codes.      */
/* note that we allocate one more byte to put a terminating `0' */
/* now determine whether the private dictionary is encoded in binary */
/* or hexadecimal ASCII format -- decode it accordingly              */
/* we need to access the next 4 bytes (after the final \r following */
/* the `eexec' keyword); if they all are hexadecimal digits, then   */
/* we have a case of ASCII storage                                  */
/* ASCII hexadecimal encoding */
/* put a safeguard */
/* binary encoding -- copy the private dict */
/* we now decrypt the encoded binary private dictionary */
/* replace the four random bytes at the beginning with whitespace */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\type1\type1.c
/***************************************************************************/
/*                                                                         */
/*  type1.c                                                                */
/*                                                                         */
/*    FreeType Type 1 driver component (body only).                        */
/*                                                                         */
/*  Copyright 1996-2001 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\type42\t42drivr.c
/***************************************************************************/
/*                                                                         */
/*  t42drivr.c                                                             */
/*                                                                         */
/*    High-level Type 42 driver interface (body).                          */
/*                                                                         */
/*  Copyright 2002, 2003, 2004, 2006, 2007, 2009 by Roberto Alameda.       */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* This driver implements Type42 fonts as described in the               */
/* Technical Note #5012 from Adobe, with these limitations:              */
/*                                                                       */
/* 1) CID Fonts are not currently supported.                             */
/* 2) Incremental fonts making use of the GlyphDirectory keyword         */
/*    will be loaded, but the rendering will be using the TrueType       */
/*    tables.                                                            */
/* 3) As for Type1 fonts, CDevProc is not supported.                     */
/* 4) The Metrics dictionary is not supported.                           */
/* 5) AFM metrics are not supported.                                     */
/*                                                                       */
/* In other words, this driver supports Type42 fonts derived from        */
/* TrueType fonts in a non-CID manner, as done by usual conversion       */
/* programs.                                                             */
/*                                                                       */
/*************************************************************************/
/*
/*
/*
/*
/* format interface */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\type42\t42objs.c
/***************************************************************************/
/*                                                                         */
/*  t42objs.c                                                              */
/*                                                                         */
/*    Type 42 objects manager (body).                                      */
/*                                                                         */
/*  Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009               */
/*  by Roberto Alameda.                                                    */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* now, propagate the charstrings and glyphnames tables */
/* to the Type1 data                                    */
/* we copy the glyph names `block' and `elements' fields; */
/* the `lengths' field must be released later             */
/* we must now build type1.encoding when we have a custom array */
/* OK, we do the following: for each element in the encoding   */
/* table, look up the index of the glyph having the same name  */
/* as defined in the CharStrings array.                        */
/* The index is then stored in type1.encoding.char_index, and  */
/* the name in type1.encoding.char_name                        */
/* Change min/max encoded char only if glyph name is */
/* not /.notdef                                      */
/***************** Driver Functions *************/
/* open the tokenizer, this will also check the font format */
/* if we just wanted to check the format, leave successfully now */
/* check the face index */
/* Now load the font program into the face object */
/* Init the face object fields */
/* Now set up root face fields */
/* We only set this flag if we have the patented bytecode interpreter. */
/* There are no known `tricky' Type42 fonts that could be loaded with  */
/* the unpatented interpreter.                                         */
/* XXX: TODO -- add kerning with .afm support */
/* get style name -- be careful, some broken fonts only */
/* have a `/FontName' dictionary entry!                 */
/* assume "Regular" style if we don't know better */
/* do we have a `/FontName'? */
/* no embedded bitmap support */
/* Load the TTF font embedded in the T42 font */
/* Ignore info in FontInfo dictionary and use the info from the  */
/* loaded TTF font.  The PostScript interpreter also ignores it. */
/* compute style flags */
/* first of all, try to synthesize a Unicode charmap */
/* now, generate an Adobe Standard encoding when appropriate */
/* Select default charmap */
/* delete internal ttf face prior to freeing face->ttf_data */
/* release font info strings */
/* release top dictionary */
/* release afm data if present */
/* release unicode map, if any */
/*************************************************************************/
/*                                                                       */
/* <Function>                                                            */
/*    T42_Driver_Init                                                    */
/*                                                                       */
/* <Description>                                                         */
/*    Initializes a given Type 42 driver object.                         */
/*                                                                       */
/* <Input>                                                               */
/*    driver :: A handle to the target driver object.                    */
/*                                                                       */
/* <Return>                                                              */
/*    FreeType error code.  0 means success.                             */
/*                                                                       */
/* First glyph slot for this face */
/* free bitmap if needed */
/* clear all public fields in the glyph slot */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\type42\t42parse.c
/***************************************************************************/
/*                                                                         */
/*  t42parse.c                                                             */
/*                                                                         */
/*    Type 42 font parser (body).                                          */
/*                                                                         */
/*  Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by            */
/*  Roberto Alameda.                                                       */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* as Type42 fonts have no Private dict,         */
/* we set the last argument of T1_FIELD_XXX to 0 */
/********************* Parsing Functions ******************/
/*******************************************************************/
/*                                                                 */
/* Here a short summary of what is going on:                       */
/*                                                                 */
/*   When creating a new Type 42 parser, we try to locate and load */
/*   the base dictionary, loading the whole font into memory.      */
/*                                                                 */
/*   When `loading' the base dictionary, we only set up pointers   */
/*   in the case of a memory-based stream.  Otherwise, we allocate */
/*   and load the base dictionary in it.                           */
/*                                                                 */
/*   parser->in_memory is set if we have a memory stream.          */
/*                                                                 */
/* now, try to load `size' bytes of the `base' dictionary we */
/* found previously                                          */
/* if it is a memory-based resource, set up pointers */
/* check that the `size' field is valid */
/* read segment in memory */
/* free the base dictionary only when we have a disk stream */
/* Set Units per EM based on FontMatrix values.  We set the value to */
/* 1000 / temp_scale, because temp_scale was already multiplied by   */
/* 1000 (in t1_tofixed, from psobjs.c).                              */
/* we need to scale the values by 1.0/temp_scale */
/* note that the offsets must be expressed in integer font units */
/* if we have a number or `[', the encoding is an array, */
/* and we must load it now                               */
/* read the number of entries in the encoding; should be 256 */
/* we use a T1_Table to store our charnames */
/* We need to `zero' out encoding_table.elements */
/* Now we need to read records of the form                */
/*                                                        */
/*   ... charcode /charname ...                           */
/*                                                        */
/* for each entry in our table.                           */
/*                                                        */
/* We simply look for a number followed by an immediate   */
/* name.  Note that this ignores correctly the sequence   */
/* that is often seen in type42 fonts:                    */
/*                                                        */
/*   0 1 255 { 1 index exch /.notdef put } for dup        */
/*                                                        */
/* used to clean the encoding array before anything else. */
/*                                                        */
/* Alternatively, if the array is directly given as       */
/*                                                        */
/*   /Encoding [ ... ]                                    */
/*                                                        */
/* we only read immediates.                               */
/* we stop when we encounter `def' or `]' */
/* check whether we have found an entry */
/* Otherwise, we should have either `StandardEncoding', */
/* `ExpertEncoding', or `ISOLatin1Encoding'             */
/* The format is                                */
/*                                              */
/*   /sfnts [ <hexstring> <hexstring> ... ] def */
/*                                              */
/* or                                           */
/*                                              */
/*   /sfnts [                                   */
/*      <num_bin_bytes> RD <binary data>        */
/*      <num_bin_bytes> RD <binary data>        */
/*      ...                                     */
/*   ] def                                      */
/*                                              */
/* with exactly one space after the `RD' token. */
/* don't include delimiters */
/* `RD' */
/* one space after `RD' */
/* A string can have a trailing zero byte for padding.  Ignore it. */
/* load offset table, 12 bytes */
/* fall through */
/* the offset table is read; read the table directory */
/* Pad to a 4-byte boundary length */
/* there are no more than 256 tables, so no size check here */
/* fall through */
/* all other tables are just copied */
/* if control reaches this point, the format was not valid */
/* We have `<< ... >>'.  Count the number of `/' in the dictionary */
/* to get its size.                                                */
/* rewind */
/* initialize tables */
/* Initialize table for swapping index notdef_index and */
/* index 0 names and codes (if necessary).              */
/* The format is simple:                   */
/*   `/glyphname' + index [+ def]          */
/* We stop when we find an `end' keyword or '>' */
/* skip `/' */
/* add a trailing zero to the name table */
/* record index of /.notdef */
/* if /.notdef does not occupy index 0, do our magic. */
/* Swap glyph in index 0 with /.notdef glyph.  First, add index 0  */
/* name and code entries to swap_table.  Then place notdef_index   */
/* name and code entries into swap_table.  Then swap name and code */
/* entries at indices notdef_index and 0 using values stored in    */
/* swap_table.                                                     */
/* Index 0 name */
/* Index 0 code */
/* Index notdef_index name */
/* Index notdef_index code */
/* if the keyword has a dedicated callback, call it */
/* now the keyword is either a simple field or a table of fields; */
/* we are now going to take care of it                            */
/* look for `FontDirectory' which causes problems for some fonts */
/* skip the `FontDirectory' keyword */
/* look up the `known' keyword */
/* skip the `known' keyword and the token following it */
/* if the last token was an array, skip it! */
/* look for immediates */
/* now compare the immediate name to the keyword table */
/* loop through all known keywords */
/* we found it -- run the parsing callback! */
/* initialize the tables -- simply set their `init' field to 0 */
/* finalize tables */
/* finalize parser */
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\type42\type42.c
/***************************************************************************/
/*                                                                         */
/*  type42.c                                                               */
/*                                                                         */
/*    FreeType Type 42 driver component.                                   */
/*                                                                         */
/*  Copyright 2002 by                                                      */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libfreetype\src\winfonts\winfnt.c
/***************************************************************************/
/*                                                                         */
/*  winfnt.c                                                               */
/*                                                                         */
/*    FreeType font driver for Windows FNT/FON files                       */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2003, 2004, 2006, 2007, 2008, 2009 by       */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*  Copyright 2003 Huw D M Davies for Codeweavers                          */
/*  Copyright 2007 Dmitry Timoshkov for Codeweavers                        */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/
/*************************************************************************/
/*                                                                       */
/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
/* messages during execution.                                            */
/*                                                                       */
/* PE00 */
/* 0x014c - i386 */
/* 0x10b */
/* first of all, read the FNT header */
/* check header */
/* Version 2 doesn't have these fields */
/* this is a FNT file/table; extract its frame */
/* does it begin with an MZ header? */
/* yes, now look for an NE header in the file */
/* good, now look into the resource table for each FNT resource */
/* loading `winfnt_header_fields' needs at least 118 bytes;    */
/* use this as a rough measure to check the expected font size */
/* check full signature */ ||
/* i386 */                        ||
/* FIXME */         ||
/* DataIsDirectory */ )
/* DataIsDirectory */ )
/* DataIsDirectory */ )
/* RT_FONT */ )
/* we artificially increase the glyph index; */
/* FNT_Load_Glyph reverts to the right one   */
/* try to load font from a DLL */
/* this didn't work; try to load a single FNT font */
/* we now need to fill the root FT_Face fields */
/* with relevant information                   */
/* set up the `fixed_sizes' array */
/*
/* initial platform/encoding should indicate unset status? */
/*        charmap.encoding_id = TT_MAC_ID_ROMAN; */
/* Select default charmap */
/* setup remaining flags */
/* reserve one slot for the .notdef glyph at index 0 */
/* Some broken fonts don't delimit the face name with a final */
/* NULL byte -- the frame is erroneously one byte too small.  */
/* We thus allocate one more byte, setting it explicitly to   */
/* zero.                                                      */
/* revert to real index */
/* the .notdef glyph */
/* jump to glyph entry */
/* jump to glyph data */
/* font->header.bits_offset */ + offset;
/* allocate and build bitmap */
/* note: since glyphs are stored in columns and not in rows we */
/*       can't use ft_glyphslot_set_bitmap                     */
/* now set up metrics */
/*
/* END */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libpng\png.c
/* png.c - location for general purpose libpng functions
/* Generate a compiler error if there is an old png.h in the search path. */
/* Tells libpng that we have already handled the first "num_bytes" bytes
/* Checks whether the supplied bytes match the PNG signature.  We allow
/* READ */
/* Function to allocate memory for zlib */
/* PRIVATE */,
/* Function to free memory for zlib */
/* PRIVATE */
/* Reset the CRC variable to 32 bits of 1's.  Care must be taken
/* PRIVATE */
/* The cast is safe because the crc is a 32 bit value. */
/* Calculate the CRC over a section of data.  We can only pass as
/* PRIVATE */
/* critical */
/* 'uLong' is defined in zlib.h as unsigned long; this means that on some
/* Should never issue a warning */
/* evil, but safe */
/* The following should never issue compiler warnings; if they do the
/* And the following is always safe because the crc is only 32 bits. */
/* Check a user supplied version number, called from both read and write
/* Libpng versions 1.0.0 and later are binary compatible if the version
/* Success return. */
/* Generic function to create a png_struct for either read or write - this
/* PRIVATE */,
/* This temporary stack-allocated structure is used to provide a place to
/* Added at libpng-1.2.6 */
/* Added at libpng-1.2.43 and 1.4.0 */
/* Added at libpng-1.2.43 and 1.4.1, required only for read but exists
/* The following two API calls simply set fields in png_struct, so it is safe
/* (*error_fn) can return control to the caller after the error_ptr is set,
/* Temporarily fake out the longjmp information until we have
/*stack allocation*/
/* Call the general version checker (shared with read and write code):
/* png_ptr->zstream holds a back-pointer to the png_struct, so
/* Eliminate the local error handling: */
/* This is the successful return point */
/* A longjmp because of a bug in the application storage allocator or a
/* Allocate the memory for an info_struct for the application. */
/* Use the internal API that does not (or at least should not) error out, so
/* This function frees the memory associated with a single info struct.
/* Do this first in case of an error below; if the app implements its own
/* Initialize the info structure.  This is now an internal function (0.89)
/* The following line is why this API should not be used: */
/* Set everything to 0 */
/* The following API is not called internally */
/* Free text item num or (if num == -1) all text items */
/* Free any tRNS entry */
/* Free any sCAL entry */
/* Free any pCAL entry */
/* Free any profile entry */
/* Free a given sPLT entry, or (if num == -1) all sPLT entries */
/* Free any hIST entry */
/* Free any PLTE entry that was internally allocated */
/* Free any image bits attached to the info structure */
/* READ || WRITE */
/* This function returns a pointer to the io_ptr associated with the user
/* Initialize the default input/output functions for the PNG file.  If you
/* The png_save_int_32 function assumes integers are stored in two's
/* Convert the supplied time into an RFC 1123 string suitable for use in
/* RFC1123 limitation */ ||
/* enough for a four-digit year */
/* This reliably terminates the buffer */
/* To do: remove the following from libpng-1.7 */
/* Original API that uses a private buffer in png_struct.
/* The only failure above if png_ptr != NULL is from an invalid ptime */
/* TIME_RFC1123 */
/* READ || WRITE */
/* Silence compiler warning about unused png_ptr */
/* The following return the library version as a short string in the
/* Version of *.c files used when building libpng */
/* Version of *.h files used when building libpng */
/* Silence compiler warning about unused png_ptr */
/* Returns longer string containing both version and date */
/* Silence compiler warning about unused png_ptr */
/* NOTE: this routine is not used internally! */
/* Build a grayscale palette.  Palette is assumed to be 1 << bit_depth
/* Check chunk_name and return "keep" value if it's on the list, else 0 */
/* beyond end */
/* The code is the fifth byte after each four byte string.  Historically this
/* num_chunk_list > 0, so at least one */
/* This means that known chunks should be processed and unknown chunks should
/* PRIVATE */
/* READ_UNKNOWN_CHUNKS || HANDLE_AS_UNKNOWN */
/* SET_UNKNOWN_CHUNKS */
/* This function, added to libpng-1.0.6g, is untested. */
/* WARNING: this resets the window bits to the maximum! */
/* READ */
/* This function was added to libpng-1.0.7 */
/* Version of *.c files used when building libpng */
/* Ensure that png_ptr->zstream.msg holds some appropriate error message string.
/* PRIVATE */
/* Translate 'ret' into an appropriate error string, priority is given to the
/* Normal exit */
/* This means the deflate stream did not have a dictionary; this
/* gz APIs only: should not happen */
/* internal libpng error */
/* End of input or output; not a problem if the caller is doing
/* Compile errors here mean that zlib now uses the value co-opted in
/* png_convert_size: a PNGAPI but no longer in png.h, so deleted
/* Added at libpng version 1.2.34 and 1.4.0 (moved from pngset.c) */
/* always set if COLORSPACE */
/* This is called to check a new gamma value against an existing one.  The
/* Either this is an sRGB image, in which case the calculated gamma
/* Do not overwrite an sRGB value */
/* sRGB tag not involved */
/* PRIVATE */
/* Changed in libpng-1.5.4 to limit the values to ensure overflow can't
/* Allow the application to set the gamma value more than once */
/* Do nothing if the colorspace is already invalid */
/*from gAMA*/) != 0)
/* Store this gamma value. */
/* At present if the check_gamma test fails the gamma of the colorspace is
/* Error exit - errmsg has been set. */
/* PRIVATE */
/* Everything is invalid */
/* Clean up the iCCP profile now if it won't be used. */
/*not used*/);
/* Leave the INFO_iCCP flag set if the pngset.c code has already set
/* PRIVATE */
/* reduce code size; check here not in the caller */
/* Added at libpng-1.5.5 to support read and write of true CIEXYZ values for
/* The reference white is simply the sum of the end-point (X,Y,Z) vectors,
/* Check xy and, implicitly, z.  Note that wide gamut color spaces typically
/* The reverse calculation is more difficult because the original tristimulus
/* By the argument, above overflow should be impossible here. The return
/* Now find the red numerator. */
/* Overflow is possible here and it indicates an extreme set of PNG cHRM
/* r+g+b scales = white scale */)
/* Similarly for green_inverse: */
/* And the blue scale, the checks above guarantee this can't overflow but it
/* And fill in the png_XYZ: */
/*success*/
/* Normalize by scaling so the sum of the end-point Y values is PNG_FP_1.
/* Allow an error of +/-0.01 (absolute value) on each chromaticity */
/* Added in libpng-1.6.0, a different check for the validity of a set of cHRM
/* As a side-effect this routine also returns the XYZ endpoints. */
/*actually, the math is pretty accurate*/) != 0)
/* Too much slip */
/* This is the check going the other way.  The XYZ is modified to normalize it
/* Used to check for an endpoint match against sRGB */
/* From ITU-R BT.709-3 */
/* color      x       y */
/* red   */ 64000, 33000,
/* green */ 30000, 60000,
/* blue  */ 15000,  6000,
/* white */ 31270, 32900
/* The consistency check is performed on the chromaticities; this factors out
/* The end points must be reasonably close to any we already have.  The
/* failed */
/* Only overwrite with preferred values */
/* ok, but no change */
/* The end points are normally quoted to two decimal digits, so allow +/-0.01
/* ok and changed */
/* PRIVATE */
/* We must check the end points to ensure they are reasonable - in the past
/* success */
/* We can't invert the chromaticities so we can't produce value XYZ
/* libpng is broken; this should be a warning but if it happens we
/* failed */
/* PRIVATE */
/* End points are invalid. */
/* failed */
/* Error message generation */
/* checks all the top bits */ &&
/* see below for calculation */
/* 9 chars */
/* Truncate to 79 chars */
/* +2 = 90 */
/* So 'value' is at most 4 bytes and the following cast is safe */
/* total +8; less than the else clause */
/* +24 = 114*/
/*+2 = 116*/
/* The 'reason' is an arbitrary message, allow +79 maximum 195 */
/* This is recoverable, but make it unconditionally an app_error on write to
/* sRGB || iCCP */
/* PRIVATE */
/* sRGB sets known gamma, end points and (from the chunk) intent. */
/* IMPORTANT: these are not necessarily the values found in an ICC profile
/* D65 XYZ (*not* the D50 adapted values!) */
/* color      X      Y      Z */
/* red   */ 41239, 21264,  1933,
/* green */ 35758, 71517, 11919,
/* blue  */ 18048,  7219, 95053
/* Do nothing if the colorspace is already invalidated. */
/* Check the intent, then check for existing settings.  It is valid for the
/* If the standard sRGB cHRM chunk does not match the one from the PNG file
/* This check is just done for the error reporting - the routine always
/*from sRGB*/);
/* intent: bugs in GCC force 'int' to be used as the parameter type. */
/* endpoints */
/* gamma */
/* Finally record that we have an sRGB profile */
/* set */
/* sRGB */
/* Encoded value of D50 as an ICC XYZNumber.  From the ICC 2010 spec the value
/* PRIVATE */
/* PRIVATE */
/* first 132 bytes only */, int color_type)
/* Length check; this cannot be ignored in this code because profile_length
/* tag count: 12 bytes/tag */
/* (2^32-4-132)/12: maximum possible tag count */
/* truncated tag table */
/* The 'intent' must be valid or we can't store it, ICC limits the intent to
/* The ICC limit */
/* This is just a warning because the profile may be valid in future
/* At this point the tag table can't be checked because it hasn't necessarily
/* Data checks (could be skipped).  These checks must be independent of the
/* signature 'ascp' */
/* Currently the PCS illuminant/adopted white point (the computational
/*no tag value*/,
/* The PNG spec requires this:
/* data colour space field */
/* 'RGB ' */
/* 'GRAY' */
/* It is up to the application to check that the profile class matches the
/* profile/device class */
/* 'scnr' */
/* 'mntr' */
/* 'prtr' */
/* 'spac' */
/* All supported */
/* 'abst' */
/* May not be embedded in an image */
/* 'link' */
/* DeviceLink profiles cannot be interpreted in a non-device specific
/* 'nmcl' */
/* A NamedColor profile is also device specific, however it doesn't
/* To allow for future enhancements to the profile accept unrecognized
/* For any profile other than a device link one the PCS must be encoded
/* 'XYZ ' */
/* 'Lab ' */
/* PRIVATE */
/* header plus whole tag table */)
/* The first tag */
/* First scan all the tags in the table and add bits to the icc_info value
/* must be aligned */
/* not padded */
/* The ICC specification does not exclude zero length tags, therefore the
/* CNHP730S.icc shipped with Microsoft Windows 64 violates this, it is
/* This is a hard error; potentially it can cause read outside the
/* success, maybe with warnings */
/* Information about the known ICC sRGB profiles */
/* This data comes from contrib/tools/checksum-icc run on downloads of
/* adler32, crc32, MD5[4], intent, date, length, file-name */
/* ICC sRGB v2 perceptual no black-compensation: */
/* ICC sRGB v4 perceptual */
/* The following profiles have no known MD5 checksum. If there is a match
/* This is a 'mntr' (display) profile with a mediaWhitePointTag that does not
/*broken*/,
/*broken*/,
/* The quick check is to verify just the MD5 signature and trust the
/* invalid */
/* the value for 0 length data */
/* First see if PNG_SKIP_sRGB_CHECK_PROFILE has been set to "on" */
/* This may be one of the old HP profiles without an MD5, in that
/* Profile is unsigned or more checks have been configured in. */
/* Length *and* intent must match */
/* Now calculate the adler32 if not done already. */
/* These basic checks suggest that the data has not been
/* So this check must pass for the 'return' below to happen.
/* These profiles are known to have bad data that may cause
/* Warn that this being done; this isn't even an error since
/* The signature matched, but the profile had been changed in some
/* no match */
/* PRIVATE */
/* Is this profile one of the known ICC sRGB profiles?  If it is, just set
/*already checked*/png_get_uint_32(profile+64));
/* READ_sRGB */
/* PRIVATE */
/* If no sRGB support, don't try storing sRGB information */
/* Failure case */
/* iCCP */
/* PRIVATE */
/* Set the rgb_to_gray coefficients from the colorspace. */
/* png_set_background has not been called, get the coefficients from the Y
/* We allow 0 coefficients here.  r+g+b may be 32769 if two or
/* Check for an internal error. */
/* This is a png_error at present even though it could be ignored -
/* COLORSPACE */
/* PRIVATE */
/* Check for width and height valid values */
/* Check other values */
/* Accept filter_method 64 (intrapixel differencing) only if
/* ASCII to fp functions */
/* Check an ASCII formated floating point value, see the more detailed
/* The following is used internally to preserve the sticky flags */
/* PRIVATE */
/* First find the type of the next character */
/* Now deal with this type according to the current
/* not a part of the number */
/* Ok as trailer, ok as lead of fraction. */
/* two dots */
/* trailing dot? */
/* delayed fraction */
/* case PNG_FP_FRACTION + PNG_FP_SAW_SIGN:
/* case PNG_FP_FRACTION + PNG_FP_SAW_DOT:
/* This is correct because the trailing '.' on an
/* not a part of the number */
/* case PNG_FP_EXPONENT + PNG_FP_SAW_DOT:
/* case PNG_FP_EXPONEXT + PNG_FP_SAW_E:
/* I.e. break 2 */
/* The character seems ok, continue. */
/* Here at the end, update the state and return the correct
/* The same but for a complete string. */
/* must be non-zero - see above */;
/* i.e. fail */
/* pCAL || sCAL */
/* Utility used below - a simple accurate power of ten from an integral
/* Handle negative exponent with a reciprocal at the end because
/* Decompose power bitwise. */
/* else power is 0 and d is 1 */
/* Function to format a floating point value in ASCII with a given
/* PRIVATE */
/* We use standard functions from math.h, but not printf because
/* Enforce the limit of the implementation precision too. */
/* Basic sanity checks */
/* See the requirements below. */
/* '-'  PLUS 1 TOTAL 1 */
/* A base 10 exponent */
/* 10^exp_b10 */
/* First extract a base 10 exponent of the number,
/* exponent to base 2 */
/* <= exponent to base 10 */
/* Avoid underflow here. */
/* May underflow */
/* And this may overflow. */
/* Normalize fp and correct exp_b10, after this fp is in the
/* Because of the code above fp may, at this point, be
/* Allow up to two leading zeros - this will not lengthen
/* PLUS 3 TOTAL 4 */
/* PLUS 2 digits: TOTAL 3 */
/* Dot added below before first output. */
/* No zeros to add */
/* Generate the digit list, stripping trailing zeros and
/* Count of leading zeros */
/* Count of digits in list. */
/* Use modf here, not floor and subtract, so that
/* Rounding up to 10, handle that here. */
/* Advance exp_b10 to '1', so that the
/* I.e. 1+(ch-48) */
/* Did we reach the beginning? If so adjust the
/* cdigits == 0 */
/* Leading decimal point (plus zeros?), if
/* Else lost a leading zero, so 'exp_b10' is
/* In all cases we output a '1' */
/* Guarantees termination below. */
/* Included embedded zeros in the digit count. */
/* exp_b10 == (-1) means we just output the decimal
/* PLUS 1: TOTAL 4 */
/* counted above */
/* The total output count (max) is now 4+precision */
/* Check for an exponent, if we don't need one we are
/* The following only happens if we didn't output the
/* Total buffer requirement (including the '\0') is
/* Here if an exponent is required, adjust size for
/* 'E': PLUS 1 TOTAL 2+precision */
/* The following use of an unsigned temporary avoids ambiguities in
/* '-': PLUS 1 TOTAL 3+precision */
/* Need another size check here for the exponent digits, so
/* '0' */
/* 'i' */
/* 'n' */
/* 'f' */
/* Here on buffer too small. */
/* FLOATING_POINT */
/* Function to format a fixed point value in ASCII.
/* PRIVATE */
/* Require space for 10 decimal digits, a decimal point, a minus sign and a
/* Avoid overflow here on the minimum integer. */
/* else overflowed */
/* flag value */;
/* Split the low digit off num: */
/* Record the first non-zero digit, note that this is a number
/* The remaining digits are fractional digits, ndigits is '5' or
/* decimal point */
/* ndigits may be <5 for small numbers, output leading zeros
/* Don't output the trailing zeros! */
/* And null terminate the string: */
/* Here on buffer too small. */
/* FIXED_POINT */
/* READ_SCAL */
/* muldiv functions */
/* This API takes signed arguments and rounds the result to the nearest
/* Return a * times / divisor, rounded. */
/* A png_fixed_point is a 32-bit integer. */
/* Following can't overflow because the arguments only
/* Can't overflow because the a*times bit is only 30
/* carry */
/* else overflow */
/* s32.s00 is now the 64-bit product, do a standard
/* NOTE: signed */
/* carry */
/* Handle the rounding. */
/* Check for overflow. */
/* READ_GAMMA || INCH_CONVERSIONS */
/* The following is for when the caller doesn't much care about the
/* more fixed point functions for gamma */
/* Calculate a reciprocal, return 0 on div-by-zero or overflow. */
/* error/overflow */
/* This is the shared test on whether a gamma value is 'significant' - whether
/* PRIVATE */
/* A local convenience routine. */
/* The required result is 1/a * 1/b; the following preserves accuracy. */
/* overflow */
/* 16BIT || !FLOATING_ARITHMETIC */
/* The inverse of the above. */
/* The required result is 1/a * 1/b; the following preserves accuracy. */
/* This may overflow because the range of png_fixed_point isn't symmetric,
/* overflow */
/* READ_GAMMA */
/* gamma table code */
/* Fixed point gamma.
/* The following are the values for 16-bit tables - these work fine for the
/* Each time 'x' is multiplied by 2, 1 must be subtracted off the final log,
/* result is at most 19 bits, so this cast is safe: */
/* The above gives exact (to 16 binary places) log2 values for 8-bit images,
/* As above, but now the input has 16 bits. */
/* Calculate the base logarithm from the top 8 bits as a 28-bit fractional
/* Now we need to interpolate the factor, this requires a division by the top
/* Since we divided by the top 8 bits of 'x' there will be a '1' at 1<<24,
/* <= '257' */
/* Safe, because the result can't have more than 20 bits: */
/* 16BIT */
/* The 'exp()' case must invert the above, taking a 20-bit fixed point
/* NOTE: the first entry is deliberately set to the maximum 32-bit value. */
/* Adjustment table; provided to explain the numbers in the code below. */
/* Else overflow or zero (underflow) */
/* Obtain a 4-bit approximation */
/* Incorporate the low 12 bits - these decrease the returned value by
/* And handle the low 6 bits in a single block. */
/* Handle the upper bits of x. */
/* Check for overflow */
/* Else underflow */
/* Get a 32-bit value: */
/* Convert the 32-bit value to 0..255 by multiplying by 256-1. Note that the
/* Get a 32-bit value: */
/* Convert the 32-bit value to 0..65535 by multiplying by 65536-1: */
/* 16BIT */
/* FLOATING_ARITHMETIC */
/* 'value' is unsigned, ANSI-C90 requires the compiler to correctly
/*SAFE*/value/255.,gamma_val*.00001)+.5);
/* Overflow. */
/* The same (unsigned int)->(double) constraints apply here as above,
/* Overflow. */
/* 16BIT */
/* This does the right thing based on the bit_depth field of the
/* PRIVATE */
/* should not reach this */
/* 16BIT */
/* Internal function to build a single 16-bit table - the table consists of
/* Various values derived from 'shift': */
/* CSE the division and work round wacky GCC warnings (see the comments
/* The 'threshold' test is repeated here because it can arise for one of
/* The old code would overflow at the end and this would cause the
/* Inline the 'max' scaling operation: */
/* See png_gamma_8bit_correct for why the cast to (int) is
/* We must still build a table, but do it the fast way. */
/* NOTE: this function expects the *inverse* of the overall gamma transformation
/* 'num' is the number of tables and also the number of low bits of low
/* 'gamma_val' is set to the reciprocal of the value calculated above, so
/* 8-bit output value */
/* Find the corresponding maximum input value */
/* 16-bit output value */
/* Find the boundary value in 16 bits: */
/* Adjust (round) to (16-shift) bits: */
/* And fill in the final entries. */
/* 16BIT */
/* Build a single 8-bit table: same as the 16-bit case but much simpler (and
/* Used from png_read_destroy and below to release the memory used by the gamma
/* PRIVATE */
/* 16BIT */
/* 16BIT */
/* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
/* We build the 8- or 16-bit gamma tables here.  Note that for 16-bit
/* PRIVATE */
/* Remove any existing table; this copes with multiple calls to
/* Probably doing rgb_to_gray */);
/* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
/* 16-bit gamma code uses this equation:
/* shift == insignificant bits */
/* keep all 16 bits */
/* PNG_MAX_GAMMA_8 is the number of bits to keep - effectively
/* Guarantees at least one table! */
/* NOTE: prior to 1.5.4 this test used to include PNG_BACKGROUND (now
/* Notice that the '16 from 1' table should be full precision, however
/* Probably doing rgb_to_gray */);
/* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
/* 16BIT */
/* READ_GAMMA */
/* HARDWARE OR SOFTWARE OPTION SUPPORT */
/* sRGB support */
/* sRGB conversion tables; these are machine generated with the code in
//en.wikipedia.org/wiki/SRGB)
/* The convert-to-sRGB table is only currently required for read. */
/* SIMPLIFIED_READ */
/* The base/delta tables are required for both read and write (but currently
/* SIMPLIFIED READ/WRITE sRGB support */
/* SIMPLIFIED READ/WRITE SUPPORT */
/* Double check that we have a png_ptr - it should be impossible to get here
/* First free any data held in the control structure. */
/* Ignore errors here. */
/* Copy the control structure so that the original, allocated, version can be
/* Then the structures, calling the correct API. */
/* Success. */
/* Safely call the real function, but only if doing so is safe at this point
/* Ignore errors here: */
/* PRIVATE */
/* Utility to log an error. */
/* SIMPLIFIED READ/WRITE */
/* READ || WRITE */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libpng\pngerror.c
/* pngerror.c - stub functions for i/o and memory allocation
/* PRIVATE */
/* WARNINGS */
/* This function is called whenever there is a fatal error.  This function
/* Strip "#nnnn " from beginning of error message. */
/* If the custom handler doesn't exist, or if it returns,
/* Prior to 1.5.2 the error_fn received a NULL pointer, expressed
/* If the custom handler doesn't exist, or if it returns,
/* ERROR_TEXT */
/* Utility to safely appends strings to a buffer.  This never errors out so
/* Utility to dump an unsigned value into a buffer, given a start pointer and
/* number of digits output */
/* minimum number required */
/* digit output (for the fixed point format) */
/* This is written so that the loop always runs at least once, even with
/* Needs five digits (the fraction) */
/* Expects at least 2 digits. */
/* FALL THROUGH */
/* This format expects at least two digits */
/* FALL THROUGH */
/* an error */
/* Keep track of the number of digits added */
/* Float a fixed number here: */
/* End of the fraction, but maybe nothing was output?  In that case
/* and !output */
/* This function is called whenever there is a non-fatal error.  This function
/* These functions support 'formatted' warning messages with up to
/* Avoid overflow by doing the negate in a png_alloc_size_t: */
/* The internal buffer is just 192 bytes - enough for all our messages,
/* Index in the msg[] buffer: */
/* Each iteration through the following loop writes at most one character
/* '@' at end of string is now just printed (previously it was skipped);
/* Consume the '@' */
/* Search for the parameter digit, the index in the string is the
/* If the parameter digit is out of range it will just get printed. */
/* Append this parameter */
/* No need to copy the trailing '\0' here, but there is no guarantee
/* Consume the parameter digit too: */
/* else not a parameter and there is a character after the @ sign; just
/* At this point *message can't be '\0', even in the bad parameter case
/* i is always less than (sizeof msg), so: */
/* And this is the formatted message. It may be larger than
/* WARNINGS */
/* PRIVATE */
/* PRIVATE */
/* BENIGN_ERRORS */
/* Currently limited by profile_error in png.c */
/* These utilities are used internally to build an error message that relates
/* PRIVATE */
/* iin < PNG_MAX_ERROR_TEXT, so the following is safe: */
/* WARNINGS || ERROR_TEXT */
/* READ && ERROR_TEXT */
/* WARNINGS */
/* READ */
/* PRIVATE */
/* This is always supported, but for just read or just write it
/* This API only exists if ANSI-C style error handling is used,
/* From libpng 1.6.0 the app gets one chance to set a 'jmpbuf_size' value
/* not allocated */
/* new NULL return on OOM */
/* Already allocated: check the size */
/* This is an internal error in libpng: somehow we have been left
/* png_ptr->jmp_buf_ptr = &png_ptr->jmp_buf_local; */
/* caller will probably crash: no choice here */
/* Finally fill in the function, now we have a satisfactory buffer. It is
/* PRIVATE */
/* A size of 0 is used to indicate a local, stack, allocation of the
/* This stuff is so that a failure to free the error control structure
/* Make an internal, libpng, jmp_buf to return here */
/* come back here */
/* stack allocation */
/* Return to setjmp on error */
/* *Always* cancel everything out: */
/* This is the default error handling function.  Note that replacements for
/* PRIVATE */,
/* Check on NULL only added in 1.5.4 */
/* Strip "#nnnn " from beginning of error message. */
/* Make compiler happy */
/* If control reaches this point, png_longjmp() must not return. The only
/* This function is called when there is a warning, but the library thinks
/* PRIVATE */
/* Make compiler happy */
/* Make compiler happy */
/* WARNINGS */
/* This function is called when the application wants to use another method
/* This function returns a pointer to the error_ptr associated with the user
/* Currently the above both depend on SETJMP_SUPPORTED, however it would be
/* PRIVATE */, (PNGCBAPI
/* An error is always logged here, overwriting anything (typically a warning)
/* Retrieve the jmp_buf from within the png_control, making this work for
/* Missing longjmp buffer, the following is to help debugging: */
/* Here on an internal programming error. */
/* PRIVATE */ PNGCBAPI
/* A warning is only logged if there is no prior warning or error. */
/* PRIVATE */
/* Safely execute function(arg) with png_error returning to this function. */
/* And do the cleanup prior to any failure return. */
/* SIMPLIFIED READ || SIMPLIFIED_WRITE */
/* READ || WRITE */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libpng\pngget.c
/* pngget.c - retrieval of values from info struct
/* Easy access to info, added in libpng-0.99 */
/* The following casts work because a PNG 4 byte integer only has a valid
/* The conversion is *(2.54/100), in binary (32 digits):
/* .1 */
/* .1001 */
/* .1101 */
/* .000000000000000000001 */
/* .1101000000000001101 */
/* .000000000001001 */
/* .000000000001001000000001001 */
/* .000000000001001000001001001 */
/* .110100000001001110101001001 */
/* .00000110100000001001110101001001 */
/* The argument is a PNG unsigned integer, so it is not permitted
/* Overflow. */
/* Convert from metres * 1,000,000 to inches * 100,000, meters to
/* To avoid the overflow do the conversion directly in floating
/* To avoid the overflow do the conversion directly in floating
/* pHYs */
/* INCH_CONVERSIONS */
/* png_get_channels really belongs in here, too, but it's been around longer */
/* EASY_ACCESS */
/* The XYZ APIs were added in 1.5.5 to take advantage of the code added at the
/* Quiet API change: this code used to only return the end points if a cHRM
/* This is somewhat irrelevant since the profile data returned has
/* This is redundant if we can be sure that the info_ptr values were all
/*TODO: make this work without FP support; the API is currently eliminated
/* FLOATING_ARITHMETIC */
/* FIXED_POINT */
/* FLOATING POINT */
/* sCAL */
/* pHYs */
/* if (info_ptr->color_type != PNG_COLOR_TYPE_PALETTE) */
/* These functions were added to libpng 1.2.6 and were enabled
/* This function was added to libpng 1.4.0 */
/* This function was added to libpng 1.4.1 */
/* SET_USER_LIMITS */
/* These functions were added to libpng 1.4.0 */
/* IO_STATE */
/* READ || WRITE */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libpng\pngmem.c
/* pngmem.c - stub functions for memory allocation
/* Free a png_struct */
/* PRIVATE */
/* png_free might call png_error and may certainly call
/* We may have a jmp_buf left to deallocate. */
/* Allocate memory.  For reasonable files, size should never exceed
/* png_malloc_base, an internal function added at libpng 1.6.0, does the work of
/* PRIVATE */,
/* Moved to png_malloc_base from png_malloc_default in 1.6.0; the DOS
/* checked for truncation above */
/* This is really here only to work round a spurious warning in GCC 4.6 and 4.7
/* known to be > 0 */
/* The failure case when the request is too large */
/* PRIVATE */,
/* PRIVATE */,
/* These are internal errors: */
/* Check for overflow on the elements count (so the caller does not have to
/* Because png_malloc_array worked the size calculations below cannot
/* error */
/* TEXT || sPLT || STORE_UNKNOWN_CHUNKS */
/* Various functions that have different error handling are derived from this.
/* 'm' means png_malloc */
/* Passing 'NULL' here bypasses the application provided memory handler. */
/*use malloc*/, size);
/* 'M' means png_malloc_default */
/* USER_MEM */
/* This function was added at libpng version 1.2.3.  The png_malloc_warn()
/* Free a pointer allocated by png_malloc().  If ptr is NULL, return
/* USER_MEM */
/* This function is called when the application wants to use another method
/* This function returns a pointer to the mem_ptr associated with the user
/* USER_MEM */
/* READ || WRITE */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libpng\pngpread.c
/* pngpread.c - read a png file in push mode
/* Push model modes */
/* It's easiest for the caller if we do the save; then the caller doesn't
/* This includes any pending saved bytes: */
/* So subtract the saved buffer size, unless all the data
/* At the end of png_process_data the buffer size must be 0 (see the loop
/* If is impossible for there to be a saved buffer at this point -
/* What we do with the incoming data depends on what we were previously
/* PRIVATE */
/* Read any remaining signature bytes from the stream and compare them with
/* PRIVATE */
/* SAFE, does not exceed 8 */ 
/* PRIVATE */
/* unknown handling method */
/* First we make sure we have enough data for the 4-byte chunk name
/* If we reach an IDAT chunk, this means we have read all of the
/* PRIVATE */
/* PRIVATE */
/* We want the smaller of 'skip_length' and 'save_buffer_size', but
/* We want the smaller of 'skip_length' and 'current_buffer_size', here,
/* PRIVATE */
/* PRIVATE */
/* PRIVATE */
/* TODO: this code can be commoned up with the same code in push_read */
/* We want the smaller of 'idat_size' and 'current_buffer_size', but they
/* We want the smaller of 'idat_size' and 'current_buffer_size', but they
/* PRIVATE */
/* The caller checks for a non-zero buffer length. */
/* This routine must process all the data it has been given
/* TODO: WARNING: TRUNCATION ERROR: DANGER WILL ROBINSON: */
/* Keep going until the decompressed data is all processed
/* We have data for zlib, but we must check that zlib
/* TODO: WARNING: TRUNCATION ERROR: DANGER WILL ROBINSON: */
/* Using Z_SYNC_FLUSH here means that an unterminated
/* Check for any failure before proceeding. */
/* Terminate the decompression. */
/* This may be a truncated stream (missing or
/* Skip the check on unprocessed input */
/* Did inflate output any data? */
/* Is this unexpected data after the last row?
/* Extra data. */
/* Do no more processing; skip the unprocessed
/* Do we have a complete row? */
/* And check for the end of the stream. */
/* All the data should have been processed, if anything
/* PRIVATE */
/* 1.5.6: row_info moved out of png_struct to a local here. */
/* NOTE: width of current interlaced row */
/* libpng 1.5.6: the following line was copying png_ptr->rowbytes before
/* The transformed pixel depth should match the depth now in row_info. */
/* Expand interlaced rows to full size */
/* Updates png_ptr->pass */
/* Pass 1 might be empty */
/* Skip top 4 generated rows */
/* Pass 3 might be empty */
/* Skip top two generated rows */
/* Pass 5 might be empty */
/* Skip top generated row */
/* PRIVATE */
/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
/* Start of interlace block */
/* Offset to next interlace block */
/* Start of interlace block in the y direction */
/* Offset to next interlace block in the y direction */
/* Height of interlace block.  This is not currently used - if you need
/* PRIVATE */
/* PRIVATE */
/* PRIVATE */
/* new_row is a flag here - if it is NULL then the app callback was called
/*blocky display*/);
/* PROGRESSIVE_READ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libpng\pngread.c
/* pngread.c - read a PNG file
/* Create a PNG structure for reading, and allocate any memory needed. */
/* Alternate create PNG structure for reading, and allocate any memory
/* USER_MEM */
/* Added in libpng-1.6.0; this can be used to detect a read structure if
/* In stable builds only warn if an application error can be completely
/* TODO: delay this, it can be done in png_init_io (if the app doesn't
/* Read the information before the actual image data.  This has been
/* Read and check the PNG file signature. */
/* IDAT logic needs to happen here to simplify getting the two flags
/* This should be a binary subdivision search or a hash for
/* It has been consumed */
/* SEQUENTIAL_READ */
/* Optional call to update the users info_ptr structure */
/* New in 1.6.0 this avoids the bug of doing the initializations twice */
/* Initialize palette, background, etc, after transformations
/* New in 1.6.0 this avoids the bug of doing the initializations twice */
/* SEQUENTIAL_READ */
/* Undoes intrapixel differencing,
/* MNG_FEATURES */
/* png_read_start_row sets the information (in particular iwidth) for this
/* 1.5.6: row_info moved out of png_struct to a local here. */
/* NOTE: width of current interlaced row */
/* Check for transforms that have been set but were defined out */
/* WARNINGS */
/* If interlaced and we do not need a new row, combine row and return.
/*display*/);
/*display*/);
/*display*/);
/*display*/);
/*display*/);
/*display*/);
/* Fill the row with IDAT data: */
/* libpng 1.5.6: the following line was copying png_ptr->rowbytes before
/* Intrapixel differencing */
/* The transformed pixel depth should match the depth now in row_info. */
/* Expand interlaced rows to full size */
/*display*/);
/*row*/);
/*ignored*/);
/*ignored*/);
/* SEQUENTIAL_READ */
/* Read one or more rows of image data.  If the image is interlaced,
/* SEQUENTIAL_READ */
/* Read the entire image.  If the image has an alpha channel or a tRNS
/* And make sure transforms are initialized. */
/* Caller called png_start_read_image or png_read_update_info without
/* Make sure this is set correctly */
/* Obtain the pass number, which also turns on the PNG_INTERLACE flag in
/* SEQUENTIAL_READ */
/* Read the end of the PNG file.  Will not read past the end of the
/* If png_read_end is called in the middle of reading the rows there may
/* Report invalid palette index; added at libng-1.5.10 */
/* Zero length IDATs are legal after the last IDAT has been
/* SEQUENTIAL_READ */
/* Free all memory used in the read struct */
/* NOTE: the 'setjmp' buffer may still be allocated and the memory and error
/* Free all memory used by the read */
/* libpng 1.6.0: use the API to destroy info structs to ensure consistent
/* png_read_info() gives us all of the information from the
/* -------------- image transformations start here ------------------- */
/* libpng 1.6.10: add code to cause a png_app_error if a selected TRANSFORM
/* Tell libpng to strip 16-bit/color files down to 8 bits per color.
/* Added at libpng-1.5.4. "strip_16" produces the same result that it
/* If both SCALE and STRIP are required pngrtran will effectively cancel the
/* Strip alpha bytes from the input data without combining with
/* Extract multiple pixels with bit depths of 1, 2, or 4 from a single
/* Change the order of packed pixels to least significant bit first
/* Expand paletted colors into true RGB triplets
/* We don't handle background color or gamma transformation or quantizing.
/* Invert monochrome files to have 0 as white and 1 as black
/* If you want to shift the pixel values from the range [0,255] or
/* Flip the RGB pixels to BGR (or RGBA to BGRA) */
/* Swap the RGBA or GA data to ARGB or AG (or BGRA to ABGR) */
/* Swap bytes of 16-bit files to least significant byte first */
/* Added at libpng-1.2.41 */
/* Invert the alpha channel from opacity to transparency */
/* Added at libpng-1.2.41 */
/* Expand grayscale image to RGB */
/* Added at libpng-1.5.4 */
/* We don't handle adding filler bytes */
/* We use png_read_image and rely on that for interlace handling, but we also
/* Optional call to gamma correct and add the background to the palette
/* -------------- image transformations end here ------------------- */
/* Read rest of file, and get additional chunks in info_ptr - REQUIRED */
/* INFO_IMAGE */
/* SEQUENTIAL_READ */
/* SIMPLIFIED READ
/* Arguments to png_image_finish_read: */
/* Encoding of PNG data (used by the color-map code) */
/* File encoding not yet known */
/* 8-bit encoded to sRGB gamma */
/* 16-bit linear: not encoded, NOT pre-multiplied! */
/* 8-bit encoded to file gamma, not sRGB or linear */
/* 8-bit linear: only from a file value */
/* Color-map processing: after libpng has run on the PNG image further
/* Process GA data to a color-map with alpha */
/* Process GA data to a background index */
/* Process RGB data */
/* Process RGBA data */
/* The following document where the background is for each processing case. */
/* Arguments: */
/* Local variables: */
/* step between rows */
/* E_ values above */
/* For P_FILE, reciprocal of gamma */
/* PNG_CMAP_ values above */
/* Do all the *safe* initialization - 'safe' means that png_error won't be
/* And set the rest of the structure to NULL to ensure that the various
/* Error clean up */
/* Utility to find the base format of a PNG file from a png_struct. */
/* Use png_ptr here, not info_ptr, because by examination png_handle_tRNS
/* Is the given gamma significantly different from sRGB?  The test is the same
/* An uninitialized gamma is assumed to be sRGB for the simplified API. */
/* i.e. *2.2, rounded */);
/* Do the main body of a 'png_image_begin_read' function; read the PNG file
/*warn*/);
/* Do this the fast way; just read directly out of png_struct. */
/* Does the colorspace match sRGB?  If there is no color endpoint
/* We need the maximum number of entries regardless of the format the
/* This is slightly evil, but png_init_io doesn't do anything other
/* Clean up: just the opened file. */
/* STDIO */
/* Now set the IO functions to read from the memory buffer and
/* Utility function to skip chunks that are not used by the simplified image
/* Prepare the reader to ignore all recognized chunks whose data will not
/* bKGD */
/* cHRM */
/* gAMA */
/* iCCP */
/* sBIT */
/* sRGB */
/* Ignore unknown chunks and all other chunks except for the
/* But do not ignore image data handling chunks */
/*SAFE*/(sizeof chunks_to_process)/5);
/* HANDLE_AS_UNKNOWN */
/* The following macro gives the exact rounded answer for all values in the
/* Utility functions to make particular color-maps */
/* double check */
/* must be the file encoding */
/* The file value is composed on the background, the background has the given
/* The alpha is always an 8-bit value (it comes from the palette), the value
/* Scale to 65535; divide by 255, approximately (in fact this is extremely
/* Now scaled by 65535 */
/* P_sRGB */
/* NOTE: P_LINEAR values to this routine must be 16-bit, but P_FILE values must
/* Update the cache with whether the file gamma is significantly different
/* Note that the cached value may be P_FILE too, but if it is then the
/* This encoding occurs quite frequently in test cases because PngSuite
/* The values are 8-bit sRGB values, but must be converted to 16-bit
/* This is set if the color isn't gray but the output is. */
/* NOTE: these values are copied from png_do_rgb_to_gray */
/* y is scaled by 32768, we need it scaled by 255: */
/* Store the value. */
/* The linear 16-bit values must be pre-multiplied by the alpha channel
/* FALL THROUGH */
/* FALL THROUGH */
/* output encoding is P_sRGB */
/* Alpha is retained, the output will be a color-map with entries
// opaque
// The 231 entries are selected to make the math below work:
// transparent
// partially opaque
/* 255 is used here for the component values for consistency with the code
/* Build a 6x6x6 opaque RGB cube */
/* Return a palette index to the above palette given three 8-bit sRGB values. */
/* Output processing option */
/* Encoding libpng must produce */
/* Background information; the background color and the index of this color
/* Flags to accumulate things that need to be done to the input. */
/* Exclude the NYI feature of compositing onto a color-mapped buffer; it is
/* alpha in input */ &&
/* no alpha in output */)
/* compose on black */
/* no way to remove it */)
/* Get a copy of the background color (this avoids repeating the checks
/* Default the input file gamma if required - this is necessary because
/* Do this directly, not using the png_colorspace functions, to ensure
/* Decide what to do based on the PNG color type of the input data.  The
/* There at most 256 colors in the output, regardless of
/*ignore*/, back_alpha = 0;
/* If there is a tRNS chunk then this either selects a transparent
/* png_create_colormap_entry just takes an RGBA and writes the
/* 'i' is a file value.  While this will result in duplicated
/*8-bit with file gamma*/);
/* Else this entry is transparent.  The colors don't matter if
/* We need libpng to preserve the original encoding. */
/* The rows from libpng, while technically gray values, are now also
/* bit depth is 16 */
/* The 16-bit input values can be converted directly to 8-bit gamma
/* Background is gray; no special processing will be
/* And make sure the corresponding palette entry
/* The background passed to libpng, however, must be the
/*unused*/
/* NOTE: does this work without expanding tRNS to alpha?
/*need_expand*/,
/*gamma: not used*/);
/* output_processing means that the libpng-processed row will be
/* And set (overwrite) color-map entry 254 to the actual
/* 8-bit or 16-bit PNG with two channels - gray and alpha.  A minimum
/* alpha is removed */
/* Alpha must be removed as the PNG data is processed when the
/* Background is gray; no special processing will be required. */
/* And make sure the corresponding palette entry matches. */
/* The background passed to libpng, however, must be the sRGB
/*unused*/
/*need_expand*/,
/*gamma: not used*/);
/* This is the same as png_make_ga_colormap, above, except that
/* NOTE: this preserves the full precision of the application
/* For non-opaque input composite on the sRGB background - this
/* else already linear */
/* This may produce a value not exactly matching the
/* PNG_sRGB_FROM_LINEAR expects a 16-bit linear value scaled
/* Exclude the case where the output is gray; we can always handle this
/* The color-map will be grayscale, so we may as well convert the
/* The output will now be one or two 8-bit gray or gray+alpha
/* Both input and output have an alpha channel, so no background
/* Either the input or the output has no alpha channel, so there
/* Ideally this code would use libpng to do the gamma correction,
/* But if the input has alpha or transparency it must be removed
/* We need to ensure that the application background exists in
/* from the fixup above */
/* The app supplied a gray which is in output_encoding, we
/* now P_LINEAR */
/* now P_FILE */
/* And make sure the corresponding palette entry contains
/*unused*/, output_encoding);
/* And make sure the corresponding palette entry matches.
/*unused*/, P_LINEAR);
/* The background passed to libpng, however, must be the
/*unused*/
/* NOTE: the following is apparently a bug in libpng. Without
/*need_expand*/,
/*gamma: not used*/);
/* output is color */
/* We could use png_quantize here so long as there is no transparent
/* Is there any transparency or alpha? */
/* Is there alpha in the output too?  If so all four channels are
/* Add a transparent entry. */
/* This is stored as the background index for the processing
/* Add 27 r,g,b entries each with alpha 0.5. */
/* This generates components with the values 0, 127 and
/* Alpha/transparency must be removed.  The background must
/* sRGB background */
/*unused*/, output_encoding);
/* Compare the newly-created color-map entry with the one the
/* The background color must be added. */
/* Add 27 r,g,b entries each with created by composing with
/* This generates components with the values 0, 127
/*unused*/, output_encoding);
/* background color is in the standard color-map */
/*unused*/
/*need_expand*/,
/*gamma: not used*/);
/* no alpha or transparency in the input */
/* Alpha in the output is irrelevant, simply map the opaque input
/* It's already got a color-map.  It may be necessary to eliminate the
/* Just in case: */
/* Don't change from color-map indices */
/* Must compose the PNG file color in the color-map entry
/*8-bit*/);
/* The PNG data may have indices packed in fewer than 8 bits, it
/*NOT REACHED*/
/* Now deal with the output processing */
/* Change to 8-bit sRGB */
/* FALL THROUGH */
/* Double check using the recorded background index */
/*ok*/;
/* The final part of the color-map read called from png_image_finish_read. */
/* Called when the libpng data must be transformed into the color-mapped
/* The row may be empty for a short image: */
/* Read read the libpng data into the temporary buffer. */
/* Now process the row according to the processing option, note
/* The data is always in the PNG order */
/* NOTE: this code is copied as a comment in
/* opaque */
/* transparent */
/* partially opaque */
/* Because the alpha entries only hold alpha==0.5 values
/* Likewise there are three entries for each of r, g
/* Here are how the values map:
/* red */
/* green */
/* blue */
/* As a flag */
/* Update the 'info' structure and make sure the result is as required; first
/* The expected output can be deduced from the colormap_processing option. */
/* Output must be one channel and one byte per pixel, the output
/* Output must be two channels and the 'G' one must be sRGB, the latter
/* Output must be 8-bit sRGB encoded RGB */
/* Output must be 8-bit sRGB encoded RGBA */
/* 216 + 1 + 27 */)
/* goto bad_output; */
/* FALL THROUGH */
/* Now read the rows.  Do this here if it is possible to read directly into
/* The following expression is designed to work correctly whether it gives
/* Just the row reading part of png_image_read. */
/* The row may be empty for a short image: */
/* Read the row, which is packed: */
/* Now do the composition on each pixel in this row. */
/* else no change to the output */
/* else just use component */
/* This is PNG_OPTIMIZED_ALPHA, the component value
/* =65535 */
/* So 'component' is scaled by 255*65535 and is
/* components and alpha channel */
/* The do_local_background case; called when all the following transforms are to
/* Double check the convoluted logic below.  We expect to get here with
/* Expect the 8-bit case to always remove the alpha channel */
/* Use direct access to info_ptr here because otherwise the simplified API
/* 8-bit sRGB gray values with an alpha channel; the alpha channel is
/* The row may be empty for a short image: */
/* Read the row, which is packed: */
/* Now do the composition on each pixel in this row. */
/* else no change to the output */
/* else just use component */
/* Since PNG_OPTIMIZED_ALPHA was not set it is
/* gray and alpha channel */
/* constant background value */
/* Read the row, which is packed: */
/* Now do the composition on each pixel in this row. */
/* else use background */
/* else just use component */
/* gray and alpha channel */
/* 16-bit linear with pre-multiplied alpha; the pre-multiplication must
/* The division by two is safe because the caller passed in a
/* The 'x' start and step are adjusted to output components here.
/* The row may be empty for a short image: */
/* Read the row, which is packed: */
/* Now do the pre-multiplication on each pixel in this row.
/* else 0 */
/* else just use component */
/* components and alpha channel */
/* The guts of png_image_finish_read as a png_safe_execute callback. */
/* to avoid double gamma correction bug */
/* Add transforms to ensure the correct output format is produced then check
/* Now check the format to see if it was modified. */
/* removed by png_set_expand */;
/* alpha mode */
/* Do this first so that we have a record if rgb to gray is happening. */
/* gray<->color transformation required. */
/* libpng can't do both rgb to gray and
/*maybe*/;
/* Set the gamma appropriately, linear for 16-bit input, sRGB otherwise.
/* Call png_set_alpha_mode to set the default for the input gamma; the
/* If there *is* an alpha channel in the input it must be multiplied
/* associated alpha */
/* If 'do_local_background' is set check for the presence of gamma
/* This is 'png_gamma_threshold' from pngrtran.c; the test used for
/*required*/;
/* prevent libpng doing it */
/* else leave as 1 for the checks below */
/* If the bit-depth changes then handle that here. */
/*16-bit output*/)
/* 8-bit output */
/* Now the background/alpha channel changes. */
/* Removing an alpha channel requires composition for the 8-bit
/* If RGB->gray is happening the alpha channel must be left and the
/*required*/;
/* 16-bit output: just remove the channel */
/* compose on black (well, pre-multiply) */
/* 8-bit output: do an appropriate compose */
/*unused*/
/* This is always an 8-bit sRGB value, using the 'green' channel
/*need_expand*/,
/*gamma: not used*/);
/* compose on row: implemented below. */
/* This leaves the alpha channel in the output, so it has to be
/* output needs an alpha channel */
/* This is tricky because it happens before the swap operation has
/* opaque filler */
/* This stops the (irrelevant) call to swap_alpha below. */
/* Now set the alpha mode correctly; this is always done, even if there is
/* Check only the output format; PNG is never BGR; don't do this if
/* Only relevant if there is an alpha channel - it's particularly
/* Disable this if doing a local background,
/* If the *output* is 16-bit then we need to check for a byte-swap on this
/* If change is not now 0 some transformation is missing - error out. */
/* Update the 'info' structure and make sure the result is as required; first
/* do_local_compose removes this channel below. */
/* do_local_background does the same if required. */
/* internal error */
/* This is actually an internal error. */
/* Now read the rows.  If do_local_compose is set then it is necessary to use
/* The following expression is designed to work correctly whether it gives
/* Choose the correct 'end' routine; for the color-map case all the
/* SIMPLIFIED_READ */
/* READ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libpng\pngrio.c
/* pngrio.c - functions for data input
/* Read the data from whatever input you are using.  The default routine
/* PRIVATE */
/* This is the function that does the actual reading of data.  If you are
/* fread() returns 0 on error, so it is OK to store this in a png_size_t
/* This function allows the application to supply a new input function
/* It is an error to write to a read device */
/* READ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libpng\pngrtran.c
/* pngrtran.c - transforms the data in a row for PNG readers
/* Set the action on getting a CRC error for an ancillary or critical chunk. */
/* Tell libpng how we react to CRC errors in critical chunks */
/* Leave setting as is */
/* Warn/use data */
/* Quiet/use data */
/* Not a valid action for critical data */
/* Error/quit */
/* Tell libpng how we react to CRC errors in ancillary chunks */
/* Leave setting as is */
/* Warn/use data */
/* Quiet/use data */
/* Error/quit */
/* Warn/discard data */
/* Is it OK to set a transformation now?  Only if png_start_read_image or
/* Turn on failure to initialize correctly for all transforms. */
/* Ok */
/* no png_error possible! */
/* Handle alpha and tRNS via a background color */
/* FLOATING_POINT */
/* READ_BACKGROUND */
/* Scale 16-bit depth files to 8-bit depth.  If both of these are set then the
/* Chop 16-bit depth files to 8-bit depth */
/* Check for flag values.  The main reason for having the old Mac value as a
/* If there is no sRGB support this just sets the gamma to the standard
/* The following silently ignores cases where fixed point (times 100,000)
/* This preserves -1 and -2 exactly: */
/* READ_ALPHA_MODE || READ_GAMMA */
/*screen*/);
/* Validate the value to ensure it is in a reasonable range. The value
/* The default file gamma is the inverse of the output gamma; the output
/* There are really 8 possibilities here, composed of any combination
/* default: png standard */
/* No compose, but it may be set by png_set_background! */
/* color channels premultiplied */
/* The output is linear: */
/* associated, non-opaque pixels linear */
/* output_gamma records the encoding of opaque pixels! */
/* associated, non-linear, alpha encoded */
/* Only set the default gamma if the file gamma has not been set (this has
/* But always set the output gamma: */
/* Finally, if pre-multiplying, set the background fields to achieve the
/* And obtain alpha pre-multiplication by composing on black: */
/* just in case */
/* Dither file to 8-bit.  Supply a palette, the current number
/* This is easy enough, just throw out the least used colors.
/* Initialize an array to sort colors */
/* Initialize the quantize_sort array */
/* Find the least used palette entries by starting a
/* To stop early if the list is pre-sorted */
/* Swap the palette around, and set up a table, if necessary */
/* Put all the useful colors within the max, but don't
/* Move all the used colors inside the max limit, and
/* Only move the colors we need to */
/* Indicate where the color went */
/* Find closest color for those colors we are not using */
/* Find the closest color to one we threw out */
/* Point to closest color */
/* This is much harder to do simply (and quickly).  Perhaps
/* Initialize palette index arrays */
/* Initialize the sort array */
/* Initial wild guess at how far apart the farthest pixel
/* int dr = abs(ir - r); */
/* int dg = abs(ig - g); */
/* int db = abs(ib - b); */
/* READ_QUANTIZE */
/* New in libpng-1.5.4 - reserve particular negative values as flags. */
/*screen*/);
/*file*/);
/* Checking the gamma values for being >0 was added in 1.5.4 along with the
/* Set the gamma values unconditionally - this overrides the value in the PNG
/* FLOATING_POINT */
/* READ_GAMMA */
/* Expand paletted images to RGB, expand grayscale images of
/* GRR 19990627:  the following three functions currently are identical
/* Expand paletted images to RGB. */
/* Expand grayscale images of less than 8-bit depth to 8 bits. */
/* Expand tRNS chunks to alpha channels. */
/* READ_EXPAND */
/* Expand to 16-bit channels, expand the tRNS chunk too (because otherwise
/* Because rgb must be 8 bits or more: */
/* Need the IHDR here because of the check on color_type below. */
/* TODO: fix this */
/* Make this an error in 1.6 because otherwise the application may assume
/* png_ptr->transformations &= ~PNG_RGB_TO_GRAY; */
/* NOTE: this calculation does not round, but this behavior is retained
/* Use the defaults, from the cHRM chunk if set, else the historical
/* png_ptr->rgb_to_gray_blue_coeff  = 2366; */
/* Convert a RGB image to a grayscale of the same width.  This allows us,
/* FLOATING POINT */
/* RGB_TO_GRAY */
/* In the case of gamma transformations only do transformations on images where
/* PRIVATE */
/* PNG_GAMMA_THRESHOLD is the threshold for performing gamma
/* Initialize everything needed for the read.  This includes modifying
/* For the moment 'png_init_palette_transformations' and
/* PRIVATE */
/* Called to handle the (input) palette case.  In png_do_read_transformations
/* Ignore if all the entries are opaque (unlikely!) */
/* If no alpha we can optimize. */
/* Any alpha means background and associative alpha processing is
/* png_set_background handling - deals with the complexity of whether the
/* The following code cannot be entered in the alpha pre-multiplication case
/* Invert the alpha channel (in tRNS) unless the pixels are
/* READ_INVERT_ALPHA */
/* background expand and (therefore) no alpha association. */
/* READ_EXPAND && READ_BACKGROUND */
/* PRIVATE */
/* Added to libpng-1.5.4: check the color type to determine whether there
/* If no alpha we can optimize. */
/* Any alpha means background and associative alpha processing is
/* png_set_background handling - deals with the complexity of whether the
/* The following code cannot be entered in the alpha pre-multiplication case
/* i.e., GRAY or GRAY_ALPHA */
/* Expand background and tRNS chunks */
/* FALL THROUGH (Already 8 bits) */
/* Already a full 16 bits */
/* background expand and (therefore) no alpha association. */
/* READ_EXPAND && READ_BACKGROUND */
/* PRIVATE */
/* This internal function is called from png_read_start_row in pngrutil.c
/* Prior to 1.5.4 these tests were performed from png_set_gamma, 1.5.4 adds
/* The following temporary indicates if overall gamma correction is
/* has been set */
/* screen set too */
/* Assume the output matches the input; a long time default behavior
/* The converse - assume the file matches the screen, note that this
/* neither are set */
/* Just in case the following prevents any processing - file and screen
/* We have a gamma value now. */
/* Now turn the gamma transformation on or off as appropriate.  Notice
/* Certain transformations have the effect of preventing other
/* Stripping the alpha channel happens immediately after the 'expand'
/* Kill the tRNS chunk itself too.  Prior to 1.5.4 this did not happen
/* STRIP_ALPHA supported, no COMPOSE */
/* If the screen gamma is about 1.0 then the OPTIMIZE_ALPHA and ENCODE_ALPHA
/* Make sure the coefficients for the rgb to gray conversion are set
/* Detect gray background and attempt to enable optimization for
/* PNG_BACKGROUND_EXPAND: the background is in the file color space, so if
/* PNG_COMPOSE: png_set_background was called with need_expand false,
/* READ_EXPAND && READ_BACKGROUND */
/* READ_GRAY_TO_RGB */
/* For indexed PNG data (PNG_COLOR_TYPE_PALETTE) many of the transformations
/* TODO: fix this.  Because the expand_16 operation is after the compose
/* READ_BACKGROUND && READ_EXPAND_16 */
/* On the other hand, if a 16-bit file is to be reduced to 8-bits per
/* NOTE: below 'PNG_READ_ALPHA_MODE_SUPPORTED' is presumed to also enable the
/* Includes ALPHA_MODE */
/* This needs to change - in the palette image case a whole set of tables are
/* Issue a warning about this combination: because RGB_TO_GRAY is
/* We don't get to here unless there is a tRNS chunk with non-opaque
/* back_1 */
/* back */
/* if (png_ptr->trans_alpha[i] != 0xff) */
/* Prevent the transformations being done again.
/* color_type == PNG_COLOR_TYPE_PALETTE */
/* if (png_ptr->background_gamma_type!=PNG_BACKGROUND_GAMMA_UNKNOWN) */
/* color_type != PNG_COLOR_TYPE_PALETTE */
/* Correction to linear */
/* Correction to screen */
/* gs = PNG_FP_1; */
/* RGB or RGBA with color background */
/* GRAY, GRAY ALPHA, RGB, or RGBA with gray background */
/* The background is now in screen gamma: */
/* color_type != PNG_COLOR_TYPE_PALETTE */
/* png_ptr->transformations & PNG_BACKGROUND */
/* Transformation does not include PNG_BACKGROUND */
/* READ_BACKGROUND */
/* RGB_TO_GRAY needs to have non-gamma-corrected values! */
/* NOTE: there are other transformations that should probably be in
/* Done the gamma correction. */
/* color_type == PALETTE && !PNG_BACKGROUND transformation */
/* READ_GAMMA */
/* No GAMMA transformation (see the hanging else 4 lines above) */
/* The png_composite() macro is defined in png.h */
/* READ_BACKGROUND */
/* significant bits can be in the range 1 to 7 for a meaninful result, if
/* READ_SHIFT */
/* Modify the info structure to reflect the transformations.  The
/* PRIVATE */
/* This check must match what actually happens in
/* The following is almost certainly wrong unless the background value is in
/* The following used to be conditional on PNG_GAMMA (prior to 1.5.4),
/* No 16 bit support: force chopping 16-bit input down to 8, in this case
/* For compatibility with previous versions use the strip method by
/* !READ_16BIT */
/* STRIP_ALPHA and FILLER allowed:  MASK_ALPHA bit stripped above */
/* If adding a true alpha channel not just filler */
/* Adding in 1.5.4: cache the above value in png_struct so that we can later
/* Unpack pixels of 1, 2, or 4 bits per pixel into 1 byte per pixel,
/* Reverse the effects of png_do_shift.  This routine merely shifts the
/* The palette case has already been handled in the _init routine. */
/* A shift of more than the bit depth is an error condition but it
/* Must be 1bpp gray: should not be here! */
/* NOTREACHED */
/* Must be 2bpp gray */
/* assert(channels == 1 && shift[0] == 1) */
/* Must be 4bpp gray */
/* assert(channels == 1) */
/* Single byte components, G, GA, RGB, RGBA */
/* Double byte components, G, GA, RGB, RGBA */
/* Scale rows of bit depth 16 down to 8 accurately */
/* source */
/* destination */
/* end+1 */
/* The input is an array of 16 bit components, these must be scaled to
/* must be signed! */
/* Simply discard the low byte.  This was the default behavior prior
/* source */
/* destination */
/* end+1 */
/* skip low byte */
/* This converts from RGBA to ARGB */
/* This converts from RRGGBBAA to AARRGGBB */
/* This converts from GA to AG */
/* This converts from GGAA to AAGG */
/* This inverts the alpha channel in RGBA */
/*          This does nothing:
/* This inverts the alpha channel in RRGGBBAA */
/*          This does nothing:
/* This inverts the alpha channel in GA */
/* This inverts the alpha channel in GGAA */
/*
/* Add filler channel if we have RGB color */
/* This changes the data from G to GX */
/* This changes the data from G to XG */
/* This changes the data from GG to GGXX */
/* This changes the data from GG to XXGG */
/* COLOR_TYPE == GRAY */
/* This changes the data from RGB to RGBX */
/* This changes the data from RGB to XRGB */
/* This changes the data from RRGGBB to RRGGBBXX */
/* This changes the data from RRGGBB to XXRRGGBB */
/* COLOR_TYPE == RGB */
/* Expand grayscale files to RGB, with or without alpha */
/* This changes G to RGB */
/* This changes GG to RRGGBB */
/* This changes GA to RGBA */
/* This changes GGAA to RRGGBBAA */
/* Reduce RGB files to grayscale, with or without alpha
//www.inforamp.net/~poynton/>  (THIS LINK IS DEAD June 2008 but
//web.archive.org/web/20000816232553/http://www.inforamp.net/
//www.poynton.com/notes/colour_and_gamma/>
/* Notice that gamma to/from 1 are not necessarily inverses (if
/* If there is no overall correction the table will not be
/* NOTE: this is the historical approach which simply
/* RGB bit_depth == 16 */
/* From 1.5.5 in the 16 bit case do the accurate conversion even
/* Replace any alpha or transparency with the supplied background color.
/* Background is already in screen gamma */
/* if (row_info->bit_depth == 16) */
/* Background is already in screen gamma */
/* Background is already in screen gamma */
/* if (png_ptr->bit_depth == 16) */
/* Background is already in screen gamma */
/* Background is already in screen gamma */
/* if (row_info->bit_depth == 16) */
/* Background is already in screen gamma */
/* READ_BACKGROUND || READ_ALPHA_MODE */
/* Gamma correct the image, avoiding the alpha channel.  Make sure
/* if (row_info->bit_depth == 16) */
/* if (row_info->bit_depth == 16) */
/* if (row_info->bit_depth == 16) */
/* Encode the alpha channel to the output gamma (the input channel is always
/* The alpha channel is the last component: */
/* The alpha channel is the last component: */
/* Only get to here if called with a weird row_info; no harm has been done,
/* Expands a palette row to an RGB or RGBA row depending
/* If the bit depth < 8, it is expanded to 8.  Also, if the already
/* If the bit depth is 8 and the color type is not a palette type expand the
/* The row have a sequence of bytes containing [0..255] and we need
/* source, last byte + 1 */
/* destination, end + 1 */
/* This looks real messy, but the compiler will reduce
/* READ_QUANTIZE */
/* Transform the row.  The order of transformations is significant,
/* PRIVATE */
/* Prior to 1.5.4 this output row/pass where the NULL pointer is, but this
/* The following is debugging; prior to 1.5.4 the code was never compiled in;
/* Application has failed to call either png_read_start_image() or
/* at_start == false, because SWAP_ALPHA happens later */);
/* From Andreas Dilger e-mail to png-implement, 26 March 1998:
/* If gray -> RGB, do so now only if background is non-gray; else do later
/* Because RGB_TO_GRAY does the gamma transform. */
/* Because PNG_COMPOSE does the gamma transform if there is something to
/* Because png_init_read_transformations transforms the palette, unless
/* at_start == false, because SWAP_ALPHA happens later */);
/* There is no harm in doing both of these because only one has any effect,
/* READ_QUANTIZE */
/* Do the expansion now, after all the arithmetic has been done.  Notice
/* NOTE: moved here in 1.5.4 (from much later in this list.) */
/* Added at libpng-1.5.10 */
/* User read transform function */
/* png_ptr */
/* row_info: */
/*  png_uint_32 width;       width of row */
/*  png_size_t rowbytes;     number of bytes in row */
/*  png_byte color_type;     color type of pixels */
/*  png_byte bit_depth;      bit depth of samples */
/*  png_byte channels;       number of channels (1-4) */
/*  png_byte pixel_depth;    bits per pixel (depth*channels) */
/* start of pixel data for row */
/* READ_TRANSFORMS */
/* READ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libpng\pngrutil.c
/* pngrutil.c - utilities to read a PNG file
/* The following is a variation on the above for use with the fixed
/* PRIVATE */
/* known to be in range */
/* The caller can turn off the warning by passing NULL. */
/* NOTE: the read macros will obscure these definitions, so that if
/* Grab an unsigned 32-bit integer from a buffer in big-endian format. */
/* Grab a signed 32-bit integer from a buffer in big-endian format.  The
/* non-negative */
/* 2's complement: -x = ~x+1 */
/* Grab an unsigned 16-bit integer from a buffer in big-endian format. */
/* ANSI-C requires an int value to accomodate at least 16 bits so this
/* READ_INT_FUNCTIONS */
/* Read and check the PNG file signature */
/* PRIVATE */
/* Exit if the user application does not expect a signature. */
/* The signature must be serialized in a single I/O call. */
/* Read the chunk header (length + type name).
/* PRIVATE */
/* Read the length and the chunk name.
/* Put the chunk name into png_ptr->chunk_name. */
/* Reset the crc and run it over the chunk name. */
/* Check to see if chunk name is valid. */
/* Read data, and (optionally) run it through the CRC. */
/* PRIVATE */
/* Optionally skip data and then check the CRC.  Depending on whether we
/* PRIVATE */
/* The size of the local buffer for inflate is a good guess as to a
/* Compare the CRC stored in the PNG file with that calculated by libpng from
/* PRIVATE */
/* critical */
/* The chunk CRC must be serialized in a single I/O call. */
/* Manage the read buffer; this simply reallocates the buffer if it is not small
/* else silent */
/* READ_iCCP|iTXt|pCAL|sCAL|sPLT|tEXt|zTXt|SEQUENTIAL_READ */
/* png_inflate_claim: claim the zstream for some nefarious purpose that involves
/* So the message that results is "<chunk> using zstream"; this is an
/* Implementation note: unlike 'png_deflate_claim' this internal function
/* zlib return code */
/* Set this for safety, just in case the previous owner left pointers to
/* png_inflate now returns zlib error codes including Z_OK and Z_STREAM_END to
/* INPUT: */ png_const_bytep input, png_uint_32p input_size_ptr,
/* OUTPUT: */ png_bytep output, png_alloc_size_t *output_size_ptr)
/* Else not claimed */
/* zlib can't necessarily handle more than 65535 bytes at once (i.e. it
/* avail_in and avail_out are set below from 'size' */
/* Read directly into the output if it is available (this is set to
/* zlib INPUT BUFFER */
/* The setting of 'avail_in' used to be outside the loop; by setting it
/* not consumed last time */
/* safe: < than ZLIB_IO_MAX */
/* zlib OUTPUT BUFFER */
/* not written last time */
/* maximum zlib can process */
/* Reset the output buffer each time round if output is NULL and
/* safe: < ZLIB_IO_MAX */
/* zlib inflate call */
/* In fact 'avail_out' may be 0 at this point, that happens at the end
/* For safety kill the local buffer pointer now */
/* Claw back the 'size' and 'remaining_space' byte counts. */
/* Update the input and output sizes; the updated values are the amount
/* Ensure png_ptr->zstream.msg is set (even in the success case!) */
/* This is a bad internal error.  The recovery assigns to the zstream msg
/*
/* must be initialized to the maximum! */,
/*add a '\0' to the end of the uncompressed data*/)
/* TODO: implement different limits for different types of chunk.
/* Now try to claim the stream. */
/*finish*/,
/* input: */ png_ptr->read_buffer + prefix_size, &lzsize,
/* output: */ NULL, newlength);
/* Use 'inflateReset' here, not 'inflateReset2' because this
/* Because of the limit checks above we know that the new,
/*finish*/,
/* freed below */
/* The size changed on the second read, there can be no
/* for safety */
/* Free the text pointer (this is the old read_buffer on
/* This really is very benign, but it's still an error because
/* Out of memory allocating the buffer */
/* inflateReset failed, store the error message */
/* Release the claimed stream */
/* the claim failed */ if (ret == Z_STREAM_END) /* impossible! */
/* Application/configuration limits exceeded */
/* READ_COMPRESSED_TEXT */
/* Perform a partial read and decompress, producing 'avail_out' bytes and
/* next_in and avail_in must have been initialized by the caller. */
/* set in the loop */
/* Use Z_SYNC_FLUSH when there is no more chunk data to ensure that all
/* Should not be required, but is safe */
/* Ensure the error message pointer is always set: */
/* Read and check the IDHR chunk */
/* PRIVATE */
/* Check the length */
/* Set internal variables */
/* Find number of channels */
/* invalid, png_set_IHDR calls png_error */
/* Set up other useful info */
/* Read and check the palette */
/* PRIVATE */
/* Moved to before the 'after IDAT' check below because otherwise duplicate
/* This is benign because the non-benign error happened before, when an
/* The cast is safe because 'length' is less than 3*PNG_MAX_PALETTE_LENGTH */
/* Don't depend upon png_color being any order */
/* If we actually need the PLTE chunk (ie for a paletted image), we do
/* Only if we have a CRC error */
/* If we don't want to use the data from an ancillary chunk,
/* Otherwise, we (optionally) emit a warning and use the chunk. */
/* TODO: png_set_PLTE has the side effect of setting png_ptr->palette to its
/* The three chunks, bKGD, hIST and tRNS *must* appear after PLTE and before
/* Cancel this because otherwise it would be used if the transforms
/* PRIVATE */
/* PRIVATE */
/* PRIVATE */
/* PRIVATE */
/* If a colorspace error has already been output skip this chunk */
/*prefer cHRM values*/);
/* PRIVATE */
/* If a colorspace error has already been output skip this chunk */
/* Only one sRGB or iCCP chunk is allowed, use the HAVE_INTENT flag to detect
/* READ_sRGB */
/* PRIVATE */
/* Note: this does not properly handle profiles that are > 64K under DOS */
/* error message output, or no error */
/* crc checked */
/* Consistent with all the above colorspace handling an obviously *invalid*
/* If a colorspace error has already been output skip this chunk */
/* Only one sRGB or iCCP chunk is allowed, use the HAVE_INTENT flag to detect
/* Find the keyword; the keyword plus separator and compression method
/* maximum */
/* TODO: make the keyword checking common */
/* We only understand '0' compression - deflate - so if we get a
/*finish: don't, because the output is too small*/);
/* We have the ICC profile header; do the basic header checks.
/* The length is apparently ok, so we can check the 132
/* Now read the tag table; a variable size buffer is
/*silent*/);
/* Still expect a buffer error because we expect
/* The profile has been validated for basic
/*finish*/);
/* But otherwise allow extra data: */
/* This can be handled completely, so
/* Check for a match against sRGB */
/* Steal the profile for info_ptr. */
/*steal*/
/* else the profile remains in the read
/* else png_icc_check_tag_table output an error */
/* profile truncated */
/* else png_icc_check_header output an error */
/* else png_icc_check_length output an error */
/* profile truncated */
/* Release the stream */
/* png_inflate_claim failed */
/* or missing */
/* Failure: the reason is in 'errmsg' */
/* else already output */
/* READ_iCCP */
/* PRIVATE */
/* Note: this does not properly handle chunks that are > 64K under DOS */
/*silent*/);
/* WARNING: this may break if size_t is less than 32 bits; it is assumed
/* Empty loop to find end of name */ ;
/* A sample depth should follow the separator, and we should be on it  */
/* This must fit in a png_uint_32 because it is derived from the original
/* Integrity-check the data length */
/* Discard all chunk data except the name and stash that */
/* READ_sPLT */
/* PRIVATE */
/* TODO: is this actually an error in the ISO spec? */
/* TODO: this is a horrible side effect in the palette case because the
/* PRIVATE */
/* We convert the index value into RGB components so that we can allow
/* GRAY */
/* PRIVATE */
/* PRIVATE */
/* PRIVATE */
/* Read the pCAL chunk (described in the PNG Extensions document) */
/* PRIVATE */
/*silent*/);
/* Null terminate the last string */
/* Empty loop */ ;
/* We need to have at least 12 bytes after the purpose string
/* Check that we have the right number of parameters for known
/* Empty loop to move past the units string. */ ;
/* Get pointers to the start of each parameter string. */
/* Skip the null string terminator from previous parameter. */
/* Empty loop to move past each parameter string */ ;
/* Make sure we haven't run out of data yet */
/* Read the sCAL chunk */
/* PRIVATE */
/* Need unit type, width, \0, height: minimum 4 bytes */
/*silent*/);
/* Null terminate the last string */
/* Validate the unit. */
/* Validate the ASCII numbers, need two ASCII numbers separated by
/* This is the (only) success case. */
/* PRIVATE */
/* Note: this does not properly handle chunks that are > 64K under DOS */
/* PRIVATE */
/*warn*/);
/* Empty loop to find end of key */ ;
/* Note: this does not correctly handle chunks that are > 64K under DOS */
/* PRIVATE */
/*silent*/);
/* TODO: also check that the keyword contents match the spec! */
/* Empty loop to find end of name */ ;
/* zTXt must have some LZ data after the keyword, although it may expand to
/* TODO: at present png_decompress_chunk imposes a single application
/*terminate*/) == Z_STREAM_END)
/* It worked; png_ptr->read_buffer now looks like a tEXt chunk except
/* Note: this does not correctly handle chunks that are > 64K under DOS */
/* PRIVATE */
/*warn*/);
/* First the keyword. */
/* Empty loop */ ;
/* Perform a basic check on the keyword length here. */
/* Expect keyword, compression flag, compression type, language, translated
/* Now the language tag */
/* Empty loop */ ;
/* WARNING: the length may be invalid here, this is checked below. */
/* Empty loop */ ;
/* prefix_length should now be at the trailing '\0' of the translated
/* TODO: at present png_decompress_chunk imposes a single application
/*terminate*/) == Z_STREAM_END)
/* Utility function for png_handle_unknown; set up png_ptr::unknown_chunk */
/* The following is safe because of the PNG_SIZE_MAX init above */
/*SAFE*/;
/* 'mode' is a flag array, only the bottom four bits matter here */
/*SAFE*/;
/* Do a 'warn' here - it is handled below. */
/* This is benign because we clean up correctly */
/* READ_UNKNOWN_CHUNKS */
/* Handle an unknown, or known but disabled, chunk */
/* PRIVATE */
/* the chunk was handled */
/* NOTE: this code is based on the code in libpng-1.4.12 except for fixing
/* One of the following methods will read the chunk or skip it (at least one
/* The user callback takes precedence over the chunk keep value, but the
/* Callback to user unknown chunk handler */
/* ret is:
/* If the keep value is 'default' or 'never' override it, but
/* with keep = PNG_HANDLE_CHUNK_IF_SAFE */
/* chunk was handled */
/* Critical chunks can be safely discarded at this point. */
/* insufficient memory */
/* Use the SAVE_UNKNOWN_CHUNKS code or skip the chunk */
/* READ_USER_CHUNKS */
/* keep is currently just the per-chunk setting, if there was no
/* If here there is no read callback pointer set and no support is
/* Now store the chunk in the chunk list if appropriate, and if the limits
/* FALL THROUGH */
/* NOTE: prior to 1.6.0 this case resulted in an unknown critical
/* not at limit */
/* FALL THROUGH */
/* no limit */
/* USER_LIMITS */
/* Here when the limit isn't reached or when limits are compiled
/* no store support: the chunk must be handled by the user callback */
/* Regardless of the error handling below the cached data (if any) can be
/* !PNG_READ_UNKNOWN_CHUNKS_SUPPORTED */
/* There is no support to read an unknown chunk, so just skip it. */
/* !READ_UNKNOWN_CHUNKS */
/* Check for unhandled critical chunks */
/* This function is called to verify that a chunk name is valid.
/* Bit hacking: the test for an invalid byte in the 4 byte chunk name is:
/* PRIVATE */
/* Combines the row recently read in with the existing pixels in the row.  This
/* PRIVATE */
/* Added in 1.5.6: it should not be possible to enter this routine until at
/* Added in 1.5.4: the pixel depth should match the information returned by
/* Don't expect this to ever happen: */
/* Preserve the last byte in cases where only part of it will be overwritten,
/* end_ptr == NULL is a flag to say do nothing */
/* little-endian byte */
/* big-endian byte */
/* end_mask is now the bits to *keep* from the destination row */
/* For non-interlaced images this reduces to a memcpy(). A memcpy()
/* The following copies everything for 'display' on passes 0, 2 and 4. */
/* Narrow images may have no bits in a pass; the caller should handle
/* For pixel depths up to 4 bpp the 8-pixel mask can be expanded to fit
/* Return a mask for pass 'p' pixel 'x' at depth 'd'.  The mask is
/* Hence generate the appropriate 'block' or 'sparkle' pixel copy mask.
/* Combine 8 of these to get the full mask.  For the 1-bpp and 2-bpp
/* Utility macros to construct all the masks for a depth/swap
/* Hence the pre-compiled masks indexed by PACKSWAP (or not), depth and
/*PACKSWAP*/][3/*depth*/][6] =
/* Little-endian byte masks for PACKSWAP */
/* Normal (big-endian byte) masks - PNG format */
/* display_mask has only three entries for the odd passes, so index by
/* Little-endian byte masks for PACKSWAP */
/* Normal (big-endian byte) masks - PNG format */
/* !PNG_USE_COMPILE_TIME_MASKS */
/* This is the runtime alternative: it seems unlikely that this will
/* !USE_COMPILE_TIME_MASKS */
/* Use the appropriate mask to copy the required bits.  In some cases
/* It doesn't matter in the following if png_uint_32 has more than
/* rotate right to good compilers */
/* something to copy */
/* NOTE: this may overwrite the last byte with garbage if the image
/* May need to restore part of the last byte */
/* pixel_depth >= 8 */
/* Validate the depth - it must be a multiple of 8 */
/* now in bytes */
/* Regardless of pass number the Adam 7 interlace always results in a
/* Work out the bytes to copy. */
/* When doing the 'block' algorithm the pixel in the pass gets
/* But don't allow this number to exceed the actual row width. */
/* normal row; Adam7 only ever gives us one pixel to copy. */
/* In Adam7 there is a constant offset between where the pixels go. */
/* And simply copy these bytes.  Some optimization is possible here,
/* There is a possibility of a partial copy at the end here; this
/* And there can only be one byte left at this point: */
/* This can only be the RGB case, so each copy is exactly one
/* Check for double byte alignment and, if possible, use a
/*else use memcpy*/ &&
/* Everything is aligned for png_uint_16 copies, but try for
/* Get to here when the row_width truncates the final copy.
/* Else do it in 16-bit quantities, but only if the size is
/* End of row - 1 byte left, bytes_to_copy > row_width: */
/* ALIGN_TYPE code */
/* The true default - use a memcpy: */
/* NOT REACHED*/
/* pixel_depth >= 8 */
/* Here if pixel_depth < 8 to check 'end_ptr' below. */
/* READ_INTERLACING */
/* If here then the switch above wasn't used so just memcpy the whole row
/* Restore the overwritten bits from the last byte if necessary. */
/* PRIVATE */
/* Because these may affect the byte layout */)
/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
/* Offset to next interlace block */
/* SAFE; pixel_depth does not exceed 64 */
/* Silence compiler warning */
/* READ_INTERLACING */
/* First pixel/byte */
/* Remainder */
/* From previous iteration or start */
/* Find the best predictor, the least of pa, pb, pc favoring the earlier
/* Calculate the current pixel in a, and move the previous row pixel to c
/* Process the first pixel in the row completely (this is the same as 'up'
/* Remainder */
/* This function is called once for every PNG image (except for PNG images
/* To use this define PNG_FILTER_OPTIMIZATIONS as the name of a function to
/* PRIVATE */
/* OPTIMIZATION: DO NOT MODIFY THIS FUNCTION, instead #define
/* PRIVATE */
/* Loop reading IDATs and decompressing the result into output[avail_out] */
/* safety: set below */
/* This is an error even in the 'check' case because the code just
/* A PNG with a gradually increasing IDAT size will defeat this attempt
/*error*/);
/* And set up the output side. */
/* standard read */
/* after last row, checking for end */
/* Use NO_FLUSH; this gives zlib the maximum opportunity to optimize the
/* Take the unconsumed output back. */
/* avail_out counts the extra bytes */
/* Do this for safety; we won't read any more into this row. */
/* checking */
/* The stream ended before the image; this is the same as too few IDATs so
/* the deflate stream contained extra data */
/* PRIVATE */
/* We don't need any more data and the stream should have ended, however the
/* The NULL causes png_read_IDAT_data to swallow any remaining bytes in
/* safety */
/* Now clear everything out for safety; the following may not have been
/* If the zstream has not been released do it now *and* terminate the reading
/* Always do this; the pointers otherwise point into the read buffer. */
/* Now we no longer own the zstream. */
/* The slightly weird semantics of the sequential IDAT reading is that we
/* PRIVATE */
/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
/* Start of interlace block */
/* Offset to next interlace block */
/* Start of interlace block in the y direction */
/* Offset to next interlace block in the y direction */
/* TO DO: don't do this if prev_row isn't needed (requires
/* if (png_ptr->transformations & PNG_INTERLACE) */
/* libpng deinterlacing sees every row */
/* Here after at the end of the last row of the last pass. */
/* SEQUENTIAL_READ */
/* PRIVATE */
/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
/* Start of interlace block */
/* Offset to next interlace block */
/* Start of interlace block in the y direction */
/* Offset to next interlace block in the y direction */
/* WARNING: * png_read_transform_info (pngrtran.c) performs a simpliar set of
/* In fact it is an error if it isn't supported, but checking is
/* This value is stored in png_struct and double checked in the row read
/* calculated on demand */
/* Align the width on the next larger 8 pixels.  Mainly used
/* Calculate the maximum bytes needed, adding a byte and a pixel
/* Use 16-byte aligned memory for row_buf with at least 16 bytes
/*filter byte*/;
/*filter byte*/;
/* Use 31 bytes of padding before and 17 bytes after row_buf. */
/* The sequential reader needs a buffer for IDAT, but the progressive reader
/* Finally claim the zstream for the inflate of the IDAT data, use the bits
/* READ */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libpng\pngset.c
/* pngset.c - storage of image information into info struct
/* override with app values*/) != 0)
/* FLOATING_POINT */
/* cHRM */
/* Changed from info->num_palette to PNG_MAX_PALETTE_LENGTH in
/* TODO: validate format of calibration name and unit name */
/* Check that the type matches the specification. */
/* Validate params[nparams] */
/* Double check the unit (should never get here with an invalid
/* '-' */ || !png_check_fp_string(swidth, lengthw))
/* '-' */ || !png_check_fp_string(sheight, lengthh))
/* Check the arguments. */
/* Convert 'width' and 'height' to ASCII. */
/* Check the arguments. */
/* Convert 'width' and 'height' to ASCII. */
/* It may not actually be necessary to set png_ptr->palette here;
/* Changed in libpng-1.2.1 to allocate PNG_MAX_PALETTE_LENGTH instead
/* This causes the gAMA and cHRM to be written too */
/* sRGB */
/* Set the colorspace first because this validates the profile; do not
/* Don't do any of the copying if the profile was bad, or inconsistent. */
/* But do write the gAMA and cHRM chunks from the profile. */
/* PRIVATE */
/* Make sure we have enough space in the "text" array in info_struct
/* Calculate an appropriate max_text, checking for overflow. */
/* Round up to a multiple of 8 */
/* Now allocate a new array and copy the old members in; this does all
/* num_text is adjusted below as the entries are copied in */
/* Set iTXt data */
/* PNG_iTXt_SUPPORTED */
/* It may not actually be necessary to set png_ptr->trans_alpha here;
/* Changed from num_trans to PNG_MAX_PALETTE_LENGTH in version 1.2.1 */
/*
/* Use the internal realloc function, which checks for all the possible
/* Out of memory or too many chunks */
/* Skip invalid input entries */
/* png_handle_sPLT doesn't do this, so this is an app error */
/* Just skip the invalid entry */
/* In the event of out-of-memory just return - there's no point keeping
/* IMPORTANT: we have memory now that won't get freed if something else
/* This multiply can't overflow because png_malloc_array has already
/* Note that 'continue' skips the advance of the out pointer and out
/* sPLT */
/* New in 1.6.0; copy the location and check it.  This is an API
/* Write struct, so unknown chunks come from the app */
/* Use the old behavior */
/* This need not be an internal error - if the app calls
/* Now reduce the location to the top-most set bit by removing each least
/* The cast is safe because 'location' is a bit mask and only the low four
/* Check for the failure cases where support has been disabled at compile
/* Prior to 1.6.0 this code used png_malloc_warn; however, this meant that
/* safe because it is initialized */
/* Increment unknown_chunks_num each time round the loop to protect the
/* But just skip storing the unknown chunk */
/* These increments are skipped on out-of-memory for the data - the
/* This API is pretty pointless in 1.6.0 because the location can be set
/* Fake out the pre 1.6.0 behavior: */
/* undocumented! */
/* also undocumented */
/* Utility function: update the 'keep' state of a chunk if it is already in
/* '0' means just set the flags, so stop here */
/* Ignore all unknown chunks and all chunks recognized by
/* bKGD */
/* cHRM */
/* gAMA */
/* hIST */
/* iCCP */
/* iTXt */
/* oFFs */
/* pCAL */
/* pHYs */
/* sBIT */
/* sCAL */
/* sPLT */
/* sTER */
/* sRGB */
/* tEXt */
/* tIME */
/* zTXt */
/*SAFE*/(sizeof chunks_to_ignore)/5U;
/* num_chunks_in > 0 */
/* Prior to 1.6.0 this was silently ignored, now it is an app_error
/* Since num_chunks is always restricted to UINT_MAX/5 this can't overflow.
/* If these chunks are being reset to the default then no more memory is
/* Add the new chunks together with each one's handling code.  If the chunk
/* Now remove any spurious 'default' entries. */
/* This means the application has removed all the specialized handling. */
/* checked above */
/* must fit */
/* Deflate will potentially go into an infinite loop on a SYNC_FLUSH
/* This function was added to libpng 1.2.6 */
/* Images with dimensions larger than these limits will be
/* This function was added to libpng 1.4.0 */
/* This function was added to libpng 1.4.1 */
/* ?SET_USER_LIMITS */
/* If allowed is 1, png_benign_error() is treated as a warning.
/* BENIGN_ERRORS */
/* Whether to report invalid palette index; added at libng-1.5.10.
/* READ || WRITE */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libpng\pngtest.c
/* pngtest.c - a simple test program to test libpng
/* Defined so I can write to a file on gui/windowing platforms */
/*  #define STDERR stderr  */
/* For DOS */
/* Known chunks that exist in pngtest.png must be supported or pngtest will fail
/* else nothing can be done */\
/* defined by pnglibconf.h from 1.7 */
/* Copied from pngpriv.h but only used in error messages below. */
/* Makes pngtest verbose so we can find problems. */
/* Makes buffer overruns easier to nail */
/* Turn on CPU timing
/* chunk unsupported by libpng in input */
/* count calls to png_error */
/* count calls to png_warning */
/* Define png_jmpbuf() in case we are using a pre-1.0.6 version of libpng */
/* Defines for unknown chunk handling if required. */
/* Utility to save typing/errors, the argument must be a name */
/* Example of using row callbacks to make a simple progress meter */
/* Example of using user transform callback (we don't transform anything,
/* Example of using user transform callback (we don't transform anything,
/* Contents of row_info:
/* Counts the number of zero samples (or zero pixels if color_type is 3 */
/* Other color types */
/* WRITE_USER_TRANSFORM */
/* START of code to validate stdio-free compilation */
/* These copies of the default read/write functions come from pngrio.c and
/* Check if the current operation (reading / writing) is as expected. */
/* Check if the buffer size specific to the current location
/* no restrictions here */
/* uninitialized */
/* fread() returns 0 on error, so it is OK to store this in a png_size_t
/* Do nothing; fflush() is said to be just a waste of energy. */
/* Stifle compiler warning */
/* This is the function that does the actual writing of data.  If you are
/* !STDIO */
/* This function is called when there is a warning, but the library thinks
/* This is the default error handling function.  Note that replacements for
/* We can return because png_error calls the default handler, which is
/* END of code to validate stdio-free compilation */
/* START of code to validate memory allocation and deallocation */
/* Allocate memory.  For reasonable files, size should never exceed
/* png_malloc has already tested for NULL; png_create_struct calls
/* This calls the library allocator twice, once to get the requested
/* Disable malloc_fn and free_fn */
/* Restore malloc_fn and free_fn */
/* Make sure the caller isn't assuming zeroed memory. */
/* Free a pointer.  It is removed from the list at the same time. */
/* This happens all the time. */
/* Unlink the element from the list. */
/* We must free the list element too, but first kill
/* Finally free the data. */
/* USER_MEM && DEBUG */
/* END of code to test memory allocation/deallocation */
/* Demonstration of user chunk support of the sTER and vpAg chunks */
/* (sTER is a public chunk not yet known by libpng.  vpAg is a private
/* Used for location and order; zero means nothing. */
/* already have one of these */
/* Find where we are (the code below zeroes info_ptr to indicate that the
/* after IDAT */
/* handled */
/* Return one of the following:
/* s  T */
/* E  R */
/* Found sTER chunk */
/* Error return */
/* Invalid mode */
/* duplicate sTER - give it to libpng */
/* v  p */
/* A  g */
/* Did not recognize */
/* Found ImageMagick vpAg chunk */
/* Error return */
/* duplicate vpAg */
/* Notice that this preserves the original chunk order, however chunks
/* WRITE */
/* !READ_USER_CHUNKS */
/* END of code to demonstrate user chunk support */
/* START of code to check that libpng has the required text support; this only
/* This is an error */
/* END of code to check that libpng has the required text support */
/* Test one file */
/* "static" prevents setjmp corruption */
/* Treat png_benign_error() as errors on read */
/* Treat them as errors on write */
/* if strict is not set, then app warnings and errors are treated as
/* Allow application (pngtest) errors and warnings to pass */
/* Preserve all the unknown chunks, if possible.  If this is disabled then,
/* This is a bit of a hack; there is no obvious way in the callback function
/* num_pass will not be set below, set it here if the image is
/*NOT REACHED*/
/* Use floating point versions */
/* Floating point */
/* Fixed point */
/* TIME_RFC1123 */
/* libpng doesn't reject a tRNS chunk with out-of-range samples */
/* Copy the locations from the read_info_ptr.  The automatically
/* Write the info in two steps so that if we write the 'unknown' chunks here
/* before PLTE */
/* after PLTE */
/* SINGLE_ROWBUF_ALLOC */
/* !SINGLE_ROWBUF_ALLOC */
/* WRITE */
/* !SINGLE_ROWBUF_ALLOC */
/* TIME_RFC1123 */
/* Copy the locations from the read_info_ptr.  The automatically
/* Normally one would use Z_DEFAULT_STRATEGY for text compression.
/* When the unknown vpAg/sTER chunks are written by pngtest the only way to
/* SINGLE_ROWBUF_ALLOC */
/* Summarize any warnings or errors and in 'strict' mode fail the test.
/* We don't really expect to get here because of the setjmp handling
/* If there we no write support nothing was written! */
/* else nothing was written */
/* else the files will be changed */
/* NOTE: the unsupported_chunks escape is permitted here because
/* WRITE */
/* Input and output filenames */
/* Show the version of libpng used in building the library */
/* Show the version of libpng used in building the application */
/* Do some consistency checking on the memory allocation settings, I'm
/* I think the following can happen. */
/* TIME_RFC1123 */
/* TIME_RFC1123 */
/* And skip this test */
/* Generate a compiler error if there is an old png.h in the search path. */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libpng\pngtrans.c
/* pngtrans.c - transforms the data in a row (used by both readers and writers)
/* Turn on BGR-to-RGB mapping */
/* Turn on 16 bit byte swapping */
/* Turn on pixel packing */
/* Turn on packed pixel swapping */
/* Add a filler byte on read, or remove a filler or alpha byte on write.
/* In libpng 1.6 it is possible to determine whether this is a read or write
/* On read png_set_filler is always valid, regardless of the base PNG
/* not used in the write case */
/* write */
/* On write the usr_channels parameter must be set correctly at the
/* There simply isn't any code in libpng to strip out bits
/* Here on success - libpng supports the operation, set the transformation
/* Added to libpng-1.2.7 */
/* The above may fail to do anything. */
/* Invert monochrome grayscale data */
/* PRIVATE */
/* This test removed from libpng version 1.0.13 and 1.2.0:
/* Swaps byte order on 16 bit depth images */
/* PRIVATE */
/* Feature added to libpng-1.6.11 for testing purposes, not
/* Swaps pixel packing order within bytes */
/* PRIVATE */
/* PACKSWAP || WRITE_PACKSWAP */
/* Remove a channel - this used to be 'png_do_strip_filler' but it used a
/* PRIVATE */
/* source pointer */
/* destination pointer */
/* One beyond end of row */
/* At the start sp will point to the first byte to copy and dp to where
/* GA, GX, XG cases */
/* Skip initial filler */
/* Skip initial channel and, for sp, the filler */
/* For a 1 pixel wide image there is nothing to do */
/* Skip initial filler */
/* Skip initial channel and, for sp, the filler */
/* bad bit depth */
/* Finally fix the color type if it records an alpha channel */
/* RGBA, RGBX, XRGB cases */
/* Skip initial filler */
/* Skip initial channels and, for sp, the filler */
/* Note that the loop adds 3 to dp and 4 to sp each time. */
/* Skip initial filler */
/* Skip initial channels and, for sp, the filler */
/* Copy 6 bytes, skip 2 */
/* bad bit depth */
/* Finally fix the color type if it records an alpha channel */
/* The filler channel has gone already */
/* Fix the rowbytes value. */
/* Swaps red and blue bytes within a pixel */
/* PRIVATE */
/* READ_BGR || WRITE_BGR */
/* Added at libpng-1.5.10 */
/* PRIVATE */
/* num_palette can be 0 in MNG files */
/* Calculations moved outside switch in an attempt to stop different
/* in this case, all bytes must be 0 so we don't need
/* CHECK_FOR_INVALID_INDEX */
/* This function returns a pointer to the user_transform_ptr associated with
/* See the comments in png.h - this is the sub-image row when reading an
/* help the app not to fail silently */
/* invalid */
/* USER_TRANSFORM_INFO */
/* READ_USER_TRANSFORM || WRITE_USER_TRANSFORM */
/* READ || WRITE */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libpng\pngwio.c
/* pngwio.c - functions for data output
/* Write the data to whatever output you are using.  The default routine
/* PRIVATE */
/* NOTE: write_data_fn must not change the buffer! */
/* This is the function that does the actual writing of data.  If you are
/* This function is called to output any data pending writing (normally
/* PRIVATE */
/* This function allows the application to supply new output functions for
/* WRITE_FLUSH */
/* It is an error to read while writing a png file */
/* WRITE */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libpng\pngwrite.c
/* pngwrite.c - general routines to write a PNG file
/* Write out all the unknown chunks for the current given location */
/* If per-chunk unknown chunk handling is enabled use it, otherwise
/* NOTE: this code is radically different from the read side in the
/* safe-to-copy overrides everything */ ||
/* TODO: review, what is wrong with a zero length unknown chunk? */
/* WRITE_UNKNOWN_CHUNKS */
/* Writes all the PNG information.  This is the suggested way to use the
/* Write PNG signature */
/* Write IHDR information. */
/* The rest of these check to see if the valid field has the appropriate
/* Write only one of sRGB or an ICC profile.  If a profile was supplied
/* WRITE_sRGB */
/* COLORSPACE */
/* Invert the alpha channel (in tRNS) */
/* sCAL */
/* pHYs */
/* tIME */
/* sPLT */
/* Check to see if we need to write text chunks */
/* An internationalized chunk? */
/* Write international chunk */
/* Mark this chunk as written */
/* If we want a compressed text chunk */
/* Write compressed chunk */
/* Mark this chunk as written */
/* Write uncompressed chunk */
/* Mark this chunk as written */
/* Can't get here */
/* tEXt */
/* Writes the end of the PNG file.  If you don't want to write comments or
/* See if user wants us to write information chunks */
/* local index variable */
/* Check to see if user has supplied a time chunk */
/* Loop through comment chunks */
/* An internationalized chunk? */
/* Write international chunk */
/* Mark this chunk as written */
/* Write compressed chunk */
/* Mark this chunk as written */
/* Write uncompressed chunk */
/* Mark this chunk as written */
/* Write end of PNG file */
/* This flush, added in libpng-1.0.8, removed from libpng-1.0.9beta03,
/* Initialize png_ptr structure, and allocate any memory needed */
/* Alternate initialize png_ptr structure, and allocate any memory needed */
/* USER_MEM */
/* Set the zlib control values to defaults; they can be overridden by the
/* The 'zlib_strategy' setting is irrelevant because png_default_claim in
/* WRITE_COMPRESSED_TEXT */
/* This is a highly dubious configuration option; by default it is off,
/* In stable builds only warn if an application error can be completely
/* App warnings are warnings in release (or release candidate) builds but
/* TODO: delay this, it can be done in png_init_io() (if the app doesn't
/* Write a few rows of image data.  If the image is interlaced,
/* row counter */
/* row pointer */
/* Loop through the rows */
/* Write the image.  You only need to call this function once, even
/* row index */
/* pass variables */
/* points to current row */
/* Initialize interlace handling.  If image is not interlaced,
/* Loop through passes */
/* Loop through image */
/* Performs intrapixel differencing  */
/* WRITE_16BIT */
/* MNG_FEATURES */
/* Called by user to write a row of image data */
/* 1.5.6: moved from png_struct to be a local structure: */
/* Initialize transformations and other stuff if first time */
/* Make sure we wrote the header info */
/* Check for transforms that have been set but were defined out */
/* If interlaced and not interested in row, return */
/* error: ignore it */
/* Set up row info for transformations */
/* Copy user's row into buffer, leaving room for filter byte. */
/* Handle interlacing */
/* This should always get caught above, but still ... */
/* Handle other transformations */
/* At this point the row_info pixel depth must match the 'transformed' depth,
/* Write filter_method 64 (intrapixel differencing) only if
/* Intrapixel differencing */
/* Added at libpng-1.5.10 */
/* Check for out-of-range palette index */
/* Find a filter if necessary, filter the row and write it out. */
/* Set the automatic flush interval or 0 to turn flushing off */
/* Flush the current output buffers now */
/* We have already written out all of the data */
/* WRITE_FLUSH */
/* forward decl */
/* Free any memory used in png_ptr struct without freeing the struct itself. */
/* Free any memory zlib uses */
/* Free our memory.  png_free checks NULL for us. */
/* Use this to save a little code space, it doesn't free the filter_costs */
/* The error handling and memory handling information is left intact at this
/* Free all memory used by the write.
/* added in libpng 1.6.0 */
/* Allow the application to select one or more row filters to use. */
/* FALL THROUGH */
/* WRITE_FILTER */
/* WRITE_FILTER */
/* If we have allocated the row_buf, this means we have already started
/* WRITE_FILTER */
/* This allows us to influence the way in which libpng chooses the "best"
/* GRR 970116 */
/* Convenience reset API. */
/* Clear out any old values in the 'weights' - this must be done because if
/* Leave the filter_costs - this array is fixed size. */
/* Clear out the arrays */
/* Check arguments; the 'reset' function makes the correct settings for the
/* To make sure that the weighting starts out fairly */
/* Safe to set this now */
/* If, in the future, there are other filter methods, this would
/* All the arrays are inited, safe to set this: */
/* Return the 'ok' code. */
/* Provide floating and fixed point APIs */
/* The internal API allocates all the arrays and ensures that the elements of
/* If using the weighted method copy in the weights. */
/* Here is where we set the relative costs of the different filters.  We
/* FLOATING_POINT */
/* The internal API allocates all the arrays and ensures that the elements of
/* If using the weighted method copy in the weights. */
/* Here is where we set the relative costs of the different filters.  We
/* Use a 32 bit unsigned temporary here because otherwise the
/* FIXED_POINT */
/* WRITE_WEIGHTED_FILTER */
/* The flag setting here prevents the libpng dynamic selection of strategy.
/* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a
/* Prior to 1.6.0 this would warn but then set the window_bits value, this
/* This would produce an invalid PNG file if it worked, but it doesn't and
/* The following were added to libpng-1.5.4 */
/* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a
/* WRITE_CUSTOMIZE_ZTXT_COMPRESSION */
/* end of API added to libpng-1.5.4 */
/* Write the file header information. */
/* ------ these transformations don't touch the info structure ------- */
/* Invert monochrome pixels */
/* Shift the pixels up to a legal bit depth and fill in
/* Pack pixels into bytes */
/* Swap location of alpha bytes from ARGB to RGBA */
/* Remove a filler (X) from XRGB/RGBX/AG/GA into to convert it into
/* Continue if ignored - this is the pre-1.6.10 behavior */
/* Flip BGR pixels to RGB */
/* Swap bytes of 16-bit files to most significant byte first */
/* Swap bits of 1, 2, 4 bit packed pixel formats */
/* Invert the alpha channel from opacity to transparency */
/* ----------------------- end of transformations ------------------- */
/* Write the bits */
/* It is REQUIRED to call this to finish writing the rest of the file */
/* currently required for png_image_write_* */
/* Initialize the write structure - general purpose utility. */
/* Error clean up */
/* Arguments to png_image_write_main: */
/* Arguments: */
/* Local variables: */
/* Write png_uint_16 input to a 16-bit PNG; the png_ptr has already been set to
/* To point to the first component */
/* Work out the output row end and count over this, note that the increment
/* Calculate a reciprocal.  The correct calculation is simply
/* always at least one channel */
/* The following gives 65535 for an alpha of 0, which is fine,
/* component<alpha, so component/alpha is less than one and
/* round to nearest */
/* Skip to next component (skip the intervening alpha channel) */
/* Given 16-bit input (1 to 4 channels) write 8-bit output.  If an alpha channel
/*from the above macro*/)
/* The following gives 1.0 for an alpha of 0, which is fine, otherwise if 0/0
/* component<alpha, so component/alpha is less than one and
/* The test is that alpha/257 (rounded) is less than 255, the first value
/* round to nearest */
/* Convert the component to sRGB. */
/* To point to the first component */
/* Use row_end in place of a loop counter: */
/* Scale and write the alpha channel. */
/* always at least one channel */
/* Skip to next component (skip the intervening alpha channel) */
/* while out_ptr < row_end */
/* while y */
/* No alpha channel, so the row_end really is the end of the row and it
/* NOTE: the caller must check for cmap != NULL and entries != 0 */
/* This gets automatically converted to sRGB with reversal of the
/* no alpha */
/* RGB */
/* Gray */
/* alpha */
/* Calculate a reciprocal, as in the png_write_image_8bit code above
/* RGB */
/* gray */
/* Color-map has sRGB values */
/* FALL THROUGH */
/* FALL THROUGH */
/* The following four ints are actually booleans */
/* input */
/* Make sure we error out on any bad situation */
/*error*/);
/* Default the 'row_stride' parameter if required. */
/* Set the required transforms then write the rows in the correct order. */
/* Counter-intuitively the data transformations must be called *after*
/* The gamma here is 1.0 (linear) and the cHRM chunk matches sRGB. */
/* color      x       y */
/* white */ 31270, 32900,
/* red   */ 64000, 33000,
/* green */ 30000, 60000,
/* blue  */ 15000,  6000
/* Else writing an 8-bit file and the *colors* aren't sRGB, but the 8-bit
/* Write the file header. */
/* Now set up the data transformations (*after* the header is written),
/* If there are 16 or fewer color-map entries we wrote a lower bit depth
/* That should have handled all (both) the transforms. */
/* Apply 'fast' options if the flag is set. */
/* NOTE: determined by experiment using pngstest, this reflects some
/* Check for the cases that currently require a pre-transform on the row
/* Skip the 'write_end' on error: */
/* Otherwise this is the case where the input is in a format currently
/* Write the image to the given (FILE*). */
/* This is slightly evil, but png_init_io doesn't do anything other
/* Write the image to the named file. */
/* from fflush/fclose */
/* Make sure the file is flushed correctly. */
/* from fclose */
/* from fflush or ferror */
/* The image has already been cleaned up; this is just used to
/* Clean up: just the opened file. */
/* STDIO */
/* SIMPLIFIED_WRITE */
/* WRITE */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libpng\pngwtran.c
/* pngwtran.c - transforms the data in a row for PNG writers
/* Pack pixels into bytes.  Pass the true bit depth in bit_depth.  The
/* Shift pixel values to take advantage of whole range.  Pass the
/* With low row depths, could only be grayscale, so one channel */
/* This converts from ARGB to RGBA */
/* This converts from AARRGGBB to RRGGBBAA */
/* WRITE_16BIT */
/* This converts from AG to GA */
/* This converts from AAGG to GGAA */
/* WRITE_16BIT */
/* This inverts the alpha channel in RGBA */
/* Does nothing
/* This inverts the alpha channel in RRGGBBAA */
/* Does nothing
/* WRITE_16BIT */
/* This inverts the alpha channel in GA */
/* This inverts the alpha channel in GGAA */
/* Does nothing
/* WRITE_16BIT */
/* Transform the data according to the user's wishes.  The order of
/* PRIVATE */
/* User write transform
/* png_ptr */
/* row_info: */
/*  png_uint_32 width;       width of row */
/*  png_size_t rowbytes;     number of bytes in row */
/*  png_byte color_type;     color type of pixels */
/*  png_byte bit_depth;      bit depth of samples */
/*  png_byte channels;       number of channels (1-4) */
/*  png_byte pixel_depth;    bits per pixel (depth*channels) */
/* start of pixel data for row */
/* WRITE_TRANSFORMS */
/* WRITE */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libpng\pngwutil.c
/* pngwutil.c - utilities to write a PNG file
/* Place a 32-bit number into a buffer in PNG byte order.  We work
/* Place a 16-bit number into a buffer in PNG byte order.
/* Simple function to write the signature.  If we have already written
/* Inform the I/O callback that the signature is being written */
/* Write the rest of the 8 byte signature */
/* Write the start of a PNG chunk.  The type is the chunk type.
/* Inform the I/O callback that the chunk header is being written.
/* Write the length and the chunk name */
/* Put the chunk name into png_ptr->chunk_name */
/* Reset the crc and run it over the chunk name */
/* Inform the I/O callback that chunk data will (possibly) be written.
/* Write the data of a PNG chunk started with png_write_chunk_header().
/* Write the data, and run the CRC over it */
/* Update the CRC after writing the data,
/* Finish a chunk started with png_write_chunk_header(). */
/* Inform the I/O callback that the chunk CRC is being written.
/* Write the crc in a single operation */
/* Write a PNG chunk all at once.  The type is an array of ASCII characters
/* On 64 bit architectures 'length' may not fit in a png_uint_32. */
/* This is the API that calls the internal function above. */
/* This is used below to find the size of an image to pass to png_deflate_claim,
/* Only return sizes up to the maximum of a png_uint_32; do this by limiting
/* Interlacing makes the image larger because of the replication of
/* This is the code to hack the first two bytes of the deflate stream (the
/* Optimize the CMF field in the zlib stream.  The resultant zlib stream is
/* else windowBits must be 15 */
/* zlib compression method and flags */
/* else no change */
/* WRITE_OPTIMIZE_CMF */
/* Initialize the compressor for the appropriate type of compression. */
/* So the message that results is "<chunk> using zstream"; this is an
/* Attempt sane error recovery */
/* don't steal from IDAT */
/* set below */
/* zlib return code */
/* If customization is not supported the values all come from the
/* Adjust 'windowBits' down if larger than 'data_size'; to stop this
/* IMPLEMENTATION NOTE: this 'half_window_size' stuff is only here to
/* Check against the previous initialized values, if any. */
/* For safety clear out the input and output pointers (currently zlib
/* Now initialize if required, setting the new parameters, otherwise just
/* The return code is from either deflateReset or deflateInit2; they have
/* Clean up (or trim) a linked list of compression buffers. */
/* PRIVATE */
/* This pair of functions encapsulates the operation of (a) compressing a
/* The uncompressed input data */
/* Its length */
/* Final compressed length */
/* First block of output */
/* Compress the data in the compression state input */
/* To find the length of the output it is necessary to first compress the
/* Set up the compression buffers, we need a loop here to avoid overflowing a
/* may be zero! */
/* zlib updates these for us: */
/* Set below */
/* Chunk data is limited to 2^31 bytes in length, so the prefix
/* Need a new (malloc'ed) buffer, but there may be one present
/* Link in this buffer (so that it will be freed later) */
/* Move 'end' to the next buffer pointer. */
/* Compress the data */
/* Claw back input data that was not consumed (because avail_in is
/* safety */
/* There may be some space left in the last output buffer. This needs to
/* safety */
/* Now double check the output length, put in a custom message if it is
/* Reset zlib for another zTXt/iTXt or image data */
/* The only success case is Z_STREAM_END, input_len must be 0; if not this
/* Fix up the deflate header, if required */
/* But Z_OK is returned, not Z_STREAM_END; this allows the claim
/* Ship the compressed text out via chunk writes */
/* This is an internal error; 'next' must have been NULL! */
/* WRITE_COMPRESSED_TEXT */
/* Check that the tEXt or zTXt keyword is valid per PNG 1.0 specification,
/*&& ch <= 255*/))
/* A space or an invalid character when one wasn't seen immediately
/* If the character was not a space then it is invalid. */
/* just skip it, record the first error */
/* trailing space */
/* Terminate the keyword */
/* Try to only output one warning per keyword: */
/* keyword too long */
/* WARNINGS */
/* WRITE_TEXT || WRITE_pCAL || WRITE_iCCP || WRITE_sPLT */
/* Write the IHDR chunk, and update the png_struct with the necessary
/* PRIVATE */
/* Buffer to store the IHDR info */
/* Check that we have valid input data from the application info */
/* Write filter_method 64 (intrapixel differencing) only if
/* Save the relevent information */
/* Set the usr info, so any transformations can modify it */
/* Pack the header information into the buffer */
/* Write the chunk */
/* not READY_FOR_ZTXT */
/* Write the palette.  We are careful not to trust png_color to be in the
/* PRIVATE */
/* This is a little slower but some buggy compilers need to do this
/* This is similar to png_text_compress, above, except that it does not require
/* PRIVATE */
/* First time.   Ensure we have a temporary buffer for compression and
/* It is a terminal error if we can't claim the zstream. */
/* The output state is maintained in png_ptr->zstream, so it must be
/* Now loop reading and writing until all the input is consumed or an error
/* set below */
/* INPUT: from the row data */
/* safe because of the check */
/* Include as-yet unconsumed input */
/* OUTPUT: write complete IDAT chunks when avail_out drops to zero. Note
/* Write an IDAT containing the data then reset the buffer.  The
/* For SYNC_FLUSH or FINISH it is essential to keep calling zlib with
/* The order of these checks doesn't matter much; it just affects which
/* most likely return code! */
/* If all the input has been consumed then just return.  If Z_FINISH
/* This is the end of the IDAT data; any pending output must be
/* Release the stream */
/* This is an error condition. */
/* Write an IEND chunk */
/* PRIVATE */
/* Write a gAMA chunk */
/* PRIVATE */
/* file_gamma is saved in 1/100,000ths */
/* Write a sRGB chunk */
/* PRIVATE */
/* Write an iCCP chunk */
/* PRIVATE */
/* 1 byte for the compression byte */
/* These are all internal problems: the profile should have been checked
/* internal error */
/* Make sure we include the NULL after the name and the compression type */
/* Allow for keyword terminator and compression byte */
/* Write a sPLT chunk */
/* PRIVATE */
/* Make sure we include the NULL after the name */
/* Loop through each palette entry, writing appropriately */
/* Write the sBIT chunk */
/* PRIVATE */
/* Make sure we don't depend upon the order of PNG_COLOR_8 */
/* Write the cHRM chunk */
/* PRIVATE */
/* Each value is saved in 1/100,000ths */
/* Write the tRNS chunk */
/* PRIVATE */
/* Write the chunk out as it is */
/* One 16 bit value */
/* Three 16 bit values */
/* Write the background chunk */
/* PRIVATE */
/* Write the histogram */
/* PRIVATE */
/* Write a tEXt chunk */
/* PRIVATE */
/* Make sure we include the 0 after the key */
/*checked above*/(key_len + text_len + 1));
/*
/* Write a compressed text chunk */
/* PRIVATE */
/* Add the compression method and 1 for the keyword separator. */
/* Compute the compressed data; do it now for the length */
/* Write start of chunk */
/* Write key */
/* Write the compressed data */
/* Close the chunk */
/* Write an iTXt chunk */
/* PRIVATE */
/* Set the compression flag */
/* no compression */
/* compressed */
/* for the keywod separator */
/* We leave it to the application to meet PNG-1.0 requirements on the
/* empty language is valid */
/* may be empty */
/* may be empty */
/* So the string will fit in a chunk: */
/*SAFE*/comp.input_len;
/* Write the oFFs chunk */
/* PRIVATE */
/* Write the pCAL chunk (described in the PNG extensions document) */
/* PRIVATE */
/* terminator */
/* Find the length of each parameter, making sure we don't count the
/* Write the sCAL chunk */
/* PRIVATE */
/* Append the '\0' here */
/* Do NOT append the '\0' here */
/* Write the pHYs chunk */
/* PRIVATE */
/* Write the tIME chunk.  Use either png_convert_from_struct_tm()
/* PRIVATE */
/* Initializes the row writing capability of libpng */
/* PRIVATE */
/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
/* Start of interlace block */
/* Offset to next interlace block */
/* Start of interlace block in the y direction */
/* Offset to next interlace block in the y direction */
/* 1.5.6: added to allow checking in the row write code. */
/* Set up row buffer */
/* Set up filtering buffer, if using this filter */
/* We only need to keep the previous row if we are using one of these. */
/* Set up previous row buffer */
/* WRITE_FILTER */
/* If interlaced, we need to set up width and height of pass */
/* Internal use only.  Called when finished processing a row of data. */
/* PRIVATE */
/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
/* Start of interlace block */
/* Offset to next interlace block */
/* Start of interlace block in the y direction */
/* Offset to next interlace block in the y direction */
/* Next row */
/* See if we are done */
/* If interlaced, go to next pass */
/* Loop until we find a non-zero width or height pass */
/* Reset the row above the image for the next pass */
/* If we get here, we've just written the last row, so we need
/* Pick out the correct pixels for the interlace pass.
/* PRIVATE */
/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
/* Start of interlace block */
/* Offset to next interlace block */
/* We don't have to do anything on the last pass (6) */
/* Each pixel depth is handled separately */
/* Start at the beginning */
/* Find out how many bytes each pixel takes up */
/* Loop through the row, only looking at the pixels that matter */
/* Find out where the original pixel is */
/* Move the pixel */
/* Next pixel */
/* Set new row width */
/* This filters the row, chooses which filter to use, if it has not already
/* PRIVATE */
/* These will never be selected so we need not test them. */
/* Find out how many bytes offset each pixel is */
/* The prediction method we use is to find which method provides the
/* We don't need to test the 'no filter' case if this is the only filter
/* Gives us some footroom */
/* Reduce the sum if we match any of the previous rows */
/* Factor in the cost of this filter (this is here for completeness,
/* Sub filter */
/* It's the only filter so no testing is needed */
/* We temporarily increase the "minimum sum" by the factor we
/* We are already worse, don't continue. */
/* Up filter */
/* We are already worse, don't continue. */
/* Avg filter */
/* We are already worse, don't continue. */
/* Paeth filter */
/* SLOW_PAETH */
/* SLOW_PAETH */
/* We are already worse, don't continue. */
/* WRITE_FILTER */
/* Do the actual writing of the filtered row data from the chosen filter. */
/* Save the type of filter we picked this time for future calculations */
/* WRITE_FILTER */
/* Do the actual writing of a previously filtered row. */
/*includes filter byte*/)
/* Swap the current and previous rows */
/* Finish row - updates counters and flushes zlib if last row */
/* WRITE_FLUSH */
/* WRITE */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libpng\arm\arm_init.c
/* arm_init.c - NEON optimised filter functions
/* Below, after checking __linux__, various non-C90 POSIX 1003.1 functions are
/* Do run-time checks */
/* WARNING: it is strongly recommended that you do not build libpng with
/* for sig_atomic_t */
/* PNG_ARM_NEON_FILE */
/* PNG_ARM_NEON_FILE */
/* PNG_ARM_NEON_CHECK_SUPPORTED */
/* The switch statement is compiled in for ARM_NEON_API, the call to
/* Allow the run-time check to execute if it has been enabled -
/* PNG_ARM_NEON_API_SUPPORTED */
/* not checked */
/* PNG_ARM_NEON_CHECK_SUPPORTED */
/* OFF or INVALID */
/* Option turned on */
/* IMPORTANT: any new external functions used here must be declared using
/* PNG_ARM_NEON_OPT > 0 */
/* PNG_READ_SUPPORTED */
________________________________________________________________________________________
E:/AllLangDS/ds/cpp/tango-examples-c-master\tango-examples-c-master\third_party\libpng\arm\filter_neon_intrinsics.c
/* filter_neon_intrinsics.c - NEON optimised filter functions
/* This code requires -mfpu=neon on the command line: */
/* intrinsics code from pngpriv.h */
/* libpng row pointers are not necessarily aligned to any particular boundary,
/* The following relies on a variable 'temp_pointer' being declared with type
/* a + b */
/* c * 2 */
/* pa */
/* pb */
/* pc */
/* pa <= pb */
/* pa <= pc */
/* pb <= pc */
/* pa <= pb && pa <= pc */
/* PNG_ARM_NEON_OPT > 0 */
/* PNG_READ_SUPPORTED */
/* PNG_ARM_NEON_IMPLEMENTATION == 1 (intrinsics) */
