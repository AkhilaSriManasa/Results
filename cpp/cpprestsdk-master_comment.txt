/***
/* Can pass proxy information via environment variable http_proxy.
//192.1.8.1:8080
// Open a stream to the file to write the HTTP response body into.
// Create an HTTP request.
// Encode the URI query since it could contain special characters like spaces.
//www.bing.com/"), client_config_for_proxy());
// Write the response body into the file buffer.
// Close the file buffer.
// Wait for the entire response body to be written into the file.
/***
// ws2tcpip.h - isn't warning clean.
//
// Entry point for the blackjack client.
// Arguments: BlackJack_Client.exe <port>
// If port is not specified, client will assume that the server is listening on port 34568
//
//localhost:");
/***
// Build our listener's URI from the configured address and the hard-coded path "blackjack/dealer"
//
// To start the server, run the below command with admin privileges:
// BlackJack_Server.exe <port>
// If port is not specified, will listen on 34568
//
//localhost:");
/***
//
// A GET of the dealer resource produces a list of existing tables.
//
// Get information on a specific table.
//
// A POST of the dealer resource creates a new table and returns a resource for
// that table.
//
// Join an existing table.
//
// A DELETE of the player resource leaves the table.
//
// Get information on a specific table.
//
// A PUT to a table resource makes a card request (hit / stay).
//
// Get information on a specific table.
/***
/***
//
// Give everyone two cards.
//
// Double the bet
// Take one card and then stay
// It is **possible** that all players have Blackjack, in which case
// the round is over. It's especially likely when there's only one
// player at the table.
// int idx = m_currentPlayer;
// Handle insurance
// TODO: Right now, players must make sure to get in when the dealer is taking bets.
//       Change the logic to anticipate that a new player may come to the table at
//       any point, and wait until the next round.
//
// Value == suit*16+(facevalue-1)
//
//
// Stack the decks.
//
// Randomize the shoe
//
// Convert to the other format
//
/***
// The Blank Application template is documented at http://go.microsoft.com/fwlink/?LinkId=234227
/// <summary>
/// Initializes the singleton application object.  This is the first line of authored code
/// executed, and as such is the logical equivalent of main() or WinMain().
/// </summary>
/// <summary>
/// Invoked when the application is launched normally by the end user.  Other entry points
/// will be used when the application is launched to open a specific file, to display
/// search results, and so forth.
/// </summary>
/// <param name="args">Details about the launch request and process.</param>
// Do not repeat app initialization when the Window already has content,
// just ensure that the window is active
// Create a Frame to act as the navigation context and associate it with
// a SuspensionManager key
// TODO: Restore the saved session state only when appropriate, scheduling the
// final launch steps after the restore is complete
// When the navigation stack isn't restored navigate to the first page,
// configuring the new page by passing required information as a navigation
// parameter
// Place the frame in the current Window
// Ensure the current window is active
// When the navigation stack isn't restored navigate to the first page,
// configuring the new page by passing required information as a navigation
// parameter
// Ensure the current window is active
/// <summary>
/// Invoked when application execution is being suspended.  Application state is saved
/// without knowing whether the application will be terminated or resumed with the contents
/// of memory still intact.
/// </summary>
/// <param name="sender">The source of the suspend request.</param>
/// <param name="e">Details about the suspend request.</param>
// Unused parameter
// Unused parameter
// TODO: Save application state and stop any background activity
/***
// Adjust the clipping of the cards image to reflect the current card
// Show back of the card
/***
/***
// The User Control item template is documented at http://go.microsoft.com/fwlink/?LinkId=234236
/***
//localhost:34568/blackjack/")
//localhost:34568/blackjack/");
// The cards are already shown.
// Add a dummy card that isn't shown.
/***
//api.eventful.com/json/events/search?...&location=");
//data.tmsapi.com/v1/movies/showings?");
//api.datamarket.azure.com/Bing/Search/Image?$format=json");
//dev.virtualearth.net/REST/v1/Locations");
//maps.googleapis.com/maps/api/geocode/json");
//api.openweathermap.org/data/2.1/find/name?q=");
// FILL IN THE API KEYS FOR THE DIFFERENT SERVICES HERE.
// Refer Readme.txt for details on how to obtain the key for the services.
// Ignore the error, Log it if a logger is available
// Handler to process HTTP::GET requests.
// Replies to the request with data.
// opening the file (open_istream) failed.
// Reply with an error.
// Respond to HTTP::POST messages
// Post data will contain the postal code or location string.
// Aggregate location data from different services and reply to the POST request.
//localhost:");
/***
// In case of any failure to fetch data from a service,
// create a json object with "error" key and value containing the exception details.
// Given postal code, query eventful service and obtain num_events upcoming events at that location.
// Returns a task of json::value of event data
// JSON result Format:
// {"events":["title":"event1","url":"http://event1","starttime":"ddmmyy",..]}
// Event data is null, we hit an error.
// Query openweathermap API and obtain weather information at the given location.
// Returns a task of json::value containing the weather data.
// Format:
// {"weather":{"temperature":"49","pressure":"xxx"..}}
//openweathermap.org/img/w/") +
// Query bing images to fetch some image URLs of the given location
// Returns a task of json::Value
// JSON result format:
// {"images":["url1", "url2"]}
// Get the current date
// Query tmsapi and fetch current movie showtimes at local theaters, for the given postal code
// Also quert bing images for movie posters
// Returns a task of JSON value
// JSON result format:
// "movies":[{"title":"abc","theatre":[{"name":"theater1","datetime":["dd-mm-yyThh:mm"]},{"name":"theater2","datetime":["ddmmyy"]}],"poster":"img-url"}}]}..
// From the data obtained from tmsapi, construct movie JSON value to be sent to the client
// We will collect data for 5 movies, and 5 showtime info per movie.
// new theater
// Add theater entry
// Update the showtime for same theater
// For every movie, obtain movie poster URL from bing
// Ignore any failure in fetching movie posters. Just return
// the movie data to the client.
// Reply with the aggregated JSON data
// Check if the input text is a number or string.
// If string => city name, use bing maps API to obtain the postal code for that city
// number => postal code, use google maps API to obtain city name (location data) for that postal code.
// then call fetch_data to query different services, aggregate movie, images, events, weather etc for that city and
// respond to the request.
// get location from postal code
/***
/***
// The Blank Application template is documented at http://go.microsoft.com/fwlink/?LinkId=234227
/// <summary>
/// Initializes the singleton application object.  This is the first line of authored code
/// executed, and as such is the logical equivalent of main() or WinMain().
/// </summary>
/// <summary>
/// Invoked when the application is launched normally by the end user.  Other entry points
/// will be used when the application is launched to open a specific file, to display
/// search results, and so forth.
/// </summary>
/// <param name="args">Details about the launch request and process.</param>
// Do not repeat app initialization when the Window already has content,
// just ensure that the window is active
// Create a Frame to act as the navigation context and associate it with
// a SuspensionManager key
// TODO: Restore the saved session state only when appropriate, scheduling the
// final launch steps after the restore is complete
// When the navigation stack isn't restored navigate to the first page,
// configuring the new page by passing required information as a navigation
// parameter
// Place the frame in the current Window
// Ensure the current window is active
// When the navigation stack isn't restored navigate to the first page,
// configuring the new page by passing required information as a navigation
// parameter
// Ensure the current window is active
/// <summary>
/// Invoked when application execution is being suspended.  Application state is saved
/// without knowing whether the application will be terminated or resumed with the contents
/// of memory still intact.
/// </summary>
/// <param name="sender">The source of the suspend request.</param>
/// <param name="e">Details about the suspend request.</param>
// Unused parameter
// Unused parameter
// TODO: Save application state and stop any background activity
/***
// Placeholder strings for app tokens
// see blog post at http://aka.ms/FacebookCppRest
// for information on obtaining these values
// Look in the Local Settings for previously-stored login credentials
// Check if the token is still valid
// Currently cached access token is valid
// Return an empty task to match the function's return value
// If the token was invalid, go through full login
// If no token was found, go through full login
// Create uri for OAuth login on Facebook
//www.facebook.com/dialog/oauth");
// App id
//www.facebook.com/connect/login_success.html");
//www.facebook.com/connect/login_success.html")))
// Save authentication token
// Add token to Local Settings for future login attempts
//graph.facebook.com");
/***
/// <summary>
/// Invoked when this page is about to be displayed in a Frame.
/// </summary>
/// <param name="e">Event data that describes how this page was reached.  The Parameter
/// property is typically used to configure the page.</param>
// Unused parameter
// Disable button to prevent double-login
/***
/***
/*
// Extra includes for Windows desktop.
//
// Set key & secret pair to enable session for that service.
//
//
// Utility method to open browser on Windows, OS X and Linux systems.
//
// NOTE: Windows desktop only.
// NOTE: OS X only.
// NOTE: Linux/X11 only.
//
// A simple listener class to capture OAuth 1.0 HTTP redirect to localhost.
// The listener captures redirected URI and obtains the token.
// This type of listener can be implemented in the back-end to capture and store tokens.
//
//
// Base class for OAuth 1.0 sessions of this sample.
//
//
// Specialized class for LinkedIn OAuth 1.0 session.
//
//api.linkedin.com/uas/oauth/requestToken"),
//www.linkedin.com/uas/oauth/authenticate"),
//api.linkedin.com/uas/oauth/accessToken"),
//localhost:8888/"))
//api.linkedin.com/v1/people/"), m_http_config);
//
// Specialized class for Twitter OAuth 1.0 session.
//
//api.twitter.com/oauth/request_token"),
//api.twitter.com/oauth/authorize"),
//api.twitter.com/oauth/access_token"),
//testhost.local:8890/"))
//api.twitter.com/1.1/"), m_http_config);
/***
/*
// Extra includes for Windows desktop.
//
// Set key & secret pair to enable session for that service.
//
//
// Utility method to open browser on Windows, OS X and Linux systems.
//
// NOTE: Windows desktop only.
// NOTE: OS X only.
// NOTE: Linux/X11 only.
//
// A simple listener class to capture OAuth 2.0 HTTP redirect to localhost.
// The listener captures redirected URI and obtains the token.
// This type of listener can be implemented in the back-end to capture and store tokens.
//
//
// Base class for OAuth 2.0 sessions of this sample.
//
//
// Specialized class for Dropbox OAuth 2.0 session.
//
//www.dropbox.com/1/oauth2/authorize"),
//api.dropbox.com/1/oauth2/token"),
//localhost:8889/"))
// Dropbox uses "default" OAuth 2.0 settings.
//api.dropbox.com/1/"), m_http_config);
//
// Specialized class for LinkedIn OAuth 2.0 session.
//
//www.linkedin.com/uas/oauth2/authorization"),
//www.linkedin.com/uas/oauth2/accessToken"),
//localhost:8888/"))
// LinkedIn doesn't use bearer auth.
// Also doesn't use HTTP Basic for token endpoint authentication.
// Also doesn't use the common "access_token", but "oauth2_access_token".
//api.linkedin.com/v1/people/"), m_http_config);
//
// Specialized class for Microsoft Live Connect OAuth 2.0 session.
//
//login.live.com/oauth20_authorize.srf"),
//login.live.com/oauth20_token.srf"),
//testhost.local:8890/"))
// Scope "wl.basic" allows fetching user information.
//apis.live.net/v5.0/"), m_http_config);
//
// App.xaml.cpp
// Implementation of the App class.
//
// The Blank Application template is documented at http://go.microsoft.com/fwlink/?LinkId=234227
/// <summary>
/// Initializes the singleton application object.  This is the first line of authored code
/// executed, and as such is the logical equivalent of main() or WinMain().
/// </summary>
/// <summary>
/// Invoked when the application is launched normally by the end user.  Other entry points
/// will be used when the application is launched to open a specific file, to display
/// search results, and so forth.
/// </summary>
/// <param name="args">Details about the launch request and process.</param>
// Do not repeat app initialization when the Window already has content,
// just ensure that the window is active
// Create a Frame to act as the navigation context and associate it with
// a SuspensionManager key
// TODO: Restore the saved session state only when appropriate, scheduling the
// final launch steps after the restore is complete
// When the navigation stack isn't restored navigate to the first page,
// configuring the new page by passing required information as a navigation
// parameter
// Place the frame in the current Window
// Ensure the current window is active
// When the navigation stack isn't restored navigate to the first page,
// configuring the new page by passing required information as a navigation
// parameter
// Ensure the current window is active
/// <summary>
/// Invoked when application execution is being suspended.  Application state is saved
/// without knowing whether the application will be terminated or resumed with the contents
/// of memory still intact.
/// </summary>
/// <param name="sender">The source of the suspend request.</param>
/// <param name="e">Details about the suspend request.</param>
// Unused parameter
// Unused parameter
// TODO: Save application state and stop any background activity
//
// MainPage.xaml.cpp
// Implementation of the MainPage class.
//
//
// NOTE: You must set this Live key and secret for app to work.
//
//login.live.com/oauth20_authorize.srf",
//login.live.com/oauth20_token.srf",
//login.live.com/oauth20_desktop.srf")
/// <summary>
/// Invoked when this page is about to be displayed in a Frame.
/// </summary>
/// <param name="e">Event data that describes how this page was reached.  The Parameter
/// property is typically used to configure the page.</param>
// Unused parameter
// Start over, clear tokens and button state.
//apis.live.net/v5.0/"), http_config));
//
// pch.cpp
// Include the standard header and generate the precompiled header.
//
/***
/// <summary>
/// A convenient helper function to loop asychronously until a condition is met.
/// </summary>
/// <summary>
/// Structure used to store individual line results.
/// </summary>
/// <summary>
/// Parser implementation for 'matched_lines' type.
/// </summary>
// namespace streams
// namespace Concurrency
/// <summary>
/// Function to create in data from a file and search for a given string writing all lines containing the string to
/// memory_buffer.
/// </summary>
// Close the file and results stream.
/// <summary>
/// Function to write out results from matched_lines type to file
/// </summary>
// Create a shared pointer to the matched_lines structure to copying repeatedly.
// Find all matches in file.
// Write matches into custom data structure.
// Write out stored match data to a new file.
// Wait for everything to complete.
/***
// The Blank Application template is documented at http://go.microsoft.com/fwlink/?LinkId=234227
/// <summary>
/// Initializes the singleton application object.  This is the first line of authored code
/// executed, and as such is the logical equivalent of main() or WinMain().
/// </summary>
/// <summary>
/// Invoked when the application is launched normally by the end user.  Other entry points
/// will be used when the application is launched to open a specific file, to display
/// search results, and so forth.
/// </summary>
/// <param name="args">Details about the launch request and process.</param>
// Do not repeat app initialization when the Window already has content,
// just ensure that the window is active
// Create a Frame to act as the navigation context and associate it with
// a SuspensionManager key
// TODO: Restore the saved session state only when appropriate, scheduling the
// final launch steps after the restore is complete
// When the navigation stack isn't restored navigate to the first page,
// configuring the new page by passing required information as a navigation
// parameter
// Place the frame in the current Window
// Ensure the current window is active
// When the navigation stack isn't restored navigate to the first page,
// configuring the new page by passing required information as a navigation
// parameter
// Ensure the current window is active
/// <summary>
/// Invoked when application execution is being suspended.  Application state is saved
/// without knowing whether the application will be terminated or resumed with the contents
/// of memory still intact.
/// </summary>
/// <param name="sender">The source of the suspend request.</param>
/// <param name="e">Details about the suspend request.</param>
// Unused parameter
// Unused parameter
// TODO: Save application state and stop any background activity
/***
// The Blank Page item template is documented at http://go.microsoft.com/fwlink/?LinkId=234238
/// <summary>
/// Invoked when this page is about to be displayed in a Frame.
/// </summary>
/// <param name="e">Event data that describes how this page was reached.  The Parameter
/// property is typically used to configure the page.</param>
// Unused parameter
// The following functions let you get information for an arbitrary WL resource, upload a file, or download a file.
// Use the Live Connect Interactive SDK on MSDN to explore your WL data and then try the same here.
//
// Some other things to try:
//
//  delete a file using lv_client.remove()
//  copy or move a file using lv_client.copy() and lv_client.move().
//  create a contact using lv_client.post()
//  modify a calendar event using lv_client.put()
//
// Start by getting the file metadata from OneDrive. We need the file name.
// Once we have the name, we can create a storage file in the downloads folder.
// With a file reference in hand, we download the file.
/***
/***
//github.com/Microsoft/cpprestsdk
// Helper function to check to make sure the uri is valid.
// Some things like proper URI schema are verified by the URI class.
// We only need to check certain things specific to HTTP.
// We have already read (and transmitted) the request body. Should we explicitly close the stream?
// Well, there are test cases that assumes that the istream is valid when t receives the response!
// For now, we will drop our reference which will close the stream if the user doesn't have one.
// If cancellation has been triggered then ignore any errors.
// First try to complete the headers with an exception.
// Complete the request with no msg body. The exception
// should only be propagated to one of the tce.
// Complete the request with an exception
// If the response body is compressed we will read the encoding header and create a decompressor object which will
// later decompress the body
// Note that some headers, for example "Transfer-Encoding: chunked", may legitimately not produce a decompressor
// Note that, while Transfer-Encoding (chunked only) is valid with Content-Encoding,
// we don't need to look for it here because winhttp de-chunks for us in that case
// Add the correct header needed to request a compressed response if supported
// on this platform and it has been specified in the config and/or request
// Accept-Encoding -- request Content-Encoding from the server
// TE -- request Transfer-Encoding from the server
// Required by Section 4.3 of RFC-7230
// Copy the user specified output stream over to the response
// Prepare for receiving data from the network. Ideally, this should be done after
// we receive the headers and determine that there is a response body. We will do it here
// since it is not immediately apparent where that would be in the callback handler
// Schedule a task to start sending.
// If guarantee order is specified we don't need to do anything.
// If cancellation is enabled and registration was performed, unregister.
// namespace details
/// <summary>
/// Private implementation of http_client. Manages the http request processing pipeline.
/// </summary>
// pplx::extensibility::recursive_lock_t does not support move/copy, but does not delete the functions either.
/// <summary>
/// Initiate an http request into the pipeline
/// </summary>
/// <param name="request">Http request</param>
/// <summary>
/// Adds an HTTP pipeline stage to the pipeline.
/// </summary>
/// <param name="stage">A pipeline stage.</param>
// The last stage is always set up by the client or listener and cannot
// be changed. All application-defined stages are executed before the
// last stage, which is typically a send or dispatch.
// The vector of pipeline stages.
// Macros to help build string at compile time and avoid overhead.
// namespace client
// namespace http
// namespace web
/***
//github.com/Microsoft/cpprestsdk
// GCC Bug 56222 - Pointer to member in lambda should not require this to be captured
// See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=56222
// GCC Bug 51494 - Legal program rejection - capturing "this" when using static method inside lambda
// See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51494
// This bug also afflicts VS2013 which incorrectly reports "warning C4573: the usage of 'symbol' requires the compiler
// to capture 'this' but the current default capture mode does not allow it"
// namespace
// This simply instantiates the internal state to support ssl. It does not perform the handshake.
// Ensures closed connections owned by request_context will not be put to pool when they are released.
// Check if the error code indicates that the connection was closed by the
// server: this is used to detect if a connection in the pool was closed during
// its period of inactivity and we should reopen it.
// Don't bother reopening the connection if it's a new one: in this
// case, even if the connection was really lost, it's still a real
// error and we shouldn't try to reopen it.
// These errors tell if connection was closed.
// For SSL connections, we can also get a different error due to
// incorrect secure connection shutdown if it was closed by the
// server due to inactivity. Unfortunately, the exact error we get
// in this case depends on the Boost.Asio version used.
// Asio < 1.10.8 didn't have ssl::error::stream_truncated
// unlock
// Check to turn on/off server certificate verification.
// Check to set host name for Server Name Indication (SNI)
// Guards concurrent access to socket/ssl::stream. This is necessary
// because timeouts and cancellation can touch the socket at the same time
// as normal message processing.
/// <summary>Implements a connection pool with adaptive connection removal</summary>
/// <remarks>
/// Every 30 seconds, the lambda in `start_epoch_interval` fires, triggering the
/// cleanup of any connections that have resided in the pool since the last
/// cleanup phase.
///
/// During the cleanup phase, connections are removed starting with the oldest. This
/// ensures that if a high intensity workload is followed by a low intensity workload,
/// the connection pool will correctly adapt to the low intensity workload.
///
/// Specifically, the following code will eventually result in a maximum of one pooled
/// connection regardless of the initial number of pooled connections:
/// <code>
///   while(1)
///   {
///     auto conn = pool.try_acquire();
///     if (!conn) conn = new_conn();
///     pool.release(std::move(conn));
///   }
/// </code>
/// </remarks>
// Note: must be called under m_lock
// Pool was empty. Create a new connection
// CPPREST_PLATFORM_ASIO_CERT_VERIFICATION_AVAILABLE
// Release connection back to the pool. If connection was not closed, it will be put to the pool for reuse.
//// Replace the connection. This causes old connection object to go out of scope.
// There is no support for auto-detection of proxies on non-windows platforms, it must be specified explicitly
// from the client code.
// For a normal http proxy, we need to specify the full request uri, otherwise just specify the resource
// stop injection of headers via method
// resource should be ok, since it's been encoded
// and host won't resolve
// Add the Host header if user has not specified it explicitly
// Extra request headers are constructed here.
// Add header for basic proxy authentication
// Check user specified transfer-encoding.
// Stream without content length is the signal of requiring transfer encoding chunked.
// Some servers do not accept POST/PUT requests with a content length of 0, such as
// lighttpd - http://serverfault.com/questions/315849/curl-post-411-length-required
// old apache versions - https://issues.apache.org/jira/browse/TS-2902
// Enforce HTTP connection keep alive (even for the old HTTP/1.0 protocol).
// Start connection timeout timer.
// If socket is a reused connection or we're connected via an ssl-tunneling proxy, try to write the
// request directly. In both cases we have already established a tcp connection.
// If the connection is new (unresolved and unconnected socket), then start async
// call to resolve first, leading eventually to request write.
// For normal http proxies, we want to connect directly to the proxy server. It will relay our request.
// Register for notification on cancellation to abort this request.
// weak_ptr prevents lambda from taking shared ownership of the context.
// Otherwise context replacement in the handle_status_line() would leak the objects.
// Shut down transmissions, close the socket and prevent connection from being pooled.
// Note that we must not try to CONNECT using an already established connection via proxy -- this would send
// CONNECT to the end server which is definitely not what we want.
// The ssl_tunnel_proxy keeps the context alive and then calls back once the ssl tunnel is established via
// 'start_http_request_flow'
// Don't recycle connections that had an error into the connection pool.
// By default, errorcodeValue don't need to converted
// map timer cancellation to time_out
// We need to correct inaccurate ASIO error code base on context information
// bug in boost error_code mapping
// Replace the connection. This causes old connection object to go out of scope.
// Only perform handshake if a TLS connection and not being reused.
// Use a weak_ptr since the verify_callback is stored until the connection is
// destroyed. This avoids creating a circular reference since we pool connection
// objects.
// OpenSSL calls the verification callback once per certificate in the chain,
// starting with the root CA certificate. The 'leaf', non-Certificate Authority (CA)
// certificate, i.e. actual server certificate is at the '0' position in the
// certificate chain, the rest are optional intermediate certificates, followed
// finally by the root CA self signed certificate.
// If OpenSSL fails we will doing verification at the end using the whole certificate
// chain so wait until the 'leaf' cert. For now return true so OpenSSL continues down
// the certificate chain.
// CPPREST_PLATFORM_ASIO_CERT_VERIFICATION_AVAILABLE
// Reuse error handling.
// Reuse error handling.
// Read until the end of entire headers
// if HTTP version is 1.0 then disable 'Keep-Alive' by default
// Failed to write to socket because connection was already closed while it was in the pool.
// close() here ensures socket is closed in a robust way and prevents the connection from being put to the
// pool again.
// Create a new context and copy the request object, completion event and
// cancellation registration to maintain the old state.
// This also obtains a new connection from pool.
// If the request contains a valid instream, we try to rewind it to
// replay the just-failed request. Otherwise we assume that no data
// was sent in the first place.
// As stated in the commit message of f4f2348, we might encounter
// streams that are not capable of rewinding and hence resending the
// request is not possible. We cannot recover from this condition and
// need to escalate it to the using code.
// Rewinding the stream might throw, in which case we cannot do the
// connection re-establishment transparently. I.e. report the exception
// to the calling code.
// Resend the request using the new context.
// If the server uses HTTP/1.1, then 'Keep-Alive' is the default,
// so connection is explicitly closed only if we get "Connection: close".
// If the server uses HTTP/1.0, it would need to respond using
// 'Connection: Keep-Alive' every time.
// Without Content-Length header, size should be same as
// TCP stream - set it size_t max.
// false indicates report_exception was called
// Check for HEAD requests and status codes which cannot contain a
// message body in HTTP/1.1 (see 3.3.3/1 of the RFC 7230).
//
// note: need to check for 'chunked' here as well, azure storage sends both
// transfer-encoding:chunked and content-length:0 (although HTTP says not to)
// we can stop early - no body
// Need to guard against attempting to decompress when we're already finished or encountered an error!
// It is valid for the decompressor to sometimes return an empty output for a given chunk, the data
// will be flushed when the next chunk is received
// consume crlf
// Move the decompressed buffer into a shared_ptr to keep it alive until putn_nocopy completes.
// When VS 2013 support is dropped, this should be changed to a unique_ptr plus a move capture.
// consume crlf
// consume crlf
// more data need to be read
// It is valid for the decompressor to sometimes return an empty output for a given chunk, the data will
// be flushed when the next chunk is received
// Move the decompressed buffer into a shared_ptr to keep it alive until putn_nocopy completes.
// When VS 2013 support is dropped, this should be changed to a unique_ptr plus a move capture.
// Request is complete no more data to read.
// Simple timer class wrapping Boost deadline timer.
// Closes the connection when timer fires.
// The existing handler was canceled so schedule a new one.
// CPPREST_PLATFORM_ASIO_CERT_VERIFICATION_AVAILABLE
// Use a task to externally signal the final result and completion of the task.
// Asynchronously send the response with the HTTP client implementation.
// namespace details
// namespace client
// namespace http
// namespace web
/***
//github.com/Microsoft/cpprestsdk
// If the listener path is empty, then just return the request URI.
// If the user didn't explicitly set a reason phrase then we should have it default
// if they used one of the standard known status codes.
// namespace http
// namespace web
/***
//github.com/Microsoft/cpprestsdk
// unnamed namespace
// Helper function to query for the size of header values.
// Helper function to get the status code from a WinHTTP response.
// Helper function to get the reason phrase from a WinHTTP response.
// WinHTTP reports back the wrong length, trim any null characters.
/// <summary>
/// Parses a string containing HTTP headers.
/// </summary>
// Clear the header map for each new response; otherwise, the header values will be combined.
// Status code and reason phrase.
// Helper function to build error messages.
// Helper function to build an error message from a WinHTTP async result.
// Possible ways a message body can be sent/received.
// Not Windows 8.1 or later, use the default proxy setting
// _WIN32_WINNT < _WIN32_WINNT_WINBLUE
// Windows 8.1 or later, use the automatic proxy setting
// ^^^ _WIN32_WINNT >= _WIN32_WINNT_VISTA ^^^ // vvv _WIN32_WINNT < _WIN32_WINNT_VISTA vvv
// _WIN32_WINNT >= _WIN32_WINNT_VISTA
// Additional information necessary to track a WinHTTP request.
// Factory function to create requests on the heap.
// owned by m_request_handle to be deleted by WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING
// If the user specified that to guarantee data buffering of request data, in case of challenged authentication
// requests, etc... Then if the request stream buffer doesn't support seeking we need to copy the body chunks as it
// is sent.
// This self reference will keep us alive until finish() is called.
// Compress/decompress-related processing state lives here
// defined(_MSC_VER) && _MSC_VER < 1900
// Minimal state for on-the-fly decoding of "chunked" encoded data
// Returns true if the end of chunked data has been reached, specifically whether the 0-length
// chunk and its trailing delimiter has been processed.  Otherwise, offset and length bound the
// portion of buffer that represents a contiguous (and possibly partial) chunk of consumable
// data; offset+length is the total number of bytes processed from the buffer on this pass.
// The data stream does not conform to "chunked" encoding
// Look for further trailer fields or the end of the stream
// We're at the end of the data we need to ignore
// this is only set if we're at the end of the message
// else we're at the end of a trailer field
// We're processing (and ignoring) a trailer field
// We've already seen a carriage return; confirm the linefeed
// The data stream does not conform to "chunked" encoding
// We're processing the terminating "empty" chunk; there's
// no data, we just need to confirm the final chunk delimiter,
// possibly ignoring a trailer part along the way
// else we move on to the chunk data itself
// Now we move on to the next chunk size
// We expect a chunk size next
// We just processed the end-of-input delimiter
// We're processing a post-chunk delimiter
// The data stream does not conform to "chunked" encoding
// We found the carriage return; look for the linefeed
// We're processing an ASCII hexadecimal chunk size
// We've reached the end of the size, and there's no chunk extension
// We've reached the end of the size, and there's a chunk extension;
// we don't support extensions, so we ignore them per RFC
// The data stream does not conform to "chunked" encoding
// We're at the offset of a chunk of consumable data; let the caller process it
// We're moving on to the post-chunk delimiter
// We've previously processed the terminating empty chunk and its
// trailing delimiter; skip the entire buffer, and inform the caller
// Let the caller process the result
// Move on to the next byte
// the number of bytes remaining in the chunk we're currently processing
// if true, we're processing a chunk size or its trailing delimiter
// if true, we're processing a delimiter between a chunk and the next chunk's size
// if true, we're processing a delimiter, and we've already seen its carriage return
// if true, we're processing a chunk extension or trailer, which we don't support
// if true, we're processing (and ignoring) a trailer field; m_ignore is also true
// we read data from the stream into this before compressing
// we use this in place of m_buffer if the stream has directly-accessible data available
// we most recently read this many bytes, which may be less than m_buffer.size()
// we've compressed this many bytes of m_bytes_read so far
// we've read and compressed all bytes, but the compressor still has compressed bytes to
// give us
// we've sent at least some number of bytes to m_decompressor
// we've read, compressed, and consumed all bytes
// if true, we need to decode and decompress a transfer-encoded message
// un-decompressed bytes remaining in the most-recently-obtained data from m_chunk
// We may still hold a piece of the buffer if we encountered an exception; release it here
// we do the validation inside curl
// no custom validation selected; either we've delegated that to winhttp or
// certificate checking is completely disabled
// typically happens when given a custom host with an initially HTTP connection
// already validated OK
// note that the following chain only checks the end certificate; we
// assume WinHTTP already validated everything but the common name.
// we assume WinHTTP already checked these:
/* SECURITY_FLAG_IGNORE_REVOCATION */
/* SECURITY_FLAG_IGNORE_UNKNOWN_CA */
/* SECURITY_FLAG_IGNORE_WRONG_USAGE */
/* SECURITY_FLAG_IGNORE_CERT_DATE_INVALID */,
// As the stack frame cleans up, this will be deleted if no other references exist.
// Can only create on the heap using factory function.
//  It is the server's responsibility only to accept
//  authentication schemes that provide a sufficient
//  level of security to protect the servers resources.
//
//  The client is also obligated only to use an authentication
//  scheme that adequately protects its username and password.
//
// Small RAII helper to ensure that the fields of this struct are always
// properly freed.
// WinHTTP client.
// Closes session.
// Unregister the callback.
// Use a task to externally signal the final result and completion of the task.
// Asynchronously send the response with the HTTP client implementation.
// Open session and connection with the server.
// This object have lifetime greater than proxy_name and proxy_bypass
// which may point to its elements.
// Windows 8 or earlier, do proxy autodetection ourselves
// ... then try to fall back on the default WinINET proxy, as
// recommended for the desktop applications (if we're not
// running under a user account, the function below will just
// fail, so there is no real need to check for this explicitly)
// WinHttpOpen cannot handle trailing slash in the name, so here is some string gymnastics to keep
// WinHttpOpen happy proxy_str is intentionally declared at the function level to avoid pointing to the
// string in the destructed object
// Open session.
// Set timeouts.
// Set max connection to use per server to 1.
// Enable TLS 1.1 and 1.2
// Register asynchronous callback.
// Open connection.
// Start sending request.
// First see if we need to be opened.
// DO NOT TOUCH the this pointer after completing the request
// This object could be freed along with the request as it could
// be the last reference to this object
// stop injection of headers via method
// resource should be ok, since it's been encoded
// and host won't resolve
// Failure to download the auto-configuration script is not fatal. Fall back to the default proxy.
// Need to form uri path, query, and fragment for this request.
// Make sure to keep any path that was specified with the uri when the http_client was created.
// Open the request.
// If credentials are specified, use autologon policy: WINHTTP_AUTOLOGON_SECURITY_LEVEL_HIGH
//    => default credentials are not used.
// Else, the default autologon policy WINHTTP_AUTOLOGON_SECURITY_LEVEL_MEDIUM will be used.
// Check to turn off server certificate verification.
// if we are validating certificates, also turn on revocation checking
// check if the user has overridden the desired Common Name with the host header
// There is a request body that needs to be transferred.
// The content length is not set and the application set a stream. This is an
// indication that we will use transfer encoding chunked.  We still want to
// know that stream's effective length if possible for memory efficiency.
// While we won't be transfer-encoding the data, we will write it in portions.
// Prepare to request a compressed response from the server if necessary.
// Add headers.
// Register for notification on cancellation to abort this request.
// cancellation callback is unregistered when request is completed.
// Call the WinHttpSendRequest API after WinHttpCloseHandle will give invalid handle error and we
// throw this exception. Call the cleanup to make the m_request_handle as nullptr, otherwise,
// Application Verifier will give AV exception on m_request_handle.
// Call the callback function of user customized options.
// Only need to cache the request body if user specified and the request stream doesn't support seeking.
// Capture the current read position of the stream.
// Record starting position in case request is challenged for authorization
// and needs to seek back to where reading is started from.
// If we find ourselves here, we either don't know how large the message
// Helper function to query/read next part of response data from winhttp.
// If user specified a chunk size then read in chunks instead of using query data available.
// If bytes read is less than the chunk size this request is done.
// Is it really, though?  The WinHttpReadData docs suggest that less can be returned regardless...
// m_buffer holds the compressed data; we'll decompress into the caller's buffer later
// Set the chunk size up front; we need it before the lambda functions come into scope
// We could allocate less than a chunk for the compressed data here, though that
// would result in more trips through this path for not-so-compressible data...
// If we've previously allocated space for the compressed data, don't reduce it
// Choose a semi-intelligent size based on how much total data is left to compress
// Just base our allocation on the chunk size, since we don't have any other data available
// We're not compressing; use the smaller of the remaining data (if known) and the configured (or default)
// chunk size
// If the read buffer for copying exists then write to it.
// We have raw memory here writing to a memory stream so it is safe to wait
// since it will always be non-blocking.
// The stream ended earlier than we detected it should
// Stop writing chunks if we reached the end of the stream.
// Note that we could detect end-of-stream based on !m_remaining_to_write, and insert
// the last (0) chunk if we have enough extra space... though we currently don't.
// Move the saved buffer into the read buffer, which now supports seeking.
// An actual read always resets compression state for the next chunk
// If we've been asked to keep a copy of the raw data for restarts, do so here, pre-compression
// We've read to the end of the stream; finalize here if possible.  We'll
// decrement the remaining count as we actually process the read buffer.
// All input has been consumed, but we still need to collect additional compressed output;
// this is done (in theory it can be multiple times) as a finalizing operation
// The stream ended earlier than we detected it should
// We think we're done; inform the compression library so it can finalize and/or give us any pending
// compressed bytes. Note that we may end up here multiple times if m_needs_flush is set, until all
// compressed bytes are drained.
// else we're still compressing bytes from the previous read
// We're done reading all chunks, but the compressor may still have compressed bytes to
// drain from previous reads
// Update the number of bytes compressed in this read chunk; if it's been fully compressed,
// we'll reset m_bytes_processed and m_bytes_read after reading the next chunk
// Release the acquired buffer back to the streambuf at the earliest possible point
// We're still working on data from a previous read; continue compression without reading new data
// We just need to send the last (zero-length) chunk; there's no sense in going through the compression
// path
// We need to read from the input stream, then compress before sending
// Unexpected end-of-stream.
// The stream grew, but we won't
// We're not compressing; just read and chunk
// Unexpected end-of-stream.
// Stop writing chunks after this one if no more data.
// Stop writing chunks after this one if no more data.
// use initial small string optimization capacity
// Returns true if we handle successfully and resending the request
// or false if we fail to handle.
// Check if the saved read position is valid
// Try to seek back to the saved read position
// We successfully seeked back; now reset the compression state, if any, to match
//  If we got ERROR_WINHTTP_RESEND_REQUEST, the response header is not available,
//  we cannot call WinHttpQueryAuthSchemes and WinHttpSetCredentials.
// Obtain the supported and preferred schemes.
// This will return the authentication failure to the user, without reporting fatal errors
// This will return the authentication failure to the user, without reporting fatal errors
// If we have been redirected, then WinHttp needs the proxy credentials again to make the next request
// leg (which may be on a different server)
// No credentials found so can't resend.
// New scope to ensure plaintext password is cleared as soon as possible.
// Reset the request body type since it might have already started sending.
// There is a request body that needs to be transferred.
// The content length is unknown and the application set a stream. This is an
// indication that we will need to chunk the data.
// While we won't be transfer-encoding the data, we will write it in portions.
// We're good.
// We will not complete the request. Instead wait for the response to the request that was resent
// Callback used with WinHTTP to listen for async completions.
// This callback is responsible for freeing the type-erased context.
// This particular status code indicates that this is the final callback call, suitable for context
// destruction.
// The request context was already released, probably due to cancellation
//  Some authentication schemes require multiple transactions.
//  When ERROR_WINHTTP_RESEND_REQUEST is encountered,
//  we should continue to resend the request until a response is received that does not contain a 401 or
//  407 status code.
// The request is resending. Wait until we get a new response.
// Report progress finished uploading with no message body.
// First need to query to see what the headers size is.
// Now allocate buffer for headers and query for them.
/*401*/ ||
/*407*/)
// The request was not completed but resent with credentials. Wait until we get a new response
// Check whether the request is compressed, and if so, whether we're handling it.
// false indicates report_exception was called
// Signal that the headers are available.
// If the method was 'HEAD,' the body of the message is by definition empty. No need to
// read it. Any headers that suggest the presence of a body can safely be ignored.
// HTTP Specification states:
// If a message is received with both a Transfer-Encoding header field
// and a Content-Length header field, the latter MUST be ignored.
// If none of them is specified, the message length should be determined by the server closing the
// connection. http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.4
// Status information contains pointer to DWORD containing number of bytes available.
// Allocate space for the compressed data; we'll decompress it into the caller stream once it's
// been filled in
// Read in available body data all at once.
// We haven't seen the 0-length chunk and/or trailing delimiter that indicate the end of
// chunked input
// No more data available, complete the request.
// Status information length contains the number of bytes read.
// Report progress about downloaded bytes.
// If no bytes have been read, then this is the end of the response.
// We haven't seen the 0-length chunk and/or trailing delimiter that indicate the end of
// chunked input
// Note, some servers seem to send a first chunk of body data that decompresses to nothing, but
// initializes the decompression state; this produces no decompressed output.  Subsequent chunks
// will then begin emitting decompressed body data.
// Oddly enough, WinHttp doesn't de-chunk for us if "chunked" isn't the only
// encoding, so we need to do so on the fly as we process the received data
// Process the next portion of this piece of the transfer-encoded message
// Skip chunk-related metadata; it isn't relevant to decompression
// We've processed/validated all bytes in this transfer-encoded message.
// Note that we currently ignore "extra" trailing bytes, i.e.
// c->m_compression_state.m_bytes_processed <
// c->m_compression_state.m_bytes_read
// There should be more data to receive; look for it
// Decompression is done; complete the request
// We still have more data to process in the current buffer
// There should be more data to receive; look for it
// Otherwise, we've processed all bytes in the input buffer, but there's a good chance
// that there are still decompressed bytes to emit; we'll do so before reading the next
// chunk
// We're still processing the current message chunk
// The chunked request has been completely processed (or contains no data in the first
// place)
// The outer do-while requires an explicit task return to activate the then() clause
// If it's possible to know how much post-compression data we're expecting (for instance if we
// can discern how much total data the ostream can support, we could allocate (or at least
// attempt to acquire) based on that
// The streambuf couldn't accommodate our request; we'll use m_body_data's
// internal vector as temporary storage, then putn() to the caller's stream
// See if we still have more work to do for this section and/or for the response
// in general
// We decompressed directly into the output stream
// We decompressed into our own buffer; let the stream copy the data
// We're only here to pick up any exception that may have been thrown, and to clean up
// if needed
// If the data was allocated directly from the buffer then commit, otherwise we still
// need to write to the response stream buffer.
// If we couldn't write everything, it's time to exit.
// WinHTTP session and connection
// If auto config is true, dynamically find the proxy for each URL using
// the proxy configuration script at the given URL if it's not empty or
// using WPAD otherwise.
// namespace details
// namespace client
// namespace http
// namespace web
/***
//github.com/Microsoft/cpprestsdk
// Important for WP8
// Additional information necessary to track a WinRT request.
// Factory function to create requests on the heap.
// Request contexts must be created through factory function.
// But constructor needs to be public for make_shared to access.
// Implementation of IXMLHTTPRequest2Callback.
// Called when the HTTP request is being redirected to a new URL.
// Called when HTTP headers have been received and processed.
// Called when a portion of the entity body has been received.
// Called when the entire entity response has been received.
// Break the circular reference loop.
//     - winrt_request_context holds a reference to IXmlHttpRequest2
//     - IXmlHttpRequest2 holds a reference to HttpRequestCallback
//     - HttpRequestCallback holds a reference to winrt_request_context
//
// Not releasing the winrt_request_context below previously worked due to the
// implementation of IXmlHttpRequest2, after calling OnError/OnResponseReceived
// it would immediately release its reference to HttpRequestCallback. However
// it since has been discovered on Xbox that the implementation is different,
// the reference to HttpRequestCallback is NOT immediately released and is only
// done at destruction of IXmlHttpRequest2.
//
// To be safe we now will break the circular reference.
// Called when an error occurs during the HTTP request.
// Break the circular reference loop.
// See full explanation in OnResponseReceived
/// <summary>
/// This class acts as a bridge for the underlying request stream.
/// </summary>
/// <remarks>
/// These operations are completely synchronous, so it's important to block on both
/// read and write operations. The I/O will be done off the UI thread, so there is no risk
/// of causing the UI to become unresponsive.
/// </remarks>
// read_length is the initial length of the ISequentialStream that is available for read
// This is required because IXHR2 attempts to read more data that what is specified by
// the content_length. (Specifically, it appears to be reading 128K chunks regardless of
// the content_length specified).
// OnError has already been called so just error out
// Do not read more than the specified read_length
// The request context controls the lifetime of this class so we only hold a weak_ptr.
// Length of the ISequentialStream for reads. This is equivalent
// to the amount of data that the ISequentialStream is allowed
// to read from the underlying stream buffer.
/// <summary>
/// This class acts as a bridge for the underlying response stream.
/// </summary>
/// <remarks>
/// These operations are completely synchronous, so it's important to block on both
/// read and write operations. The I/O will be done off the UI thread, so there is no risk
/// of causing the UI to become unresponsive.
/// </remarks>
// OnError has already been called so just error out
// The request context controls the lifetime of this class so we only hold a weak_ptr.
// WinRT client.
// Use a task to externally signal the final result and completion of the task.
// Asynchronously send the response with the HTTP client implementation.
// Start sending request.
// Not supported by WinInet. Generate a more specific exception than what WinInet does.
// IXHR2 does not allow transfer encoding chunked. So the user is expected to set the content length
// Start sending HTTP request.
// New scope to ensure plain text password is cleared as soon as possible.
// Suppress automatic prompts for user credentials, since they are already provided.
// Set timeout.
// If XHR_PROP_ONDATA_NEVER is defined in ixmlhttprequest.h or msxml6.h utilize it.
// Specifies never to call OnDataAvailable improving performance and we
// already don't use OnDataAvaliable anyway.
// Add headers.
// Set response stream.
// Call the callback function of user customized options
// Register for notification on cancellation to abort this request.
// cancellation callback is unregistered when request is completed.
// namespace details
// namespace client
// namespace http
// namespace web
/***
//github.com/Microsoft/cpprestsdk
// Encode into DER format into raw memory.
// The Windows Crypto APIs don't do host name checks, use Boost's implementation.
/// <summary>
/// Helper function to check return value and see if any exceptions
/// occurred when calling a JNI function.
/// <summary>
/// <returns><c>true</c> if JNI call failed, <c>false</c> otherwise.</returns>
// Clear exception otherwise no other JNI functions can be called.
// In the future if we improve error reporting the exception message
// can be retrieved from here.
// Possible performance improvement:
// In the future we could gain performance by turning all the jclass local
// references into global references. Then we could lazy initialize and
// save them globally. If this is done I'm not exactly sure where the release
// should be.
// ByteArrayInputStream
// CertificateFactory
// X509Certificate
// TrustManagerFactory
// X509TrustManager
// StrictHostnameVerifier
// Create CertificateFactory
// Create Java array to store all the certs in.
// For each certificate perform the following steps:
//   1. Create ByteArrayInputStream backed by DER certificate bytes
//   2. Create Certificate using CertificateFactory.generateCertificate
//   3. Add Certificate to array
// Create TrustManagerFactory, init with Android system certs
// Get TrustManager
// Validate certificate chain.
// Verify hostname on certificate according to RFC 2818.
// Simple RAII pattern wrapper to perform CFRelease on objects.
// namespace
// Build up CFArrayRef with all the certificates.
// All this code is basically just to get into the correct structures for the Apple APIs.
// Copies are avoided whenever possible.
// Create trust management object with certificates and SSL policy.
// Note: SecTrustCreateWithCertificates expects the certificate to be
// verified is the first element.
/* client side */, cfHostName.get());
// Perform actual certificate verification.
// Create certificate context from server certificate.
// Let the OS build a certificate chain from the server certificate.
// Check to see if the certificate chain is actually trusted.
// namespace details
// namespace client
// namespace http
// namespace web
/***
//github.com/Microsoft/cpprestsdk
// CPPREST_EXCLUDE_COMPRESSION is set if we're on a platform that supports compression but we want to explicitly disable
// it. CPPREST_EXCLUDE_BROTLI is set if we want to explicitly disable Brotli compression support.
// CPPREST_EXCLUDE_WEBSOCKETS is a flag that now essentially means "no external dependencies". TODO: Rename
// !defined(CPPREST_EXCLUDE_COMPRESSION)
// defined(TARGET_OS_MAC)
// !defined(CPPREST_EXCLUDE_WEBSOCKETS) && !defined(CPPREST_EXCLUDE_COMPRESSION)
// zconf.h may define compress
// CPPREST_EXCLUDE_BROTLI
// CPPREST_BROTLI_COMPRESSION
// A shared base class for the gzip and deflate compressors
// __clang__
// __clang__
// A shared base class for the gzip and deflate decompressors
// __clang__
// __clang__
// Z_BUF_ERROR is a success code for Z_FINISH, and the caller can continue as if operation_hint::is_last was
// not given
// 15 is MAX_WBITS in zconf.h; add 16 for gzip
// gzip auto-detect
// 15 is MAX_WBITS in zconf.h
// deflate auto-detect
// Drain any compressed bytes remaining from a prior call
// Compress the caller-supplied buffer
// We're not compressing any new data; ensure calculation sanity
// Make one more pass to finalize the compressed stream
/* || !input_size*/)
// N.B. we ignore 'hint' here.  We could instead call BrotliDecoderDecompress() if it's set, but we'd either
// have to first allocate a guaranteed-large-enough buffer and then copy out of it, or we'd have to call
// reset() if it failed due to insufficient output buffer space (and we'd need to use
// BrotliDecoderGetErrorCode() to tell if that's why it failed)
// CPPREST_BROTLI_COMPRESSION
// CPPREST_HTTP_COMPRESSION
// Generic internal implementation of the compress_factory API
// Generic internal implementation of the decompress_factory API
// "Private" algorithm-to-factory tables for namespace static helpers
// CPPREST_BROTLI_COMPRESSION
// CPPREST_HTTP_COMPRESSION
// CPPREST_HTTP_COMPRESSION
// CPPREST_BROTLI_COMPRESSION
// CPPREST_HTTP_COMPRESSION
// CPPREST_HTTP_COMPRESSION
// CPPREST_HTTP_COMPRESSION
// CPPREST_HTTP_COMPRESSION
// CPPREST_HTTP_COMPRESSION
// CPPREST_HTTP_COMPRESSION
// CPPREST_BROTLI_COMPRESSION
// CPPREST_BROTLI_COMPRESSION
// namespace builtin
// namespace builtin
// See https://tools.ietf.org/html/rfc7230#section-4.3 (TE) and
// https://tools.ietf.org/html/rfc7231#section-5.3.4 (Accept-Encoding) for details
// Tokenize by commas first
// Then remove leading and trailing whitespace
// Next split at the semicolon, if any, and deal with rank and additional whitespace
// Skip trailing whitespace in encoding type
// Check for an optional ranking, max. length "q=0.999"
// Determine ranking; leading whitespace has been implicitly skipped by find().
// The ranking always starts with '1' or '0' per standard, and has at most 3 decimal places
// This is a real number rank; convert decimal part to hundreds and apply it
// An entirely empty header is OK per RFC, but an extraneous comma is not
// Immediately try to instantiate a compressor for any unranked or top-ranked algorithm
// Store off remaining ranked algorithms, sorting as we go
// else a rank of 0 means "not permitted"
// else we've chosen a compressor; we're just validating the rest of the header
// Note: for Accept-Encoding, we don't currently explicitly handle "identity;q=0" and "*;q=0"
// If we're here, we didn't match the caller's compressor above;
// try any that we saved off in order of highest to lowest rank
// N.B for TE, "trailers" will simply fail to instantiate a
// compressor; ditto for "*" and "identity" for Accept-Encoding
// The client specified a preference for "no encoding" vs. anything else we might still have
// Tokenize by commas first
// Then remove leading and trailing whitespace
// Immediately try to instantiate a decompressor
// We found our decompressor; store it off while we process the rest of the header
// The first encoding type did not match; throw an informative
// exception with an encoding-type-appropriate HTTP error code
// Either the response is compressed and we have a decompressor that can handle it, or
// built-in compression is not enabled and we don't have an alternate set of decompressors
// Add all specified algorithms and their weights to the header
// Request that no encoding be applied
// namespace details
// namespace compression
// namespace http
// namespace web
/***
//github.com/Microsoft/cpprestsdk
// Remove once VS 2013 is no longer supported.
// Future improvement: why is this stored as an array of structs instead of a map
// indexed on the status code for faster lookup?
// Not a big deal because it is uncommon to not include a reason phrase.
// The end of the size.
// The end of the message.
// The end of the size.
// The end of the chunk.
// 0-15
// 16-31
// 32-47
// 48-63
// 64-79
// 80-95
// 96-111
// 112-127
// Checks if the method contains any invalid characters
// namespace details
// namespace http
// namespace web
/***
//github.com/Microsoft/cpprestsdk
/// Helper functions to convert a series of bytes from a charset to utf-8 or utf-16.
/// These APIs deal with checking for and handling byte order marker (BOM).
// little endian
// big endian
// Helper function to change endian ness from big endian to little endian
// unknown defaults to big endian.
// unknown defaults to big endian.
// namespace
// namespace details
// check no failure, fully consumed, and correct fixed text
// See if the user specified an outstream
// The user did not specify an outstream.
// We will create one...
// Since we are creating the streambuffer, set the input stream
// so that the user can retrieve the data.
// If the user did specify an outstream we leave the instream
// as invalid. It is assumed that user either has a read head
// to the out streambuffer or the data is streamed into a container
// or media (like file) that the user can read from...
// An invalid response_stream indicates that there is no body
// Transfer encoding is set; it trumps any content length that may or may not be present
// Build a header for comparison with the existing one
// Some external entity added this header, and it doesn't match our
// expectations; bail out, since the caller's intentions are not clear
// A compressor is set; this implies transfer encoding, since we don't know the compressed length
// up front for content encoding.  We return the uncompressed length if we can figure it out.
// An explicit content length is set; trust it, since we
// may not be required to send the stream's entire contents
// The content length wasn't explicitly set, but we figured it out;
// use it, since sending this way is more efficient than chunking
// We don't know the content length; we'll chunk the stream
// There is no content
// Helper function to inline continuation if possible.
// if the outstream is one we created by default on the customer's behalf, try to close it
// If close throws an exception report back to user.
// If closing stream throws an exception ignore since we already have an error.
// Remove once VS 2013 is no longer supported.
// Not referring to mime_types to avoid static initialization order fiasco.
/// <summary>
/// Determines whether or not the given content type is 'textual' according the feature specifications.
/// </summary>
// Remove once VS 2013 is no longer supported.
// Not referring to mime_types to avoid static initialization order fiasco.
/// <summary>
/// Determines whether or not the given content type is JSON according the feature specifications.
/// </summary>
/// <summary>
/// Gets the default charset for given content type. If the MIME type is not textual or recognized Latin1 will be
/// returned.
/// </summary>
// We are defaulting everything to Latin1 except JSON which is utf-8.
/// <summary>
/// Parses the given Content-Type header value to get out actual content type and charset.
/// If the charset isn't specified the default charset for the content type will be set.
/// </summary>
// No charset specified.
// Split into content type and second part which could be charset.
// No charset specified.
// Split and make sure 'charset'
// Remove the redundant ';' at the end of charset.
// If no Content-Type or empty body then just return an empty string.
// Perform the correct character set conversion if one is necessary.
// There is no risk of blocking.
// Latin1
// There is no risk of blocking.
// utf-16
// There is no risk of blocking.
// utf-16le
// There is no risk of blocking.
// utf-16be
// There is no risk of blocking.
// Perform the correct character set conversion if one is necessary.
// There is no risk of blocking.
// utf-8, ascii
// There is no risk of blocking.
// Latin1
// There is no risk of blocking.
// utf-16
// There is no risk of blocking.
// utf-16be
// There is no risk of blocking.
// Perform the correct character set conversion if one is necessary.
// There is no risk of blocking.
// Latin1
// There is no risk of blocking.
// Could optimize for linux in the future if a latin1_to_utf8 function was written.
// utf-8.
// There is no risk of blocking.
// utf-16.
// There is no risk of blocking.
// utf-16le
// There is no risk of blocking.
// utf-16be
// There is no risk of blocking.
// Latin1
// There is no risk of blocking.
// On Linux could optimize in the future if a latin1_to_utf8 function is written.
// utf-8, usascii and ascii
// There is no risk of blocking.
// utf-16.
// There is no risk of blocking.
// utf-16le
// There is no risk of blocking.
// utf-16be
// There is no risk of blocking.
// There is no risk of blocking.
// Helper function to convert message body without extracting.
// The instream is not yet set
// Content-Type must have textual type.
// Latin1
// utf-8.
// utf-16.
// utf-16le
// utf-16be
//
// Helper function to generate a wstring from given http_headers and message body.
//
// This is necessary for Linux because of a bug in GCC 4.7
// namespace http
// namespace web
/***
//github.com/Microsoft/cpprestsdk
// Helper function to check URI components.
// Some things like proper URI schema are verified by the URI class.
// We only need to check certain things specific to HTTP.
// HTTP Server API includes SSL support
// Do nothing if the open operation was already attempted
// Not thread safe
// If failed to open need to mark as closed.
// Do nothing if the close operation was already attempted
// Not thread safe.
// Note: Return the previous close task
// Specific method handler takes priority over general.
// Method is not supported.
// Send back a list of supported methods to the client.
// namespace listener
// namespace experimental
// namespace http
// namespace web
/***
// Actual initiates sending the response.
// If the user didn't explicitly set a reason phrase then we should have it default
// if they used one of the standard known status codes.
// Add a task-based continuation so no exceptions thrown from the task go 'unobserved'.
// There's no server context. The message may be replied to locally, as in a HTTP client
// pipeline stage. There's no sending required, so we can simply consider the reply
// done and return an already filled-in task.
// success
// already handled
// namespace http
// namespace web
/***
// we assume that the lock has been taken here.
// the server API was not initialized, register a default
// start the server if necessary
// register listener
// Registration failed, need to decrement registration count.
// ignore this exception since we want to report the original one
// unregister listener
// stop server if necessary
// save the original exception from unregister listener
// rethrow exception if one occurred
// namespace details
// namespace experimental
// namespace http
// namespace web
/***
//github.com/Microsoft/cpprestsdk
// namespace
// namespace
/// This class replaces the regex "\r\n\r\n|[\x00-\x1F]|[\x80-\xFF]"
// It was added due to issues with regex on Android, however since
// regex was rather overkill for such a simple parse it makes sense
// to use it on all *nix platforms.
//
// This is used as part of the async_read_until call below; see the
// following for more details:
// http://www.boost.org/doc/libs/1_55_0/doc/html/boost_asio/reference/async_read_until/overload4.html
// ".\r\n\r\n$"
// "\r.\n\r\n$"
// "  .\r\n\r\n$"
// "\r\n.\r\n$"
// "    .\r\n\r\n$"
// "\r\n\r.\n$"
// "    \r.\n\r\n$"
// "      .\r\n\r\n$"
// This function implements the searcher which "consumes" a certain amount of the input
// and returns whether or not there was a match (see above).
// From the Boost documentation:
// "The first member of the return value is an iterator marking one-past-the-end of the
//  bytes that have been consumed by the match function. This iterator is used to
//  calculate the begin parameter for any subsequent invocation of the match condition.
//  The second member of the return value is true if a match has been found, false
//  otherwise."
// In the case that we end inside a partially parsed match (like abcd\r\n\r),
// we need to signal the matcher to give us the partial match back again (\r\n\r).
// We use the excluded variable to keep track of this sequence point (abcd.\r\n\r
// in the previous example).
// In the case of State::cr or State::crlfcr, setting the state here
// "skips" a none state and therefore fails to move up the excluded
// counter.
// These structures serve as proof witnesses
// track how many threads are still referring to this
// before sending response, the full incoming message need to be processed.
// before sending response, the full incoming message need to be processed.
// namespace
// namespace asio
// namespace boost
// resolve the endpoint address
// #446: boost resolver does not recognize "+" as a host wildchar
// clear the buffer
// Listener closed
// Handle successful accept
// at this point an asynchronous task has been launched which will call
// m_connections.erase(conn.get()) eventually
// the following cannot throw
// boost ssl apis throw boost::system::system_error.
// Exception indicates something went wrong setting ssl context.
// Drop connection and continue handling other connections.
// spin off another async accept
// client closed connection
// peer has performed an orderly shutdown
// this can be removed. ECONNABORTED happens only for accept()
// connection reset by peer
// connection timed out
// read http status line
// Check to see if there is not allowed character on the input
// Make sure path and version is long enough to contain the HTTP version
// Get the path - remove the version portion and prefix space
// may be std::range_error indicating invalid Unicode, or web::uri_exception
// Get the version
// if HTTP version is 1.0 then disable pipelining
// Get the remote IP address
// also exclude '\r'
// check if the client has requested we close the connection
// need to read the sent data
// read body
// there is more to read
// have read request body
// The condition is such that after completing the async_read below, m_request_buf will contain at least `size`
// bytes.
// locate the listener:
// may be web::uri_exception, or std::range_error indicating invalid Unicode
// Look up the lock for the http_listener.
// It is possible the listener could have unregistered.
// We need to acquire the listener's lock before releasing the registered listeners lock.
// But we don't need to hold the registered listeners lock when calling into the user's code.
// clear the buffer
// check if the responder has requested we close the connection
// always terminate the connection since error happens
// kill the connection
// internal_erase_connection has been called above.
// halt existing connections
// ensure the end slash is present
// Future improvement - really this API should entirely be asynchronously.
// the hostport_listener::start() method should be made to return a task
// throwing the exception.
// First remove the listener from hostport listener
// Second remove the listener form listener collection
// Then take the listener write lock to make sure there are no calls into the listener's
// request handler.
// namespace
// namespace details
// namespace experimental
// namespace http
// namespace web
/***
//github.com/Microsoft/cpprestsdk
/// <summary>
/// String values for all HTTP Server API HTTP_REQUEST_HEADERS known headers.
/// NOTE: the order here is important it is from the _HTTP_HEADER_ID enum.
/// </summary>
//
// This is weird for the 'KnownHeaders' but there is no way I can find with the HTTP Server API
// to get all the raw headers. The known ones are stored in an array index by a HTTP Server API
// enumeration.
//
// TFS 354587 As a perf optimization we could parse the headers from Windows on demand in the
//      http_header class itself.
// header value can be empty
// Create a url group for this listener.
// Add listener's URI to the new group.
// Windows HTTP Server API has issues when the port isn't set to 80 here -- it expects a url prefix string
// which always includes the port number
// http://msdn.microsoft.com/en-us/library/windows/desktop/aa364698(v=vs.85).aspx
// Windows HTTP Server API will not accept a uri with an empty path, it must have a '/'.
// Windows HTTP Server API will only accept decoded uri strings.
// inside here we check for a few specific error types that know about
// there may be more possibilities for windows to return a different error
// Set timeouts.
// Add listener registration.
// Associate Url group with request queue.
// First remove listener registration.
// Then take the listener write lock to make sure there are no calls into the listener's
// request handler.
// Next close Url group, no need to remove individual Urls.
// Initialize data.
// Open server session.
// Create request queue.
// Create and start ThreadPool I/O so we can process asynchronous I/O.
// Start request receiving task.
// Shutdown request queue.
// Wait for all requests to be finished processing.
// Release resources.
// Oversubscribe since this is a blocking call and we don't want to count
// towards the concurrency runtime's thread count. A more proper fix
// would be to use Overlapped I/O and asynchronously call HttpReceiveHttpRequest.
// This requires additional work to be careful synchronizing with the listener
// shutdown. This is much easier especially given the http_listener is 'experimental'
// and with VS2015 PPL tasks run on the threadpool.
// Start processing the request
// Unfortunately have to work around a ppl task_completion_event bug that can cause AVs.
// Bug is that task_completion_event accesses internal state after setting.
// Workaround is to use a lock incurring additional synchronization, if can acquire
// the lock then setting of the event has completed.
// Add a task-based continuation so no exceptions thrown from the task go 'unobserved'.
// Save the http_request as the member of windows_request_context for the callback use.
// The read_headers_io_completion callback function.
/// <summary>
///  The read request headers completion callback function.
/// </summary>
// HTTP_REQUEST::pRawUrl contains the raw URI that came across the wire.
// Use this instead since the CookedUrl is a mess of the URI components
// some encoded and some not.
// If an exception occurred, finish processing the request below but
// respond with BadRequest instead of dispatching to the user's
// request handlers.
// See if we need to compress or decompress the incoming request body, and if so, prepare for it
// Something is wrong with the header; we'll fail here
// We could not find a decompressor; we'll see if the user's handler adds one later
// Something is wrong with the header; we'll fail here
// We could not find a decompressor; we'll see if the user's handler adds one later
// Note that init_response_headers throws away m_msg, so we need to set our compressor here.  If
// the header contains all unsupported algorithms, it's not an error -- we just won't compress
// This would require pre-compression of the input stream, since we MUST send Content-Length, so we'll
// (legally) ignore it
// m_compressor = http::compression::details::get_compressor_from_header(header,
// http::compression::details::header_types:accept_encoding);
// Respond with a reasonable message
// Retrieve the remote IP address
// Start reading in body from the network.
// Dispatch request to the http_listener.
// Even though we have a bad request, we should wait for the body otherwise we risk racing over m_overlapped
// The read_body_io_completion callback function
// Once we allow users to set the output stream the following assert could fail.
// At that time we would need compensation code that would allocate a buffer from the heap instead.
// There was no more data to read.
/// <summary>
///  The read request body completion callback function.
/// </summary>
// Save http_request copy to dispatch to user's handler in case content_ready() completes before.
// Look up the lock for the http_listener.
// It is possible the listener could have unregistered.
// We need to acquire the listener's lock before releasing the registered listeners lock.
// But we don't need to hold the registered listeners lock when calling into the user's code.
// Use a proxy event so we're not causing a circular reference between the http_request and the response task
// If an exception occurred while processing the body then there is no reason
// to even try sending the response, just re-surface the same exception.
// Copy the request reference in case it's the last
// At this point the user entirely controls the lifetime of the http_request.
// Don't let an exception from sending the response bring down the server.
// This means the user didn't respond to the request, allowing the
// http_request instance to be destroyed. There is nothing to do then
// so don't send a response.
// Avoid unobserved exception handler
// Should never get here, if we do there's a chance that a circular reference will cause leaks,
// or worse, undefined behaviour as we don't know who owns 'this' anymore
// After response is sent, break circular reference between http_response and the request context.
// Otherwise http_listener::close() can hang.
// Wait until the content download finished before replying because m_overlapped is reused,
// and we don't want to delete 'this' if the body is still downloading
// Fake a body completion so the content_ready() task doesn't keep the http_request alive forever
// Content-Length should not be sent with Transfer-Encoding
// Temporarily move the compressor to the response, so _get_content_length() will honor it
// else one was already set from a callback, and we'll (blindly) use it
// No matching decompressor was supplied via callback
// Send response callback function
// Figure out how to send the entity body of the message.
// There's no data. This is easy!
// OK, so we need to chunk it up.
// Attempt to figure out the remaining length of the input stream
/// <summary>
///  The send response headers completion callback function.
/// </summary>
// Transmit the response body to the network
// We are done sending data.
// In both cases here we could perform optimizations to try and use acquire on the streams to avoid an extra copy.
// If an exception occurs surface the error to user on the server side
// and cancel the request so the client sees the error.
// Check whether this is the last one to send...
// We're transfer-encoding...
// ...and compressing.  For simplicity, we allocate a buffer that's "too large to fail" while compressing.
// We'll read into a temporary buffer before compressing
// If an exception occurs surface the error to user on the server side
// and cancel the request so the client sees the error.
// Compress this chunk; if we read no data, allow the compressor to finalize its stream
// We chose our parameters so that compression should
// never overflow body_data_length; fail if it does
// Check whether this is the last one to send; note that this is a
// few lines of near-duplicate code with the non-compression path
// If an exception occurs surface the error to user on the server side
// and cancel the request so the client sees the error.
// Check whether this is the last one to send...
// Send the body through HTTP.sys
// Send response.
// Send response body callback function
/// <summary>
///  The send response body completion callback function.
/// </summary>
/// <summary>
///  The cancel request completion callback function.
/// </summary>
// Cancel request callback function.
// namespace details
// namespace experimental
// namespace http
// namespace web
/***
//github.com/Microsoft/cpprestsdk
// namespace details
//
// Start of platform-dependent _hmac_sha1() block...
//
// Windows desktop
// Code analysis complains even though there is no bug.
// Windows RT
// Linux, Mac OS X
//
// ...End of platform-dependent _hmac_sha1() block.
//
// Notes:
// - Doesn't support URIs without scheme or host.
// - If URI port is unspecified.
//");
// While map sorts items by keys it doesn't take value into account.
// We need to sort the query parameters separately.
// Push oauth1 parameters.
// Sort parameters and build the string.
// http://oauth.net/core/1.0a/#signing_process
// 9.1.1.  Normalize Request Parameters
// The request parameters are collected, sorted and concatenated into a normalized string:
//	- Parameters in the OAuth HTTP Authorization header excluding the realm parameter.
//	- Parameters in the HTTP POST request body (with a content-type of application/x-www-form-urlencoded).
//	- HTTP GET parameters added to the URLs in the query part (as defined by [RFC3986] section 3).
// Note: this should be improved to not block and handle any potential exceptions.
// Should never happen.
// configure proxy
// Here the token can be either temporary or access token.
// The authorization is complete if it is access token.
// Remove once VS 2013 is no longer supported.
// Return the token object only if authorization has been completed.
// Otherwise the token object holds a temporary token which should not be
// returned to the user.
// namespace experimental
// namespace oauth1
// namespace http
// namespace web
// _WIN32_WINNT >= _WIN32_WINNT_VISTA
/***
//github.com/Microsoft/cpprestsdk
// Expose base64 conversion for arbitrary buffer.
// namespace details
// NOTE: The redirected URI contains access token only in the implicit grant.
// The implicit grant never passes a refresh token.
// Build HTTP Basic authorization header.
// Add credentials to query as-is.
// configure proxy
// Some services don't return 'token_type' while it's required by OAuth 2.0 spec:
// http://tools.ietf.org/html/rfc6749#section-5.1
// As workaround we act as if 'token_type=bearer' was received.
// Do nothing. Preserves the old refresh token.
// Handle the case of a number as a JSON "string".
// Using streams because std::stoll isn't avaliable on Android.
// The authorization server may return different scope from the one requested.
// This however doesn't necessarily mean the token authorization scope is different.
// See: http://tools.ietf.org/html/rfc6749#section-3.3
// Use the requested scope() if no scope parameter was returned.
// namespace experimental
// namespace oauth2
// namespace http
// namespace web
/***
//github.com/Microsoft/cpprestsdk
// at() overloads
// Remove once VS 2013 is no longer supported.
/***
//github.com/Microsoft/cpprestsdk
// allow expressions like while(true) pass
//
// JSON Parsing
//
// The DEBUG macro is defined in XCode but we don't in our CMakeList
// so for now we will keep the same on debug and release. In the future
// this can be increase on release if necessary.
// Replace with template alias once VS 2012 support is removed.
//
// Consume whitespace characters and return the first non-space character or EOF
//
// Returns false only on overflow
// This namespace hides the x-plat helper functions
// namespace
// Safe to cast because the check after this if/else statement will cover EOF.
// Check for two (or more) zeros at the beginning
// Parse the number assuming its integer
// It is negative and cannot be represented in int64, so we resort to double
// It is negative, but fits into int64
// It is positive so we use unsigned int64
// Magic number 5 leaves room for decimal point, null terminator, etc (in most cases)
// Resize to cut off the null terminator
// Digit encountered?
// Decimal dot?
// Check that the following char is a digit
// Exponent?
// Check for the exponent sign
// First number of the exponent
// The rest of the exponent
// The peeked character is not a number, so we can break from the loop and construct the number
// Not expected number character?
// We already found a '/' character as the first of a token -- what kind of comment is it?
// Line comment -- look for a newline or EOF to terminate.
// Block comment -- look for a terminating "*/" sequence.
// Consume the character
// This function is specialized for the string parser, since we can be slightly more
// efficient in copying data from the input to the token: do a memcpy() rather than
// one character at a time.
// Line comment -- look for a newline or EOF to terminate.
// Block comment -- look for a terminating "*/" sequence.
// Consume the character
// A four-hexdigit Unicode character.
// Transform into a 16 bit code point.
// Add the input char to the decoded number
// This function converts unescaped character pairs (e.g. "\t") into their ASCII or Unicode representations (e.g.
// tab sign) Also it handles \u + 4 hexadecimal digits
// handle multi-block characters that start with a high-surrogate
// skip escape character '\u'
// Construct the character based on the decoded number
// This function is specialized for the string parser, since we can be slightly more
// efficient in copying data from the input to the token: do a memcpy() rather than
// one character at a time.
// Reset start position and continue.
// For now, we're ignoring comments.
// State 1: New field or end of object, looking for field name or closing brace
// State 2: Looking for a colon.
// State 3: Looking for an expression.
// State 4: Looking for a comma or a closing brace
// State 1: Looking for an expression.
// State 4: Looking for a comma or a closing bracket
// Returning a null value whether or not an error occurred.
// namespace details
// namespace json
// namespace web
/***
//github.com/Microsoft/cpprestsdk
//
// JSON Serialization
//
// This has better performance than writing directly to stream.
// This has better performance than writing directly to stream.
// If a control character then must unicode escaped.
// #digits + 1 to avoid loss + 1 for the sign + 1 for null terminator.
// This can be improved performance-wise if we implement our own routine
// #digits + 2 to avoid loss + 1 for the sign + 1 for decimal point + 5 for exponent (e+xxx) + 1 for null
// terminator
// #digits + 1 to avoid loss + 1 for the sign + 1 for null terminator.
// #digits + 2 to avoid loss + 1 for the sign + 1 for decimal point + 5 for exponent (e+xxx) + 1 for null
// terminator
/***
//github.com/Microsoft/cpprestsdk
// stdafx.cpp :
// Include the standard header and generate the precompiled header.
/***
//github.com/Microsoft/cpprestsdk
/// <summary>
/// Spin lock to allow for locks to be used in global scope
/// </summary>
// namespace details
// This is the 99.9% case.
// unlock
// This case means the global m_scheduler is not available.
// We spin off an individual scheduler instead.
// namespace pplx
/***
// DEVNOTE:
// The use of mutexes is suboptimal for synchronization of task execution.
// Given that scheduler implementations should use GCD queues, there are potentially better mechanisms available to
// coordinate tasks (such as dispatch groups).
// namespace platform
// namespace details
// namespace pplx
/***
//github.com/Microsoft/cpprestsdk
// namespace platform
// namespace details
// namespace pplx
/***
//github.com/Microsoft/cpprestsdk
// Disable false alarm code analysis warning
// RtlCaptureSTackBackTrace is not available in MSDK, so we only call it under Desktop or _DEBUG MSDK.
//  For MSDK unsupported version, we will return zero frame number.
// !__cplusplus_winrt
// defined(__cplusplus_winrt)
// InitializeCriticalSection can cause STATUS_NO_MEMORY see C28125
// ^^^ __cplusplus_winrt ^^^ // vvv !__cplusplus_winrt vvv
// __cplusplus_winrt
// namespace platform
//
// Event implementation
//
// !__cplusplus_winrt
//
// critical_section implementation
//
// TFS# 612702 -- this implementation is unnecessarily recursive. See bug for details.
//
// reader_writer_lock implementation
//
// _WIN32_WINNT >= _WIN32_WINNT_VISTA
//
// scheduler implementation
//
// ^^^ __cplusplus_winrt ^^^ // vvv !__cplusplus_winrt vvv
// ^^^ _WIN32_WINNT < _WIN32_WINNT_VISTA ^^^ // vvv _WIN32_WINNT >= _WIN32_WINNT_VISTA vvv
// _WIN32_WINNT < _WIN32_WINNT_VISTA
// __cplusplus_winrt
// namespace details
// namespace pplx
// ^^^ !defined(_WIN32) || CPPREST_FORCE_PPLX ^^^ // vvv defined(_WIN32) && !CPPREST_FORCE_PPLX vvv
// putting this in a temporary reference variable to workaround
// VS2013 compiler bugs
// namespace Concurrency
/***
// This pointer will be 0-initialized by default (at load time).
//github.com/Microsoft/cpprestsdk/wiki/How-to-build-for-Android");
// __ANDROID__
// __ANDROID__
// Calling get_jvm_env() here forces the thread to be attached.
// __ANDROID__
// __ANDROID__
// ^^^ VS2013 ^^^ // vvv everything else vvv
// defined(_MSC_VER) && _MSC_VER < 1900
// if linked into a DLL, the threadpool shared instance will be
// destroyed at DLL_PROCESS_DETACH, at which stage joining threads
// causes deadlock, hence this dance
// ^^^ _WIN32 ^^^ // vvv !_WIN32 vvv //
// ^^^ VS2013 ^^^ // vvv everything else vvv
// defined(_MSC_VER) && _MSC_VER < 1900
// unnamed namespace
// __ANDROID__
// ^^^ VS2013 ^^^ // vvv everything else vvv
// defined(_MSC_VER) && _MSC_VER < 1900
// namespace
// defined(__ANDROID__)
// namespace crossplat
// defined(__ANDROID__)
//  !defined(CPPREST_EXCLUDE_WEBSOCKETS) || !defined(_WIN32)
/***
//github.com/Microsoft/cpprestsdk
/***
/// <summary>
/// The public parts of the file information record contain only what is implementation-
/// independent. The actual allocated record is larger and has details that the implementation
/// require in order to function.
/// </summary>
/// <summary>
/// The file handle of the file
/// </summary>
/// <summary>
/// A list of callback waiting to be signaled that there are no outstanding writes.
/// </summary>
// namespace details
// namespace streams
// namespace Concurrency
/// <summary>
/// Perform post-CreateFile processing.
/// </summary>
/// <param name="fh">The Win32 file handle</param>
/// <param name="callback">The callback interface pointer</param>
/// <param name="mode">The C++ file open mode</param>
/// <returns>The error code if there was an error in file creation.</returns>
/* prot */)
// Buffer reads internally if and only if we're just reading (not also writing) and
// if the file is opened exclusively. If either is false, we're better off just
// letting the OS do its buffering, even if it means that prompt reads won't
// happen.
// seek to end if requested
// Start at the end of the file.
/// <summary>
/// Open a file and create a streambuf instance to represent it.
/// </summary>
/// <param name="callback">A pointer to the callback interface to invoke when the file has been opened.</param>
/// <param name="filename">The name of the file to open</param>
/// <param name="mode">A creation mode for the stream buffer</param>
/// <param name="prot">A file protection mode to use for the file stream</param>
/// <returns>True if the opening operation could be initiated, false otherwise.</returns>
/// <remarks>
/// True does not signal that the file will eventually be successfully opened, just that the process was started.
/// </remarks>
/// <summary>
/// Close a file stream buffer.
/// </summary>
/// <param name="info">The file info record of the file</param>
/// <param name="callback">A pointer to the callback interface to invoke when the file has been opened.</param>
/// <returns>True if the closing operation could be initiated, false otherwise.</returns>
/// <remarks>
/// True does not signal that the file will eventually be successfully closed, just that the process was started.
/// </remarks>
// Since closing a file may involve waiting for outstanding writes which can take some time
// if the file is on a network share, the close action is done in a separate task, as
// CloseHandle doesn't have I/O completion events.
/// <summary>
/// Initiate an asynchronous (overlapped) write to the file stream.
/// </summary>
/// <param name="info">The file info record of the file</param>
/// <param name="callback">A pointer to the callback interface to invoke when the write request is completed.</param>
/// <param name="ptr">A pointer to the data to write</param>
/// <param name="count">The size (in bytes) of the data</param>
/// <returns>0 if the write request is still outstanding, -1 if the request failed, otherwise the size of the data
/// written</returns>
// Decrement the counter of outstanding write events.
// If this was the last one, signal all objects waiting for it to complete.
/// <summary>
/// Initiate an asynchronous (overlapped) read from the file stream.
/// </summary>
/// <param name="info">The file info record of the file</param>
/// <param name="callback">A pointer to the callback interface to invoke when the write request is completed.</param>
/// <param name="ptr">A pointer to a buffer where the data should be placed</param>
/// <param name="count">The size (in bytes) of the buffer</param>
/// <param name="offset">The offset in the file to read from</param>
/// <returns>0 if the read request is still outstanding, -1 if the request failed, otherwise the size of the data read
/// into the buffer</returns>
// First, we need to understand how far into the buffer we have already read
// and how much remains.
// Then, we allocate a new buffer.
// Then, we copy the unread part to the new buffer and delete the old buffer
// Then, we read the remainder of the count into the new buffer
/// <summary>
/// Read data from a file stream into a buffer
/// </summary>
/// <param name="info">The file info record of the file</param>
/// <param name="callback">A pointer to the callback interface to invoke when the write request is completed.</param>
/// <param name="ptr">A pointer to a buffer where the data should be placed</param>
/// <param name="count">The size (in bytes) of the buffer</param>
/// <returns>0 if the read request is still outstanding, -1 if the request failed, otherwise the size of the data read
/// into the buffer</returns>
/// <summary>
/// Write data from a buffer into the file stream.
/// </summary>
/// <param name="info">The file info record of the file</param>
/// <param name="callback">A pointer to the callback interface to invoke when the write request is completed.</param>
/// <param name="ptr">A pointer to a buffer where the data should be placed</param>
/// <param name="count">The size (in bytes) of the buffer</param>
/// <returns>0 if the read request is still outstanding, -1 if the request failed, otherwise the size of the data read
/// into the buffer</returns>
// To preserve the async write order, we have to move the write head before read.
/// <summary>
/// Flush all buffered data to the underlying file.
/// </summary>
/// <param name="info">The file info record of the file</param>
/// <param name="callback">A pointer to the callback interface to invoke when the write request is completed.</param>
/// <returns>True if the request was initiated</returns>
/// <summary>
/// Adjust the internal buffers and pointers when the application seeks to a new read location in the stream.
/// </summary>
/// <param name="info">The file info record of the file</param>
/// <param name="pos">The new position (offset from the start) in the file stream</param>
/// <returns>New file position or -1 if error</returns>
/// <summary>
/// Adjust the internal buffers and pointers when the application seeks to a new read location in the stream.
/// </summary>
/// <param name="info">The file info record of the file</param>
/// <param name="pos">The new position (offset from the start) in the file stream</param>
/// <returns>New file position or -1 if error</returns>
/// <summary>
/// Adjust the internal buffers and pointers when the application seeks to a new write location in the stream.
/// </summary>
/// <param name="info">The file info record of the file</param>
/// <param name="pos">The new position (offset from the start) in the file stream</param>
/// <returns>New file position or -1 if error</returns>
/***
//github.com/Microsoft/cpprestsdk
/***
/// <summary>
/// The public parts of the file information record contain only what is implementation-
/// independent. The actual allocated record is larger and has details that the implementation
/// require in order to function.
/// </summary>
/// <summary>
/// The Win32 file handle of the file
/// </summary>
/// <summary>
/// A Win32 I/O context, used by the thread pool to scheduler work.
/// </summary>
// namespace details
// namespace streams
// namespace Concurrency
/// <summary>
/// Our extended OVERLAPPED record.
/// </summary>
/// <remarks>
/// The standard OVERLAPPED structure doesn't have any fields for application-specific
/// data, so we must extend it.
/// </remarks>
////If dwErrorCode is 0xc0000011, it means STATUS_END_OF_FILE.
////Map this error code to system error code:ERROR_HANDLE_EOF
/// <summary>
/// Translate from C++ STL file open modes to Win32 flags.
/// </summary>
/// <param name="mode">The C++ file open mode</param>
/// <param name="prot">The C++ file open protection</param>
/// <param name="dwDesiredAccess">A pointer to a DWORD that will hold the desired access flags</param>
/// <param name="dwCreationDisposition">A pointer to a DWORD that will hold the creation disposition</param>
/// <param name="dwShareMode">A pointer to a DWORD that will hold the share mode</param>
// C++ specifies what permissions to deny, Windows which permissions to give,
/// <summary>
/// Perform post-CreateFile processing.
/// </summary>
/// <param name="fh">The Win32 file handle</param>
/// <param name="callback">The callback interface pointer</param>
/// <param name="mode">The C++ file open mode</param>
// Buffer reads internally if and only if we're just reading (not also writing) and
// if the file is opened exclusively. If either is false, we're better off just
// letting the OS do its buffering, even if it means that prompt reads won't
// happen.
// Start at the end of the file.
/// <summary>
/// Open a file and create a streambuf instance to represent it.
/// </summary>
/// <param name="callback">A pointer to the callback interface to invoke when the file has been opened.</param>
/// <param name="filename">The name of the file to open</param>
/// <param name="mode">A creation mode for the stream buffer</param>
/// <param name="prot">A file protection mode to use for the file stream</param>
/// <returns><c>true</c> if the opening operation could be initiated, <c>false</c> otherwise.</returns>
/// <remarks>
/// True does not signal that the file will eventually be successfully opened, just that the process was started.
/// </remarks>
/// <summary>
/// Close a file stream buffer.
/// </summary>
/// <param name="info">The file info record of the file</param>
/// <param name="callback">A pointer to the callback interface to invoke when the file has been opened.</param>
/// <returns><c>true</c> if the closing operation could be initiated, <c>false</c> otherwise.</returns>
/// <remarks>
/// True does not signal that the file will eventually be successfully closed, just that the process was started.
/// </remarks>
// Since closing a file may involve waiting for outstanding writes which can take some time
// if the file is on a network share, the close action is done in a separate task, as
// CloseHandle doesn't have I/O completion events.
// _WIN32_WINNT >= _WIN32_WINNT_VISTA
/// <summary>
/// The completion routine used when a write request finishes.
/// </summary>
/// <remarks>
/// The signature is the standard IO completion signature, documented on MSDN
/// </remarks>
/// <summary>
/// The completion routine used when a read request finishes.
/// </summary>
/// <remarks>
/// The signature is the standard IO completion signature, documented on MSDN
/// </remarks>
/// <summary>
/// Initiate an asynchronous (overlapped) write to the file stream.
/// </summary>
/// <param name="info">The file info record of the file</param>
/// <param name="callback">A pointer to the callback interface to invoke when the write request is completed.</param>
/// <param name="ptr">A pointer to the data to write</param>
/// <param name="count">The size (in bytes) of the data</param>
/// <returns>0 if the write request is still outstanding, -1 if the request failed, otherwise the size of the data
/// written</returns>
// WriteFile will return false when a) the operation failed, or b) when the request is still
// pending. The error code will tell us which is which.
// Overlapped is deleted in the threadpool callback.
// If WriteFile returned true, it must be because the operation completed immediately.
// However, we didn't pass in an  address for the number of bytes written, so
// we have to retrieve it using 'GetOverlappedResult,' which may, in turn, fail.
// 1. If WriteFile returned true, it must be because the operation completed immediately.
// The xp threadpool immediately creates a workerthread to run "_WriteFileCompletionRoutine".
// If this function return value > 0, the condition "if (written == sizeof(_CharType))" in the filestreams.h
// "_getcImpl()" function will be satisfied. The main thread will delete the input "callback", while the threadpool
// workerthread is accessing this "callback"; there will be a race condition and AV error. We directly return 0 and
// leave all the completion callbacks working on the workerthread. We do not need to call GetOverlappedResult, the
// workerthread will call the "on_error()" if the WriteFaile failed. "req" is deleted in
// "_WriteFileCompletionRoutine, "pOverlapped" is deleted in io_scheduler::FileIOCompletionRoutine.
// 2. If WriteFile returned false and GetLastError is ERROR_IO_PENDING, return 0,
//    The xp threadpool will create a workerthread to run "_WriteFileCompletionRoutine" after the operation
//    completed.
// Overlapped is deleted in the threadpool callback.
// 3. If ReadFile returned false and GetLastError is not ERROR_IO_PENDING, we must call "callback->on_error()".
//    The threadpools will not start the workerthread.
// _WIN32_WINNT >= _WIN32_WINNT_VISTA
/// <summary>
/// Initiate an asynchronous (overlapped) read from the file stream.
/// </summary>
/// <param name="info">The file info record of the file</param>
/// <param name="callback">A pointer to the callback interface to invoke when the write request is completed.</param>
/// <param name="ptr">A pointer to a buffer where the data should be placed</param>
/// <param name="count">The size (in bytes) of the buffer</param>
/// <param name="offset">The offset in the file to read from</param>
/// <returns>0 if the read request is still outstanding, -1 if the request failed, otherwise the size of the data read
/// into the buffer</returns>
// ReadFile will return false when a) the operation failed, or b) when the request is still
// pending. The error code will tell us which is which.
// Overlapped is deleted in the threadpool callback.
// We find ourselves here because there was a synchronous completion, either with an error or
// success. Either way, we don't need the thread pool I/O request here, or the request and
// overlapped structures.
// If ReadFile returned true, it must be because the operation completed immediately.
// However, we didn't pass in an address for the number of bytes written, so
// we have to retrieve it using 'GetOverlappedResult,' which may, in turn, fail.
// 1. If ReadFile returned true, it must be because the operation completed immediately.
// The xp threadpool immediately creates a workerthread to run "_WriteFileCompletionRoutine".
// If this function return value > 0, the condition "if ( ch == sizeof(_CharType) )" in the filestreams.h
// "_getcImpl()" function will be satisfied. The main thread will delete the input "callback", while the threadpool
// workerthread is accessing this "callback"; there will be a race condition and AV error. We can directly return 0
// and leave all the completion callbacks working on the workerthread. We do not need to call GetOverlappedResult,
// the workerthread will call the "on_error()" if the ReadFile failed. "req" is deleted in
// "_ReadFileCompletionRoutine, "pOverlapped" is deleted in io_scheduler::FileIOCompletionRoutine.
// 2. If ReadFile returned false and GetLastError is ERROR_IO_PENDING, return 0.
//    The xp threadpool will create a workerthread to run "_WriteFileCompletionRoutine" after the operation
//    completed.
// Overlapped is deleted in the threadpool callback.
// 3. If ReadFile returned false and GetLastError is ERROR_HANDLE_EOF, we must call "callback->on_completed(0)".
//    The threadpool will not start the workerthread.
// 4. If ReadFile returned false and GetLastError is not a valid error code, we must call "callback->on_error()".
//    The threadpool will not start the workerthread.
// _WIN32_WINNT >= _WIN32_WINNT_VISTA
// pending
// error
// operation is complete. The pattern of returning synchronously
// has the expectation that we duplicate the callback code here...
// Do the expedient thing for now.
// return pending
// First, we need to understand how far into the buffer we have already read
// and how much remains.
// We have four different scenarios:
//  1. The read position is before the start of the buffer, in which case we will just reuse the buffer.
//  2. The read position is in the middle of the buffer, and we need to read some more.
//  3. The read position is beyond the end of the buffer. Do as in #1.
//  4. We have everything we need.
// Reuse the existing buffer.
// pending
// error
// operation is complete. The pattern of returning synchronously
// has the expectation that we duplicate the callback code here...
// Do the expedient thing for now.
// return pending
// Then, we allocate a new buffer.
// Then, we copy the unread part to the new buffer and delete the old buffer
// Then, we read the remainder of the count into the new buffer
// pending
// error
// operation is complete. The pattern of returning synchronously
// has the expectation that we duplicate the callback code here...
// Do the expedient thing for now.
// return pending
// If we are here, it means that we didn't need to read, we already have enough data in the buffer
/// <summary>
/// Read data from a file stream into a buffer
/// </summary>
/// <param name="info">The file info record of the file</param>
/// <param name="callback">A pointer to the callback interface to invoke when the write request is completed.</param>
/// <param name="ptr">A pointer to a buffer where the data should be placed</param>
/// <param name="count">The size (in characters) of the buffer</param>
/// <returns>0 if the read request is still outstanding, -1 if the request failed, otherwise the size of the data read
/// into the buffer</returns>
/// <summary>
/// Write data from a buffer into the file stream.
/// </summary>
/// <param name="info">The file info record of the file</param>
/// <param name="callback">A pointer to the callback interface to invoke when the write request is completed.</param>
/// <param name="ptr">A pointer to a buffer where the data should be placed</param>
/// <param name="count">The size (in characters) of the buffer</param>
/// <returns>0 if the read request is still outstanding, -1 if the request failed, otherwise the size of the data read
/// into the buffer</returns>
// To preserve the async write order, we have to move the write head before read.
/// <summary>
/// Flush all buffered data to the underlying file.
/// </summary>
/// <param name="info">The file info record of the file</param>
/// <param name="callback">A pointer to the callback interface to invoke when the write request is completed.</param>
/// <returns><c>true</c> if the request was initiated</returns>
// Writes are not cached
/// <summary>
/// Adjust the internal buffers and pointers when the application seeks to a new read location in the stream.
/// </summary>
/// <param name="info">The file info record of the file</param>
/// <param name="pos">The new position (offset from the start) in the file stream</param>
/// <returns>New file position or -1 if error</returns>
/// <summary>
/// Adjust the internal buffers and pointers when the application seeks to a new read location in the stream.
/// </summary>
/// <param name="info">The file info record of the file</param>
/// <param name="offset">The new position (offset from the end of the stream) in the file stream</param>
/// <param name="char_size">The size of the character type used for this stream</param>
/// <returns>New file position or -1 if error</returns>
// Clear the internal buffer.
/// <summary>
/// Adjust the internal buffers and pointers when the application seeks to a new write location in the stream.
/// </summary>
/// <param name="info">The file info record of the file</param>
/// <param name="pos">The new position (offset from the start) in the file stream</param>
/// <returns>New file position or -1 if error</returns>
/***
//github.com/Microsoft/cpprestsdk
/// <summary>
/// The public parts of the file information record contain only what is implementation-
/// independent. The actual allocated record is larger and has details that the implementation
/// require in order to function.
/// </summary>
// namespace details
// namespace streams
// namespace Concurrency
/// <summary>
/// Translate from C++ STL file open modes to Win32 flags.
/// </summary>
/// <param name="mode">The C++ file open mode</param>
/// <param name="prot">The C++ file open protection</param>
/// <param name="dwDesiredAccess">A pointer to a DWORD that will hold the desired access flags</param>
/// <param name="dwCreationDisposition">A pointer to a DWORD that will hold the creation disposition</param>
/// <param name="dwShareMode">A pointer to a DWORD that will hold the share mode</param>
/// <summary>
/// Perform post-CreateFile processing.
/// </summary>
/// <param name="fh">The Win32 file handle</param>
/// <param name="callback">The callback interface pointer</param>
/// <param name="mode">The C++ file open mode</param>
/// <returns>The error code if there was an error in file creation.</returns>
// Seek to end if it's in appending write mode
/// <summary>
/// Create a streambuf instance to represent a WinRT file.
/// </summary>
/// <param name="callback">A pointer to the callback interface to invoke when the file has been opened.</param>
/// <param name="file">The file object</param>
/// <param name="mode">A creation mode for the stream buffer</param>
/// <returns>True if the opening operation could be initiated, false otherwise.</returns>
/// <remarks>
/// True does not signal that the file will eventually be successfully opened, just that the process was started.
/// This is only available for WinRT.
/// </remarks>
// take a snapshot of current writer, since writer can be replaced during flush
// Flush operation will not begin until all previous writes (StoreAsync) finished, thus it could avoid race.
// Rethrow exception if no callback attached.
/// <summary>
/// Close a file stream buffer.
/// </summary>
/// <param name="info">The file info record of the file</param>
/// <param name="callback">A pointer to the callback interface to invoke when the file has been opened.</param>
/// <returns>True if the closing operation could be initiated, false otherwise.</returns>
/// <remarks>
/// True does not signal that the file will eventually be successfully closed, just that the process was started.
/// </remarks>
// The lock fInfo->m_lock must not be held at this point
// The lock fInfo->m_lock must not be held at this point
/// <summary>
/// Initiate an asynchronous (overlapped) read from the file stream.
/// </summary>
/// <param name="info">The file info record of the file</param>
/// <param name="callback">A pointer to the callback interface to invoke when the write request is completed.</param>
/// <param name="ptr">A pointer to a buffer where the data should be placed</param>
/// <param name="count">The size (in bytes) of the buffer</param>
/// <param name="offset">The offset in the file to read from</param>
/// <returns>0 if the read request is still outstanding, -1 if the request failed, otherwise the size of the data read
/// into the buffer</returns>
// I don't know of a better error code, so this will have to do.
// pending
// error
// operation is complete. The pattern of returning synchronously
// has the expectation that we duplicate the callback code here...
// Do the expedient thing for now.
// return pending
// First, we need to understand how far into the buffer we have already read
// and how much remains.
// We have four different scenarios:
//  1. The read position is before the start of the buffer, in which case we will just reuse the buffer.
//  2. The read position is in the middle of the buffer, and we need to read some more.
//  3. The read position is beyond the end of the buffer. Do as in #1.
//  4. We have everything we need.
// Reuse the existing buffer.
// pending
// error
// operation is complete. The pattern of returning synchronously
// has the expectation that we duplicate the callback code here...
// Do the expedient thing for now.
// return pending
// Then, we allocate a new buffer.
// Then, we copy the unread part to the new buffer and delete the old buffer
// Then, we read the remainder of the count into the new buffer
// pending
// error
// operation is complete. The pattern of returning synchronously
// has the expectation that we duplicate the callback code here...
// Do the expedient thing for now.
// return pending
// If we are here, it means that we didn't need to read, we already have enough data in the buffer
/// <summary>
/// Read data from a file stream into a buffer
/// </summary>
/// <param name="info">The file info record of the file</param>
/// <param name="callback">A pointer to the callback interface to invoke when the write request is completed.</param>
/// <param name="ptr">A pointer to a buffer where the data should be placed</param>
/// <param name="count">The size (in characters) of the buffer</param>
/// <returns>0 if the read request is still outstanding, -1 if the request failed, otherwise the size of the data read
/// into the buffer</returns>
/// <summary>
/// Write data from a buffer into the file stream.
/// </summary>
/// <param name="info">The file info record of the file</param>
/// <param name="callback">A pointer to the callback interface to invoke when the write request is completed.</param>
/// <param name="ptr">A pointer to a buffer where the data should be placed</param>
/// <param name="count">The size (in characters) of the buffer</param>
/// <returns>0 if the write request is still outstanding, -1 if the request failed, otherwise the size of the data read
/// into the buffer</returns>
// To preserve the async write order, we have to move the write head before read.
// In most of the time, we preserve the writer so that it would have better performance.
// However, after user call seek, we will dispose old writer. By doing so, users could
// write to new writer in new position while the old writer is still flushing data into stream.
// It keeps tracking the number of bytes written into m_writer buffer.
// ArrayReference here is for avoiding data copy.
// Flush data from m_writer buffer into stream , if the buffer is full
/// <summary>
/// Flush all buffered data to the underlying file.
/// </summary>
/// <param name="info">The file info record of the file</param>
/// <param name="callback">A pointer to the callback interface to invoke when the write request is completed.</param>
/// <returns>True if the request was initiated</returns>
/// <summary>
/// Adjust the internal buffers and pointers when the application seeks to a new read location in the stream.
/// </summary>
/// <param name="info">The file info record of the file</param>
/// <param name="pos">The new position (offset from the start) in the file stream</param>
/// <returns>New file position or -1 if error</returns>
/// <summary>
/// Adjust the internal buffers and pointers when the application seeks to a new read location in the stream.
/// </summary>
/// <param name="info">The file info record of the file</param>
/// <param name="offset">The new position (offset from the end of the stream) in the file stream</param>
/// <param name="char_size">The size of the character type used for this stream</param>
/// <returns>New file position or -1 if error</returns>
/// <summary>
/// Adjust the internal buffers and pointers when the application seeks to a new write location in the stream.
/// </summary>
/// <param name="info">The file info record of the file</param>
/// <param name="pos">The new position (offset from the start) in the file stream</param>
/// <returns>New file position or -1 if error</returns>
// m_buffill keeps number of chars written into the m_writer buffer.
// We need to flush it into stream before seek the write head of the stream
// Moving write head should follow the flush operation. is_done test is for perf optimization.
// Detach stream could avoid stream destruction after writer get destructed.
/// <summary>
/// This class acts as a bridge between WinRT input streams and Casablanca asynchronous streams.
/// </summary>
// Rather than using ComPtr, which is somewhat complex, a simple RAII class
// to make sure that Release() is called is useful here.
// namespace details
// namespace streams
// namespace Concurrency
/***
//github.com/Microsoft/cpprestsdk
/// <summary>
/// Unreserved characters are those that are allowed in a URI but do not have a reserved purpose. They include:
/// - A-Z
/// - a-z
/// - 0-9
/// - '-' (hyphen)
/// - '.' (period)
/// - '_' (underscore)
/// - '~' (tilde)
/// </summary>
/// <summary>
/// General delimiters serve as the delimiters between different uri components.
/// General delimiters include:
/// - All of these :/?#[]@
/// </summary>
/// <summary>
/// Subdelimiters are those characters that may have a defined meaning within component
/// of a uri for a particular scheme. They do not serve as delimiters in any case between
/// uri segments. sub_delimiters include:
/// - All of these !$&'()*+,;=
/// </summary>
/// <summary>
/// Reserved characters includes the general delimiters and sub delimiters. Some characters
/// are neither reserved nor unreserved, and must be percent-encoded.
/// </summary>
/// <summary>
/// Legal characters in the scheme portion include:
/// - Any alphanumeric character
/// - '+' (plus)
/// - '-' (hyphen)
/// - '.' (period)
///
/// Note that the scheme must BEGIN with an alpha character.
/// </summary>
/// <summary>
/// Legal characters in the user information portion include:
/// - Any unreserved character
/// - The percent character ('%'), and thus any percent-endcoded octet
/// - The sub-delimiters
/// - ':' (colon)
/// </summary>
/// <summary>
/// Legal characters in the authority portion include:
/// - Any unreserved character
/// - The percent character ('%'), and thus any percent-endcoded octet
/// - The sub-delimiters
/// - ':' (colon)
/// - IPv6 requires '[]' allowed for it to be valid URI and passed to underlying platform for IPv6 support
/// </summary>
/// <summary>
/// Legal characters in the path portion include:
/// - Any unreserved character
/// - The percent character ('%'), and thus any percent-endcoded octet
/// - The sub-delimiters
/// - ':' (colon)
/// - '@' (at sign)
/// </summary>
/// <summary>
/// Legal characters in the query portion include:
/// - Any path character
/// - '?' (question mark)
/// </summary>
/// <summary>
/// Legal characters in the fragment portion include:
/// - Any path character
/// - '?' (question mark)
/// </summary>
// this is intentional, they have the same set of legal characters
/// <summary>
/// Parses the uri, setting the given pointers to locations inside the given buffer.
/// 'encoded' is expected to point to an encoded zero-terminated string containing a uri
/// </summary>
// IMPORTANT -- A uri may either be an absolute uri, or an relative-reference
// Absolute: 'http://host.com'
// Relative-Reference: '//:host.com', '/path1/path2?query', './path1:path2'
// A Relative-Reference can be disambiguated by parsing for a ':' before the first slash
// found a colon, the first portion is a scheme
// the first character of a scheme must be a letter
// start parsing the scheme, it's always delimited by a colon (must be present)
// skip over the colon
// if we see two slashes next, then we're going to parse the authority portion
// later on we'll break up the authority into the port and host
// skip over the slashes
// the authority is delimited by a slash (resource), question-mark (query) or octothorpe (fragment)
// or by EOS. The authority could be empty ('file:///C:\file_name.txt')
// We're NOT currently supporting IPvFuture or username/password in authority
// IPv6 as the host (i.e. http://[:::::::]) is allowed as valid URI and passed to subsystem for support.
// now lets see if we have a port specified -- by working back from the end
// the port is made up of all digits
// has a port
// skip the colon
// no port
// look for a user_info component
// if we see a path character or a slash, then the
// if we see a slash, or any other legal path character, parse the path next
// the path is delimited by a question-mark (query) or octothorpe (fragment) or by EOS
// if we see a ?, then the query is next
// skip over the question mark
// the query is delimited by a '#' (fragment) or EOS
// if we see a #, then the fragment is next
// skip over the hash mark
// the fragment is delimited by EOS
// default path to begin with a slash for easy comparison
// Encodes all characters not in given set determined by given function.
// for utf8 encoded string, char ASCII can be greater than 127.
// ch should be same under both utf8 and utf16.
// ASCII don't need to be encoded, which should be same on both utf8 and utf16.
// 5.2.3. Merge Paths https://tools.ietf.org/html/rfc3986#section-5.2.3
// path contains and does not end with '/', we remove segment after last '/'
// 5.2.4. Remove Dot Segments https://tools.ietf.org/html/rfc3986#section-5.2.4
// namespace
// canonicalize components first
// convert scheme to lowercase
// convert host to lowercase
// canonicalize the path to have a leading slash if it's a full uri
//"));
// only add the leading slash when the host is present
// namespace details
// Encode '&', ';', and '=' since they are used
// as delimiters in query component.
/// </summary>
/// Encodes a string by converting all characters except for RFC 3986 unreserved characters to their
/// hexadecimal representation.
/// </summary>
// Note: we also encode the '+' character because some non-standard implementations
// encode the space character as a '+' instead of %20. To better interoperate we encode
// '+' to avoid any confusion and be mistaken as a space.
// No encoding of ASCII characters in host name (RFC 3986 3.2.2)
/// <summary>
/// Helper function to convert a hex character digit to a decimal character value.
/// Throws an exception if not a valid hex digit.
/// </summary>
// encoded string has to be ASCII.
// Split into key value pairs separated by '&'.
// Each individual URI component must be decoded before performing comparison.
// TFS # 375865
// scheme is canonicalized to lowercase
// host is canonicalized to lowercase
// resolving URI according to RFC3986, Section 5 https://tools.ietf.org/html/rfc3986#section-5
// starts with '/'
// starts with '//'
// otherwise relative to root
// relative url
// web::uri considers empty path as '/'
// namespace web
/***
//github.com/Microsoft/cpprestsdk
// Only one slash.
// Only one ampersand.
// The query key value pair was already encoded by us or the user separately.
// namespace web
/***
//github.com/Microsoft/cpprestsdk
// namespace
// namespace details
// Remove once VS 2013 is no longer supported.
// this handle DOES NOT need to be freed
// strip exceeding characters of the initial resize call
// First see if the STL implementation can handle the mapping for common cases.
// On Linux we are using boost error codes which have the exact same
// mapping and are equivalent with std::generic_category error codes.
// namespace details
// Create a dedicated type for characters to avoid the issue
// of different platforms defaulting char to be either signed
// or unsigned.
// use fast inner loop to skip single byte code points (which are
// expected to be the most frequent)
// start special handling for multi-byte code points
// 2 byte character, 0x80 to 0x7FF
// can't require surrogates for 7FF
// 3 byte character, 0x800 to 0xFFFF
// 4 byte character, 0x10000 to 0x10FFFF
// Save repeated heap allocations, use the length of resulting sequence.
// 4 byte character, 0x10000 to 0x10FFFF
// In UTF-16 U+10000 to U+10FFFF are represented as two 16-bit code units, surrogate pairs.
//  - 0x10000 is subtracted from the code point
//  - high surrogate is 0xD800 added to the top ten bits
//  - low surrogate is 0xDC00 added to the low ten bits
// In UTF-16 U+0000 to U+D7FF and U+E000 to U+FFFF are represented exactly as the Unicode code point
// value. U+D800 to U+DFFF are not valid characters, for simplicity we assume they are not present
// but will encode them if encountered.
// 3 byte character, 0x800 to 0xFFFF
// 2 byte character, 0x80 to 0x7FF
// single byte character, 0x0 to 0x7F
// try to use a fast inner loop for following single byte characters,
// since they are quite probable
// adjust index since it will be incremented by the for loop
// 2 bytes needed (11 bits used)
// Check for high surrogate.
// 4 bytes needed (21 bits used)
// 3 bytes needed (16 bits used)
// single byte character
// 2 bytes needed (11 bits used)
// leading 5 bits
// trailing 6 bits
// Check for high surrogate.
// To get from surrogate pair to Unicode code point:
// - subtract 0xD800 from high surrogate, this forms top ten bits
// - subtract 0xDC00 from low surrogate, this forms low ten bits
// - add 0x10000
// Leaves a code point in U+10000 to U+10FFFF range.
// 4 bytes needed (21 bits used)
// leading 3 bits
// next 6 bits
// next 6 bits
// trailing 6 bits
// 3 bytes needed (16 bits used)
// leading 4 bits
// middle 6 bits
// trailing 6 bits
// Ascii is a subset of UTF-8 so just convert to UTF-16
// Latin1 is the first 256 code points in Unicode.
// In UTF-16 encoding each of these is represented as exactly the numeric code point.
// Prefer resize combined with for-loop over constructor dest(s.begin(), s.end())
// for faster assignment.
// diff between windows and unix epochs (seconds)
// shift into 1601, the first 400 year cycle including 1900
// subtract off leap years from 1601
// The following table assumes no leap year; leap year is added separately
// Jan
// Feb
// Mar
// Apr
// May
// Jun
// Jul
// Aug
// Sep
// Oct
// Nov
// Dec
// Jan
// Feb
// Mar
// Apr
// May
// Jun
// Jul
// Aug
// Sep
// Oct
// Nov
// Dec
// LINUX
// convert to 10e-7
// convert and add microseconds, 10e-6 to 10e-7
// shift to start of this 400 year cycle
// shift back to 1900 base from 1601:
// convert to seconds
// Thu, 01 Jan 1970 00:00:00 GMT\0
// 1970-01-01T00:00:00.1234567Z\0
// ^^^ _MSC_VER // !_MSC_VER vvv
// _MSC_VER
// ^^^ _MSC_VER // !_MSC_VER vvv
// _MSC_VER
// Append fractional second, which is a 7-digit value with no trailing zeros
// This way, '1200' becomes '00012'
// ^^^ _MSC_VER // !_MSC_VER vvv
// _MSC_VER
// trim trailing zeros
// Jan
// Feb, special handling for leap years
// Mar
// Apr
// May
// Jun
// Jul
// Aug
// Sep
// Oct
// Nov
// Dec
// Feb needs leap year testing
// adjustMinutes > 59 is impossible due to digit 5 check
/*
//tools.ietf.org/html/rfc1123
// military time deleted by RFC 1123
// parsed day of week
// validity checked later
// parsed day
// parsed day
// parsed month
// days in month validity check
// parsed year
// parsed hour
// parsed mins
// parsed seconds
// parsed seconds
// 60 to allow leap seconds
// some timezone adjustment necessary
// parse year
// parse month
// parse day
// No time
// skip 'T'
// parse hour
// parse minute
// minute > 59 is impossible because we checked that the first digit is <= 5 in the basic format
// check above
// parse seconds
// We allow 60 to account for leap seconds
// consume remaining fractional second digits we can't use
// no more digits in the input, do the remaining multiplies we need
// no adjustment needed for zulu time
// the timezone is malformed, but cpprestsdk currently accepts this as no timezone
/// <summary>
/// Converts a timespan/interval in seconds to xml duration string as specified by
/// http://www.w3.org/TR/xmlschema-2/#duration
/// </summary>
// Find the number of minutes
// Hours
// Days
// The format is:
// PdaysDThoursHminutesMsecondsS
// (approximate mins/hours/secs as 2 digits each + 1 prefix character) + 1 for P prefix + 1 for T
// The format is:
// PnDTnHnMnS
// if n == 0 then the field could be omitted
// The final S could be omitted
// skip 'P'
// decimal point is not handled
// days
// Hours
// Minutes
// seconds
// namespace utility
/***
//github.com/Microsoft/cpprestsdk
// return empty string
//
// A note on the implementation of BASE64 encoding and decoding:
//
// This is a fairly basic and naive implementation; there is probably a lot of room for
// performance improvement, as well as for adding options such as support for URI-safe base64,
// ignoring CRLF, relaxed validation rules, etc. The decoder is currently pretty strict.
//
// gcc is concerned about the bitfield uses in the code, something we simply need to ignore.
// Validation
// padding only at the end
// Handle the last four bytes separately, to avoid having the conditional statements
// in all the iterations (a performance issue).
// There shouldn't be any information (ones) in the unused bits,
// There shouldn't be any information (ones) in the unused bits.
/***
//github.com/Microsoft/cpprestsdk
// Helper function to zero out memory of an IBuffer.
// This shouldn't happen but if can't get access to the raw bytes for some reason
// then we can't zero out.
// Create buffer containing plain text password.
// To fully guarantee asynchrony would require significant impact on existing code. This code path
// is never run on a user's thread and is only done once when setting up a connection.
// Get access to raw bytes in plain text buffer.
// Construct string and zero out memory from plain text buffer.
// ^^^ __cplusplus_winrt ^^^ // vvv !__cplusplus_winrt vvv
// Early return because CryptProtectMemory crashes with empty string
// Round up dataSizeDword to be a multiple of CRYPTPROTECTMEMORY_BLOCK_SIZE
// Copy the buffer and decrypt to avoid having to re-encrypt.
// __cplusplus_winrt
// _WIN32_WINNT >= _WIN32_WINNT_VISTA
// _WIN32
// namespace details
// namespace web
/***
// This will be set if there are any tasks waiting to receive a message
// Push message to the queue as no one is waiting to receive
// There are tasks waiting to receive a message.
// Setting the tce outside the receive lock for better performance
// There are tasks waiting to receive a message, signal them
// Push task completion event to the tce queue, so that it gets signaled when we have a message.
// Receive message queue is not empty, return a message from the queue.
// namespace details
// namespace client
// namespace websockets
// namespace web
/***
// Helper function to build an error string from a Platform::Exception and a location.
// This class is required by the implementation in order to function:
// The TypedEventHandler requires the message received and close handler to be a member of WinRT class.
// Public members cannot have native types
// Handler to be executed when a message has been received by the client
// Handler to be executed when a close message has been received by the client
// Sets the HTTP request headers to the HTTP request message used in the WebSocket protocol handshake
// Unfortunately the MessageWebSocket API throws a COMException if you try to set the
// 'Sec-WebSocket-Protocol' header here. It requires you to go through their API instead.
// Add any specified subprotocols.
// Locally copy the task completion event since there is a PPL bug
// that the set method accesses internal state in the event and the websocket
// client could be destroyed.
// Only call close if successfully connected.
// Users should have already called close and wait on the returned task
// before destroying the client. In case they didn't we call close and wait for
// it to complete. It is safe to call MessageWebSocket::Close multiple times and
// concurrently, it has safe guards in place to only execute once.
// result.get() should happen before anything else, to make sure there is no unobserved exception
// in the task chain.
// No sends in progress
// Start sending the message
// This indicates we should determine the length automatically.
// The user's stream knows how large it is -- there's no need to buffer.
// We have determined the length and can proceed normally.
// The stream needs to be buffered.
// We have postponed the call to send_msg() until after the data is buffered.
// First try to acquire the data (Get a pointer to the next already allocated contiguous block of data)
// If acquire succeeds, send the data over the socket connection, there is no copy of data from stream to
// temporary buffer. If acquire fails, copy the data to a temporary buffer managed by sp_allocated and send it
// over the socket connection.
// Stream does not support acquire or failed to acquire specified number of bytes
// If acquire did not return the required number of bytes, do not rely on its return value.
// Allocate buffer to hold the data to be read from the stream.
// Acquire succeeded, assign the acquired pointer to sp_allocated. Use an empty custom destructor
// so that the data is not released when sp_allocated goes out of scope. The streambuf will manage its
// memory.
// Send the data as one complete message, in WinRT we do not have an option to send fragments.
// Catch exceptions from previous tasks, if any and convert it to websocket exception.
// Convert to websocket_exception.
// Catch to avoid slicing and losing the type if falling through to catch (...).
// Set the send_task_completion_event after calling release.
// Send a close frame to the server
// Send a close frame to the server
// Wait for the close response frame from the server.
// WinRT MessageWebSocket object
// Context object that implements the WinRT handlers: receive handler and close handler
// Tracks whether or not the websocket client successfully connected to the server.
// External callback for handling received and close event
// Queue to track pending sends
// namespace details
// namespace client
// namespace websockets
// namespace web
/***
// Force websocketpp to use C++ std::error_code instead of Boost.
// Workaround data-race on websocketpp's _htonll function, see
// https://github.com/Microsoft/cpprestsdk/pull/1082
// This is a hack to avoid memory leak reports from the debug MSVC CRT for all
// programs using the library: ASIO calls SSL_library_init() which calls
// SSL_COMP_get_compression_methods(), which allocates some heap memory and the
// only way to free it later is to call SSL_COMP_free_compression_methods(),
// but this function is unaccessible from the application code as OpenSSL is
// statically linked into the C++ REST SDK DLL. So, just to be nice, call it
// here ourselves -- even if the real problem is in ASIO (up to v1.60.0).
/* _WIN32 && !NDEBUG */
// Utility function to build up error string based on error code and location.
// Unlock the mutex so connect/close can use it.
// Now, what states could we be in?
// This should be impossible
// This will do nothing in the already-connected case
// This will do nothing in the already-closing case
// At this point, there should be no more references to me.
// Options specific to TLS client.
// Attempt to use platform certificate validation when it is available:
// If OpenSSL fails we will doing verification at the end using the whole certificate chain,
// so wait until the 'leaf' cert. For now return true so OpenSSL continues down the certificate
// chain.
// OpenSSL stores some per thread state that never will be cleaned up until
// the dll is unloaded. If static linking, like we do, the state isn't cleaned up
// at all and will be reported as leaks.
// See http://www.openssl.org/support/faq.html#PROG13
// This is necessary here because it is called on the user's thread calling connect(...)
// eventually through websocketpp::client::get_connection(...)
// Options specific to underlying socket.
// Support for SNI.
// If user specified server name is empty default to use URI host name.
// OpenSSL runs the string parameter through a macro casting away const with a C style cast.
// Do a C++ cast ourselves to avoid warnings.
// Unknown message type. Since both websocketpp and our code use the RFC codes, we'll just
// pass it on to the user.
// 'move' the payload into a container buffer to avoid any copies.
// Set User Agent specified by the user. This needs to happen before any connection is created
// Get the connection handle to save for later, have to create temporary
// because type erasure occurs with connection_hdl.
// Add any request headers specified by the user.
// Add any specified subprotocols.
// Setup proxy options.
// OpenSSL stores some per thread state that never will be cleaned up until
// the dll is unloaded. If static linking, like we do, the state isn't cleaned up
// at all and will be reported as leaks.
// See http://www.openssl.org/support/faq.html#PROG13
// unlock
// No sends in progress
// Start sending the message
// This indicates we should determine the length automatically.
// The user's stream knows how large it is -- there's no need to buffer.
// We have determined the length and can proceed normally.
// The stream needs to be buffered.
// We have postponed the call to send_msg() until after the data is buffered.
// First try to acquire the data (Get a pointer to the next already allocated contiguous block of data)
// If acquire succeeds, send the data over the socket connection, there is no copy of data from stream to
// temporary buffer. If acquire fails, copy the data to a temporary buffer managed by sp_allocated and send it
// over the socket connection.
// Stream does not support acquire or failed to acquire specified number of bytes
// If acquire did not return the required number of bytes, do not rely on its return value.
// Allocate buffer to hold the data to be read from the stream.
// Acquire succeeded, assign the acquired pointer to sp_allocated. Use an empty custom destructor
// so that the data is not released when sp_allocated goes out of scope. The streambuf will manage its
// memory.
// The client has already been closed.
// Catch exceptions from previous tasks, if any and convert it to websocket exception.
// Set the send_task_completion_event after calling release.
// Only need to hold the lock when setting the state to closed.
// Can't join thread directly since it is the current thread.
// unlock
// Making a local copy of the TCE prevents it from being destroyed along with "this"
// This case should have already been filtered above.
// Perform type erasure to set the websocketpp client in use at runtime
// after construction based on the URI.
// Used to safe guard the wspp client.
// Queue to track pending sends
// External callback for handling received and close event
// Used to track if any of the OpenSSL server certificate verifications
// failed. This can safely be tracked at the client level since connections
// only happen once for each client.
// namespace details
// namespace client
// namespace websockets
// namespace web
/***
//github.com/Microsoft/cpprestsdk
// namespace client
// namespace websockets
// namespace web
/***
// Make sure ends in .dll
// Check if the module is already loaded.
// Load dll.
// If there is no GetTestList function then it must be a dll without any tests.
// Simply return an empty TestList.
/***
// TestRunner.cpp : Defines the entry point for the console application.
//
// If starts with .\ remove it.
// Escape any '.'
// Replace all '*' in dllName with '.*'
// Filter out any files that don't match.
// TestRunner can only execute either desktop or winrt tests, but not both.
// This starts with visual studio versions after VS 2012.
// The 'Require' property on a test case is special.
// It requires a certain global setting to be fulfilled to execute.
// Can be multiple requirements, a semi colon seperated list
// All the properties specified at the cmd line act as a 'filter'.
// Functions to list all the test cases and their properties.
// Remember where each list of tests came from.
// Retrieve the static tests and clear for dll loading.
// Cycle through all the test binaries and load them
// Only omit an error if a wildcard wasn't used.
// Store the loaded binary into the test list map
// Combine suite and test name
// Add standard error as output as well.
// The test runner built with WinRT support might be used on a pre Win8 machine.
// Obviously in that case WinRT test cases can't run, but non WinRT ones should be
// fine. So dynamically try to call RoInitialize/RoUninitialize.
// RO_INIT_MULTITHREADED
// The list_test_options() function determines if list or listProperties.
// Start timer.
// Run test cases
/***
// namespace UnitTest
/***
// Safe to ignore we check the size to make sure no buffer overruns before.
// namespace UnitTest
/***
// non-const pointer to avoid VS2013 STL bug
// namespace
// namespace UnitTest
/***
/***
// Ignoring warning about possible overrun because we aren't going to entirely
// change how unittestpp deals with strings.
// namespace UnitTest
/***
// namespace UnitTest/***
// namespace UnitTest
// namespace
// namespace UnitTest
/***
// namespace
// namespace Detail
// namespace UnitTest
/***
// stdafx.cpp :
// Include the standard header and generate the precompiled header.
/***
// namespace UnitTest
/***
// namespace UnitTest
/***
// If on windows we could be either desktop or winrt. Make a requires property for the correct version.
// Only a desktop runner environment can execute a desktop test case and vice versa on winrt.
// This starts with visual studio versions after VS 2012.
// namespace UnitTest
/***
// namespace UnitTest
/***
// cstdio doesn't pull in namespace std on VC6, so we do it here.
// Function to work around outputing to the console when under WinRT.
// add 1 for null termination
// namespace UnitTest
/***
// namespace UnitTest
/***
// std::future and std::thread doesn't exist on Visual Studio 2010 so fall back
// to use agent.
// Logic to decide the timeout for individual test
// 1. If /testtimeout is specified with testrunner arguments, use that timeout.
// 2. Else, if the test has a Timeout property set, use that timeout.
// 3. If both the above properties are not specified, use the default timeout value.
// Timed wait requires async execution.
// namespace UnitTest
/***
// namespace
// close <test> element
// namespace UnitTest
/***
// namespace
// namespace UnitTest
/***
// namespace UnitTest
/***
// stdafx.cpp :
// Include the standard header and generate the precompiled header.
/***
// namespace
/***
// namespace
/***
// non-const on purpose so no folding of duplicate data
// namespace
/***
// namespace
/***
// namespace
/***
// namespace
// namespace UnitTest
/***
// namespace
/***
/*
// namespace
/***
// namespace
/***
// We're really testing the macros so we just want them to compile and link
// namespace
// We're really testing if it's possible to use the same suite in two files
// to compile and link successfuly (TestTestSuite.cpp has suite with the same name)
// Note: we are outside of the anonymous namespace
/***
// namespace
/***
// namespace
/***
// We're really testing if it's possible to use the same suite in two files
// to compile and link successfuly (TestTestSuite.cpp has suite with the same name)
// Note: we are outside of the anonymous namespace
/***
// These are sample tests that show the different features of the framework
// namespace
/***
// Overload to let MemoryOutStream accept std::string
// namespace
/***
// VC6 doesn't have DWORD_PTR
// namespace UnitTest
/***
// Exclude rarely-used stuff from Windows headers
// namespace utilities
// namespace common
// namespace tests
/***
// WinHTTP requires non-empty password
// Auth header
// unauthorized
// TFS 648783
// WinHTTP requires non-empty password
// Auth header
// unauthorized
//localhost:34567/"));
// In this test, the request cannot be resent, so the username and password are not required
// Auth header
// unauthorized
// Must specify content length with winrt client, so this test case isn't possible.
// WinHTTP requires non-empty password
// Auth header
// unauthorized
// Client resent the request
// Accessing a server that returns 401 with an empty user name should not resend the request with an empty password
// Auth header
// unauthorized
// Fails on WinRT due to TFS 648278
// Accessing a server that supports auth, but returns 401, even after the user has provided valid creds
// We're making sure the error is reported properly, and the response data from the second response is received
//localhost:34569/"));
// Auth header
// still unauthorized after the user has resent the request with the credentials
// Auth header
// unauthorized
// Client resent the request
// in winrt, client resent the request again
// These tests are disabled since they require a server with authentication running.
// The server portion to use is the C# AuthenticationListener.
// Helper function to retrieve all parameters necessary for setup tests.
// This test should be executed for NTLM, Negotiate, IntegratedWindowsAuth, and Anonymous.
// This test should be executed for NTLM, Negotiate, IntegratedWindowsAuth, and Digest.
// This test should be executed for all authentication schemes except None.
// WinRT implementation doesn't support request buffer caching.
// __cplusplus_winrt
// _WIN32
// Fix for 522831 AV after failed authentication attempt
//apis.live.net"), config);
// The resulting data must be non-empty (an error about missing access token)
// http_server does not support auth
//httpbin.org/basic-auth/user1/user1"), client_config);
// Socket shouldn't be open yet since no requests have gone out.
//apis.live.net"), config);
// The resulting data must be non-empty (an error about missing access token)
// SUITE(authentication_tests)
// namespace client
// namespace http
// namespace functional
// namespace tests
/***
// Set a method.
// Set a path once.
// Set the path twice.
// Body data types.
// vector - no content type.
// vector - with content type.
// string - no content type.
// string - with content type.
// Body data.
// empty vector.
// empty string.
// empty wstring.
// without content type
// with content type
// Silently pass if locale isn't installed on the machine.
// fr_RF would have 1 000
// Silently pass if locale isn't installed on machine.
// namespace client
// namespace http
// namespace functional
// namespace tests
/***
// Tests using different types of strings to construct an http_client.
// The goal of this test case is to make sure we can compile,
// if the URI class doesn't have the proper constructors it won't.
// So we don't need to actually do a request.
//localhost:4567/"));
//localhost:4567/")));
// Tests different variations on specifying the URI in http_client constructor.
//localhost:55678") + paths[i]);
// Helper function verifies that when constructing an http_client with given
// URI std::invalid_argument is thrown.
// expected
//localhost:34567/"));
// Invalid scheme.
// empty host.
//:34567/"));
//localhost:34568/p/g"));
// copy constructor
// assignment
//bad:-1"));
// move constructor
// move assignment
// move constructor
// move assignment
// Verify that we can read the config from the http_client
// Verify that we can get the baseuri from http_client constructors
// Verify that the callback of sslcontext is called for HTTPS
//www.google.com/"), config);
// Verify that the callback of sslcontext is not called for HTTP
//www.google.com/"), config);
// SUITE(client_construction)
// namespace client
// namespace http
// namespace functional
// namespace tests
/***
// A fake "pass-through" compressor/decompressor for testing
// compress in chunks
// the entire input buffer has been consumed by the compressor
// extend the output buffer if there may be more compressed bytes to retrieve
// once more with no input or output, to assure no error and done
// actual
// decompress in as-compressed chunks
// decompress again in fixed-size chunks
// once more with no input, to assure no error and done
// decompress all at once
// invalid decompress buffer, first and subsequent tries
// FAKE
// Supported algorithms
// Strings that double as both Transfer-Encoding and TE
// Similar, but geared to match a non-built-in algorithm
// Repeat for Transfer-Encoding (which also covers part of TE) and Content-Encoding (which also covers all of
// Accept-Encoding)
// No compression - Transfer-Encoding
// Built-in only
// Supplied compressor/decompressor
// No matching compressor
// Negative tests - invalid headers, no matching algorithm, etc.
// Negative tests - empty headers
// Negative tests - invalid rankings
// Builtins
// Null decompressor - effectively forces no compression algorithms
// --> "gzip;q=1.0"
// TE- and/or Accept-Encoding-specific test cases, regenerated for each pass
// Switch built-in vs. supplied results the second time around
// Built-in only
// Supplied compressor - both matching and non-matching
// No acquire(), to force non-acquire compression client codepaths
// Run a quick test to see if we're dealing with older/broken winhttp for compressed transfer encoding
// The test server throws if it's destructed with outstanding tasks,
// which will happen if winhttp responds 501 without informing us
// _WIN32
// Test decompression both explicitly through the test server and implicitly through the listener;
// this is the top-level loop in order to avoid thrashing the listeners more than necessary
// Start the listener, and configure callbacks if necessary
// This one won't be found by the server in the default set...
// Compression happens in the listener itself
// This one won't be found in the server's default set...
// _WIN32
// Add a single pre-compressed stream, since Content-Encoding requires Content-Length
// Test various buffer sizes
// Re-build the sets of compress and decompress factories, to account for the buffer size in our "fake"
// ones
// Use a memory-constrained Brotli instance in some cases for code coverage
// Test compressible (net shrinking) and non-compressible (net growing) buffers
// Test both Transfer-Encoding and Content-Encoding
// Test supported compression algorithms
// Test both GET and PUT
// Add a pair of non-compressed streams for Transfer-Encoding, one with and one
// without acquire/release support
// Add a single pre-compressed stream, since Content-Encoding requires
// Content-Length
// We implement the decompression path in the server, to prove that valid,
// compressed data is sent
// _WIN32
// _WIN32
// Send the request
// extra to ensure no overflow
// On Windows, someone along the way adds "Accept-Encoding: peerdist",
// so we can't unconditionally assert that Accept-Encoding is not
// present
// Account for space for the chunk header and delimiters, plus a chunk
// extension and a chunked trailer part
// __cplusplus_winrt
// __cplusplus_winrt
// Add delimiters for the first (and only) data chunk, plus the final
// 0-length chunk, and hack in a dummy chunk extension and a dummy
// trailer part.  Note that we put *two* "0\r\n" in here in the 0-length
// case... and none of the parsers complain.
// Common send and response processing code
// SUITE(request_helper_tests)
// namespace client
// namespace http
// namespace functional
// namespace tests
/***
// Test implementation for pending_requests_after_client.
// send requests.
// send responses.
// verify responses.
// Tests requests still outstanding after the http_client has been destroyed.
//localhost323:-1"));
// This API should not throw. The exception should be surfaced
// during task.wait/get
// Send request.
// Wait for request
// Close server connection.
// Try sending another request.
// CodePlex 295
// CodePlex 295
//www.bing.com/"));
// This test sends an SSL request to a non-SSL server and should fail on handshaking
//localhost:34568/"));
// The response body should timeout and we should receive an exception
// The response body should timeout and we should receive an exception
// This test can't be implemented with our test server so isn't available on WinRT.
// Codeplex 328.
// All errors after cancellation are ignored.
// This test can't be implemented with our test server since it doesn't stream data so isn't avaliable on WinRT.
// Codeplex 328.
// Try to connect to a server on a closed port and cancel the operation.
// http_client_asio had a bug where, when canceled, it would cancel only the
// current connection but then go and try the next address from the list of
// resolved addresses, i.e., it wouldn't actually cancel as long as there
// are more addresses to try. Consequently, it would not report the task as
// being canceled. This was easiest to observe when trying to connect to a
// server that does not respond on a certain port, otherwise the timing
// might be tricky.
// We need to connect to a URI for which there are multiple addresses
// associated (i.e., multiple A records).
//microsoft.com:442/"));
// Send request.
// Make sure that the client already finished resolving before canceling,
// otherwise the bug might not be triggered.
// SUITE(connections_and_errors)
// namespace client
// namespace http
// namespace functional
// namespace tests
/***
// The WinRT-based HTTP stack does not support headers that have no
// value, which means that there is no point in making this particular
// header test, it is an unsupported feature on WinRT.
// copy constructor
// move constructor
// assignment operator
// move assignment operator
// wchar
// utility::string_t
// int
// unsigned long
// match with empty string
// match with string containing spaces
// match failing
// Find when empty.
// Find that exists.
// Find that doesn't exist.
// Add multiple
// Add one that already exists
// Add with different case
// Add with spaces in string
// begin when empty
// with some values.
// begin when empty
// with some values.
// Test default case of cpprestsdk setting host header as host:port
// Test case where we overwrite the host header
// SUITE(header_tests)
// namespace client
// namespace http
// namespace functional
// namespace tests
/***
// Ensure that your traffic goes to port 8877 on the machine where NetFuzz is running
// Netfuzz sets an HTTP proxy at that location which your client must talk to
//localhost:8877/")) {}
// The WinRT-based HTTP stack does not support headers that have no
// value, which means that there is no point in making this particular
// header test, it is an unsupported feature on WinRT.
// SUITE(http_client_fuzz_tests)
// namespace client
// namespace http
// namespace functional
// namespace tests
/***
// Helper function send a simple request to test the connection.
// Take in the path to request and what path should be received in the server.
// namespace client
// namespace http
// namespace functional
// namespace tests
/***
// Tests the defined methods and custom methods.
// Don't include 'CONNECT' it has a special meaning.
// -  this is never passed to the listener with http_listener
// - ditto
// namespace client
// namespace http
// namespace functional
// namespace tests
/***
// Helper function to initialize an array of strings to contain 1 MB data.
// 10k
// response to requests
// send requests
// wait for requests.
// Tests multiple requests with responses containing data.
// response to requests
// send requests
// response to requests
// wait for requests.
// SUITE(multiple_requests)
// namespace client
// namespace http
// namespace functional
// namespace tests
/***
//localhost:17778/"))
///123?123=a&1="), temp_endpoint)
// clang-format off
// Basic base string generation.
//example.com:80/request?a=b&c=d")); // Port set to avoid default.
// Added "extra_param" and proper parameter normalization.
//example.com:80/request?a=b&c=d"));
// Use application/x-www-form-urlencoded with parameters in body
//example.com:80/request?a=b&c=d")); // Port set to avoid default.
//example.com:80/request?a=b&c=d")); // Port set to avoid default.
// Verify prefix, and without 'oauth_token'.
// Verify suffix with proper 'oauth_callback'.
// Reply with temporary token and secret.
//localhost:17778/?oauth_token=testbar"));
// NOTE: This test also covers token_from_verifier().
// Verify temporary token prefix.
// Verify suffix with 'oauth_verifier'.
// Verify we have 'oauth_nonce' and 'oauth_signature'.
// Reply with access token and secret.
// Simulate temporary token.
//localhost:17778/?oauth_token=xyzzy&oauth_verifier=simsalabim"));
// clang-format on
// SUITE(oauth1_tests)
// namespace client
// namespace http
// namespace functional
// namespace tests
/***
//localhost:16743/"))
//test1"), m_uri.to_string(), U("https://bar"))
///?a=21#1=2"), token_endpoint)
//?=#"), redirect_uri)
// Empty authorization URI.
// Authorization URI with scope parameter.
// Full authorization URI with scope.
//test1"));
//localhost:8080"));
//test1/?response_type=code&client_id=4567abcd&redirect_uri=http://")
// Verify again with implicit grant.
//test1/?response_type=token&client_id=4567abcd&redirect_uri=http://")
// Verify that a new state() will be generated.
// Fetch using HTTP Basic authentication.
// Fetch using client key & secret in request body (x-www-form-urlencoded).
// Clear token.
// Authorization code grant.
// Implicit grant.
// Verify token refresh without scope.
// Verify chaining refresh tokens and refresh with scope.
// Default, bearer token in "Authorization" header (bearer_auth() == true)
// Bearer token in query, default access token key (bearer_auth() == false)
// Bearer token in query, updated token, custom access token key (bearer_auth() == false)
// Verify reply JSON 'access_token', 'refresh_token', 'expires_in' and 'scope'.
// Verify undefined 'expires_in' and 'scope'.
// SUITE(oauth2_tests)
// namespace client
// namespace http
// namespace functional
// namespace tests
/***
// http://www.cnn.com redirects users from countries outside of the US to the "http://edition.cnn.com/" drop
// location
//edition.cnn.com"));
// CNN's main page doesn't use chunked transfer encoding.
// CNN's other pages do use chunked transfer encoding.
// On platforms which do not support compressed http, nothing to check.
//en.wikipedia.org/wiki/HTTP_compression"), config);
// Use code.google.com instead of www.google.com, which redirects
//code.google.com"));
// Use code.google.com instead of www.google.com, which redirects
//code.google.com"));
// Save the current ambient scheduler
// Change the ambient scheduler to one that schedules synchronously
// Use code.google.com instead of www.google.com, which redirects
//code.google.com"));
// Revert to the original scheduler
// Use code.google.com instead of www.google.com, which redirects
//code.google.com"));
// Uncomment the following line to output the chars.
// std::cout << chars << '\n';
//ws.audioscrobbler.com/2.0/") U(
// Verify that the body size isn't empty.
// Note additional sites for testing can be found at:
// https://badssl.com/
// https://www.ssllabs.com/ssltest/
// http://www.internetsociety.org/deploy360/resources/dane-test-sites/
// https://onlinessl.netlock.hu/#
// !defined(__cplusplus_winrt)
//self-signed.badssl.com/")); }
//self-signed.badssl.com/")); }
// !defined(__cplusplus_winrt)
//wrong.host.badssl.com/")); }
//wrong.host.badssl.com/"));
//wrong.host.badssl.com/")); }
//198.35.26.96/"));
// WinHTTP will transparently follow the HTTP 301 upgrade request redirect,
// ASIO does not and will return the 301 directly.
// !defined(__cplusplus_winrt) && !defined(CPPREST_FORCE_HTTP_CLIENT_WINHTTPPAL)
//expired.badssl.com/")); }
//expired.badssl.com/")); }
// !defined(__cplusplus_winrt)
//revoked.badssl.com/"));
//revoked.badssl.com/")); }
// !defined(__cplusplus_winrt)
//untrusted-root.badssl.com/")); }
//untrusted-root.badssl.com/")); }
// !defined(__cplusplus_winrt)
//expired.badssl.com/"), config);
// !defined(__cplusplus_winrt)
// Create URI for:
// https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&playlistId=UUF1hMUVwlrvlVMjUGOZExgg&key=AIzaSyAviHxf_y0SzNoAq3iKqvWVE4KQ0yylsnk
//www.googleapis.com/youtube/v3/playlistItems?"));
// Send request
// Retry up to 4 times.
// Update this accordingly, if the number of items changes
// If we didn't get a "connection broken" error (or we are on the last retry), rethrow it
// SUITE(outside_tests)
// namespace client
// namespace http
// namespace functional
// namespace tests
/***
// Don't include 'CONNECT' it has a special meaning.
// this is never passed to the listener
// Don't include 'CONNECT' it has a special meaning.
// Don't include 'CONNECT' it has a special meaning.
// The counting is prevented from happening, because the short-circuit come before the count.
// Don't include 'CONNECT' it has a special meaning.
/// <summary>
/// Pipeline stage used for pipeline_stage_inspect_response.
/// </summary>
// Put in nested scope so we lose the reference on the shared pointer.
// SUITE(pipeline_stage_tests)
// namespace client
// namespace http
// namespace functional
// namespace tests
/***
// We don't have very precise control over how much of a message is transferred
// in each chunk being sent or received, so we can't make an exact comparison here.
// We don't have very precise control over how much of a message is transferred
// in each chunk being sent or received, so we can't make an exact comparison here.
// We don't have very precise control over how much of a message is transferred
// in each chunk being sent or received, so we can't make an exact comparison here.
//localhost323:-1"));
// We should never see this handler called.
// We should never see this handler called for download, but for upload should still happen, since
// there's a server (just not a very responsive one) and we're sending data to it.
// CodePlex 295
// We don't have very precise control over how much of the message is transferred
// before the exception occurs, so we can't make an exact comparison here.
// First all is for data upload completion
// second is for data download
/* It is ok if the request does not complete before the server is shutdown */
// 2rd is for data download
// Expected.
// namespace client
// namespace http
// namespace functional
// namespace tests
/***
// In order to run this test, replace this proxy uri with one that you have access to.
//netproxy.redmond.corp.microsoft.com");
//x");
// IXHR2 does not allow the proxy settings to be changed
// __cplusplus_winrt
// Can't specify a proxy with WinRT implementation.
// relax, this is not my real password
// Access to this server will succeed because the first request will not be challenged and hence
// my bogus credentials will not be supplied.
//www.microsoft.com"), config);
// The above "netproxy.redmond.corp.microsoft.com" is an internal site not generally accessible.
// This will cause a failure to resolve the URL.
// This is ok.
//httpbin.org"), config);
//httpbin.org"), config);
// SUITE(proxy_tests)
// namespace client
// namespace http
// namespace functional
// namespace tests
/***
// On Windows, someone along the way (not us!) adds "Accept-Encoding: peerdist"
// Without content type.
// With content type.
// Empty body type
// Without content type.
// With content type.
// Empty body.
// JSON bool value.
// JSON null value.
// SUITE(request_helper_tests)
// namespace client
// namespace http
// namespace functional
// namespace tests
/***
// On WinRT, we must compensate for the fact that we will be accessing files in the
// Documents folder
// Used to prepare data for stream tests
// Transfer encoding chunked is not supported. Not specifying the
// content length should cause an exception from the task. Verify
// that there is no unobserved exception
// Implementation for request with stream test case.
//(withContentLength);
// We should only have read the first 4500 bytes.
// We should only have read the first 26 bytes.
// Ignore on WinRT CodePlex 144
// Codeplex 328.
// These tests aren't possible on WinRT because they don't
// specify a Content-Length.
// Make request.
// Write a bit of data then close the stream early.
// Verify that the task completes successfully
// Make request.
// Write a bit of data then close the stream early.
// Verify that the responseTask throws the exception set when closing the stream
// Codeplex 328.
// Ignore on WinRT only CodePlex 144
// Make request.
// Write a bit of data then close the stream early.
// Verify that the responseTask throws the exception set when closing the stream
// Codeplex 328.
// Ignore on WinRT only CodePlex 144
// Make request.
// Write a bit of data then close the stream early.
// Verify that the responseTask throws the exception set when closing the stream
// Codeplex 328.
// SUITE(request_stream_tests)
// namespace client
// namespace http
// namespace functional
// namespace tests
/***
// Tests path specified in requests with non-empty base path in client constructor.
//localhost:45678/base_path/"));
// Path not starting with '/'.
// Path starting with '/'.
// Tests path specified in requests with empty base path in client constructor.
//localhost:45678"));
// NON empty path.
// Request path of '*'
/*"));
// Empty base of '/' with request path starting with '/'.
//localhost:45678/"));
// query
// fragment
// WinRT implementation percent encodes the '#'.
// try with encoding string.
// verify encoding actual happens with plain.
// Tests combining case URI query/fragments with relative URI query/fragments.
// Try with query.
// WinRT implementation percent encodes the '#'.
// Try with fragment.
// WinRT implementation percent encodes the '#'.
// SUITE(request_uri_tests)
// namespace client
// namespace http
// namespace functional
// namespace tests
/***
// Helper function to send a request and response with given values.
// default encoding (Latin1)
// us-ascii
// Latin1
// utf-8
// "utf-8" - quoted charset
// no content length
// If there is no Content-Type in the response, make sure it won't throw when we ask for string
// utf-16le
// utf-16be
// utf-16 no BOM (utf-16be)
// utf-16 big endian BOM.
// utf-16 little endian BOM.
// default encoding (Latin1)
// us-ascii
// Latin1
// utf-8
// "utf-8" - quoted charset
// no content length
// If there is no Content-Type in the response, make sure it won't throw when we ask for string
// utf-16le
// utf-16be
// utf-16 no BOM (utf-16be)
// utf-16 big endian BOM.
// utf-16 little endian BOM.
// default encoding (Latin1)
// us-ascii
// Latin1
// utf-8
// "utf-8" - quoted charset
// no content length
// If there is no Content-Type in the response, make sure it won't throw when we ask for string
// utf-16le
// utf-16be
// utf-16 no BOM (utf-16be)
// utf-16 big endian BOM.
// utf-16 little endian BOM.
// with non matching content type.
// with unknown charset
// default encoding (Latin1)
// us-ascii
// Latin1
// utf-8
// If there is no Content-Type in the response, make sure it won't throw when we ask for json
// utf-16le
// utf-16be
// utf-16 no BOM (utf-16be)
// utf-16 big endian BOM.
// utf-16 little endian BOM.
// unofficial JSON MIME types
// with non matching content type.
// with unknown charset.
// textual content type - with unknown charset
// textual type with us-ascii
// textual type with Latin1
// textual type with utf-8
// textual type with utf-16le
// textual type with utf-16be
// textual type with utf-16
// non textual content type
// SUITE(response_extract_tests)
// namespace client
// namespace http
// namespace functional
// namespace tests
/***
// Write the response into the file
// The test needs to be a little different between desktop and WinRT.
// In the latter case, the server will not see a message, and so the
// test will hang. In order to prevent that from happening, we will
// not have a server listening on WinRT.
// Send a 100 KB data in the response body, the server will send this in multiple chunks
// This data will get sent with content-length
// Tests if an exception occurs and close throws an exception that the close
// one is ignored and doesn't bring down the process.
// This sets the content_length
// overwrite content_length to 0
// add chunked transfer encoding
// add connection=close header, connection SHOULD NOT be considered persistent' after the current
// request/response is complete
// respond
// With chunked transfer-encoding, send 2 chunks of different sizes in the response
// Send two chunks, note: second chunk is bigger than the first.
// SUITE(responses)
// namespace client
// namespace http
// namespace functional
// namespace tests
/***
// custom status code.
// SUITE(status_code_reason_phrase_tests)
// namespace client
// namespace http
// namespace functional
// namespace tests
/***
// stdafx.cpp :
// Include the standard header and generate the precompiled header.
/***
// to_string
// to_string
// to_string
// Don't verify the values of each of these headers, but make sure they exist.
// to_string
// SUITE(to_string_tests)
// namespace client
// namespace http
// namespace functional
// namespace tests
/***
// namespace listener
// namespace http
// namespace functional
// namespace tests
/***
// For single_core test case.
// Let the connection timeout
// close() racing with a new connection
// Depending on timing this might not succeed. The
// exception will be caught and ignored below
// The response body should timeout and we should recieve an exception
// If we reach here then it is an error
// Note: Run with admin privileges to listen on default port.
// This test will fail with "Access denied: attempting to add Address.." exception if it is not run as admin.
//localhost/portnotspecified"));
// Verify close does not throw an exception while listening on default port
// Fake having a scheduler with only 1 core.
// Don't wait on the task otherwise it could inline allowing other tasks to run on the scheduler.
// This test case is manual becuase it requires to be run under and account without admin access.
//localhost/"));
// Start closing the listener and then send reply.
// Helper function to verify http_exception and return the error code value.
// Using our production http_client here because it
// allows separation of sending headers and body.
// namespace listener
// namespace http
// namespace functional
// namespace tests
/***
// single header value.
// empty header value.
// 10 headers.
// several headers different casings.
// "Date" was being incorrectly mapped to "Data"
// see https://github.com/microsoft/cpprestsdk/issues/1208
// No http_request/response classes can be around for close to complete.
// header with empty value
// 10 headers
// several headers in different casings
// duplicate headers fields
// namespace listener
// namespace http
// namespace functional
// namespace tests
/***
// Test that the default ctor works.
// move constructor
// move assignment
// Path that matches exactly
// Path that matches but is more specific.
// Try a request with a path that doesn't match.
// Path that matches exactly
// Try a request with a path that doesn't match.
// non HTTP scheme
//localhost:456/")), std::invalid_argument);
// empty HTTP host
//:456/")), std::invalid_argument);
// try specifying a query
//localhost:45678/path?key1=value")), std::invalid_argument);
// try specifing a fragment
//localhost:4563/path?key1=value#frag")), std::invalid_argument);
// Verify default configuration.
// Verify specified config values.
// copy constructor
// move constructor
// assignment
// move assignment
//www.example-social-network.com"));
//en.wikipedia.org/wiki/Main_Page"));
// namespace listener
// namespace http
// namespace functional
// namespace tests
/***
// content type and string body
// content type and rvalue reference string body
// namespace listener
// namespace http
// namespace functional
// namespace tests
/***
// Don't include 'CONNECT' it has a special meaning.
// request with no body
// request with body size explicitly 0
// request with body data
// 26 * 160 is greater than 4k which is the chunk size.
// our product client would be able to pipe multiple requests on one connection
// intentionally break order
// wait for requests.
// verify the requests and responses are still match
// Wrap in try catch to print out more information to help with a sporadic failure.
// Path component contains encoded characters
// Query string contains encoded characters
// URI has path and fragment components
// URI has path, query and fragment components
// Requires a certificate for execution.
// Here are instructions for creating a self signed cert. Full instructions can be located here:
// http://blogs.msdn.com/b/haoxu/archive/2009/04/30/one-time-set-up-for-wwsapi-security-examples.aspx
// From an elevated admin prompt:
// 1. MakeCert.exe -ss Root -sr LocalMachine -n "CN=Fake-Test-CA" -cy authority -r -sk "CAKeyContainer"
// 2. MakeCert.exe -ss My -sr LocalMachine -n "CN=localhost" -sky exchange -is Root -ir LocalMachine -in
// Fake-Test-CA -sk "ServerKeyContainer"
// 3. Find corresponding SHA-1 hash with CertUtil.exe -store My localhost
// 4. Netsh.exe http add sslcert ipport=0.0.0.0:8443 appid={00112233-4455-6677-8899-AABBCCDDEEFF}
// certhash=<40CharacterThumbprintWithNoSpaces>
// namespace listener
// namespace http
// namespace functional
// namespace tests
/***
// namespace listener
// namespace http
// namespace functional
// namespace tests
/***
// Add one with a different case.
// Add a general handler
// throw exception
// throw exception, after replying first
// try overridding the default OPTIONS handler
// try overridding the default OPTIONS handler
//localhost:45678/path1"));
//localhost:45678/path1/path2"));
//localhost:45678/path3"));
//localhost:45678"));
// send a request to the first listener
// send a request to the second listener
// send a request to the third listener
// Remove the second listener and send a request again.
//localhost:45679/path1"));
//localhost:45679/path1/path2"));
//localhost:45679"));
//localhost:45679"));
// first listener is used to wait until a request comes into the second
// and then will try to close the second.
// pick a large number to see leaks easier
// use large number of iterations to test for leaks
// this help recognizing the leaked memory in the CRT/VLD dump
// formatting should succeed
// parsing should succeed
// parsing should fail
//localhost:45678/path1"));
//localhost:45678"));
// All clients currently use HTTP/1.1
// Send a request to the listener
//localhost:45678/path1"));
//localhost:45678"));
// We can't guarantee that the host has both IPv4 and IPv6 available, so check for either IP
// Send a request to the listener
// namespace listener
// namespace http
// namespace functional
// namespace tests
/***
// listen on empty, request /path1/path2
// listen on /path1, request /path1/path2
// listen on /path1%20/path2%20, request /path1%20/path2%20/path%203
//localhost:45678"));
//localhost:45678"));
// namespace listener
// namespace http
// namespace functional
// namespace tests
/***
// 26 * 160 is greater than 4k which is the chunk size.
// namespace listener
// namespace http
// namespace functional
// namespace tests
/***
// Used to prepare data for read tests
// Try sending data straight from a file.
// Try sending data straight from a file.
// Try sending data straight from a file.
// We shouldn't be sending more than the content-length.
// We should only have read the first 4500 bytes.
// Try sending data straight from a file.
// Not setting the content length forces "transfer-encoding: chunked"
// Try sending data straight from a file.
// Not setting the content length forces "transfer-encoding: chunked"
// Write 4K - the exact internal chunk size
// Ensure that it is transfer-encoded
// Wait for headers
// Wait for data
// Now verify that we've got the right data
// Fails sporadically, Codeplex #158
// Write 4K - the exact internal chunk size
// Ensure that it is transfer-encoded
// Wait for headers
// Wait for data
// namespace listener
// namespace http
// namespace functional
// namespace tests
/***
// known status code
// user defined status code
// standard status code, no reason phrase
// standard status code, with reason phrase
// non standard status code, no reason phrase
// namespace listener
// namespace http
// namespace functional
// namespace tests
// stdafx.cpp :
// Include the standard header and generate the precompiled header.
/***
// to string
// to_string
// maybe to_string() should wait for the request to complete?
// in the mean time...
// namespace listener
// namespace http
// namespace functional
// namespace tests
/***
// Helper function to verify all given headers are present.
// verify that content-type key exists in the header and the value matches the one provided
// Helper function to parse HTTP headers from a stringstream.
// Keep parsing until CRLF is encountered.
// Parse request line.
// Parse headers.
// Parse in any message body
// Parse response line.
// Parse headers.
// Prase in any message body.
// Textual response is always sent as UTF-8, hence the converison to string_t
// Beware: what kind of string this is? <-- stringhack until we tighten up wide/narrow string business
// We have more than one byte of data, but it's null-terminated at byte 1.
// Therefore, this is a wide string
// namespace utilities
// namespace http
// namespace functional
// namespace tests
/***
// stdafx.cpp :
// Include the standard header and generate the precompiled header.
/***
// Flatten the http_headers into a name:value pairs separated by a carriage return and line feed.
// Helper function to query for the size of header values.
// Helper function to get the status code from a WinHTTP response.
// Helper function to trim leading and trailing null characters from a string.
// Helper function to get the reason phrase from a WinHTTP response.
// WinHTTP reports back the wrong length, trim any null characters.
/// <summary>
/// Parses a string containing Http headers.
/// </summary>
// Status code and reason phrase.
// Open session.
// Set timeouts.
// Set max connection to use per server to 1.
// Register asynchronous callback.
// Open connection.
// Release memory for each request.
// Unregister the callback.
// Add headers.
// WinHTTP callback.
// Now allocate buffer for headers and query for them.
// Check to see if the response has a body or not.
// Actual WinHTTP call to read in body.
// Used to store all requests to simplify memory management.
// namespace utilities
// namespace http
// namespace functional
// namespace tests
/***
// Helper function to parse verb from Windows HTTP Server API.
/// <summary>
/// String values for all HTTP Server API HTTP_REQUEST_HEADERS known headers.
/// NOTE: the order here is important it is from the _HTTP_HEADER_ID enum.
/// </summary>
// Open server session.
// Create Url group.
// Create request queue.
// Windows HTTP Server API will not accept a uri with an empty path, it must have a '/'.
// Add Url.
// Associate Url group with request queue.
// Launch listener thread
// Oversubscription for long running ConcRT tasks
// Read in everything except the body.
// Now create request structure.
// Read in request body.
// Windows HTTP Server API will not accept a uri with an empty path, it must have a '/'.
// Remove Url.
// Stop request queue.
// Close all resources.
// Oversubscription for long running ConcRT tasks
// intentionally narrow wchar_t -> char
// Add headers.
// Add the no cache header.
// Add all other headers.
// TFS 624150
// Add body.
// Synchronously sending the request.
// Free memory needed for headers.
// namespace utilities
// namespace http
// namespace functional
// namespace tests
/***
// namespace utilities
// namespace http
// namespace functional
// namespace tests
/***
// Copy object that has values added.
// Copy object that parses with value, but none additional added.
// Factory which takes a vector.
// Tests constructing empty and adding.
// Construct as null value, then turn into object.
/*keep_order==*/true);
/*keep_order==*/false);
// Constructor which takes a vector.
// Test empty factory and adding.
// Construct as null value and then add elements.
// Element [0] should already behave as an object.
// Test factory which takes a size.
// The begin and end iterators on non-const instances
// The begin and end iterators on const instances
// Test at()
// Test find()
// Test find() const
// The begin and end iterators on non-const instances
// The begin and end iterators on const instances
// SUITE(construction_tests)
// namespace json_tests
// namespace functional
// namespace tests
/***
// Look for UTF-8 BOM
// UTF8 to UTF16 conversion will retain the BOM, remove it.
// namespace json_tests
// namespace functional
// namespace tests
/***
// for_each
// find_if
// copy_if
// transform
// namespace json_tests
// namespace functional
// namespace tests
/***
// Test both positive and negative number
// Check that the number is convertible to signed int64
// Check for other integral conversions
// Negative limits
// Around zero
// Positive limits
// Outside 32-bits limits
// a number out of the int32 range
// Check that the number is convertible to unsigned int64
// Check for other integral conversions
// 7 = length of "1." and "e+123" which is the begining and the end of the double representation
// If the number is within integral types limit and not decimal, it should be stored as one of the integral
// types
// If it is outside the range, these methods should return false.
// Note that at this point there is no guarantee that the number was stored as double.
// Note: this should not parse to a ullong because of rounding
// the lowest number that will be represented as double due to overflowing
// unsigned int64 (52bits fraction in double-precision)
// between 0-ULLONG_MAX and LLONGMIN
// JSON uses the C locale always and should therefore not be impacted by the process locale
// If locale isn't installed on system just silently pass.
// unsigned int64 max
// signed int64 min
// double max
// double min
// Make sure these are equal
// These two are to verify that explicitly stated signed int was stored as unsigned int as we store all
// non-negative numbers as unsigned int
// These numbers would be equal if converted to double first. That is how we compared them before we had int64
// support.
// Checking boundary condition - zero
// SUITE(json_numbers_tests)
// namespace json_tests
// namespace functional
// namespace tests
/***
// '\', '"', and control characters must be escaped (0x1F and below).
// TFS 535589
// TFS#501321
// Test using Windows only API.
// namespace json_tests
// namespace functional
// namespace tests
/***
// GCC 4.8 doesn't support regex very well, fall back to Boost. Revist in GCC 4.9.
// const expression
// Try all the whitespace characters before/after all the structural characters
// whitespace characters according to RFC4627: space, horizontal tab, line feed or new line, carriage return
// structural characters: [{]}:,
// [,]
// {:}
// two character escapes
// Euro sign as a hexidecmial UTF-8
// UTF-16 character with surrogate pair
// Grinning Face emoji as a hexadecimal UTF-8
// backslash '\'
// quotation '"'
// Try constructing a json string value directly.
// Try parsing a string
// Try parsing a stringstream.
// Nothing but a comment
/* There's nothing but a comment here */  ")));
// There's nothing but a comment here\n")));
// Some invalid comments
/*/")));
/* /* nested */ */")));
// Correctly placed comments
// This is a trailing comment\n"));
// nested\n comment */"));
/* This is a trailing comment with a // nested\n comment */"));
// This is a leading comment\n -22"));
/* This is a trailing comment */"));
/* This is a leading comment */ -22"));
/***/"));
// A comment in the middle of an empty object\n}"));
/* A comment in the middle of an empty object */}"));
// A comment in the middle of a non-empty object\n 2}"));
/* A comment in the middle of a non-empty object */ 2}"));
// A comment in the middle of an empty array\n]"));
/* A comment in the middle of an empty array */]"));
// A comment in the middle of a non-array\n 2]"));
/* A comment in the middle of a non-empty array */ 2]"));
// Nothing but a comment
/* There's nothing but a comment here */ ");
// There's nothing but a comment here\n ");
// Some invalid comments
/*/");
/* /* nested */ */");
// Correctly placed comments
// This is a trailing comment\n");
// nested\n comment */");
/* This is a trailing comment with a // nested\n comment */");
// This is a leading comment\n -22");
/* This is a trailing comment */");
/* This is a leading comment */ -22");
/***/");
// A comment in the middle of an empty object\n}");
/* A comment in the middle of an empty object */}");
// A comment in the middle of a non-empty object\n 2}");
/* A comment in the middle of a non-empty object */ 2}");
// A comment in the middle of an empty array\n]");
/* A comment in the middle of an empty array */]");
// A comment in the middle of a non-array\n 2]");
/* A comment in the middle of a non-empty array */ 2]");
// This should parse without issues:
// But this one should throw:
// Make sure collection stays unsorted:
// Make sure lookup still works:
// Make sure 'a' goes to the back of the collection, and
// can be looked up
// If locale isn't installed on system just silently pass.
// string serialize
// cpprestsdk stream serialize
// std stream serialize
// SUITE(parsing_tests)
// namespace json_tests
// namespace functional
// namespace tests
/***
// stdafx.cpp :
// Include the standard header and generate the precompiled header.
/***
// null
// bool - true
// bool - false
// number - int
// number - double
// string
// object - with values created from parsing
// object - with values added
// array
// array
// object
// This number will have the longest serializaton possible (lenght of the string):
// Sign, exponent, decimal comma, longest mantisa and exponent make so.
// #digits + 2 to avoid loss + 1 for the sign + 1 for decimal point + 5 for exponent (e+xxx)
// Check narrow string implementation
// Check wide string implementation
// SUITE(to_as_and_operators_tests)
// namespace json_tests
// namespace functional
// namespace tests
/***
// Include ATL headers before casablanca headers
// Exclude rarely-used stuff from Windows headers
// some CString constructors will be explicit
// Exclude rarely-used stuff from Windows headers
// These MFC headers are not code analysis clean.
// MFC extensions
// MFC core and standard components
// MFC support for Internet Explorer 4 Common Controls
// MFC support for Windows Common Controls
// _AFX_NO_AFXCMN_SUPPORT
// Windows Header Files:
// some CString constructors will be explicit
//www.cnn.com")); }
// SUITE(header_test1)
// namespace atl_headers
// namespace misc
// namespace functional
// namespace tests
/***
// Exclude rarely-used stuff from Windows headers
// Include ATL headers after casablanca headers
// Exclude rarely-used stuff from Windows headers
// some CString constructors will be explicit
// Exclude rarely-used stuff from Windows headers
// These MFC headers are not code analysis clean.
// MFC extensions
// MFC core and standard components
// MFC support for Internet Explorer 4 Common Controls
// MFC support for Windows Common Controls
// _AFX_NO_AFXCMN_SUPPORT
// Windows Header Files:
// some CString constructors will be explicit
//www.cnn.com")); }
// SUITE(header_test2)
// namespace atl_headers
// namespace misc
// namespace functional
// namespace tests
/***
// Calculate fib in serial
// namespace helpers
// this should not hang
// Test that default constructed task<T> properly throw exceptions
// Test void tasks
// Test that default constructed task<void> properly throw exceptions
// create movable only type
// explicitly delete copy functions
// _MSC_VER
// Dev10 compiler gives an error => .then(func) where func = int!
// Test constant 'this' pointer in member functions then(), wait() and get(),
// so that they can be used in Lambda.
// _MSC_VER < 1700
// _MSC_VER
// Test Fire-and-forget behavior
// test create task
// this should not hang, because of the set of tce
// The Dev10 compiler hits an ICE with this code
// Do nothing
// _MSC_VER < 1700
// should be no-op
// testing ( t1 && t2 ) || t3, operator&& finishes first
// testing ( t1 && t2 ) || t3, operator|| finishes first
// testing t1 && (t2 || t3)
// this should not hang
// this should not hang
// this should not hang
// this should not hang
// this should execute
// this should NOT execute
// this should NOT execute
// this should execute
// this should execute
// this should NOT execute
// this should NOT execute,
// this should execute
// this should NOT execute
// this should execute
// should throw 42
// this should NOT execute
// this should NOT execute
// this should execute
// this should NOT execute
// this should execute
// Cancel t1 now that t2 is guaranteed canceled with an exception
// Observe the exceptions from t5, t6 and t7
// A task that participates in a 'when all' operation is canceled and then throws an exception. Verify that
// value and task based continuations of the when all task see the exception.
// A task that participates in a 'when all' operation throws an exception, but a continuation of the when all
// task is canceled before this point. Ensure that continuation does not get the exception but others do.
//
// operator&& with differing tokens:
//
// CodePlex 292
// This test is needed to disable an optimizer dead-code check that
// winds up generating errors in VS 2010.
// This test is needed to disable an optimizer dead-code check that
// winds up generating errors in VS 2010.
// This test is needed to disable an optimizer dead-code check that
// winds up generating errors in VS 2010.
// This test is needed to disable an optimizer dead-code check that
// winds up generating errors in VS 2010.
// take task<int> in the ctor
// Must unwrap:
// take lambda returning task<int> in the ctor
// Must NOT unwrap:
// Must unwrap:
// take task<void> in the ctor
// Must unwrap:
// take lambda returning task<void> in the ctor
// Must NOT unwrap:
// Must unwrap:
// Must unwrap:
// BUG TFS: 344954
// Commenting this line out makes the program work!
// Create a task that is always cancelled
// Task unwrapping!
// This should not crash
// again, unwrapping in continuation
// this should not crash
// Same for void task
// SUITE(pplxtask_tests)
// namespace PPLX
// namespace functional
// namespace tests
/***
// The task should not have started yet.
// Start the task
// Wait for the lambda to finish running
// Yield.
// Verify that the lambda did run
// Wait for the task.
// Start the task
// Wait for the lambda to finish running
// Yield.
// Verify that the lambda did run
// Wait for the task.
// TFS # 521911
// 2 continuations to be scheduled on the scheduler.
// Note that task "t" is not scheduled.
// Ensure that exceptions thrown from user lambda
// are indeed propagated and do not escape out of
// the task.
// Ensure that we do not inline the work on this thread
// Wait should succeed as the event was set above
// wait should succeed as this is manual reset
// wait should fail as the event is reset (not set)
// SUITE(pplx_op_tests)
// namespace pplx_tests
// namespace functional
// namespace tests
/***
// Dev12 doesn't have an in-box ambient scheduler, since all tasks execute on ConcRT.
// Therefore, we need to provide one. A scheduler that directly executes a functor given to it is
// a simple and valid implementation of a PPL scheduler
// run on sched
// run on sched
// inherit sched
// sched1
// sched2
// inherit sched2
// Does not run on the scheduler - it should run inline
// run on sched
// Does not run on the scheduler - it should run inline
// run on sched2
// Does not run on the scheduler - it should run inline
// run on sched2 (inherits from the when_all task
// Same as the above test but use task<int> to instatinate those templates
// Does not run on the scheduler - it should run inline
// run on sched2 (inherits from the when_all task
// Same as the above test but use multiple when_all
// Does not run on the scheduler - it should run inline
// run on default scheduler as the operator && breaks the chain of inheritance
// Runs inline
// Does not run on the scheduler - it should run inline
// run on sched2
// Do a whenall to wait for all the tasks
// Does not run on the scheduler - it should run inline
// run on sched2 (inherits from the when_all task
// Do a whenall to wait for all the tasks
// Same as whenany_options_test1 except that we instantiate a different set of template functions
// Does not run on the scheduler - it should run inline
// run on sched2 (inherits from the when_all task
// Do a whenall to wait for all the tasks
// There is nothing to execute
// runs on sched (1)
// runs on sched (2)
// use default scheduler
// (1)
// (2)
// use default scheduler
// custom scheduler (1)
// We are on the default scheduler
// run on custom scheduler (2)
// SUITE(pplx_task_options_tests)
// namespace PPLX
// namespace functional
// namespace tests
/***
// stdafx.cpp :
// Include the standard header and generate the precompiled header.
/****************************** Module Header ******************************\
//code.msdn.microsoft.com/windowsapps/CppSparseFile-7f28156b
//www.microsoft.com/opensource/licenses.mspx#Ms-PL.
/*!
/*!
// Open the file for read
// Get file information
/*!
//msdn.microsoft.com/en-us/library/aa365276.aspx
// Retrieves the size of the specified file, in bytes. The size includes
// both allocated ranges and sparse ranges.
// Retrieves the file's actual size on disk, in bytes. The size does not
// include the sparse ranges.
// Print the result
/*!
// Create a normal file
// Use the DeviceIoControl function with the FSCTL_SET_SPARSE control
// code to mark the file as sparse. If you don't mark the file as sparse,
// the FSCTL_SET_ZERO_DATA control code will actually write zero bytes to
// the file instead of marking the region as sparse zero area.
/*!
// Specify the starting and the ending address (not the size) of the
// sparse zero block
// Mark the range as sparse zero block
/*!
// Open the file for read
// Range to be examined (the whole file)
// Allocated areas info
// ERROR_MORE_DATA is the only error that is normal
// Calculate the number of records returned
// Print each allocated range
// Set starting address and size for the next query
/***
// Used to prepare data for read tests
//
// The following two functions will help mask the differences between non-WinRT environments and
// WinRT: on the latter, a file path is typically not used to open files. Rather, a UI element is used
// to get a 'StorageFile' reference and you go from there. However, to test the library properly,
// we need to get a StorageFile reference somehow, and one way to do that is to create all the files
// used in testing in the Documents folder.
//
// Because of '_Prot' in WinRT builds.
// The create_system_error API expects a WIN32 error code NOT an HRESULT.
// Some other unexpected error code was encountered, fail immediately.
// Throw statement is still included after because compiler warns about not
// all paths returning a value.
// Test using single-byte strings
// Test that seeking works.
// Test that seeking works.
// Read a character asynchronously to get the buffer primed.
// Test that seeking works.
// Test that seeking works.
// In order to get the implementation to buffer reads, we have to open the file
// with protection against sharing.
// Test that seeking works.
// In order to get the implementation to buffer reads, we have to open the file
// with protection against sharing.
// Test that seeking works when the file is larger than the internal buffer size.
// In order to get the implementation to buffer reads, we have to open the file
// with protection against sharing.
// Test that we can seek to a position near the end of the initial buffer,
// read a chunk spanning the end of the buffer, and get a correct outcome.
// In order to get the implementation to buffer reads, we have to open the file
// with protection against sharing.
// reads 'a'
// reads 'bcd'. File contains the org string though!!!
// reads 'efg'. File contains org string 'abcdef..'.
// Create a file with one byte.
// Try to read from file with a 2 byte character.
// since casablanca does not use sparse file apis we're not doing the reverse test (write one byte at 4Gb and verify
// with std apis) because the file created would be too big
// Create a file with one byte.
// create a sparse file with sparse file apis
// write 1 byte
/*4GB*/, NULL, FILE_END);
// read the file with casablanca streams
// write using casablanca streams
// verify with std streams
// write with std stream
// Create a file with one byte.
// verify with casablanca streams
// SUITE(file_buffer_tests)
// namespace streams
// namespace functional
// namespace tests
/***
// Look for UTF-8 BOM
// SUITE(streams_fuzz_tests)
// namespace streams
// namespace functional
// namespace tests
/***
// Used to prepare data for file-stream read tests
// On WinRT, we must compensate for the fact that we will be accessing files in the
// Documents folder
// Disabling warning in test because we check for nullptr.
//
// The following functions will help mask the differences between non-WinRT environments and
// WinRT: on the latter, a file path is typically not used to open files. Rather, a UI element is used
// to get a 'StorageFile' reference and you go from there. However, to test the library properly,
// we need to get a StorageFile reference somehow, and one way to do that is to create all the files
// used in testing in the Documents folder.
//
// Because of '_Prot' in WinRT builds.
// Tests using memory stream buffers.
// Closing again should not throw.
// There's no newline int the input.
// There's no newline int the input.
// There's no newline in the input.
// There's no newline in the input.
// There's one newline in the input.
// There's one newline in the input.
// There's one newline in the input.
// There's one newline in the input.
// There's no newline in the input.
// There's one delimiter in the input.
// Create a really large (200KB) stream and read into a stream buffer.
// It should not take a long time to do this test.
// There's no newline in the input.
// There's no newline in the input.
// This should not throw
// Create a really large (100KB) stream and read into a stream buffer.
// It should not take a long time to do this test.
// Read a file to end with is_eof tests.
// Async Read a file to end with is_eof tests.
// workaround VC10 's bug.
// There's no newline in the input.
// The read_to_delim() should have flushed, so we should be getting what's there,
// less than we asked for.
// There's no newline in the input.
// The read_line() should have flushed, so we should be getting what's there,
// less than we asked for.
// There's no newline in the input.
// The read_to_end() should have flushed, so we should be getting what's there,
// less than we asked for.
// On Linux, this becomes the exact copy of istream_extract_string1, hence disabled
// On Linux, this becomes the exact copy of istream_extract_string2, hence disabled
// Make sure parsing consumes just the right amount of characters.
// Make sure parsing consumes just the right amount of characters.
// http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/
// two numbers merged after comma
// two numbers merged in exponent
// two numbers merged in exponent
// a big number
// numbers with exponent
// a number ending with a dot
// Checking positive and negative zero's by dividing 1 with it. They should result in positive and negative
// infinity.
// there are 2 spaces here
// The bool operator shall not throw
// All operations should throw
// The destructor shall not throw
// SUITE(istream_tests)
// namespace streams
// namespace functional
// namespace tests
/***
// Verify putc synchronously
// Verify putc async
// verify putc after close
// Verify putc synchronously
// Verify putc async
// verify putc after close
// Verify putc synchronously
// Verify putc async
// verify putc after close
// verify putn after close
// verify putn after close
// verify putn_nocopy after close
// Allocate space for 10 chars
// commit 2
// Allocate space for 10 chars
// commit 2
// Allocate space for 10 chars
// commit 2
// current should be at the begining
// Calling getc again should return the same character (getc do not advance read head)
// getc should return eof after close
// Calling getc again should return the same character (getc do not advance read head)
// sgetc should return eof after close
// Calling bumpc again should return the next character
// Read till eof
// operation should return eof after close
// Calling sbumpc again should return the next character
// Read till eof
// operation should return eof after close
// Calling getc should return the same contents as before.
// operation should return eof after close
// ungetc from the begining should return eof
// ungetc could be unsupported!
// We shouldn't be able to read any more
// We shouldn't be able to read any more
// This shouldn't crash
// current should be at the begining
// There should be nothing to read
// Close the write head
// The buffer should still be open for read
// Closing the write head again should not throw
// The read head should still be open
// Close the read head
// Closing the read head again should not throw
// The buffer should now be closed
// Write 4 characters
// Try to read 8 characters - this should block
// Close the write head
// The buffer should still be open for read
// The read head should still be open
// Closing the write head should trigger the completion of the read request
// Close the read head
// The buffer should now be closed
// Write 4 characters
// Try to read 8 characters - this should block
// Close the read head
// The read task should not be completed
// Close the write head
// Closing the write head should trigger the completion of the read request
// The buffer should now be closed
// Close the read and write head in parallel
// Close the read head
// Closing the read head again should not throw
// Close the write head
// Closing the write head again should not throw
// The buffer should now be closed
// stream large amounts of data
// If the stream stores all the data then we will run out of VA space!
// 4 MB
// stream 4 GB
// Fill some random positions in the buffer
// overwrite the values in ptr
// ISequentialStream implementation
// The read happens before the write.
// We may or may not read data from both writes here. It depends on the
// stream in use. Both are correct behaviors.
// The read happens before the write.
// Different results depending on stream implementation. Both correct.
// The read happens before the write.
// We close the stream buffer before enough bytes have been written.
// The read happens before the write.
// We close the stream buffer before enough bytes have been written.
// Make sure that the first read results in fewer bytes than requested
// and that the second read returns -1.
// The read end should still be open
// close the read end
// Now the buffer should no longer be open
// The read happens before the write.
// The read happens after the write.
// The read happens before the write.
// The read happens after the write.
// The read happens before the write.
// The read happens after the write.
// Even though we have closed for read, we should
// still be able to write.
// test byte stream
// Check that the exception is generated by the 'get(),' not the operation.
// Check that the exception is generated by the 'get(),' not the operation.
// Check that the exception is generated by the 'get(),' not the operation.
// Check that the exception is generated by the 'get(),' not the operation.
// This test passes if it does not generate an exception.
// namespace streams
// namespace functional
// namespace tests
/***
//
// The following two functions will help mask the differences between non-WinRT environments and
// WinRT: on the latter, a file path is typically not used to open files. Rather, a UI element is used
// to get a 'StorageFile' reference and you go from there. However, to test the library properly,
// we need to get a StorageFile reference somehow, and one way to do that is to create all the files
// used in testing in the Documents folder.
//
// Because of '_Prot' in WinRT builds.
// This will fail
// This return statment will prevent the test from hanging,
// cause if the numbers are merged there will be less than 100 numbers,
// and reading from the file will block
// SUITE(ostream_tests)
// namespace streams
// namespace functional
// namespace tests
/***
// stdafx.cpp :
// Include the standard header and generate the precompiled header.
/***
// Used to prepare data for read tests
//
// The following functions will help mask the differences between non-WinRT environments and
// WinRT: on the latter, a file path is typically not used to open files. Rather, a UI element is used
// to get a 'StorageFile' reference and you go from there. However, to test the library properly,
// we need to get a StorageFile reference somehow, and one way to do that is to create all the files
// used in testing in the Documents folder.
//
// There's no newline in the input.
// There's one newline in the input.
// There's no newline in the input.
// There's one delimiter in the input.
// There's no newline in the input.
// There's one newline in the input.
// Won't fix bug TFS 639208
// VERIFY_IS_FALSE(is.is_open());
// Try with a read.
// Try with a write.
// There's one newline in the input.
// namespace streams
// namespace functional
// namespace tests
/***
// Take care to make this a non-character!
// Take care to make this a non-character!
// SUITE
// namespace streams
// namespace functional
// namespace tests
/***
//testname.com:81/path?baz"));
//testname.com:81")), a);
//testname.com:81/path?baz"));
//testname.com:81")), a);
// SUITE(accessor_tests)
// namespace uri_tests
// namespace functional
// namespace tests
/***
//testname.com/path?baz");
//testname.com/path/baz?baz")), combined);
//fakeuri.net"));
//testname.com/path1?key1=value2"));
//testname2.com/path2?key2=value3")).query()).to_uri();
//testname.com/path1?key1=value2&key2=value3"), combined.to_string());
//fakeuri.org/?key=value"));
//testname.com/path1?key1=value2"));
//testname2.com/path2?key2=value3")).to_uri();
//testname.com/path1/path2?key1=value2&key2=value3"), combined.to_string());
//myhost.com"));
// SUITE(combining_tests)
// namespace uri_tests
// namespace functional
// namespace tests
/***
//steve:@testname.com:81/bleh%?qstring#goo")));
//testname.com:81/bleh%?qstring#goo")));
//testname.com:81/bleh%?qstring#goo")));
//st:pass@localhost:456/path1?qstring#goo"));
//localhost:456/path1?qstring#goo"));
//localhost:456/path?qstring#goo"));
// Tests invalid URI being passed in constructor.
//localhost:345/")), uri_exception);
//localhost:345/")), uri_exception);
//localhost:345/\"")), uri_exception);
//localhost:345/path?\"")), uri_exception);
//local\"host:345/")), uri_exception);
// Tests a variety of different URIs using the examples in RFC 2732
// The URI parser will make characters lower case
//[FEDC:BA98:7654:3210:FEDC:BA98:7654:3210]:80/index.html"));
//[1080:0:0:0:8:800:200C:417A]/index.html"));
//[3ffe:2a00:100:7031::1]"));
//[::192.9.5.5]/ipng"));
//[1080::8:800:200C:417A]/foo"));
//[::FFFF:129.144.52.38]:80/index.html"));
//[2010:836B:4179::836B:4179]"));
// Tests a variety of different URIs using the examples in RFC 3986.
//ftp.is.co.za/rfc/rfc1808.txt"));
// TFS #371892
// uri ldap(U("ldap://[2001:db8::7]/?c=GB#objectClass?one"));
// VERIFY_ARE_EQUAL(U("ldap"), ldap.scheme());
// VERIFY_ARE_EQUAL(U(""), ldap.user_info());
// VERIFY_ARE_EQUAL(U("2001:db8::7"), ldap.host());
// VERIFY_ARE_EQUAL(0, ldap.port());
// VERIFY_ARE_EQUAL(U("/"), ldap.path());
// VERIFY_ARE_EQUAL(U("c=GB"), ldap.query());
// VERIFY_ARE_EQUAL(U("objectClass?one"), ldap.fragment());
// We don't support anything scheme specific like in C# so
// these common ones don't have a great experience yet.
//192.0.2.16:80/"));
//johndoe:testname@ftp.is.co.za/rfc/rfc1808.txt"));
// Test query component can be separated with '&' or ';'.
//localhost/path1?key1=val1;key2=val2"));
// SUITE(constructor_tests)
// namespace uri_tests
// namespace functional
// namespace tests
/***
//testname.com/%%?qstring"));
//testname.com/%25%25?qstring"));
//testname.com/%%?qstring"));
//testname.com/%25%25?qstring"));
// SUITE(conversions_tests)
// namespace uri_tests
// namespace functional
// namespace tests
/***
//first.second/")).is_authority());
//first.second")).is_authority());
//first.second/b")).is_authority());
//first.second?qstring")).is_authority());
//first.second#third")).is_authority());
//first.second/")).has_same_authority(uri(U("http://first.second/path"))));
//first.second:83/")).has_same_authority(uri(U("http://first.second:83/path:83"))));
//first.second:82/")).has_same_authority(uri(U("http://first.second/path"))));
//first.second:82/")).has_same_authority(uri(U("http://first.second/path"))));
//path.:82/")).has_same_authority(uri(U("http://first.second/path"))));
//first.second/")).has_same_authority(uri()));
//first.second/"))));
//*/")).is_host_wildcard());
/*/")).is_host_wildcard());
//+/?qstring")).is_host_wildcard());
//bleh/?qstring")).is_host_wildcard());
//+*/?qstring")).is_host_wildcard());
//localhost/")).is_host_loopback());
//LoCALHoST/")).is_host_loopback());
//127")).is_host_loopback());
//bleh/?qstring")).is_host_loopback());
//+*/?qstring")).is_host_loopback());
//127.0.0.1/")).is_host_loopback());
//127.155.0.1/")).is_host_loopback());
//128.0.0.1/")).is_host_loopback());
//bleh/?qstring")).is_host_portable());
//localhost/")).is_host_portable());
//+/?qstring")).is_host_portable());
//bleh/?qstring")).is_port_default());
//localhost:0/")).is_port_default());
//+:85/?qstring")).is_port_default());
//bleh/?qstring")).is_path_empty());
//localhost:0")).is_path_empty());
//+:85/path/?qstring")).is_path_empty());
// SUITE(diagnostic_tests)
// namespace uri_tests
// namespace functional
// namespace tests
/***
//path%name/%#!%"));
//path%25name/%25#!%25"), result);
// Tests trying to encode empty strings.
// utility::string_t
// std::wstring
// Tests encoding in various components of the URI.
// only encodes characters that aren't in the unreserved and reserved set.
// utility::string_t
//^localhost:80/path ?^one=two# frag"));
//%5Elocalhost:80/path%20?%5Eone=two#%20frag"), result);
// Tests encoding individual components of a URI.
// encodes all characters not in the unreserved set.
// utility::string_t
// Tests trying to decode a string that doesn't have 2 hex digits after %
// Tests making sure '+' is encoded even though nonstandard, so it doesn't
// get mistaken later by some implementations as a space.
// SUITE(encoding_tests)
// namespace uri_tests
// namespace functional
// namespace tests
/***
//localhost:80/path1"));
//localhost:80/path1"));
//localhost:80"));
//localhost:80/path%201"));
//localhost:80/pat%68a1"));
//localhost:80/patha1"));
//localhost:80/patha1?name=first#t%65st"));
//localhost:80/patha1?name=first#test"));
//localhost:80/path1")), uri(U("https://localhost:80/path1")));
//localhost:80/path1")), uri(U("http://localhost2:80/path1")));
//localhost:80/path1")), uri(U("http://localhost:81/path1")));
//localhost:80/path1")), uri(U("http://localhost:80/path2")));
//localhost:80/path1?key=value")),
//localhost:80/path1?key=value2")));
//localhost:80/path1?key=value#nose")),
//localhost:80/path1?key=value#nose1")));
//Path")), uri(U("hTtp://pAth")));
//path")), uri());
//path")));
//path1")), uri(U("http://path2")));
// SUITE(operator_tests)
// namespace uri_tests
// namespace functional
// namespace tests
// testing resolution against examples from Section 5.4 https://tools.ietf.org/html/rfc3986#section-5.4
// 5.4.1. Normal Examples https://tools.ietf.org/html/rfc3986#section-5.4.1
//a/b/c/d;p?q");
//a/b/c/g"));
//a/b/c/g"));
//a/b/c/g/"));
//a/g"));
//g")), U("http://g"));
//a/b/c/d;p?y"));
//a/b/c/g?y"));
//a/b/c/d;p?q#s"));
//a/b/c/g#s"));
//a/b/c/g?y#s"));
//a/b/c/;x"));
//a/b/c/g;x"));
//a/b/c/g;x?y#s"));
//a/b/c/d;p?q"));
//a/b/c/"));
//a/b/c/"));
//a/b/"));
//a/b/"));
//a/b/g"));
//a/"));
//a/"));
//a/g"));
// 5.4.2. Abnormal Examples https://tools.ietf.org/html/rfc3986#section-5.4.2
//a/b/c/d;p?q");
//a/g"));
//a/g"));
//a/g"));
//a/g"));
//a/b/c/g."));
//a/b/c/.g"));
//a/b/c/g.."));
//a/b/c/..g"));
//a/b/g"));
//a/b/c/g/"));
//a/b/c/g/h"));
//a/b/c/h"));
//a/b/c/g;x=1/y"));
//a/b/c/y"));
//a/b/c/g?y/./x"));
//a/b/c/g?y/../x"));
//a/b/c/g#s/./x"));
//a/b/c/g#s/../x"));
// SUITE(resolve_uri_tests)
// namespace uri_tests
// namespace functional
// namespace tests
/***
// Separating with '&'
// Separating with ';'
// Separating with '&'
// Separating with ';'
// Separating with '&'
// Separating with ';'
// SUITE(splitting_tests)
// namespace uri_tests
// namespace functional
// namespace tests
/***
// stdafx.cpp :
// Include the standard header and generate the precompiled header.
/***
// Helper functions to verify components of a builder.
// Default constructor
// scheme, user_info, host, port
//steve:pass@localhost:44/Yeshere888"));
// utility::string_t
//steve:pass@localhost:44/Yeshere888?abc:123&abc2:456#nose"));
// copy constructor
// move constructor
// assignment operator
// move assignment operator
// true
//localhost:4567/"));
// false
// true
//localhost:4567/"));
// false
//steve:temp@localhost:4556/"));
// to_string
// to_string
// to uri
// to encoded string
//steve:temp@localhost:4556/path%20with%20space"), with_space.to_string());
// empty uri builder path
// empty append path
// uri builder with slash
// both with slash
// both without slash
// encoding
// self references
// empty uri builder path
// empty append path
// uri builder with slash
///path2"), builder.path());
// leading slash (should result in "//")
///path2//path3"), builder.path());
// trailing slash
///path2//path3/path4//path5"), builder.path());
// encoding
// self references
//example"), builder.path());
///example/"), builder.path());
// empty uri builder query
// empty append query
// uri builder with ampersand
// both with ampersand
// both without ampersand
// number query
// string query
// key and value separate with '=', '&', and ';'
// self references
// with just path
// with just query
// with just fragment
// with all
//uribuilder.com/"));
// try with encoded_string
// Check that ASCII characters that are invalid in a host name
// do not get percent-encoded.
//myhost.com/path1"));
//myhost.com/path1/path2"));
//invaliduri.com"));
// Silently pass if locale isn't installed on machine.
//127.0.0.1:34568/")); }
// SUITE(uri_builder_tests)
// namespace uri_tests
// namespace functional
// namespace tests
/***
// Note: base64 works by encoding any 3 bytes as a four-byte string. Each triple is encoded independently of
// previous and subsequent triples. If, for a given set of input bytes, the number is not an even multiple of 3,
// the remaining 1 or two bytes are encoded and padded using '=' characters at the end. The encoding format is
// defined by IETF RFC 4648. Such padding is only allowed at the end of a encoded string, which makes it impossible
// to generally concatenate encoded strings and wind up with a string that is a valid base64 encoding.
//
// Since each triple of bytes is independent of others, we don't have to test particularly large sets if input data,
// validating that the algorithm can process at least two triples should be sufficient.
//
// These tests are what base64 RFC 4648 proposes.
// These tests are what base64 RFC 4648 proposes.
// Check '/' encoding
// Check '+' encoding
// Tests beyond what the RFC recommends.
// Check '/' decoding
// Check '+' decoding
// Check '/' decoding
// Check '+' decoding
// Check the whole base64 alphabet
// These tests are for input that should be disallowed by a very strict decoder, but
// the available APIs on Windows accept them, as does glib, which is used on Linux.
// Invalid character before padding, unused ones.
// CRLF in the middle.
// Not the right length.
// Characters not in the alphabet
// Too much padding at the end.
// Valid strings, concatenated
// SUITE(base64)
// namespace utils_tests
// namespace functional
// namespace tests
/***
// This is by no means a comprehensive test suite for the datetime functionality.
// It's a response to a particular bug and should be amended over time.
// ISO 8601
// RFC 1123
// ISO 8601
// RFC 1123
// ISO 8601
// ISO 8601
// Preserve all 7 digits after the comma:
// lose the last '000'
// lose the last '999' without rounding up
// leading 0-s after the comma, tricky to parse correctly
// another leading 0 test
// this is going to be truncated
// Only one digit after the dot
// 2019-04-22T23:52:44 is a Monday
// NT epoch adjustment
// non leap year allows feb 28
// leap year allows feb 29
// bad letters in each place
// truncation
// wrong day
// year too small
// month bad
// day too small
// day too big
// day too big for feb
// day too big for feb (non-leap year)
// other months
// hour too big
// minute too big
// second too big
// underflow
// bad tz
// bad tzoffsets
// zero month day
// boundary cases:
// epoch
// INT_MAX - 1
// INT_MAX after subtacting 1
// leap seconds
// jan
// non leap year allows feb 28
// leap year allows feb 29
// mar
// apr
// may
// jun
// jul
// aug
// sep
// oct
// nov
// dec
// No digits after the dot, or non-digits. This is not a valid input, but we should not choke on it,
// Simply ignore the bad fraction
// Various unsupported cases. In all cases, we have produce an empty date time
// empty
// too short
// no trailing Z
// not a valid date
// any non digits or valid separators
// _XPLATSTR("1971-01-01a00:00:00Z"), parsed as complete date
// "1971-01-01T00:00:00a", accepted as per invalid_no_trailing_timezone above
// truncation
// _XPLATSTR("1970-01-01"), complete date
// _XPLATSTR("1970-01-01T00:00:00"), // accepted as invalid timezone above
// year too small
// month too small
// month too big
// day too small
// day too big
// day too big for feb
// day too big for feb (non-leap year)
// other months
// hour too big
// minute too big
// second too big
// underflow
// time zone underflow
// _XPLATSTR("1970-01-01T00:00:00.Z"), // accepted as invalid timezone above
// bad tzoffsets
// zero month day
// SUITE(datetime)
// namespace utils_tests
// namespace functional
// namespace tests
/***
// namespace utils_tests
// namespace functional
// namespace tests
/***
// Generate 100 nonces and check each is unique.
// SUITE(nonce_generator_tests)
// namespace utils_tests
// namespace functional
// namespace tests
/***
// stdafx.cpp :
// Include the standard header and generate the precompiled header.
/***
// encodes to single byte character
// last ASCII character
// encodes to 2 byte character
// encodes to 3 byte character
// surrogate pair - encodes to 4 byte character
// U+10000
// U+12345
// U+10FFFF
// surrogate pair - covering regression bug where 0x10000 was accidentally bitwise OR'ed instead of added.
// single byte character
// last ASCII character
// null byte
// 2 byte character
// U+80
// 11010000
// 10000000
// U+7FF
// 11011111
// 10111111
// 3 byte character
// U+800
// 11101000
// 10000000
// 10000000
// U+FFFF
// 11101111
// 10111111
// 10111111
// 4 byte character
// U+10000
// 11110100
// 10000000
// 10000000
// 10000000
// U+10FFFF
// 11110100
// 10001111
// 10111111
// 10111111
// 1 byte character followed by 4 byte character
// 00110011
// U+10000
// 11110100
// 10000000
// 10000000
// 10000000
// U+10FFFF
// 11110100
// 10001111
// 10111111
// 10111111
// high surrogate with missing low surrogate.
// high surrogate with no more characters
// missing second continuation byte
// 11001111
// missing third continuation byte
// 11100110
// 10001101
// missing fourth continuation byte
// 11110000
// 10101101
// 10011101
// continuation byte missing leading 10xxxxxx
// 11100110
// 00001101
// 11100110
// 11001101
// invalid for a first character to start with 1xxxxxxx
// 10000000
// 10000000
// 10111111
// 10000000
// Silently pass if locale isn't installed on machine.
// Silently pass if locale isn't installed on machine.
// Ensure the error message string returned by windows_category doesn't contain trailing zeros.
// _WIN32
// namespace utils_tests
// namespace functional
// namespace tests
/***
// SUITE(win32_encryption)
// defined(_WIN32) && _WIN32_WINNT >= _WIN32_WINNT_VISTA && !defined(__cplusplus_winrt)
// namespace utils_tests
// namespace functional
// namespace tests
/***
// Authorization not implemented in non WinRT websocket_client yet - CodePlex 254
// No credentials -> challenge the request
// Unauthorized.
// User name/password did not match: Forbidden - auth failure.
// User name and passwords match. Successful auth.
// connect without credentials, when the server expects credentials
// Connect with credentials
// helper function to check if failure is due to timeout.
//echo.websocket.org/")).wait();
// Since this test depends on an outside server sometimes it sporadically can fail due to timeouts
// especially on our build machines.
// Since this test depends on an outside server sometimes it sporadically can fail due to timeouts
// especially on our build machines.
//self-signed.badssl.com/")); }
//wrong.host.badssl.com/")); }
//expired.badssl.com/")); }
// SUITE(authentication_tests)
// namespace client
// namespace websocket
// namespace functional
// namespace tests
/***
// Helper function verifies that when constructing a websocket_client with invalid
// URI std::invalid_argument is thrown.
// expected
//localhost:34567/"));
// Invalid scheme.
// empty host.
//:34567/"));
// Verify that we can read the config from the websocket_client
// Verify that we can read the config from the websocket_callback_client
// Verify that we can get the baseuri from websocket_client connect.
// Move constructor
// Handler to verify the message sent by the client.
// Move assignment
// Handler to verify the message sent by the client.
// Handshake request will be completed only if header match succeeds.
// Else fail the handshake, websocket client connect will fail in this case.
// Handshake request will be completed only if header match succeeds.
// Else fail the handshake, websocket client connect will fail in this case.
// SUITE(client_construction)
// namespace client
// namespace websocket
// namespace functional
// namespace tests
/***
// Test close websocket connection: client sends an empty close and server responds with close frame
// Test close websocket connection: client sends a close with reason and server responds with close frame
// Server sends a close frame (server initiated close)
// Send close frame from server
// Test close websocket connection with callback client: client sends an empty close and server responds with close
// frame
// verify it is ok not to set close handler
// Test close websocket connection: client sends a close with reason and server responds with close frame
// Server sends a close frame (server initiated close)
// Send close frame from server
// make sure it only called once.
// SUITE(close_tests)
// namespace client
// namespace websocket
// namespace functional
// namespace tests
/***
// Send before connecting
// Server does not exist
// Send after close
// CodePlex 319 fails on VS2013.
// Send after close for callback client
// Receive after close
// Start receive task after client has closed
// Start the receive task after server has sent a close frame
// Send close frame from server
// 100 ms should be plenty for local loopback
// Destroy the client without closing it explicitly
// Destroy the callback client without closing it explicitly
// test won't finish if we can't release client properly
// connect fails while user is waiting on receive
//localhost:9981/ws")).get(), websocket_exception);
// SUITE(error_tests)
// namespace client
// namespace websocket
// namespace functional
// namespace tests
/***
// Can't specify a proxy with WinRT implementation.
//netproxy.redmond.corp.microsoft.com"));
// relax, this is not my real password
//echo.websocket.org/")).wait();
// The above "netproxy.redmond.corp.microsoft.com" is an internal site not generally accessible.
// This will cause a failure to resolve the URL.
// This is ok.
// Timer expired case, since this is an outside test don't fail due to timing out.
// SUITE(proxy_tests)
// namespace client
// namespace websocket
// namespace functional
// namespace tests
/***
// Receive text message (no fragmentation)
// Receive text message (no fragmentation)
// Test the stream interface to read data
// Receive binary message (no fragmentation)
// Server sends text message fragmented in 2 fragments
// Server sends message of length 0
// Receive UTF-8 string with special characters
// Receive multiple messages
// Start the receive task after the server has sent a message
// We dont have a way of knowing if the message has been received by our client.
// Hence Sleep for 100 msecs and then initiate the receive
// Start task to receive text message before connecting.
// Connect after the client is waiting on a receive task.
// Now send the message from the server
// Receive message using callback APIs
// make sure client works fine without setting receive handler
// set receive handler
// SUITE(receive_msg_tests)
// namespace client
// namespace websocket
// namespace functional
// namespace tests
/***
// On WinRT, we must compensate for the fact that we will be accessing files in the
// Documents folder
// Used to prepare data for stream tests
// Handler to verify the message sent by the client.
// Handler to verify the message sent by the client.
// Handler to verify the message sent by the client.
// Send message from input stream -> data is already populated in the stream buffer
// Send text message (no fragmentation)
// Send text message with websocket_callback_client
// Send text message (no fragmentation)
// Test the stream interface to send data
// Send Binary message (no fragmentation)
// Send empty text message
// WinRT client does not handle empty messages. Verify websocket_exception is thrown.
// Send multiple text messages
// Send multiple text messages
// Send multiple text messages from a stream
// Send multiple text messages from a file stream
// send uses stream::acquire API, acquire will fail for file streams.
// Send multiple text messages from a container stream, where container stream has more data than what we want to
// send in a single message
// Send multiple text messages from a producer consumer stream, where stream initially has less data than what we
// want to send in a single message Write data to the buffer after initiating the send, send should succeed.
// Send multiple text messages from a container stream, where stream has less data than what we want to send in a
// single message Since container stream does not support in | out simultaneously, websocket send_msg will fail to
// read the required number of bytes and throws an exception.
// Send multiple binary messages from the same stream
// Send text message followed by binary message
// Send a multi byte UTF-8 text message
// Send a streamed text message without specifying length
// Handler to verify the message sent by the client.
// Send a streamed binary message without specifying length
// Handler to verify the message sent by the client.
// Send a ping message to the server
// Send a ping message to the server with a body
// Send an unsolicited pong message to the server
// Send an unsolicited pong message to the server with a body
// Send an unsolicited pong message to the server with websocket_callback_client
// SUITE(send_msg_tests)
// namespace client
// namespace websocket
// namespace functional
// namespace tests
/***
// stdafx.cpp :
// Include the standard header and generate the precompiled header.
/***
// stdafx.cpp :
// Include the standard header and generate the precompiled header.
/***
// generated too late for disable to be effective inside push/pop
/* _WIN32 */
// In the future this should be configurable through option in test server.
// Websocketpp typedefs
/// <summary>
/// Implementation of http request from websocket handshake to avoid leaking
/// details about websocketpp into test utilities.
/// </summary>
// Also need to indicate the connection is rejected if non 200 status code.
// Websocketspp does not currently support explicit fragmentation. We should not get here.
// Ignore the error code.
// Once the WebSocket object has been initialized,
// the below event wil be used to signal that the server has been initialized.
// The server can now send messages to the client.
// Wait for the websocket server to be initialized.
// WebSocket::FRAME_FLAG_FIN | WebSocket::FRAME_OP_TEXT;
// WebSocket::FRAME_FLAG_FIN | WebSocket::FRAME_OP_BINARY;
// WebSocket::FRAME_OP_CLOSE;
// std::cerr << "Sending message from server: " << strmsg << std::endl;
// namespace utilities
// namespace websocket
// namespace functional
// namespace tests
